The objects keeps track of some kind of information (instance variables), can be interacted with only in specified ways (interface), have setters (switch/button) and a getters (lights, your eyes). So, we are talking about objects that have the ability to do things, have interfaces by which you can get them to do them, and don't show you how they work inside. Then you have a nice segue into constructing an Object together. What nice about using objects as an analogy for Objects is that, well, that's what they were named after, so that's really the philosophical conception from the start. 

If I feel a course floundering, I also have been known to ask for feedback mid-semester in order to diagnose the problem and correct course. I have received very thoughtful (and sometimes powerful) responses to these questions over the years. 

In my class, the only rules I set are that kids may not give code to each other, either directly or indirectly. I also set a "rule of thumb" that if student A needs help from student B on a portion of a lab, student B must have finished that portion, and may look at student A's (relevant) work, but that A may not look at B's work. Part of the logic here is that I already consider labs to be "suspect" with regards to plagiarism, so the giant brunt of their grades come from tests and quizzes. The labs, then, are primarily a tool that the kids should use to prepare for the assessment. I explain this to them often, and point out that not fully understanding their own lab is a great way to shoot themselves in the foot. 

I would try to focus in on the kinds of errors that beginner programmers get stuck on, to imitate as closely as possible the kind of situation that they would want a debugger for. So, I might code this method, which contains exactly the sort of subtle mistake 101 students regularly make, right in front of them: 

Which got me thinking that I really did want to expand my craft, and that a book would be just the thing. In my searching, I of course found Guzdial's Learning-centered Design (which BennetBrown mentioned), but I also found this: Guide to Teaching Computer Science: An Activity-Based Approach. However, I can find precious little detail about either volume. Are there significant differences between the two that I should take into account when selecting one of them? EDIT: I also just found Pedagogical Patterns, which does not claim to be a CS book, but its primary two authors are Computer Science professors so it might also fit into this question. (Also, I believe that these are the only two books like this, though if I have missed one somewhere, leave a comment and I will integrate it into the question.) 

I am almost painfully aware of the importance of examinations as a way to create emotionally important memory-recall events, and therefore their vital importance in learning itself. Within the examination itself, however, I usually place the questions in an order that optimizes page-layout; I want to give the students enough space, but otherwise use the fewest pages possible. However, it occurs to me that this may not be optimal. Is there any research (or does anyone have experience) that supports the idea that the order of question on an examination can impact pedagogic efficacy? 

Regarding architecture specifically, I don't see a tremendous benefit in high-school level programming classes. However, at just one level or so of higher abstraction, discussing the principles of memory management as it applies to programs they write (such as stack and heap operation, how function calls are handled, etc) can make a big difference. It is very hard to describe why tail recursion is important, or the operational output of in Java, or even what the code below accomplishes without discussing some lower level operation of the computer: 

This is really a separate approach from my first answer, which has received some push-back. It's worth noting that many of these loners are simply students who are substantially ahead of the curve. One way to really want to engage such students in pair programming is to pair them with each other. This will create something of a Dream Team. Give them the assignment, but tell them that their goal is to produce the coolest thing that they can that utilizes the concepts that the lab is developing within the time before the lab is due. Tell them you're excited to see what they can come up with, that you'll allow them to present their work to the group at large, and that if it's a cool enough idea, you may use it as a launching point for a future lab for later generations of students. As an aside, there is no reason to restrict this approach to the high-fliers. It can be reasonable to allow students to propose modifications to the labs if these modifications excite the students. It involves more work on your end, but you'll get better output and (more importantly) more engagement and buy-in from your students overall. 

I've always released a number of test cases for the purposes of clarity. I do have to double- and triple-check that my unpublished test cases are nevertheless unambiguously specified in the documentation I provided. However, I am a computer science teacher, not a mystery novelist. It would never occur to me to deduct points for test cases that are not provided in advance without also telling the student what the test case in question is at the moment of the deduction. That seems plum crazy to me; how would the students learn this way? 

As I indicated in the question, it has been my experience that there are certain kids who never seem to come along. My data is drawn from a rather small group (definitely under 1000 kids learning CS over the course of my career), and @Buffy's idea that these students are satisfying rather than optimizing may well be correct. However, I haven't seen convincing evidence of that. What evidence I do have, unscientific though it may be, is that there are, indeed, students whose brains are simply not wired for this field. It always appears to be the case that, with enormous effort, they can obtain some very basic competencies, but the material does not fit "naturally" into their way of thinking, in much the same way as not everyone can feel certain aspects of musicality. (See beat deafness and the 4% of humanity with congenital amusia.) It is important to note that I am not suggesting that people with such musical disabilities can learn nothing of music; rather, I am suggesting that a very high level of musicality (such as that associated with the professional musician) may never be realistically attainable. It is also worth noting that 4% is not a terribly low number; over the course of a teaching career, one would encounter many students with such handicaps to overcome. Programming requires substantial sequencing ability, a certain intuitive capability to informally understand (and guarantee) post-conditions, and the ability to simultaneously understand multiple layers of abstraction. Within the normal distributions of abilities, therefore, it stands to reason that there will be a (not insubstantial) subset of people who will have enormous difficulties with the topic. And, similar to music, it may not be that they are incapable of learning any particular aspect of programming, but they may never really be able to pull it all together with any sort of facility, no matter how hard they work. 

I actually try to avoid note-taking, because I try to avoid lecturing for long enough that it's worth time for them to take out paper and writing instruments. So there are opportunities for significant note-taking maybe once every three classes. Notes are taken by hand. I just cannot keep everyone on-task while lecturing unless I instruct them to close computers. I give them a structured outlines to fill in for notes, but try to ensure that the outline organizes the content in a different way from the lecture. The goal is to move them from transcribing the words of the lecture to summarizing into their own synopsis, with some original thought about the meaning. 

Convenience Easy integration with GitHub Error highlighting (though I have some issues with this) Ease with packages and project integration 

They should be designing a set of Objects from the ground-up. That could include designing part of the project itself (such as choosing an ecosystem or a sport to simulate) The requirements of the project should be rich enough to support the use of encapsulation, inheritance, and polymorphism. 

Or, how to move that circle along so that it ranges from to (still a circle of size , but it no longer starts at ): 

First, remember that every course should have a through-line - a central story that it tells. This story is what provides coherence to the pieces. If history is part of that central story, then the answer to your question is self-apparent. For instance, the information obviously belongs in a Social History of Computing in Society course. Questions like this arise, however, when the material in question doesn't comfortably nestle inside that core through-line. In those instances, I recommend the following approach: Non-curricular "extras" are wonderful if they substantially enhance or broaden students' perspectives, but don't bog things down too much. So: if it's really valuable, make sure you can keep it short and to the point. The question, then, is whether the cost to the pacing of the class is overridden by the generalized benefit of gaining some context. Since these extras aren't a part of the central story of a class, and aren't cornerstone pieces of the key course goals, they inherently slow down the pacing of the course and muddy that central through-line. If you enter into too many side-paths, the central message of the course can get truly lost, and the whole course will begin to feel rudderless. A few diversions down side-paths can be enriching, but too many destroy the arc of the class. If you're unsure about whether your through-line is being communicated, you can poll students about the purposes of the various exercises and lessons how do they all fit into the bigger picture? If your students seem to know what's going on, you're in good shape. If the results are more mixed, I would spend time re-telling your big story, and steer clear of side pursuits until the central line is firmly reestablished.