Once you've found the minimum and maximum, you can save a little bit of computation by not finding the number of unique values; the number of unique values is greater than one if and only if min < max. Are there no separate "greater than" or "less than" comparators? The 5 in 'one patameter passed' (note: should be 'one parameter passed') and 1 and 10 in 'two patameter passed' look like magic numbers. You should define constants equal to these numbers, or pass them as parameters. You have a lot of repetition; you should consider re-writing it so aren't doing the same thing in different blocks. 

For instance, suppose you have 11239. The last non-nine digit is 3. Add one and get 4. Then replace the 3 and all digits after it with 4, and get 11244. The following code found solutions for 147 out of the 162 target numbers in 86 seconds. Presumably, increasing would get more of them. (and making it less verbose would probably save some time) 

You could also try a regex to create and see whether it's faster. If you want to run this just once per puzzle, you could just iterate through letters, but that likely wouldn't be optimal. 

General tip: if you're doing an if-then with several elif/else clauses, consider whether a dictionary would be simpler. 

You could replace the blocks after the block with a case statement. Using recursion in this case is rather odd. The basic structure of your function is: 

Which method to use depends on the size of the inputs. If you know that each word is at most five letters long, then you have N*M candidates for beginning letters, four more letters to find, and at most eight choices at each letter, so in this case that's an upper bound 9*8^4 = 36864, which is a large number but doable. For a larger board, and longer words, this can easily get unwieldy, though. If the inputs given are representative, then with only four words in the dictionary, the fastest method is to just check each word. So, for instance, for the word "geeks", you would first get a list of places where the letter "g" appears in the boggle, and for each location you would get a list of adjacent "e"'s, and so on. Note that you will have to keep track of what letters you've used in a word; if one of the words in the dictionary were "gig", your program shouldn't use the same "g" twice. As for your code, it doesn't seem to check multiplicities or adjacency, so the following is somewhat moot, but most of your code can be replaced by a single line: 

Generate list of boggle words, and check each one to see whether it's in the dictionary. For each word in the dictionary, see whether it's in the boggle words. Generate boggle words, but stop once you reach something that isn't the beginning of a word (for instance, if an actual human were playing boggle, and they saw ZK, they wouldn't try to find any words that starts with the sequence, because they would know there aren't any such English words.) 

Putting an function inside a list comprehension seems a bit iffy to me, especially since you don't seem to close it anywhere. List comprehensions are generally better than for loops. The name is a bit misleading, as it's the filename, not the file object. So alternative code would be: 

One big area for optimization is your function. First of all, you should keep track of whether you've already checked a number for primality: 

If the number is n nines, then the next number should be n+1 ones Otherwise: a) find the first digit that's smaller than the one before it. If there are no such numbers, use the first digit. b) add one to that digit c)replace every digit after that one with ones. 

EDIT: the above find decreasing numbers with , but it will look at higher numbers first. To get decreasing numbers, I believe this algorithm will work: 

returns the remainder of when divided by 2. Python is not a strongly typed language, so this remainder can be used as a boolean; if there is a remainder, is truthy, and if the remainder is zero, then it is falsy. So you can replace your with . 

If you put it in a Pandas Series, then you can use to get a DataFrame containing the data you want. If you want it as a dictionary of lists, then you can just convert it with 

In English, this is "possibility is the list of all words in dictionary such that all letters in the word are in bString". 

should be moved to right before the elif block that uses it; there's no point calling a function if you don't use it. Also, since there's nothing after all the elif/else blocks, you can just return at the end of each block, and then you can change the elif's to if's (with returns at the end of each block, you can't get to a block unless the previous conditions have been false). Building on Julian's answer, you can do: 

There is no n given in this problem. The n in O(n) isn't just some dummy variable; it refers to an actual parameter in the problem space. Saying "the complexity is O(n)", when you haven't said what n is, is meaningless. Every time you move the window, all but one element is already sorted. You can do a binary search to find where to insert the new element, giving O(log(D)) complexity. For D = 4, that won't save much time and probably isn't worth the overhead, but for large D it would be a significant savings. 

You're not using integer properties of ; you're just checking whether it's equal to a comparison value, not doing math on it, so there's no need to convert to . If you are going to convert, do it after you've checked whether the input is valid. You can use modular arithematic to get rid of some statements: 

This turns any number from 0 to 99 to words, no recursion. It can easily be extended to -999 to 999, and a little more work would get it to, say, -10^33 to 10^33. 

Now you just have to split the hundreds part into 2-digit sections. Instead of doing this one digit at a time, you can do it two digits at a time. 

The initial strategy that I thought of was iterating through possible multiplicands, and checking whether the product is monotonic. You seem to be instead iterating through monotonic numbers, and checking whether they're divisible. This may be a better way of doing it, but it can be implemented in a simpler manner. For one thing, you seem to be re-generating the list of monotonic numbers for each number in . Instead, you should generate a monotonic number, and then check it against all the numbers in . You can speed this up even more by deleting numbers from as solutions are found. Another issue is how you're generating monotonic numbers. Your method is rather convoluted and I don't fully understand it, but I'm pretty sure it's not optimal. Monotonic numbers can be generated through the following algorithm: 

I tested the following loop strategy by generating a list of numbers between 0 and 1, and then randomly selecting a number from the list greater than a threshold. I found that as the threshold goes up, the time for the list comprehension strategy goes down, while the time for the loop strategy goes up. The cross-over tended to be at around threshold = .8 . So this suggests that if more than 20% of your word are "long", the loop strategy is faster. However, I didn't exactly replicate your use case in my tests, so the cross-over is likely different. Also, if you're going to sample repeatedly, it's probably faster to calculate the list comprehension once and then sample from it repeatedly. 

When you're checking for failure, instead of asking "is it one of these cases that I've thought of that are bad", ask "Is it not one of the case that are good". Doing the former raises the issue of whether you've thought of everything that can go wrong. What if they enter a float? A string? Instead, do: 

There are two primary use cases of : you want to feed in a variable as a parameter, or you have a large number of elements. When you have , you're feeding in three fixed parameters to get an iterator with only three elements. It would be much more readable if you just put . There are quite a few lines where I don't understand why you have the code you do, such as instead of and instead of (And while misspellings don't affect your code as long as you're consistent, "opponent" has two p's) If you have the same list over and over again, you might want to name it. E.g. On a broader level, an option would be to name each line in which a player can win, e.g. , then create several dictionaries: has lines as keys and lists of squares in those lines as values, has squares as keys and lines that include those squares as values, and has lines as keys and the sum of the squares in those lines as values, where 'X' is worth -1, 'O' is worth 1, and blank squares are 0. Every time someone makes a move, find what lines that square is in, and add the appropriate number to the appropriate line totals. If the absolute value of a line total reaches 3, the game is over. Assuming the computer is 'O', you can then have the computer turn check whether any line total is 2, and if so make a move in that line, otherwise check whether any line total is -2 and if so move in that line. 

I found that the time taken varied a bit, which is odd since this should be deterministic, but on average this took about half as much time as @Eric Duminil 's solution. 

Well, it is correct to say that . Do you really want to add all this complexity to your function just to handle the special case of n<2? It depends on what you're using it for. If you're just wanting to be able to give Rodney the correct answer, he's probably not giving n<2, and if he does, you can just say "not prime" without running the program. You should consider just raising an error when n<2, rather than complicating the output. 

One thing to think about is what is being run how many times. That depends somewhat on the use case. No matter what, you're performing the check every time you run this function. Instead, you can just separate the words by length up front; create a dictionary where keys are integers and the values are lists of words of that length. The next question is whether you envision this function being run once for a puzzle, or repeatedly every time a new letter is guessed. If the latter, @200_success 's answer will be recreating regexes for each letter that are only slightly different from the previous letter, when you only need to check the new letter. So suppose you have a function that returns a list that is empty if the puzzle is finished, otherwise the first entry is the last letter guessed, and the second entry is the positions that letter appeared (if the letter didn't appear, then the list is empty).