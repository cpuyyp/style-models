Since A* is frequently getting neighbors to its current node, you can easily create a set of functions for getting adjacent nodes. For example, , , and so on. These functions will take the current node and return the node in the direction specified by the function name. Most of the time these functions can just increment a value and be done, however, on the edges, that will change. You'll want to map the surface of your cube to a 2D coordinate system. However you do this is up to you, they don't have to line up, just give each grid space a unique X, Y coordinate. Now when on an edge, and getting the adjacent grid space it's not necessarily going to be just incrementing the coordinates. We have to find out which face we're moving to and switch to the coordinates of that face. For example, getting the XPlus coordinate here will change both the X and the Y coordinates because we're moving to a new grid space on a new face. The green line represents an edge between two faces. 

You'll likely also have to increase the width of your text box. Wrapping occurs when the text doesn't fit in the specified width, it wraps to a new line. Alternatively you can use less text or just make the text box wider. 

Select from the top menu, and open the . On the right hand side of the page there is a list of categories. Select the category. This category contains a number of asset packages published by Unity Technologies. Included in this pack is the package. You'll also find a number of other packages that have great quality assets and they're all free. 

Typically I'll do some kind of colored pattern, with a different color on each edge and text or something in the middle so I can tell if the texture is mirrored. The colors on each edge allow you to be sure that the rotation is how you want it. Additionally, if you have textures that are supposed to line up, like for a skybox, I would draw colored lines across the textures where they are supposed to meet, to ensure they are aligned correctly in game. 

Note that the should be using the animated matrices for each bone instead of the bind matrices. It should also get all it's parent matrices like so: 

This creates a random velocity, then changes the position of the object based on that velocity. EDIT Sorry I misread your question. I saw your velocity variable and thought you wanted to move the object over time. But your description says you want it to appear at random locations. Simply change this line: to To make it appear at a random location (I'd also suggest renaming the variable from , because that indicates a change in position over time). 

I'd say the team you have is considerably more than resources that most have setting out to do an indie project. If your programmers are itching to get started, then do so! Start implementing the design plan you have now. The best way to learn more is to start doing! You'll get so many more ideas just by working out the finer details. 

I've done something to this similar recently in my game. Mine was for water flow, but it could be adapted for explosions. I've already adapted mine for lighting too :). Essentially your explosion starts with a fixed amount of "blast", this is the total area your explosion covers. Through each iteration of moving your blast outwards you're subtracting from this total number of "blast" pixels. When the count runs out, your explosion stops. When moving outward, the pixels lined up with the vector that's directly away from the blast is allowed to channel the most blast pixels, it has a higher throughput. This way the paths directly away from the blast get the most blast throughput. You can add rules that when the blast changes direction, the throughput is halved or whatever ends up working best. This ends up being very cellular automata. You define the rules of a cell, and they go out and do all the work. In my image, black represents walls and you see the height of each cube defines the throughput and the color represents it's current pressure from red to white. Basically you have a bucket of blast and you need to define the size and direction of the pipes leading away from the blast to flow that blast out. High pressure to low. What inspired this algorithm for me was Dwarf Fortress and the way the water flowed with pressure. Obviously I don't know exactly how it was done in Dwarf Fortress, but I hacked together my own version that works pretty well. There's a little more info on how I did my algorithm and an interview with the Dwarf Fortress creator here. 

Where converts a world position into the root position of the chunk that contains that location. And the functions take a Vector2 to add/remove from the loaded list. Finally, you may find adding in a buffer for unloading could be nice. If someone is moving the camera around a lot right on a chunk boundary, you can save a lot of loading/unloading by just keeping it loaded. Essentially, you may find that unloading at the same time as loading isn't necessarily the best option. 

This will allow you to have a bit more control in other aspects as well. For example you can check to see if the game is over before checking for input. That would disallow players from moving around after the game ended. 

Further, you can combine the two and steer between the deformed vertices on the displaced line. Creating smooth movement that's more random than one point to the next. Or you can take those displaced line vertices and use them to make a BÃ©zier curve and follow it exactly. 

Now you have a galaxy shaped like a star with arms. With more stars at the core and the arms somewhat distinct. Time to rotate. For each star, take its distance from the center and multiply that by to get a . Rotate each star by the rotation amount clockwise or counter clockwise around the center point. Marvel at the resulting spiral galaxy. 

I think it's totally fine to have simple methods for accessing, updating or manipulating the data in components. I think the functionality that should stay out of components is logical functionality. Utility functions are just fine. Remember, the entity-component system is just a guideline, not strict rules you need to follow. Don't go out of your way to follow them. If you think it makes more sense to do it one way, then do it that way :) EDIT To clarify, you're goal is not to avoid OOP. That would be pretty difficult in most of the common languages used these days. You're trying to minimize inheritance, which is a large aspect of OOP, but not required. You want to get rid of the Object->MobileObject->Creature->Bipedal->Human type inheritance. However, it's OK to have some inheritance! You're dealing with a language that's heavily influenced by inheritance, it's very difficult to not use any of it. For example, you can have a class or interface that all your other components extend or implement. Same deal with your class. This makes things a lot easier. I strongly recommend you take a look at the Artemis framework. It's open source and it has some example projects. Open those things up and see how it works. For Artemis, entities are stored in an array, simple. However, their components are stored in an array or arrays (separate from the entities). The top level array groups the lower level array by component type. So each component type has its own array. The lower level array is indexed by entity ID. (Now I'm not sure if I'd do it that way, but that's the way it's done here). Artemis reuses entity IDs, so the max entity ID doesn't get larger than your current number of entities, but you can still have sparse arrays if the component is not a frequently used component. Anyway, I won't pick that apart too much. This method for storing entities and their components seems to work. I think it would make a great first pass at implementing your own system. The entities and components are stored in an separate manager. The strategy you mention, making entities store their own components (), is kind of against the entity component theme, but it's totally acceptable if you feel that makes the most sense. 

Pixel perfect collision with particles would be very CPU intensive, this would be even worse on a mobile device. You may want to cheat and use a bounding shape to surround the area the particles occupy, and use that bounding shape for collision purposes. This doesn't have to be exact. It's an approximation of the area the particles occupy. I imagine if you actually implemented this and tested it you'd find that it was sufficient for your needs. 

There is no standard, but you should do it in a way that makes sense to you and contains all the information you may need to track that build. I worked for a company that essentially broke it down like this: [Major build number].[Minor build number].[Revision].[Package] i.e. Version: 1.0.15.2 

Solid characters doesn't mean much, computers aren't that smart yet :). You likely want to implement collision detection. Each character would have self collision detection and collision detection against other characters. You'd also create procedures to stop body parts from going further when a collision is detected. Unfortunately, this isn't generally something you can just "turn on". It'll take a good amount of work. I won't go into collision detection, since you didn't ask about it. The easiest solution, as Nicol Bolas said, is to create your animations so that characters don't collide with themselves. Additionally, if you have characters animating next to each other, you'll have to ensure they are positioned to not collide with each other. Here are a few things you can do to help ensure two animations don't collide: