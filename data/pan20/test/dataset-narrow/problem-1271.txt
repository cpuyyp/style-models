I am quite new to game development (but not programming) so please forgive me if I am not correctly understanding certain concepts. I am trying to figure out how to use world coordinates rather than pixel coordinates so that my game can work correctly at different resolutions. As I understand it, I need a viewport and I can use camera functions such as project() and unproject() to convert between the two coordinates. At the moment, I am just placing objects every 16 pixels as this is the size of objects and the objects cannot intersect. For example: 

I am trying to achieve a view with which I can see 50 walls on the x-axis and 30 on the y-axis. I was able to do this when using direct pixel coordinates and multiplying by 16 (the pixels-per-world-unit number), however as stated before, I don't think I want to use this method anymore because of negative affects at different resolutions. 

I've been told that having a set pixels-per-world unit number is bad practice because it will not look the same at different resolutions. Because of this, I am trying to learn about using abstract world-space coordinates instead, however I am having some trouble understanding. I've setup a quick test project for learning this: $URL$ As I understand it, CAM_WIDTH and CAM_HEIGHT should be the dimensions of the world in world units. However, I must be missing something because the end result seems to have made the world 50 pixels by 30 pixels. (My "wall" texture drawn at (0,0) in the bottom left is 16x16 pixels) 

On a tile based strategy game I'm working on the player may select an area in which a room is placed. To do so the player selects the tiles. Either by clicking on each individual tile or dragging from one point to another. An algorithm kicks in and decides how and where the pre-made tiles should be placed. My concern is getting this algorithm working for more complex shapes than a single rectangle. My first approach was to check whether or not the tiles around each selected tile is selected. Using this "signature" the algorithm chooses what tile matches that description and places it accordingly. With this setup I would need 7 models: 

This seems like a viable option without too much work for the modellers. I have however had some problems recognising the tiles where an cap should be placed. And for situations as shown on the right-hand room would require a near endless combination of caps and walls. A solution to discard the caps would be to make walls with a 45 degree cut on the end. This way there would be a lot more flexibility in placing the tiles and it would allow for special cases found in T-junctions. I believe the current pattern recognition algorithm would not suffice here. In order for it to work I think each tile had to check what kind of tile is around it, not only whether or not it's selected. I fear that this option would require too much computing power as the surrounding tiles may change recursively. Now, the question is what option should I go for? One of the two proposed, or an third option? 

However, now I move very slow because delteTime is a very small number. How can I make movement still the same speed without depending on the fps? Sorry if I'm missing something obvious, I just can't seem to wrap my head around this. 

I'm working on one of my first games and I've read that linking your game logic to FPS is bad because it will run differently at different FPS (obviously). I have already made some of the basic game dependent on frame rate and now that I know this, I would like to unlink the logic and render. I've learned that LibGdx has deltaTime in its render method for this, however I believe I'm misunderstanding how I am to use it. For example, my movement currently looks something like this: 

In my case, I would like the player to move 6 units per second. Since I built this on 60 fps, that means that movementSpeed is 0.1. Now the way I have seen deltaTime used is by scaling the movementSpeed based on the time like this: 

I'm currently playing around with a base builder/manager-esque type of game similar to Evil Genius. To build a room I would like to have the following process: 1. Select room type 2. Click and hold the mouse. Drag to create a rectangle over the area. 3. On release, place entire room. I have already implemented this, but I find it inefficient and I would like to improve it. As of now the indicator rectangle is simply a sprite that is scaled and moved to fit. I would, however, like to have the indicator rectangle to be "adaptive". Meaning that if I drag a placement rectangle over an invalid area the indicator will be red at that point. To do this I figured I could go with some sort of loop. I.e. "A change in rectangle size noticed. Update all new indicator tiles with correct colour". I had all the pseudo code figured out, but then I realised instantiating a number of gameobjects would be kinda inefficient. If the player is making a large rectangle in a short amount of time, that would surely slow down the game? Is there any other way to solve my problem, or is this the most efficient solution? I should note that this build system is grid based. Each tile has a coordinate given by two integers and is saved in a 2D array. You can easily access the array and see what tile is at any given point or find the coordinate of any tile. 

First off, it would be greatly beneficial to learn Java before attempting to create a minecraft mod. There are many great tutorials out there (I personally started out learning with thenewboston's tutorials on youtube) and you'll gain a new useful skill! Now onto your question. As newton1212 said, texture management has changed in 1.8. In fact, nearly everything related to rendering as a whole has been changed in the base game. JSON is now used for almost the entire system. This tutorial covers updating a mod to 1.8 rather than creating one, however the updated files should be helpful to you anyways. Good luck and feel free to ask any more questions you have. 

The bottom left block is located at pixel (0, 0), the one to the right at (16, 0), to the right of that is (32, 0), and so on. However, I would like to be able to place them at (0,0), (1, 0), and (2, 0) with the same result so that it looks the same on different resolutions. Basically, I'm asking how to set this up and have it work properly as world coordinates.