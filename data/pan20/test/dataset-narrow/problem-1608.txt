To differentiate the last case from the previous three, you would have to test using another, high quality supply intended for power, not just re-charging batteries. If you get the low voltage indicator no matter what you do, then you should contact the distributor for a warranty claim. 

So that you can stuff and have it put somewhere that isn't , where it may overwrite existing stuff and will not work. This needs to exist of course: 

First, get rid of that init script and forget about it. It's pointless in light of what it means to achieve, in addition to having been written by someone who do not understand how to achieve it properly in the first place. You can just stick stuff like this in -- first check there's a set at the top there already. If not: 

This obviously depends on which FPGA board you are talking about and what inferfaces are built into it. I think they are considered an optimal solution to things like this, but they can get very expensive and, having fooled with one a bit, I can promise unless you can find existing designs/code for the task, the workload in terms of human labour is going to drastically dwarf doing it using a normal computer in a normal general purpose language. I'm pointing this out because you are very wrong to believe an FPGA "can not handle this much data processing" -- again, they are an optimal solution performance wise -- but it is most likely not cost effective for you implementation wise. 

You can't, since if someone hacks the router, they could (for example) kick one of your other computers off the network and replace it using the same internal IP and MAC address (MAC addresses are easily spoofed). IP and MAC address are the only ways to identify who you are connected to below the application level, and neither of them is definitive or reliable for purposes of security. At the application level, you have various techniques such as those used with SSL, whereby key only access and certificates can provide secure forms of identification. However, you can still restrict access based on MAC or IP address to protect against intruders that access the network but do not have any control of the router -- in which case they won't be able to supplant an IP. MAC address spoofing is still possible, though, so you are better off giving the computers you want access to the pi a reserved IP on the router, and then using that.1 The normative way to restrict access is via a firewall. The most common firewall interface on linux, which is installed by default on raspbian, is iptables. A complete introduction to that is beyond the scope of a Q&A, but there are various tutorials around, and the pages explain most of the details. An example of an iptables rule is: 

The one you bought probably has two partitions. The first is a small (~50 MB) FAT32 partition. The second is a larger (2-4 GB) ext4 (linux native) partition. The FAT32 one is required by the Broadcom SoC, I think. It contains some kind of simple bootloader and the kernel. The second one is the root filesystem. 

This is actually a useless tool with SD cards, because SD cards use virtual addressing and there is no guarantee of consistency with regard to the correspondence to actual physical addresses; in fact, even simply reading data may cause it to be physically moved in a way that is opaque to the operating system and hence any software running on it. Even if you do a vigorous read/write test using , it's in theory possible that the controller could literally, on a 4 GB card, simply use the exact same 1 MB erase block 4000+ times when does a scan, meaning it would have verified the functionality of less than 0.1% of the volume. 

You can find the Pi kernel source here: $URL$ Note that's by default set to the 4.4 branch, but the latest is actually 4.9. It will take a long time to compile on the Pi, although that may not be necessary if you can find the build tree for your current kernel...which as far as I am aware is not available via Raspbian, unfortunately. Cross-compiling is probably a better option... However... The kernel I'm using definitely has . It comes from the "firmware" repo: $URL$ The kernel is in , you also need the directories from in . pulls from a slightly different repo, but that one has as well. This would be the easiest method ( first). Beware if you use any of these methods (building your own or pulling from a repo) then subsequent s will overwrite . My solution to this is to mount somewhere else, then the stuff that's written into is just a few wasted MB. However, that approach will be awkward with ; you may be able to set first, or you could just mount it on temporarily. That partition isn't needed during runtime, it is just mounted for updates and so you can edit easily, etc. There are some caveats around about the latest kernel (as pulled by ) being a bleeding edge (the Raspbian kernel lags behind a bit), but I have never suffered any grief from it. I am pretty sure most of the time the Raspbian kernel isn't any different, i.e., what's "bleeding edge" today will be used unchanged as the default kernel next month. Although that makes your missing module a bit odd... 

It's not impossible, but it will take you much less time and frustration to learn how to strip an existing distribution of the things you don't want. Which if what you don't want is pretty much everything, pretty much everything can be disabled and removed. Most of what you would need to know to do that, you would need to know to build it up to that point anyway -- it is mostly just understanding what "a very basic" but still functional linux would look like. You might find "linux from scratch" interesting. Although that is going to be painfully slow on the pi, reading it over and trying some of it on a normal computer would be a good place to start thinking about the what and how of what you want. 

The is significant since it means the kernel is looking for a root fs on the third partition. I looked at the CentOS image and it does use three partitions with the root fs last, so that makes sense. 

I use this pattern with all kinds of things and for me, it is the simplest, most foolproof and flexible method without having to rely too much on subtleties of systemd features. Put another way, there is no doubt a more proper way, from a systemd usage perspective, to get more-or-less the same result, but for that you'll have to spend some time delving through the documentation, experimenting, and hoping your assumptions are correct. By instead using a simple shell controlled fork, we take the power back so to speak. BTW (includes a few caveats): 

You would have to, since obviously the pins have to straddle both sides of the breadboard. I promise if you try to do this one of two things will happen: 

No. It is a fairly delicate piece of electronics, so whatever you do to prevent this boils down to "being more careful". 

This means getty (terminal based login) was ready after ~11.7s, then another minute and 20 seconds passes before "multi-user.target" is ready. Yet nothing in either summary appears to be a culprit -- the service that takes the longest is networking, at ~5s. Can you observe anything if you plug a screen in and watch the boot? I believe 1.5 minutes is some kind of default that systemd uses to wait on a service to initialize, after which it gives up and cancels it. If you watch a console, this will be shown with red asterisks doing a sort of Knight Rider thing whilst other services tick up with green "Ok"s. If that's actually not an issue (it may not be noticeable depending on the context of use, e.g., since everything else is done I believe you could log in remotely before that time is up) and your boot time is ~10-12s, then stop obsessing -- no model of Pi is particularly beefy, and that is a reasonable amount of time for it to boot a full fledged OS. 

Yes. Jessie uses systemd which includes a new-fangled logger, journald. I think systemd is great, but since journald keeps its log in a binary format, it is a PITA for stuff like this (where you want/need to look for errors in the log without the system running). There is a way to examine journald files using a journald tool on another system (see Wilf's comment below). Raspbian by default keeps the journald log on disk, but I've always disabled this since it tends to become ginormous (i.e., the binary format is not a space saving one). This does indicate an advantage to journald, namely it keeps a system log in memory and hence does not require a read-write filesystem be available (making it particularly useful if you are running in emergency mode). Fortunately, logging to disk can also be done in a human readable format via old school syslog, and Raspbian is default configured that way. The configuration (see ) dumps a copy of everything to . This includes stuff from the kernel that you can view with when the system is running. There is a caveat: If the system failed before the root filesystem was mounted read-write, there will be nothing to read about whatever happened and no indication in the on disk logs that the system even booted. 

You could of course just do and proceed that way, but this way you are playing safe. On the other hand, if you are intending to do a system wide install, you will need to do so at some point (). 

The last raspbian image I checked it's not on automatically, which is a bit different from normal debian, I think. It's enabled in runlevels 3-5, but the default is 2. 

A complication here is how you are using the pins. If you use a library that uses , neither method here will work for you. I do not know which libraries do not do this -- most of them do. However, you only need to use such a library if you want the web server to be able to set the pull up/down resistors or one of the pi-specific modes. If all you need to do is check/set the state (high/low) or direction (in/out) you can use the interface directly (i.e., no library), and both these methods will work. 

The Zero uses the original BCM2835 SoC used on the first generation of Pi's and all the other single core models, with a ARM1176JZF-S processor (although the Zero models have ones binned as 1000 Mhz instead of 700). All ARM11 cores use the ARMv6 instruction set architecture. Since those using ARMv7 or 8 are backward compatible with ARMv6, Raspbian has stuck with that. This is also the reason most of the distros used on the multicore models cannot be used on the Zero -- because they are ARMv7. 

1. Beware, as per scitronboy's comment below, that the ACT led on the Pi Zero behaves inversely to that on other models. 

I'm not a representative of either a retailer or the Pi Foundation, so I cannot for certain say this has nothing to do with the latter -- meaning, it is a policy of individual retailers, not the manufacturer -- but I think it is most likely the individual retailers. That being the case, I suppose some stores could try and impose a "one zero per lifetime" cap -- but that seems a bit absurd. It also means that there may be some retailers which have no limit at all. There is at least one popular retailer that I've noticed apply a "one per customer" limit only with regard to the zero when ordered without accessories for $5, but no such limit when ordering them packaged in a kit (and they did not prevent me from ordering a total of two at once this way, one of them in a kit). I notice the same retailer obviously sets some of its stock aside just for kits, since they will show the plain zero as out-of-stock but various kits including a zero as in stock. I think most retailers who sell them alone for $5 probably go out of stock very quickly, and if they do impose a limit, it will probably be "reset" when they restock. I.e., I'm sure when aforementioned popular retailer gets another bunch, I will be allowed to order another one without having to get sneaky, create a new account, have it mailed to a friend's address, etc. I believe this is all tied to production runs. The Foundation has a couple of "official" retailers they work with publicly -- in fact, these are more than just retailers as (at least in the past) they have actually produced the Pis themselves. I know there have been other more localized relationships of this sort, e.g., there was a red model B at one point only available in (parts of) Asia, produced under licence by a distributor there. I don't know what the relationship of the smaller/unofficial retailers is, including whether or not they have to go through one of the Foundation's two international partners (RS Components and Farnell element 14). I imagine at some level everyone not licensed to do production themselves must pre-order a certain amount and this is in part what determines the size of a production run.