You should remove the i386 architecture since you are running a ARM architecture. But first you need to remove packages from the wrong architecture that have been installed: 

The error is often mentioned when a corrupt image have been transferred to a SD card or when a SD card is faulty or kernel bugs. I have replaced a corrupt SD card due to this cause and that solved my challenge. 

GPIO.cleanup() is cleaning up all the ports you’ve used. It resets the ports you have used in your program back to input mode. 

See ref. below. 2. Network interface names. Quote: Predictable Network Interface Names As if Stretch, the old network names like eth0, eth1 have gone away as the device name can change. The new names are similar to these: enp6s0, enp8s0, enp0s31f6, enp5s0. Ref.: $URL$ 

Your assumption is mixing input and output. I have just explained what the difference between input and output is here: RPi 1 Model A input/output pin ratings And the reason for a pull-up/pull-down is that a GPIO pin without these can be in an "unknown state" aka floating and pick up static charges and behave erratic. So a pull-up/pull-down resistor is forcing the input to always be in a known state! 

NO! A motor is producing a EMC that could kill your GPIO and in worst case your Raspberry Pi. And the current needed to run the motor is probably exceediing the limit of the GPIO! You need a motor driver circuit, example 

Linux is a common OS in the IT industry. It is driving the most super computers in the world, and is a common OS in the IoT market. Linux powers many of the biggest Internet properties (e.g., Google, Amazon, Facebook, eBay, Twitter and Yahoo!) It is estimated it will have about 5% of the total IT market in 2017. $URL$ 

The voltage divider isn't causing a current of any significant, the input resistance (impedance) is 45-65 k ohm. The total current is approx 0.77 mA and a 1/10 will be passing through the internal resistance (77 uA). So taking in the internal resistance in the calculation the divider will be 1.7v vs 3.3v and that's within the Raspberry Pi's tolerance 

The main constrain is if you write to the same location of the SD card. And as I understand you question, you arn't writing to the same file and changing the content of the file, but creating many files++++ then it wouldn't be a problem. 

PWM and solenoids, hmm doesn't sound like a good idea. The solenoids you refers to are either on or off, why do you want a half locked/open lock? I would propose 16 relays with driver circuits since the Raspberry Pi can only drive 16mA per GPIO and and not exceeding a total for all GPIO of 50mA. 

The other way is to change the metric for the 0.0.0.0 route so that the route via LAN has a higher metric than the one for the WiFi. To make the router taböle permanent check out How to make a change to the routing table persist? 

There are several ESP8266 based relay power modules. The ESP8266 is a WiFi and CPU chip and is widely used in Home projects for the purpose you are asking about. I prefer to program them with Arduino IDE and uses MQTT as control protocol, and as a hub I uses Raspberry Pi with Mosquitto and Node Red to create the logic that control the different devices/modules. I get my inspiration from: $URL$ Andreas Spiess channel $URL$ 

I am using Raspbian and command allows from a ssh terminal keyboard session to run a command like and display a picture in the monitor connected via HDMI port on the Raspberry Pi. 

CLONE/COPY DATA INTO FILESYSTEMS - Raspbian will mount extra filesystems on with owner and will create errors with the command. By making new mount points and mounting the filesystems there, errors will not be created. The command will not cross filesystems, so , , , etc (system generated filesystems) and mounted filesystems (, etc) will not be cloned/copied. It is best to not have other jobs running on the system during this section. 

If NOOBS or PINN is on the SD Card, then the first vfat partition(/dev/mmcblk0p1)/filesystem is NOOBS or PINN boot and /dev/mmcblk0p5 partition/filesystem(SETTINGS) is used to select which OS is to boot. Use the cmd to locate the partitions of the and (root) filesystems. If there is only one OS on the SD card, use the procedures above and adjust for the boot and root partition (probably /dev/mmcblk0p6 for boot and /dev/mmcblk0p7 for root). If multiple Linux OS's are on the SD card, boot to a different Linux OS and use the above procedure as a guide to rewrite to boot and root partitions/filesystems of the OS to be replaced. 

Done, now you can power down, remove power and swap the sda card in place of the system sd card and power up. Your cloned system should be up and running as before. To update your backup on the cloned sda card, use the bottom part of the script starting at the "# Backup part ...". If your orginal sd card has root as as boot as , the , , and commands are not needed. Note: If downloading this script, you may need to run to convert from Dos to Unix . 

Change root device. Edit with sudo vi or sudo nano and change to . Also edit and change the to . Note that the could be in the form of or . Reboot, . Verify that root (/) is on /dev/sda1 with the command. Download new OS and copy the images back to the SD card. 

Yes you can upgrade NOOBS or PINN (enhanced version of NOOBS). NOOBS and PINN both uses two partitions on the Pi's boot system SD Card, /dev/mmcblk0p1 (a vfat boot partition) and /dev/mmcblk0p5 (a Linux display/selector/(/media/pi/SETTINGS) partition). To list files in NOOBS/PINN boot partition, it has to be mounted, then . I would suggest to make a back up or your system first as if any thing goes wrong the only other recovery would be a fresh install. Get the lastest copy of NOOBS or PINN Make subdirectory or . Change to subdirectory or and unzip or . The in the file is for the new install. We are updating, not installing a new systems. THIS OPTION HAS TO BE REMOVED, (Enter) cmd to delete word (Enter) to save and exit ( (Enter) to quit without saving if things goes wrong) (See WARNING at $URL$ Remove the old NOOBS/PINN files from /dev/mmcblk0p1 that is mounted on /mnt/d1 previous, and copy the new files . Cleanup and sync, , , or . Reboot and and first boot on the new NOOBS or PINN and then to previous OS boot. 

You could skip the breadboard, but it would definitely make things easier for you if you would use it. Just google "raspberry pi light led" without the quotes. 

I am trying to manage the songs in my 3rd gen iPod Touch via gtkpod, or rythmbox. I’m currently unable to find out how to mount it, because it doesn’t show up in my list of devices. Am I missing something that’s right in front of me? From what I found via Google, the commands below should shed some light on the subject. However, I see no mention of new devices found, like "sda1", much less any mount points like "media/ipod", which would be super... 

From what you describe, it can be a power supply issue, or a defective Pi. I would try a different power supply before sending it back. I only got mine to work well with an iPad charger, otherwise Bluetooth and Wifi wouldn't work. 

I've found that most of my chargers don't provide enough power to my PI3, even if the "under-voltage" icon doesn't show up. This causes the Wifi and Bluetooth to be disabled in an otherwise working system. An original Apple iPad charger did the trick. 

I've setup my rpi3 running OpenVPN with the script from www.pivpn.io. It works fine with my Android phone (Samsung S6). It doesn't work with my iPad air, nor with an iPhone. What can cause OpenVPN not to work with iOS devices? Here's the config file from the iPad: client dev tun proto udp remote xxxxxx.xxxxxxx.com 1195 resolv-retry infinite nobind persist-key persist-tun key-direction 1 remote-cert-tls server tls-version-min 1.2 verify-x509-name server name cipher AES-256-CBC auth SHA256 comp-lzo verb 1 

-----BEGIN CERTIFICATE----- (etc, etc) And here's the log: 2017-03-17 13:18:12 ----- OpenVPN Start ----- OpenVPN core 3.1.2 ios arm64 64-bit built on Dec 5 2016 12:50:25 2017-03-17 13:18:12 Frame=512/2048/512 mssfix-ctrl=1250 2017-03-17 13:18:12 UNUSED OPTIONS 4 [resolv-retry] [infinite] 5 [nobind] 6 [persist-key] 7 [persist-tun] 11 [verify-x509-name] [server] [name] 15 [verb] [1] 2017-03-17 13:18:12 EVENT: RESOLVE 2017-03-17 13:18:12 Contacting xx.xxx.xx.xxx:1195 via UDP 2017-03-17 13:18:12 EVENT: WAIT 2017-03-17 13:18:12 SetTunnelSocket returned 1 2017-03-17 13:18:12 Connecting to [xxxxxx.xxxxxxx.com]:1195 (xx.xxx.xx.xxx) via UDPv4 2017-03-17 13:18:13 NET Internet:ReachableViaWiFi/-R t------ 2017-03-17 13:18:22 Server poll timeout, trying next remote entry... 2017-03-17 13:18:22 EVENT: RECONNECTING 2017-03-17 13:18:22 EVENT: RESOLVE 2017-03-17 13:18:22 Contacting xx.xxx.xx.xxx:1195 via UDP 2017-03-17 13:18:22 EVENT: WAIT 2017-03-17 13:18:42 SetTunnelSocket returned 1 2017-03-17 13:18:42 Connecting to [xxxxxx.xxxxxxx.com]:1195 (xx.xxx.xx.xxx) via UDPv4 2017-03-17 13:18:52 Server poll timeout, trying next remote entry... 2017-03-17 13:18:52 EVENT: RECONNECTING 2017-03-17 13:18:52 EVENT: RESOLVE 2017-03-17 13:18:52 Contacting xx.xxx.xx.xxx:1195 via UDP 2017-03-17 13:18:52 EVENT: WAIT 2017-03-17 13:18:52 SetTunnelSocket returned 1 2017-03-17 13:18:52 Connecting to [xxxxxx.xxxxxxx.com]:1195 (xx.xxx.xx.xxx) via UDPv4 2017-03-17 13:19:02 Server poll timeout, trying next remote entry... 2017-03-17 13:19:02 EVENT: RECONNECTING 2017-03-17 13:19:02 EVENT: RESOLVE 2017-03-17 13:19:02 Contacting xx.xxx.xx.xxx:1195 via UDP 2017-03-17 13:19:02 EVENT: WAIT 2017-03-17 13:19:02 SetTunnelSocket returned 1 2017-03-17 13:19:02 Connecting to [xxxxxx.xxxxxxx.com]:1195 (xx.xxx.xx.xxx) via UDPv4 2017-03-17 13:19:12 EVENT: CONNECTION_TIMEOUT [ERR] 2017-03-17 13:19:12 EVENT: DISCONNECTED 2017-03-17 13:19:12 Raw stats on disconnect: BYTES_OUT : 3240 PACKETS_OUT : 60 CONNECTION_TIMEOUT : 1 N_RECONNECT : 5 2017-03-17 13:19:12 Performance stats on disconnect: CPU usage (microseconds): 52155 Network bytes per CPU second: 62122 Tunnel bytes per CPU second: 0 2017-03-17 13:19:12 EVENT: DISCONNECT_PENDING 2017-03-17 13:19:12 ----- OpenVPN Stop ---- 

See $URL$ for installation. The basic boot for Raspbian on the Raspberry Pi 3B is two partitions/filesystems on the system micro SD card, one for boot and the other for root. The boot filesystem is the first vfat (Windows) partition and the root filesystem is on a Linux partition (more details at How does Raspberry Pi boot?). (New options allow booting from other devices, see $URL$ .) BerryBoot use the boot filesystem as a boot manager and use squashfs for the OS(s). It saves space, but very hard to update. NOOBS, NOOBS Lite, and PINN ($URL$ use the first boot filesystem and a SETTINGS filesystem to select an OS boot filesystem, which boots and load the OS (Raspbian, Retropie, ...). NOOBS has Raspberry Pi support. NOOBS is larger file as it contains Raspbian with option to download other OS(s). NOOBS Lite and PINN are smaller file and requires internet connection to load any/all OS(s). PINN has more OSs to select from and is popular. To select a different OS with BerryBoot, NOOBS, NOOBS Lite, or PINN just reboot and use the keyboard to select which OS you choose to use. The default is the last selected. (It is possible to change a selection in SETTINGS to predetermine which OS will become the default on reboot (not tried on BerryBoot).) Another option would be to just download and install Retropie ($URL$ as it will also install Raspbian Jessie (New Raspbian is Stretch) as Stretch is not currently supported by Retropie. Exit the EmulationStation with F4 and you will be in Raspbian Jessie Lite with a command prompt. You could also buy a NOOBS card, plug it in, power up, and you are good to go. I would suggest starting with NOOBS or PINN installs on your first try. You can always buy more micro SD cards and try different options to see which you like the best. The displays is a different question. From web searches it appears that a touch screen and/or a HDMI monitor can be connected to the RPi 3 ($URL$ I only use HDMI monitor/TV. Plug in the monitor, power on the monitor before powering up the RPi and it self configures the resolution. There are some configurations in the /boot/config.txt file. 

I have had good results with the WD PiDrive Cable $URL$ It will not connect to all hard drives as it has a funny connector. It is a Y type cable that your power supply cable plugs into it and it powers the Hard Drive and the PI in parallel with the USB cable also. 

To answer your last question about using instead of to create an image file to be used by Etcher, the answer is yes and no. Let me start at the beginning. I have not used Etcher, I have used the Pi to create its own bootable clone/backup sd card from the running system. From this sd card or stick the , , , , type of commands can be safely used by Etcher to create an image file. The setup takes some effort, but it is easy after the setup. I apologize for the mistakes in my previous answer, I will try to correct them. SETUP - From your addition information I see that you are running Raspbian and Recalbox and I think NOOBS was installed. I have downloaded and installed NOOBS on a used reformatted sd card, unzipped it in place, shutdown/power off, inserted in system sd slot, inserted a new sd card in a USB adaptor, powered up, selected Raspbian and Recalbox, and configured with raspi-config. I copied from my old system card, /etc/hostname, /etc/hosts, /etc/ssh/, and /home/pi/.ssh/ and rebooted. PARTITIONS - The sd (serial disk, sda) card/stick/key/HD has sectors which hold data. Partitions (primary, extended and logical; sda1, sda2, sda5) divides the sectors into groups to hold filesystems. The logical subdivides the extended. Some useful commands are , , , , ... for partition information.