Note: this last line will produce a unit vector (i.e. of length one), you may need to handle thing a bit differently if you want the diagonals to be of length sqrt(2) like the code you posted with your question. Edit: I can see two approaches to address the issue of switching directions on each frame and approximating 16-direction movement. BlackList: If each time a player changes direction we disable or blacklist the direction they were taking before that turn, this would rule out that issue, and instead result an a high degree of over steering. This might be acceptable if the target was stationary but is unlikely to look natural if the target moves into the direction we have blocked, and players would learn to take advantage of this. 

If familiar with OpenGL Immediate Mode this approach is pretty straight forward, but if you later decide that you would like to texture your primitives I would recommend using a MeshRenderer with a custom mesh. Morten Nobel has published a tutorial on using this approach with 3D meshes his blog. The same approach can be used create a plane of arbitrary shape. 

Since you're already assuming you have a good game, and it's popular enough to make it through the Greenlight process, you don't have much to worry about. Once you have enough critical mass to get Greenlight, people will have voted to get your game there, it's highly likely that at least some portion of them will also buy the game once it's on Steam. Additionally, once it's available on Steam, you have a much larger market that will now see and have the ability to easily purchase your game. So, yes, you can expect more marketing and thus sales. If you have Steam selling your game, you'll have more sales and marketing. Certainly a lot more than if you never had your game on Steam. I can't imagine a situation where you'd have fewer people knowing about your game or fewer sales as a result of getting Greenlight. You can find some statistics for Greenlight games here. And an article here. Steam is typically very tight with marketing numbers. Even within the Greenlight program you don't have exact numbers for how many people need to vote in order to make your game Greenlight. It's highly unlikely you'll be able to find statistics that show before/after for Greenlight games. Steam doesn't like people sharing their revenue information about games sold on Steam either, so it's even more unlikely. There are some hints here and there. All in all, things point to the obvious, getting your game on Steam is better than not being on Steam. With the assumptions you make, you are nearly guaranteed some form of success. 

I am working of some editor scripts for Unity but have found that it is difficult to force Unity to reload my editor scripts. My scripts are modelled on the static constructor approach and perform some manipulation of the Tag Manager. Currently the static constructor is called when either: 

Rigidbodies can be said to operate in two modes: Non-Kinematic has physics driven movement, the physics engine will consider any forces brought to bear on the object to calculate and apply changes to velocity, rotation and position. Kinematic lacks physics driven movement, the physics engine will not cause this object to move and any forces on the object will be disregarded. These objects can be moved through code by directly manipulating the Transform if required. One important point to be mindful of is that the physics engine is optimized such that it will not detect collisions between two Kinematic Rigidbodies. If your ball is a Non-Kinematic Rigidbody and you want the bricks to remain stationary then I recommend setting the bricks to Kinematic. 

Spawn the object at a random location on the side of the screen. Additionally, give it a initial direction/velocity of straight across the screen +/- random 20 degrees at whatever speed you want it to move. Finally choose a random target location on the opposite side of the screen. Now use steering to guide the object from its initial starting position and velocity to the target position. This way you only need to choose two positions and you'll get fairly natural movement while it's moving from one side of the screen to the other. Alternatively, you can pick your start and end positions forming a line across the screen, then use mid point displacement to alter the line to make it less straight. (I suggest a higher (H) value closer to one so your bird doesn't look like it's on drugs). 

If you want the camera to be at 0,0, you set its position to be 0,0. If you want to align the bottom left corner of the camera with 0,0, you need a little math. It's not required to be an integer coordinate. It can easily be a decimal, depending on the field of view or the size of the projection, and the aspect ratio of the view. For your first image, using 16:9 aspect ratio, the x value would indeed be 8.88 and the y value would be 5.0. With a orthographic size of 5, and an aspect ratio of 16:9. Since the Y dimension is smaller, it'll always equal the orthographic size. The X value is calculated using the aspect ratio: 

Using a consistent naming scheme e.g. all types use CamelCase. Use the generic form of as it allows compile time type checking: 

The usual approach to this scenario is to build a collection and then shuffle the contents, much like a deck of playing cards. The Fisher-Yates shuffle is a simple and effective algorithm that suits our purpose well. Here is a minimal implementation: 

"Am I sacrificing anything ... in order to play it at half-speed?": Yes. You mention authoring at a high pitch so that it will sound normal on playback. By reducing the range of useful frequencies during authoring you are essentially compressing your audio into an artificiality narrow range of values, this may compromise the quality of sound on playback. This effect will not always be apparent to the listener. 

A more interesting approach would be to determine a difficulty rating for the wave, and a difficulty rating for each enemy type. Then you could add different enemies to the until you have reached the desired difficulty. 

A* is the logical choice. Your main concern is going to be with generating good navigation nodes. The nodes will tell you everything you need to know about how traversable each node is with respect to each unit. 

While I ended up with a similar approach to yours, I can tell you about an implementation I went through on my way there. It's probably a bit simpler to understand, so it should be easier to modify. Basically, I use the normal of the vertex to tell the vertices which way to shift in the view plane. More specifically, that can be done like this: 

There are so many options. People do tend to relate game playing to violent video games, but there are actually far more games that are not violent. 

Pick a random direction and start going Continue exploring, choosing random directions at intersections Once you've reached a dead end, path towards the nearest "fog of war" Loop to 2 until exit is discovered. 

It you look at the or () in the inspector under Constraints > Freeze Rotation you will see a checkbox for each applicable axis. These checkboxes will stop the physics engine from applying any rotation about that axis. 

For data that is created at design time you can use the TextAsset resource type. Note that despite its name it can be used for arbitrary binary data if preferred. To persist data that is created at run time PlayerPrefs provides a key-value store. This will be implemented in a platform appropriate manner and performance may vary. If storing a large number of items at once is causing delays it may be improved by consolidating the data into a single sting. To simplify parsing of this data many people use SimpleJSON. 

Collision events will only be detected under specific circumstances. Each collider can be considered to have these relevant properties: 

These No Warranty / "as is" clauses are intended to reduce any liability brought against the software developers/publishers. 

You can add a pause to the code you've copied. Add some booleans to the top (sorry I don't do UnityScript, so syntax may be poor/inaccurate). 

Send the developer a few euros (more than two) and an email asking for help setting up Eclipse with his project. Support open source and get the exact help you need. WIN-WIN. 

You step through the simulation quickly, in a loop or a loop depending on what the goal is. You're essentially simulating the frames in the loop with predetermined time steps, ideally with the same value as your fixed time step. Depending on how you have your game set up, this could be as easy as using your existing functions. 

This is when using my own serializer to create the out of an object and its components. That array could just as easily be full of JSON or any other binary data. If your allocated ID is not being found on the other end, it could be because the object you're trying to communicate was created incorrectly, giving it a different . You can always use or you can send a message to clients that an object needs to be instantiated and send the along with it. 

This sounds like the object is at rest and the Rigidbody has been put to sleep. You can modify to change this behaviour for a single instance. Alternatively you can change the threshold project wide via the Physics Manager. Try setting "Sleep Threshold"/"Sleep Velocity" to zero. 

I'm having trouble visualizing the problem you are describing, however I can see two issues with the implementation posted. The first issue is that you are using the updated rotation as the first parameter of the lerp function. Doing this will produce a movement that will start off quickly but then slow down towards the end. This effect is great for camera movement but would look a little off for rotating a card. Another issue is that you are using (elapsed time) as the third parameter for lerp, this will produce varying (and possibly unexpected) results for those occasions where is not equal to 1. The solution is to use as this will smoothly travel from 0 to nearly 1. At the end of the loop you can then force the final rotation to ensure a predictable final state. A smooth and complete lerp requires stable and parameters and a parameter that ranges between 0 and 1. Please try this version with these changes applied: