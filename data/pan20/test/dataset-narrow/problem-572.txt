I agree with @ckuhn203 in that the first looks cleaner. I'm not too familiar with C# and its style, but in C I would definitely prefer using a loop: 

This is the classical implementation of the sieve. The resulting array will hold a value of for prime values. Now, observe that the first time you ever see a prime, you remove all of its multiples from contention. We can therefore store a separate list containing just these primes. (We also have to loop over the back half of the array to get any primes .) 

In addition, in your code, you're running a lot of s here. Rather than calling it each time, you can store the result into a variable and only have to call it once. I didn't do it here because by making the other change, you'll only have to call it once anyway. 

It looks like you're looking for the index of the first child of with the class. (Incidentally, your code will also trigger on stuff like , which might be a false positive. Be careful about your classes!) Native selectors work fine here. Furthermore, your initial assignment doesn't do things the jQuery way -- there's no reason to initialise two separate jQuery objects. Try replacing your block with something like: 

Functions should be named according to what they do. This means they should often start with a verb, so rather than , it should be . (There are exceptions. For example, when checking a condition, you can use .) Furthermore, they should be named in ; the first letter should be lowercase, while the first letter in each word should be uppercase. Consider aggregating your dog mood functions into a single method. You'll probably soon learn about s; an enum would be a natural way to store and represent the dog's current mood (Ã  la ). If you're looking for a 40% chance of something, then or will do what you want. will get you a random number from to inclusive, so will actually be a 36% chance. Your chain is needlessly complex. Remember that an will only be considered if all preceding s and s failed. Thus, you can instead use an - ladder similar to the following. (Note that the percentages are accurate only if you change your line to use rather than . 

while the big clauses were identical from the start the smaller cases did differ only because of the bad data representation. Avoid error prone repetition of constants now let's have a closer look at . there is one diagonal checked twice, we delete that one. the cause for this error is editing by copy paste and altering values. with a little python list slicing and comprehension we can make this code shorter and thus less error prone 

When writing library classes you should follow the python guidelines to enable generic duck typed interfacing. have a look at the python datamodel and try to make e. g. the following tests work by implementing and . 

EDIT: I simply had to try the bag of words approach I simply slide a window of the probe words length ofer the text words in single word steps. for this text window i calculate the bag of words and compare it to the probe and sum the absolute difference values for every entry. e. g.: 'so the the moon' vs. 'the moon moon is' resulting (so:1 the:2 moon:1) vs. (the:1 moon:2 is:1) wich results in a diff (so:1 the:1 moon:-1 is:-1) in absolute values (so:1 the:1 moon:1 is:1) summing up to the value 4. This measure for my test set 

(and so does ) does not handle the 'not found' case. this went unnoticed as you did not write a test. So the main point is - if you write a library class/function it is mandatory to do good tests. full code coverage and all regular and edge cases you can think of. python provides a unit test framework, use it. 

Problem definition it is not clearly defined whether shall result in. your implementation suggests as desired result. other possibilites include 

Your loop has a potential complexity of R * M (R number of words in ransom, M number of words in magazine). Additionally you use in the inner loop which which does linear search in magazine. The solution is to count occurences of words in both, magazine and ransom. this is done in a single sweep and of linear complexity R + M (dict get/set is average linear). the moste dense and readable solution is 

so any other variable referencing a node or even the root node will possibly reference something old. 

should perhaps be , as most typically associate terminology with having some value returned to caller. 

You seem to be caught in between making a decision on whether this should be a concrete class or a class to be used statically. If concrete as currently designed, I don't understand why you wouldn't just pass the time to the constructor and set the angle as a property which can be read vs. recalculatated every time via a method call. If you truly want to treat these methods in essence as static methods like you are currently doing, then consider making these methods static and don't store state. 

Also, if you consider making favorite into class as suggested, you can clean up your code like this: 

I honestly don't understand the branch of logic here which reads from cached representation. Why bother even doing that if you aren't actually returning the JSON? Even the branch where you interact with the Twitter API does not return anything to the caller (see earlier comment), but does write to the cache. Is this really just a function to update the cache from the twitter feed? If so, why so you ever need to read the existing cache file and it? 

Why are you mixing snake_case and camelCase? I know PHP, as a language, is not really good about this (mainly from its legacy roots), but that doesn't mean libraries that you are writing should not be consistent amongst themselves with regards to the symbols you are defining. 

Your application should probobaly only have 600 permissions (or possibly 644 if other system users need to read to files) in the upload file directory. I assume none of these files are going to be executed (thus needing 7). 

You would likely want a unique index across word_id and antonym/synonym_id, or perhaps just treat this as compound primary key and drop the autoincrement primary key altogether (not sure what your lookup use cases are here to make this decision, or if you are using some sort of framework that always expects records to have autoincrement primary key). 

I frankly don't understand the parent child stuff in your hide function. Are you expecting multiple nesting levels? 

So, if you resolve that injecting every dependency that could possibly be needed into every class is not the way you want to go, you can then address the problem with your provider/factory behavior. If you wanted to only pass required dependencies to consuming classes, your method would quickly become overly complex (it might get this way even with your current dependency injection approach if you need more complex instantiation logic for given classes). You could imagine some horrible construct like: 

I recognise that you asked about your mergesort, but I couldn't help but notice your bubblesort... You're doing once before the loop, and again at the end of each iteration. Instead, you could just use in your condition. Furthermore, your swapping could be rewritten with just one temporary variable: 

I was writing an answer but @jsanc623 beat me to the punch with the , so I'll just add the missing bit. Your solution won't work if your file is served from e.g. . Instead of doing it this way, you can find the current filename more reliably like so: 

This is a little bit messy; this is the issue I was referring to earlier. It's good that you added a comment, but even with the comment it seems a little bit bleh. This is mostly an issue because your and methods both call , even though in this instance you'd prefer to just use the logic. If you can, it'd be better to separate the model logic (the stuff dealing with the adding and deleting on ) from the presentation logic (rendering, clearing input boxes, etc.). That way this method becomes a lot cleaner. There's also a bug here: if you edit to an already existing todo item, the add will fail, but the delete will still run, so you lose your existing item. This will even happen when you edit to the same thing. 

In PHP 5.5+, the best practice is to use and . You can use it in your code like so. Notice that this obsoletes the column in your table. 

Hint: The problem statement asks you to remove friends from the end of the list as necessary. Think carefully about this. 

columns should almost always be s, not s. That's just silly design. Similarly, should be an . should be foreign keyed to some table. is not necessarily a good name. If you only need to differentiate between active and inactive, use a and name it something like . If you need more states, then assign a value like or or , instead of and . There's no reason to have a separate table for and . Rename to something else (?) and get rid of . Whenever you have a top-tier item, set its to or . 

You should explicitly define either abstract or simple default implementation (i.e. that doesn't enforce return data type) for method on . 

I have several concerns with your classes. The foremost one is that in that act of trying to define what a "user" is in your system, you are allowing arbitrary external SQL to be passed to the class to query the database. What if if someone passes SQL for a totally different table? Because of this, you really have no encapsulation around your User class at all. I would suggest perhaps a User class which truly represents represents only the properties and methods related to an individual user in the system, and then perhaps a UserFactory class which exposes methods to return one or more User objects. I think having the methods in the factory class be static makes a lot of sense. I don't know that having static methods on an instantiable User class makes much sense. I don't understand your need for the database class. It doesn't really do anything. Normally, one might write a database wrapper class to do something like manage DB connections, abstract away underlying DB implementation (i.e. in this case) from consuming classes, provide more natural language query capabilities, perform general object-relational mapping or something that actually adds value. This class: 

This is pretty straight forward code and there is not really much here to provide much critique to. The biggest concern to me would be in the area of data validation. You are not currently doing anything to validate that you have appropriate parameters being passed to your methods. You should consider adding type hinting for your parameters to better enforce that, for example, you are getting a valid database object to work with or a valid Artikel object to add to the repository. Similarly for thing like setting article id and name where you might be expecting a postivive integer or non-zero length string, you should validate this in your methods and perhaps throw InvalidArgumentException if validation fails. I question the need for setters on Artikel class if these objects would only be instantiated in the mapper process and are tied to actual database records. Should these objects actually be mutable like this? If not, I would actually consider using __get() magic method here instead of the getter you specified to allow more clear and concise access to these properties (I.e. $article.id or $article.naam) while still making the object immutable. I would encourage you to properly indent your code in a consistent manner and always use single empty lines between class methods consistently. Also, place empty lines between your includes and the beginning of class definitions. One final small thing, and it may just be my preference, is that you might consider using protected visibility instead of private when first writing these base classes. I would generally only use private when there will be at least one inheriting class and I had a specific reason to actually restrict visibility to those inheriting classes. 

the first definitely do not belong there, this shall be done in main or in a UI. for the latter if no user interaction is required this could be logging. if requred it should be done on the dedicated UI. getting the message there could be via return values or more pythonic via raised exceptions. so we remove the print from 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

explicit loops python has list slicing and list comprehension. in you use comprehension but could use the more dense slicing 

if you hold your rows and columns as list of lists (which has some other advantages we will see later) you can even omit parameter n whe testing a line 

this would be less heuristic than your approach, although you probably will again apply some more algorithms/heuristics to find the 'exact' match start/end. 

still there is an if clause which we could make shorter. there are numerous techniques to toggle/select/cycle values from a limited set. here i am tempted to use a very lazy one (as the number of iterations is small) 

There is nothing wrong in general with for loops. If you have to iterate over some elements there is no magic that can avoid this. So why is your function "not very efficient"? And why is this because of the for-loop? However you asked for a pythonic solution. In Python explicit for loops are avoided by using list comprehension. Internally Python again loops over all elements, however slightly more efficient. Better readability is the other big gain. So let's measure (I did some renaming for readability). I compare