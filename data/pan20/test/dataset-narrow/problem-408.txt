If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

This sacrifices quite a bit of functionality to pull this off, mainly because of my preference for s. To add the ability to add/remove child nodes, I went with a view instead. This way the data itself stays the same, just our view of it changes. I also added a helper to provide depth-first traversal, to abstract away doing things with the nodes in the tree. 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

In the constructor, use the member init list, not assignments in the body of the function. Some of those can be default initializers on the data members (tileID, elevatedTilePosition). 

How do you use this? Normally a takes a predicate but you have it labeled , and the first parameter is unnamed. I think it would be clearer to call it (If I understand what it does) and name the searched-for rectangle to be clear that’s what it is for. 

Look at Boost.Range. Your first point drives most of the rest of the concerns. Write your template function to take a Range. You can pass it a C string literal, a std::string, an array, vector, or anything —— even a pair of iterators if that’s what you need after all. Not limited to char? No problem: make it a Range of T, with a default of char. This takes the place of your initial idiomatic approach. Use ranges rather than iterators, and you don’t need to wrap it for convenience. Boost.Range does all that for you. The output can remain an output iterator, but I like to make it a range adaptor. With that, you can do things like: 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

Along those same lines, became because that's really what it does. I also moved the helper functions into 's companion object. It's a good default organization strategy. itself had mostly structural changes. I changed the visibility of , so that mutating it has to pass through the helpers. It also became a Set, as the OS doesn't generally make guarantees about listing order, so I wanted to avoid implying that the order was something that could be relied on not to change. became just and passes a defensive copy of the internal set. That gives us this final version, with a small driver to make testing easier. 

Your function that switches from one to the other representation is overly complicated, and not very useful when you can’t tell which form you start with. E.g. 

Good that you use an initialization list! You are, however, using ye olde syntax. Use curlys, not parens, for initialization. Since you only have the one constructor, “all” of them use the same values for most of the members. Put them in the class definition as direct initializers on the members, instead. 

In real life, I use Boost’s , located in the string algos library. Not in general that you should be familiar with and with a number of Boost libraries as ever-present common code. 

Huh? A constexpr that doesn’t return a value, and an expression that does nothing? I think you want to use , not a trick to cause an error in template instantiation. 

It is normal and idiomatic to write this as a non-member taking two arguments. And, write it in terms of , which is written as a member. Likewise for the other operators. 

By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1 

There's really not much we can help you, given the low level of detail in the question. There are somethings you have in this code snippet that are generally considered a Very Bad Idea, so I'll give what help I can in that regard. Null Checks There are a bunch of these types of checks in the posted code: 

Isn’t the library a map with as the key? Yes, you are comparing it with ! Why?????? Use the normal way to an item in the container, which returns an iterator, which you can then remove. For the other version, I’d suggest implementing a general-purpose find and then remove can just call that. But then I see you do have a pair of functions, the first of which should be something the container already does directly without a linear search, and the second duplicates most of the body of . You should implement that as a private helper that returns the iterator, so you can then use that to erase etc. Then the public finding function can call that and just return . That is assuming you don’t want to expose the underlying container’s iterators to the user — but earlier I suggested providing iterators to your library. So rethink the design here. In general, you are wrapping a standard container instead of just letting the user use a standard container. You just need typedef the specific form of map, and define non-member secondary finds for matching the book rather than the key. 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

Lazy Version It's possible to build a tree in a tail-recursive manner. It's much more difficult to do that with the references to the parent node. So I cheated by making it a lazy data structure instead. The first version was pretty basic. 

Alternate Implementation Another alternative, which is arguably simpler, is to implement this as a case class with function arguments. This implementation is exactly equivalent to the refactored version above, and is arguably simpler and easier to use. 

Much simpler. Premature Optimizations If you ever have enough members in a room for the optimization to gain you anything, you'll probably be exceeding the length of the Mongodb query. This needlessly complicates your code. Ironically, any gains are lost when you forgot to use rather than , which needs to iterate through the lists you just made to avoid iterating through the lists. It looks like the accessors for the attributes already return values, so this can be much more readably rendered like this: 

No, don’t do that. Just provide the underlying (const) iterators and the user can use if that’s what he wanted to do, or whatever without having to copy the collection at all. 

Passing built in arrays as parameters actually just pass a pointer. Declaring functions like this, even if you understand how it works, is poor practice. If you declare 

I see you are generally using up-to-date C++ library and language features. But, the handler should be a rather than a . That makes me wonder if this class is doing a lot of the heavy lifting that already does, including local buffer optimizations? Could your class be built around that instead? 

Don’t use macro in C++. Don’t compare pointers (or pointer-like objects) against explicitly; rather, use their truth value (an operator bool in smart pointer types) 

That’s what happens naturally. Leave off the explicit definition (which is worse that the automatic code and also prevents the compiler from recognising the regularity) or write 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

If you used a like I suggested above, you would not need to write a destructor at all! (And, it would not automatically generate a bad copy constructor!) 

You already allocated so throwing will leak memory. Put these preconditions first, before doing anything at all. You are duplicating most of the content here. Just write it as one test: 

Two things: the is rather slow for lookup! A sorted would be faster! Boost.Container has a etc. Second, you are copying the statically-allocated lexical string literals into string objects. Do you really need here? I would (did, actually) just use a plain (pre-sorted) array of , and make the whole thing . If literals were you could at least save the redundant copy and run-time copying, but pondering why it isn’t will show you why I’m mentioning this — it needs to allocate memory, and do run-time work to set up the set. Keeping the entire table in one contiguous lump of memory will not only save memory for all those pointers and nodes, but will be much faster. 

Normally, I'd suggest trying to get rid of as much mutable state as possible. That's not really possible here, the circular reference to the parent pretty much guarantees that something is going to need to be mutable. Vanilla Version Without deviating much from your original design, there are a few cleanup suggestions that I can make. First, as suggested by @Carcigenicate , could use some naming fixes. In the version below I used , but it could have been any number of choices. I also inlined the creation of . 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: