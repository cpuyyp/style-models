u and v are the reminder coordinates that indicates where the point is whithin the i,j rectangle: Using w we can say if we are in the green area (u < (W-w)/2) or not. if it is the case we are in the green area we need to know if we are in the upper or lower half of the hexagon: we are in the upper half if i and j are both even or both odd; we are in the lower half otherwise. In both cases it is usefull to trasform u and v so they vary between 0 and 1: 

It would be better if you knew what kind of change will be involved. If your world is quasi-static you would like to distribute the basic map to all your clients and to comunicate the changes only to player that visit an area: this allow you setup map distribution services that don't use the same bandwith of your game server. In this case you can validate the client version at login and redirect the user to the map sources if major changes to maps where happened since the last login. The story is completely different if the contents are fully user generated. In both cases you have to split the world in chunks: you probably do not load the whole world in memory when you render it. Don't do the mistake to size the map chunks tailored to the client needs, changes to client should not affect the server: add a level of indirection, the client probably have to load a few of chunks to work smoothly. If you are on the web and you like to let your users to generate a lot of content, you may try to use couchdb as database backend. Using Couchdb you get a rest json based api, filtrable change notifications and using indexes you may look up the data fast. The main advantages are the unstructured data and the near real time scalability. The first one let you to add data in a way that client can process only if they know how to, backward compatibility or ligth/full compatibility for example; the latter let you build a system that can grow from a couple of user to thousands. This comes at the price of system design, the changes need time to propagate and collisions may occour so you have to think about this kind of advanced problems in the earlier stages of design: is the game worth the candle? Intermediate cases exists, here you can try to mix the two strategies up so if immutable or near-immutable content exists, you should separate it from the rest of the contents and distribute them in an appropriate manner, while using from semi-structured to structured data provider for the contents more subject to changes. 

The red area represents the distance covered in t milliseconds (the integral generalization of the formula space = speed * time). Knowing V,A, the elapsed time you can compute the distance covered (the red area) using the formula for the trapezoid area: 

Conclusions The norms computed on canvas coordinates give the worst of the results: the two coordinate systems does not match very well so the price to have a easier norm is simply too high. The Euclidean norm is the better choice but the slower one; The Taxycab norm offer a very good trade off. The "L0" is the fastest and easier but the price is to have a distance that is a little unrealistic. 

if your cubes are axis aligned then you may construct tree interval Trees one for each axis. An intervall tree is a data structure that let you query for an intervall overllapping or a point hit of a set of intervall. If you can ensure that no cube will ever have an edge less than ε then you can easely see if a cube touches other cubes by querying your trees. To understand how this works lets scale the problem down to "1D cubes" i.e. segments It the testing segments is AB then take the points A-ε,A+ε,B-ε,B+ε check the intervall tree for the hit. For every segment that matches there are a few of possible relation with your testing segment: 

Each rectangular area constitutes a choice about what of the tile's corner should be taken as shadow cone edge. This reasoning can be pushed further to connect multiple adjacent tiles and let them cast a single wider cone as follow. The first step is to ensure that no obstacles are toward the observer direction, in that case the nearest obstacle is considered instead: If the yellow tile is an obstacle that tile becomes the new red tile. Now lets consider the upper cone edge: 

In the above picture you can see how wider grids allow for random position within an area that assure you the required minimum distance even if position are placed the nearest possibile. The tradeoff of this aproach is that adding randomness (e) you loose available cells and vice versa. 

Taxicab Tile We can see even this time how the canvas coordinate gives the worst results: this is the price for an easier way to compute distances. The "Taxicab Tile" gives a reasonable results, quite similar to the "Euclidean Tile", but simply summing the tile coordinate. This is a very popular norm for this kind of problems 

The rectangle width is w + (W - w)/2 = (w + W)/2, its height is h/2; the width of the green rectangle is (W-w)/2. Is easy to find out where in which rectangle the point falls: 

In the example above you can see the shadow casted by the rightmost of the bottom wall and how this shadow delete the hidden obstacle from the list of the obstacle you have to check (X have to check;*checked). If you get sort the list using some binary partiton so the cosest X are checked first you may slightly speed up your check. You may use a sort of "Naval Battles" algorithm to check block of Xs at once (basically looking for an adiacent X that is in a direction that can make the shadow cone wider) [EDIT] Two rays are needed to cast correctly a shadow and, since a tile is rectangular, a lot of assumptions can be done using the available symmetries. The ray coordinates can be computed using a simple space partitioning around the obstacle tile: 

Talking about percentage, you can generate an integer number from 0 to 99 than subdivide your 100% into chunks of different sizes: 

I have two points A and B. I want to perform a smooth deceleration from A stopping at B over time t. The only thing I managed to do so far was a lerp, which isn't right of course because it's unnatural. I also tried multiplying the velocity by some factor (0.9 or similar), but then I don't know how to choose the factor such that the end point B is reached (or as near to it as some epsilon value seems reasonable). Does anyone have something relatively simple that I could use? I can read C++ and C# code. 

Sure there's something I'm missing about wrap/repeat textures in D3D 9. I've tried setting the sampler in the shader, i.e. : 

Shimmering I understand shimmering in textures is caused by sub-pixel accuracy aliasing against the regular grid of pixels on the screen when drawn. I have a good example of it here, whereby I'm attempting to scroll/pan a 2d texture by modifying the texture coordinates rather than by moving some actual geometry. The texture is "wrapped" and my idea was to fill in the bit falling off the left (or right), filling it in on the other side, to effect a single scrolling/panning surface of (almost) infinite size. Unfortunately with random noise on the texture, when I'm zoomed all the way out the shimmering is kind-of horrific. When I zoom in a bit it seems OK, which is kind-of confusing to me. But anyway, is there a filter of some kind I can put into my shader to prevent this shimmering? I'm at something of a loss here. (To complicate matters my texture is actually just L16 luminance and I'm palettising it in the shader - the L16 is sampled with LINEAR, the palette texture is POINT, though I'm pretty sure this makes little difference to the shimmering). Please note that with the video, YouTube has done its absolute best to remove any detail from it, meaning it's difficult to see the shimmer under the encoding artifacts. 

I tried an implementation of glFrustum (no longer available as I'm using core profile of course) as follows: 

OK, I fixed the problem by implementing a different way of doing it I found here. I've made this a bit quicker by doing the set-up of the incremental Gaussian in the vertex shader and passing that into the pixel shader (no point in doing it in the pixel shader when it's not dependent on anything else). It still shimmers, but it's no way near as bad as it was before. Not sure why (!). Also it's a bit quicker with the incremental, rather than the full evaluation per-pixel. 

I have a repeating texture that I'm using as a scroll surface. The idea is that as I pan the surface I adjust the texture coordinates, filling in what gets wrapped on the right as it disappears from the left. This is all working quite well. When bilinear filtering is switched on (D3DTEXF_LINEAR) I think the repeat filters the edge of the texture with the corresponding pixels on the other side given the wrap. This is wrong of course. I've had a look around for bilinear filtering shaders that ignore edge texels but can't seem to find anything. Does anyone have an ideas about how to do this? Is there a way of configuring a sampler to ignore edge texels when filtering? Is there a bilinear filtering shader knocking around I can use as a reference? 

I want to auto-bind uniform blocks with certain named values to certain binding points when I compile a shader. For example, I have some basic, default fixed binding points that are always used for certain things like: 

advice I had as a UI designer/developer a very long time ago is to design/develop in black and white, add colour only for emphasis. I've seen so many bits of software over the years that were destroyed by a theme, skin or graphics that the developer probably thought was a good idea at the time, but that looked pretty awful to anyone with a small amount of aesthetic judgement. The other tip I would give is to make sure all of your bitmap assets are scaled correctly, with filtering and/or use anti-aliasing. The final rule is to design "sets", so that all of your assets have a similar aesthetic. If you apply those 3 it's hard to go wrong :). (Another quick tip: If you're going to use gradient fills, make them as subtle as possible). 

At the moment I'm binding manually by finding the index of a named block with glGetUniformBlockIndex, and then binding it with glUniformBlockBinding. What I'd like to do is fetch the set of all block names in my shader program. When I iterate with glGetActiveUniformsiv, I get a list of all uniforms, which excludes block names. Is there any way to do this without testing and failing each of my above names to see if it's an active block with glGetUniformBlockIndex? There's no glGetActiveUniformBlocksiv, is there... 

I'm trying to figure out how to perform tiled rendering of my 3d scene (OpenGL). The motivation is to cut the scene up into several textures, combining them into a single image for saving at a very high resolution, or for printing. I've done some reading on this and apparently I just need to put appropriate parameters into my projection matrix for each tile in the scene. This is where I'm failing (miserably). I can't see where or what to use for it. My perspective projection matrix is pretty standard, like this: 

I thought there might be something screwy with my texture coordinates too, so I hard coded them to be 0.0, 0.0 on the left and 2.0, 2.0 bottom right. I expected x 2 repeat but got a similar result to the screenshot, with the texture top left and then what looks like clamp across the rest of the image. What mistake have I made here? (Note that the screenshot isn't the 0.0, 0.0 -> 2.0, 2.0 experiment I did, it's the general case I get as I'm panning my image around). 

The keyword you're looking for is "easing". There are lots of different easing functions that behave and look different but all of them interpolate some variable from A to B given a time T. If your ship is at A and you want it to decelerate until it hits B, you can give it a velocity by, for example, applying this function: 

But, alas I'm not sure what parameters I need to use for left, top, right and bottom when iterating across the scene, viewport or screen. Can anyone assist me? Edit: I found this example (unfortunately D3D) of someone doing something similar. The author seems to be just multiplying _11 and _22 by the width (scale up) and then modifying _31 and _32 according to the current tile position - iterating through the whole grid. I did try this but I got a black screen of doom.