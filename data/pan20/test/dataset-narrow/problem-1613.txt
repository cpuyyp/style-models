Serial is just a way to send data (often text) between two devices bidirectionally. Operating systems generally expose the serial device to user space programs for them to use as they see fit. Under Linux they can be accessed through or or . Under Mac through or similar. And under windows it's called something like . The Raspberry Pi's serial device is at from the pi's perspecitive. By default it writes the startup logs and then attached a terminal (aka a getty) to the serial device which allows you to control the pi over the serial line from a pc. You can view and send commands to this terminal from your computer with a USB to serial adapter and a serial program like or (or one of many others) on Linux/Mac or on Windows. The baud rate that the getty uses is , this is the speed of the serial connection and must match on both sides of the serial line or you will just get corrupted data. This is nice for general access to the pi without a network connection but is not the best way to control the pi programmatically. Instead it is better to write your own program to listen on the serial port on the pi and do things when it receives messages on it. Disable the serial getty To do this we need to first turn off the getty and logs that are configured by default. You can do this on rasbian by following this guide. On the latest raspbian you can do this by running the following. Or on older versions follow this 

assign 0x01 to the first byte in the array, which will basically tell the bluetooth device that you are working with a keyboard input report. the second byte is used to specify any modifier keys (alt, shift, ctrl etc.) which is useful if you need to hold down shift to sprint in the game. the third byte you shouldn't touch. The other 6 bytes you should use to specify which keys you want to simulate in form of Bluetooth key constants provided in the keymap.py file. 

I persume I have a resource leak in one of my applications but all I'm doing is communicating via UNIX sockets and an Arduino via serial using wiringPi. I've been very careful to cleanup all my memory that I allocate dynamically and it doesn't seem to be any issues with heap memory anyways since the cached memory seems to be what's giving me issues. 

Now I was back up to just about 56 MB of memory! What might be the source I am running several processes that communicate via UNIX sockets and I might just have missed a huge resource leak in one of my programs, but how would I detect it? Furthermore since I want my project to be up and running pretty much all of the time I want to somehow detect when the memory is low (say < 10%) and then run these set of magic commands to free up my memory. 

It sounds like what you are doing on the arduino is , converting the range from 0-1024 to 0-255 then using . What you are doing is converting a analog signal to a PWM signal. The function is badly named in the arduino sdk. It does not write an analog signal to a pin. Instead it sends a series of pulses, with varying width between them where 0 is fully off and 1 is full on. In some devices (such as leds) this mimics the effect of changing the voltage. Other devices such as servos and motor controllers actually expect a PWM signal to function correctly. There is no way without addition hardware for an arduino UNO to generate a true analog signal. Now, in electronics analog to digital converters and digital to analog converters convert a signal from a min to a max voltage in so many steps, 1024 in the case of the arduino ADC. Even if analogWrite produced a true analog signal, its range is 0-255, but the min and max voltage would still likely be the same - just with less resolution so all you are doing is lowering the resolution of the signal rather then reducing its voltage. Now, the pi has no ADC built into it so you need some sort of external ACD to read an analog signal, there are many such chips about and you can skip the arduino UNO entirely by using one, without having to worry about coding it at all - you can just worry about coding on the pi. Assuming you still want to use the arduino as a ADC you are going to need to talk to the pi over a protocol it understands. There are many of them to pick from: serial (UART), i2c or spi. WARNING: the arduino UNO is a 5v device dy default, its pins will read/write signale at 5v. The raspberry pi can only accept 3.3v MAX on a pin. Sending a 5v signal to it will damage the pi. You can use a logic level converter to shift from 5v to 3.3v. Alternatively, you can run the arduino off 3.3v (by supplying 3.3v to the pin label (and bypassing the 5v reg onboard) or by replacing the voltage reg with a 3.3v reg, at which point the pins will read/write 3.3v max. Serial is probably the easiest to get started with. You will want to change your sketch basically; then and finally a small to stop it overwhelming the serial line. From the pi you can read these values with any serial reading application (picocom, screen, minicom) on the device file: 

If you are using raspivid to record it is "possible", there has been a patch to support large files, where the size > 2 GB ( is required in flags supplied to gcc). However you need to compile the userland source by yourself. It shall be noted however, you should be very careful, because if you fill up the system partition on Linux, very bad behavior can occur. So you should create a separate partition for your long videos. It may also be a good idea to decrease the bit-rate if you have problems with the file size. 

Using this microphone I have some severe noise in the background. The more peripherals I plug in (camera, gertboard, wi-fi adapter) the worse the noise becomes. We've tried several different power supplies, however the problem still remains. The microphone seems to pick up some switching noise from the pi itself and from the peripherals connected to it. The most significant frequency one can hear sounds to be about 1 Khz. The noise is not present if one plugs in the microphone into any other computer. So the problem clearly lies with the raspberry pi itself. Do you have any suggestions as to what to do about this problem? I am using a Raspberry Pi Model B with old linear regulators. Perhaps the problem could be fixed by using a USB hub with an external power supply? (EDIT: So, I took a new sample from a video today and one can hear a "click" sound every second which I find wouldn't sound too much alike ground loop noise. Anyway here's a image of the frequency analysis: 

You are running out of memory and being hit by the OOM Killer in an attempt to stop your system crashing. The OOM Killer is a bit random, but is weighted by the amount of memory a process uses so if you see a lot of nginx worker processes being killed then they are likely responsible for the memory usage. You can use tools like , or (slightly nicer version of top) to see how much memory you are using and which applications are using most of it to help give you an idea of where the problems might be and if the changes you make are actually helping. Given that it is the nginx worker processes that are being killed how many do you have? I think by default it is the number of cores you have but it can be configured. Since the workers have their own memory pool the more works you have the more memory you will use. If you are using php-fpm you might want to look at the number of worker that uses as well as they share the same problem as the nginx workers. Raspberry pi images also don't come with swap space (but can be configured to have some) which can give you more effective memory before the OOM Killer kicks in. Swap space would be most useful if you occasionally spike in memory usage or have a lot of generally unused memory, otherwise it tends to hamper performance and can reduce the life of your sd card. 

In Step 20 of the tutorial you mentioned, all that is happening is that the script listens for keyboard input on the raspberry pi, and then sends that over Bluetooth. If you simply want to instantiate the Bluetooth connection and then send keystrokes programmatically and finally exit you just need to replace the call to with something like and of course manually set the self.state structure. As described in Step 17, the input reports are made of 9 bytes and prefixed with a byte indicating that the remaining bytes are an input report (). You will need to instantiate the report with 9 values and do the following things: 

The option for raspivid is used to set the output path where you want to record a video but you never set it to anything and instead you try to redirect the stream to a file. If you want really want to use and pipe it into a file you can use the option with a dash. From the documentation: 

I have my raspberry pi A+ in my embeeded project and every byte of memory is important when I've only got 128 MB to my CPU (I need 128 MB for the GPU because I use the camera module). Unfortunently the memory is eaten up by linux quite quickly. Freeing up the cache makes a huge difference Before I ran a few commands on my raspberry pi I had less than 4 MB of memory left! 

Your problem is with the Exec line. is not a valid way to execute a command with bash, you want . However the exec line already uses a shell to execute the command so you do not need bash wrapper at all and can just use: 

Then they build a docker image with your application in it, and push that to your pi restarting the container all automatically. They even offer a local dev loop where you can build the docker image locally and push it directly to the pi. 

Ensuring the baud rate matches the rate set in your sketch (9600 is a good value to start with). Use then to exit. This is useful for debugging the output from the arduino. You can then use pythons pyserial module to open the serial port read a line and do what ever you want with the value. 

You need at least two pis. Each only has one HDMI port and can only run one os/display at a time. You effectively have three entities, the media server and two displays/thin clients. Raspberry pis can act as either a media server or a thin client (or both at once). So you can connect one pi to one display, have it run as a media server and client to that display and have the other pi connect to the first over the network and act just as a client. XBMC can act as both a server and client, so you just need to get a second pi connected to the second display to connect to the first one. Note however that the pi is not very fast at network/disk access and streaming two streams over it might prove too much for it. If you find performance to be a problem you can setup a central media server (on low end hardware, possibly with more disk space) to act as the media server (with XBMC) and the two pis to just act as clients. 

I'm using adafruit's usb to ttl gadget to communicate with my raspberry pi over usb. For some reason when I plug in my Raspberry Pi Ralink RT8188 wifi dongle and reboot, I can't access my raspberry pi over usb anymore. I use screen like this to access my raspberry pi: 

That should work to record a simple video. However the simplest and most recommended way is to use the command below. 

You need to make sure the output pcm points to the speaker/output device you want the audio to go to. You can use to get a list of available output devices. You can know use avconv or ffmpeg to record audio from any application and also routing the audio to an output device. Here is an example: 

Any reason why I can't access my raspberry pi over usb when I am using a wifi dongle? EDIT: dmesg output before WiFi. Output of before WiFi: . dmesg output after WiFi. Output of after WiFi: It seems like it kindof works when having the wifi dongle, except the output is totally broken (logged in and ran command ): 

I found this article online and decided to give it a shot and run the commands they recommended and the result is mindblowing. 

This would simulate that you hold left shift and the key. You should probably use for readability. For further information I found this github repository which I think could be useful for you. Also you should read the documentation for python-evdev here. Unfortunately I can't test this as I haven't got a raspberry pi available now, but I think you should be able to figure it out, good luck! 

Note that you might find that the terminal window closes right after the last command finishes. If you want to keep it open you can add (depending on your terminal) or (depending on the terminal application you use). Alternative you can append to the end of the command to keep the terminal window open waiting for some input. This will work even if your terminal does not support an option to keep it open. 

From here you can run any command to manipulate the image. Once finished setting it up how you want exit the chroot and do some cleanup: 

The usb on the raspberry pi is not connected to the main cpu, it is connected to a usb hub. USB hubs are slave devices to the main cpu and cannot reverse this behaviour. OTG is basically a direct connection to the cpu which can act as either a master or slave device. USB is a high speed protocol, it requires specific hardware to meet the required timings involved. This hardware is used by the usb HUB and not exposed over the GPIO pins. If you are allowed extra hardware you can use a microcontroller that can act as a usb slave device and connect it to the pi over serial, i2c or spi. Some possible boards you can use for this are the arduino leonardo (or any based off the atmega32u4 chip set) or the teensy. Depending on what you want to achieve the programming of these might be simple to very advanced depending on if there already exists a library that does what you want. If it is a simple dumb connection you need you can use a usb to UART adaptor. If you are not fixed on the pi 3 you can use the pi zero, which does not have the usb hub and instead exposes the usb OTG directly.