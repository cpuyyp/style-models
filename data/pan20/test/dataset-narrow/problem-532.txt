That also uses the java concurrency framework to process the parts. The block that create the task list is very hard to understand, and if you want use something like that should be extracted to a separate method. The log output of the execution time per Blok is wrong. schedules the execution. The block execution is finished when all returned futures in the returned List return . The loop blocks the execution even when there are available threads. The operation is blocking. Even worse the first element in your loop may block the execution even all the other futures are already finished and the Threads are waiting in an idle state. Your are not interested in the result so why not using ? It's not clear why you are using this "Batch" approach. If you want to limit the number of scheduled tasks you can use limit the queue size. The handling of the in the form you are dealing with it is considered bad practice( see Brian Goetz article about "Dealing with InterruptedException"). Last but not least a design issue: Your Controller must not create a new instance of the provided interfaces - it does not even know how to create an instance of these interfaces. The two biggest issues are that your code blocks the processing even in cases where it is not necessary and the handling of the . 

Usually there is no need for an explicit Array of numbers. The index you use to accesss the elements in the is the number you are testing. To make it explicit instead of 

seems to be wrong. You unconditionally assign the value of and afterwards you check for and repeat that assignment. Disadvantange of the suggested approach is that the array contains two additonal elements for the numbers 0 and 1. For the execution time this is usually is negligible - especially for big s. For your Questions 

You are not really waiting for all threads to fininsh. If one of your threads run in an timeout you simply ignore it. You can fix this by stetting a flag that signals your thread to terminate. I've done this by adding a class which and extend and which have a flag that signals them to terminate as soon as possible. Your contains only one value which is overwritten by the Producer Loop via the method, nothing prevents this. The calls are useless because nobody actually waits for the There are a lot of issues in your code so I've decided to rewrite it in a way that actually works. It uses a Queue to transport the elements from the to the The notifies any waiting Consumer via about new Elements. The uses an Index to determine whether he should pull elements from the queue and increments the after he has taken the 10 elements from the queue. In the I give you an example how the in Java can be used, and a possible way how to deal with s. 

First of all it would be good to use the standard Java Conventions, i.e. method names start with a lower case letter. i.e. shold either be or simply . Also handle InterruptedException correctly. For details have a look at the book Java Concurrency in Practice In your case it does not make sense to catch the you can simply declare it as thrown. The ArrayList for the threads is not necessary, you have a fix number of Threads, you can replace it by an Array. 

One more note about the rest of code: I don't like how you use plenty of additional temporary vectors. When you want to enjoy C++ performance boost, you have to be a bit more aware of data structure, as that's the major advantage of C++ over other high-level languages. Usually the sorting algorithms are implemented to either work above the initial container memory without any temporary, or when temporary is required, only single secondary vector of full size is created. Then internal calls pass the first/last iterators to point to the parts of the vector memory, which should be processed in the particular inner call. If you need temporary vector, one of full size should provide enough temporary space for the operation, being properly partitioned by first/last iterators. I'm sorry to not provide the example, but I believe you can find some merge sort implementations on the Internet, probably showing operation on 1-2 vector's only without the copying of content between internal calls. 

performance ideas (from comment): If you are already assuming ASCII alphabet-only word inputs, you may do direct , which will yield only values, and for vs it will produce the same values too (functioning as fake ). I also personally prefer non-else/non-nested variants (when they make sense), so I would do and the would go after that in the loop block. This is part of answer is level golfing advice, i.e. lowering readability and robustness of source for some hypothetical performance gain, not suitable for real world production code ;). 

one way is class holding the actual string, responsible for manipulation with it. other way is helper utility class providing only functions, not holding any string at all. 

Which would use getters to set up the exp bar, exp number display, level number display, set up correct colours based on those, and finally to start some effect when would be true (having that "effect" as an stand-alone app entity, capable to handle it's own life cycle, like some animation of fire works or sound player playing ding once). In case of some more complex level-up effect I would consider either making state of it part of original model, or having separate LevelUpEffectModel to hold state of effect, with it's own view and controller. Controller: Finally controller is the glue of view and model, but should not contain any biz-logic, or low-level view updating commands. So in this example it would do probably things like: 

I had only some limited quick look, just cherry-picking some things to comment on: Entropy level: I'm not expert on this topic, but I think using time stamp as additional entropy source every time you produce a number is not a very good idea. But I'm even afraid you use it as only source of entropy in some cases, which is definitely wrong. I was unable to quickly show what's wrong about it, as you have weird way of updating, masking the problem out in your example. But after you change this I'm afraid it will become obvious this needs rather some "seeding", and building up upon seed data. About : You do great deal of pushing all around into it, yet only pops from it, and only once. So after running this for a while (using it as output stream, without calling RNG) the buffer will grow a lot, eventually running out of memory. If this one is supposed to be a buffer of pre-generated random numbers, then the should generate new buffer value only when buffer is empty, and then it should pop value from buffer and return it. But I would do something different, I would change buffer into single number, used as seed. At any point of your current source, where you end with buffer.push, you would instead use old value of buffer as input for the transformation (in some way), storing result back to buffer. Then will do yet another transform over it, and return the value. But at this moment the timestamp-every-call will start affecting the statistics of random numbers a lot for particular date-time and RNG calling period. So I would use timestamp only for initial seeding, then the RNG would work as any common pseudo-random arithmetic RNG, with added twist of output stream being further source of entropy. About output stream as entropy source: well, you should check the common output stream byte values first, they are not "random" bytes. From the code it looks like you are aware of that, trying to build an unsigned value ORing 4 shifted values, but the result is only 20b wide for ASCII, and the values are overlapping, so the upper bits of ASCII (not varying much) will affect the lower bits of next character (I hope I did read the source correctly, didn't debug it, BTW for better readability you should put these transformations from string to unsigned into some function, so you can test it on it's own). I would probably take only 3 bits (or maybe just alternating 2+3, to avoid ASCII specific values definition to affect the entropy of such value too much) of each output character, and cumulate them in 32b buffer till it's full (the overlapping 1-2 bits kept for next value), then use it for transforming the seed buffer (so roughly every 10 output chars the seed will get additional entropy). This may still go quite wrong with UTF-8 or unicode16/32 output stream variants, just imagine somebody using it with UTF-8 Arabic texts, having every second byte something like or what's the actual prefix (too lazy to check). About : 

Additional indentation levels add complexity, which increases the work you must do to understand the code. 

Please use understandable naming. When I saw used in , I had to go back to find what it was really doing. Give it a name that specifies that it is the graphics side of the program right in the name. The same applies to various other names in the program. 

What happens when the input is formatted incorrectly? Does your program handle this use case? While this program may not need to have intensive error handling, many programs do, so this is a point worth mentioning. If the user left out one of the numbers in one of the arrays, it appears your program would throw an exception when you are filling your 2D arrays: 

Fourth, the HTML you posted needs to go in the element inside your tag. This is how your file should look: 

First, this code seems a little squished together. I would put newlines between my methods to make it a little clearer where one unit of responsibility starts and the previous one stops. Second, please use your braces. And if you aren't going to use braces, then consistently don't use them: 

This is in the same class as the value and directly accesses the value. I know that I could expand it to take any , but I haven't because cannot be passed by reference: 

My latest inspection for Rubberduck determines whether a procedure should be a function by checking whether it has a single parameter (either explicit or implicit). The quick fix takes this procedure, changes it into a function, and updates all calls. This inspection starts deep down, involving the parser: 

What happens when or throws an error and the value isn't really disposed, but is still set to ? What should happen here? 

However, now you are exposing your call stack to the user, which you don't want to do. This information could provide hints to someone trying to break into your system, and is not allowed under some security protocols (SOC 2, for example). Instead of returning the whole exception, build a new piece of data and return just the relevant bits (or if they just need one piece, then just return that piece). 2) Don't return . Either return an empty object (if the caller doesn't care if there were no results), or throw an exception. Alternately, you could use a and return from the method. The first successful path would return and the second would return . 3) You might have a SQL Injection attack going on here. Check out what happens if the client sends a request with the text parameter "test' or 1 = 1 --". It looks like the resulting query might be , but I don't know this well enough to be sure. 

Turns out @Mat's Mug posted his answer first, but I'd already written this, so it won't hurt to mention it again. You do not always put braces around blocks. While braces are not required, it is good practice to always use them: 

You can assign a value to directly through your setter, why are you bypassing the setter and modifying the backing field? This is another excellent place to use an auto-implemented property. 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

I found another bug in your source: will be always false. Unrelated to your bug, I have read an advice somewhere to always use only "<", "<=", "==" and "!=" in comparisons. It felt strange for few weeks, but once you get used to it, it really makes easier to read sources, as you know the values should only increase from left to right, if the expression is true. So I would write your expression as: . 

Well, the runtime of your code can be maybe improved a bit by cleaning up the current code a bit, but the main bottleneck is the inefficient algorithm, so I will not comment on your particular code and style, and I will focus on the algorithm only (if you still insist on code clean-up of current version, let me know in comments, I may try to rewrite few bits of it more to my style to show you a thing or two, but I think reviewing better algorithm would make more sense). Also I would focus on the search algorithm, not on the init. I'm afraid with huge word list even init can be very costly, and worth optimization, but the initial data may be preprocessed ahead, so you then read not only word list, but complete definition of graph with edges between them. You should have posted, if the init itself is important for you as well (can be worth of effort for application where input word list changes often, so graph has to be rebuilt often). Imagine the words as nodes of graph, with edges between words different only in single letter (obviously words of different length form a completely disconnected sub graph, but even with words of the same length the graph can have several disconnected sub-groups). If a starting word has a ladder to the ending one, both should belong to the same sub group of graph. So first optimization may be to store each sub group separately (for example: having for 4-letter words two or more graphs). Then in O(subgroup_size*letters) you can tell if starting word belongs to the group under scrutiny. (with global hash map of words containing index to subgroup and index within subgroup the O(...) can get even lower, depends on hash map search implementation, but the initialization will get longer). Now the ending word must belong to the same subgroup, otherwise the ladder path does not exist at all, so another search of word ( O(subgroup_size*letters) ) will tell you, if the solution does exist. And also you will have both nodes (starting and ending word). Now you should do a "path between nodes" search, I'm not sure if the shortest one is required, or any will do. For these situations something like A* path-finding algorithm can be used. I didn't check A* lately, so just from my head some idea about such algorithm, basically searching the graph from both ends, in a deep/wide way by word_distance: You have to create some and set . will be distance (number of nodes) from starting point. Also set and marks whether belongs to the starting node, or to the ending node. Put both indices in the deque. Now till the deque is not empty, pick the index out of it and it's color. For all it's neighbours: