Thinking outside of the box here: Can't you just run it in a screen session and detach screen when you want to turn your Windows off, so the program will keep running and not turn it off? Check the screen manual on how to detach/retach. Screen is one of the most used utilities when you have a remote machine. 

Depends on what you use your Pi for. If you use it to develop, like I do, and for that use git or some other distributed version control system, it gets pretty annoying to have a new commit dated 3 days ago. If you need public-key infrastructure certificates, that have begin and end times on them, you will have expired or not-yet-valid errors at some point. If you run a backup application, that needs to schedule when to suck data from your network and store it elsewhere, you will need accurate time to make sure you won't do that right in the middle of the day, where open files are everywhere and network bandwidth might be affected. But yes, for all those reasons NTP isn't necessary. You can setup a rdate or ntpdate on boot and not have ntp trying to compensate for clock fluctuations of your processor, at you will do just fine. But there is at least one use that I can think of that will need NTP-level accuracy: parallel and distributed use and processing. Be it a load balanced web server, be it a file storage system, be it a file mirroring task. For most of the other cases, you can just replace NTP with something else, like I suggested earlier, rdate or even ntpdate. The latter seems to be easier to get going these days, given that NTP is pretty standard and rdate protocol ports are almost certainly filtered or closed everywhere around. I have had one Pi running unsynced for some time, on a air gap security application. The experience was awful, even if the application did not need any sort of time-accuracy. I would get crazy trying to figure out the creation or change dates of files, trying to figure out information from logs (when did that happen?!) and all sorts of things that you usually place in a window of time to understand or analyse. 

Which doesn't seem to be availabe in the stock kernel. From what I have researched, achievements of the RT_PREEMPT development have been gradually ported into the kernel, and I feel that the PREEMPT is a first-step towards preemption that has appeared. RT Kernel wiki states, about CONFIG_PREEMPT: 

accordingly. Remember that all the configuration files in /etc/openvpn will be executed automatically at boot-time. 

To find out all the packages with "curl" in the package name. You are probably looking for one of these: 

You should clone and checkout each one of the 4 repos and take a look at the patches on them. The thing with patches is that they are really only guaranteed to work with the exact version of the code they patch. So you have to find out for which exact version of each of the components (the Linux Kernel, D-Bus and eglibc) each of the repos is currently targeting, then grab the source code for that exact version of the component and try to apply the patches against the specific version. If you are lucky, you may find the source code the debian way, except for the kernel. You will then have to compile the sources to get the resulting executables and install the executables. The Kernel is a bit tricky, but D-Bus and eglibc can be done the debian way. For the kernel you will have to follow this tutorial, the Local Building item. If you need something more verbose, try this one. Remember that even though you might find the exact version of the kernel to patch against, Raspberry Pi's kernel is not the default stock linux kernel. So, even if you have the exact version of the kernel for the patches, patching might still fail. And, if that happens, you will have to go down the code yourself and decide what changes have to be made to the patches so that they will apply without error. Remember that if you have a rejected patch, your objective will most likely not be achieved. What you want is no easy task, and would take some time and some trial-and-error iteractions even to the most experienced kernel programmer. 

You can use the Raspberry Pi as you would use any other Linux-running computer, notably the PC. The main difference between a PC and the RPi is that PCs run on x86 or x86_64 (AMD64) architectures, and the RPi uses a ARMv6 processor. So if you have a pre-compiled application for the PC, you will have to try to emulate a PC somehow on the Pi to try to make it work. And this is far from being simple, not to mention efficient. You will not have commercial scientific applications like Mathematica, MatLab, LabView with versions compatible, for example. On the other hand, you have open source alternatives that are pre-compiled for the Raspberry Pi and can be installed with a simple command like GNU R, GNU Octave, SciLab and other great software. A special mention to Python, as I can presume by your tag on the question: being an interpreted language and working perfectly on the Raspberry Pi, you should be able to run your python-programs without any change. Also if you have the source code, you most likely just need to compile it on the RPi, or Cross-Compile it on the PC targeting the ARMv6 architecture, to have it running, just as you would on the PC. Resouces of the RPi are, obviously, very limited comparing to what you have on a PC, in every term conceivable. 

As pointed out by BHP in the comments, it is/was a link bug, according to the forum post. Given that the current version in the repository is 1.3.3, it is most likely solved. Please tell us if the problem persists. 

And then try to compile the software again. If that doesn't work, try to install the "libcurl3" as a second option. 

Now go to /etc/openvpn and edit the file to your configuration. Everytime your RPi boots, init will run OpenVPN with all the configuration files in that /etc/openvpn directory, if you don't act otherwise. So, it will automatically start that OpenVPN configuration client.conf that you dropped in there, in the background. If you want to start/stop it manually, try: 

You can begin your Bluetooth development reading An Introduction to Bluetooth Programming by Albert Huang, chapter 4 deals specifically with BlueZ. Also, take a look at BlueZ less then optimal development page. 

Short answer: This is a bad idea overall. And a terrible idea in terms of stability. Long Answer: Memory swapping is something like a last resort measure when your system will run out of RAM available to load all the programs and their data. How well the Operating System manages the swapping pages will be a determinant to how fast your system will perform. So your OS will get one page of the memory of a program and will allocate that page on the disk, and free RAM space for another page, and the algorithm responsible for that will choose which pages should be swapped to disk and which will remain in RAM. If a page that was transferred to disk needs to be used by its owner, the OS will then choose another page and put that other page on the swap file/disk/partition and will put that particular page your program needs back into RAM. Note that the time needed for this operation in tremendous, compared to RAM-scale times. Now you will have a REAL PROBLEM if, once the OS tries to locate the page on disk, that page, for any reason, is not available. This will most likely result in a kernel error, and a kernel dump on the screen, crashing the OS. So, if you have a network issue, and thus your swap file gets disconnected, this will crash the system. As for your other question: I don't think Linux will ever swap the kernel or its loaded modules to disk, but I am not positive on this one. 

You can check what preempt is currently "active" by checking the kernel's configuration from /proc/config.gz: 

Given that your sensor is a DS18B20, and it is a 1-wire circuit and that 1-wire is a protocol that can do multiple adressing on that same bus and that the 1-wire temperature kernel module can read as many as 10 temperature sensors on the same bus. (check line 49 of the driver source code). If you just connect 10 of your sensors to the same 3 pins (3v3, GND and the 1-wire IO pin - which is pin number 4 on the connector (this is hardcoded in the driver!) and you will read their outputs from /sys/bus/w1/devices/28*/w1_slave where the 28* is the individual unique 1-wire address. Check adafruit's excellent tutorial. Don't forget the 4K7 resistor pulling up the data pin (number 4 - ONLY ONE!), as the internal pull up of the Pi gives you roughly 50K, and that is too much for the sensor, so you will need this extra component. You should just make sure you are not trying to use parasitic power. If you connect the 3 pins of all the devices, you should be fine. 

Your application of the real-time term seems to be correct to the sense that real-time is not necessarily very fast as many believe, but it is something that has to be done in a specific time-frame, be it microsseconds, be it seconds, be it hours. Your 5-10ms time requirements is not really fast, but your real-time constraint have to be taken in account. Java is not really the nicest play for the RPi, being very heavy on the processing and memory sides of it. If, as you say, you need to be sure that your signals are processed in the specified time frame, you should take a look at real-time solutions, which neither the stock Linux kernel, nor the Java Virtual Machine are of any use for. It is true that 5-10ms are big for the usual application, but you should consider that in a non real-time system, some runaway process, some crashing VM or blocked I/O call can take much longer than that time frame to solve and, even if your average tested response time is within that requirements, you may from time to time, face an exceeded response time situation for your cyber-physical interaction. If it is crucial for your application to stay in that RT constraints, neither the stock Linux kernel, nor Java will be a good fit for a development solution. Being that the case, you should think of real-time solutions. I have been in that position before and what I chose to use is a lower level RT data acquisition and actuation sub-system and a higher level supervisor that received information from this lower level out of a real-time context. I use Xenomai as real-time supervisor, you can download a SD-ready image from this link and test it on your RPi. I then developed the acquisition and actuation sub-systems under RT Xenomai and the higher level supervisory/communication in Erlang, which is itself a soft-real-time virtual machine. In a less constrained real-time application I used Erlang top to bottom. The Erlang virtual machine is a soft real-time interpreter, and has given very good and steady results on my tests, when it is not crucial to be in the time frame. It has very good support on Raspbian.