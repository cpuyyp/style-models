I don't see what you will gain with your hypothetical syntax, let's say there is one... your code will look like this: 

Perhaps you want to decouple the point calculation methods from the array altogether. This can be done easily enough by passing instead of , as that is all the actually cares about, although this solution will break as soon as point calculation will need more information... 

Succinctness As rubyists, we love being succinct, and we love playing with enumerations. You will see very few literal and in ruby code, as well as very few explicit calls. For example: Instead of writing we will prefer to compound the condition to which will do the same thing, but we "save" . The power of Enumeration Ruby has a very powerful , and is used widely, often more than once in a line (using method chaining). For example: 

Readonly properties This is also recurring in your code - property getters for members which are initialized only upon instantiation. If you replace them with members, you can make your code more succinct: 

And we have another one-liner! Everything is an enumerable So you want to save on your "upto-loops"? Let's do it! You want to enumerate over each pair of numbers from to , so what you actually want is to have a long matrix of those pairs: 

Naming Your naming is quite verbose, which is good (not counting ), but sometimes, although the name looks meaningful, it actually does not convey any useful meaning: 

I like the way you fill the hash, though I wish you had named your parameters better - is an obfuscated choice. Also, you could have refactored it into a method Having is not inheriting - Your class is curious - you opted for it to inherit from instead of having a , and then you override to do something not very Hash-y... The names you chose for this class are very generic and obfuscated... I would have written that class like this: 

Others have suggested different strategies, I'll comment on your code: Meaningful naming and are abbreviations, which are rather ambiguous. Better call them and . The name of the method () adds to the confusion, since it is not apparent what exactly are you adding. is more descriptive. Method names should be actions (, , ), but variable names should be nouns ( instead of ). This is especially important in ruby, where the same syntax might either call a method or refer to a local variable. Make your code human-readable The innards of your method are quite 'magic'. For the casual reader there is no way to understand why what you do there works. A lot of s and s, and and with no rhyme or reason. Build your solution in a way that a reader who is not familiar with it will understand what you are trying to do. Otherwise, she won't be able to maintain your code when needed. You won't be able to maintain it to in a couple of months, or even weeks. Break it up to meaningful helper methods. Try to keep meaningful structures (if you are concerned with whether the ID is odd or even, maybe a better solution will not include flattening the store in the first place?). If you find that you are still left with unintelligible code (and only as a last resort!) a couple of comments explaining what you are doing and why may be very helpful. Redundant logic 

Who should use scanner? As was already suggested - should be a local variable. I don't agree with the suggestion to pass it around as an argument, since I don't think the other methods have any business prompting the user. should do exactly that - check that the number is valid! What's the meaning of -1? From reading your code, I can see a little problem: 

Or you could use an extension method, which will result in a cool usage syntax, and make clear from where you are extracting the : 

And what happens if repetition is not expected? This is actually not defined in your description as well... By looking in your code it means that if there is no repetition, anytime between start date and end date (or forever) is considered valid... Maybe a better name for the method be ? When enums don't matter You have declared two enums - and . One observation - naming conventions for enums is CamelCase, so the names should be and . But, look at what you do with - you translate it (not in a very DRY way) to , you should consider to drop it all together and use the Calendar constants from the start... What exceptions are for? and throw . Why? Again, all dates are legal. Exceptions should be used in case where something prevented the method from completing its promise to its caller. For example - would throw an exception when the input string is not made of integers - it simply can't parse it to a valid integer. The same way that a will throw an exception when the file was not found where expected. Here they are used for completely expected values - the input date is either a match to the indicated repetition dates, or it isn't. Exceptions break the flow of the method, and need to be handled. They are also very inefficient at runtime. These methods should simply return , just like their caller. Simplify you API according to use-cases To set a weekly repetition, you expect the user to call two methods - and then remember to call . This is far from optimal to your prospective user, and very hard to enforce statically. The reason you chose this way is because that is the way your class is arranged internally. If you think about the API from the outside, maybe a better set of APIs would be , and . This way, the user will set the relevant days in the same call where he sets the repetition type. It would also make it easier to expand your API in the future to ... 

Accessors in C# You should read on accessors in C# - your setter does not do what it should - it should set the value if . If this has no meaning (you can't change the value of - you should drop the altogether. Correct use of accessors: 

You should expect Starting a couple of years back, is moving to a new expectation syntax, you should consider porting to it: 

Both of these solutions will give you the needed matrix, so we can move on the see what we should do with it... We want to get the coeffiecients that produce the number of primes, so let's do just that: 

I think your code is very nice, succinct, and ruby-like. Two minor issues - Your code is a bit over-sophisticated, which makes it not very readable, and quite brittle. Although it won't fit in one line - a solution will be more suitable here: 

I also think that you should consider not save the in your map, but rather a of it. Less boilerplate Your code has a repeating pattern which is something like this: 

Naming You should give variables and methods proper names: Consistency Your class contains a method and an method, but also a variable and a method. Either rename to or the other way around (not including the class name of course). Typos It is a very awkward "oopsy" moment when you find a typo in your code, even more so if it is a method name which is already in use or overridden - so re-read your code and try to find them before they become harder to replace... ( should be ) Convey meaning Your variable/parameter names should convey the meaning of what do they hold, and how they should be used. is maybe technically accurate, but does not help the reader know what it is for. Perhaps would do a better job. is also a little too generic, and might be more appropriate. is also very technical, and I think that is more readable, and gives a better flow to the calling code. Don't be lazy In most cases it is a bad idea to shorten words in variable names, as they make the name less readable - don't use - say . Don't repeat type in the name There is no need in repeating the type of a variable in its name - does not reduce anything by omitting the word from it. Comments When you have good naming to your classes, methods and parameters, you will find that most method comments are simply re-iterations of the method signatures. Likewise, when you find that a method/parameter needs extra explanation in a comment, it might be because it has a bad name. So, is very self-descriptive, and doesn't actually need any documentation. Comments have a nasty habit of rotting - when you change the code, you tend not the maintain the comments, which after awhile will stop describing the code, and sometimes even totally mislead the reader. (see , for example) Encapsulation Keep internal data of a method inside it - don't expose it in your signature. and have no business in the method signatures. One is totally internal, and the other should be instantiated within the method and returned rather than passed by reference. Declare variables only when they are needed There is no need to declare variables at the beginning of a method if they are only used at its end.