Is there a class of languages $L(G)$ admitted by a class of phrase structure grammars $G$ equivalent to $\mathbf{PR}$? (the class of primitive recursive languages = $\mathbf{LOOP}$)? In greater detail: given the well known definition of a grammar $G = (N,\Sigma,P,S)$ with $N$ being a finite set of nonterminal symbols, $\Sigma$ being a finite set of terminal symbols with $N \cap \Sigma = \emptyset$, $S \in N$ being the start symbol and $P$ being a finite set of production rules $P = \{(l_0,l_1,…,l_i)\times(r_0,r_1,…,r_j)^{*}\} \subset \alpha N \beta \rightarrow \gamma$ with $(l_i)\times(r_j) \in (\Sigma \cup N)\times(\Sigma \cup N)$ and $\alpha, \beta, \gamma \in (\Sigma \cup N)^{*}$, does there exist a set of further conditions on $\alpha$, $\beta$ and $\gamma$ only dependend on any of the $l_i$ and $r_j$(in other words, it is a purely syntactic restriction) such that $L(G) = \mathbf{PR}$? Clearly, since $\mathbf{CSL} \subsetneq \mathbf{PR} \subsetneq \mathbf{RE}$ and both $\mathbf{CSL}$ and $\mathbf{RE}$ admit a grammar formalism (namely the noncontracting or monotonic grammars and the unrestricted grammars), I wondered whether such a formalism might exist for $\mathbf {PR}$ as well. Contrary to the classes of $\mathbf{CSL}$ and $\mathbf{RE}$, the only known definitions of $\mathbf{PR}$ seem to either use nested functional equations or abstract programming language constructs instead of formal grammars. Extensive search in the academic literature, forums and online didn't gave any answers. It seems this question is an open problem bare of any interest. I know that many arithmetic functions over the natural numbers can be defined using $\mathbf{PR}$ nested functional equations and that such arithmetic functions can also be defined using string rewriting or formal grammars. However, given the potential complexity by applications of either definitions of $\mathbf{PR}$ and the additional complexity arising by trying to delimit them from $\mathbf{RE}$, it seems unclear to find a phrase structure grammar formalism which generates exactly $\mathbf{PR}$. 

I apologize ahead of time, if there's no single question here. COMMENTS Logic is a very broad subject, but I'm not a logician so I'm not sure how to be more specific. Ease of use is a priority, which is why I consider just bootstrapping Boolean logic. I think that when we "call out" a proposition... the conclusion may be true, but the thought process may be wrong, as VijayD suggests in the comments. It's not clear if bulls**t is the same as uncertainty -- we may be quite sure the proof is wrong. I think it would be nice to see an extension of boolean logic, which assigns a value to proofs rather than statements. A proof where all the steps are valid gets assigned a value of T, if steps are faulty, we'd like to measure to what extent the conclusion doesn't follow from the premises. This idea must have been tried before. A Google search comes up with the notions like heyting algebra, topos, multi-valued logic and even more sources in the comments and answer. 

This produces a sequence of fair bits from biased bits *even if you do not know the bias $p = \mathbb{P}[x_i = 1]$ as long as your sequence is 

union, $L_1 \cup L_2 \in \mathbf{DCSL}$ intersection, $L_1 \cap L_2 \in \mathbf{DCSL}$ set difference, $L_1 \setminus L_2 \in \mathbf{DCSL}$ (or $L_1 - L_2 \in \mathbf{DCSL}$ to remove ambiguities with left quotient) complementation, $L_1^c \in \mathbf{DCSL}$ concatenation, $L_1 L_2 \in \mathbf{DCSL}$ Kleene star, $L_1^* \in \mathbf{DCSL}$ intersection with a regular language, $L_1 \cap L_R \in \mathbf{DCSL}$ (bonus) left/right quotient with a regular language, $L_1 / L_R \in \mathbf{DCSL}$ and $L_R \backslash L_1 \in \mathbf{DCSL}$ (bonus) reversal (bonus) homomorphism, maybe $\lambda$-free homomorphism (bonus) inverse homomorphism (bonus) substitution, maybe $\lambda$-free substitution (bonus) 

There does seem to be a lot of information regarding the closure properties of both deterministic context-free and nondeterministic context-sensitive languages. However, the literature is almost mute on the subject of the closure properties of deterministic context-sensitive languages. In fact, I have spend days looking for it on the internet and in the standard reference books about formal languages and theoretical computer science and didn't find anything complete or related enough to bother using and I wasn't able to find results let alone proofs for most properties myself either. So, let $\mathbf{DCSL}$ denote the class of deterministic context-sensitive languages, then given two arbitrary languages $L_1, L_2 \in \mathbf{DCSL}$ and a regular language $L_R$, what are its closure properties under 

The language $ \mathtt{MOD_p} = \{a^{ip} \mid i \geq 0\} $ (for some prime number $p$) can be recognized by a $ O(\log p) $-state bounded-error quantum finite automata (QFAs) but the proof is non-constructive. The best known constructively obtained number of states is $ O(\log^{2+o(1)}p) $ for bounded-error QFAs recognizing $ \mathtt{MOD_p} $. REF: Section 4.2 of (Ambainis and Yakaryilmaz, 2015). 

As far as I know, it is not known whether $ \mathsf{NP} \subseteq \mathsf{IP(2pfa)} $, where $ \mathsf{IP(2pfa)} $ is the class of languages having interactive proof systems with some two-way probabilistic finite automata verifiers (Finite state verifiers I: the power of interaction by Dwork and Stockmeyer). Does anybody know any progress on this issue? I know the following results: 

If the number of matrices is fixed (i.e., given a part of the input), then the problem was shown to be NP-complete in The complexity of the max word problem and the power of one-way interactive proof systems by Condon (1993). You can download the related technical report (1990) for free. The first paragraph from the technical report is as follows: 

What is the simplest computational model for which the emptiness problem is undecidable? Emptiness problem for a computational model (e.g. finite state automaton, alternating pushdown automaton, bounded-error quantum automaton with a counter, deterministic LBA, etc.) is to determined whether, for a given such machine, the language recognized/defined by this machine is empty. Here the description of the machine should be finite! I know that the word "simplest" is a little vague. There could be more than one answer for some incomparable computational models. As a special remark, I believe that the question would become more interesting by focusing on unary and binary alphabets separately. Note that there are many computational models for which the halting problem is decidable but the emptiness problem (and some other problems) is (are) undecidable, e.g. Linear bounded automata (LBAs). 

I have a sequence of numbers $x_1, x_2, \dots, x_n, \dots \in \mathbb{R}$ I would like to extract fair bits from that sequence. 

The sequence of numbers I have is the hourly readings from a sensor, so it exhibits cyclic behavior every 24 hours + every week. If I compute the expected value over time, it may be possible to subtract out the daily and weekly cycles leaving sequence of loosely self-correlated real numbers. How can I extract randomness from here in a simple way? 

I was reading Harry Frankfurt's On Bulls*t, a 1986 philosophical essay about this blurry notion between truth and falsity. This is not a gratuitous exercise. This may have applications to computer science, since we are always piping data-sets into each other. Some of these data sources may be specious, the piping process can break down, or the conclusions we draw from them can be wrong as well. One way of approaching Frankfurt's theory may be to express in terms of logical circuits, where the integrity of the gates or the inputs may be in question. On pencil and paper, we mostly use boolean logic with values $T,F$ and gates $\mathbf{not},\vee,\wedge$. Maybe it is possible to perturb boolean logic slightly to model how circuits are robus or break down with respect to noise. Do logical theories exist accounting for doubt and uncertainty? Can we measure how much a lie hurts the integrity of a conclusion? I'm sure that even with a collection of verifiably true or false statements, it's possible to write arguments (and conclusions) whose values are in the middle. Or even to decide if one argument is "more" valid than another.