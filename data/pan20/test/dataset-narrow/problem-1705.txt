What caught my eye is the "stability" measurement. I'll let it run for a while to see if it becomes non-zero, hoping it might address Question 2 below. edit 2: Looking at the question timed out, nothing received on ntpdc> loopinfo? I found the command 

Comments by @Joan (above) were extremely helpful! MCP3008 does indeed use , where I had it erroneously set to . The following works very nicely! 

appears when trying to kill it. So for almost a minute, the DAEMON is a zombie (so to speak). This means that the idea of quickly turning it off and then on again is a bad one. Instead, if the OP (me) really wants to do this with Python, the script has to honor this transient zombie status and not just start and stop it willy-nilly. 

Today's announcement at raspberrypi.org: Raspberry Pi 3 Model B+ On Sale Now at $35 describes several improvements. In the linked YouTube video changes to the power supply are discussed between and , but I'm not quite sure which parts are historical review, and which are related to the most recent changes. Could someone point out which are the main points they make here about the new Pi 3B+ power supply? 

It turns out that this sluggishness in the pigpiod DAEMON's status is real. It's not a problem in the script. I saw this by accident while trying to stop and then restart pigpio while debugging a DHT22 script. Here's some text from the Pi's terminal. After the killall, pigpiod can not be started between and . The message: 

I'm trying to learn how to safely and reliably start and stop the pigipod DEOMON process from within a python script. If pigpiod happens to be running already, then this script is always successful. It stops pigpiod and then starts it again. But if pigpiod is NOT running when I run this, then MOST of the time it fails, and the standard message block that starts with "Can't connect to pigpio at localhost(8888)" appears when I try to instantiate pi = This happens even though returns , there are no exceptions, and a was executed "just to make sure". 

My Raspbian Pi crashes to a Kernel panic when I start it up, and it suggested somewhere that an invalid cmdline.txt can cause this. What is in the cmdline.txt by default? 

Is there a way to monitor the current CPU core voltage and overclock, similarly to CPU-Z but for the raspberry pi? This is so I can check that nothing is limiting the overvolt or overclock. 

I can make new files, folders and install new software but I can't download files from the internet (Using Iceweasel(Firefox) and Midori). When installing new software at some point it says something like "man.db: not enough memory". Also when starting the Pi, "[warn] Root filesystem full...warning" comes up. I use rasbian wheezy with a 16GB SD card. I always use root user. Any ideas what the problem is? df command output: 

Depends how mobile you need it to be. If you don't move it too often or too far, it could be worth using 1 12v/2 6v batteries to power it and then using a 5v regulator. It would last quite a long time and you could also use a 12v solar panel to recharge it if needed. If you need to move it around quite often, you could use a 5v battery, such as this one $URL$ but they are usually more expensive and don't hold as much charge. 

About a year ago I installed NOOBS on an SD card, then put raspbian on the SD card using NOOBS, and it's always worked fine, however I now have a problem where whenever I boot into raspbian I get "Unable to mount root fs on unknown-block(179,2)". After looking around this seems to be due to a corrupted partition on the SD card. I hosted my website using this SD card, and I forgot to make any backups. From windows, how can I recover those files, without Linux or fsck? I'm using Windows 10, and I have a card reader and I can access NOOBS's RECOVERY partition, which doesn't appear to contain anything useful. I was using a pi 2 B. Thanks! 

I have created a game that only runs on a pi and I want to upload to the Pi Store, but I need to take a screenshot of the game. Anyone know some good software for taking screenshots on a pi? 

The scripts and the results mostly speak for themselves. returns good data when I use the standard I2C GPIO pins, but the bit banging I2C returns what looks like random data. What might I try to debug this? note: I didn't forget to move the SDL and SCA leads to the appropriate pins. Using 3.3V to supply the DS3231 Real Time Clock. 

This is a partial answer; I am going to try to understand further why this is so. If someone is able to explain further that would be wonderful. The behavior described by the OP (in this case, me) is: 

My PiBox module, I've left the verbose print statements in to help explain what I believe each step is doing. It's certainly safe to ignore or delete them: 

For the next 1000 milliseconds, a transition in either direction on pin 22 will result in a call to , passing the new level and the tick number (microseconds). If I understand correctly, in pigpio one can set up one watchdog per GPIO pin, so there could in principle be many running at the same time. My question is what are these watchdogs? Are they CPU threads, or are they running in the GPIO electronics itself, or something else? Like real dogs, can they compete, conflict, or collide (say two watchdogged GPIO pins experience edges at exactly the same time), or do they get along nicely with each other? This is from and may be of some help: 

I started to try to read an MCP3008 ADC using SPI bit banging with pigpio. I wrote the unattractive little script below, starting from the example in the pigpio documentation and here is a screenshot of my output. I believe that this should read the lowest four channels of the ADC and print the output. Channels 0 to 3 are connected to +5V, GND, +5V, floating, so I expected to see values like 1023, 0, 1023, xxx where the last would be noise. Instead I see all 1023's. Have I done something terribly wrong? 

edit 1: I've taken a look at Install NTP on CentOS which turned up in a search for help trying to understand what "lithium.constan" meant, and I found the command: 

To be able to connect to your pi from anywhere outside the local network, you will need to make sure that your router is set to port-forward. To do so you will need to login to your router. If you're using Windows, open the command prompt and enter "ipconfig". Scroll up and find the ip address for the "Default Gateway", and enter this into your browser. If you're using Linux, the command is "ip addr". It should then load a login page for your router, where you will need to enter the admin username and password. I cannot give you specific instructions after this part as each router has a different interface. You will then need to search through the settings for an option that says "Port-Forwarding", which is usually a checkbox. Restart your router and you should be able to connect from outside your local network. 

$URL$ It's 25mb and does a whole lot more then hello world. EDIT: Another important thing to note: "Tiny Core is designed to run entirely in RAM, which means that you don’t install it so much as load the disk image onto an SD card. When you’re running the operating system, everything is loaded into the computer’s memory." 

The highest temperature my CPU has ever reached is 61 degrees. However the overclocking capabilities change depending on the manufacturer and batch. 

There are many relays availible for use with the Pi. It's very similar to a transistor, except its digital rather then analogue, once the input is at a high enough the relay will turn on its normally off output. There are 5 inputs and 2 outputs. One output is normally on, the other is normally off. In between is the input for the relay. There are 3 more inputs the other side of the board that will have GPIO pins. 2 are for VCC(+5V) and the other is the GND(-). The third pin is the input that controls the relay, changing it's state from normally on/off. You can connect the GPIO pins directly from your Pi. This is how a 1 relay board works, but if you're using a 2 relay (or more) board, it should be easy to work out. 

Question: What could cause to fail to start pigpiod successfully some of the time, but still always return and throw no exceptions? edit: RPi 3, Python 2.7, Raspian 8.0 jessie Failure looks like this: 

I am writing a data logging python script and I would like it to find out if the system clock has been synchronized via NTP recently, and if not, to attempt to cause it to happen before proceeding. Starting from this answer, I've found that for the status 

but it seems like a bad idea to do that if it wasn't necessary. edit: using Raspbian GNU/Linux 8 (jessie) Question: How can I test the status and then conditionally force a synchronization only if needed? This answer suggests the package $URL$ but I'm not sure if this is advisable or not, so I thought I'd ask before installing and running it, and I'd still have to guess the status by comparing the results to the system clock and deciding if the agreement were good enough or not. I'd still like to know if ntp is active and that it believes the synchronization is close. 

will display the results on the console, but I don't know how I can get the python script to see if ntp is active or not, since this call returns only . I could always just force a reset even if not needed using 

smbus works. When I convert these back from BCD to ints, I get a reasonable time object, with seconds increasing at 1 Hz. 

I've turned the WiFi off about five minutes ago so that explains the watchdog timer being 372 seconds. Is the value for frequency what I'm looking for? Question 1: Is using the lowest value for "when" a reasonable way to gauge roughly how long it's been since the system time has been checked against internet servers? Question 2: Does the ntp daemon make an estimate of system clock drift rate available in any way? If it's say 10 ppm or 100 ppm, is this reported somehow? Question 3: What do the characters in the first column such as '+', '*', '-', or absence thereof indicate? System: using Raspbian GNU/Linux 8 (jessie) 

I've only managed to overclock my Pi to 1.3 GHz, but this guy here $URL$ got it up to 2.4GHz. Is it the cooling that makes it possible to get up to that high? I couldn't overclock my Pi any more because, if I increased it more, it would crash at startup. Would cooling help with this too? Usually, it seems that you only need cooling to keep the CPU cool as overclocking heats it more then normal, but if it crashes at startup would more cooling actually help? 

I want to change the default governor on my pi from ondemand to performance. Is there a way of doing this? 

See this website: $URL$ Download the software, run, select the SD card drive and it will completely format everything on the SD card no matter what file system was used. 

You could use the GPIO ports on the Pi and the RPi.GPIO API for Python to communicate and convert the number to binary, although this would take quite a bit of coding. Another option would be to connect the two pis' directly to each other with just 1 ethernet cable, for which you would need to configure a default, static IP address to use on each. Then you could use the socket API from Python to communicate. 

Flashing the SD-Card may have un-done the changes you did. Follow the same instructions you did to get it working the first time. 

That fan has only 2 cables, a black and red, for positive and negative, which means there it is either on or off depending on if it's plugged in or not. There is no thermometer inside measuring how hot the processor is. Normal computers usually have a fan with 3-4 cables. Two for power, one for controlling the speed, and the last one tells the computer what speed the fan is currently spinning at. To turn on the fan when the processor gets hot you'd need to write a script that turns on or off a gpio pin depending on the temperature, connect that to the control input of a relay, and connect the fan's negative to the pi's negative, the pi's positive to the input of the relay, and the relay's output to the fan's positive. DO NOT connect the fan directly into the controllable GPIO pins. Also, it cannot get hot enough to cause damage to itself unless it's somewhere very hot, a lot hotter then room temperature.