I don't know what "lodu" means (although the Urban Dictionary suggest something rather offensive), but here's a relatively vague answer on how is saving done, due to a relatively vague question. Apparently, what you meant is not called "lodu", but "ludo". First things first, you must figure out what do you want to save, ie, what part of the game state. Common suspects are: 

I'm currently designing a rough prototype of a mecha fighting game. These are the basics I came up with: 

I'm making a multiplayer match-making game, and by my current design, people will need to pay a small fee before joining a match. At the end of the match, the team that won will get the money. That will be a virtual currency, but still, will it discourage people to enter matches? I introduced it to make the matches matter more, because there's always a fear that you will loose your investments. I'm not talking about anything big here, but even a small amount might have a similar psychological effect as a bigger one. 

I'm finishing a HTML5 browser game, and I'd like to have some player feedback. I was planning to make players take a short survey at the end of the game. Is this the best approach? How long should it be? Should I just let them write about the game instead of answer questions? What are good questions to ask and how? For example, do I let them write about physics, do I let them just choose "GOOD" or "BAD" or do I have a scale from 1 to 10? 

Well, definitely. You don't have to go to extremes, like adam, who suggests that you should make your games more like databases and use declarative programming. You could combine the approaches, for example, not having an entity manager but specific lists for various types of objects. Component based design is really useful when you end up with a monolithic class that defies the single responsibility principle. Generally, in simpler games, or games where performance is needed, you might not want to use entity systems (but the performance greatly depends on the implementation). As for why inheritance is used in game development, well, it was already there and natively supported, everyone else is using it, and it's simply intuitive. And seriously, if you plan ahead and use at least some component based design elements, you'll be fine with a classic implementation of a game. 

I suggest that, instead of changing velocities, you change the forces acting upon an object. Don't "nudge" them out, rather, do it smoothly and utilizing already existing code. By doing this the bodies wont immediately (and rapidly, I suppose) change their velocities. Check out Box2DJS for an example: $URL$ 

If you don't understand the code, tell me what is bothering you in a comment and I will explain further. 

We all know that there have been attempts to create commercially successful MMORTS games, but all have failed. By failed, I mean that they didn't get really popular in the gaming community. Why is that? What is an MMORTS? It's like an RTS (a real-time strategy; Rome: Total war, Stronghold, StarCraft, WarCraft) but has an MMO component, meaning that you not only build your economy and industry, but you get to compete with other players doing just that in real time. This interests me because I'm trying to make a game that is similar to an MMORTS as well. Summary: what are the reasons that are stopping the MMORTS genre from evolving? 

Makes a function for instancing levels Makes an array for storing levels Fills that array with n levels 

Where #1 is the empty board, and #2 #7 #8 are the game states you get to from possible moves for the first player. Of course, the tree for Connect Four would look different. Making a move simply means visiting a node, i.e. going by one of the branches. Please note that a single node presents the entire game state - i.e. it is a collection of all the game pieces and the entire board (obviously this can get memory-heavy, but there are optimizations). You also have to use some stochastic and heuristic methods because the number of nodes will grow exponentially in size - you simply wont be able to traverse all of them and know which one to choose - statistics is your only weapon. The Monte Carlo method seems to be suitable here. When deciding which branch to take, you obviously have to pick the one with the highest probability of winning. So you have to calculate that probability for each of the possible branches (moves). You do this by moving to them, and then picking random paths to go down. You continue down the paths until you reach a final state. Say you sample 10 000 final states. Then the probability of winning for that branch is . The paths have to be random. You do this by picking a random sample of children of a node and only visiting them. At one point down the tree you will have to take only a single random child of a node because picking even a small percentage is still exponential. There are also options of dividing the result by the depth of the search since deeper searches are less relevant. Please note that you have to take into account what the other player would do: some of his moves are more likely to be taken than others, see MiniMax. 

C++ is a great language. It isn't very complex: the learning curve is fine, level of entry is low, and pointers are awesome! No better way to learn about variables, memory, functions and so on... I used to recommend Python as someone's first language, but I avoid doing so now. Why? Because Python is a really abstract language. You wont learn a lot about how computers work on a lower level if you start with Python. So, I seriously recommend that you start learning C++. It has a much larger userbase and codebase than D, and it's the industry standard for the AAA. However, if you only plan is to make smaller indie games, then it might suit you fine. The problem is that as soon as you expand your team to have more programmers, you'll run into troubles. Chances are, they wont know D... But, as you stated, you're interested in getting a job, so yeah, you should use C++. Also, you are not "wasting your time with D". Programming isn't wasting time. Once you grasp the basics of a language, that algorithm you learned with D can sure as hell be coded in C++ or Python. So, after some time, you're not learning a language, you're learning to program. This has a lot to do with your portofilio, if you made collision detection in one language, it isn't hard to make it in another. 

I suggest you represent your game as a tree. This obviously mandates that you know basic graph theory. Google: BFS, DFS, graph theory - until you get the basic concepts such as node, leaf, children, parents, siblings, etc. The initial game setting is the root node, its branches are the moves you can make, the other inner nodes are distinct game states that you get to by taking those moves, and leaf nodes are end states that can be , , or . Visualization of the game state tree: 

There are many approaches to this. But, basically, you want to draw these buttons in, say, GIMP, and then put them on screen using a canvas. Then, register an onclick event to the canvas, and when it fires you want to iterate through an array of buttons (I suggest you make a constructor function for that; that would be a class in other languages), and when you see that a button has been clicked, you execute it's onclick function. The button's onclick function can be something like , given that you wrapped your game inside a function like I always do. For that, you need to know the position of the canvas in the web page, because onclick tells you the mouse's absolute position, and you need a position relative to the canvas. That is simple to solve. First, you calculate the offset of your canvas with this: 

You still need to perform the checks. There are several ways of doing this. You certainly don't want to go the dumb way, that is, checking each pair of objects in the scene. No, implement something called a quadtree. It's a space-partitioning algorithm that greatly increases the speed and efficiency of collision detection. 

Edit: there's a bug in your code. At the new Date().getTime() part (you can write it like that, no need for extra parenthesis). 

I suggest you use FL Studio. I used it, and it's pretty powerful. A lot of professionals use it as well. It's an app where you can arrange sounds in patterns, synthetize sounds, import your own, and do a lot more. 

And I have two 3D vectors, the camera position, and the focus position. The focus vector is always behind the monster. I know how to rotate the camera around the focus with the help of my mouse, but the monster is always facing the same direction, and I'd like to change that! I'd like it to work almost as in World of Warcraft; while I'm standing still I can move the camera around freely, but as soon as I move, the monster should change the direction according to the vector. Also, I need to make it move in that direction, I guess I could have a 2D vector called , which I should change accordingly (it would look like a rotating radius of a circle I guess). How do I do this? For reference, I'm working in Three.js, and this is the code with which I rotate the camera: 

The movement system applies velocities to positions. The acceleration system applies forces to velocities. The collision system detects collisions and applies the forces in the right directions, or, if you want crude collisions, directly alters the velocities. For example, you could calculate the angle between the collisions using atan2, and then use that to apply the correct forces/velocities the bodies. Have the collision detection system broadcast messages if needed too. 

You could also use a dictionary (map, hasmap, etc). It would be just as easy as using an array approach, but more flexible since shifting and all that is handled for you. You just need an IdManager class, an instance of which would be a member of your EntityManager class. The IdManager should have a public method called , which would always return a unique string of n characters. You would also need a private method , which would be called from to compute the new unique ID. 

Where did you get this idea about C++ being a terrible monster language? It's not! It's actually very fun. True, you can get close to the hardware, which actually has two benefits: you learn a lot more about how the computer actually functions, and second you have a lot more power in your hands than with, say, C#. But then again, C++ features great abstraction methods and has very useful libraries, so it's not like you'll actually be communicating with the graphics card directly (you definitely can) - it will just be abstracted away. Knowing just about any language is very useful, has a good chance of increasing your probability to be hired, and definitely makes you a better programmer. When you'll have time, check out JavaScript and/or Python. Others would probably suggest Lisp too, but I'm not that knowledgeable when it comes to it, so I wont say anything. But it might be useful to check it out anyway, I think it's pretty neat even with my limited understanding of its concepts. There's Haskell too but bleh. 

I'm going over some SDL tutorials aimed at creating 2D games. However, when I create a basic SDL program - is it hardware accelerated? Or is hardware acceleration only relevant when it comes to 3D animations? Can a GPU help when it comes to pure 2D graphics? 

This question is, I suppose, not limited to Javascript, but it is the language I use to create my game, so I'll use it as an example. For now, I have structured my HTML5 game like this: 

It depends. There are many areas of game development, just as there are many areas of physics. First, you will only need to know physics for games that require physics, obviously!If you're making an MMO, for example, you probably wont need physics. But, as soon as there is any falling, velocities, acceleration and things like that involved, you'll need physics. Mostly, it's just movement stuff, m1v1 + m2v2 = m1v3 + m2v4, dS = V*dT, and your regular formulas you already know. I doubt that you will need anything more complicated from that, at least for now. What is the problem, though, is applying physics. Collision detection isn't really an area of physics (or at least until you get to the subatomic level), but you still need it in your physics engine. 

In an Entity System I am making, there is a central class called , which stores all component instances. It's a dictionary-of-arrays, and entity ids are indexes for the arrays. To access a component of an entity with you would do this: . So, each loop of the game, these arrays would be fed to their respected systems ( ). Now, I don't see why systems couldn't be implemented just as functions, as I showed. What optimizations can be made by using classes with data and methods (caching)? Also, these systems would need to iterate over all the entities that exist, doesn't this make entity frameworks much slower than regular inheritance based engines? Why do some people "register" systems to the class? 

Achievements are definitely getting in, but I don't think that they will solve my problem entirely, that's why I have ranks. What I wanted is a small piece of information that would allow the player to estimate his success, and that is solved by a number (level) or one word (rank), but definitely not by a long list of achievements. I'm still, of course, looking for better ways to do this and comments on what I have so far.