Once you call with a non-null geometry shader, that shader is bound to the device and it remains bound until you either bind another one or until you unbind it (by calling with a null pointer). Consequently, if you call and pass it a non-null geometry shader, and then you call your sprite method, the sprites will still be rendered with the geometry shader active, which will likely do unexpected things to their geometry, causing them to be unrenderable or to render way off screen or something. You have a separate method for rendering sprites, and that method is currently assuming that no geometry shader is present, but that's no longer the case. You should solve this problem by ensuring you set all state that is relevant in your draw methods. In this case you probably want to ensure the geometry shader is unbound in your method by calling with a null pointer prior to issuing a draw call. 

Disable gravity entirely, and then manually apply gravity to every object you want to have it (ignoring the objects you don't want to be affected by gravity), or Apply a force that counteracts the force of gravity every frame to the objects you want to appear to be unaffected by gravity. 

You probably want to look into state machines. Here's a popular App Hub tutorial on game state management, and here's another random Google result for XNA state machine information (it's not really a topic that needs to be specific to XNA, so you can get broader search results in Google if you exclude the "XNA" bit, if you want to research the topic more yourself). Once you have the basic implementation of such a system, you can expand it by adding (for example) animations that play as you transition in or out of states. 

The general solution to doing things without type-checking is to move that functionality, in some way, behind an interface. In this particular case, if both moving and static entities in your physics world shared a common IPhysicsBody interface that supported the ApplyForce method (or was the parameter to such a method), you could apply forces in your collision handling to all entities. Static entities would simply implement ApplyForce such that it did nothing, to reflect their inability to move in response to forces. In some cases, having "empty methods" mandated by a base class or interface in a subclass is a sign of a poor class hierarchy design. It's hard to say whether this would make that the case for your code without knowing more about it. But that said, another approach is to do away with the concept of static and moveable objects at all, and just make moveability a property: a flag or a special value of mass that represents "infinite mass." Then you simply check for this ApplyForce and early-out. The advantage to this approach (other than a simpler/no hierarchy) is that you can temporarily make objects immobile if needed, which can be helpful. 

For efficiency, constant buffers will be mapped such that values do not straddle GPU registers. Each register is four floats in size (16 bytes) so constant buffer structures must be a multiple thereof on the GPU. Your C++ structure should be padded accordingly if you want to use it as a convenience for mapping data (this, note, doesn't always scale well). Your issue, then, is that an HLSL boolean is four bytes, but one byte on the CPU side (in your specific implementation). This causes your C++ structure to not align properly: the significant bit of a boolean value (the 0 or 1 that matters) is going to be stored in the least-signficant byte of the value, and since the sizes don't agree the location of that byte in memory will differ in the CPU and GPU versions of the structure. Manually inserting the appropriate padding and ensuring proper 16-byte alignment, or just using an appropriately-sized type, like an integer, should fix the issue. This thread may also be of use to you as it contains a more in-depth discussion of roughly the same problem. 

You can use to determine if a given is suitable for the device's backbuffer; it's unlikely that particular format will be. Instead, try creating the device with any old acceptable backbuffer format ( for example); it doesn't matter since you won't be rendering to it. Then create a new texture with the desired destination format (), set it as a render target, and render to that. 

You generally need to pay the market research corporations for this information. Often quite a lot of money, as well. Even then what you'll get is generally the perspective of retail markets, and not the perspective of the individual studios responsible for the games. Some basic, high-level information is usually available (for example, news outlets will report on the NPD charts). But often you have to purchase the detailed reports. Sales breakdowns from individual companies, such as Valve, may not be available at all. If they are you'll likely need to either dig through lots of random news reports to assemble the data, read investor reports if available, or (again) pay somebody to do this for you. What you are trying to do (predict the sales of a game based on previous data) is a hard problem even with good data (past performance is no guarantee of future results, just like with the stock market). It's going to be very hard to do on the cheap. 

The specific image used for each fixed sprite or the leading moving sprite can be adjusted based on that sprite's current vertical position. That's how you can get the curved appearance of the wave over time (there's a different angle to the leading, noisy sprite depending on how close the wave column is to the bottom of the screen. You can't do this entirely in the sprite sheet, obviously, you'll have to write code for it. But once you get it working for a single column, you can simulate the full wave effect by having multiple columns, starting new ones as the wave advances across the screen. Roughly, they'd look like 

ID3DXFont can be used to render 2D text, and D3DXCreateText can be used to generate a 3D text mesh you could render as well. In general I would think the 2D approach is preferable, unless you want the text to do something odd like spin in 3D space. To find the appropriate place to start rendering the text (for the 2D case), you'll want to use the character's position in world space (perhaps plus some offset vector that provides a position just above the character's head). Then multiply that point by the combined view and projection matrix via something like D3DXVec3Project. This will yield a screen space position you can render the text to. Note that you may need to offset the screen space position by, for example, -(width of text / 2) or use the flag if you want the text centered. 

Unfortunately, I don't think there are any -- I've never stumbled across them, at least. There's definitely a niche there if you can write a C# wrapper that can be distributed (not sure what the FBX SDK license terms are, though, they may make that cumbersome). 

The most-vulnerable point here is the initial client-to-server transmission. If somebody snooped those packets, they could see messages not technically intended for them. You could encrypt the data, but that's a lot of effort for only minimal gain. The client must be able to decrypt chat packets eventually, and intercepting the packets as they leave the client would be the best place to do the aforementioned snooping, so the key is already available to the snooper, just a little harder to find. It's very important that you pass your chat through a server that you are in control of, though. It need not be the game server, it can be a dedicated server for funneling chat, but you want to control the routing. It lets you have oversight for GM disputes, it lets you enforce user requests to block or mute other users, it solves the issues you might have with NAT punching or other networking shenanigans you can have trying to do peer-to-peer chat, and it provides enough of a barrier to casual hacking (which peer-to-peer chat is prone to) to solve 90% of the security concerns. Which is about as good as you'll get.