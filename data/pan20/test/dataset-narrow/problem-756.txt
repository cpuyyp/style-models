When providing an object, I don't think it makes sense to pass the index into the callbacks. Rather, pass in the current key. Also, I think reads much clearer here: 

jQuery's method can take a callback function - it'll be called for every element in the collection - and will use the returned value to set the element's html. You can use bracket notation to access the key in your , so that you can dynamically get to the key you want with the string in the brackets: 

Use & . They're SO MUCH faster. Since you call every time you instantiate your plugin, you should probably move the call into your constructor instead. Public functions should be assigned to the prototype, so that we don't create a new function every time we create a new instance. Likewise, define a private function outside of the constructor, in the parent closure. Again, we don't want to have to re-create the same function over and over again. 

Your variable is declared without a , so that it's leaking into the global namespace. Don't do that. As it stands now, your isn't used anywhere in the code. I'll assume it's not applicable here. Instead of manually keeping of your iteration, use the % (Modulus) operator to calculate your rows. jQuery's method doesn't deal with code fragments the way you seem to think it does. actually appends a whole table, not just an opening tag (that's not even possible). Access to the DOM is not free. Every time you hit the DOM you incur some overhead. Try keeping DOM modification to a minimum. Unlike others, when dealing with a simple HTML construct such as this, I prefer to build my fragment from a concatenated string since it's much faster. 

And see Raymond Hettinger's guide to using for more pro-tips. The idea here is to override the default attribute values on a per-class basis (dmg and str, in this case) but have the root class do all the attribute-setting, since it's all the same except for the values. 

That should be a single database call. You'll want to compute the set of companies that are not in the result set, and then them: 

This figures out the letter-index (0..25), adjusts it for shift, wraps it around, and then puts it back in the ASCII lowercase range. Note: this is probably what you want, because "Caesar". But if you want wrapping from upper to lower case, that's a different expression. 

Also worth noting: when you invoke with empty parens, it doesn't mean "return nothing". It means "return a tuple with zero items". The expression (note: expression) is an empty-tuple constructor. This is consistent with calling a function with no args, since positional args are a tuple: 

Note that I have changed the behavior here, from 50/50 to proportional to the # remaining. You could certainly change it back. The point is to change the condition. Note also that this is where you would replace calls to separate inside/outside functions with a single function. You could create a container with two sets of parameters, and index by a random number (0,1) or random string ('in', 'out') to select which parameter set to use. Help Yourself Don't be afraid to write helper functions. In fact, if you write a comment, ask yourself if that comment should be a function name instead. If you write a paragraph of code, and then break for another paragraph, ask yourself if that should be a new function. Even if you only call it once, it might be a structural function rather than a reusable function. You have this code: 

The method will traverse the DOM all the way up the chain. Rather use the method, which will stop at the first match: 

Note: is the same as , just a bit faster; it doesn't create a new jQuery object at every step in the loop. 

Sane Selectors - There's no need to add all those selectors by hand. Simply use an attribute selector to select all elements that start with a given string. Selector caching - If there's one thing you can do to your code to keep it fast, it's selector caching. $.each - We're using jQuery's helper to loop through the array, since it also supports older browsers ( is not supported in IE < 9). 

Don't use , even if you think that in this particular case it's safe. Even if it were, it's still slow, and not supported everywhere JS is. There's no point in using this function if you know that the path exists. The whole point is to try to fetch something through a deep path without an error. I think you can skip the console logging bit. It'd make sense to allow the user to provide a default value to be returned if the final path segment is not found. If you're doing this, you may as well support arrays too. 

(Also worth noting: is the name of a Greek letter. is something you do in a boat.) You might even consider the fact that Python supports unicode identifiers, like so: 

I had a look at your functions file. You wrote code that spelled out all the checks. That may have flavored your thinking for the AI as well. Use special purpose tools You are sharing code from Google Drive. There are special purpose sites for sharing code, like $URL$ or $URL$ If you use them, other people can easily see your code, download it, even make changes and send them back to you in a standardized way. Abstract your concepts Instead of, for example, checking if a position is filled, then if a position+1 is filled, then if a position+2 is filled, then if a position+3 is filled, try creating some slightly more abstract concepts and implementing them, so you can use loops rather than copy/paste. For example, create a enum. Use that to index some offset values. Then, instead of writing functions for each possible direction, just loop over 4 iterations of adding the offsets: 

Of course, might be a better name than . Break down your function Currently your function consists of a loop to play multiple games in series, containing a loop to play each alternating turn, plus logic to display the end-of-game results. Break down your main into a separate function to play one game, plus a loop to play multiple games by calling that function: 

Just keep in mind that this will query the DOM on every single !! Are you sure you can't somehow do this differently? 

I built this very-basic lazy list (I'll add more methods as I need them). You provide it an array, a generator or any iterator. It creates a lazy list, which lets you run a pipeline of transformations in a lazy manner, meaning that they'll only be applied as you pull values out of the list. Here's the class: 

P.S. is not very descriptive. You should consider coming up with a more intuitive naming convention. 

The code above works, but the text is not associated with the radio button in any way. To remedy that, consider wrapping labels around your radio buttons: 

To make all this easier on yourself, don't re-invent the wheel. Look into John Resig's tiny inheritance library: Simple JavaScript Inheritance. 

Your code does not actually function the way you want it to. checks for the existence of that element, not whether its value is set. Your radio buttons don't have a attribute on them. They really should. You should cache your selectors. You're querying for a total of 7 times in your code, and an additional 4 times on every click. Instead of listening for every click inside , you should instead only listen for the event of the radio buttons. On page load, if there's a value in the input text field, all we have to do is check the correct radio button. The event listener will take care of the rest. 

Memory Ownership in C++ One of the most important concepts in C++ when dealing with pointers is the idea of ownership. Some terms: 

And let people access and directly. (Python provides a mechanism, , for dealing with the case where you want to turn a member access into a function call. But it's not the first thing to do.) The next thing that struck me about your code was this: 

Next, rename to something more accurate: or some such. Try to always write your code using the vocabulary of the problem domain. In this case, the problem domain is a board game. Finally, there are a bunch of opportunities for you to tighten things up. For example, checking for a win in the turn function instead of separately, or using a list-of-lists instead of three separate row lists. If you can make the changes above and update your code, then we can get into those changes. 

I suggest that the word "new" is understood to mean object creation and initialization. Rather than , consider . Going one step farther, you might make this a preprocessor macro that returns a typed pointer. (In a post- version, where arbitrary data can be handled.) Something like: 

While using a closure to prevent polluting the global namespace is a good idea, you shouldn't be passing in random data like that. The way you are doing it, you are forcing the reader to scroll to the bottom of the function call before reading the function body - that's just plain confusing for no good reason. Instead, declare the variables regularly within the closure, and assign their values right then and there. That way, it's much easier to read (and maintain), while still keeping the global namespace intact. 

In addition, Crockford suggests that you put the calling parentheses inside the wrapping parenthesis. 

P.S. You haven't described how you're exposing the plugin's additional methods. For that you should read the jQuery plugin creation tutorial. Find the section titled Provide Public Access to Secondary Functions as Applicable. 

If you find that you have to do this a lot, you can abstract it into a custom filter, which you can then use in your selectors: 

In the regex above, we're looking for any characters in the string that are not in the bracket group. If none are found, will return 0 (which when negated will result in ). If any of those characters are found, will be returned and negated to . 

Given , how can you predict (above)? What's the number at the root of the tree? Given the number at the root of a tree, what are the values of the numbers at the root of the next lower subtrees? (Hint: easy for the left, harder for the right.) 

In general I like the fact that most of your code is close to the left edge of the screen. There are a couple of lines that are long, but only one really pushes the right edge. With that said, you seem a little too focused on breaking code down - it's a small thing, but I think I'd prefer a few more 3-tab lines, and a few less subroutines. There are some functions that probably shouldn't be functions. In particular, your separation of 3-digits and 2-digits is a mistake, IMO. Handling the English "hundreds" is really just a matter of computing a string, since it will either be "N hundred " or it will be ''. I believe you should handle the entire three-digit "chunk" (your term) as a single function. Use of Python 

Right now it's just a wrapper. That's probably all it needs to be. But if you parse the result, you might be able to move the import of the HTTP and XML libraries into the audioscrobbler module entirely, which simplifies the rest of your program. Get top artists from a specific country I would suggest that this becomes another call to your package: 

No need for all that. Just use one bracket group, negate it (be prepending a ), and use the return value directly: 

Very good question. I'm pretty sure this can't be done within the selector. However, instead of checking the every time it's clicked, the collection before applying the event listener: 

If you don't care about IE, you can check the property directly, which is much faster and much more reliable, since also contains any arbitrary data that might have been set (possibly by a plugin): 

Are you sure you really need that selector? Wouldn't do the job just the same? While we're at it, why are you listening to the click on the elements, and then find the via ? Can't you just listen to the event on the s themselves? Is there any method to that configuration? I wasn't able to deduce any algorithm from what you've provided, but I'm sure there is. You'd be better off calculating it on the fly, if possible. 

If you want to, you could even build that original array dynamically, which will make this much easier to maintain: 

Please remember to always cache your selectors. To get the of an element, use instead of . There's no need to use two separate steps to first get the value, then set it. Instead, pass a function to , and return the new value you want. To convert a string to a number, just prefix it with the plus sign (e.g. will return the number ). It's safer, and more concise, than . When using CSS selectors, you should always strive to use the native CSS3 selectors, since they're much faster than jQuery's own custom selectors. and are not CSS3 selectors. In your case, you should use and , since they're native CSS3 selectors. Since IDs are unique per page, there's no reason to qualify an ID selector with the tag name (as you've done with ). Just use the ID on its own. Again, better performance. 

Get rid of magic numbers Your declaration that "buy_index == 1" means buy, and 2 means sell is ridiculous. If your code produces those numbers, then change your code. If you are reading the numbers from somewhere, change the numbers: 

Develop a use case Looking at your classes, I don't understand what you intend to use them for. The fact that your docstrings are all """TODO: Docstring""" doesn't help with this. So I have to ask you, what problem does this code solve? You have internalized the HTTP request. So I can't pass in a connection, or a session. This means I have to trust your interface and cannot provide my own certs. Not a great web library. Your RatingFetcher does a lot of work at init time, then when I call it returns an object that I have to decode based on its length. That's not very intuitive or friendly. Before you do anything else, I'd suggest you have a clear vision in mind of what problem you're solving, so you can write code that makes that solution Pythonic. I don't see any generators or iterators, so it doesn't seem to handle bulk operations. Is that a drawback or a feature? What is a Warnings? Your warnings class takes a username as a parameter. But really, all you do is generate formatted warning messages. And the method names on the class are about the same length as the messages, so if I use your class I don't think I'm saving anything - no keystrokes, no logic, no convenience. This goes back to the lack of a use case, but I don't understand why I would ever want to use your Warnings. The kind of information being presented is not typically what the module is used for. You are printing warnings based on data, rather than based on danger to the code. That seems like more of a GUI thing or WebUI thing than a console thing. Don't tell the network admin that a chess player hasn't played enough games - you should be telling the user that is challenging them. Don't nest too deep What does mean here?