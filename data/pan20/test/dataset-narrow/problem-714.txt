NOTE: I probably should have added another function of some sort that would update the JQuery objects in case they do not get loaded correctly or the HTML was to be dynamically created later (or something weird like that). But, instead what I did was just place the script at the end of the HTML file to make sure all of the HTML elements had been created before the JQuery objects attempted to be created. 

NOTE: This is not bullet proof by no means. So, play with it to make it fit what you need. For more on . 

Blech! :) You could solve the problem and expose a cleaner API by providing type-specific accessors. 

Without the real code to be tested, I can only provide an example of how I've tested something similar with QUnit and Sinon.JS, though you don't even need the latter. You can either use Sinon.JS to mock a response to the AJAX call or substitute your own manual mock for or . I find the former preferable as it documents the AJAX call and tests the full front-end code, but it's beyond the scope of this question. You could argue that you're needlessly testing jQuery itself, and you'd be right. YMMV :) Mocking JQuery Let's assume this click event handler that uses the AJAX call to acquire a JSON string. I've omitted the extra deferred for simplicity as your current test of the promise attached to the element is fine. 

I have it set up to where represents dereferencing. Also, everything returns if out of bounds. The only different one is which returns itself. The reason for picking is because it's shorter than all of the others that refer to itself (besides ...). By making it to where the returns allows for the . 

ViewBase For this I created a unique function that will automatically define the camel case property and create the JQuery object. 

self It appears from looking at the code, you are following a Python like syntax. To stay consistent, I would always place as the first argument. 

but I found it easier to move the first/last element handling out of the loop. Also, negative list indexes reduce the calls to which cleans up the logic a bit. My first refactoring built a new list in-place with similar procedural code: 

One thing that makes this difficult is that you're modifying the rows along the way. This makes extracting functions harder since they have side-effects. Instead, leave the original values untouched and build up an accumulator to hold the best path sums. Extracting this to a new function yields a very readable outer algorithm: 

This prevents from flooding the global scope and you can control what scope the library is connected to. Here is an example: 

So, I created this strange fix which probably is not the best take but it keeps somewhat of the original design. 

Throw an error because a full string is still evaluated as true in JavaScript. But, in my opinion do not slow down your code to account for incorrect use. That way the people who know what they are doing won't be slowed down to check if it is a string. That way if someone wraps your library they can make the check if they want to:) If it's empty then it is palindrome in my opinion. Other than that, I don't see any big ones. Yes, this is usually called an assert. When doing small tests like you are doing it is fine to create a small one. I prefer modularity when building software. (As I said down in the comments) If all I want is a feather do not give me the whole bird. A lot of libraries out there for JavaScript are like that. Even the sacred jQuery does this, when all I want is to send an AJAX request I have to bring in this huge library. To me it's slow and bulky, so when I make software I make a small piece to handle one thing and optimize it to do that one thing. But, if you are looking for a common library used to handle unit testing at a industry level QUnit does a very good job but just brings the whole bird. The code I provided should help... 

My first thought is to use the Factory Pattern and supply a to the which would cease to be abstract. 

Update: Start by replacing named variables such as and with an array of number/styles so these become and . Add another loop to assign the numbers and styles. 

Capture the enclosing section and current next task. Do nothing if this new section should be skipped. Create a new next task that will either 

Solving the first problem is simple enough: use a to cause all incoming threads to block until the first list of objects is set. Ideally the system would start another thread to specifically load the data rather than letting the first random thread to come along and do it. This isn't necessary (see below), but it's much cleaner. For the second problem, wrap the list of objects in an to supply a correct memory barrier. You might be thinking, "Oh no! Not two synchronizers for each access!" but Java's synchronization primitives have improved greatly over the years, and the atomic value holders are even cheaper than full synchronization. 

I will say though that it seems a little unnecessary to have all of this. I would only do that if you have a lot of complicated initialization stuff each element. If you only have a button with a simple event and all you have that is complicated is the handler, then I would let the handler be the complicated part not the rest of my code. 

It's not very elegant but I figured if someone wanted an iterator that looked like an iterator and worked in more browsers, then this might help. 

Wow, that's a lot of work--too much for a single function. Let's simplify it by extracting functions for emitting the help text and formatting the message. 

For the second part, use values as Josay suggested but place the flag inside a function that returns a closure. Each call to establishes its own flag without having to package them all into an array or object. 

The following rewrite tests only the error ( value provided) path to make it easier to follow. The main difference is that each test now checks a single aspect of the overall behavior. You still need to decide how to group the tests for each use case--either with separate top-level blocks or nesting as you did above. 

Next to make it easier to everything, you could loop through your calling each one of the functions. 

Recreating JQuery Objects As @YiJiang said in the comments in the question, it would be better to store the JQuery object than constantly calling on the private variables you have. So, you could do something like: 

Because you will end up creating a new for every instance created. You would be better off creating a static like function: 

When programming a solution like this, in order to simplify the problem create a separate function for each component. So, I would break it up into three different parts: 

You've missed several variable renamings which keeps your code from compiling, and those names were truly atrocious! , , ? Create more descriptive names as an opportunity to practice your touch-typing skills. :) It doesn't help that the names in the original problem description weren't much better: 

This eliminates much of the -checking that complicates code and makes it harder to read and follow and is a common source of bugs. 

You are duplicating the code that advances the cell indices in : once if the cell comes in already filled and again when you place the next guess. You can drop the latter and simply pass in the same cell indices since you're setting the cell's value first.