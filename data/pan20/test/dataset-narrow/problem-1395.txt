It probably sounds obvious, but... Don't full-screen your game while you're recording the video otherwise it will 'obviously' be incredibly slow because it captures your screen resolution. I'm guessing this is what you're being bit by. FRAPS will take care of this just fine. So will many others but I found FRAPS the most convenient and easiest to use. I used FRAPS to record and Windows Movie Maker to put together some maps I made in Starcraft II -- example. 

I have no experience in this domain, but I've seen something that may be useful. If you know, or anyone else knows about this feel free to elaborate on it. A buddy of mine pointed me to this when I was talking about creating a multiplayer web-based game. $URL$ 

Essentially any game related forum. It's not easy 'getting it out there.' It's quite time consuming. Aside from that, I would get active on $URL$ There is a ton of activity and you can post your game, mod or add-on. If you sign up on gamedev.net and pay a yearly fee one of the perks is listing your projects in their showcase - $URL$ If you're working on something really really slick, you might want to think about writing in to some of these websites and see if they would write a post / review your game. That could help quite a bit. 

Have you thought about using a good API to help you with your flash development? Take a look at Flixel and Box2D. 

I would supplement those questions with specific questions relating to the team and project that you personally want to know from a management position. 

It's been said above, testing is very, very tedious. Manual testing is a monkeys job. Companies understand that coming in through support is a well known path for people looking to get into the game industry. There are companies that don't like it. I recently watched an interview with Gabe Newell where he mentioned companies firing an employee who attempts and move out of QA. Companies need testers who are genuinely interested in what they're doing. So if this is your path make the best of it. 

Two things... The first one being the most critical Don't Ignore Marketing You're indie. Nobody knows you. You absolutely need to get yourself out and start building your brand as early as you possibly can. You can't expect to have the next big hit so you need to start dipping your toes into the water early. Marketing is hard. Building a brand can be a full-time position. Spend an hour or two everyday talking to your community or other people to help them discover you. Nothing sucks worse than spending a year making something and you don't meet a fraction of your expectations or even reach anything close to your potential. Don't Sacrifice Quality Don't fall into the trap of thinking that just because you're independent that you can't produce something of extremely good quality. Yes, it will take you more time to develop than someone with a powerhouse of developers, but you're just going to have to be more creative. If you don't like your artistic style, fix it. If your procedural algorithm routine sucks, fix it. 

1.) You need to update _lookRotation when the mouse is clicked or it never changes so your agent will never look at a new location. Simple Coroutine Example: 

Add this script to your LineRenderer GameObject. It will allow you to set the SortingLayer and the SortingOrder in that Layer for your LineRenderer and correctly draw it with an additive material. 

I'm working on converting a dx11 shader from a .fx file for use in Unity3D and I'm a little puzzled by the HLSL Buffer<> type declared in the shader. More specifically, what are these and how can I implement them in Unity? I'm aware of the Structured, Append, and Consume Buffers but those appear to be different then this and the Microsoft documentation wasn't to helpful. Is it just like an array that is populated and sized from code before getting assigned to the shader? Are they read only or writable as well? So far I'm thinking the closest approximation I can use is a StructuredBuffer but the .fx file has its own declaration for that as well so I'm not entirely sure I should go that route. Example: 

When a Resource is Loaded its not actually Instantiated and added to the Scene so Awake() is never called. Change your code to something like the following: 

If you're just looking to make your game compatible with some older devices consider using Quality Settings . Go to Edit->Project Settings->Quality Settings to set up each level and instruct Unity to use full size textures/half size etc.... Then add a Menu Scene that will load first allowing the User to select the settings he wants for his devices. 

Limit Velocity Over Lifetime->Dampen in the Editor. From Unity Docs: "(0-1) value that controls how much the exceeding velocity should be dampened. For example, a value of 0.5 will dampen exceeding velocity by 50%." For best results set Speed under Limit Velocity Over Lifetime to a Curve that shows how you want the particles velocity to react over its lifetime then use Dampen to fine tune it to your liking. 

Try using CacheProceduralProperty to specify at runtime what properties you want to cache and which ones you don't. 

} 1.) Consider using Transform.LookAt to simplify the rotation. 2.) In your movement code, myTransform.Up represents the Up vector of the transform in local spcae, so if your model is tipped off center then Up will no longer point Up in world space. Use Vector3.Up as MistaGiggles suggests. 3.) You can make your enemy hover above the player by adding an Offset amount for the Y axis like the sample code above. Additional way to rotate your enemy based on your comment: 1.) Get the normalized vector from enemy to player and assign it to Transform.Right, which would be your X axis. Unity takes care of updating the Transform's rotation internally when you set Up/Right/Forward manually. 

Unity3D doesn't have any direct support for voice recognition. You would need to write an extension (System.Speech.Recognition) or find some kind of plug-in to get you rolling. If you do end up going this direction you will lose out on the unity web player compatibility with your project. I do not see any plug-ins that are already developed for this purpose. 

This is a team effort. If people are playing the blame game you might want to look for some other company to work with. With code bases being hundreds of thousands lines of code no tester is going to find all of the bugs. That's just not realistic. 

Introduction to the project, goals, and anything you feel like sharing about the project process Top 5 - What went right? Top 5 - What went wrong? Conclusion... Bringing it to the end. 

There are some really great indies over on tigsource.com (art board). I've seen a lot of those guys pump out some really cool pixel art. I'm sure you'll find a fair amount of people willing to give you advice. You might check out gamedev.net as well. I know Mark Eugn does a LOT of epic pixel art (gd.net journal). To showcase your work, $URL$ might be the way to go. You can break what you do down into categories so people can find their focus faster. The interface for the site is nice. 

You're in luck! I just discovered some Linear Algebra tutorials on Wolfire's blog that I felt were really good. The guy writing the tutorials, David, has such a killer way to explain the stuff. It's extremely handy for those that are weak at math since it is showing more practical application than theory (which is what someone weak could use) 

Data drive your characters with LUA scripts or even XML files. When you interact with an NPC, grab the file that is attached to it, read it in, adjust for any game variables that may have been triggered, and product the valid response. The biggest gain from doing it this way is you can easily go in and manipulate the dialog, add new characters, etc. You also avoid mucking up your code base with special logic in handling each and every case. 

Introduction to 3D Game Programming With DirectX 9.0 (awesome) NVIDIA FX Composer (good for examples) There was a Shader X2 intro paper on ATI's website, but it's been removed... Ah! Found it here! 

I have seen a couple of things in the past where I have seen a crowd majority buck their heads. One really sticks out in my mind: Little Challenge In a prior project, I leaned against the word 'casual' a little too much. I imagined people picking up this game and simply solving a simple feat and moving on. I didn't integrate any kind of losing mechanism per say, but left that for the player to determine. A 'did the player meet his/her expectation' type of situation. Judging from the feedback I received I see not giving a clear losing mechanism a mistake and a missed opportunity. It seemed that those players who wanted a way to lose actually enjoy knowing they've lost. I guess that may sound obvious, but I wasn't quite thinking about it that way. Reward a Player By nature humans are always trying to achieve that next best thing. I think there are some instincts at play there. At a young age our mind was a buzz when we got a new toy, for example. So in a game I imagine that a player who is given something along the way will improve the fun-factor. I assume this is exactly what Achievements are targeting - a direct reward. 

I have a texture shown over the screen using screen space UV's. The Texture is 495x,596x, Screen size is 888,500, but can change. The Texture has a Tile of (3.469775f,1.392644f) to correct for distortion from being stretched to the Screen's size, and has repeat set to Clamped. So basically, I'm showing a Texture of an arbitrary size on screen and using Tile and Offset in the shader to correct for distortion and keep the texture at its original aspect ratio. Now my problem is I want to Zoom in and out by a set pixel amount in Screen space. So lets say: I need the texture to increase in width by 10 pixels in screen space. What is a formula I can use to recalculate the Tile and Offset so that the texture stays at the same aspect it was but increases by the amount I want it zoomed? I've been trying things like: 1 Pixel = (1f / Camera.main.pixelWidth). So to zoom by 10 pixels I would go something like Tile.x += (10f * (1f / Camera.main.pixelWidth)); But this doesn't seem quite right, I'm not seeing it increase the Texture by the right number of pixels... My current function is something like this, but for Zoom = 5f, it's only enlarging by about 2px. AspectRatio = Tiling in the Material and WidthOffset/HeightOffset is just the Offset. 

I have an app made in Unity3d for android and iOS. In it, the user has the ability to link their accounts with Facebook and Twitter. For Facebook I use their Unity plugin, for Twitter, I open an external browser page that lets them accept or decline Twitter integration that then redirects to a php page the calls the app URI to return focus to Unity. On Android this all works perfectly using an Intent in the Manifest. In IOS I'm running into issues though and I don't really know my way around XCode. I'm using the newest version, XCode 7 Beta 2. The App runs as expected but for both the Facebook and Twitter authentications, upon returning focus to the App from the Browser, it completely restarts the App as if just launched rather then returning from a suspended state. In the Unity build I have "Run in Background" selected. I setup the URL Scheme in XCode. Its a pretty basic app so I don't think its being closed due to Memory usage. Any ideas or any settings I can change in XCode that might be preventing it from resuming? *Note, if I just hit Home and send the App to the background it will properly resume, its only when called by the URI from the browser that it seems to completely restart. 

And much more. I'd download it and play with some of the samples they have included that demos much of it's functionality. 

Don't ignore details... Short fingers? Scars? Tattoos? Missing eyeball? One leg? Tearful body odor? You can now use those descriptors to assist in bringing your character a personality. If you're designing a combat game, you can take the fact that you know your character has scars to describe a hard-fought battle the character was in back during Vietnam. Now that we know that, maybe your character has PTSD which will influence certain game mechanics. If you're developing a puzzle game, maybe your character got those scars from a science experiment gone wrong. The goal is getting all of the possible creative juice out of you that describes every single detail that you possible can about this character. Give your other designers all of the information that they could possibly need to fit your character into the game world. If an Artist is modeling your character they can simply look at your descriptors and recognize the look. They can read a short bio and realize that this guy is a thug or an innocent/clumsy scientist. If a musician needs to compose a piece that focuses on your character, they can discern the mood they need from reading a short bio. 

Big companies tend to create group atmospheres. Artists will hang out with artists. Programmers will hang out with programmers. Testers will probably hang out with support. You will have to make an effort to network (lunch, activities). There is no reason why you wouldn't be able to create good relationships with developers. 

You're gaining valuable insight as you work through the process. For any good business man that works on a project it's fairly easy to tear your project to pieces when analyzing what you did wrong. Figuring out want went right is a little harder. How I would approach a thorough postmortem Get All Perspectives in Writing Ask each team member to write a few pages on project observations. Instead of randomly laying a trail for them to fulfill I would ask exact questions that you want to know about. You can supplement this with a meeting, but I rather get someones sole attention without distraction. The most obvious questions would be 

Take a look at this video tutorial that show off the trigger editor. Here are some good tutorials to get you started. The game itself was written in C/C++. 

Fail Early, Fail Often Well, it is pretty hard to 'fail early' when your project is out of the door. Hopefully the feedback you gain from the above will shed light on processes that may have been pretty dark to you. There are problems that you will run against that will sting pretty bad. It'll be pretty difficult to just forget those. To make sure that you don't forget the problem areas it could be handy to write a 'Core Value' type list that you keep at arms reach. Keep them available for others to see and for you to see. When the your next project starts I might be inclined to bring some of these to the table to get other people's perspectives. If you have new eyes on the project you might get feedback that could shed new light on solving a particular issue. As long as you're aware, and you keep your problems in the light, you're bound to solve those issues. Write It Grab all of the writings and bring it all together.