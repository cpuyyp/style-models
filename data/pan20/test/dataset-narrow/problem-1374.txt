For balancing mechanics, Grab some friends, and do it manually, the fun way. If your game is good i doubt they would disagree, just spend a weekend playing your MMO for a bit. This should help get the basics out of things like whether bleeding needs a nurf or buff, whether being crippled needs to slow down a character more or less, etc. For balancing moves and such, try a beta, open or closed and give players the chance to give feedback. Given the fact that your balancing is for the players, maybe players should have a say in the balancing? I know this isn't about documentation, but it is still THE BEST option out. Or i could save my answer by saying "Documents from players beat general guideline documents". 

My final advice though, is to try it all out for yourself. Check out Reimers tutorials in XNA and DirectX (and just browse google for some OpenGL tuts), and work out which one you think would be better for your interests. 

DisplayBox.SetValue is a function which goes through and sets the texture. This is working! DrawIsoCube() draws the cube (the test model) and this is working too. The problem is definitely something to do with the unreusability of the render target. Pretty simple yet it's not working. It appears that whatever the last image being rendered is, is shown in every image of the allBlockIso array. Anyone know a fix? Cheers. P.S. sorry if this wan't explained well. I'm not very good at explaining :P 

i want to be able to loop through a hole bunch of textures, and render them on an object. I then want the rendered image to be placed onto a texture2D. The point? well hopefully i will end up with an array of Texture2D's containing a model with multiple skins. Here's my code: 

Although the damage is somewhat random, it only varies by 26.5 percent over the total range, so you're guaranteed to do a certain level of damage on average over time. These types of attacks are useful for characters who have both low stats and low levels in games that normally account for those factors in dealing damage. Plus, they ignore the defense of the target (although the formula could be easily reworked to fit in defense if you so desired). 

A formula like this is good if you want a very simple method of estimating damage, or a quick jumping off point for modifying damage based on other factors like skills and elemental weaknesses. To show how broad this kind of formula can truly go, consider the damage formula for Inflation RPG, an Android and IOS game (See $URL$ The formula is heavily both stat and equipment dependent. Each piece of equipment has two stats - a bonus to the ATK stat, and a multiplier value. Some pieces of equipment have low multipliers, but high bonuses, others have low bonuses but high multipliers. For a character with only 10 ATK, the Battle Axe with it's 5000 ATK Bonus but low 145% multiplier is a great choice. The total damage is , but the Estoc, with 0 bonus and a multiplier of 300% is a poor choice - the damage is . Later in the game, a character with 5000 attack would prefer switching weapons. Stat- and Level-Based: A good example of this is Final Fantasy V, VI, and Final Fantasy XII (See $URL$ for example). The formula for swords in FFXII is: 

As others have mentioned, the Final Fantasy X formula is pretty complex. Generally for that series the later the game, the more complicated the formula. It's probably easier to base your damage formula on another game entirely. But in general, I think it's worth discussing from a very general level what kind of damage formulas you can find in the world, and how you can make a game based around them. The first thing you need to decide is how much damage do you want to be able to do at the end of the game, and what kind of stats do you want the player to be able to have? Once you have that, you can pick a formula system, and then optimize the formula and weapon values to reflect those ranges over time. Purely Stat-Based This is a good idea if you want your characters to be flexible in terms of what levels of enemies they can challenge. A formula like this is only going to depend on the player's stats, their equipment, and the stats of the enemies. These formulas are usually fairly simple. Final Fantasy Legend II (See $URL$ for instance, has weapons that do damage based on the simple formula: 

Basically i am trying to render a model yet it seems to draw polygons that should be behind something, in front of it. So i end up seeing some faces that should be behind something, totally covering it. Bah, i suck at explaining so here's the pic: 

See the Railing? It should be at the front, but it's covered by the top of the platform. Also, on the side, the shadowed area should be practically hidden from that front wall... Other bits are around the place too if you just look at it... :( I tried the 3 different cull modes, none of them fixed it, so i don't think its the culling (in fact Clockwise made it worse... :P). Thanks for any help. 

Basically, your character has 5 main points associated with them, as shown in the image above. 2 head collision points (green) 2 wall collision points (red) 1 ground collision point (yellow) Every step of the game you check collision on each of these 5 points when moving. If either of the head collision points are hit, you have jumped to high! If either of the wall collision points are hit, you have hit a wall, and if your ground collision point is hit, you have hit the ground, and should move your character up a pixel (until it no longer detects ground). So how does this handle slopes? Well if you look at the image above, you'll notice that some things may be low enough to pass under the wall collision points, and then hit the ground collision point, forcing the character to move upwards. This means if you had a slope, if the slope is too great, it will hit the wall collision point before the ground collision point; no access. However if the slope is low enough, it shall hit the ground collision point before the wall collision point, moving the character up, and therefore making the character walk up the slope. Extra points can be added for collision detection to improve mechanics, though remember every point you add means more calculations... Adding two ground collision points, and spreading them evenly along the bottom sometimes helps. The further the ground collision points are from the middle, the steeper slopes are that the player can handle. Alternatively you could just make the wall collision points higher up, but this may not end well (your character may end up "Jumping" onto obstacles. So my advice is keep the wall collisions reasonably low, (remember if the head collision points are in the corner as shown in my image, then they can also act as wall collision points). Sorry don't have access to any code to help you out here, and its 1am, too tired to think of it off the top of my head. Hope it helps you, and if not, someone else who glances by :) 

It doesn't HAVE to be this way, but I've seen the pattern in many games from console RPGs to PC strategy games, and even handheld tower defense games. In a game like Oblivion, the difficulty is that the player has to make choices in the strategy building in the early- and mid-game by choosing how to level up that can have drastic consequences late-game because there's no option to change that strategy later. It's how you've built your character. The same is true in Diablo 2, and many other games that allow you to select skills for your character without the ability to change them later on. A skill-based character advancement thus takes a bit more fore-thought into how individual skills can be used to build a cohesive strategy. In Diablo 2 you can see how the developers struggled with it by looking at how often they tweaked the skills over the lifetime of the game. It's easy for an inexperienced player to reach a point where their permanent strategy choices are no longer effective against the opponents they're facing. That doesn't necessarily make the game unbalanced - it simply turns the skill progression choices into part of the player's strategy, and may require several playthroughs to develop an optimal strategy. 

They're very similar, but notice that the sword formula only depends on the strength and level, while the staff formula depends on strength, magic and level. The advantage to this kind of formula is that it allows the player two avenues of growth - building their stats, or building their levels. The downside is that it also penalizes characters both ways as well. What this really ends up doing is allowing the player to level up to increase their damage output (for FFXII this amounts increasing their damage output by ~4% per level around level 50 when you factor in stat gains) to help customize the difficulty to their comfort level. Fixed Damage: Fixed-damage formulas do not depend on the character's stats or level, they depend only on the internal damage formula of the weapon itself. They can still vary over a range, but they deal the same damage regardless of the user (barring any other special effects or character traits). They're best used if the weapon is going to do fixed-damage and the ability to equip the weapon depends on either stats and/or level. Diablo 2, for example, does this, as do many roguelikes which have weapons that depend on die rolls. That being said, 'fixed damage' does not imply "non-random" - and in fact there's usually some element of randomness to the damage done. This is a good methodology if you want to have weapons that are easy to transfer between characters or to carefully control the damage output that characters at certain points in the game can do if you know what equipment they have access to (via drop tables, chests, and steal tables). Another place you'll run into this is with certain types of equipment or items in Final Fantasy. 1000 Needles, for instance, always deals 1000 damage. In Final Fantasy Legend II, martial arts deal damage based on the formula: