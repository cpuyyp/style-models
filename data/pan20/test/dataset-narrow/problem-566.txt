Recursion adds its own cost, though, so whether it's faster in practice would require testing. An alternative would be to add a second iterative compression function: 

At this point you can probably guess that I'll recommend doing away with the list. A generator should work. If on Python 2, is probably better than as well. (Note, I didn't mention . That could be changed into invocations if you are on Python 2, but you seem to be on Python 3.) 

Yes, path compression. You descended down two paths from and to and and it took \$O(log\ n)\$. At each step you can point a node to its root, instead of just the next element. You can do this recursively like so: 

The actual hashing is done in and OpenSSL. Those pretty much cannot be reduced, so at best it could be made ~3 times as fast. 

However, beware. AFAICT, the item could have been deleted by another process in between checking whether it exists and deleting it. You should probably just delete the item and raise an error if that fails. 

Read the input in blocks, which you sort and save into files. Merge the files while iterating by always choosing the extremal item. 

By choosing block size close to , you only need to keep about \$\sqrt x\$ items in memory at a time. 

You are saving some data that you never use. , never used after this. The whole parameter is unused if you remove the assignment. already is. If you remove from here, you can also remove from . 

I think the logic for getting the minimal distance between the points would work even without the explicit check against MAX_INT: 

I especially like the point of @Mike, namely that you should generalize your code. I would suggest taking this idea one step further, by having the situations and the choices in some data structure (e.g. JSON) and having only a single div, where to render the text and the corresponding choices (as opposed to one div per situation). To be more concrete, I am thinking about something like this: HTML: 

As I said above, I'm not saying that this suggested change is necessarily better than the code you have now (in fact it is a bit more over-engineered). It is rather a way of exploring how to further OOP-fy your code. Test Code Let me first say, that I find it a really positive thing that you write your code with testing in mind, and add unit tests to cover (almost) all the cases. That said, some remarks: 

Alternative While the recursive approach is elegant and easily understandable, it might be less convenient for very long inputs. I suggest another solution, based on the idea, that if you want all permutations, then each character can either be part, or not be part of a permutation. This gives us 2^N possible permutations, where N is the length of the input. So, you can just generate this number (2^N), and then iterate from 0 to 2^N-1, and calculate the corresponding perm. for each number. So, if the number is represented as binary digits, then 1 means that the character at the corresponding position should be part of the permutation, 0 that it should not. (If you do not need the empty perm., just start the iteration from 1, instead of 0.) With your example, 'AA2', this would work as follows: N=3, so iterate from 0 to 7 (=2^3 - 1). 0 corresponds to the empty set. 1 = 001b, so '2' is part of the permutation. 2 = 010b, so only (the second) 'A' is part of the permutation. 3 = 011b, so the perm. is A2, etc. Remarks: 

Recursive type definitions are common. The thing to remember is whether or not your model whatever you're modelling. In you case ask yourself 

what you have posted is orthogonal to MVC. MVC deals with user interfaces. It has later been reshaped many times to fit various platforms such as the web but the original ideas came out of Xerox some forty years ago and tryed to bridge the gap between the user and the model in the computer (the M) though it's known as MVC it actually MVC-U where the U is for user and the U is there to stress the relationship between the system (MVC) and the User (U). There's no interface in the code you've posted and hence at best it can be viewed as a mechnism to start some (sub)system that's build on MVC. The Model is suppossed to represent piece of the users mental model. How they see the world and it has been shown that if there's a 1:1 relation ship between the real life model and the one in the system Users are better at using the system. The view is what the user sees. You can say it's a visual representation of the model and the controller is coordinating user inputs and model updates (which in turn are reflected by an update of the view) So the short answer would be "no" but the longer is more down the line of "MVC is something unrelated to the problem you are solving with the above code" 

This will return . However, is misplaced here, because it should be at position , and it is, instead, at position . To be honest, I don't really know what would be the best solution here. I can imagine the following: 

For the refactoring, I suggest that you should wrap the logic of the for-loop into a do-while loop. Something like this: 

You can write e.g.: "The implementation of {@link #save() save()} function is optional." Same holds for the JavaDoc of the method itself. 

Discussion: first of all, please note that the above code is rather a proof of concept and not a full solution. Besides the missing effects (which you can add if you choose to extend this example ;) ), it can be improved in many ways (e.g. not putting game state and functions into the global namespace, but rather enclose them in an object). That said, let me point out the advantages of this solution: 

Out of scope The quality of the hash-functions used for testing is out of scope of this review. (I know there are much better ones, but for now I focused on the data-structure itself.) However, if you know a way to e.g. better organize them, and avoid repetition (but without making that global!), that would be very appreciated. The code 

Further remarks: Robustness I recommend some extra checks to your program, to make sure that it is robust to potential wrong input: 

The answers to most of your questions have been given and aside from consistency in naming and using BigInteger there's not much more to say to the questions however A more general comment would be that Fibonacci sequences makes for an odd class. It's a function more than a class and what you've implemented is basically a way to curry the argument to the function and that leeds to a somewhat odd class design. Not because your design is odd but because the tool is not the best one for the task. If you are modelling a function as a class where does the result then go? as a calculated property or the return value of the single method? So instead of modelling a function that returns the n-th number you could create a class that represents a fibonacci sequence 

Whether or not this can compare speedwise with other implementations depend on how well the optimizer can optimize the code 

to get the second number in the sequence. Of course you could use memoization and an indexer to speed up consequetive calls. The below does that (not thread safe) 

Since you are essentially performing a fold of the list and returning a tuple you could express just that in the code which would also be rather short and still only loop trough the list once 

of course the answer is yes to all three and that proves your model is sensical from that respect. Last question would then be "Does my chosen platform allow me to express this model" and the answer to that is also yes. In a more generalised form. When you consider inheritance ask your self whether there's a "is-a" relationship between objects of the derived and base classes. If the answer is no don't use inheritance. If the answer is yes it's a candidate for inheritance (doesn't mean you should always use inheritance though). For members as yourself whether the containing model has a "has-a" relationship to the contained model in the real world. If not don't included it in the containing model. If yes consider composition a candidate 

Why is this last point advantageous? Because you can easily add more situations, without the need to copy-paste the gui elements (wrapping divs). Besides that, it is also possible to quickly change the gui implementation. (E.g., if you decide to have divs instead of buttons, you do not have to change every one of them.) I created a fiddle, where you can try the concept. (Unluckily, the built-in fiddle of SO is not available from tablets...) 

Is this a correct implementation of the data-structure, or do you see any flaws? Is there a way to make the implementation more optimal? (E.g. is there an elegant way in to jump out of the if we encounter a bit not equal to ?) Related to the above: is there a way to make this code more idiomatic? (I.e., conforming to Clojure best practices.) Can you think of any missing tests? Or some other edge-cases which are not covered? 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

But as I understand, this code does not show any digits, just fills a space with a colour. Is this the intended behaviour? If so, then I suggest documenting why is it like that (in a comment), otherwise, I propose to extend the functionality so that seconds are rendered as well. On a side note, I recommend to use always the block-form of if-else statement (and any other statements), even if it has just one instruction per branch. In other words, I suggest rewriting it as follows: