May I suggest that you buy the book Artificial Intelligence for Games by Ian Millington - it's excellent! :) $URL$ The source code is at Github - MIT license. Of course, if you're not using C/C++, then this might be less relevant. But really an awesome introduction to the world of Artificial stupidity/intelligence. Things you're going to need from it are steering and state machines. For starters. 

Try FontStudio: $URL$ It's made especially for creating bitmap fonts for games. I post a link to the Ogre3D forum, because it hasn't got a home of its own currently. Find a link to the latest version in the last post of that topic (page 2). 

Unity3D is developed using Mono, so of course you can! Just be careful. Like the others said: test your code as often as possible on 'the other OS' - and by that I mean daily. Unity is available for Windows and the Mac, but since Mac essentially is unix, I guess it's only a matter of time/effort before Unity can target Linux.. 

A good resource manager is key to how well - and how flexible - your game 'engine' is going to be. Not only does it solve a lot of problems with low level resource management, but it also helps to ensure that resources are loaded only once, and then reused if they are already loaded. If the resource system is abstracted well, the underlying details can wary between file system, physfs storage, sql even... You just request a resource, and it's given to you. No need to worry about resource IDs and stuff like that. Duplicate resource conflict handling, etc. Let the resource manager sort that out. Depending on how you design it - if C++ then make friends with your scenemanaging class(es) to ensure that ownership is properly handled. Resource pool ? No problem. Forgetting to release resources? No problem. Same interface to resources no matter where they are: memory, disk, archive, network. No problem. Do you want streaming? Threading? Let your resource management hub take care of that. And you can rest assured that it will inform you when the resources are ready to be used. Ogre 3D has a very flexible resource management system, but I am sure there are others 'out there'. 

At start you could disable its Rigidbody component or the script that is moving the tower. Then re-enable it when ever you want. 

I have a model of an SMG with arms exported from Blender and set to generic rig in unity import settings. I was creating an animation for this model in Unity Animation tab, it included changes in position and rotation of the individual parts like magazine and left arm and gun itself. Then when I was satisfied with how the animation worked (I saw it by pressing the play button IN THE ANIMATION TAB). My problem is that when I click play IN THE GAME TAB there is no rotation and some movement, only some parts move (but not rotate). Does anyone know what could be my problem? I am not sure what screenshots to post so tell me what you need to see and I'll add some. Thanks in advance. 

You could use RigidBody2D.AddForce(Vector3) to make knockback or you could have and animation of the player being bounced. 

I believe this happens because the bullet's speed is very fast so the collision doesn't have enough time to be detected, that's why I prefer using raycast for the shooting. 

You could try and check if the distance between two objects is increasing or decreasing or you can use an infinite raycast and check the object it hits. 

Take a look at this OpenGL getting started page: $URL$ You'll see that The Communist Duck is right: it's just a matter of downloading a header or two from the extension registry: $URL$ However, as he also said, it might be easier for you to download an extension handler which does all the gritty work for you, like GLee - or GLEW: GLee : $URL$ GLEW : $URL$ 

The best way of having your programmer art replaced by real art is to carry on making a great game. Pimp your game as often as you can - concentrate of game mechanics first - then I am sure that you'll attract some artist types - maybe even for free (join the team). This approach is probably the only one if you're short of cash, and/or want to stay free. Programmers art could make sure that you concentrate on the most important aspect of your game: the game itself. There are of course places where you can grab models and art under an open license, but I would just carry on making a game if I were you. Don't bother spending too much time trying to learn how to be an artist yourself. That skill takes years.. 

My advice would be: Do! But only if you have a use for it. No need to create a DSL if you are just going to use it yourself - internally. Galaxy is the scripting language which the Startcraft II editor is using. It's a prime example of a domain specific language. It targets game designers rather than programmers: 

Try decreasing the amount of the rotation, so change 5 to a lower number like 2, if that's still a lot decrease it even more. 

Use rigidbody.AddForce instead of transform.Translate so that the collisions are detected. For the direction create a variable with the difference between the target and the object itself and then normalize to find out the direction. 

So I'm creating a zombie game where the zombies are passive and just walk randomly all over the area when player is not near. My question is: how would I make zombies move randomly? I code in C#. Basically, there is a town filled with zombies that just wander around the area (walk randomly everywhere slowly) until the player is seen or is very near. Thanks. 

Check out this link $URL$ this link shows another question asked on unity forums and shows an answer which also contains a link to a showcase video. 

I believe what happens is that you set the Time.timescale to 0 in the start menu script but at the same time you have the pause menu script setting the Time.timescale to 1 because your variable pause is false. So what you could do is change your pause script so that it only is able to resume the game (set pause to false) if the game was previously paused. Another option is to make another public Boolean variable (for example called "canRun") in the pause script then when ever the game starts (eg. Start button is pressed) you set canRun to true from the start menu script. In your pause script you adjust your if statement to check for canRun as well. Change this if statement: 

Sample Tutorial Lisp is the perfect language to use to create domain specific languages, but there's other options, of course. Like Boo. That way your designers/modders don't have to learn programming, even if it's just Lua, it's still programming. Edit: Let me add that a DSL can be implemented in a scripting language - it's not synonymous with not using a scripting language. Especially if you are using Lisp or similar, since it lends itself extremely well to create domain specific languages. 

I know that this does not really answer you question, but bear with me: Why not (pretty much) every format? Use Assimp: $URL$ There's examples of loaders using DirectX - I found one here: $URL$ In addition to the Assimp Viewer shipped with the Assimp project. That should get you started using all the formats Assimp supports: $URL$ It's probably possible to serialise the meshes as XAML - I bet there's code for that out there.. 

I have problems with that too, actually. Let's say you have a Game. Instead of making 'Game' a state like 'Loading', 'Main Menu', etc. - IMO it's better to let Game have several states: "Loading" - "showing menu" - "paused", etc. The Game is still running, but when it shows the main menu it would be in 'show menu' mode. And when Game is not in any particular state, it's just running. It makes much more sense, at least to me. :) 

You could try and create 3d game objects like cubes and spheres, then as those have colliders place them somehow to fit approximately the walls, the floor and ceiling and then just remove the mesh renderer component from those objects to make them invisible. 

In my scene I have two cubes one has a tag "Respawn" and another one has the following script attached: ` 

I have done a texture in GIMP and imported it in Unity but for some reason the texture appears to be squashed in the sides. Image done in gimp: 

Objects shouldn't pass through each other if both have colliders. You could disable isKinematic on the rigidbody and then use AddForce to push. You could use also transform.translate() to move the player. 

You could try making the sword and the hand same object so when you animate the hand the sword will be animated too. 

When I run it and move around my second cube with "Respawn" tag the first cube doesn't always looks at it, at certain point it just starts rotating the opposite side as if it has bounds to it's rotation. What am I doing wrong? 

You can use: transform.Translate(Input.GetAxis("Mouse Y"), 0, Input.GetAxis("Mouse X")); Or if you want to use physics: rigidbody.AddForce(Input.GetAxis("Mouse Y"), 0, Input.GetAxis("Mouse X")); 

In Unity i have a model of a tree with leaves made of a plane and a texture, when I upload it to unity the texture is only visible on one side so how can I change it to be visible from both sides without increasing the polygons. And I am not familiar with complicated shader programming and stuff so could you please explain in detail. Thanks I'm advance. 

I know this topic is flagged as 'solved', but IMO you should look into FBX. Autodesk is using that format, and it's the exchange format of all the major 3D programs. So don't bother with Collada. It's bloated, unintuitive - and not backed by the major players. Which is Autodesk - they're are buying pretty much every 3D app out there. Autodesk FBX SDK: $URL$ 

$URL$ I agree with these remarks and think it is a stellar discussion of why DirectX is better than OpenGL. That journal is in response to David at Wolfire. I hope that serves to balance it out a bit. ;) But in general, if you're using a cross-platform, cross-API framework: Use DirectX on Windows and OpenGL on *nix. 

The domestic market is huge in the U.S. and thus it's much easier for any company/industry to succeed. In Europe, you have to cross borders to get a market. It's not really directly related to the game development business. 

Globals are much faster! So it would fit perfectly for a performance intensive application, like a game. Singletons are a better global, IMO, and thus the right tool. Use it sparingly! 

There are one major source of open sourced models for Ogre3D available: WorldForge Media Repository WorldForge assets are licensed under the GPL, meaning that you need to contribute back any changes, but you're free to use the models in any project, closed source too. Then, a repository not directly available in Ogre format, but very useful none the less: Ryzom Asset Repository Ryzom assets are licensed under the CC by Sa (Creative Commons) license.