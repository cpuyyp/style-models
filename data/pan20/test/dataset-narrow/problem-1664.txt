There is such thing as , which is supposedly sourced by DM's and and . So you could make it a softlink to . In this case, you should make a link to , since this is used too. 

No result. Here are the results for a similar online search of Debian's jessie stable, all architectures (i.e., including the basis of Raspbian). I also tried "tetramino.py" in case there was a minor typo in your question. Note these searches include all available packages, not just all currently installed ones (as per ). 

If you're truly proficient with js, I recommend the last one. If not, you might as well start learning one of perl/python/ruby and go with apache or nginx (I left php off that list because IMO the other three are more truly general purpose languages, and hence more generally useful to learn). Because C++ is unnecessary, and probably not advantageous for, writing web applications, it is pretty unusual -- which is why there isn't much in the way of utility libraries for helping with that. It is also much more labour intensive than python/perl/ruby, and so those three (plus php) have come to dominate the niche. 

However, if you are using , the comparison operator in (or square brackets, which are a shorthand for ), then there should be either be a space on both sides (beware it will work without any spaces, but not as intended...). And yes, is a comparison operator in shell, synonymous with (except within bash's , see here) -- and it tests for string equality, not numerical (although since numbers can be treated as strings, this can be a subtle distinction). 

These should drag in X and other dependencies if they are not there already. If you wish to start X from the command line using or , you'll need: 

There should be a man page (); the options are also explained here. I do not see a "background" or "damonize" (similar concept) option there. This is probably because was written specifically for the pi to exploit hardware acceleration for video playback (it may be less unique now in this sense than it once was); it will play audio mp3's simply because (educated guess) it needs to include that decoding/playback code anyway. However, using the audio system on the pi does not require any special software written for it, so if all you want to do is listen to mp3's you can use anything that runs on linux. For a command-line interface that I think will background, try (); I believe this should be set up to use ALSA as the soundsystem so if you are using and don't hear anything, that's why (it could also be vice versa). Checking here (), you can list the possibilities with: 

When the button is down/the switch is closed, voltage flows from to ground, so the state of the pin, as determined by the logic gate at , is 0/off. The reason for the resistor is to prevent a short circuit -- from the output which drives this circuit (red wire/) and NOT the input (green/) where you are testing the logic. The term "pull-up resistor" can thus be misconstrued if we take it to mean a resistor which affects the input pin. It doesn't affect the input at all. The actual "pull-up" (a connection to ) is what affects it. The "pull-up resistor" is a safeguard on the pull-up. The lesson here WRT to potential short circuits is don't accidentally set an input pin connected to ground as an output pin and drive it high. 

To create a default one. How closely this all has to match for the module to work I'm not sure, except to the extent that it definitely does have to be from the same version tuple (3.10.25). If it's rejected as having mismatched symbols or something to that effect, you're out of luck. 

On a Raspberry Pi, do not bother with anything beyond 2 GB. If you end up using more than that, do yourself a favour and buy something that isn't a pi and has more than 1 GB RAM. 

Neither has any control over the other. A very accurate analogy would be, if you call your friend, you are now connected via the phone system. Who controls who in this scenario? We could say it is possible for you to control your friend or vice versa, either by agreement or some form of psychological coercion. Similarly, there are protocols built on top of serial that could allow one device to control the other; this would require a corresponding software implementation at both ends. Along those lines, by default the standard Pi operating systems are set up to use the UART port as a "serial console", meaning if you connect to that with a PC, you can login and control the Pi. However, this is easily disabled to allow whatever form of duplex serial communication you can find or dream up to occur. For example, you could run serial console programs from both ends to create a "chat" style scenario (where again, neither party has any control over the other). 

You can't, or at least, you can't use a static image. You could write a script to resize it dynamically depending on the size of the target medium. The other alternative is to resize on first boot, which is what Raspbian does. 

What's "slow"? A transfer from the SD card can't exceed the speed of the SD card reader, which with a decent card will be 15-20 MB/s and has an absolute theoretical maximum of 25 MB/s. At ~20 MB/s it should take 1.5 - 2 minutes to transfer. If the system is busy with other I/O to the card, e.g., you are still logging, I would expect that to have a noticeable impact. The USB and ethernet jack share one bus limited to 280 Mbps total (35 MB/s), which should be enough to allow for any network connection and the transfer to occur simultaneously at high speed, but that's it. So this could be a factor as well. 

The alias does not work for 1 or 2 reasons. The 1st is that aliases are not expanded by default for non-interactive shells. The 2nd is that the alias may not even be defined for non-interactive shells, depending on where you defined the alias (stuff in "bashrc" files is never loaded for non-interactive shells). If the alias is defined (eg, because it is in an applicable "profile" file), then you can set: 

With regard to "on its own network", this means putting the wifi interface into access point mode -- whether it is an ESP8266 or a Raspberry Pi (or a smartphone, or a desktop, etc). It is somewhat more complicated on the Pi than it is with NodeMCU, since the pi is a general purpose computer running a multi-tasking operating system. This question should get you going on the two key elements: 

If you want to resize a partition, either on the card or in an image (you should be able to mount the partitions in an actual image file on freeBSD, but I do not know how) there are actually two steps: Resizing the partition (e.g., with ) and resizing the filesystem. Which order you need to do them in depends on whether you are shrinking or growing. Partitions within a device image can be mounted and modified, the image shrunk appropriately or recreated from scratch. Some tools may do both at once for you. 

This should not be happening, in case you are unsure. Plugging or unplugging the HDMI should not cause a problem. If the system is actually still running, you should be able to plug the HDMI cable back in and see whatever was there before. If not, this is a further clue it has stopped for some odd reason. If it has stopped and the ethernet was on, the green LEDs indicating the link is up should go off -- that would be another clue. If it appears it has shut down, you could unplug it, take the SD card out, and look at the end of logs in (e.g., and , if they exist) for messages that look relevant and have an appropriate timestamp. If the system still seems to be running (e.g., the ethernet link lights are on) but you can't get it to respond anymore, you'll have to unplug it anyway. Wait a couple of minutes to increase the likelihood of stuff being synced to disk, then unplug it and have a look in the logs as described above.