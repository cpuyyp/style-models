I know, it has the magic number for the k loop, but at least it checks each key.... Ideone I have put my recommendations in to this ideone... take it for a spin 

OK, so we have a method, that takes your arguments, and returns a function that filters a CSV record if the right field is matching an argument. Now, our main method can have: 

but your JSONClient code does not implement so the remove will do an identity check to do the comparison, and thus the remove() will never remove anything because you can never add a client twice. Why have the ? Additionally, it appears that your JSONClient class is used as both the client-side class, as well as the server-side handler. I don't like this model. You should separate those concerns, and, if needed provide some abstract-class functionality that both sides can use. Having both concerns in a single class makes it complicated. 

Posting the campaign e-mail could be a slow task and (even if it was fast) there is the possibility that another instance of the program may be processing the same campaign at the same time. If you are using a database for your campaigns you should consider a different approach. I recommend: 

(note I added some spaces around the as well). has me really confused... you store it at the class level, and you never 'reset' it. This makes me think you create a new instance of each time you test a .... otherwise the will just keep getting bigger, and bigger..... I believe that should also just be declared inside the method, and not as a class field.... 

use only one thread, ever. use synchronization, correctly. use constructs in the java.util.concurent.* packages, correctly use volatile 

Using a distinct set of badge names from the Badges table required multiple scans of the data. Processing that data with a set of in statements for each badge type was uglier than needed. The multiple stages of case statements to process the data was somewhat overly complicated. The ugly transform (again using case statements), to get the data from row-based to column based could be done better. 

Note that the method is now static, and it does not need the section to clean up. You can see this running in ideone: $URL$ 

Using this system, the socket STAYS OPEN ALL THE TIME... do not close it! This is the way that TCP is designed to work. NOTE, you need to make the corresponding changes on the server side as well.... The server cannot keep closing the socket after every transmission... it needs to read a line, process it, and wait for the next line without closing the socket. Read up on the Java Socket Tutorial.... 

Now, in that table, you have the correct RepaymentType cross reference for the update. Your update now simply becomes: 

Now, that's pretty complicated, right? Well, it does a "quick" integer regex check, and if it's likely an integer, it tries to parse it as an integer, and fails over to a double, and then to a string.... If it's not likely an integer, it checks if it's a double, and so on..... How can this code be faster, you ask? Well, we're almost certainly having clean parses when we do them, and we'll have almost no exceptions... But, is it actually faster? Here are the results: 

Now, as for determining whether two bits are the same, or not, I think that function can be improved, but I have not really run the truth table on it. The code is simple enough to understand though, and readability is important in these things. Using the hint from ErikR - this algorithm would be faster though too: 

This is a generic method. You can throw pretty much anything at it from any collection structure. An implementation of the method would look something like: 

About the This is the second reason to consider wrapping your current sort-entry method in to a calling method.... something like: 

Your code attempts to loop through a million input records, but your concurrency is set relatively low at 1000. After you have looped a thousand times, you have 1000 go-routines all looking to write a result to either the or channels.... but, because those channels are unbuffered, there needs to be something reading from them before they can be written to... ... but you have to queue up all 1000000 CSV records before you start to read those channels. Because you never complete the loops (you're blocked writing to the channel), you never release a value from the either.... thus, you never get to progress in the loop. Your code is buggy. A solution would be to put the entire CSV-reading code in to a separate go-routine, so that your can start reading from the / channels immediately. instead Instead of having 2 return channels and , it would be better to return a simple struct: 

Apart from this though, the program seems reasonable (I have not run it). My only comment is that this uses relatively advanced features of the shell. In my experience, it is often better to write these things in perl because people expect perl to do more complicated things. I don't know if this is sounding right, but, even though perl may be slower than this solution, it is also something that sys admins are familiar with, and will be happier to maintain than a complex shell script.... Still, if the people maintaining this code are familiar with what you are doing (and the fact that you are asking on CodeReview rather than using your peers is a suggestion that is not the case) then I would say it is fine. 

Your algorithm has two loops, and that's really not necessary. This question is looking for a special 'trick' to be done.... and that trick is to process the data in reverse order.... Consider this loop: 

Your function is fine, given the specification, but there is jut an issue of input validation... what about negative values? Your current loop condition is . This would be better written as . When you see the it makes you wonder if there's a condition that's weird. In this case, there's not. Further, your code excludes all negative values. What about the sum of ? That makes me think that the code should all be looped on the condition , but that would sum as -6, and not 6. I was initially tempted to suggest that you have the code: 

So, because of this inconsistency, I imagine that you really want the to be a generic type.... and you should specify it as part of the class signature: 

Running the CountDownLatch code with the previous LockFree code, and the original, I get the following results (Note they were run at a different time to other results in this post, and are not comparable with them). 

Your desire to use the "functional way" is not well-motivated. Why do it "the functional way" when the "other way" is not only easier to read, but also common practice, and well-understood? 

When you have cascading if-condition logic like you have in your first if-block, consider using a lookup table instead. Lookup tables pre-process the data in a way that makes the use of the data much faster. How would this work? First, define where your boundaries are: