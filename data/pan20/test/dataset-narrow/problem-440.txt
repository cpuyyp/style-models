My introduction of the algorithm This is the algorithm to apply trie knowledge and also use maximum weighted independent set knowledge. And the algorithm is one of medium level in February 2017 RookieRank 2 contest. In the contest, I implemented the trie algorithm but failed test case 10 afterwards. So, after the contest, I studied the algorithm and one of submissions, write C# code to ask for review. Most of my time is to learn how to implement a trie, and also help myself understand prefix neighbor. The return statement in the function is so confusing, for the test case of string dictionary , the stack of return statements and when the prefix neighbor is set, definitely need better solution in my opinion. 

Explanation 0 The value of \$total\$ is maximal if the students form the direct friendships in the following order: 

Checking out 8, found 7, 8, 9. We have lookup[4][5] = lookup[5][6] + 1. In other words, 8 is the average of 7 and 9, since 8 = (7 + 9)/ 2. This is also a simple example of AVERAGE subproblem. 

You are given \$q\$ queries, where each query is in the form of an unordered list of \$m\$ distinct direct friendships between \$n\$ students. For each query, find the maximum value of \$total\$ among all possible orderings of formed friendships and print it on a new line. Input Format The first line contains an integer, \$q\$, denoting the number of queries. The subsequent lines describe each query in the following format: The first line contains two space-separated integers describing the respective values of \$n\$ (the number of students) and \$m\$ (the number of distinct direct friendships). Each of the \$m\$ subsequent lines contains two space-separated integers describing the respective values of \$x\$ and \$y\$ (where \$x<>y\$) describing a friendship between student \$x\$ and student \$y\$. Constraints 

Introduction of algorithm The algorithm is very good one for me to practice write a depth first search and also start to learn LINQ. I still remembered that I did the practice in June 2016, and the code was written and saved as a gist here. I reviewed the code today, and rewrote the code to make a new base case selection for depth first search. Based on the facts that last 12 months I asked questions over 35 questions on this site and also I have practiced mock interview over 100 times since this March 2017, I have more ideas to review my own code after six months. I also learned from my mock interview experience last month missing a base case. Code improvements I decided to make a few improvements based on my last practice over 18 months ago. Internal class is used instead of external class. I choose to use camel case for public method, and rename the function DuplicateCheckingPathSum to make the function name self-documenting. Specially I took 10 - 20 minutes to go over those stackoverflow links to learn LINQ and also ASP.NET C# class and I found that those links are really helpful for me to warm up LINQ. It is tough for me to see that after 18 months I still do not make big progress on LINQ and the functional programming syntax still looks like foreigners to me. Most of important change is that I learn better recursive function design after 18 months. I was surprised that I ended my last practice with so many issues. The base case should be selected to avoid duplicated count of each path. I like to see the depth first search algorithm specially a recursive function is written in very structured way, base case is very clear and also the recurrence formula afterwards. Please share your advice on my journey to be a good thinker on depth first search on binary tree. I still make mistakes on depth first search and have interest to know how to choose the base case as an art and scientific approach. 

My Introduction of algorithm This is the first medium algorithm on Hackerrank RookieRank2 contest in Feb. 11, 2017, I played the contest and then I spent hours minutes to write the algorithm in C# programming language after I spent at least minutes to understand the problem. The best performer only needs to take less than minutes. I spent extra time in the contest to change the code from directions to directions after I failed some test cases, I should have worked on possible directions to next move in the design before I start to write the code. The C# code passes all test cases on hackerrank. 

Introduction of the algorithm The longest arithmetic progressions algorithm can be solved using dynamic programming method. I spent several hours to study the algorithm. I read the paper called "Finding Longest Arithmetic Progressions", base on the author's introduction in the paper, the lower bound algorithm is O(nlogn) based on the algebraic decision tree model of computation. I will try to understand the lower bound algorithm later on, also I like to read the related question called Longest equally-spaced subsequence on stackoverflow.com. Dynamic programming The longest arithmetic progression can be found in O(n2) time using a dynamic programming algorithm similar to the following interesting subproblem , which can be called AVERAGE. AVERAGE subproblem It is to determine whether the input contains a three-term arithmetic progression, or equivalently, if any array element is the average of two others. Test case analysis I like to use a 7 x 7 matrix to define the lookup table based on the test case {1,3,4,5,7,8,9}. Base case is to set lookup[i][n-1] = 2 for any i from 0 to n - 1. 

Problem statement Similar to Leetcode 37 Sudoku solver, the algorithm is to determine if the sudoku board can be filled with ‘1’,‘2’,…,‘9’. A sudoku board is represented as a two-dimensional 9x9 array, each element is one of the characters ‘1’,‘2’,…,‘9’ or the '.' character. The dot character '.' stands for a blank space. The sudoku solver should fill the blank spaces with characters such that each row and each column and each 3 * 3 matrix forming 9 * 9 matrix have each character of '1', '2', ...,'9' exactly once. In every row of the array, all characters ‘1’,‘2’,…,‘9’ appear exactly once. In every column of the array, all characters ‘1’,‘2’,…,‘9’ appear exactly once. In every 3x3 sub-board that is illustrated below, all characters ‘1’,‘2’,…,‘9’ appear exactly once. 

Debug the code, and check how many times the dictionary is looked up. 3 times. key = "0 1", "0 2", "1 2". Draw a recursion tree for this simple test case. Here is the graph: 

     0 1 2 3 4 5 6 _________________________ 0| 0 0 0 0 0 0 2 1| 0 0 0 0 0 0 2 2| 0 0 0 0 0 0 2 3| 0 0 0 0 0 0 2 4| 0 0 0 0 0 3 2 5| 0 0 0 0 0 0 2 6| 0 0 0 0 0 0 2 The idea of applying test case analysis is to tutor myself to learn how to solve the algorithm using dynamic programming method step by step, later on I can apply this technique to other dynamic programming algorithm as well. Practice for mock interview I was told to practice this algorithm when I practice mock interviews February 18, 2018 weekend. I wrote a C# solution based on the above test case. The algorithm is not too hard, but it is hard for me to come out the idea to define the subproblem AVERAGE the first time. 

My introduction of the algorithm The algorithm is one of medium level algorithm in hackerrank woman codesprint in Nov., 2016. It can be solved using recursive function and memorization. In the contest, I did not write the recursive function because I overcooked the solution, ended up with a few hours scoring from maximum score . I learned the lesson, write less code, avoid complicated code, think recursively. And I documented the study how to think recursively and tried to learn the simple recursive function. After 3 months of the contest, I reviewed the algorithm again, and spent one hour to rewrite the C# code based on one of submissions I studied 3 months ago. Please help me review the algorithm. The C# code passes all test cases using hackerrank online judge. 

So, following the table from left-top corner, row by row, top to down, frequencyTablep[0,0] = 1, 0 can be divisible by 8, even 0 is not a subsequence of 968. We add to the table first, and then later take away 1 from frequencyTable[2,0]. So the numbers obtained from sequences of are ,,, is the answer. C# code passes all test cases on hackerrank online judge. 

We then print the number of squares she can attack from that position, which is \$9\$. My introduction of algorithm: This algorithm is a medium one in hackerrank world codesprint 9 contest, and I like to code review the solution I wrote after the contest, instead of the one in the contest. Because in the contest, I did not encapsulate the 8 directions very well, I spent time to write code for each direction. And I am studying the open/ close principle, the idea of implementation is the similar, do not write if/ else code to discuss each direction. Enumerate all directions by iterating the directions array once: 

This is the first time I answer one of my questions. Maybe I should make it a community wiki :-). Hash function design I did appreciate JS1 and all others help me to practice this algorithm. I did study one hour to go over hash function basic concepts after JS1's review, and reviewed one of the hash function's study I did after one of Hackerrank string problem - Sherlock and anagram in March 27, 2016. I chose the same hash function as following: 

Introduction of Algorithm The max score is the first medium level algorithm on Hackerrank Rookie 3 contest in May 5, 2017. The success rate is 14.10%, and I only scored 3.5 out of 35 points in the contest. In the contest, I did some work on recursive algorithm, but failed to implement the correct memoization, and did not know that bit mask is the solution to solve timeout issue. After the contest I was busy to learn and teach myself. I thought that if I am a good tester, very patient to go over a few simple test cases first, I must have solved the problem. So I like to try the idea on the algorithm after the contest. Two unit test cases are chosen, one is the array {\$1, 2\$}, and the other is {\$1,2,1\$}. Test case {1, 2, 1} C# code only passed first 5 test cases, timeout last 5 test cases. Source code can be looked up from the link. The solution is implemented with the correct memoization matching the recursive tree, but timeout since too many string concatenation. Suppose that the array has three numbers, int[] numbers = new int[]{1, 2, 1}. Calculated variable as Dictionary has the following: [0 1, 0] [0 2, 0] [0, 1] [1 2, 0] [1, 0] [2, 1] [,1] The key is encoded using the function: 

I have to write some code review and make some corrections on the above C# code. Testing using Leetcode 4 online judge It is Sunday Dec. 17, 2017, 10 months after I posted the question, I had a mock interview and then peer asked me to solve the algorithm Leetcode 4: median of two sorted array. So I shared my solution using the above code, but the peer sent an email to tell me that the code has bugs. I spent over 60 minutes to fix all the bugs using the code to solve Leetcode 4 algorithm. Here is the C# code to pass the Leetcode 4 online judge. There are several bugs in my original code. Missing one value 

My introduction of algorithm This is medium level algorithm on Leetcode.com. I have practiced over ten times from March 2017 to Jan. 2018. I wrote the algorithm in mock interview five times and also watched five peers to work on the algorithm. I experienced the pain to write a for loop inside a while loop four times, I wrote the code with a bug to print one row matrix twice, duplicate the output on last row and first column. And also I watched a few times the peer to struggle with so many bugs. Overall it is an algorithm with a lot of fun to play with. How to write bug free solution in mock interview? First time I had a mock interview on another mock interview platform on Jan. 23, 2018, and it is anonymous one. The interviewer asked me if I can write the solution only using one loop instead of four for loops inside one while loop whereas two for loops to iterate on row, either top or bottom row; two for loops to iterate on last column or first column. I had worked on the algorithm over 10 times on mock interview, but I never come out the completed idea based on limited time concern and buggy for loops. None of my peers came out the idea and wrote the similar ideas, and I only had discussion with one peer before. As an interviewer or interviewee, I did thought about four for loops are problematic as well. One time I complained to the peer in mock interview when I worked on the four for loop of this spiral matrix problem. I told the peer that I like to use extra array to mark visit, so that my four for loop can always go from 0 to rows - 1 or 0 to cols - 1. The code will take extra time to iterate on visited elements but definitely no worry to define the start and end position. The peer's advice is not to be a hacker in mock interview, you should always follow the interviewer's hint or advice. That is only time I made very close to this new idea. It is helpful to review all past practices through the code blogs. Here is one of blogs about the practice on spiral matrix algorithm. Analysis of the algorithm One thing I like to do is to write down some analysis of the algorithm before I write any code in mock interview. And it is also very helpful for me to go over various ideas to find the optimal one. I also like to practice this approach when I ask a question on this site. Here are some keywords for the spiral matrix algorithm. Direction - There are four directions. Change direction if need, in the order of clockwise, starting from top left corner (0,0). Range - Stay inside the array Visit - visit each element in the array only once. Do not visit more than once. Order - follow the order of clockwise, start from (0,0). Quick solution with readable code I wrote a C# solution and use extra space to declare an array to mark the element in the matrix is visited or not. To change direction, if the current row and column is out of boundary of matrix or it is visited before. I wrote the solution after the mock interview, I could not believe that I need so many hints in the mock interview after so many practice, one hint for four directions, one hint using extra array for visited array. Here is C# solution.