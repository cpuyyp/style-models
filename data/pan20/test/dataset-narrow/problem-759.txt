When you have map + function definition in one statement, consider creating a named function with a defn, or using a for expression: 

Your solution is great, I found it very readable. You can get a simpler version by treating all the words as a single sequence. 

Which is perhaps against the spirit of learning how to do it, so it is worth looking at the implementation code: $URL$ Which shows the correct way to test for various things you may expect in a tree (There are quite a few different tests you can take advantage of). and are cool, but it is probably more common to think of trees as data structures rather than lazy sequences; you will note that postwalk returns datastructures, not lazy sequences. So I recommend you also return datastructures (in your case vectors and lists, rather than a sequence). 

Both are equivalently readable, I'll nitpick on some details though :) Both solutions will fail with null elements. The generic type would be better named T instead of Type, as Type has another definition already. numElementsInArray() as a function looks a little odd because it is undefined, instead consider passing in the information you need as part of the method definition. When modifying in place you do not want to return the array because presumably you are trying to skimp on memory allocations and are just going to look for the result in the first array that was passed in. 

I've used a larger number of smaller classes here. We now have the benefit of easily being able to add a new to our game, we just make a new class, implement Location, and say what should happen when the method is called! Of course if you needed to do more things than just you , you could add new methods. But I'm a big fan of having as few public methods as possible in any given class. Your logic for checking number of tiles to towns etc. could all be done in the class. In your example, you have some logic around maintaining knowledge about whether or not you can drink from a location, I'll just add one more quick example about how you can do this, let's rework the class just a little bit. 

So I think we could break this up into 3 different classes. Let's talk about what our view can look like 

If you return the member variable songsInPlaylist directly, the caller can do whatever they want with that same instance of the list. (An alternative is to provide an unmodifiable version of the list. Note that if the objects inside the list are mutable, then you still have things to worry about.) Similarly, in your PlayList constructor 

Nice solution. Your solution already works great with sequences of numbers (and more) already. The multi-method is not a good idea. It is a function which can take either a seq or a number. You should avoid creating functions that take arguments that can be different types (it is confusing and suggests your might be better off with 2 functions or a protocol) unless there is a really good reason. In this case does not add anything useful (why did you add it? do you have an example use case?) 

update is 1.7 only, but you could also use update-in [:flag] I think this would be better promoted to a defn, and perhaps called something like 

Unwrapping deeply nested function calls is good where they are well named, small functions. When they are compound statements it becomes hard to keep mental track of what is flowing through the pipe vs what is flowing through the step. Creating a function spit-words for the (re-seq ...) would make the flow very readable as a thread. Named steps are good too, so it just comes down to whether the names are adding anything, if the threading is too complex, or the steps should be factored out. 

Rather than saving the answer in a static or object-level variable, you can return it from your functions. This lets you keep more careful track of what makes changes to it. Imagine if you had a lot of different functions like that incrementally update the answer every time they execute. If you started seeing the wrong answer due to a bug in the code, it could be difficult to trace it to the broken function. To handle the object-oriented way, rename to whatever you like, change both of your functions from to type, and return the partial answer and the end answer from each of them, handling them locally. You can make a new that calls your renamed function and handle the printing of the answer in instead of the function that does the work. 

is a primitive type, while is a class. That distinction won't cause a logical error here, but consistency always helps when a program grows larger and more complex. Order of Operations: Your program handles each step of the calculation correctly, but it doesn't understand Order of Operations. That's a more complex concept that you'll have to look at a whole expression for instead of being able to handle each operation piece by piece. The fully object-oriented solution is to treat the expression and the individual operations as their own objects and apply logic to those objects piece by piece. You could, for instance, create a list of numbers and operations, and scan through that list, applying the highest-priority (multiplication and division in this case) operations first. The fully functional solution is to scan the expression and use recursion to decide which numbers need to into first, returning the results of each step up until the base function returns the final answer. There are many ways to do it, and you can think about how you'd like to implement it in your calculator 

Consider using named constants, instead of magic numbers. A magic number is a number that has no clear meaning on its own. 

I'd just like to add a few more points on top of what @RobAu has already suggested in his answer. It's considered an anti-pattern / bad practice to use exceptions as control flow. In your program, you throw / catch an to re-start the user input process on an invalid input. I would recommend that you simply continually prompt for a valid value instead. You should keep the main method in a separate class. At the moment your class has multiple responsibilities. It's in charge of being the game, but also as the runner/driver of the program. I would expect the main method to look like this. 

and let the garbage collector worry about the rest. You would of course still need to check that all of these values are okay to use like this before hand. LinkedLists are supposed to be good at adding and deleting elements from the start. And if it's a doubly linked list, also the end. As side note, I would prefer to see your Node class as a private class inside your linked list class. As this Node class probably shouldn't be used anywhere else. Your public interface is a bit unusual, for a list, I would expect to have public methods like , etc. is an implementation detail, this should be a private method that's called when the list is empty. if I wanted to insert an element at the head of the list, I would prefer Another thing that stands out is your deleteNode method. This is definitely an implementation detail leaking out. A user of the list shouldn't know at all about Nodes. The method doesn't even take a node, it takes an int, I would prefer . Also, your list won't properly support duplicate values, if I have 3 nodes with the value if 5, and I try to delete 5, it will delete the first node with a value of 5 it finds. As another side, you should make as many variables private as possible. 

This assigns the operator to and performs the comparison without the need for a statement. You can use a do-while loop to handle the first number and print "Operator: " to the console before reading , if you like. 

This is often tolerated as a static variable, since we're very unlikely to change the fact that we're reading from System.in in the middle of our calculations. On the other hand, doesn't need to be static, and since it's a resource that should be closed when we're done with it, the best practice is to make it a local variable or manage it carefully as needed. The object-oriented approach is to use a loosely-coupled function like for your input, and then let all of the calculation happen in a different function. You might also want to be consistent with your arguments in 

Nice solution. This code is pretty legible, which is great if you have to debug anything. There are a few simple ways you can make your program more user-friendly and resistant to user error. Input: For the user, it can be tedious to type in their values on every line, always being asked for 

Object Oriented Programming: Generally, static variables should be reserved for variables that are shared between multiple instances of a class, and any other variables should be made local or non-static. The static variables you've defined here work properly, but reorganizing the methods and changing the variables into local ones will make it easier to add functionality to this calculator later. 

Now they can do whatever they want with the list they passed in, and it won't effect your object at all! Efficiency at the moment your selectSong method has O(n) time complexity, because you need to (worst case) iterate through the entire list to find your song. A better data structure to use here would be a Map. This allows you for O(1) or constant time access. Instead of your JukeBox being backed by a list, you could have it backed by a HashMap. So you could have O(1) access to any song given its name. Or maybe a Map, or even both. your selectSong method could look something like this 

Now, in order to be a , we just need to implement an method. So instead of maintaining booleans which describe the concrete class, we can make many smaller implementations instead. Let's have a look at a potential implementation. 

Unusual Behaviour right now, if I pop() an empty stack, it will return 0. This would be extremely unusual behaviour for an empty data structure. It wouldn't really be empty anymore would it? 

This will not prevent the calling code from mutating the objects in the list themselves, but it will prevent the underlying list from being modified. Now I'm not sure what your calling code looks like, but I would question the decision to add getters/setters for everything. I would recommend first making everything private, then only making a getter as you need it, and if you really need to make a setter, ask yourself again, then once more, and if you can't think of any alternative, you should then write a setter. see $URL$ There are plenty of arguments for and against getters & setters. You should read both to get a better understanding of when you should and shouldn't use them. And when you do write a setter, don't assign the reference direction, assign a copy. 

Can you use and to read in all of your numbers and operators at once, from a line like or ? matches a regular expression, and is the pattern for any single character. Error Handling: What happens if the user types in a bad operator? If someone tries to ask for , the operation is ignored in this case. Instead of getting the result of = 12, they could get a result of 21 without realizing there was a mistake. A good way to protect against that is to use a statement in your switch block. A way to handle these errors and let the program or the user know there was a mistake is by writing 

is never actually changed or used. is functionally equivalent to the loop that you wrote. This is a fairly common pattern, and there are a few ways to go about organizing it. Yours is handy because the variable communicates that this loop will continue until something is 'done'. The best place to explain to the reader how a loop is supposed to terminate is right there in the condition. One more descriptive (but also less clean) way to write that condition would be 

so all I know here, is that it's a list of Strings that represents the ships that player A has. But to find out how it does that, I need to go look at where and how it's used. So I search through the code and find this line 

We constantly append to the same list. Being able to compare cards for equality would be useful, consider overriding the __eq__ and __hash__ methods. And if you want to be able to do card1 < card2, you can also override __lt__ and __gt__ Final Comments My final suggestion would be, try and make a card game using what you've written. See what problems you run into, what works, what doesn't work. Something straight forward like War. Hopefully you found this review helpful! 

This comment is redundant, the append method on a list appends an element to that list, you don't also need to say that it adds to the list. Here is an example of a comment that's useful 

At the moment you're offsetting in 2 places, when in fact you don't need to do this anywhere! This is making the code more difficult for other people to follow. In your display method