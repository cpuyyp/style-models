Why do we need so many columns? The assignment is to return the movie title and reviewer name, so let's just do that: 

OK, if the array is invalid (a null pointer), 0. You are doing this check for every recursive call of the function, but this could only happen in the first call. You should actually do this check outside of the function (looking in , you already do this) and ensure that you always pass a valid array pointer into the function. That will save you a comparison on every recursive call. Get rid of this call. Note that the comparison to that you have in is the correct way to do it. The 0 check will likely work (because NULL is almost always set to 0), but it is less reliable. 

I would put the / over as little code as possible. This also makes it easier to add an case to the statement if necessary. For example: 

Note that I also changed the quotation marks. Double quotes allow variable interpolation, which you weren't using. Single quotes are actually slightly faster, so they are preferred for most strings. You may want to add some sort of output protection too though. For example, if is based on user input, you might do 

It is more common to use the long form of the opening tag. The second tag is only optionally supported by PHP installations. Also, it can suddenly stop working if your host adjusts the configuration (possibly accidentally during an upgrade). 

That's much clearer about what it's doing, but the truth is that you don't even need to do that in this case. 

When doing a comparison like this, you should really consider creating an interface, e.g. , so that you can maintain consistent method interfaces. You can then have your two permutation types implement the interface and use a templated generator class. 

Now I can easily see what I'm printing. Using and didn't tell me what they actually were, but and do. Move Semantics 

It seems to me that the original code will only work if you do all your Enqueue calls before doing your Dequeue calls. You can reset this by doing a Shrink or Grow, but there still seems to be a problem if you do an Enqueue after a Dequeue without an intervening size change. Why is Enqueue private? I'd expect two public methods: Enqueue and Dequeue. The constructor and the Count get property should also be public (as others have noted, set should be private). Everything else can be private. Note: I didn't try to be comprehensive here. These comments are in addition to those in the other answers, not replacements for them. If someone wants a comprehensive answer, feel free to copy my contributions. 

If there are any values other than , then you can look them up more specifically. Also search for a few values that you construct, e.g. for a of where , , and are disallowed, should be in the list. Also should be there. 

which says what it is doing explicitly rather than relying on a side effect. Also, I put it all the way around, as you want to force it to be a 32 bit integer all the time, not just when the value is not the default. 

The will trigger any resizes that may be necessary. You don't have to manage the number of open tags yourself. 

This allows the user to not know what the various types are, just how the user would describe them. Also, this allows the underlying implementation to change without impacting the user. For example, if we moved from a 32-bit operating system to a 64-bit operating system, the second case might change from to . 

Finally, if is greater than or equal to , you return . We can now say that what this function does is: it sets a global variable to the number of times that an element of the array is greater than all the members to its right; it returns the largest value from the array; and it produces output. That's three things done by one function, but the usual preference is to only do one thing per function. You mention that you are worried about efficiency. So apparently you put these three responsibilities into one function so as to maximize efficiency. I'll accept that decision. Perhaps someone else wants to argue it, but I think that there's some things that I can tell you within the parameters that you set. There's basically two things in this function that eat up time. One is that you do a lot of print statements (up to one less than the number of inputs). The other is that you are doing the recursive call. Presumably you have to do the print statements, so we're stuck with those. We don't have to do the recursive call. 

You shouldn't resize a by 1. It's an expensive operation, so if you're going to do it, do it up large. A typical expansion is more like 50% or 100%. It's not evident that this program would need to make a vector smaller at all. Either the stack is going to grow again or it will end and the entire data structure can be released. You do three things to implement a operation on your stack. If was a stack variable, you could just say 

Why is this so complicated? It looks like is how you represent the empty space where no tile is present. Since all moves will involve this tile, why specify it? Also, why get the and positions now? You could pass just the tile and get those in the function. Then you could write 

Why not make this an instead? Then you could output to things other than just a file. An is a limiting choice here. My quick read is that the best choice would be to have both an and an which extends it. 

Note that res can contain all the permutations (of which there are \$n!\$). This is what gives you your \$O(n!)\$ time. Note that it's actually \$O(n^3n!)\$ time, but the \$n!\$ eats the \$n^3\$. 

is an implementation detail and your caller doesn't need to know it. I also changed to . I think it better represents what the holds. I'm not sure that I'd call these brute force versus smart force. A brute force algorithm is one that tries every possibility once. A brute force solution would be to generate all \$10!\$ solutions and then randomly pick one. Your algorithm can actually iterate an arbitrary number of times (in fact, it's not guaranteed to finish). I might call it naive rather than brute force. 

Try to avoid the single statement form of loop control structures. It's harder to quickly scan and follow plus it can lead to a class of bug that can be nasty to debug. If always using the block form saves even one debug session, you'll come out ahead in the long term. 

is a class method. You can do that, but in PHP it's more common to include a module to do that and to put the HTML in the module. You could also put your head section in the same module. You'd call it like 

Rather than echoing the result, it would probably be better to it. That way you can display it or check for invalid values or whatever. This can also be seen as a violation of the Single Responsibility Principle: you are calculating the hash value; don't display it as well. If you really want to display it, consider changing the name to something like . 

The final semi-colon is unnecessary there. It doesn't harm anything (perhaps a wasted clock cycle on the null instruction), but neither does it contribute anything. 

I don't know the answer to this. For a definitive answer, you'd have to ask the interviewer. If you told us what the book actually says, we might be able to give you some guidance. As a general rule, it's good to ask the interviewer questions that show you understand the problem. Asking if it is all right to use the method of is perfectly reasonable. Another question that is relevant here is if you are allowed to change the existing order of the . Clearly it must be mutable, as you have to remove duplicates. It's not as clear that order doesn't matter. It might or might not. Complexity is an \$O(n \log n)\$ algorithm in terms of time. The rest of the method is linear (\$O(n)\$) in time. You iterate through once. This makes the method \$O(n \log n)\$ overall. In terms of memory complexity, the iteration is \$O(1)\$. It adds three variables, regardless of the size of . The is more complex. It can use up to \$n/2\$ new object references. That makes it \$O(n)\$ in memory complexity. This might be a violation of the "no temporary buffer" constraint. Testing It looks like you tested this code in place in the method. It probably would have been better if you could have written this as unit tests. As it is, each new test obliterates the old.