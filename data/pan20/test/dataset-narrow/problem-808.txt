At a smaller company I worked for in the past we used this. It is a script that compares PASS/FAILS, certainly not a bad tool to try out. Interested to see what others have used. 

Did you do an when you "backed up" the WsusContent folder? This will then have created a cab file that you could have imported into your new server (which would create the database when you reinstall) If you did not do an export of your data I don't believe you will have a cab file to import that data back. The command will check the update metadata in your database to the corresponding update files that are stored in WsusContent to check if they are missing or corrupt. If so, it will download them again. 

If you are running Hyper-V and wish to look at the performance on its current machine then I recommend the following article on How to Monitor Hyper-V Performance. Has come in handy in the past. I am not aware of any tools that can look at the performance of the Hyper-V layer which are inexpensive. 

The best way I learned Linux was being thrown into it. I was given a project on a non-production system which required learning many different steps both basic and advanced system administration work. From there I was able to use the wonderful world of Google to learn much of my tasking as well as reading "A Practical Guide to Fedora and Red Hat Enterprise Linux" This was one of the most helpful books I came across. Personally at this point it became what I was going to make of the learning experience. I may have spent more time than was needed to complete the project but the general point was the learning experience. This of course is my own opinioin, remember that people learn differently than others. Some can read a book and simply "get it" while others need to get their hands dirty to really learn. I highly recommend asking the individual how they best learn so you may set them up for success. You could also set him up with VMPlayer and load up a few different flavors of Linux which you may use in your area. 

Put this at the bottom of your file (it's in your user's home directory): cd /a/very/very/annoyingly/long/path/name Edit your . This method gives you quick tab-completable directory changes Mine looks like this, for example, since most of my shell work is in the two directories 'iliumSvn' or 'unix.varia'.: export CDPATH='.:~:~/iliumSvn/:~/unix.varia' 

First, you would normally want to use or or to get root privileges for an X application. Second, why are you using on Debian? (I mean is even enabled? It's not by default on Debian, as opposed to Ubuntu or OS X.) Third, I can't think of any circumstance where you actually need to run a browser with root privileges. There are cases when you need a gui application as root - say, you want to edit a system file (/etc/network/interfaces for example), and you're most comfortable editing with . That's not an unreasonable thing to want to do. But you would want to use or a similar utility to transfer the privileges. 

Some versions of support a or flag to show the tree of relationships between processes. If your version doesn't have that, check for , a stand-alone package to do the same thing. It can help in cases like this. 

If you can see the "Hello world" post from the blog's front page, but you get a 404 error from WordPress when you click the link, then I wonder if it's a problem with WordPress's links structure. Have you changed the permalinks defaults? (If so, the blog itself will offer you a handy-dandy set of rules to put into a .htaccess file.) 

The system wouldn't allow you to remove without a fight, just like it wouldn't let you remove your kernel or the tools themselves. One problem is that your question mixes two problems: (1) what is the set of packages that are minimally required for nginx as apt dependencies and (2) what is a sane minimal set of packages for a healthy working system. As an example, nginx probably may not depend in any libapt sense on sshd, but you don't want to remove ssh from a remote server. I actually think @tigran's answer is safest and quickest. You can install a minimal system in minutes, and this question has already been here a half-hour. Other than that, I would suggest that has very powerful search and matching options. You could probably craft a command line like this: 

Is the delay due to initial/pre-first index file load? If so, this could be due to DNS resolution. You can take out this factor in the following tests: 

Add the IP of the server to your client's /etc/hosts so that no DNS queries are involved. Run the test again and see if you have more consistent results. If the results are consistent, then the variability is due to DNS resolution. If switching to static IP doesn't help, try referencing the host via IP address in the addressbar when you test the page with your web browser. On the off chance the /etc/host change didn't take. If using fixed IP doesn't clear the variability, then try a local test from the server itself, to rule out network variability. If you still see the issue from a localhost test, then the issue is with your app stack on the server. :( 

First thing that comes to mind is: are you using a FQDN/DNS to initiate a connection to your memcache server or are you using an IP address or local socket? If you are using a hostname, you might be losing some time in the name resolution. Try either putting the FQDN in the clients and servers' /etc/hosts and restart so that nothing gets cached, or change the reference to be IP address based, and see if you don't see an improvement. 

VMware's server and vSphere products support some USB 1.1 functionality for the VM guest OS(s). If the dongle requires USB 2 features, you might have problems. You will need to explicitly configure the USB device to be assigned/allocated to the VM in question. If your Host OS takes hold of the device, then it will prevent proper operation with the Guest VM. Same story if you fire up a new VM and it includes the USB suport, it may also take the USB device. 

Ah... good ol'Solaris and it's wonderful default policies. When you created the users on a new system install, there was an account expiration time set. This is in the /etc/shadow file, I believe. You will need to unlock the account and then set an expiration time far far into the future. I've tried the "never expires" flag in the past, but it's never worked as expected. You can fix it on a system you've been locked out of by vi'ing the /etc/passwd file after booting into recovery mode. Helps alot if you have a clean working Solaris box you can create a test account and set the expiration flag properly on, and transplant that. Yes, the above is a bit of a fudge. Edit: Corrected file from /etc/passwd to /etc/shadow. $URL$ and $URL$ What does one of the locked accounts look like? (A shadow line, but without the password hash)? 

If the problem is simply that you have to start every session in the terminal with this: , then I can think of two solutions. 

But again, getting such a command just right might very well take longer than installing a minimal system and setting it running. 

I like PmWiki quite a lot. It's easy to install, easy to customize, and it doesn't require a database. (Neither does Ikiwiki, which I've also used and liked.) PmWiki supports a great deal of customization through cookbook recipes, and it appears that it can do what you want in terms of user authentication and permissions. See this page. But I haven't used it that way, so I can't confirm how well that works. Edit: In response to the OP's comment, I have used BoltWire (check your spelling and your link - both are incorrect), and I prefer PmWiki. They are both reasonably easy to install and both pretty lightweight. I didn't dislike BoltWire at all, but I found PmWiki more fully-featured and easier to configure. Edit 2: Since you mention in a comment on another post that you are using Debian, both Ikiwiki and PmWiki are available in Debian and pretty trivial to install using your favorite APT package manager. I would recommend that you try both out and decide for yourself. 

I think that 2 is cleaner and better in the long run, but either should work fine. The issue with 1 is that if your work habits change, you will need to remember to remove that line, or it will drive you crazy every time you open a shell. 

The utility runs under a very limited environment. This means that you have to spell things out in a way you would not if you were working interactively at the command line (e.g., rather than just ). It's also worth saying that Apple recommends over . (I actually use myself on Macs, but only because I'm used to it from Linux machines. I keep meaning to switch.)