The above algorithms is an implementation of this expression. A more literal version should maybe be: 

The previous version worked in general as expected. This one IMO a little more. I'm sure you can find a lot of possible drawbacks, so you're very welcome to do so. The origin to this work is still t3chb0t's inspiring posts. 

Overall I think your code is OK, you have done some good thinking about the data structure, workflow and user interface. I like the command pattern. I have the following comments: 

First of all: your function naming is confusing in the way you use singularis/pluralis (-Record/-Records). They all returns a single (or null) object so stick to -Record. I would not filter the records by DATE_DELETED_DTE, but leave it to the client to check the returned object (for null and deleted-flag). That's because if you provide a function with the indclude-deleted-flag the client will have to check for null and/or rec.DATE_DELETED_DTE == null anyway, and he/she is not helped at all. So unless some clients are not allowed to access deleted records I'll suggest the following: 

Although your efforts show a good understanding of details of functional programming, I think you make it all too complicated. The overall task is to map a list of integers to either the integer itself or a text in respect to one or more predicates. That can be done like this: 

What are b1, b2, operation1/2 doing? A better naming would be suitable. Tuples are nice objects for holding (temporary) data, but I wouldn't use them in the above situation. Instead I would make a class or find another approach. 

This seems to ensure no slip in the sequence of timestamps (Second-wise at least), but each elapsed interval may be (cumulatively) delayed according to previous intervals "laziness". In this way you are not guarantied that the job is done on schedule, but you won't miss a job because of "missing" seconds. It seems though that the time pump catches up the delay when no action delay the current elapsed interval. 

then it would not be found as a change. If you're going to use the class with lists of reference types you need to track the state of each item between calls to - which could be a hash or something like that. 

When it comes to Object Expressions as a mock for testing, I haven't found a valid approach in this case, because you can't extend an OE beyond the type you "derive" from. For instance the below straight forward solution is not an option: 

In this way you - as a client of LuaHandle - don't have to deal with the extern api's at all and no invalid IntPtr can be past as argument to 

Xiaoy312 has a point about the risk of missing seconds when using . It seems that each "tick" of waits until the previous returns. So if the OnNext halts the thread a while, the next "tick" is fired too late and you may miss a second or two. Trying to start each scheduled task on a new thread - for instance via a seems to be a bad idea, since the same Cron job probably can not run concurrently(?). One way not to lose any seconds using is as follows: 

But be aware, that using linq is not necessarily the most optimized approach (performance wise) , so you'll have to do some tests. 

I'm not sure if I would have the _index as a class field. Of course it determines the state of the object, but since the Dump() is a one time event and the state is useless afterwards it isn't really to any use to have it there. The result of having it like that is that your WriteAscii() gets unnecessarily "complicated" and in fact needs to "violate" the state as it must backtrack. Instead I would suggest a WriteBody() as something like this: 

I think it's best not to do too much nesting as it makes a flow hard to follow. Further keep it simple and do not do everything in one function. IMO it's OK to make multiple return statements in a function if it's clear why, but others may disagree. I would do something like below: 

Although I strongly agree with tinstaafl in that the use of ToString() is not very beautiful from a mathematical point of view the solution he provides is rather unstable due the first if-clause (). On my computer the following errors are found: x = 0.000000000345; Wrong result x = 13 or 0.000054635 or 54.635 Stack overflow I haven't (had the time to) found a reliable solution, so it seems that ToString() is the best choice of stop-condition. sqroot() is missing one important input check: x >= 0 : 

The Sprite class and inheritance Since Money, Item, Monster etc. all are subclasses of Sprite, I would only have one set of objects containing all sprites: 

It's hard to comment on the thread safety because there is too little information about the environment the class is supposed to work in. Therefore my answer focus solely on the class construct. 

Below I've reentered all your code with some inline comments and modifications (All begins with // HH or // HH TODO): 

In that way the client also know from the return value if the record actual exists (but maybe deleted) or not (null is returned). 

I can't quite figure out in which situation you would use and in which . and what the difference really should be. I made some tests and overall it seems to work. I did though find the below strange behavior: Testing with these two values: 

In large I think the sort function is right out of the book of bubblesort. IMO your naming is a little overdone. The long names are for an inexperienced eye hard to read. The ascending and descending sort loops are essentially the same except for the direction of the comparation, so no need for backward loop or special temporary variables etc. The swap mechanism calls for a swap function. All in all find below a revised version of the sort function. 

I think TheQuickBownFox's suggestion is rather elegant. With a little twist (the use of ) it is only necessary to call once per num: 

I can't see the necessity of the type parameter TException as it all works on base Exception? This has an unnecessary if statement as you have just instantiated the text object, so its length will probably always be 0: 

That said I think both solutions suffer from a generation problem (I'm not a GOL-expert so I may be wrong): 

I think, this filter isn't very reliable (one day some one has a column name containing "skip" that should not be skipped): 

A slightly different approach is to avoid the sublclassing and instead feed the generic DelaySequence class with a generator function. It makes it more flexible. 

Below I'll comment on the xaml. First of all: there are many ways to do things and we may all have our preferences, so the below is my way: Position of controls: in general do not use margins to position controls absolute in the window. Instead use the grid with appropriate column- and row definitions. For your MainWindow it could be something like this: 

As the image shows checks against two different generations because the board cells are successively updated through the calls to in resulting in a false new state. The solution is to create a new board per generation and recursively check those while creating the next generation board: 

The function can't handle values lesser than 2, and it shouldn't as it has no meaning. But instead of returning properly it ends in a long while loop. Instead of int you could use ulong because it signals the domain of the function. There is no need to return anything from the prfact() because the nums argument holds the result. You can optimize the algorithm in that the curr argument is unnecessary as shown below. 

You are firing the InitializingAssessments event on the form each time it is activated. Shouldn't that be in the load-event? 

Your handling of state is nice and clean and easily maintained in that you always create a new instance when ever Buffer or Cursor changes. But it requires objects. Cursor is not : 

on the view (form) maybe should be an interface which HomeScreenPresenter implements. Further: Instead of the presenter reacts on events on the view the view should call "passive" methods on the presenter - but it's a matter of taste maybe. 

Make resources: as show above the ForegroundBrush and BackgroundBrush are created as resources and referenced in the Button Style - and you can reference them inline on other controls as well. It makes it easy to maintain if you later want another color. Fixed Sizes: Be cautious about fixed size Windows. Your Display Window is defined with . A better solution would be to make your content sizable, which gives the user a possibility to resize the window to his/hers needs and a better experience. 

As I see it, your code works fine as it is. You could though improve it a little bit by appending each priceTypeId in one appendFormat operation as in: 

I would return in the outmost function too to avoid the call to ToArray() in order to let the client decide how to handle the output: 

Note: If you try PrimesBySieveAndLinq.GetPrimes(int.MaxValue) it is very slow at the beginning, but speeds up after some 1000 of primes. 

There is nothing much to say about the implementation of the algorithm itself. It seems to be a fairly one-to-one implementation of the pseudo code and it looks rather functional to me. You could though avoid all the argument declaration if you change a few things in the functions as shown below. Beside that I prefer to encapsulate recursive functions in a wrapper function but that - I think - is a matter of taste: 

If changing to the below you can avoid the IsNumeric check and you can specify a format string for all property types: 

1) You should never use in a statement. Instead use or create a dedicated and use it in the statement: 

The "Counter" This is essentially the same as the previous. It notifies observers for every second and act fundamentally seen as a timer. 

All that said, bubble sort is not the most efficient algorithm, so if you have large data sets to sort I will suggest other more powerfull algorithms like quicksort, mergesort, heapsort or combsort where quicksort and combsort maybe are the easiest to implement (they are all well documented on Wikipedia). 

As a follow up to this first attempt to create and use my own implementation, this is version 2.0. The goal has been to correct the code where there were conceptual misunderstandings and to take the issues pointed to by answers into account. The overall concept is the same: A scheduler that can fire off jobs when they want to be in intervals as small as one second. Instead of using a timer, the Observer pattern is used by implementing an type, that notifies subscribers each second. The Scheduler 

I largely agree with Adriano in his discussion of your code, but I find his method naming a little too detailed. Below find my review of your extensions. 

Actually you can have anonymous types as parameters - called dynamics - but IMO it's not pretty (and probably rather slow): 

Secondly, if the check of all masks follows the same pattern as showed, you can create a mask checker method like this one (in C# 7.0): 

If the valid column names are fairly static, I would make some kind of settings file, where the valid columns are defined: 

Analysis Basically you want to compare two sequences of numbers index by index. If they differ then save the target value, if not then increment to the next value of the input array. The index of the target sequence (here from min to max) is always incremented. Instead of the target sequence you can just increment a value starting from and ending on . All in all it could be done something like this: 

Instead I would make sure always returns something enumerable. And since it is always returning the same kind of objects, I would make it returning a defined class instead of the use of dynamic. I don't understand why you don't use the fact that it's all about Exceptions. Instead of collecting the subtree of Exceptions you could do it recursively avoiding the use of : 

I can't add to the existing reviews of your code (other than I find it a little hard to follow), but maybe you find the below Linq-approach useful as inspiration. It seems to be "slow" for small data sets but rather fast for larger: 

In the way you show that you create each Skill instance, you really have anything than the Description to distinguish them from each other. I read your Skill class as merely an advanced flag that defines a small set of properties. In the below I further anticipate, that each skill type doesn't change throughout the game. If that is correct, then I would make the Skill class as a "singleton" per Skill type (onehanded, twohanded etc.) and let a static Factory method create/return the right Skill according to a Skill Type enum: