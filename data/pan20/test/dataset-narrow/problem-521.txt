I store timer values in TimerVal(1 To 5, 1 To 26). That is 5 times per loop for each of 26 worksheets. I use column 6 for worksheet totals. I use row 27 for loop portion totals. I used TimerVal(0,5) for the start time so TimerVal(N-1,5) is always the end time of the last loop. I use constants so if you decide you need 4 or 6 times per loop or you add more worksheets, you can change the constants rather than my code I placed before the Do statment. I placed immediately after the Do statment, with four other such statements placed throughout the loop. The effect of this is for the loop to record 125 times. The following code displays those times to the immediate window as durations: 

You could rearrange the boolean expression so the then-block is executed rather than the else-block but that sort of boolean expression hurts my head. If having a boolean expression I can understand means using the else-block then so be it. When I set up my workbook, my equivalent of Sheets("BW TB") ended up in the middle so I have had to change your code in this way. I have had to do the same to the code I am about to show you. You need to isolate the portion of your routine that is taking a long time. The secret to this is the Timer statement which returns seconds since midnight as a single. I have declared some new variables: 

That is followed by a boolean expression. Here I assert that the current sheet name is not BWTB. It this assertion is true, execution does not pause. But if it is false, execution stops on the assert statement. Place the assert statement at the top of the suspect code. When it pauses, use F8 (execute single statement) or use F9 (set/unset breakpoint) and F5 (execute until breakpoint) to step through the code until you have isolated the problem. I assume you have made all the improvements people have suggested although my experiments reveal these improvements will not make the difference we all believed. You start with Sheets("4020"). I seem to recall that you said it was important to start with this sheet. Is this because the other sheets depend on Sheets("4020") or because Sheets("4020") is Sheets(1)? I do not like the way you step through the sheets. Your code depends on Sheets("4020") being Sheets(1) and Sheets("BW TB") being Sheets(26). If Sheets("4020") is special you should make the body a subroutine with sheet name or index as a parameter. You then (1) call the subroutine for Sheets("4020") and (2) amend the loop to: 

You will know from my last answer that I have created a workbook that has the same structure as yours. This means that with some modification I can run your macro. For me it takes .75 seconds for the loops to complete. In this answer, I explain what I have done and why. I recall that at one stage you were reporting that Sheet("BW TB") was being updated when it should not have been. I cannot find that report so perhaps it has been sorted. No matter, it is an excuse to tell you something. Programs always seem to go wrong in the middle. You want the program to run for 5 minutes and then stop at the problem area so you can investigate statement by statement. The tool for this task is the Assert statement. Most languages have assert statements. The VBA one is of the form: 

When you do this, you must then not mix C++ I/O (IO streams) with C I/O ( and friends) in your program, but mixing these is bad practice anyway. Here are some other comments to your code: 

One thing I am aware of is that the code does not handle trigraphs; they are somewhere near the end of the to-do list. 

You're overdoing it with comments. A lot. And trivial ones at that. Every programmer knows that creates a vector of pointers to , or that you have to use with pointers. Such comments are really just clutter and actually make the code harder to read. Save them for the non-obvious bits. It's unclear what protects. Does it protect ? Or ? Or both? This is one of the places where you should comment, but you didn't ( is absolutely pointless). If possible, rename the mutex to match its purpose. It would also be a good idea to wrap the mutex and the data it protects in a class, to ensure that unsafe access is impossible. requires the reader to parse it (and what's with the double parentheses?) The meaning of , on the other hand, is immediately obvious. And how does it create 4 threads? You could just as well rewrite the entire loop to make it more concise (and perhaps more efficient too): 

As far as performance is concerned, there are no problems in this code. It's using C++ streams in the idiomatic way, which is good. If you're experiencing performance issues, you could try detaching from C streams at the start of your program: 

looks like a rather arbitrary number for the default template argument for (it's actually a magic number). There is even no guarantee that 16 is a valid alignment value. I would probably choose something less arbitrary such as . There is no reason to use for the type of . You don't actually care about alignment of at all (which is emphasised by you passing to its parameter). All you need is a buffer of suitable size, and for this (or a ) would work just as well. As a side note, be aware that was only introduced in C++14. Visual Studio 2013 supports some C++14 bits, but using it makes your code non-C++11-compliant. You might want to swap the order of the data members, it might prevent need for padding between an oddly-sized and aligned . You might consider overloading the pointer operators and for your class as syntactic sugar for , it simplifies usage. Other generic classes which store a single object sometimes do so as well; an example is . 

This will cause the loop to terminate when a 0 is entered in the input. This behaviour does no match the assignment, and hence it represents a bug. Based on the assignment, you should only terminate when input ends, which will be correctly caught by the loop. The line should therefore be removed. Related, your after-loop test for is incorrect. If the loop is (correctly) terminated by being unable to read more numbers because the file has ended, both and will be set on . The condition will therefore fail. You might want to augment the condition to check for EOF: 

Indentation in the post-loop conditional is inconsistent with the rest of the program, and should be fixed. The same holds for the block (unless that was just screw-up of the code formatter here on Stack Exchange). The return value of is interpreted by the operating system as the return code of the program. On all OSes I know, 0 indicates success, non-zero indicates failure. You should therefore return 0 on successful program termination. Or just omit the altogether, is implied in the function in C++. Or, if you want to be really beyond reproach, and comaptible even with OSes where 0 does not necessarily mean success, you can change it to ; this requires . Error output (such as your message) should be sent to (standard error stream, usually file descriptor 2), not to (standard output stream, usually file descriptor 1). A more helpful error message would be in order as well. Something like 

My PowerShell scripting skills are pretty poor, but I've managed to hobble together got this script: 

Well there's not much code to review here, but for what's here, I'd say it looks okay. I would only make one suggestion. If all you're going to do in your controller action is return single string wrapped up in a JSON object, why not dispose of the JSON and just return the HTML as content? Ajax call: 

Start from the end and work your way back, that way once you've found one palindrome you're done! You only have to check half of the digits for equality. We can shave off some time by avoiding / 

If you want to verify that either value is in the , may not be the best option. It will continue to test for collisions even after it finds a match. For two search strings you can just do: 

Use 's rather than fiddling with individual date parts. Use an array to store the edges between each Chinese year. Search through the array until you find a match then return the index of that element mod 12. (plus 1 since you want values ranging from 1 - 12). 

For something this simple, I think using the is fine, however, if you need to use the list of acceptable integers more generally or avoid hard-coding the set in a single expression1, you can use something like this: 

How can I clean up the process for formatting the arguments string? It seems pretty ugly at the moment, and if I have to add any more parameters, it's just going to get uglier. Is there an easy way to convert a list of parameters to a string that's suitable for invoking another function? Note: Simply passing in the parameters as a single string (e.g. ) doesn't really solve my issue, it just moves it back one step. I'd like to create the string within itself. 

Which might save you a little bit of time, if you're dealing with millions of elements, or calling this function millions of times. But for brevity, I'd recommend this: 

You can also use a binary search (since this data is sorted) to speed up the search. My PHP is a bit rusty, so some one else might be able to improve this further, but I think it would look like this: 

Any other exceptions it throws indicate a invalid parameter or bad program state. You probably don't want to just ignore these errors and move on as though nothing has happened. I recommend you just do this: 

The one thing that really stands out to me: you don't need to convert the boolean result of to a human-readable string, then test the string. Just test the result directly, then convert it to a human-readable string. 

Both of these look better than my original code, though I'm not sure that the match has added any expressiveness to the code, so for now I'm keeping the plain old / statement. This is mostly just taking advantage of the built-in behavior of dictionaries in .NET ( returns the default value if the key is not found, and the property's setter will perform an insert if necessary), but I'm still open to any suggestions on improving this more. 

The same holds for all other uses of C I/O (, ), of course. and would be better declared with type , as they represent the number of some objects. If you have access to C++11, all the above could be simplified even further using range-based loops, lambdas in standard algorithms, or at the very least iterator-based loops. I didn't bother with iterators here (even though they could be used), because their type has to be spelled out explicitly. In such case, it would also make more sense not to allocate the threads dynamically, but create them directly in the vector. No need for manual deallocation, no dynamic allocation overhead. 

The names and don't say anything about the variables' use. I had to read through most of your code to figure out what means. Always use descriptive names for your variables, at least for those whose value is supposed to persist for extended periods of time. I would be willing to accept the , as it is basically one-shot, but should be renamed at least to or or something more descriptive. Your looping and termination logic seems odd. You are using the correct construct , looping while there's valid input left. But then you have this block: 

Here's the first functional version of my Python 2 script for processing comments in C++ source files. It's a personal project, I expect to expand it later with more advanced options (mainly about replacing comments with whitespace or marking their original positions in the comment-only output). It's also intended as a learning excercise. I am self-learned in Python, my primary language is C++. So the core of my question is whether the code is "Pythonic" and if not, how to improve on that. I don't want to "write C++ with a different syntax," I want to (learn to) write proper Python. I will of course also welcome any other comments (general style, efficiency, safety). 

Also note that I added a call to into the waiting loop. Your previous code was leaking the threads. You're writing C++. Don't use (type unsafe!) C I/O. Do this instead: 

This type of information must go into comments. The next maintainer (which can be you in 6 moths' time) will need knowledge like this to understand the code. You should add specifications to your functions. They affect efficiency of some operations (like storing in a ), and since this is a very generic class, you should not limit its use in any way. An example for the assignment operator would be: 

You don't need to convert an object pointer to , a is sufficient for that. Don't use stronger casts than necessary. You can simplify the assignment to and make it more obvious by assigning the result of the placement-new into it: 

When printing this message, you should consider returning 1 (or ) from , instead of allowing fallback to the default success. The outer could be removed. If the file is not open, will fail, and you would at least print an error message instead of failing silently. is a very non-portable and extremely cumbersome solution looking for a problem. You're calling an external program just to wait for a key press. You should get rid of it altogether: your program is not interactive at all, it could run just fine as part of a script. Requesting input like this ruins that. Just drop that line altogether.