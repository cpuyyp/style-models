Quite how you make VLANs varies on different routers. On a 2811 with the built-in interfaces (tested on 15.1) you can use an external switch with VLANS, and use "subinterfaces" which look like this 

In addition to others' excellent answers about layering, some protocols sit right on top of the L2 ethernet frame, of which the best known are ARP, RARP, CDP etc, which relate directly to the link (also, as I'm reminded by Zac, other protocols such LLDP and STP's BPDUs.) It is very uncommon, but on occasion you'll find applications which send their data in the ethernet frame, though the only reasons I've seen for this are either a) proprietary protocols designed to be obscure or purely local like license management, b) experimentation, especially real-time transfers or evaluation of protocol stack timimg. Pros and cons of this are way outside the scope of this answer! This is output of a timing test packet with "data" starting at 0x0e. 

An academic institution is typically large enough to have several outgoing firewalls if not Internet connections. This particular institution appears to have a /24 of public address space. It appears that this one sends wireless traffic out of a different interface than wired. This is not unusual: either for simple convenience or for prioritising bandwidth for a given set of users. Sometimes you see networks where the outgoing IP address changes per connection, or is different for UDP and TCP. It's all up to the whim of what the controller of the network thinks is a good idea, usually for bandwidth management, anti-abuse, and security purposes. 

Then you use to get the second field (ether address), sort them, count the unique values, and sort by numeric count: 

With a controller to coordinate the associations, handover is very short in order to keep voice call quality acceptable. Aboslutely not for 1,000 users but without a controller you can see 1 second dropouts routinely. Badly organised controllers in public spaces can easily be observed to drop out for much longer, perhaps 30 seconds. 

If your equipment supports it, you can set up the tunnel endpoints by DNS name rather than IP address, and using some dynamic DNS service keep the names up to date when the addresses change. It can be made to work, but note that the failure modes are likely to be awful. (Might have to tune timeouts to detect the broken link.) 

Of course parallel port IP isn't common, but it illustrates the point; the other two are ubiquitous. Hope that helps Jonathan. 

Correct, unless you have devices doing proxy ARP, in which case you'll have the ethernet address of the proxy, not the actual host. If there's a next hop router in the normal routed situation, there's no ARP entry for the target. 

A very wide range of communications technologies are serial, from RS-232, I2C, ethernet and many, many, others. As a matter of physics, if you put a signal into something it will come out slightly different. As a matter of engineering therefore, instead of saying mechanism X has or doesn't have errors, it's normal to regard all communications channels as having some underlying noise, interference or other problems which cause errors, and speak of how much there is. The bit error rate article at Wikipedia has a good introduction. And instead of thinking about what's desirable ("no errors"), we think about what's acceptable ("few errors"). Depending how we define "few", We then make engineering tradeoffs between complexity, money, speed, reliability, The main techniques for reducing errors are: 

"I have an application that spawns processes that communicate with each other through TCP using the loopback interface on the same host. Just standard TCP sockets." For TCP connections over loopback, packet loss is exceptionally rare except under massive overload, and depends on the OS. I'd certainly look elsewhere. Sockets timing out on loopback is much more likely to be a programming error. Details of which depend on exactly what phase of connection the sockets are timing out. PS. Yes, for two hosts communicating and you suspect packet loss, wireshark/tshark/tcpdump is the right tool; ideally capture on both server and client, then you actually see the lost packet on one but not the other. PPS. But almost always it's best to make a guess about what kinds of packets are getting lost. "All those of a certain size?" is especially common. If it's really just random packet loss, some of the lesser-used options of ping at one end and tcpdump/whatever at the other will often do it. Otherwise, netcat can be very useful, and as another noted, iperf. 

While checksums in general have the characteristic that there are many messages which identical checksums (after all, we're going from perhaps 1Kbyte packet to 16 bits), many real life checksums have surprising good and bad properties. For example, IP checksum is guaranteed to detect all 1-bit errors; but fails to detect byte swaps. Real communications lines have certain errors much more common than others: much more common to get "all bits arrive as 0" for a short period for example, and "bytes are swapped" is more or less impossible. For a deeper understanding 

Whilest completely agreeing none of these are entirely satisfactory, here are some thoughts which might help, gleaned from doing various large-scale packet-capture analyses over the years. Perhaps one of these ideas will help you: 

You ask "In other words, will the NAT always assign the same port mapping to the same (IP, port) unique tuple ?" The answer is no, it's entirely up to the NAT device. In the general case it's impossible to guarantee it, as there's usually a 16-bit space of the NAT port, and N hosts inside the NAT with a 16-bit port space. It could try to make it as stable as possible, but usually the outgoing port is pretty unpredictable. 

[EDIT2: 2017-10-29] Edits throughout to reflect encryption issue rather than anything else. We are in close contact with client authors to see what they can find. 

The usual command uses ECHO REQUEST and ECHO REPLY, as you've seen. It does indeed locally keep track of sent time and matches with the incoming reply to determine the round trip time. TIMESTAMP and TIMESTAMP REPLY are pretty rare, and many sites simply don't answer, as many systems managers believe it to be a security issue, albeit minor. The purpose of the packets is to separate out the the times of the outgoing trip, the far end processing time, and the return trip. in general is subject to all kinds of manipulations and blockages by intervening routers, so it can be hard to read much into the results if you're using this across a network you don't control. To send them you can use a utility such as from the set of tools. It can be used for all kinds of exotic ping-like tests. 

Supposing the IPv6 ISP assigns a "Global Unicast Address. This, by definition, is globally-routable. There is no NAT." ... Even if it gives you a completely static allocation, perhaps based on the IMEI or similar of the calling device, there is no reason to assume it will actually route it under the conditions that suit you. One of the functions of the VPN is to give you control over your numbering and routing, which can be very useful to give, amongst other things, independence from the ISP. The pre-eminent way to insulate against addressing changes is of course DNS, but VPNs are another which suit some network requirements. 

If you care about the statistical niceties (stability, pop vs sample etc) use R or python instead. Certainly R will give you nice graphs to understand the distribution of whatever categorisations you're interested in. 

[Light edits to emphasise versions] What are the exact requirements of TIA/EIA 568 cabling standard as regards to the length of patch/work area cables? Specifically, I see from my 2001 copy ANSI/TIA/EIA-568-B.1-2001, Section 6.4.1.4 "Maximum lengths for copper cabling" has formulas for total length of cable against lengths of work area cable and patch cable, with deratings for various thicknesses of stranded cable. Table 6.1 shows patch + work area cables up to 27 m, shown against reduced horizontal cable lengths down to 70 m. My understanding was thus it was within standard to have longer stranded cords at the ends if you have shorter horizontal lengths. But I'm also told that certification authorities such as BICSI in the US require patch + work area cords to be no longer than 10 m. Or are there additional documents from eg BICSI certifications that should also apply? Or have I misread 568 somehow? EDIT 

In addition to the completely correct answers about speed matching directly connected systems ... One of the fundamentals of the internet (including all the private routing portions) is that the indirectly connected fast host A can communicate perfectly well with slow host B, without even any knowledge of the layer 2 mechanisms. The separation of layers means that we don't have to have direct speed compatibility between widely different technical and economic environments such as NASA and a kindergarten, while they still communicate perfectly well, within the limitations. 

Further to JFL's answer, many devices will send gratuitous ARP when the link comes up; switches correspondingly should invalidate their MAC table for a given port when the link state changes. In your example, when you swap devices C and D on their ports PC and PD, when the cables are removed the link should go down and the switch should remove their addresses from the table. If you swap the MAC addresses (by reconfiguring) on a system which doesn't send a gratuitous ARP, a switch might send the frames out of the wrong port until a transmission triggered an update. (TCP retransmissions for example.) Switches also remove MAC addresses which are too old, so eventually it would be pruned in any case. A switch with a good algorithm should notice transmissions to a MAC address which isn't replying and remove it from the table, just like aging out. It's a good experiment to try on different switches if you can get a host to behave in this way. 

It looks like the router is correct and your intention is to have various sockets on your switch in the various 100/110/etc LANs; just as if you had four ether interfaces on your router and four switches (plug ge 0/0). I've no specific knowledge of the D-LINK switch, however: 

The method with a specific flag is better if the command has it, as does, but the backtick method will work for anything.