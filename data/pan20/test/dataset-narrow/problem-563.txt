There are a couple of micro-optimizations to be made. They probably won't give you the boost you're looking for, but it's worth trying. First, you can explicitly define the return type. When you don't define one, the compiler defines it as a type, which incurs a lot of overheard compared to the "regular" data types. For clarity, this 

Which brings me to my next problem. It's case sensitive, right? So, wouldn't match. I believe it should, but I'm not familiar with Robol. Please correct me if I'm wrong. I've seen this handled by defining case insensitive tokens for each letter. 

Here's the thing about IoC containers... You don't need them. They just make our code near the root easier to read and deal with. Write your code so that it doesn't know that there even is an IoC container. When you're done, you should be able to create and run an instance of your program using any container, even one that we hand write into the composition root. 

If you changed this to use an enum instead, that comment becomes obsolete and can be removed. Always try to let the code document itself. I would much rather see this. 

shows up all over this code. While the row/column widths are easy to understand, this isn't. I have no idea what color is without looking it up. This definitely needs a well named constant value, but whatever you do, don't name it something like . If you do, you'll have to rename if you change the value. Go with something like this. 

Abstractions are useful only so far as they remain useful. Once you start jumping through hoops to maintain an abstraction, you should reflect on whether it's still useful. By choosing to rely on an instead of a , you've lost the benefits of using a binding list, while jumping through hoops to "make it work". You're also breaking a number of Microsoft's Guidelines for Collections in the process. 

Hungarian notation can be done right, but using it to tell yourself what datatype a variable is is not doing it right. Even if you must just insist on using hungarian notation this would not be right. 

Okay, so we have two distinct objects here. A and . Stats has three properties, Win, Loss, and Tie. Let's make a small adjustment to your XML to make serialization/deserialization a bit easier. First, we'll make the root object. Then we'll rename some things to make sure our resulting classes have good names. The element (and attribute) names must exactly match our class names and properties. 

In my opinion, your view is doing too much work. This is happening because your model is missing a property. If you add an property to your model, I think we can simplify the view a bit. 

Getting the values from the UI makes sense, but then you loop over , which obviously doesn't actually add anything, or you wouldn't need to loop or have a class variable. All of this logic should happen inside of . should take in two strings, handle all of the logic, and return a single string representing the output. While I'm at it, methods should have PascalCased verb-noun names. This method should be called and I will refer to it as such for the rest of the review. As I said earlier, I wouldn't expect a Function that adds binary numbers to take in Boolean values. I would rather it actually take in a byte and overload the method to handle string representation, but I'm lazy and you don't seem to need all that. Putting it all together, the signature line 

Okay, so it's a magic column? What does the magic column do? (For those that don't know, this makes special columns display as a hyperlink.) 

So no, this may not work properly. You need to register an event handler on the event so that you know the message has sent successfully. I'm going to be frank about this, the SmtpClient has an awful API. Your confusion is not your fault. Your best bet would be to create a dictionary of recipients to use as a queue. 

Finally, in this project, we have a regular *bas. This is just kind of throw away code that we use to run the tests we're interested in. 

In VBA this results in a compiler error and it's expected to be . Perhaps VBScript is more forgiving, but it also looks like the lambda operator from another popular Microsoft language. So two things happen here. I can't paste this into the VBA Editor and run it and it could cause confusion for someone expecting this to be the lambda operator. 

This is typically accomplished by having a lexer that generates a token stream from input text, a parser that produces an abstract syntax tree, and an interpreter (or compiler) that executes the AST. The interpreter will typically use the Visitor pattern to do things like evaluating expressions & conditionals and calling functions. Currently, your AST and the interpreter are all mixed together. I think you'll find your life easier if you separate the concerns into the traditional areas of responsibility. 

You're right. You do need to insulate yourself from the third party interface. It's their boundary, not yours. You need the Adapter pattern. You need to create your own interface that your code will work with. 

I'm building an RSS feed parser so, later, I can retrieve recent blog posts on my word press blog and display recent posts on my other website. This code isn't intended to implement the full RSS spec. It just needs to handle the feed that Wordpress provides. I wasn't able to leverage because I wasn't able to get a reference to it on .Net Core. Sample Input: 

If that doesn't convince you that this isn't a I don't know what will. It's a presenter that doesn't present anything. 

What really makes this terrible is the type doesn't even give us a hint because you've declare them as generic objects. You could literally stuff any class instance you wanted to into those variables. It looks like you're using to iterate the collection 

You can also save yourself an entire line of code by simply subtracting one from that value right now instead of waiting. Keep the comment. It's a good one, but don't try to right align your comments like this. The second it gets copy/pasted anywhere you'll lose the alignment and waste your time trying to line it back up. 

But wait! Didn't I just say not to create dependencies in the constructor?! Yes. I did, but that's really just to make things easy to test. By having an overload that does allow dependency injection, we have the ability to easily test in isolation. Nothing says we can't also provide a convenience ctor that creates the dependencies for production code. We've just made things more flexible is all. 

That's..... useless. It's obvious. Don't document the obvious. Style I don't know a C# dev on this site that doesn't prefer new line braces to the "Egyptian" style braces that you use. If you're working with others, I would recommend you stick with the "C# style", but really, it doesn't matter. You were 100% consistent and that is what really matters at the end of the day. Null Coalescence 

There's not a lot to go on here, but consider this. Can someone's age be ? Will a student ever be 1000 years old? An can be both of these values. That means a simple default getter/setter isn't sufficient. You'll need to write some bounds checking in the setter and throw an exception if someone tries to set to an unreasonable number.