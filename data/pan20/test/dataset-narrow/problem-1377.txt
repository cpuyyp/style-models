You should be able to use java without any performance problems, the technology went way past that. Although services that work with massive number of clients still use c++. As for your choice of sockets, it's not a matter of performance, as people usually think, it's about what are you going to use them for. On game servers you don't care if messages are out of order or got lost, you just want updates going as fast as possible. Lost messages can be ignored and if you get messages in order: 1 2 4 3, you just ignore message 3, because you already got the newer update (4). In this case you use UDP sockets (which is actually a simple wrapper over internet protocol (IP)). But on the web you want all the content to arrive in order. You don't want the footer of your .html page to be processed before the header, or to lose part of the .html page with the closing tags, because it would screw up everything, neither do you want to get second frame of your youtube video before the first one. So here you use TCP sockets that will rearrange the packets as they come to be in order and resend the request for parts that were lost (this is also a wrapper over IP, but it has a lot of optimization and features developed over past 30 years). Many applications use both TCP and UDP on the same port, which is pretty handy, but if you're making a game server and want to make sure the "attack" command gets to the server when client on the mouse you would be better off implementing it using the same UDP socket you use for updates. As for how to implement this, my practice is to have a single socket on the server that would receive all the requests and send all the responses (don't process the requests in the same thread that receives them). And identify the clients by their IPEndPoint (plus whatever type of token you use for security, if any). Just remember the IPEndPoint of the clients, so you know where to send the response, or in case you need to send them something asynchronously. Making a new sockets for each client is something you do with TCP, when you use TCPListener. But UDP sockets aren't bound to any client, so making a new sockets for each client is useless, it just means you'll have to bind a lot of ports (and setup port forwarding for all ports to your computer if you're behind a router). 

You can make the moveTo() function a blocking function in the user script, but you should definitely not make it block your script. This way you should have moveTo() return a boolean telling weather the destination was reached or the action was interrupted. I suppose this would be the simplest solution for the user. You cold also have the moveTo() function just sends the destination and actionToTake to your program and return immediately. Then your program can just move the robot towards that destination unless it gets interrupted, then when/if it reaches destination just execute the action that was assigned (action could be a function call or you could predefine a set of possible actions). 

I'm making a server for MMO in Unity, which implies that I'll have a big world, split into maps which will be on different servers (to distribute the workload), managed by one master server. Now I can't decide weather I should use one executable per map and have few executables run on each server or have few maps on one executable, which will have it's own server. Second solution also would allow me to redistribute the workload by moving maps from one server to other (which shouldn't take long to do since servers don't need to load models). Btw servers need to be made in Unity for the physics simulation and collisions... The networking part can easily be multithreaded simply by using many threads to process the requests and generate response. But since Unity is single threaded adding more maps would slow down the physics engine (plus the same thread has to apply all actions of the players to the game), so the first solution helps here by using multiple executables. (Edit: Note: physics engine will take considerable amount of CPU time, even while the scene is empty) Which solution should I chose? EDIT: On the end I decided to use both: few executables on each server, with each executable being able to run multiple maps and being able to dynamically create dungeons when needed. 

My game uses UDP sockets to stream updates between server and client and I've also made a reliable channel that resends messages if there's no response and makes sure same message isn't processed multiple times. But TCP is specifically designed to be reliable and the people who made it probably have more experience than me. So would it be good to use TCP to send commands such as "attack", "play animation", etc. instead of my UDP implementation? (Of course I mean TCP sockets that don't delay sending the data (Nagle algorithm)) 

If your level is loaded fast, but you want to show a splash screen for a while what you can do is show the splash screen at the end of one level, call LoadLevel right after and have the splash screen shown at the start of the other level. You should have a variable saying after what time to remove the splash screen. This way would be much more practical, because you have bigger control of how long it is shown. Oh and the way I save variables between levels is by using a class with static variables. Because those variables don't change when you switch scenes. 

You only need one class with one non static public member 'radius' (static variables wont work...) Just create several instances of this class and connect them to correct meshes. You can have an empty gameObject to hold those instances, then drag and drag them to connect them to your other script on your meshes. There are other ways to implement this though, but all require you to create class instances... 

The way I would do this is by having Auth server send token to Client after login along with list of validated Game servers (so that the Client can be sure the Game server is valid). Then the Client would send the token to the Game server, which would then send it to Auth server to confirm that this is the valid client. Login: 

I'm obviously talking about an authoritative server to which client sends commands and gets state updates. My question is when I get a position update and know how many milliseconds ago it was generated on the server how do I detect and fix the drift? I'm currently just blocking the client from going too far away from the last update position by smoothly moving him towards that position. Which works fine on connections with low ping, but wont work with 200+ ping.