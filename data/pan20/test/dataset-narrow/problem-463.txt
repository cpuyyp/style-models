The same is true for the statement within - though instead of using , a class constant could be created using : 

I agree with James that #3 is better because of the separation aspect. I admit that I am a novice as far as React goes, having typically worked with other frameworks like jQuery, PrototypeJS, AngularJS, VueJS. The perspective below might not really meld well with traditional React techniques, but Event delegation really helps separate the event logic (JS) from the presentation/markup (HTML). So consider HTML like this: 

Actually, that function is deprecated as of version 3.0. See the last paragraph below for more details on that topic. 

doesn't appear to be used after it is assigned to the empty array. I would hope there is not a method called after that which references that variable globally...Presuming that is the case, that variable can be removed. I would question whether really needs to be defined, since it really is just a shortcut to calling . If there were more lines to that method, it was called more than once or the interface required it be implemented (and a different implementing class did something different) then it would obviously be good to keep. 

Note that were removed from the selector because the jQuery :input selector includes those. Then can be used for registering the blur callback: 

Obviously the code works but it can be simplified in a couple ways. Event Delegation I would recommend using event delegation. Instead of adding click handlers in the HTML, a single click handler can be added in the JavaScript code to the element containing all the tags (or could be attached to ). Then refer to to know which element was clicked. In the sample HTML given, the user might click on the anchor tag (specifically where the text is) or just to the right of it, which would signify clicking on the tag itself. To determine if the anchor tag was clicked or else the parentNode, .parentNode can be used. One main advantage here is that the markup (i.e. HTML) doesn't need to contain any logic about handling the clicks - that can be separated and left in the JavaScript. This could be a separation of View and Controller code (a la MVC). In the code snippet below, addEventListener is used to register a callback when the DOM is ready (via the DOMContentLoaded event) to be interacted with (i.e. querying, adding event handlers, etc.). Then it finds all the tags and iterates over them to set the class according to whether the element clicked was the current tag. Spread operator Note that the snippet below uses the EcmaScript-2015 (A.K.A. ES-6) spread operator to get an array from the NodeList returned from . One could also use Array.from() instead of the spread operator. 

Bear in mind that IE and other browsers don't support the spread operator, so if you wanted a different syntax supported by those browsers, you could use apply 

Squaring numbers Initially I considered suggesting the use of for the squaring of numbers but that might be considered using a library. I then found the exponentiation operator (i.e. ). Bearing in mind that it isn't supported in IE, MS Edge, or Chrome/FF prior to versions 52, it can greatly simplify the squaring of numbers. Edit: Zeta pointed out that the exponentiation operation might not be optimized. A better approach would be to store the value of calculating the sum of the numbers in the range (calling the function once) and then squaring that resulting value. limit number For consistency, I would declare a constant for the limit - e.g. and use that when calling and . Sample The example below takes the good advice of Igor and renames some variables like , ,, etc. Also, note that it only calls (and the subsequent sum reduction) once. 

Other Review points JS A lot of the suggestions below come from experience writing Javascript over the past decade, getting feedback from colleagues, and reading various posts online like this one. Bind methods and create partial functions to simplify callback functions Instead of adding a click handler with an anonymous function bound to that just calls a method: 

JavaScript You can start by caching references to in a variable (e.g. ), so as to avoid DOM-lookups each time you need a reference to the element. 

One could argue that the redundancies should be reduced. One way to do that is to only have the values that change inside the branches, and then the common code follow. Take the following re-written code for an example: 

The same applies to the text selectors (i.e. could also just use one class for all three)- the styles could be consolidated: 

Return value from is a boolean The code in method calls when the parameter is an array (). When that happens, should be assigned a boolean. After that, the return statement calls but that should error because it would be calling the method fails() on a boolean... thus leading to that error you saw: 

Validation with separate methods To keep the string length validation using strlen(), you could define separate methods and call those for each field. For example, the first_name and last_name fields could both be validated by the same method: 

Validating data in There are various options for shortening the code in . Two such options are outlined below, though other options are possible as well. The first approach aims for the fewest number of lines of code (while possibly sacrificing speed), while the second breaks the existing validation out into separate methods and calls them dynamically. Validation with Regular expressions for all fields One option is to define regular expressions for each field that needs to be validated. Bear in mind that performing a regular expression match on a string just to check the length will typically be slower than using strlen() but this way you can look for validation rules and ensure the values match the format. In the code below, the ReflectionClass is used to look up the constants in the class definition and if found, will use preg_match() to ensure the values conform to the field's validation rules. You could also look into using filter_var() with FILTER_VALIDATE_REGEXP 

And actually those variables , and don't get reassigned so const can be used for those instead of let. Form Submit handler return values? There are a few statements that return the value of assigning the inner HTML of the result element. That isn't necessary. If anything was returned, I would think a value equivalent to should be returned, so as to avoid the default form submission handler, but there is already a call to . Looping through results Instead of calling Array.forEach() and appending to , Array.map() could be used to get an array of strings for the listing and then Array.join() could be used to add the array elements as the inner HTML of the results container. See this in action in the snippet below. Notice that the function used in the call to is split out to a separate function and is not defined there. Fortunately the third argument of the callback to is a reference to the array so it can tell when the last element is processed. Notice how the use of allows the callback function to be moved outside of the code where it is called. With this approach, there is no access to the variable . Thus there is no dependency on that variable. This is loosely one aspect of the dependency injection principle - one of the S.O.L.I.D. principles. One possible way to simplify that listing HTML code is to use a template literal. I will leave it as an exercise to the reader. Also, the function could return an element (e.g. from document.createElement()) but then the elements would need to be appended to the results container and any existing elements would need to be cleared. Measuring time taken to retrieve, parse and display results after each form submission Originally I was thinking of using a function like to compute the time before and after the results have been fetched and processed. However, this SO answer suggests using the now standard API performance.now() (unless you need to support older browsers like IE 9 or earlier). In the snippet below, I added a to hold the time output below the form. Before the call, there time is stored in a constant: 

P.S. It is a shame that Object.assign() doesn't have an option to not overwrite existing properties... if it did, then the extend function could simply utilize that function... 

Then take the result of calling and check if that result corresponds to a key in - if so, set the message to that message; otherwise set it to the error message.