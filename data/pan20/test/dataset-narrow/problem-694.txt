The single quoted string will also be slightly quicker to interpret, although I don't know that the difference would matter in this case. I also changed the order. It's not uncommon to see the constant on the left in C-based languages. This is because would give a compiler error while will happily evaluate as false and continue. Incidentally, you don't need this statement, as the later loop and count check will handle this case for you. There's an argument that the code is a little cleaner without this check. It certainly would be a little shorter. 

As has been expressed in other answers to this problem, the critical insight is that $$LCM(1..1) = 1$$ $$LCM(1..n) = \frac{LCM(1..n-1) * n}{gcd(LCM(1..n-1), n)}$$ From that, you can build up to an arbitrary \$n\$ by applying the second formula repeatedly. 

I didn't get around to figuring out whether that's faster or slower. My thought is that it should be faster, as it does fewer calculations per iteration. However, it replaces integer multiplications with floating point addition (and comparisons), so it may not be better. It's also possible that the compiler is smart enough to compile out any difference that might exist. In my tests, they seemed to run about the same. 

and depend on , let's start with the latter. doesn't mean much as a prefix to me, so I'm going to call this function , but that's a stylistic preference. Changing this function to use is straightforward. 

You have some unnecessary pattern match cases, such as in the instance declaration. There's nothing wrong operationally with that case of course, but it's superfluous and the beauty of the inductive construction of the integers encourages me at least to be ruthless with flensing redundant code. 

Also those comments are unnecessary, I think it's fairly clear from your descriptive names what's going on. Alright now for the fun stuff. Let's begin by identifying the individual components of what your function is doing. 

There's nothing wrong with your code in terms of functionality, but there are a number of things we can do to make it more stylish and idiomatic. The #1 most important thing you have missed is to always provide a type signature for top-level definitions. Just reading the type signature of a function can often give you an intuition as to what that function will do (think of IO actions, or higher order functions) or confirm that what you've written actually does something like what you're expecting after you've called the compiler to check your work. 

This creates a new table that ensures there are no duplicates and then copies all the values from the original table. Then it sets up the primary key so as to continue from the original table. Finally, it renames the tables so that the new table takes the place of the old table. The was taken from your table definition -- modify as necessary. Then you can just continue using the table as normal (after you check the table definition and rows). Note that you need to stop updating the table while doing this. You can sort of make the work by saying (again, 56 is based on the table definition -- adjust as necessary). If new rows are added, you can get them with . But you should stop updates before altering the table indexes and renaming the tables. An advantage of doing things this way is that if the data is wrong after the inserts, you can always drop the table and try again. Your original data is still there, untouched. And you can test it before doing it for real. 

It seems like you may not quite grasp the interplay between do-notation and monad transformer stacks. Take a look at how I've rewritten here to leverage the actual machinery of . The version you wrote is needlessly verbose due to your manually plumbing the state around! 

You could eliminate the duplication further by extracting the body of the function into another function parameterized over the shift value. Something like this. 

I can't seem to download your data set. Could you re-upload a smaller dataset (say, ~5mb? and with your testing statistics for it) to Pastebin or somewhere? The only obvious performance difference with your Python version is that is based on a binary tree, whereas Python's dict is a hashtable. This makes an O(n * log n) operation in Haskell (unless you luck into the fact that your list of pairs happen to all be distinct and sorted in ascending order) but constructing the Python dict is O(n). This should make a significant time difference, but not necessarily space, so at this point I'm out of ideas. Make sure you're compiling with I guess. (There also seems to be a functional difference between your two versions if my understanding of Python hasn't rusted off after years of neglect. will pair with itself, so maybe you want to be defined as .) On issues of style, see the below rewrite. Note particularly the reordering of definitions so as to eliminate the -clause. In your version it was easy to miss due to being inline with the -block, you can do as I did, or try decreasing the indent. 

Is this the only query on that matters? You have too many simple indexes. For example, there's no reason to have an index on just if you already have one with in the front. 

Another problem is that you apparently want categories and percents to be linked, one percent per category. So the C++ way to handle this is to make a class, but in this case, let's make a struct instead: 

This is the same basic idea as your function, but it saves time by only trying to divide by other primes. Let's go through some of the pieces. 

Note that you can determine the maximum height for any piece by a simple lookup. Then you just need to know the current depth of the board and subtract the piece height from that. This happens outside the function and you pass this value into the function as . This saves the first few iterations of checking the board. I'd write this code, but there is insufficient context in the question. The function itself then checks the current board arrangement and eliminates the empty rows at the top by comparing the value of an empty row with the current row. It updates until a non-empty row is found. I include a check of , but you can skip this if there's always at least one non-empty row in . I removed the boolean in favor of two loops. This saves checking for the condition once it has been found. And it saves checking at all in the second loop. I moved the so as to save the unnecessary . Note that the compiler may or may not have optimized that out. Once I did that, it seemed unnecessary to continue using a loop, so I switched to the . That's entirely stylistic though. Instead of shifting on every iteration, I shift once before starting. There may be a way to do this with as well, but it looks more complicated. It might use more memory but save time. You don't include the definition of , so I won't try modifying the code for this purpose. 

I wouldn't say there's anything like a proscription against doing so, but as a non-user of I can't say it helps me understand what's going on. I'm also not sure that your data structure is complex enough to warrant using in this case, functions out of tend to produce a pretty concise solution on their own when properly deployed. I haven't tested this, but I think it's equivalent. 

No need to use list comprehensions and boolean double-checking in , just write it as a filter on the range. 

I think you're tripping yourself up by position-encoding the colors. Position-encoding is usually a code smell in Haskell, what you probably want is an association. Consider the difference between and , and just how much more expressive of intent the latter is. (You could be even more specific at the type level with something like but that's probably excessive for a small game.) So then how do you write a function with type ? As you noticed the may be in any order, so to compensate you can filter for each individual color, or you could leverage the instance and the original list to group identical colors together. After the colors are in order, what's left is to simply run-length encode the list. 

It's more common to put comments before the code. However, in this case, the comment is redundant. Either expand it to be more descriptive or remove it. 

This code is unnecessary. We already output the decimal point and then any subsequent digits. Also, we eliminated the variable. 

I'm not sure about calling there. It might be better to throw an . Note that I also have the board track the empty space separately in this implementation. That saves calling every time that you want the empty space. Just call it once in the constructor: 

The comments and code don't match. According to the comments, you should in both these cases. Either the comments are wrong or the code is. If the code is correct as is, you could write it more simply 

If you just want to get rid of the second call, you can save the value in a variable. If it exists, do the assignment. If not, don't. In PHP, if you don't need to do string interpolation (variables embedded in strings), you can just use single quotes. This is slightly faster and can help avoid bugs where you accidentally interpret something as a variable that was meant to be a literal . Note: there may be better overall solutions, but with so little context, it is hard to see them. For example, you don't say how you get this URL. Or what you're going to do with it. There might be better changes in one of those places. 

Yep, that's what we want. Deriving the Answer There are probably two different ways you might come up with your own solution. Either start at the concrete and generalize, or cobble a solution from typeclasses down. From the Concrete Consider again the type of the function you need. 

Yes. If your functions logically only operate on 8-bit byte values, then that's an important fact you can and should capture in the type signature. If returning a value of or or would be absurd, then eliminate the possibility of that even happening! In General There are other odds and ends that could be changed or cleaned up, like comparing arguments to or instead of using them directly () or using s instead of more pattern matching (). 

Generally all your types should be at the top of the file, i.e. and . I might use a list comprehension in writing to clean it up a little and reduce potential errors from referencing the wrong value. 

I do not understand these names. I would have expected to see something database related. Neither nor says database to me. 

You also may want to consider using absolute URLs, as those let you specify the protocol and domain as well as the path. 

This statement appears in every branch that does not return false, nine times. Once seems to be enough. 

As Caridorc noted, is a bad name here. Another issue is that only has two possible values. This suggests to me that it is either true or false, so use a true/false variable: 

The standard is to capitalize names of user defined types, so should be . I may have misled you in my other review, so I edited it for clarity. 

Your Javadoc is out of date. It still thinks that you are returning a tree. As a general rule, you should return a (the interface) rather than an (the implementation). This will make it much easier to change the implementation in the future. You are missing an 

can be cleaned up by favoring pattern matching over guards. Whenever you see a wall of guards that depend only on , consider pattern matching instead. 

encapsulates a notion of “failure”. provides an alternative value in the case of failure. is a typeclass that exists. 

By noticing that the and arrays are only ever used in lockstep, I can throw out the index (and the array size at that, I left it as an argument just for correspondence with the original problem statement and your version). and are then ped so that I can walk over them pairwise. When the test on succeeds, I just include in the output as a multiplicand. 

Compute the product at each index. The rest of the code is just pretty-printing and IO. On the very small sample input you provided my version actually runs a fraction of a second faster than yours, my guess is that's due to the overhead you incur from setting up your vectors. If you have a larger sample input I'd be very interested to see the performance. I would wager that our two versions stay within an order of magnitude of each other on running time, and they should use roughly the same amount of space due to lazy evaluation in my version. Theoretically. ;) 

I would prefer to write that with an inequality. The reason being that an equality like this is fragile in the face of other changes. Note that if somehow becomes true, your code will happily keep pushing into unknown space until it crashes. By contrast, if you were using indexes to track these, you could write it with an inequality that would halt even when in an inconsistent state. Strictly speaking, these are not bugs. This is a place where a bug could be created by interactions with other code (not included in this program now). Such code could be external to the code here, or it could be new functionality that someone adds to this library. I mention them because it may be worthwhile to write your code in such a way that it is more robust in the face of future code. 

This comment is backwards. The doesn't store Nodes and their corresponding names. It stores names and their corresponding Nodes. It's unclear to me why this field is called . Perhaps might be better. Again, the variable type should be the interface rather than the implementation.