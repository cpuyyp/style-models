An Example If you do the above on a sophisticated problem (building a hash map) it could take up a fair amount of class/exercise time. If you want to do it in about one class period, here is an example. The Attic provides a service that produces the means of collections of random numbers with a given distribution; say Binomial. It calls "down" to get the collections. The Main Floor produces the collections themselves when asked. The collection could be represented by, say, an Iterator. The Basement produces a single value from the required distribution. It could even provide services for several distributions: Uniform, Binomial, ... Other variations are possible. The attic, could, for example, provide the collection as a sorted list, rather than just a statistic about it. You can also add other intermediate layers, of course. Note that each layer here is pretty trivial to build. Beware that you don't give the impression that all such uses have this property. Also note that what we really have here is akin to a Unix pipe, simply because it is so simple. 

So, to ask if Physical Computing, by itself, is motivating, you need to separate out the other factors. I assume that if used badly by an untrained and unmotivating teacher there would be little improvement. On the other hand, the environment itself, if supportive, will likely lead to increased motivation. Another dimension should also be considered: motivated for what? I think that the goal is to get kids interested in computing generally, but that may not actually happen. You might see motivation for only projects that include the physical manipulation aspects, though that isn't a bad thing. When I was a kid you could get a kit that let you build a simple transistor radio with your own (little) hands. It was fun, and motivating, but not for radio itself, or even for electronics. For me, at least, it just motivated me to ask questions, for which I was already well known (i.e. a pest). Don't take this post as skepticism about physical computing itself, but think about the whole environment, not just the most obvious aspect of it. Finally, an environment in which the teacher is motivated and excited can motivate the students as well, even if the teacher is him/herself struggling a bit with the material. The enthusiasm of the teacher can be infectious. This alone will lead to anecdotal "evidence" of success: "I tried it and love it. So did my students." 

I recognize that this isn't exactly an answer to your question, but is a different way to think of the issue. I applaud the answer of Mike Zamansky given here already, but suggest an orthogonal approach. One way to get students to focus on efficiency is to ask them to name (or select from a list, perhaps) the efficiency of the solution they present and also possibly to reply whether it is the most efficient algorithm that they have studied. You can go further in an assignment and ask them to say why they think their solution is a good one even if not the most efficient. And if you teach sorting for this sort of thing, you, and likely your students, should be aware of this paper (pdf) by Owen Astrachan which says, among other things that Bubble Sort is never the best solution - either for simplicity or efficiency. If you ask for a discussion, in other words, you have more information on which to grade them than just looking at the algorithm itself. It also forces them to think deeper; generally a good thing. 

I have a bit of a quibble here. The only thing enforced by Java when implementing an interface is the structure of the class implementing it. The intent of the interface programmer isn't enforceable. Good names will help express the intent, but not enforce it. Good javadoc comments will convey more of the intent, but again it isn't enforceable. Absent some compiler/runtime enforcement mechanism of pre and post-conditions and invariants it is pretty unlikely that this will change. Other languages do, of course, provide such a mechanism which leads to design by contract. However, what we CAN teach our students is to program to the intent of the code we are working with and not just its structure. And that is always true, not just when implementing an interface. So, In my class the interface of the original post here wouldn't be acceptable, coming without clarifying javadoc comments. It is a contract (only) if you treat it as such. But lots of human interactions are similar. BTW, students writing subclasses (which IMO is too often done poorly) break the intent of the superclass as well as the structure. Among other things, subclassing by adding public features makes Liskov's Substitution Principle impossible to obey. If you need to cast, your code is probably broken. I'll wait for a good question about subclassing in Java-like languages to talk about why that is. 

The above rules are intended to make your programs easier to understand, hence easier to update and maintain. When tempted to break the rules, spend a bit of time asking why, and looking to see if you can come up with a better design. Breaking the rules tends to make your overall program into a Big Ball of Mud. All of the above has focused, primarily, on clarity of the code for the programmer's benefit. But efficiency is also a consideration. The more you can inform the compiler of your intent, the better job it can do in its translation. Some languages optimize for expressing intent rather than process, in fact. Database languages and Logic languages do this explicitly. If you tell a compiler how to do something it will be constrained to follow your directions. But if you tell it what you want, rather than how to achieve it, it has more options and can do better optimizations. So, explicit typing in programs is also a way to communicate intent (what) to the compiler rather than forcing later checks (casts). So, maybe x in our first example really only needs to be a short, or even a byte. But the declaration using var probably won't achieve that. I also realize that "abstract" names like are a poor choice. I only use it here as I don't have a context in which to provide an intention revealing name. 

A personal note (no, I'm not Socrates, though it seems like we were contemporaries). I became an expert in using Calculus by graphing literally hundreds of rational functions (quotients of polynomials) by using the information from the first two or three derivatives of the function. I did this completely manually, on paper. Today there is a web site that would do it for me and graphing calculators that will do it. I could do thousands of rational functions (instead of merely hundreds) but I would learn nothing at all. I would be just an observer. I would not have been able to predict the shape of such a function as I once could do pretty effectively. I might be an expert user of a particular web site, but that wouldn't have much effect on my brain. 

There is more to your question than just "how to program". For that, however, a good guide is to learn who/where a language was developed and emulate the code that those people write. For Scala, for example, get Programming In Scala by Odersky et al, who created the language. Textbooks are not in general a good guide in general. Many do a terrible job, using old techniques with a new language or using new syntactic styles without understanding the semantic intent. For the general question, how to avoid being misled about what is important and how to think, it is a hard problem. Long term, you need to learn to think critically about things and weigh conflicting evidence. One guide to "who gets it right" is to look at the papers referenced in various places. Who is writing those papers? Who gets referenced a lot. It isn't a perfect guide, of course, but if a lot of people consider someone authoritative, they probably are. For many things in Math and CS I find wikipedia to be pretty trustworthy, especially for more or less established knowledge. The fact that bad information can be driven out by other, more knowledgeable, people is a plus. I have found the occasional bit of garbage, however, but it tends to disappear fairly quickly on technical articles (unlike pop culture). If something "feels" stupid, it may be. But you can examine the edit history of the articles there at least and see if the dumb thing is recent or has been bouncing in and out. For new discoveries, wikipedia will be in flux for a while as the idea settles down and people come to some consensus. This also explains why text books don't do a good job initially if things are changing (paradigm shift). They can be too much influenced by old thinking and unsettled experimentation with new ideas. Another suggestion is to cultivate people with more knowledge than yourself and against whom you can bounce ideas. The chat rooms as SE, of course, are a good example of where to find such people, but you may have some access to professionals in your community as well.