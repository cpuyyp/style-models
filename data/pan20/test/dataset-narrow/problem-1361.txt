Rendering Falling Rain and Snow - SIGGRAPH submission of the paper Actual published paper - Let It Snow, Let It Snow, Let It Snow (and Rain) - Game Programming Gems 5 Written by Niniane Wang(absurdly smart, who gradautes cal tech in CS at 18??!!!@!@!$) and Bretton Wade 

For Python specifically you can try and use Coroutines to do calculations over multiple update calls. 

HGE - Haaf's Game Engine is a C++ 2D engine. A very well established and very stable engine based off of DirectX. I would definitely recommend making clones of very simple 2D games to stop yourself from getting too ambitious. Tetris, mine sweeper, pacman, etc. 

Implemented as a Server/Server architecture you can implement your AI bot in C++/Java/Python/C#/Go/etc etc. 

Depending on how much 3D you're really going to use will most likely be the largest factor. Primarily 2D: If your application is primarily 2D(like 95% to really make this a viable option) then use the Slick engine which is a 2D engine. 3D models will have to be done directly in openGL via SlickCallable. Primarily 3D: It might be a lot easier to use the JMonkeyEngine 3 and use textured billboards if you need a lot of 3D graphics. A lot of the expected sprite handling will needed to be coded by yourself though, although you can stay within the world of JMonkey and not have to drop to openGL. Unique Hybrid of 2D and 3D: Depending on how much interleaving of 2D and 3D technology you need it might be more beneficial to create your own hybrid engine straight from LWJGL. A tutorial on how to build a 2D/3D asteroid game is located here Source code here 

This is a great article about how to prototype a game. From your question is seems like you're missing the idea of what a prototype is supposed to be. Prototyping: You’re (Probably) Doing It Wrong Blurb: 

Ogre4J is a binding to the Ogre C++ graphics renderer. Going straight to C++ is probably preferred though. Ogre is a scene graph based rendering engine which does everything you're looking for. 

Pogamut 3 GameBots2004 Extension of the original GameBots work done by USC which supports UT2004/ UDK/ and Defcon. Allows an external program to control bots in game in a Client/Server fashion as if they were a human player. 

This is a pretty general question with many different approaches. I'll just mention two major differences in coding AI logic into Lua. As a prerequisite you will still need to expose C/C++ low level functions so that lua can make function calls to affect game systems or query for game information. Movement, pathfinding, inventory, etc, etc Script as low level decision logic Basically you can use script for the very core decisions. How an AI may select a target, or how an AI chooses which weapon to use, etc. Think of lua functions or individual scripts as very small amounts of AI behavior. This would mean C/C++ would call a function on the lua side, passing in values where the decision logic comes up with the result and passes the result back to the caller. This type of approach works very well when the overall structure of what makes up an AI is in code and can be constructed either through hard coding or from a data source. Structures like Finite State Machines with states in lua, or Behavior Trees where individual tree nodes are coded in lua fit perfectly in this model. Script as high level decision logic A completely different approach is to allow the lua script to completely control the AI. In this sense you could have a "think" lua function that is called every tick which represents the AI logic. The "think" function would need to be ticked either per frame or whenever is appropriate for the game you're making. For example if lua is controlling animation playback it would probably need to be ticked per frame to have control over animation handling. This approach isn't structured except for the known function that C/C++ calls into for the specific AI. All AI structure and logic can be written in any form you want in script with the AI storing any persistent knowledge as global variables in lua. 

Typically in C++ game development speed is valued over encapsulation, you therefore see a ton of publicly accessible class members which really shouldn't be public. I seem to find in most cases that only a very select few clases really need to known the inner workings of another classes to the point of modifying or reading their private data. Creating public getters/setters for this private data exposes things which really shouldn't be modified willy-nilly. Would a compromise here be to use friend classes? or is there some drawback to friend classes I'm not seeing. 

$URL$ Galatic Arms Race There is another game that used a similar technology but instead evolved custom weapons based the effectiveness and overall gameplay of the user. 

There is an RTS that is based around this concept. But instead of enemies that evolve, the player trains units which are able to breed, adapt, and evolve. NERO The technology behind this is a mix between Neural Networks and Genetic Algorithms, called NeuroEvolution. 

Strategy Pattern, Composition, Dependency Injection, are all very closely related. Since the Strategy Pattern is a form of Dependency Injection, if you take a look at engines like Unity for example they are completely based off this principle. Their use of Components(Strategy Pattern) is deeply embedded into their whole engine. One of the main benefits aside from reuse of components is to avoid the dreaded deep class hierarchies. Here is an article by Mick West who talks about how he introduced this type of system into the Tony Hawk series of games by Neversoft. Evolve Your Hierarchy 

image from $URL$ What you're looking for is actually a path following steering behavior. The AI moves to a future point along the path instead of from one point to another. A gray buffer around the path allows the AI to navigate within this region before the AI must steer to stay on the path. Craig Reynold has an excellent article on how this behavior works and implemented it in the Open Source OpenSteer library Path Following steering behavior 

You can also use an array of uniform matrices and draw in groups based on the number of uniform matrices you are able to store in the GLSL shader. You will hit uniform limits fairly quickly with this approach. 

If you have 3D models there is a program made by EnvyGames, SpriteWorks, which will make 2D sprite sheets out of the models for you. Allows you to play animations and customize a bunch of stuff. I think it's a bit pricey for what it is, $49.99. Here is a tutorial on how to use SpriteWorks Creating Sprites from 3D Models - EnvyGames 

Safari Books Online has a pretty good selection. Only 22.99/month gives you access to read 10 books and preview every book they have. $URL$ 

Slick is a nice 2D Java library based off of LWJGL. It handles the game loop, rendering, and contains useful functionality to implement sprites. It comes bundled with many different demos and examples. 

Edit: I'm adding this just to clarify the difference between Prototype and Tracer Code. Always remember: A Prototype is designed to be thrown away! Tracer Code is not. The Prototype Pitfall 

I've had much better success profiling using YourKit for Java. I tried TPTP but it is very painful to use. YourKit also allows for remote connection. If you want a more simplified monitoring solution you can give JConsole a try. This is the bundled monitor program that is distributed with Java. 

A much better question to ask is "How do I pick the right teammates/project?" This is an excellent article on the subject How to Pick Indie Game Collaborators: 11 Things to Watch Out For 

OpenGL and freeglut will do what you're looking for. Freeglut can create the spheres, cubes, cylinder, cone, donuts, teapots, etc. 

More Information about the Tracer Code design, from The Pragmatic Programmer Tracer Bullets and Prototypes 

Brood Wars API is a dll injection type interface which natively is Server/Server design but also has extensions to support Client/Server architectures for additional language support. Extensions support Java, Python, C#, Php, etc. 

This is a great beginning resource that takes a look at all aspects of path finding in a very easy to digest approach. Amit’s Notes about Path-Finding 

Things like tilemaps, sprite sheets, etc are all built in. Basically lets you focus on the game, not how to write an engine. 

These are just two very different high level approaches to using scripting. Of course not taking into consideration memory or performance of the AI. 

If you wanted to stay in the XML realm of things you can use Binary XML to help increase load performance. For example Fast Infoset is an implementation of binary xml 

What are the pros and cons of using Exceptions in C++ in relation to game development. Google style guide says that they don't use Exceptions for a variety of reasons. Are the same reasons pertinent towards game development? 

So it looks like what the author of the question wants is basically to hack server calls of web based games? If that's the case I'm adding another answer which is very different from my first answer Fiddler Fiddler is a web debugging proxy. It will let you setup a proxy between you(the client) and the server. The proxy has a ton of configurations will will let you save sessions, replay sessions, pause AJAX requests and edit them on the fly. It can log all AJAX requests so you could build a HTTP robot which could simulate playing the game. Fiddler was originally created by a PM at Microsoft for debugging websites, and web interactions of applications. 

World Machine $URL$ World Machine has a non-commercial free version which only has a few limitations compared to the commercial version. I can't speak highly enough about this software. Produces both a heightmap and texturemap procedurally. I used it to create the island and texturemap for this techdemo 

They usually use diminishing returns for stat values so as you add more of the same stat it actually makes less of a difference. 

Essentially you can use Perlin Noise generation to generate your maps. You would sample the height map generated and assign gravel blocks to parts of the map that have above a certain height. Here is an excellent reference post on how to go about implementing such a system and different types of terrain that you could generate. The examples have a lot more steps than you would need, but the concept is the same. More on Minecraft-type world gen $URL$ 

Information about both of these middleware solutions is limited. I was looking for pros and cons of using either. As well as any type of comparison between both middleware packages. In particular: 

For example, Havok Content Tools allows you to define physic bodies, properties, connections, etc in Maya, 3d Studio Max, etc. For creating full scenes/levels is this really the correct approach or is there some better way to do things. 

Essentially you are asking for a derivation of the Cube Packing Problem, which is just a special case of a Packing Problem. This class of problems is known to be NP-Hard (non polynomial time solvable and at least as hard as the hardest NP-Complete problem). There are heuristics to try and solve this that aren't guaranteed to return the optimal solution. You're going to have to refer to papers though to dig deeper. This paper may help you get started(behind a pay wall) A heuristic algorithm for cube packing with time schedule - Wei Li, WenQi Huang, DongChen Jiang, XiangLong Liu 

What I've seen in most Game Engines and game engine design is that the Physics Engine is the be all end all system. Basically, AI for example may want to travel to some position, but it simply sends that request (velocity, direction) to the Physics Engine. If the AI really gets to that position is up to the will of the Physics Engine. Is there some Design or Physics Engine which will let you plan out how Physics will react? Before it will actually occur? Take for example that you can do Motion Planning by the AI to nearly eliminate foot sliding. 

Wetrix Wetrix was a cross between Tetris, and water manipulation. The idea was to create lakes by raising terrain to capture water. It was pretty fun for the N64 and PC 

A socket based messaging scheme can be used to allow any arbitrary language to interact with the AI. You could use binary based messages, xml, text, etc. Just clearly define what the message format is and what messages you will send and receive. This technique works relatively well for light to modest communication handling. There is a latency penalty associated with it of course, but since your game is a board game style it doesn't have to run in real-time. 

You need to define what you mean by best engine. Ogre3D is strictly a Rendering Engine. That point alone scares off a lot of would be game developers. Ogre3D does not have integrated collision, physics, networking, sound, scripting, etc. Ogre3d is only the graphics part of a game engine. Ogre allows for easy integration with things like Nvidia Physx or Havok, etc but it is still up the developers to integrate the products. Another disadvantage to using Ogre is when you look at fully integrated game engines, Unity, Unreal, etc. They have very nice in world editors designed for map makers, scripters, etc. It's a lot more upfront work to design something like that on top of everything else you will need to integrate to have a usable game engine to create something from. Ogre works well when the developer wants to be able to fully customize how they want their game engine. What components they will have, which libraries they will use, etc. This was the main idea behind why Ogre is and will always be a Rendering Engine. 

What are some open source AI Bot interfaces? Similar to Pogamut 3 GameBots2004 for custom Unreal Tournament bots or Brood Wars API for Starcraft bots etc. If you could please post one AI bot interface per answer (make sure to provide a link) and give a brief summary as to the content of the blog posts. Please include what type of bot interface structure it is, client/server, server/server, etc e.g. BWAPI is client/server which emulates a real player 

Take a look at Valve's director in Left 4 Dead and Left 4 Dead 2. Using adaptive AI in this aspect may add interesting gameplay dynamics and replayability when the AI learns that there is a set predictable gameplay strategy that players tend to use or abuse. It would be interesting if AI could evolve to suit an expected gameplay time. So scale harder if a player is blazing through a level, but scale it easier if players are having difficulties. Gameplay valve for a fitness function, maybe someday. 

Why bother writing the boring interface code and use AI Api's directly? Program the AI not the interaction with the game itself. Starcraft 1 The very popular BroodWars API allows for commanding all the units to do anything a real player could. You can even battle against other players or AI's with your AI $URL$ Super Mario This API allows for you to control Mario! It was a contest for the best level generation and fastest level completion AI. (A* actually won) $URL$ Galcon There is currently a contest for the best Galcon AI, a Google AI Challenge. Of course Galcon API is provided. $URL$ 

This is a huge warning against using and even thinking about using TorqueX!! note: this is based off of my experience from around 06/2009 I too, was naive and thought, wow a XNA based engine that would help speed along development. And on top of that TorqueX is free if you have an XNA creator's club account. I want to stress again this was NAIVE. I purchased the XNA account on 06/18/2009 so the TorqueX I have experience with is back in the days of TorqueX 2D and TorqueX 3D 3.1.5 From what is on their site it would give you the impression that the 3D editor and engine would greatly help with development. They even show Box Macabre on their site which uses the TorqueX 3D engine. Everything is peachy at this point and hopes are high. That is until you actually try and use it... TorqueX 3D 3.1.5 is based around using their editor to modify xml files. Too bad the editor was EXTREMELY unstable. You of course don't get to know this until you get access to their "private" forums. If you want to know why they are private it's because you'll see huge gripes. One, that TorqueX 3D was basically a POS and two, the utter lack of documentation. The companies "defense" against the lack of documentation is that there was only one documentor that was shared between all the engines they develop. I even had "The Complete Guide to Torque X" book which was written by one of the developers of Torque X. Basically the only documentation that existed at the time. Anyways to the end of the story it was a complete nightmare. I ended up switching over to TorqueX 2D which also was a ton of problems. The TorqueX 2D engine/editor was a lot better. Actually usable, but since I had the free XNA creators version I only got binaries and no source code. It's no fun when you find bugs in the engine but lack the source code to actually fix them. Their forums were littered with source code fixes which could not be applied to the binary distro. All in all, a waste of time and money. I would never in my wildest dreams touch any Torque product with a 10 foot pole.