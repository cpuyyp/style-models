First of all, you should perform a distance-based pruning of possible collisions. A bounding rectangle around object O1 with a longer edge of length a has a potential collision radius R1 = sqrt(2) * a/2, so if another object O2 with collision radius R2 is more than R1+R2 apart, they cannot collide. Only if the collision circles intersect should you check for the more complicated rectangle collision. Work with squared values to avoid the expensive sqrt(), except if you need the actual distance anyway. Then you need to change your BoundingBox property and collision detection method to support arbitrarily rotated rectangles. Instead of the Rectangle class, use 4 Points named UpperLeft, UpperRight, LowerLeft, LowerRight that you adjust according to the object's rotation. Then you use, as you already noted, the Separating Axis Theorem. Since you are using Rectangles, you can use a lot of optimizations. Details here, including Maths: 2D Rotated Rectangle Collision 

That means that even if your TotalGameTime says 60 seconds have passed, it may not be real world 60 seconds. In the worst case, if a player slows down his system, it might even be a possible exploit/cheat, so you should explore other ways of tracking time as well. 

Adding an artificial delay is a really bad idea IMHO. 1) It's unexpected - what other well-known platformer does it that way? 2) It limits your player's jumping accuracy, because in tight situations, it might prove fatal (the character falls off a platform because you can't take off quickly enough), which would be the ultimate turn-off for any player - losing against the interface 3) To compensate for 2), you would have to tone down the maximum difficulty of your jumping areas. That limits how challenging and interesting you can make your game. 4) It still doesn't actually solve the problem of spamming - if you just keep holding jump, then the character will jump after the delay, like a robot. Is that really any better than jumping like a robot without delay? There is, however, an organic solution to the problem: You just have to remember that human coordination is limited by nature. The only way for me to spam jumping is by holding the jump button. If I can't just spam the jump key, then I have to wait until my character has landed before pressing jump again. That poses a natural limit on how fast I can jump, and an artificial delay becomes completely unnecessary. All you have to do is to check for 3 things before jumping: 

So in essence, without completely breaking the XNA game loop by calling Draw whenever you feel like it, you can only influence the number of calls per second to Update, and Draw will be called at most once per Update under any circumstances. 

Nothing stops you from allowing players to go faster than the speed of light. Take a look at Space Engine(free) or Universe Sandbox to see how they do it. 

As always, you have several ways of doing it: In any case, add a bool Visible to each tile, and set it to true when it has been discovered. This property decides whether your tile is visible or not. How you save that property entirely depends on your code, only you can answer that. a) Set the background to black (GraphicsDevice.Clear(Color.Black);) at the beginning of each draw step, and simply don't draw an undiscovered tile. b) All overloads of SpriteBatch.Draw have a parameter Color, which tints the texture to a certain color, without changing the actual texture in any way. If Visible == false, then you use Color.Black in the Draw method, otherwise you use Color.White. c) If at some point you want a nicer texture than plain black, you can simply start out with all tiles being the fog tile, and then replace the texture at a visible tile with the one it is supposed to be. 

As far as I understand that, you translate your object according to its own x, y, z axes, which can be different from the world x, y, z axes, for example after you rotate the object. 

You also add a Vector2 pos, which you described in the comments as the object velocity vector, which would make even less sense; though by the name pos I guess you meant the right thing, the position vector, the object's location. So you got it half right: the mistake was that you added that position vector to the sprite sheet source rectangle (which has varying X and Y values), instead of the object's dimensions (which, expressed as a rectangle, always has position (0, 0)). Assuming your default, non-animated source rectangle is located at (0, 0) on the sprite sheet, it would explain why collision is working when not animated, because you happen to have a rectangle with the correct location, i.e. (0, 0). But as soon as you start animating, the X and Y coordinates are wrong, because you always need (0 + pos.X, 0 + pos.Y), but you get something other than 0, depending on your currentFrame and frameRow. 

What is the point of calling Draw potentially more often than Update? Why is Draw not upper-limited to the number of Update calls? 

From what I gather, your character movement is on tiles only, and you have a fixed animation length, something like a Tactics game? What I would then do is to simulate a stationary jump, and combine it with the existing walking logic. Implement a simple gravity system, if you haven't already. When you want the character to jump, you simply give him an certain upward velocity vector negative to the gravity vector, and on each frame, subtract the gravity vector from a character's speed vector, until the character hits the ground again. Now you have a natural-looking parabolic jump made easy, because that's basically how it works in real life (under Newtonian laws). Now, to jump from tile to tile, the moment you start jumping, apply the forward (horizontal) movement as you already can do. Displace the character sprite by the same vector as without jumping, and at the same time, also displace him according to a static upward jump, depending on his current upward vector. The jump and move displacement should combine to a natural-looking forward jump without fancy algorithms. Of course, you need to take into account the height difference between the starting and end tile. If the character jumps up, you need to give him enough initial velocity to get there, enough to reach a height of, say, the difference + 1 height units. When jumping down or on even ground, jump up 1 height unit before falling down. So now the duration of the jump animation depends on the height difference. Next, you need to make the duration of the forward movement dependent on the duration of the vertical movement. A long vertical jump takes a longer time to complete than a short vertical jump across the same horizontal distance, obviously, so your forward movement must not be constant, or you will typically overshoot. For a spot landing, it must always match the duration of the jump*. If you haven't already, you therefore need to extend your movement function with a duration parameter. *Exception 1: For simulating a cool "slide" after landing, don't simply end your animation with a stop, but take the idea of gravity further by implementing a friction vector, which is basically "gravity for horizontal movement". Give your character a vertical and a horizontal movement vector. Ignore gravity while the character is on the ground, and ignore friction while the character is airborne or walking. Apply friction to the horizontal velocity as soon as the character lands from a jump, so his horizontal movement will continue, but slowing down until it reaches zero. *Exception 2: If you want to simulate a jump against a wall, just reduce the upward and forward component velocity to zero the instant you hit a wall, and then let gravity do its work. 

Finite amount of lives in video games was a design element inherent to coin operated arcade gaming machines. In order to limit a player's play time so he would be forced to spend more coins or make room for the next player, a finite lives system, coupled with high difficulty, proved successful, so it became the standard for all of arcade gaming. As home gaming consoles grew more popular, their games were of course made by the people already in the industry, so game design just stuck to what they know - high difficulty, limited number of lives, which led to the popular "nintendo-hard" label, referring to NES games. As arcade machines declined in popularity and video game design matured, the concept of limited lives slowly fell out of favor. It typically made way for quick saves and instant, infinite restarts with short levels (think Super Meat Boy), in order to preserve the flow of a game, as opposed to setting back the player to the beginning of a level or checkpoint as a punishment for failure. 

You might want to take a look at the Command pattern. Basically every reversible action your entities take are implemented as a command object. All of those objects implement at least 2 methods: Execute() and Undo(), plus whatever else you need, like a time stamp property for correct timing. Whenever your entity performs a reversible action, you create an appropriate command object first. You save it on an Undo stack, then feed into your game engine and execute it. When you want to reverse time, you pop actions from the top of the stack and call their Undo() method, which does the opposite of the Execute() method. For example, in case of a jump from point A to point B, you perform a jump from B to A. After you popped an action, save it on a Redo stack if you want to go forwards and backwards at will, just like the undo/redo function in a text editor or paint program. Of course, your animations must also support a "rewind" mode for playing them backwards. For more game design shenanigans, let every entity store its actions on its own stack, so you can undo/redo them independently of each other. A command pattern has other advantages: For example, it's pretty much trivial to build a replay recorder, since you merely need to save all the objects on the stacks to a file, and at replay time, just feed it into the game engine one by one. 

You should definitely go with a score count - even if you only give 1 point per kill. If you implement a score system, you will have an easier time later on if you decide to implement more enemy types, or a combo system in the future. 

Basically you can re-use your code as it is. However, you don't execute it every frame, but only when your character direction actually needs updating, i.e. when any of the direction keys has been pressed. So the complete code could be: 

A health/damage mining system would be much more flexible and should be easier to implement than a fixed, time-based system. Basically, assign each block a health value, and your pickaxe a "mining damage" value, and whenever the pick strikes the block, you subtract its damage from the health of the block. When the block's health goes to zero or below, the block is mined. In order to achieve a certain time span until a certain block of ore is mined, then set the block's health equal to damage per pick strike * pick strikes per second Advantage: You can re-use the existing health system for all your other entities, if you have one, and you can much more easily introduce and balance kinds of ores that are easy/hard to mine and pickaxes of different strengths. You can also give your players more flexibility in what tools they use for different tasks. For example, why not allow your players to mine ores with dynamite, i.e. explosive damage, instead of only pickaxes? A health/damage system allows you to do that quite easily. 

I've googled this using a lot of keyword combinations, but to my great surprise I could not find an algorithm for constructing a regular, n-sided polygon into a given circle, i.e., finding the coordinates for the n corner points. All I could find were instructions how to do it by physical compass and straightedge, or interactive browser plug-ins without source. So where could I find such an algorithm? 

Two methods come to mind, depending on the number of fragments that you want to create: Either Paint, as noted in the comments. Easily faster than coding something up if you have a small-ish number of spritesheets and/or if you are missing most of the mappings. Or you could write a little XNA program that goes something like this: 

Strictly separate your game engine from the rest of the project, such as GUI, net code, etc. The game engine itself should be event-based, let the OS provide the "game loop" in form of its regular event handling. Make all game events that are relevant to the outside accessible through events to which the GUI and all other parts can subscribe. Then you are free to implement your GUI whichever way you want. 

If you just want to share it and you don't want to set up your own website for that purpose, you could always use any file hosting service and share the link via gaming forums. It doesn't get much easier than that. However, as people are wary (or at least should be) of downloading executables from an unknown source, you could always share the code itself through something like Sourceforge. You can quite easily set up an online repository, forum, wiki, all sorts of things, depending how much effort you want to put into it. That way, people can still download the executable, but can also verify the code that it contains nothing harmful/malicious. Also, if your game contains something that piques someone's interest, your game might, with your consent, get developed further into something even better. 

Writing games with a WinForms or WPF UI is perfectly fine. There are thousands upon thousands of popular and enjoyable games that don't need or benefit from hardware support. Just think, if nothing else, of the classic Windows games Minesweeper, Solitaire, or Freecell. I could easily imagine those games being implemented today with Forms or WPF. In fact, being the casual games that they are, that might be even the preferred way to go for me. That being said, it's important to pick the right tools for the job. Since you mentioned Jump & Run mechanics and collision detection, then you probably could cook something up in WPF, creating your own game loop and drawing and whatnot, working with UI components instead of your own specialized classes. However, is that the smart thing to do when there is XNA? Definitely not, as specialized game development frameworks ease your work so much when creating games with somewhat higher technical or design demands. So as a conclusion, you should really learn how to use a game development framework as your design goals become more complex, and if C# is what you know, XNA would be the most obvious answer as to which you should be using. 

TL;DR: Implement a bot that can quickly check whether or not a given level is solvable at all, preferably in your level editor. Then design levels that could be fun to solve. Then manually playtest for the actual fun factor and difficulty. 

You can keep a number of the total resource demand per tick for all constructions. If one resource storage hits less than this required amount, then all construction would stop completely until the storage has gathered enough to support at least 1 tick of production. Then production can resume. So instead of storing production rate as a float, it is binary - either your factory produces at full speed or it doesn't. That being said, this approach is essentially the same as Jonathan's answer, for the production rate special cases 0.0 and 1.0 - an arbitrary float f with 0.0 <= f <= 1.0 is probably more elegant as you don't get jerky storage amount movements, but the logic should be a bit simpler. 

There are several open-source projects of this nature, with different approaches to implementing the rules. Here is a blog entry from the creator of one of the more well-known MtG implementations, CardForge. It may not be a complete list, but it contains several open-source projects where you can simply browse the code, or visit the forums for specific questions. As an actual answer: Your best bet for a robust framework is to strictly employ Object-Oriented Programming. Every Action, every Trigger, every Ability is an object. Zones like Hand, Library are objects too, needless to say. In the Rules engine, never pass around dumb objects like strings or integers to describe game objects, but your objects only. Every action puts a number of trigger on a stack, where every other ability can check whether or not they care about that particular trigger, and if they do, they fire their own actions, potentially creating new triggers, and so on. Then you work down those stacks according to the game's rules, until the stack is empty, at which point new actions can be taken etc. Ideally, if you perfectly implement the game's rules, your rules code does not contain a single hardcoded card. Hardcoding cards can create convenient shortcuts, but in the long run, this will bloat your code and create potential pitfalls, such as when new cards are released that interact with those cards in a novel way. In a game like MtG with over 12,000 unique cards and no end in sight, there are MANY such interactions.