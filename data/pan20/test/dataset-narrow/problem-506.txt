and so on for the other commands. The method should also be put under this hierarchy. There is no reason to make it distinct from others; the arg that it currently receives is used only to control the output, which may be triggered through a dedicated method. Each concrete implementation may also host a method that returns the contents of the help section for the command: this will avoid to have the infinite clause while handling the help output. Finally, is not a very comfortable container for the commands and their handlers. An would suit better, for example 

They have ate least five similar arguments. It really seems that instead of having this pullulation of methods there should be an abstraction like . 

all have same role: creating a message. Since the interface is in the same package as the implementation, I suppose that this interface does not come from a third party API and it is something that you can define and change. I suggest defining an interface dedicated to pipe message building: 

I think that with this approach it is not mandatory to bind to an interface. The method may even be static. The returned builder references may be either constant or instantiated for each call: it depends on other details. With this approach, building a message will be reduced to this chaining: 

The idea would be to validate the candidate value before setting it on the object. Not sure that dedicated classes are necessary, because they are just wrappers for the only field, aren't they? Exceptions Handling Taking into account the current listing, the code 

"0 is less than or equal to X AND X is less than or equal to 1" Which approach is better for understanding? Naming The function names and are simply too vague in . Their current role is access and changing pixel color values, so their names should reflect it: or . is neither very appropriate. Its role is to choose a pixel and fill it with a calculated color. Shouldn't it be named instead? Also avoid duplicate names with underscores like and in . First, the underscore is not conventional; second, the purpose of the reference is not clear. Should it be called or or other? Design Issues I think that there is a mess about the core part of class, concerning coordinates and colors management, and in function. 

computePersonality Your main concern. There are too many repetitive . The personality type letters can be extracted into a constant matrix, for example: 

The redundant logical expression seems to be too complex for this case. And there is probably a bug. You say that the expected set of values for it is ("0", "1", "false", "true"), but if value = "2", it will also evaluate to "true": 

Prefer Classes to Multiple Tuples There are lots of usages of , with multiple occurrences of and . Tuples are nice and suitable for various situations, but when there are too many of them, it reduces readability and increases risks of bugs. And you need to remember that is and is . Or vice versa. Or both. So a simple way to improve it is just create an ad-hoc class 

"1" is still there, because checks for equivalence for "true" string value. The logic of the entire method can be thus reformulated with improved readability and simplified: 

If something breaks, you'll easily find where the problem is, instead of decoding the meaning of or . 

Welcome to Code Review and thanks for a nicely prepared question! Structure Concerning the design of this code, there is clearly an issue that should be solved with OOP approach. I mean that the following methods: 

I think that both approaches are incorrect. Why would you need to cast an object to its own type, while it is already typed to a type that inherits from its parent abstract type? The method is absolutely senseless, because if you have an instance of an object, it is typed by definition. 

This can also be transformed in Java8 streams processing to get a more elegant solution, but since the original code strongly looks like "before-Java-8", I decided to keep the style. To compare the solutions, I've also written a simple test with an ad-hoc object definition. The tests executed on 6K objects, with 5900 "inserts", 100 "updates" and 5900 "deactivated" expected items in the results gave the following: original time: between 350 and 450 ms. improved solution: between 8 and 15ms. For this implementation, there is still a drawback concerning duplicate items from the original lists. Only the last occurrence of each duplicate will be retained in the s. But since you say that you don't care about duplicates, I don't care about them neither :) P.S. And I'm not sure if it is still necessary to keep the object, if it was used only to check for processed items. 

5) As already mentioned in another post, do not use for prices. BookRepository 1) map should be . 2) In , instead of checking two times in the map, one call could be enough: 

In the condition of the same method, is usually a better choice to check if a collection contains something, than . Loops & Comprehensions Consistency There are weird differences between loop definitions that are supposed to do similar things. Just be consistent, use either or , but not both. Semicolons are very bizarre at line start and indeed are not necessary. The comprehension produces a collection that can be directly converted using , no need for additional varargs conversions: 

!? Be very careful with calls. Are you sure they are necessary in this code? Wouldn't there be a risk to break the applications of the users of this code? , if not in method, is generally a bad practice. 

Omitting dots for function calls and parenthesis for arguments are not among the recommendations of the official Scala style guide (sections Arity-0 and Arity-1). This practice can reduce the readability. For example, I find that and are easier to perceive for a human-shaped reader than the respective expressions in the original code. There are several occurrences of that can be extracted in a small helper function like . This will allow to transform the respective instructions into more elegant, for example: . But since among the three functions only one will be chosen/used, this will eliminate the duplications and the relevance of this remark. 

By analogy, there can be interface. I also recommend to always specify annotation: if the name of the field changes some day, the JSON API will not be broken. If Lombok is used in the project, this approach allows to reduce dozens of lines of code. Now, the initial class will resemble the following: 

But for this very concrete and short example of code I would consider decomposing it into patterns as a sort of overkill. There is some job to do about the original straightforward approach, so let's just try to improve it. The input numbers are read several times using the object. They should also be validated, so a dedicated method would be very useful: 

Please note that there is not a single left in this function. BTW, there is a potential bug in the original implementation. shouldn't be initialized with , but rather with . function can be refactored using the same principle, bu there will be two more things: 1) the call needs to be separated into a dedicated loop, for example: 

is not a very performant data structure when you need to search and match elements. Here you have a nested loop, with even one more "hidden" loop when is called. To improve the performance, I can suggest to operate on s. If it is not possible to change the signature of method, the contents of the lists can be transformed into two objects, where the key points to ref and the value contains the BO itself. The transformation method: 

First of all, the readability of this code is OK. Entities are quite well structured and an effort to respect the SRP principle is seen. General Design However, I would suggest a few renaming and design changes. The class resembles a factory, because it instantiates the business logic entities ( or ). But also it chooses which one to use and triggers the main action: this is too much for it, so let's separate the roles. We can introduce an interface that provides access to the main action: 

Yes, this usage is acceptable if your intention was to have a of objects that can be removed by the garbage collector if they are not referenced from elsewhere. Instead of using the old-school keyword, I'd recommend to add a ReentrantReadWriteLock field in and use it in the three methods. I think that your implementation is already quite simple, readable and usable. Making it better would depend on the goal you are looking for. But there are still a few remarks after these answers. If you add another method like , it will have drawbacks such as pollution of the APIs of the objects that do not need the second method, ambiguities in the choice of the method to use for the caller, etc. If you want to grant your user a possibility to define custom events, the simplest way that I see here is to replace the argument with : the API will not be coupled with the rigid enum (which needs to be modified in order to introduce a new event type) and the user will be able to define his own event types easily. 

Do not use full-word names for generic types. can be easily misleading, even for an IDE (for example, my IntelliJ automatically imported , which is very confusing). Use single-letter names for generics: , , ... The two methods differ only in conditional branches inside the while loop, but all the other code is redundant. That can be improved. Using Java 8, we can extract the equality condition check and the value change function into the signature of the method: 

It's ok in regards of readability, but it can be shortened. There is no need to create a dedicated with implementations. All that can happen anonymously. The function can take a function as implicit parameter: 

The properties file must contain the key . The annotation is used to point to the properties file to look in: 

Indeed, there are some possible improvements for the instructions that handle : instead of creating conditions with , the style is more "functional" when (or other methods) are called. For example: 

These remarks do not answer your initial question about the type safety of the solution. It's too early to answer it before fixing many of the critical issues. 

Now, the main part of the thing. We need an object that will hold all the that we know and provide access to them. Let's call it : 

With strict class equality, if another entity inherits from , it would fail to call and violate the principle of implementation. 4) Simplify : 

This method does two distinct things: 1) Determine which URL to use depending on the value. 2) Instantiate a object with suffix. Each of these things should be wrapped in a dedicated method. So let's first create the method: 

Concerning the class: Since this class is a wrapper for a and already contains method, it would be better if it implemented the interface. This will allow the users of this class () to benefit from try-with-resources block and they will not need to call explicitly. If an is thrown in method (which would hardly occur here, but imagine that is replaced by another source), the objects created in constructor will become inconsistent, with . Probably, that is not what was intended. Returning in this context is a replacement for an exceptional situation and is not a valid value for the calling routines. I'd suggest to avoid it here (as well as in general) and to re-throw the exception, which should be caught and managed outside. The resulting class will look as follows: 

The context of this code example is not very clear, so in my remarks below I will suppose that the code is about a generic implementation of depth-first search. 

It can be very confusing and error-prone when the instruction that immediately follows a condition is not wrapped in a block. 

It should be named , because in the current implementation it returns only the files with names matching the regex and all the directories. By the way, it is not very clear why the directories are put there. The implementation of this method is correct in general, but is coded entirely with before-Java-7 style. Indeed, would be a lot of help here. First of all, there is FileVisitor interface. Using a SimpleFileVisitor prevents us from pre-calculating . It also solves the problem of files with same names in different folders: 

Now we need to parse a raw token, represented initially as a . A token can correspond to a numeric value or to an operator. We can use Scala's Either construct to represent this choice: 

Beans Bean objects like and contain private fields that use property wrappers from package. This creates a tight coupling with the package for such simple data structures, without any particular need and adds unnecessary complexity. They should be replaced with basic types ( -> , -> etc). 

The values associated with the elements are no more than their ordinal numbers, so exactly the same effect would be reached if it were defined as 

needs an instance of and it executes all the boilerplate of traversing the file hierarchy, we need only to implement our logic. Let's call our implementor : 

(either from or ) is THE object to use when you need to dynamically construct a String from numerous concatenations. Readability contains a terribly complex filtering condition and unnecessary s. Slightly changed: 

I think that is more appropriate for these validation checks. If you still want to remain on , consider using one-liners with the standard call. RadioTest All the tests are clean, nicely coded and respect the principle of one assertion per test case. But 

All the fields should be . Since this object is instantiated only in collecting sequence and is placed in the same package, I'd suggest to reduce its visibility (and of its methods also) to package level, but this is a very minor issue. 

Args Validation It's also a good idea to validate method arguments, but I think that is not really appropriate here. The checks like 

The use of reflection is the drawback of the choice of s to wrap the data. If you have to keep the s, there might be a simplification, avoiding the brutal method invocation by name. It consists of the following: 1) Create an interface that provides access to the target method: 

Code Duplication Each of and methods contain too much duplicated code. In each of them, the second outer block can be simply cut out. An additional call of the method with inversed arguments will produce the same effect: 

Separate Model from Rendering The class contains at least two semantically distinct groups of fields: 

It introduces one more case of nested s, but is fully justified here: this is the end condition of the calls sequence, while adds more recursion. Naming. Names like or are awful and should be changed to more meaningful. 

Design Improvements Three nested loops and conditionals create too much complexity. Really, too much. The idea for improvement is: 1) Create a that associates a process name with its date. It will help us to know that the process having this name is associated with this date and that it needs to be associated with all the other known dates. 2) Iterate on the entries of the map. For each entry, create a collection of all unique dates and remove from it the date of the entry. Create a new for all those dates and add it to the target list. Here is how the whole solution might look like. is replaced with :