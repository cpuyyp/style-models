Counting is separate from the actual business of merge sort. So it is nicer to move it to a separate line. 

If you have a large number of such conditions, it may be just easier to use arrays for the same, (as in the above comment) 

Try to keep your methods pure without i/o, and collect the i/o in some portion that is dedicated to it. It helps later while you refactor the code. It is also nicer to not to rely on member variables too much, and preserve the referential transparency of functions where possible. 

Here are some comments. - If you are only @page as a way to communicate with , why not make it a parameter? 

Note - not as efficient as above, - O(n) (you could also assign that to a variable and reuse the array if the same pattern is expected elsewhere.) 

It is nicer to have a guarantee that a CreditCard will always contain a number rather than to check for nil in the getter method. 

In your implementation, what happens when the site inclusion has values but does not match, and site_exclusion is null? It seems to not match any of the conditions, which is not in sync with the requirements from my reading. Also what happens when the site inclusion has values but does not match, and site_exclusion has values that does not match? In your implementation, it seems like site exclusion takes precedence. But that does not seem to be the requirement. Perhaps I am reading either requirement wrongly or your implementation conditions wrongly? A rather terse implementation that is same as above is, 

For a first attempt, your effort is pretty reasonable. Here is another take on the same. An alternative way of collecting dot files We have a function that generates the filenames. 

I tried to slim your question down to see if it had any thing to do with only the case statement, and if condition. Here was my script 

Welcome to programming :) I did not understand your question first, then I realized that python might be your first language. In that case congratulations on picking a very nice language as your first language. Your question seems to ask for the list which is the shortest prefix of nums the sum of which is greater than the limit. Here, you might notice that it does not care about the intermediate values. Alls that the function asks is that the return value be greater than the limit. That is, this should be the output 

Well, Your code looks good, and your suspicion seems right. I would agree with you. My reasoning is that your objects should be modeled after the problem rather than the data base schema. Here I would say that the other methods are actually getters on particular animals. So it makes sense to move them to Animal class and rename the methods accordingly, i.e . I would also recommend to refactor all these methods so that the db connect, and processing are in a different method, 

And given all these, I prefer a little more functional way of processing The advantage is that you are restricting the IO to a very small portion. 

I do not know much about performance of each versions because GHC has various optimizations built in, and I have not kept up to date with them. The best option for checking that is to benchmark the code in question. Here are my updates, 

These sections seem to be repeating again and again. You could make them into a method like above, and call it instead of repeating them. 

I also think that the transformation of old name to new name should be a separate method. And why embed a string inside a string and then transform to a regular expression when you can directly transform that string to a regexp? 

It is often hard to decide which definitions go on the top level. A good rule of thumb is to see if the function being defined can be reused elsewhere. If they can't then they probably are better of as sub definitions under a where clause. 

So this captures your state machine fully. Adding future conditions is just as simple as adding to the above regular expression. The code would look like 

You could also do a general tryexec function that checks if dryrun and if so, just echos the commands and else execute them. This would be better than the current $DRY checks distributed in the code. 

Some changes to your code, First, your code didn't handle the case of empty list very well. This was why you need a complicated merge. (Also, the operation is not really a merge. A merge kind of means interleaving.) 

and use this in other methods to avoid repetition. I would also recommend moving the getTblHerd to another class - say Herd because it has an independent identity other than db_tables. Here is an example of using the above method 

Rather nice attempt :) A small advice first. Do not use Category as a type name. It may confuse haskell people who might mistake it for a completely different thing. 

Your code does not really care about mime, other than to skip it. Other than that, it cares that is seen only once. This seemed to be an overkill for bit fiddling. Removing that, 

Now, these comments are highly subjective. But given the length of your snippet, I suppose that is justified? Because it obviously works as given. 

No output in between. So for that goal, you need to remove the print statement in your code, and without the print, there is no need for the else. In languages like python, it is not required that there be an section to an if-else conditional. Hence you can omit it. We can also use enumerate to iterate on both index and the value at index. Using all these we have, 

I don't know which implementation you are using, so translate this to relevant language when needed. so is same as Note that is same as because the expression inside is matched zero or more times. You can also add in the at the beginning to the above expression, and make it repeat from 1 to 4. Here is a matching for your example, Knowing not much about your format, here is what I find odd. 

I am unsure if it was intended to be this way (allow user to input all answers before validating) otherwise, combine the below loop with above. 

Try to restrict your line width. First, it makes it easier to read your code, and second, it makes you on the lookout for refactoring opportunities. 

As @epsilon 'εⳆ2' halbe suggested below, use type signatures to define your functions first, this would help you avoid obvious errors. 

Avoid excessive comments. Especially if the comment only describes the algorithm. Instead, focus on why a function does what it does. A general thumb rule is to focus on the outside rather than the inside. That is, the comment should describe how the function fits into the larger scheme of things. Also avoid extra variables if possible. They only serve to clutter you code. 

So I used your question as an excuse to understand lenses. Here is the resulting code. See if you like it. (I don't claim it is good as I am still learning lenses) 

It may not matter a lot for this case, but usually when dealing with XSLT our rule of thumb has been, always to handle different cases with different stylesheets rather than one huge complex XSLT. 

Rather than a global count, I would suggest using either a parameter, or to return a tuple that keeps the count during each recursive call. This would also assure you thread safety. 

These few functions are tight. There is nothing more to be done with them I think. However, it should be noted that Entry and Directory have complementary functions everywhere. Perhaps it is profitable to abstract the common skeleton. 

From looking at your cdode, it seems that you have primarily two types of functions. Abstracting them away can help you to avoid duplication. 

Welcome to haskell, Your code is quite good for a beginner, I have only peripheral recommendations on your style. 

Welcome to java :), it is not hard to get into the OO mindset. But you might have to unlearn the procedural way of thinking. A few thoughts to help you along , (The Menu.java is missing. So I couldn't look at it) 

Since l and r are copied in merge_sort, we can modify them without heart burn. We first reverse the two lists O(n) so that we can use s.pop() from the correct end in O(1) (Thanks to @ofer.sheffer for pointing out the mistake). 

By printing a stack trace, and continuing, you indicate that you can recover from the current errors. Are you sure that you will be able to recover from other errors that may be added to mapper.writeValue in future? If the answer is yes, then perhaps. 

I am a beginner in Rust, and I am trying to write a program that compares common bits between two lists of bits. The program below does that (with the variable names indicating the domain of application). I would appreciate a code review by anyone who might point out idiomatic and concise ways of accomplishing the same. 

Where possible use function composition. From my experience, it makes it easier to understand the essence of the function. Also if there is a choice between composing functions and using parenthesis or $, go for (.), That would make refactoring easier later. Use currying in preference to explicit lambdas. 

It may be a good idea to write an abstract class as an interface, and then write the concrete class to conform to it. Another idea is to try to templatize Node so that the data can be any type. Also look at the stack class in STL You may also want top() and empty() methods on logic: If you are going to implement a stack using a linked list, you don't really need to keep a first and a last. Just keep the reference to the top element. On push, create a new node, set its next to the current top, and set it to top. On pop, set the top to the next of current top, and delete the node. Something along the lines of: (may contain bugs.) 

As you can see, has a different type than the expected . This is the reason you cant use there, and why we have to do all that above. Note that my statement is really same as 

I use template haskell to derive data lenses, which make your directory access a little more succinct. I also use ViewPatterns so that the dispatch on string prefixes are easier. 

On the prompt after loading your program, try to execute writeFile which was not accepting earlier, but this time, instead of that expression, replace it by ?check 

And any reason you preferred to do the invocation in Grab.runner rather than Grab.initialize? with the later, you have to do instead of But these are all minor. I wouldn't reject some one based on these. So I don't know. 

Always indicate success in main with rather than . We do this because we have to interact with the system outside where is considered a success any any other value is considered an error code. Also avoid extra in the function arguments. Especially, it is not required in statements. 

Since you have written it for practice (as indicated in your comment), and has been implemented in various platforms in rather similar manner, I assume that you want comment on the function behavior itself and not specifically whether it conforms to the POSIX function. I am aware that the second function strlcpy handles many of the criticisms below, but there is no indication in your question that you have considered these. My first problem with the is that it allows no indication of failure or indication of any behavior even though there is a possibility of a few different behaviors that the user may be interested in. 

My preference would be to make a tuple - i.e which is an immutable D.S and hence would be faster than a list. But it may not count for much. 

I think you should abstract both Add.java and Subtract.java into a parent class. (use the Game class itself) and make it define a protected method op() that takes two numbers, and does an operation on them. Override them in Add.java with addition and in Subtract.java with subtraction. This should allow the duplication to go away.