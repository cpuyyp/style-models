and marvel at the file size difference (i got 0.4MB (h264) vs 13MB (raw)). I believe the package can be used to interrogate the files although the raw one isn't very interesting. if you add the line to it'll be available from boot without the modprobe need. Also: My noir model in raw mode has some colour space issues - you should be able to mitigate these (at least in RGBA and BGRA modes) via between the format selection and the sink. 

Redis should serve you well. It will reside in memory but intermittedly writes back to disk for persistence. You can disable the persistence and set memory limits and the Python library from pip is pretty easy. Redis does a good job of serialising access too so multiple clients are no problem. And now I've remembered what it's called... If you wanted to run a smaller, lightweight Key/Value DB LevelDB might be worth a go. You need to wrap your own process around it to manage reading and writing from multiple sources / remotely but it has some Google pedigree and should be pretty performant. You may have to compile it yourself though. 

They set the authentication agent to be the keyboard, powers up the device and starts it scanning for people to talk to - with your phone as discoverable you should see it appear in the console, then connect to it via 

On the assumption you are using Raspbian Jessie or Stretch (although this applies to Arch ARM) creating a systemd unit is probably what you are after. This acts like a service and lets you kick off a process in the background that can churn away doing things without needing you to be there. You'll need to configure the unit file to your own script but under the assumption its a python script run from and you want it to run from boot then the following should get you started. 

This was a bad SD card all along. It was acting exactly like it was writing data, same write speeds, reported it had written all data but whatever occured during the initial IoT imaging process had done bad things to the card and it was stuck in a read-only state. Imaged the new card from the documented way if installing via Win10. 

The pexpect library has thrown the error which is not caught by the code in . So you can catch it yourself instead - wrap your call to , just like the linked gist does for Bluetooth Errors. import the pexpect exceptions 

Enable Bluetooth on startup, for some reason this was a bit sketchy on my Pi and after reboots it took a while to bring itself back up (2 minutes being a while). I didn't investigate, there was nothing in the log so maybe its set for a delay. Anyway, make sure its enabled via 

Assuming you are sending a control saying how many bytes you are about to send, something like in your connected event handler this should get you going. 

which does the job. Stop laughing. Part 2 If you don't know how many bytes you'll be sent you can try the following using the regular streams API. There are a host of readers and buffers and things but since at this point you are mostly stuck at reading chunks then you should be able to get by with this sort of approach. 

You can adjust that const to a suitable value, say if you know you usually get at least 128 bytes, then up it for efficiency. The caller needs to close their end to signal the end of the stream or this will just sit waiting for a while. You can junk the writer bit at the end if you don't need to return anything. The Python test client code for this was 

You'll have to enter the code from your phone into the console, or, ok the dialog (if using the GUI). You should now be paired - this step is woolly, I don't know how iPhones do things on Bluetooth so you might have to play until its paired. There are other Bluetooth options for pairing but that code one seems fair enough. You can always go back and redo that step with a more fitting implementation later on. Exit from bluetoothd by typing Next its fighting with pulse audio...Unmute it 

Audio over Bluetooth! My setup was a Pi2 running Raspbian stretch with Pixel. My Super-Sweet-Pro-Audio rig was a pair of old desktop stereo speakers via a 3.5mm jack, this looks like it mirrors your setup. I'm using a 2.1 Bluetooth USB adapter but anything should do, the onboard module on the Pi3 should work nicely. I also have docker installed, that's the only other thing I've installed, I doubt it brings anything to this particular party though. Get the system up-to-date. 

I don't think you need the and as the first part of either threads loop as you are already setting this at the start. You could also move the two lines to before you declare the functions as this should only need to be done once too. You might find that speeds up the execution of both threads and removes the delay. 

When you call python will wait until that process has completed before continuing. You may want to consider using something that simply spawns a subprocess and continues like 

If you mean the line, yes thats allowed. You do the same thing to iterate over dictionaries via the style. If you mean the Yes, sub loops using in-scope variables are allowed too. 

this should let the whole thing spin along working in the background waiting for whatever that GPIO event is and when anyone asks for the coinvalue it'll be available. Bear in mind this introduces threading which is hard. You'll also need to adjust the import of the module 

If this Pi is accessible from the Open Internet you'll get these. They are likely just random, try-it-on attacks. Check out Fail-2-ban, Linode have a guide, use the Debian section for a simple preventative measure. If you want to be more secure, disable SSH passwords and use Public key Auth instead. This will prevent people just guessing your password, again linode and digital ocean offer fair guides for this but just searching should give you plenty of guidance on hardening SSH. If you are not on the open Internet, you need to investigate how someone is getting past your Gateway / Router and directly talking to the Pi. Check your port forwarding rules if so to see if someone can make contact. 

Live video shouldn't be a problem using Gstreamer and RTSP. All that is built into GST and there are quite a few tutorials out there. Wired over short ( <100 meters ) distance isn't a problem as Dark Vader mentioned - a decent length of Cat6a will handle this. Over longer distances, or if you absolutely have to use fibre, you can look into media converters (something like this - as an example). These typically take ethernet input and provider multi-mode or single-mode fibre output. There are plenty of fast ethernet ones available that make claims of 2km to 100km (thats hundred!). If you only ever need this for a Pi you wouldn't need gigabit since the Pi cannot provide that speed anyway. Its probably best to test the RTSP stuff over ethernet first then ramp up the distances if that provides a good enough experience before commiting to hardware solutions to the distance. 

Your code does work with FileZilla in principal, I've just run it up on a Windows VM with FileZilla Server and a Pi with Python3. You'll need some configuring though. needs to be the IP address of the FTP server The and need to be the ones configured in FileZilla settings. These are not the same ones as the 'admin interface' ones. Go to in the menu bar and add yourself a user, password and set a directory to act as their home . The home directory is where you'll end up when you connect. You may want to grant write permissions to this too. in leave port 21 in place and go to the passive mode settings and configure a port range. I used 50000->50100 since I don't have anything there. You'll also need to configure the Windows firewall to accept traffic on port 21 and the same range of other ports for Passive mode. the variable needs to be based on the you set for the user. So say you set the home to and you wanted the files in you set to (note the slashes don't mix to well between Linux and Windows).