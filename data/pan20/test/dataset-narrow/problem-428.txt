For the code itself, I did not really check so I will leave other to do it ;) PS : I am open to suggestion, I tried to stay simple and explicit but I am still a beginner in Code Review ;) 

This means that all the calculating codes are in this listener, this is better than to have to scroll in a lot of lines just reading the signature of the methods ;) This is of course just an esthetic choice. This doesn't improve performance. The code will look like 

My review will mainly be readable code When you have lots of button, I am used to regroup the code in a single listener. This have the advantage to regroup the code in one place (but the inconvenient to have the code in one place ;) ). In general, I use the activity or the Fragment to implements the listener and manager itself the buttons. In your case, you use the same logic for a lot of buttons (numerics to set the value). Why not use a logic that will works for all. Let's start step by step First step, I would use an array of Resource ID to recover the buttons to remove this big block of Buttons attribution. 

It is the best to prevent any mistake, of course if you are going to call n times a CRUD method, this will cost some time so you could create the CRUD to take a varargs parameter `(Book... books) to be able to pass one or many values to a method. Then this is use like an Array so you loop on each to to the job (mainly for insert, update and delete). Using a PreparedStatement for these will reduce the compile time of the query. 

you can then just print that list to print the (filtered) row. Note that you could also do this filtering yourself, using a list comprehension; however, has the twin advantages of being common (hence readable) and carefully optimized (hence fast). 

(for erate character), but that's open to debate. Redundant s The statements in don't hurt, but they are dead code, so they take up mental space. I would be inclined to drop them---and to align the from the default case with the others, to emphasise that all of the cases return directly. No from main I know that the C standard allows it, but it will still always look wrong to me. Depending on the context for this program, other people might look at the source and have mental space occupied by the sense that the lack of a from looks wrong. But that is essentially entirely a matter of opinion, and arguably I'm the one that's wrong there. As I said though, overall it's really rather pleasant. 

Your first pair of loops builds the list . The length of this list is \$O(n^2)\$ in the length of the input. In your second set of loops for each element in you all of to find those elements which match it. The runtime of this filter process is linear in the length of , and hence quadratic in the length of the input. You perform this quadratic process once for each member of the input list; the search loop is therefore cubic in the length of the input. Your algorithm as a whole is therefore \$O(n^3)\$ in the length of the input. To make the algorithm as a whole quadratic, you need to make the second (match) stage linear in the length of . Natural approaches would include: 

Then you regroup the code in the one method and manage the code to execute by check the ID of the button (the view received). 

Then, instead of using one listener per button, you use one listener (I use the Activity in this case but you could create a class). This means you don't need to store the Button in a variable, you set the listener directly like this : 

Since you didn't create a DAO class for the books to store these constants and the CRUD methods to manage the books. This is not so bad but the DAO is the best choice. If you never use DAO, you will find some guide everywhere. 

If you close it correctly, you are the only one to have the access. So unless you are doint multithreading, this should not crash. 

I think you will end up with a locked database if you don't close it correctly. I had this error not so long ago because of this I think. This is probably an open door to memory leak too. 

Using the predicates in your case could be expensive for big list since you use 3 meaning 3 complete iteration on the list. Here is a small update of you code (I can't use the Java 8 API since I only have the Java 6 at the office ...) to do the same check but without predicate (or if else) 

PS : I could update the code to match your List but to prevent any typo, I prefer to show you the logic I used with the API I can use. 

Both are correct but cost memory. I usually add the in the instance if I know that I will need it later (to recover more data for a specific instance). 

(I'll mention how to generate this simply in a moment). You would then want to modify this to also pass through the row header, so you have the selector: 

Producing sample output on STDOUT, according to a command-line "count" parameter (this is not nice code, it's just here for reproducibility). Obviously, the performance of the filtering algorithm will depend not only on the number of sets, but also on the number of possible different names from which the sets are drawn, and the size of the sets. Smaller numbers of names make some approaches pathological; larger sets create more work for most approaches. Original program Your original program did not run as-is---it seemed to rely on a few parameters provided elsewhere, and a particular directory structure. So I modified it a little to accept a filename as its first argument, and output to STDOUT for easy testing. I also moved around the manipulation of the variable, as that seemed to either have the wrong indentation or be in the wrong place. 

Data storage If you change your typedef to be anything other than , your linked list implementation has to be copied and modified to handle multiple types (so it's less generic); on the other hand, you get better type safety. The tradeoff is probably in how you're going to use it. One thought: I would suggest looking at how the linux kernel does linked lists: they have a struct, which is then included inside the data types that you want to put into a list. So it looks something like (e.g., if you had a linked list of strings): 

is a little easy to misread. I'm always very tempted to use a loop for this kind of thing (also various kinds of pointer manipulation of a similar form) but it tends to end up being rather awkward. 

All the code samples below are functional and in both cases my sequencer is behaving as intended when populated with some simple test tasks. I recognize that I'm being a bit loose with the permissions - a lot of things are public that probably shouldn't be but it makes it easier to test and debug in my current engine and I'll buckle down on that a little later. I'm a self-taught programmer who hasn't worked with many large or experienced teams yet and I'm still quite new to C# as a language, so I'm more than happy to receive any critiques or advice on how I can generally improve! First Attempt: This was my first attempt at handling real time tasks (for example, automated character movement over time). If a task can be performed with a single frame/update/tick it will either return or , the tree will continue being traversed, and as many nodes will be ticked as possible. However, whenever a task node returns we need to store that task somehow, back out of the tree traversal, and resume from node next time. Because each composite task calls on its sub-tasks, it seems like the state of the tree at any given time is tied to the function call stack. I can't just store the running tasks in a list outside of my behavior tree, because despite being easy to tick them again next frame I would be losing the bigger picture of their place in the tree and wouldn't know where to go next. I 'solved' this by creating a reference to a task in each of my composites. When one of a composite's sub-tasks returns a reference to that task is stored in then the composite also returns . Next time the composite is ticked it checks if a task has been saved. If so, the is reference compared to the current iteration and the loop will jump ahead until we find a match. This is the behavior tree class which only really serves to encapsulate everything: 

Then, you have a bunch of linked-list functions which operate on pointers, and use an macro to get back from the to the enclosing structure. Not to say that this is better, but it's arguably a more type-safe way to get 'generic' linked lists in C. Both approaches are valid, though (and yours is more 'classic'). Const correctness I would generally say that things should be whenever possible, because it makes programs easier to reason about. I generally encounter the opposite problem to the one you're describing, though: something is conceptually const, but for incidental implementation reasons it needs to be mutable. DLL naming Well, 'dll' isn't the clearest name, because of the conceptual collision with Windows libraries. It probably isn't a big deal unless you're writing software on Windows and using dlls. I would be tempted to just call this module "list", or "ll", though. The only real constraint on the include guard macro is that it not collide with any other names in your program. I suspect that is probably fine. (Obviously, if you have some style guide or standard, that probably specifies a convention). Implementation This is pretty nice code overall. If I were feeling picky: 

Static methods on RPNStack It is odd to write a class like with all static methods and fields; effectively, you have a single global stack, for no particularly good reason. The obvious thing to do would be to make all of those methods and fields instance methods/fields, and then create an instance of within . Output It isn't clear to me why would not be working for you where does; however, you aren't closing or flushing the file, and it may be the case that some subtle difference is causing the file to be flushed in one case and not in the other. I would expect that if you close your at the end of your program, it will work fine. Recognising symbols The obvious and lightweight way to recognise a small set of symbols like this would be to use a statement. If you have Java 7+ (which you really should) you can just use strings directly as labels; otherwise, you'd have to switch on characters (which would still work for your simple language). For a more complex language, you could consider a map from symbols to actions. Error There are kinds of errors which won't be caught by your . But I don't think you need to worry too much about those. The only bit of error handling I would consider adding is that it's possible for the user to enter an expression which causes a divide by zero error. As your program stands, this will throw an and terminate the program. I would suggest either catching the and recovering with an error message, or validating the operands you're passing to the division operator. Minor nitpicking