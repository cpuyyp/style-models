I don't know what a is, but since it seems to be a single item, I don't feel is a good name for it. I'm also not sure why you'd need to add the namespace to the class explicitly: . That's usually a red flag for me. 

How often do you call this method? Because as one comment suggested, you might be better off loading all models in a dictionary in one go instead of making hundreds of db calls. 

and are bad names. I guess the "1" and "2" correspond to "if input for operation chosen by user is only one file" and "for operations which require two input files", but that doesn't convey this to me at all. Name the first one and the other for instance. Same for and : I'd guess that each file is a specific one, e.g. one contains the mentioned elsewhere. So why not reflect that in their names? Even your UI doesn't seem to provide even the slightest bit of information -- until you click the button to open the file dialog. 

Avoid mixing German and English names. It adds a level of complexity to your code, even if you're fluent enough in both. 

Continuing the series of Code Explorer posts, here is the collection of view models for the tree nodes: 

You are defining whether a build is a "debug" or "release" based on whether the code is optimized. That has nothing to do with Visual Studio's definition (and therefore the standard definition) of what a "debug" or "release" build is. That and the output paths are the only changes I can think of off-hand between the default "debug" and "release" candidates. However, you could define a "debug" build as one compiled against C# 7.2 and a "release" build as one compiled against C# 6 and leave optimization on or off in both for whatever reason. I wouldn't use the terminology "debug" vs. "release" here; I'd just check whether debug symbols were enabled when I determined whether to kick off the debugger. If you change what I suggest above, I'd recommend renaming to just and assigning it whether the code is optimized or not. I can compile as None, Full, Pdb-Only, Portable, or Embedded with JIT-optimization enabled anyway. 

I'm not sure what is going to, or should, happen if neither the nor the statements execute. Should there be an statement in there? 

There is no point in keeping your connections alive as long as you do. Typically db connections should be kept as short as possible. 

should be defined as a , and that variable should be used in instead of ; that way you can also avoid . 

What if the order changes? Also, this makes it hard to figure out which parameter is connected to which field. 

The stack trace should tell you where the exception happened, but you throw it away to create a far simpler error message. 

Same for your method: a lot of repeated and obviously copy-pasted code. Instead have a method where each of the buttons is either enabled or disabled, based on a boolean you pass as the parameter, that way you can also reduce the code of . Also, instead of setting each button, keep a collection of the buttons and loop though them. 

I don't think is a good class name, for one it is a plural. It can also be simplified by using Auto-Implemented Properties, e.g. 

The moment you start copy-pasting code, you need to realize you're doing something wrong, and that such code should be moved to a method of its own. 

I hope this makes sense; I know it can appear somewhat convoluted, but it really will make your code cleaner and easier to maintain. Basically, all your logic and display data goes in the VM, and the view is for pure presentation. Because the code-behind is part of the view, it should also only be involved in presentation details that cannot be expressed in the XAML, like fancy drag/drop details. Feel free to ping me if you have any questions. 

If you do this, you may want to make your variables global so you don't have to pass them to the method - both methods will just be able to access them. However, as a general rule, try to keep the scope of variables as tight as possible. Also, instead of having different variables for the different tax values, you could create an array of tax brackets with all the values: 

This way, you can check whether the phrase is a pangram without always printing to the screen, which is good for re-using the code later; you can then write another method to print the strings in the phrase and the alphabet. Additionally, I would recommend printing the letters in alphabetically so it is easy to see which letter is not in , which will also make it easier for any potential debugging you have to do. Edit: Thanks to matsjoyce in the comments, you can simplify it even further to this: 

But if I were you I'd rethink this entire logic. A is ugly and unwieldy; IMHO the nested dictionary should be a custom class. I also feel this code is odd and possible buggy: data is retrieved for an yet this parameter is completely absent in . The that is passed is assumed to be present as a key in , same for the . 

Using a to pass parameters is just throwing away so much functionality, especially when you seem to be passing dates: . Why not use ? 

You really need to follow Microsoft's naming conventions. What is even the point of prefixing your class names with "cs"? All you get is unreadable names, especially when you then name your variables "my(ClassName)", e.g. . Using the "my" prefix is something you should avoid as well. Same with properties etc.: do not implement some version of an Hungarian notation. 

There is also the presence of several magic strings, which reappear elsewhere in your code (the ). This indicates to me that these values should be s in a separate class, so that should there ever be a need to change them you only need to do this in one place. I would even consider something like this: 

I really like how you use the HTML5 element instead of using the old style When people write CSS, they often format it slightly different, like this: 

Your description of the algorithm used describes the famous backtracking algorithm. This algorithm, by definition, is guaranteed to find a solution, but is terribly slow because it tries all permutations until a solution is found. In order to speed your algorithm up, you should try to solve the grid the way a human would. The first step is to develop a table of legal values for each cell, rather than just trying any value from the allowed range. This alone will significantly increase the speed of the backtracking solution. The second step is looking at all possible values in each row, column, and subgrid. If a cell can only have one value, based on the limiting values in the row/column/subgrid, then you have a positive value for that cell, which can be used to reduce the number of allowed values in other cells. You also have a positive value if that cell is the only free cell in one of these subsets to support a specific value. The third step is slightly more complicated: If any two cells in a row/column/subgrid each can have only two identical values (both cells can have either 2 or 4, for example), then one of those cells will be 2 and the other 4, and you can remove these potential values from all other cells in the subgroup you are examining. The same applies to any N values in N cells ([2, 5], [3, 5], and ([2, 3] or [2, 3, 5]), for example, guarantee that this set of three values will exist in those three cells, and no other cells in the subgroup will have these values). The fourth step is based on the same principle as the previous point, but is slightly harder to identify. These cells are when any N cells have a block N values that no cells in the subgroup have. For example, if a subgrid only has two cells that allow 2 and 4, but in the current state, placing a 6 or an 8 in one of the cells would not look like a mistake (e.g. the "penciled" values for the cells are [2, 4, 6, 8] and [2, 4, 8], but no other cell in the row/column/subgrid has the values [2, 4]). Identifying these patterns and limiting these cells to supporting [2, 4] can help you limit other cells' potential values, and reduce the numbers checked in your backtracking solution significantly. Most advanced Sudokus can be solved with just these rules, and if you encounter a legal Sudoku that cannot be solved with these rules, your program will still be significantly faster because it will limit the solution to checking only potential solutions knowing the current state. 

Your entire method is 100 lines long and contains two blocks. Split this up into smaller methods; can be a variable at the class level so you don't need to pass it around. 

But the above are merely minor flaws. That they're omni-present is however a warning sign (as well as the obviously copy-pasted parts), and I'm afraid that I don't see any value in this code. I fear you're relying on very outdated documentation; instead look into ORMs like Entity Framework and how those are used. 

Your code is full of . This means there's a strong coupling between your "UI" (a console) and your actual code. Instead consider using a logging system like Serilog to handle all that. 

... can be solved far more elegantly by implementing MVVM and using commands, both of which you should be doing anyway. I'd write an example using your code, but you've not given us much to work with (and I don't have the time right now anyway). Also, is a really bad name for a method. 

is a bad name, is even worse. I have no idea what this represents. I also have to object to , especially when . 

If the user were to enter "r" instead of an value, for instance, it would crash. You can fix this by adding this: 

This is an analyzer and code fix for VSDiagnostics that detects when a doc comment on a method does not have all parameters listed. When the user tells it to provide the fix, it adds a line for all missing parameter nodes. Here is the analyzer: 

That first is not closing an element, it should probably be a . The first needs to be above the tag, and the second is invalid. I changed it this: 

Because you usually use braces, I would guess those are from accepting R# suggestions. You can turn braces on in the settings by going to the Options and choosing Code Editing -> C# -> Formatting Style -> Braces Layout and changing the settings in the Force Braces group. 

I recently wrote a code fix to handle many of the C# and VB.NET compiler diagnostics that was merged into Roslyn. Because it handles both, I implemented it as an abstract class with only the sections that are specific to the different languages in the language-specific implementations to eliminate code duplication. If you are interested, you can find my full test suites here: C# and VB.NET. The abstract class controls most of the implementation. Before you tell me to use for my code action implementation, Roslyn has an internal diagnostic telling me not to use that. 

In addition to @user1118321's review, I would also suggest to rethink your conditions. You seem to tend to do "negative" checks, you're even combining two in this case: . I'd much rather have this logic: . To me this second version is easier to understand: if the is null or its is null or empty, then execute this simple bit of code that doesn't need the , otherwise execute this more complicated bit of code that requires the . This is IMHO even more important when using ternary operators. Parsing requires me to think a lot more than if you'd written . 

There's always going to be a switch, but this way at least you're not repeating too much logic. You might even want to put those four parameters in a class and pass that class instead. 

And please, do not keep your connection open for those last three: make sure each method manages its own db connection and trust the framework to allocate resources effectively. 

First of all: how can be null or empty, considering you assign "1" as its value on the previous lines if the value of isn't "1"? Secondly: is some kind of boolean? And also: why are both and used in the rest of the code? See, that's what bad naming does: I cannot figure out what and are supposed to be, even within context. 

Other than this, I think it looks fine, other than the occasional empty comment. Your HTML validates just fine at the HTML validator. 

You are triggering logic in the constructor? Never, ever do class logic in the constructor! The constructor is for creating an object only. In this class, you shouldn't even have a constructor. 

FSharpExtensions.fs This module contains many functions for internal use only. Most of these functions are designed to be based on a certain type to make calling them easier; perhaps they should be included in the type rather than being extensions like this? 

My naming is off. I should name my method parameters using camelCase, so will become , etc. This will help the readability of the code because my brain will automatically know what group a name is in. Private fields should be named with _camelCase, so will become . I can make my Mutexes , which will prevent me from assigning them from any instance except the constructor or place of declaration. This will guarantee that they will never be reassigned to incorrect values by accident. I should use instead of the type name when declaring variables. It will reduce the amount of text to read, and I can tell what type is being assigned by the value assigned to the variable. This is not always possible, however, such as if I created a variable and did not assigned it immediately or assigned it with . is an unused variable that should be removed. The alternative would be to use it in the following line, rather than the direct value: 

There is no need for such abbreviations. Properly name your variables, and you don't need such comments. Moreover, proper names would make your code easier to follow. Sure, and aren't that hard to remember, but ? Or even worse, ? 

It's obvious doesn't contain the name, but instead an abbreviation, so the property is named incorrectly. Which you then "fix" by doing this: . And this sort is just... Why not have a numeric field -- e.g. -- and sort on that? 

Though I have to say there's still too much repetition there and thus room for error, but I fear that's inevitable when you want to stick to s. I would also consider moving repeated logic like this: and . There's a lot of repetition there, which suggests it could be moved to a method, something like this: 

But I fear your refactoring might need to widen its scope, because even if you apply this you still have an ugly or . 

Why do you have the class? Why not make life much simpler for yourself by making a , and having classes like implement ? You can then query your assembly file for classes where is implemented; that way you don't even need to fill "by hand":