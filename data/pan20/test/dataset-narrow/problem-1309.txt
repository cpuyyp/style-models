Most modeling packages allow you to add data to objects (color, texture, etc) so you can use these properties to your own properties. All of the major modeling packages also support you adding arbitrary data to objects so you wouldn't have to stretch yourself trying to finding ways to encode data on your objects. You also get the benefit of editing right on top of your level instead of making little adjustments to marker positions until they are in the right spot. Other than that, there are a number of free or cheap level editors that output to a neutral scene file, like $URL$ Exploiting your modeling software is probably the easiest way other than building your own editor however as you don't have to add another set of tools and file formats to your pipeline. 

I'd say match it to the way you want your game to be perceived. If you want it to come off as a casual game, name them something like casual, normal, tough, hard, etc. If you want the game to come across tougher, name it like gears of war--casual, normal, insane, etc. It's really up to you. Keep in mind that how you name your difficulties will also somewhat affect how the player feels after finishing them. It's much more rewarding to complete "insane" than "hard". 

Unfortunately it's really hard to stop people from cheating, which is why software like Punkbuster was created to try to catch some of them. For an MMO, the biggest thing you can do is to just not trust anything the client sends you. The client should not be able to tell you where the player has moved to, how much damage they have dealt to whom, etc. Instead, you should send control input to the server, validate that it is practical (pressing the "attack" button 1000 times in 1 second, for example, is not valid), then update the simulation on the server. You would then send the relevant parts of the new state of the game back to the client. While you are validating user input, it is also possible to look for trends in their input. If you don't allow macros, you could catch them here by noticing that the user has clicked the same button at the exact same pixel coordinates in perfect 1 second intervals for the last 30 minutes. The client itself is the main place people can cheat, so programs like Punkbuster can cut down on wallhacks, aimbots, etc. Other than that, not trusting the client and validating anything sent to you by the client will help cut down on cheating. 

This really depends on the complexity of your background as well the technology being used. For example, when using DirectX or OpenGL, all you have to do is utilizing texture wrapping: 

Nickson104 already wrote a pretty nice summary in his comment. I've been playing the game since early beta and I prefer the small AHs, so this might be a bit subjective, but overall the most important points have been mentioned already: 

You should use a different approach. JavaScript supports arrays and objects, so why not using one per entry, saving you all the splitting and also making the actual text easier to edit/read? If you want, you can have a look at some prototype I've made during a few hours for #1gam. The source is free to be used under GPLv3 (I'm perfectly fine if you don't stick to the GPL, if you're just using it for inspiration. But let me know once your game is finished.). Just don't expect awesome writing or anything like that. ;) To give a short explanation on how the code works, ignoring the CSS animation things and stuff like that: 

Things like this aren't just about providing a checksum or serial number as part of the program or image. That would be too easy to trick. In such situations one basic paradigm would always be true and important: "don't trust the image" (at all). It's more likely the checksum is created on startup (doesn't have to include the whole image data to speed up loading times), and then compared to an internal whitelist. This way it's way harder (or next to impossible) to trick the console to think the game would be something else. Signatures work in a similar way, it's just so that the "whitelist" is essentially provided as part of the image as well. Why can't they just create a matching checksum? That's easy to answer: Because it is a checksum. A checksum is supposed to change, even if there are only slight changes to the source. Of course, there will be collisions (since the checksum has a lower entropy than the actual data), but it's still most likely too hard or almost impossible to achieve this. You can't change all the code just to match the checksum, because you'll most likely have to change more than one or two arbitrary or unused values. Why can't they make a perfect copy of an existing game? That's the better question. I'm not 100% sure, but I'd assume that it might not be that easy to get the raw image and the actual data read already depends on the actual hardware accessing the data. To provide a similar example: It's not that easy to read or write a CD or DVD "as-is" simply because of the firmware doing its own processing/error correction as well. In a similar way, you can't tell a burner to exactly write the sequence to the disc. It will do so, the data read will still be the same as well, but the actual/physical data will have a different pattern/representation (e.g. due to error correction/redundancy stuff). 

It's not necessarily a common program's output at all. It could just be an arbitrary extension chosen by the developer for files that hold data about sprites. You can try opening the file in notepad to see its contents or as suggested above check the first four bytes to see if it is a normal file format saved under a different extensions. 

So, by providing an adequate abstraction between input, game logic, etc and graphics, you will have solved the problem. This is basically the point of the MVC model, especially as it pertains to desktop and web applications: there can be multiple clients accessing and manipulating the same data (a web interface, mobile client, and desktop client for email, for example). 

We can stop reinventing the wheel by... ceasing to reinvent the wheel. Use external libraries, game engines, etc. I get the sense that people do reinvent the wheel to: 

Well as far as C++, C#, and C# with XNA are concerned, Visual Studio has excellent debugging tools--pause the application in real time at any point in the code, see the values assigned to variables at any time, step through function calls, analyze the call stack, and more. In addition, tools like Pix and the CLR Profiler make development with DirectX (Pix) and CLR based languages (CLR Profiler) great. In addition, one especially useful part of working with games is that we have this giant area to write debug text, graphics, etc to. Realtime graphs of memory usage, number of objects/vertices drawn, framerate, etc are common things to draw to the screen. 

ROAM stands for "Real-time Optimally Adapting Meshes." It is a level of detail algorithm for rendering large terrains. It's somewhat complicated so I'll link to some more in depth explanations: Here is the paper: $URL$ The following is a slightly less academic explanation: $URL$ 

Generally I've used a separate partition tree for static and dynamic objects, or just disregarded it altogether for dynamic objects. This provides the benefits of both worlds: 

I'm sure there are more ways I didn't even think of as well. As for sharing, that's really up to your team and you but as this is an open source project and not something built in a corporate environment it would presumably be split evenly amongst you. 

I've been looking at micropather as well. If you are happy with the results, stick with it. If not... Since you have control over the Graph, you can add arbitrary nodes. Thus, rather than going through the calculation to add distance from sector center to portal center, just stick a node in the middle of your sectors, connected to each portal for that sector. Micropather will take the distance from the portal to the middle of the sector in it's path finding algorithm. You could also go crazy and add edges between the portals bounding a sector. (If I understand correctly, a sector is like a room, and portals are the doors out of the rooms). Then the path finding would be able to "cut corners" if it didn't need to go to the center of the room. Should be easy to try these out. For example, if your sectors are square rooms with doors on all four sides, your graph might look like this: 

I'm curious how the sphere effects were done in Osmos from Hemisphere Games. Any ideas how the resolution independent zoom in was achieved? Edit, more specifics on questions: 

I found my first edition (June 1993) copy of the red book (covering OpenGL 1.0) was sufficient and roughly equivalent to GLES 1 on the iPhone. GLSL and OpenGL 3+ are very different (no more fixed pipelines), and I wouldn't bother with the red book unless you need to support GLES 1. 

How do you render the spheres so they look good at full zoom out, and full zoom in? How would one make the nice particle effects in 100's of spheres all at once? How to construct your scene/spheres so the big spheres look round even at full zoom? 

Here is a blog post from Danc @ Lost Garden trying to hook up artists with developers. Karnak games has a great "how-to" on hiring game artists. 

Where N are nodes/sectors, and the lines represent edges. There is no explicit node for portals. If you include portals/doors in the graph you get for one room (with P for portal): 

I would highly recommend you read Ray Wenderlich's excellent book on Cocos2d, "Learning Cocos2D". I've just finished reading it cover to cover, completely worth the price. In particular, Rod and Ray introduce you to game concepts in a very gentle way through incremental level design. They cover menus, level changes, sprites, sprite sheets, behaviors, AI, physics, etc. In particular, the introduction to Box2D makes the book worthwhile, IMHO. You can get a flavor of the book by reading some of the excellent tutorials and articles on Ray's site: $URL$ I'm a more experienced iOS developer, so reading the code samples was constructive (I didn't compile any of the example code, nor the final game "Space Viking"). I did enjoy that all the game code and assets are available for download, so you can build it yourself along the way.