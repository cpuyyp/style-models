I recommend Natural Earth Data as a source of public domain cultural and physical GIS data with global coverage. Vector data sets include landmasses, countries, populated places etc, while raster base layers are available with optional details like land elevation, climate, waterways and submarine elevation. This data is intended for use with GIS software, but can be manipulated and then exported as something more "game friendly" (svg, png etc.) using tools like QGIS or indiemapper with no financial outlay. The vector layers come with detailed attribute tables that might also be useful for simulations such as names, populations and GDP. Here are a couple of quick mock-up produced with this data: 

The usual approach to this scenario is to build a collection and then shuffle the contents, much like a deck of playing cards. The Fisher-Yates shuffle is a simple and effective algorithm that suits our purpose well. Here is a minimal implementation: 

As an aside if your score is rising unpredictably it would require that your and flags are being reset. 

For data that is created at design time you can use the TextAsset resource type. Note that despite its name it can be used for arbitrary binary data if preferred. To persist data that is created at run time PlayerPrefs provides a key-value store. This will be implemented in a platform appropriate manner and performance may vary. If storing a large number of items at once is causing delays it may be improved by consolidating the data into a single sting. To simplify parsing of this data many people use SimpleJSON. 

Now that we have stopped the physics engine from managing the rotation we can control it ourselves by manipulating either or . 

I agree with the other answer, to use circles as the simplest approach, although it only works with roughly square/circular objects. One alternative though would be to actually draw the objects and check for overlap, this gives pixel-perfect collision detection. Give all "shootable" objects a unique id and have a buffer representing the screen. Render into the screen buffer the id of the object for the position it is in. I.e. if the Tank is 1 write a 1 in each location it occupies. If an enemy is 3 write a 3 there. Once your scene is drawn then as your bullet moves check the stored value of the spaces it occupies (and spaces it moves through if it is moving fast enough that tunnelling is an issue). The number found is the id of the object you hit, 0 means continue. (Don't write bullets to that buffer unless you want them to hit each other). 

Always interpolate when you can. When you don't have enough information to interpolate then you need to extrapolate. It really is that simple, don't over-think it :) To explain a bit more: In general interpolation is better because interpolation is always right. To extrapolate you have to guess. Then you have to deal with what happens when you guess wrong, which leads to rubber banding or popping and all sorts of systems to deal with handling all of that and disguising it. What happens if you extrapolated a bat position and showed it going to the right place and bouncing the ball, then realize afterwards that you were wrong and it didn't bounce the ball? There is no good way to handle that scenario. 

Applying the decoration to a script will ensure that the GameObject has the specified component. If the component is missing: 

An additional consideration might be to identify any heavy weight tasks that are taking too long to execute and splitting them up over a more than one frame. Frequently coroutines can be used for this purpose. 

Collision events will only be detected under specific circumstances. Each collider can be considered to have these relevant properties: 

If familiar with OpenGL Immediate Mode this approach is pretty straight forward, but if you later decide that you would like to texture your primitives I would recommend using a MeshRenderer with a custom mesh. Morten Nobel has published a tutorial on using this approach with 3D meshes his blog. The same approach can be used create a plane of arbitrary shape. 

should default to reporting its position relative to the game window, but can be configured by assigning the appropriate window handle to . The documentation is here. 

I'm having trouble visualizing the problem you are describing, however I can see two issues with the implementation posted. The first issue is that you are using the updated rotation as the first parameter of the lerp function. Doing this will produce a movement that will start off quickly but then slow down towards the end. This effect is great for camera movement but would look a little off for rotating a card. Another issue is that you are using (elapsed time) as the third parameter for lerp, this will produce varying (and possibly unexpected) results for those occasions where is not equal to 1. The solution is to use as this will smoothly travel from 0 to nearly 1. At the end of the loop you can then force the final rotation to ensure a predictable final state. A smooth and complete lerp requires stable and parameters and a parameter that ranges between 0 and 1. Please try this version with these changes applied: 

Queue buckets are not deprecated and are absolutely intended to solve this very problem. Objects are rendered in the scene in bucket order, i.e. Opaque is rendered then later on Transparent - there are other buckets too. Within the bucket they are sorted based on a geometry comparator. For the opaque bucket this draws near to far, for the transparent bucket it draws far to near. This is to reduce overdraw on opaque objects (so after you draw a large object in the foreground you don't also both drawing the pixels for all the small objects behind it). For transparent objects though you must draw the furthest away ones first so they appear behind the ones nearby and to allow transparent objects to be drawn as well as possible. Unfortunately it's impossible to sort objects correctly in all cases (for example overlapping objects) but the engine will try. You also have alpha discard etc available for transparent objects to prevent them writing to the depth buffer in transparent areas to help improve this. So putting the object in the transparent bucket means that all the opaque objects are drawn first. Only afterwards is your bullet hole drawn, so this then gives the result you are looking for. Before the objects were all in the opaque bucket so they were being sorted near->far. The bullet hole was being drawn first and writing to the depth buffer. The man was then being drawn, but because the depth buffer thought the bullet hole had already drawn over that area nothing was drawn there. I'm not sure why the green man was still being drawn as I'd expect him to be drawn last, maybe the extents of the model just pushed in front of the bullet hole or something though. 

Once you have perform a mathematically correct conversion to a vector without any need for further manipulation. This example assumes newAngle is in the correct units for the trigonometric functions: 

A can be used to do a quick search for any colliders below the player. can then be examined to determine the slope of the collider. Here is a sample implementation: 

The padlock in the top right corner of the image indicates that this inspector panel is in "locked" mode. Clicking on this icon will toggle the lock on and off. Further information on this feature is available on the manual page Inspector Options. 

Rigidbodies can be said to operate in two modes: Non-Kinematic has physics driven movement, the physics engine will consider any forces brought to bear on the object to calculate and apply changes to velocity, rotation and position. Kinematic lacks physics driven movement, the physics engine will not cause this object to move and any forces on the object will be disregarded. These objects can be moved through code by directly manipulating the Transform if required. One important point to be mindful of is that the physics engine is optimized such that it will not detect collisions between two Kinematic Rigidbodies. If your ball is a Non-Kinematic Rigidbody and you want the bricks to remain stationary then I recommend setting the bricks to Kinematic. 

Note: this last line will produce a unit vector (i.e. of length one), you may need to handle thing a bit differently if you want the diagonals to be of length sqrt(2) like the code you posted with your question. Edit: I can see two approaches to address the issue of switching directions on each frame and approximating 16-direction movement. BlackList: If each time a player changes direction we disable or blacklist the direction they were taking before that turn, this would rule out that issue, and instead result an a high degree of over steering. This might be acceptable if the target was stationary but is unlikely to look natural if the target moves into the direction we have blocked, and players would learn to take advantage of this.