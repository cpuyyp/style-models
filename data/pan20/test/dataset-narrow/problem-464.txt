What are they for? Why would a client of the class need to know what has been used? I'd take one of two approaches: Approach one: Continue to use this as the public contract of the class: 

This really seems like it should belong in your class. It's also odd that this function doesn't actually contain the loop, so you have to call it from within one: 

Which honestly at first glance made me ask the question 'have they done something funky with exception filters'. Exceptions You don't actually do anything with any of the exceptions that you catch. If you don't need to access the variable, then you can simply catch the exception: 

Where's the menu? I'd consider moving the call to to within your while loop. At the moment, if you manage to complete one of the calculations you're met with the prompt 'Selection:', which is fine if you remember what the menu looked like, but not particularly helpful if you don't. At a minimum, have the condition show the menu to give the user a chance to pick a menu item... Linguistics You're current approach of having an output function that takes in both English and French works, however it isn't particularly scale-able. If you introduce a third language you need another parameter etc. A better approach is to abstract the lookup away from the code. Instead of embedding the strings directly when needed, instead a well known identifier for the text can be used. So you have something like . This could initially be driven from lookup tables, however it would be better if the strings could be read in from a resource/text file. This also allows somebody other than the developer to perform the translations between languages. This approach also makes remaining strings in your code stand out more, should there be a translation for 'An error has occured!\nType of error:' for example. Variable naming Some of your variable names could be improved. Consider: 

Superficially you're existing approach will work for the short number of items you are reading. However it looks somewhat brittle. What happens if the file is edited so that instead of: 

Enough on that. Next is why is in Book? it isn't used. Even if it was used, this would be a bad place for it. Keeping a clear separation of concerns (Single Repsonsibility Principle) will show that putting logic into classes and/or methods that makes it harder to debug and fix code. Naming gets the count of entries, not the entries themselves. A better name for this method should be or or . same goes with . I nit pick the word entries because you have a class called Entry. Most collections are either called the plural version of the class name, or by the logical name of a collection of classes. (For example a collection of Animals in a Person class could be called pets, instead of animals) Be concerned when methods start to have more than 3 parameters. Your method has 4, and the intent of it is to just add a new entry. So instead of passing in those 4 entries, just have Entry as a parameter. Duplicate code: and do the same thing. that being said create a new Entry with the 4 parameters and then call addFromCopy in add. Or better yet, just delete the method add, and use only addFromCopy (but rename it to add). Be mindful of when you have code that essentially does the same thing and when you spot it, pull it out into a shared method. (yes even if it is only for 2 or 3 lines of code) Last but not least, is that I'm suprised that a new blog about learning how to program doesn't mention ANY THING about unit tests. I know it is geared for beginners learning the basics, but the basics can still be taught by using a testing framework instead of viewing the output on the console. Normally I'd give a brief example, and I still might, but I have to get going. If I have time tonight I will edit my post and show an example. 

Separate Concerns The very first few lines in your code for startup and use a . While that in of itself is not wrong, how you use them is not right. Ideally you should at the bare minimum pull out the stuff into a new class that returns a . being a new class that has 3 properites (guessing by the code you provide). We do this for a variety of reasons. One is that we want a class to do a single thing. In this case we want this class to give us all the Fields on this form with a small amount of information about each. There are many approaches on how to do this, and how to make it testable so I won't go into too much detail about it. But just know that just doing that makes understanding your code MUUUUUCH easier. For instance now my code would read something like this 

If the number of mines is 1, it should be 1, adjust the number when you need to for accessing the mine array. 

Terminal Size / Wall collision detection Collision detection didn't work as expected when I ran your program, currently you can run straight off the right side of the screen, turn around by going down and left and come back onto the screen. It turns out this is because although my terminal is only 80 characters, horizontal is set to 200, so it keeps going off the side. The terminal is capping the right hand printing, so the walls are printed correctly. Ideally you would either detect, or ask the user for their terminal size. You don't often see two breaks in the same case statement, maybe it should be: 

Clarifying the problem not only demonstrates attention to detail and helps you to understand the problem, it also buys you some time to think about how best to solve the problem. Next you need to think about the algorithm you're going to implement. Consider jotting it down on paper or the whiteboard so that you've got a reference design, that way you can worry about the order/steps required without having to worry about the language constructs/syntax at the same time. Have some kind of checklist in mind for what you need to consider in your solution. For example: 

This is because there's no tracking of which thread opened the gate. Not checking the thread has the potential to cause another issue (which you might not care about, because it's pretty common with spinlocks) whereby if you have a bug in your code, it is possible for a thread that doesn't own the lock to unlock it (anybody can call and it will unlock, even if they didn't call first). 

buf_write is and you're trying to assign it to char*[50][20]. I think you should probably be doing this: 

One of my goals when I'm using TDD is to try to clarify the requirements of the system I'm developing. The requirements you're working from have several unclear elements. You've addressed at least one of them (your requirements don't indicate what to do when a null string is supplied, but you have decided to treat it like an empty string, so you have a test for it). This is good, but because you are dealing with strings there are other cases that you haven't dealt with. For example, what happens if the delimiter supplied uses one of the delimiter characters: 

There is probably even more ways to refactor my code, but without better context that is the best I can do. This is where having unit tests is super useful because you can continue to run your test every time you make a change to it to clean it up. 

so lets make this more useful. I'm not going to show what CommandLineParser looks like to make my new test pass as I'll leave that for you, and this is more for example. 

Well my first gut reaction is that I don't like what I see. Here is why though and hopefully that will help you understand why I feel this way. First is with the naming convention. GetAdminInfo is a verb. Classes are nouns. This is true in all of mainstream OO languages. Therefore a more appropriate name would be AdministratorInformation. But even that name is misleading because of the contents. Your class has 2 arrays which of type String. Since you are dealing with a database it would be ok to make a class called AdministratorGroup which has 2 properties Name and Id with appropriate Getters and setters. Then your AdministratorInformation class would be renamed to AdministratorGroupCollection and have only 1 Array of type AdministratorGroup. Now after you put this program down for some time and come back to it you will find it easier to remember what these classes do. A name should always indicate its intent. You would be very angry at me if i had a class called CartesianPoint and instantiated it like this You'd be angry because I lied to you. I normally don't do this as I leave it up to you to make changes, but I want to show some sort of code. SO here is what your code would look like after I got my hands on it. AdministratorInfo 

Normally I would also mention testing, and one place in particular that I would like to get under some sort of test framework is Baller because there is some logic in there that needs to get tested. specically there is a bug (as far as I can tell) that if my paddle is at a steep angle the collision detection is wrong. I'm not sure specifically where it is wrong, but the ball fell right through my paddle but did move slighly (almost like there was a hole in my paddle that the ball fell into). That is all I have for now. 

One of the things I think when I see a large case statement is would this be better off as some kind of lookup table. I think yours might have some scope for doing this since they all seem to do some processing on a viewSets and a filter. Using a simple lookup table to convert the string "Where", "Single" etc into a method call would allow you to separate the logic out a bit more. So, for example you could do something like this (better naming is left as an exercise for the reader): 

What do the variables ,, represent? If was called the comment wouldn't be needed, etc. Language Looping Your first while loop is redundant, and also contains unnecessary checks. After you get input from the user you call . This throws an exception if a valid number isn't input, which escapes the loop and bypasses the if/else statement. If == || This line: 

Using a class member in your classes is overkill and will result in an unnecessary performance hit. The way that you have constructed the classes, you only use the variable from a single thread at a time. The writer thread updates the variable as it is working out the multiples, however the you are joining the thread before you read the value from your main thread. This means that you don't need the protection of . Changing the class member to a normal int has a significant impact on my system (time reduces from 10 seconds down to 3.5 seconds for the partially threaded implementation). This can further be increased by using a local variable for the counting, rather than a class member, then assigning the class member afterwards. This reduces the time on my system further down to less than a second. 

I'm not really a VB.Net'er but you appear to be able to achieve what you're after using the . It allows you to make your property a Friend so that it can only be accessed from within your module. However, it's not ideal, as you have to create the widening operator in your class and any inheritted classes. Depending on the number of different field types you may end up with more typing. I found that I had to change the method to , rather than in order to get it to be called on derived classes, but that might be because of my lack of VB.Net experience. It also works by creating new instances of objects so there is some overhead. An example of what it looks like is below: 

Moving on to MainGame, I hate to see deep nested methods. I would rather see a method inside at most the second nest. That would turn something like this 

but even more important I can create a test for SquareRootOperation to make sure that it works as desired. 

Assert This is the important part of it all. This is where you check that your code did what you are hoping. In this case I want to assert/show that those arguments were not valid. 

So I suppose the answer to your question can go in a few different routes. Best practices would suggest that you write tests, encapsulate and use some different design patterns. However my thoughts when looking at your code is that this might be a little frustrating to you. But your question also points to something that I think a few people will miss. Making 10 small classes to solve the same problem (in terms of lines of code) will be the same as 1 large class. I'll offer this suggestion as a rebuttal and an answer. Learn how to encapsulate in clear logical manners. You'll end up with 10 (just a random number) small classes. The point being that the smaller the class the easier it is to understand what it does. To answer your question as a superficial answer would be to make methods to remove the duplicate code. Your method has TONS of duplicate code and would be greatly simplified like so 

I made it like that so I can easily mock out the repository without having to drag Entity with me. Now the implementation. Sorry if it makes your eyes bleed from any blaring code smells. LogSubscriptionDataContext 

Yes. You are correct. making just the list class which does only list things would have been the correct approach, anything else breaks SRP. so a bit more of an OO approach would have been to have a factory that takes in a path (be it in string form or other) and returns your person list. Its only responsibility would be reading the file end to end and creating a list with all the people in it.