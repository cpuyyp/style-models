Effectively, you can't do this, so it's not a problem. You can only manipulate a Windows Forms control from the thread it was created on (almost always the UI thread), so you generally could not be attempting to change the render state from one control's thread while you are rendering on another control's thread. Even if you did create controls in isolated worker threads you would need to serialize access to non-thread-safe resources anyway, so you'd just have to include the render states in that serialization anyhow (but again, it's not terribly useful to put controls on the non-UI thread). Create a local abstraction that encapsulates the render state data for a particular control or render window, and in that render window's drawing method, apply those render state changes. 

If the only difference between the quads is their physical size in window coordinates ("one is bigger than the other on-screen"), and all other things (shader, textures, et cetera) are equal, then the only significant difference in the pipeline will be that the rasterizer must fill more fragments for the quad that is larger on-screen. This means that if the fragment shader being used is expensive, the larger quad may be more expensive in terms of fillrate. It is, however, unlikely that this is going to create a noticeable performance differential, especially in the shaders you are likely to be using to simply paint a quad with a texture. While there are a few other potential avenues for performance issues, they depend on factors that you having elaborated on. With only the information you've provided, fillrate is going to be the only technical difference, and even that won't likely be measurable. 

It's much easier and cleaner than correctly identifying the textual equivalents of all possible keys on all possible keyboards in a standard way. Keyboards are very complicated. You can programmatically produce the mapping from key code to key text. On Windows, for example, iterate over every virtual key code, call to translate to scan codes, then call . There are similar processes for other operating systems. However, the key text you get back is set by the keyboard driver and translated based on the locale settings in almost all cases. This makes the data unreliable for use in configuration files. A technique like the above can be useful for displaying the actual keys that a user should press (for example as part of an on-screen prompt), but not for producing a reliable textual mapping. Consequently, I think you are better off just hard-coding your desired mapping. Once you have this mapping to key names, put your key-name-to-action mappings in a JSON/XML/YAML/whatever-text-based-format-your-prefer file. (Note that on some OSs, like Windows, the virtual key codes for A - Z map to the ASCII values for uppercase A - Z, so you can save yourself some typing there; you can find similarly exploitable patterns with numbers and F-keys, usually). 

Yes, it's possible. Way back in 1999, an article was published in Game Developer on the subject, entitled "Dirty Java: Using the JNI Within Games." I still have my copy of issue in fact. Fortunately the article also appears to be available online. Of course, the code in that article is probably a tad out of date, so you can also check out these articles as well: 

Normally, it helps if you actually post the errors you're getting. In this case, however, the problem seems straightforward: RigidBody does not have a member named . It sounds like you want to set both and to . 

Both "Applications" and "Stand-Alone Applications" in this context are in reference to your games that have been produced using GameMaker. YoYo Games has provided a sample EULA, which I'm presuming is the "sample license" you're referring to, here. What clause (i) above means is that you cannot remove references to YoYo Games or the fact that your game was created using their software. Specifically your end-user license agreement must call out all the rights that YoYo Games asserts in their EULA. You can see in the sample agreement that they do so by (among other things): 

allows you to easily determine the cause of the exception (assuming the debug information in accurate and the call stack and exception source data is correct, which is probably a safe assumption in this case). The only thing that be null in that line is . That itself implies that the problem is that you've failed to initialize the sprite object correct, possibly failing to do something that sets up its backing texture (so it's null when you go to render the batch). 

Fundamentally you're going to have to decide on some kind of external representation of your sprites, something that other code can pass around and store that affords them quick access to your sprites. This kind of object, however implemented, is often referred to as a "handle." You have several basic options: 

You could write a little ray-casting 3D engine, like this fellow is working on. Wouldn't require too much color; although your screen is smaller than the one he's got, it might be workable. 

I'm not sure tiles are necessarily the way you'd want to approach this ideally. I think a better fashion would be to use non-tile-aligned sprites, or some other method such as rendering the base field as a single textured polygon and rendering the "stripes" as alpha-blended polygons on top of it. That said, I can see a way you could potentially organize your dark grass tiles, based on the information and screenshots you provided: Each strip of dark grass is oriented at some fixed angle from vertical. The middle strip might be completely vertical, the next stripe ten degrees off, the next twenty degrees, and so on. You can evenly fit into a tile set any angle that will completely bisect a column of N tiles from one corner to another. For example, here are three tiles that might be used: 

No, Lua's state is not really thread-safe by default, so you can't access the same state from many threads without work on your part. Lua will call and at appropriate points, but by default these methods do nothing and you must them to implementations that actually take the appropriate platform-specific critical section. However, that implements the most bare-bones approach to thread synchronization which just makes sure only one thread is running Lua at a time. You can see here for more information. A better approach might be trying to reorganize your update loop so something else can happen concurrently with the Lua state sync, which only itself happens on one thread. Perhaps after physics is done processing, you can both synchronize Lua and prepare your graphics calls at the same time? Or something similar; it's admittedly hard to say without knowing more about your architecture. 

Shaders of any complexity aren't generally the kind of thing you can download and drop in to your project like interchangeable cogs. Typically the more interesting effects require a fair bit of coupling to the CPU-side rendering subsystem in order to achieve their results. The same is generally true of performance -- performance tradeoffs with respect to accuracy and quality over instruction count or pipelining tend to be rooted in application-specific requirements. As a result there really isn't much in the way of the kind of repositories you are thinking of. The GPU Gems books offer a good collection of cookbook-style descriptions of techniques with both game and shaded code examples that you may want to take a look at, though. So do the Shader X books. 

You are not required to use, word-for-word, the sample EULA. However, unless you consult a lawyer regarding modifications to the language or to the terms of the sample agreement, you could very easily violate the Game Maker EULA you agreed to, potentially opening yourself up to legal action. Therefore I would recommend that you do not try to change the license unless you do so with the blessing of your lawyer. 

So you've moved the "problem" of knowing the state's type from one place (the source state code) to some other place (some random spot where you have to write the enumeration-to-type mapping), and you've significantly increased the parts of code you have to touch to add a new state type into the mix. Compare to your current approach, which really requires only 

You can use a flood-fill algorithm starting at a fixed point (say, the bottom-left) to identify a entire region of the cut: 

You'd render a quad in 3D space, using the sprite as the texture for that quad. You can billboard that quad so that it always faces the player (this is what Minecraft does for its non-block inventory items when they're on the ground, if I recall correctly). 

Capturing the mindshare of donators throughout development is important not only to build hype and anticipation, but to ensure they convert into actual paying customers on launch, and to keep them active as potential word-of-mouth influencers during and post launch. 

In the above example, the actual real time between successive updates is computed and used to scale the updates, which results in more correct update rates even if your frame rate changes. Generally this is a more desirable way to write your update loop. Not only does correct for disparity in update rates, it also lets you do interesting tricks like scale the (or set it to 0) to implement time-slowing effects (or pause the game logic). Note that in practice one may want to set up multiple such timers (especially if you are going to make use of time scaling and want some objects to be unaffected by scaling). Finally, it's occasionally desirable (especially for physics) to fix your time step. 

One useful debugging technique to determine why some particular behavior is happening is to work backwards from that behavior's observable effect. In this case, the effect is that returns 0. So let's examine : 

Nothing special. Using a singleton is unnecessary (you often see it done in some of the insanely complex, over-engineered "DI frameworks" like Caliburn that are designed for "enterprise" GUI applications -- this does not make it a good solution). In fact, introducing singletons is often the antithesis of good dependency management. They also can cause serious problems with multithreaded code because they cannot usually be made thread-safe without locks -- the more locks you must acquire, the worse your problem was suited for handling in a parallel nature. 

The 3-tuple diagonally opposite the translation tuple in a 4x4 transformation matrix (in other words, the bottom row in your example, but note that it could be the right column if you are multiplying you vertices on the right instead, which is another equally valid convention) usually isn't used. It will have non-zero values when the matrix is used to represent certain kinds of projection (such as perspective projection). It's important to remember that a 4x4 matrix is a more general mathematical concept than a "3D transformation," and that not all permutations of re-presentable 4x4 matrices have corresponding geometric interpretations. In other words, the fact that the right row "contains the transformation" is more of a happy accident of the way the math works out and not an intrinsic property of a 4x4 matrix in general. 

All of those websites have forums or sub-forums dedicated in some way to showing off games, and so you might be able to get a reasonably good response out of them. I would make sure to disclose up front whatever statistics your game collects and/or sends you though, and why you are collecting them. People can get annoyed by that if they discover it after the fact. N.B. that the Steam survey is also a useful tool in itself for gauges what a minspec should be -- it can help you see what the cost/benefit ratio of supporting a particular feature or class of hardware might be for you. 

You create an array of 1024 vertices, which you write into your vertex buffer using . This is bad because it will attempt to write all 1024 elements of the array (it utilizes the array's property), and your buffer is only 60 bytes. You hard-code the size of the vertex buffer, the primitive count, and the stride of the vertex. You should instead derive this information from the vertex type and the list of vertices itself. You are using pre-transformed positions, which means your data must be in screen space coordinates already (-1 to 1 along the X and Y axis). If your vertices have positions outside that range, they are way outside of the visible area of the screen. You should not, in general, use pre-transformed coordinates unless you understand their implications (the transformation pipeline will not run).