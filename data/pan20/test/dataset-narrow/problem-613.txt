I'm not too happy about the way the loop works though. It seems a little awkward to sometimes increment i, and other times not. 

The use of dictionaries makes it easy to add new properties and actions. The extension methods then make it a lot easier to use those dictionaries in a way that reads well. Another solution you may find easier is to make FilterAction generic: 

If you're trying to create an optional parameter, you should check if it is undefined using , rather than just , otherwise you'll have trouble setting falsy values such as , , and . One of the things that allows this code to be much shorter is the observation that in javascript, is the same as - that is to say, array lookup using an integer is no different from array lookup using a string that contains a number. This avoids the need to parse the numbers like you do. The other major saver is the use of split rather than indexing, which makes it easy to loop over the parts of the key. 

You can do this with vanilla Linq. The question is whether you want all keys on the left plus new keys from the right (a "full join") or common keys between left and right plus all keys on the right (a "right join"): 

I'm going to assume that the != in the main pivoting loop is a typo, because combined with the lack of checking that the positions don't cross, the positions would be incremented beyond the ends of the array and the whole thing would error out. and should NEVER cross. In addition, even if they don't and you miraculously end up with both leftpos and rightpos on the same element (which would have to be the pivot), you swap that element with itself unnecessarily; don't do that. Finally, in your code the "left half" call always starts at index zero; that means that the left-half call that branches from all right-half calls will scan through the entire left-hand side of the array, not just of the half it should have been given. Because the left half is sorted first, there should be no swaps, but it still has to scan through all those elements, which makes the right-hand half of the algorithm approach O(N2) complexity. Try this: 

FillTreeNodes looks pretty much OK to me, I can't see any major ways to improve it. I would suggest, though, that the StringBuilder can be replaced with a simple . I'n not convinced preprocessing the list is going to give you much. That said, we can remove the need to sort the list by removing any leaves we come across when trying to add the path to the list. Notice that by breaking the logic out into a separate function, we avoid the need for "found" flags. 

Leaving aside the problem of deeply nested code for now, I think readability is greatly improved by the use of LINQ syntax: 

My code is based off glebm's, but I've changed it so that array lookups must always use the syntax. I made a few other tweaks such as creating an object chain if assigning to a nested key that doesn't yet exist. 

As a completely untested micro-optimisation, I would suspect is going to be marginally quicker than . It does, however, round up on 0.5 instead of rounding down, which may not be what you want. 

What I came up with is a variation of a "multiton"; a class that cannot be instantiated in code, but has a finite number of static instances each representing a valid value of the type. They are implicitly convertible to strings and so the static members just drop in wherever a string is needed. 

The code to read the UI controls' state back out to the domain object is similar; if the box is checked, add the corresponding value to a "clean" (initially empty) list and assign it to the object. This smells. I was thinking of adding a Dictionary containing the checkboxes and keyed to their corresponding DayOfWeek. But, that sounds like a bit much as well (it certainly wouldn't save many LoC). Any other suggestions? 

As far as the general strategy, it doesn't look too bad. Getting a "return status code" from a method is more than a little outdated (try-throw-catch was designed to replace this style of method return), but there's a lot of "legacy code" out there, and some built-in methods still return values that indicate failure. The return value of DoOperation(), if any, should be its conceptual "product"; data produced by DoOperation as the result of a computation. If DoOperation, conceptually, doesn't make any such calculation, it would be better conceptually (and thus from an understandability standpoint) to return void and instead throw exceptions on errors. However, you'd have to throw and catch multiple types of exceptions, or keep track of multiple states instead of just "logging". Also, I don't know if you simply omitted it for the operation, but I would think that knowledge of exactly what went wrong might be good to know, and so any general catch should be or similar to allow use of exception data when handling the error. 

My code appears to work (although I am curious to know if it has any correctness issue). But I feel like the memoization I am doing is a bit inelegant. Can we do without dictionaries/maps, perhaps a dynamic programming based approach using 2d arrays? Or is that even worse in terms of time and space complexity? Also is my code to update the memoized_sol good in terms of coding technique? 

The algorithm as you have intended looks ok to me. However I have a few comments about the algorithm's efficiency. With the current approach you will regenerate the same permutation many times if there are repeated integers. Is that what you'd want? I don't think so but if you do discard the rest of this review. For repeated numbers, to avoid repeated entries in the permutation result set, one approach would be use a dictionary and check if the solution was already added to it. But this gets very inefficient when you have many repeated integers. Think about a list with 10000 instance of the same integer. Like [42, 42, 42,...., 42]. The number of unique permutations possible is exactly 1, yet your algorithm (even with dictionary) will loop many many times just to produce that one result. To address this, what is typically done is, a dictionary is created that stores the frequency of each integer that is available at a given point. We can do a DFS starting with all available integers and their original count. At each level, when we use up an integer we decrement its frequency by 1 before going further down. And we only can use an integer if the available count is greater than zero. This will generate each unique combination exactly once, so the case mentioned above with 1000 42's would finish quite fast. 

The first major fix in the block makes sure that has the proper index in the case of a one-character match; If the first character matches the single-character substring, we'd immediately return -1 because was never initialized. However, if we do this, then we run the risk of finding a possible match at the end of the string, running out of characters, and incorrectly returning the index of the partial match. For example, would return index 3 when doesn't actually exist, because it looked like a match until we ran out of characters. So, we must change the default return value to -1, and must only return the index of a possible match once we confirm that it really is a match, because if we run out of characters in before we successfully reach the end of , then doesn't exist in . The second fix in the block makes sure that multi-character substrings aren't overlooked in cases where one substring seems to match but then doesn't, but the substring starting on the very next character of would match. For instance, would fail with your initial implementation, because after the algorithm found the first two 'a's, it would search for 'b' and not find it, discard that match, but then continue at index 3, when the substring starting at index 1 would have matched. Now, this does change the index of the counter variable in the for loop, which some might say is a no-no, but I see no problem with it; it's exactly the behavior that the algorithm should exhibit. Finally, up at the very top, if or had been null, the function would have thrown a NullReferenceException. If had been empty, same thing. being empty would have worked ( would be zero and so we'd never enter the loop), but it's easy with String.INOE() to check both at once. 

For me, this makes the SelectMany a lot easier to follow. There are some other tweaks to the queries too: 

If you don't include the parenthesis, it's taken to mean a reference to the function rather than a function invocation. It's a bad idea to try and manually keep track of keyboard modifiers. For instance, if your website looses focus while the key is held down, it will think it's still down when you return focus, even if it isn't. The keyboard event has a property which will be if the control key is being held down. It's also probably a good idea to put the key code into a variable which describes which key it is, as having to remember what maps to can be tricky. 

I don't like how they will convert a null into an empty string. Seems like a good way to hide errors until they pop up later. I would do something like: 

Well, the first thing I'd do is put the patterns in a list, and loop through matching them. The second thing would be general cleanup; use namespaces where you can, one-liner if/else clauses don't need braces, use var where the type is obvious, etc etc. This gets rid of that if-elseif structure and makes the code much more concise. As far as merging the patterns, you could match on a combination of two: 

For the absolute best performance speed, I'd recommend a Dictionary of all possible values and whether they are the pattern you're looking for or not. The Dictionary has to be hard-coded or generated as a one-time cost, but once it is you get constant access time making the whole thing not only linear-time and very fast, but rather elegant: 

So I had this idea; what if I could decorate my Enum values with an attribute that cross-references a "default" value of another Enum that should be used when a variable of the current Enum type has this value? The desired usage would look like: 

As you can see I have used a magic number in place of -inf. This is not only inelegant, it will actually produce wrong answer if the input node has values in that range. I can think of a few ways to solve it, but I am open to suggestions about how you would do it. I can perhaps use special value like None but that introduces extra if logic that's not that beautiful. Are there better ideas? Do you have suggestions for better names for variables and methods? Please ignore the name of class (and the fact that it does use class) since this is due to how Leetcode's wants it to be written. 

This is a leetcode problem ($URL$ Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: