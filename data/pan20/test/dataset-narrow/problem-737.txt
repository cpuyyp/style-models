OpeningRoleRule Seems to me every implements a piece of the overall score counting for a single roll of the dice. So the opening roll is just all those rules applied - see above - then checked against some minimum value. So maybe it's not a per-se. 

We'll use that in a minute. Rename to something like Refactor so code reads "abstractly appropriate" 

Maybe should return something that has both a 'is hit' boolean and a user message. Maybe an parameter will suffice. I really do not like that the driver has to know about an internal state property. Internal to : Create a to wrap up all those lose board-specific properties and give them context. Note the evolving structure The code is simpler overall! reads very high level and it's simple too, nice! This is the invisible hand of OO programming at work. end Edit 

Depends on what optimal means to you. CodeWars culture favors concise, clever usages of the language. Conciseness can clarify code. For example using Array and String iteration & manipulation methods you might avoid the index futzing in loops. What makes it sub-optimal is the relative difficulty of reading and understanding the program overall. 

No need for ; after functions. Only declarations end in semicolons. When passing AABB objects, which are on the large side, consider passing parameters by const & instead of copying. It is faster to copy objects less than 3 words. This is 4 floats, it is kind of borderline but I will check. Certainly if you use double, then pass by reference. 2b. AABB is a weird name. Boundary would be better. Do not pull code out of the class when it is so short. The constructor and destructor are 4 lines each, the code becomes more readable and shorter when kept in the class definition, and this is the kind of code where you want those inlined anyway. Do not pass Data by value!!! This is huge, you have no idea how big T could be. Always by reference when you don't know. The biggest so far that I found is that in insert, you are testing nw,ne,sw,se. You should be comparing your value and deciding which one to do without trying them all! You might consider having only a single bounding box at the top and computing the bounds of each sub quadtree dynamically. It might be just as fast and would take substantially less space. 

Tweaking @Tomaa Paul Answer This is an exercise in compare and contrast. Think about "encapsulation", "least knowledge principle", "single responsibility principle" Think about how client code cannot screw things up because it does not have access to all those properties. Think about implications now that the client - - does not have to know intimate details of two different classes. And how and are more portable - re-usable - because they know for themselves what and how to output. Think about how you instantly know what does. Why do you know what does without reading all the code? Why can we guess that is the only thing it does? Think about why OO principles should be applied into the depths of a class. And finally, how .net framework is smart enough to use the ToString override. 

No. No you don't. Reuse the function; passing in 1) prev. question's answer 2) this question's ID. Perhaps the questions are numbered and that should suffice as an identifier. 

I was perplexed why you want a better answer if your current answer is able to solve this in seconds, but if you are interested in the math, there are definitely better ways to do it. They just don't matter much if the maximum number is on the order of 28000. If you eliminate the lists and go up to the square root, the code should get faster by a factor of 1000 or so, a rough estimate based on the difference between 28000 and the square root which is 167. Another factor of 2 due to only dividing by odd numbers after checking 2. But if you look at Wikipedia on abundant numbers: $URL$ You will see that the first abundant number that is not divisible by 2 is 5391411025 First of all, that's way more than 28000. So you can immediately ignore any number that is not even in your search for abundant numbers. Wikipedia says 2 or 3, which is confusing and seems wrong. Perhaps I misunderstood them but I was looking at their list of abundant numbers, and 20 is abundant, and it's not a multiple of 3 (it's a multiple of 5). 1+2+4+5+10 > 20 Still, this means that any number that is abundant is going to be divisible by 2 and either 3 or 5 (or both). Think of it. How are you going to get factors that sum to a lot? You need factors that are an appreciable fraction of the whole number. The closest you can get to n is n / 2. The next closest is n / 3. The highest number you have to check is the square root, and since the square root of 28000 is about 170, that's the high end. But you can immediately terminate if you find that the number is already abundant, or if the sum is so low that it cannot possibly become abundant. So try only even numbers, and do the following: 

from a previous answer: The Document object shouldn't be responsible for checking for duplicates. But should define what a duplicate is. That is to say... 

Calculating Price Polymorphically Each sub-class will calculate it's own price. So far it seems that a "Price" function is sufficient. It will be as complex as needed to calculate its price in combination to its sub-parts. Client code will only do one thing. Call "Price" - and that thing calculate's its own price. In turn, that thing calls "Price" on each sub-part. It does not matter that a pump consists of motors or motors consist of pumps or that anything consists of anything else. Because every thing is a Product and every product has the same structure and the price is always calculated the same way: BasePrice + sum of component prices + sum of options. The client does not know, or care, what the product consists of - just give me the price. This is polymorphism. 

Sorry I am late to this party, but your code is actually useful to me, so I am using it as a start for my own; here are my comments on style. 

Even if I'm not quite right, 99.9% of the abundant numbers will immediately be abundant with this test, so in constant time you will have detected them. You could check a few manually the rest of the way if you are "close" to abundant. I leave you to decide how close is close. A number that is not divisible by 2,3,4,5,6,7 is almost certainly not abundant. So you can find that critical value and then not test anything higher. Store the abundant numbers into a vector. Given the list of abundant numbers: 

Is this a reasonable approach? Is there a better way to handle columns larger than 255 characters? Blobs add complication and can't be searched, right? Suppose more types are added. Do extra fields just get added in new tables and joined to the base question table? If so, every kind of question then requires a different query. Is there any better way to do that? Ideally, I would like to be able to write a stored procedure that loads all questions in a particular quiz. The two approaches that occur to me are selecting each question and based on the type, creating the object, or selected all the objects of each type. If the system expands to 10-20 different types of questions, what would be the best way to implement this query? 

The Overall Theme Pushing details down into classes where they belong and making methods responsible for doing their jobs very significantly reduces client code clutter and makes object use simpler, cleaner, and reusable. large if block is hurting code comprehension Handle the outliers, the exceptional cases up front. I find this really helps eliminate unnecessary control structure. 

indexes! Index on new_id. You say you're using temp tables, so I assume you're populating them all at once. Do a update statistics after you fill them. Finally, why cant you say something like this? 

Refactor DB calls out of classes i.e. Separation of concerns; Single Responsibility Principle; Maximize cohesion and minimize coupling. To facilitate this, you may want to design "data transfer objects (DTO)" classes (collections) to pass to your new database code layer. The idea is an object of data w/o little or no behavior; simply for the purpose of cleanly and conveniently passing data. And certainly your classes can integrate these easily. You may want to think about making these DTOs inner classes so or , as appropriate, has total control over them. 

I am trying to represent questions in quizzes. The database is Mysql but I am using fairly generic sql. The assumption is that varchar cannot handle more than 255 though, so I am supporting longer text by having multiple text components. There are four primitive kinds of questions: multiple choice, multiple answer, fill in the blank, and editText. Multiple choice have multiple answers, with one being right. Multiple anwer have multiple answers, with some being wrong and some being right. The student is expected to pick multiple answers and avoid getting incorrect ones. Fill in the blank allows a string answer which is compared against the answer (or answers). For editText, a block of text is loaded and must be modified by the student. An edittext can exceed 255 characters, so cannot use a single varchar. In addition to the base types, there are also multi-part questions where each part can be a question. My approach is as follows: A Quiz is a collection of CompoundQuestions in a particular order. This table is not included because it is not relevant to the rest of the question. A CompoundQuestion is a sequence of text, graphics, and questions. Some compound questions could have zero questions (text only) while other CompoundQuestions could have many. Most will have just one. 

When I saw another answer that extracts this to a factory class, the above immediately struck me as a SRP violation. However if a request is the exclusive domain of the class (it is after all), then perhaps not an SRP violation. Even so I think about a client using the request functionality, not being the request functionality. 

Yes. Yes there is. Think about the logic at any given question/answer and make it work for every question/answer. The result will be a single function. We are at question #2: 

I see another model "class", let's call it . This is effectively the game itself. It will contain , the player's guess, and a method, let's say, that makes everything happen. The controller can access and wire it to the view - a button in a GUI or a keypress event in the console. MVC! 

I see a class. Your diagram inspired the thought. The diagram directly suggests the class would have an array (of hands) each element of which holds the final score for both players. This data structure, then, maps clearly to your UI concept. I see it as a separate class because it keeps score for both players, so it is inappropriate to be inside the (individual) Player class. A Player might have his score (hand) for the current game, but not past games, and certainly not the past games of a different player. *Your Other classes *