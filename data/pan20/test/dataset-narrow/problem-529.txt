While this is not a thorough code review, here are some things you could improve or should pay attention to: 

They are inherently unsafe. You have no guarantee that the pointer you receive is a pointer to a valid, zero-terminated string and not to anything else, like an array of binary data, or nowhere at all. C-Strings are dumb. They don't contain length data, nor anything else besides the address of their contents. Usually, you are wasting performance here by having to call on a string whose length is theoretically known at compile time. 

Putting all of this (and some bits of supporting code) together, a reworked version of your program could look something like this: 

There are some things to be said about your C version as well, but since you explicitly asked about the C++ version (and also because my C-knowledge is not that great), I will leave those for somebody else to comment on. General Hints and Tips 

The same problem I mentioned at also occurs here: You have a lot of unncessary allocations. Again, the approach to solving the problem is similar: 

is a bug. This should read (and if you had done more testing, your compiler likely should have told you). You are missing an include () for . Depending on how you intend to use these classes, you should add a virtual destructor to . The reason is that, if you do fancy polymorphism and try to delete an instance of through a pointer to , you get undefined behavior. If you don't care about the possible polymorphism, you should be fine as-is. I share your worry about implicit conversions. I would consider making your constructors . Keep your formatting consistent. Although your formatting is almost always the same, there is one place where you diverge from it, namely in the first two constructors of . Why do you have a space between and ? (I suppose it's just some oversight of yours). Why is the default value to two of the constructors of for the parameter , but the last constructor has instead? This is very likely to cause confusion. 

Here are some more things that bother me a little (adding to what yuri already wrote in their answer): Design Ugh, globals Globals are bad. They introduce hidden state that the execution of your functions depends on, are difficult to track, are prone to the static initialization fiasco and so on and so forth. Instead of making a global that is accessed from in the shadows, add a dictionary parameter to . This will also make accomplishing point 3, localization, much, much easier, as you can then pass different dictionaries for different languages. Other tips and tricks 

Well, you could make this work using . However, since you are implementing a quite low-level memory structure, I'm not sure I would suggest it here. In general, smart pointer usage is preferable to raw pointers; however, in a case like this where you have to manipulate the pointers themselves a lot (as opposed to the data they are pointing to), smart pointers tend to be somewhat clumsy and ill fitted. However, you should definitely make sure that you are doing memory management correctly (using static analysis as well as runtime analyzers such as valgrind, asan, msan etc.). There's nothing inherently bad about using recursion in a constructor. There are two different approaches to the copy problem. One is to treat as a dumb, struct-like class that does not much more than combining a piece of data with a pointer to the next node. In that case, it is fine to make copying nodes correctly the responsibility of . The other approach is treating s more like "smart" objects which have some ingrained behavior, in which case copying should be defined through the class. I personally prefer the latter, because it plays well with the C++ approach to OOP, and lifts some responsibility from . However, I would not say that the other approach is wrong, I just don't like it as much because it makes the overall burden on heavier. 

Consider wrapping up your parameters into dictionaries. For your code, this is really a matter of style rather than best practices or anything. Your takes in 7 parameters, which is getting close to making it hard to use your function, mostly because remembering the order to pass those parameters is starting to get tough. 

I didn't know about the option for . Very cool to learn! I like your graphs; the only improvement would be to plot the points and the curve on the same graph (i.e. combine the top panel and mid panel of the graph). Scipy's uses nonlinear least squares regression. In addition to comparing to the "local" results, you might also compare the NLSR results to the results of doing linear-regression on log-transformed data. 

Why are your Python lists instead of NumPy arrays? If you're already using NumPy, you might as well use it wherever you can. You probably don't need the loop, do you? Can't you use NumPy array slicing and the matrix capabilities of to replace this loop? If you are going to loop, you don't need to do and then reference . You can do and then reference in your loop code, for example. Write some docstrings for your functions please! 

This was noted in the comments by @flodel. Identifying slow steps The best way to figure out what lines of the code are slowest is to use a line profiling tool. I like profvis. In general, the slow steps in R are element-wise assignment to vectors/matrices/data.frames, and unvectorized functions. In your case, 

Other It wasn't anything you did with that led to the gaps. That's the matplotlib default. If you want a "tight" border to the graph, try adding a before the . 

Storing the full array of Fibonacci numbers isn't necessary. You are taking the sum "as you go" and not storing every summand in the sum. You would do well to do the same for the Fibonacci sequence itself. Just store the last two values. I think your code could be nicer if it were wrapped into a function. You could use Python's keyword to make your function a "generator function", a technique that works well with "state machine"-like approach of storing only the terms necessary to compute the next term instead of storing the full sequence. You used the reserved keyword as a variable name. That's bad; try to avoid doing that if at all possible. 

I had my own solution to PE #2 lying around and in case it's interesting or useful to you here it is. (It uses and is wrapped into a function.) 

Starting from Jaime's solution, I noticed that was being called in each loop iteration. This function seems to compute the mapping between links and knots, which is something that doesn't change in any loop iteration, at least as I understand your program. Thus I wondered if things would get factor by eliminating this repeated function call. One way to do that is to represent the mapping between links and knots as a connectivity matrix. This matrix takes up more memory than the simple lists and , especially if dense, but if that tradeoff is acceptable, it would allow just using a single call in each loop, rather than two different calls in each iteration. Effectively Jaime's code is a kind of sparse dot product, while this code uses the dense dot product. A nice bonus of this approach is that the code in the loop becomes much simpler. 

Since you are working with binary data, you should tell NumPy that your is everywhere that you can. That will lower memory requirements and speed up certain operations. For example, in should become . The default NumPy is which is not what you want. The python convention for naming functions is i.e. all lowercase with underscores, not . So should be etc. The right approach for optimizing your currently too-slow function is to use line profiling. I really like the module. If you use IPython you can use it very easily as an inline magic function. Doing #3 will mean unpacking that formidable iterator comprehension you wrote! Instead of squeezing it all on one line, I'd define a generator function for the iterator, and try to be extremely explicit so that every line has only one function call, like this: 

would make more sense as a than as a : You have no member functions whatsoever and all data members are public. Since this is usually what is expected of a , you should match those expectations. is not the right type for everything. Especially for things like indices and sizes, other (unsigned) integer types are more appropriate. Why? Because can be pretty limited in size. For example, on my machine an is a 32-bit signed integer, but, since it actually is a 64-bit architecture, I could possibly have a memory address outside the range, which would likely lead to overflow (which is UB!) and the last few elements of the list being inaccessible. Instead, suggests itself here; it is a type made to represent sizes (just as the name suggests). Think about what a parameter means and how it will be used when you define its type. Don't use . You gain almost nothing except an additional chance to break your code in subtle ways by introducing all the names from into the global namespace where they may clash with your own names. If you use C++11 or beyond, don't use , use as it offers improved type safety. Separate responsibilities. In particular, don't have any method from do any IO. Write helper methods/classes to do this (this is known as the Single Responsibility Principle and is one of the most important principles of Object Oriented Programming). Give names to the parameters in your functions declarations. Parameters without names often imply that the parameter is ignored, and names offer you another place for documentation. Don't use . It doesn't serve any purpose, except confusing you about what it does, which is printing a newline character but also flushing the output buffer which is almost never what you want. Use instead. Write out (or ) when you mean it. Please don't write 

You queue is nearly useless Harsh words. Why do I say something like this? The answer is: You only offer two methods to access elements. While this is conforming to the most basic definition of a queue, it's not very useful in everyday programming. At the very least, you should add an iterator interface, which would also allow your queue to interact with most standard algorithms and increase usability by a huge margin. Also, you should add some type definitions to conform to the standard's container library requirements. Some other things 

The bug I've found is somewhat unfortunate, but easy to fix. Apart from that, there are a lot of little things that you could do to improve your code, but apart from point 1 I didn't spot anything that would require immediate changes. However, it would be nice if you'd strive to make this code portable, i.e. remove . Also, there are some irregularities in how you name things; you should decide on a coherent style for the sake of readability. Regarding STL usage, I didn't actually find much that could be improved. Apart from replacing legacy C functionality (i.e. and ), there is not much to do in regards to making your code more C++-y. Overall, I enjoyed reading your code. Keep up the good work! 

Use or include guards, not both. They serve the same purpose. If you really care about being standard conforming, stick with the include guards. In most other cases, is also fine. Do not write out default constructors if they don't do anything special, or anything at all. The compiler is nice enough to generate them automatically for you when your don't define any other constructors, which you currently don't. is a big class, in terms of object size. One reason for this is that all those s you define there are part of every object you create and are carried around everywhere your object goes, which is totally unnecessary since those are all constants. You would likely want to make those at the very least, or, since they are private and inaccessible anyway, even remove them from the class and put them solely into the implementation file as constants. The other reason is that you carry an around when you don't need to. In fact, you treat almost like a local variable: In every method you open the underlying file anew, just to close it before returning. Well, if you do that already, then you don't need to have it as a member variable because there is nothing to preserve here. Just create a new every time, which, as an added benefit, will also allow you to get rid of those ugly and calls and rely on RAII instead. Your longest line is currently 422 characters long. That is way, way too much. There is no safe and steady rule to what people consider appropriate line lengths, but most programmers agree that lines longer than 100 and a few characters are too long (I personally am a disciple of the traditional 80 columns doctrine). Overly long lines are usually really awkward to work with (just look at the code boxes in your question!), can mess up your terminal, and are generally bothersome when performing actions such as looking at code diffs or merging commits. Pay attention to correctness. should be (assuming that you also implement the hint about I gave in point 3). should be , or even . Looking at point 3 and point 5, you can do away with as a class altogether. You don't need to preserve any state, so your class is effectively empty. Putting and as standalone functions would do the job just fine. If you would still like to keep this "these functions belong together"-relation, you could put them in their own namespace. I don't know whether you care about this or not, but your code is doing no error checking whatsoever. In my opinion, you should at least verify that the file you are reading from or writing to is open and otherwise O.K. Turn the order of your header includes around. Always include headers from the project you are working on first, then all other headers, including those part of the standard library. This serves the purpose of header verification: If any of your headers are missing an include, your compiler will tell you. If you happen to include any of those missing headers before, however, the code will compile just fine, hiding a bug. 

Why did you write your own functions for and ? It looks like you are doing fairly standard things with them, so I would use implementations from or instead. (And calling the median of a vector times a "weighted median" of vector makes some sense but it is really just the regular vanilla median of .) Your class seems pretty monolithic. I'd either remove it entirely and just use global-level functions and scripts, or make more classes. For example it looks like could be a class, and maybe even . I agree with all of Ethan Bierlein's comments too. You could make the binary logic statements in the big decison making loop a bit easier to read. For example, instead of duplicating and in every , you could pre-define a before the and then just use that variable instead of repeating the binary logic. You could do something similar with the other repeated logic. In a few spots you are mixing and native Python when you don't have to. For example, does really need or would the python built-in do the job? Or even better yet, if why not make the , , etc. variables numpy arrays? 

Then, instead of copying all of the existing data into a new array every time you go through the loop, just update the relevant positions of using NumPy slice notation. 

The advantage of doing that is you don't have to remember what order parameters get passed into your initialization function when you use it. 

Thanks for an interesting, well-posed question. Before we get to issues of performance, let me make some other suggestions for your code. 

From then on, every operation on your data should be an operation on a NumPy array instead of on a Python list. The way I wrote it, it assumes your data are integers, and also that 0 can never occur as a real data point. You can modify the and offset of the call to accordingly to meet the requirements of your particular data. This approach will only be good if each user has a number of data points that is not too different from the number for the other users. Other wise representing your data as a full matrix will be memory inefficient. Use s. If your data are non-negative integers, for example, then will be much faster than , for example. Actually, if your data are integers, then you could probably just use to make your histograms in native Python, which could also save time. 

Using the built-in solution is definitely the way to go and is still way faster than even the improved "slow" method. 

I'm not experienced enough at OOP to give you meaningful feedback on your class models, but here are two quick things I noticed when scanning my novice eyes over your code: 

The reason for the differences in timing are because evaluating takes far longer than . You can see this if you use a line profiler such as the module. Is supposed to be the derivative of ? If so, you might want to double-check your formula. The derivative of is , not . In fact, if you use the the actual definition of the derivative of , the timings become much more similar. 

Whether you regard my code as an improvement probably will depend on how familiar you are with numpy. I doubt it matters in this particular application, but if for some reason you wanted to do it with huge words, this version would likely be faster. Sample output: