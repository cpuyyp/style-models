It looks to me as if the original model boards and the Pi B+ will allow up to 200mA through the HDMI socket. The Pi 3 should allow up to 700mA through the HDMI socket. As far as I'm aware there are no schematics available for the Pi 2 or the Pi Zero, which leaves them in uncertain territory. UPDATE A very close look at a couple of product shots suggests that the Pi 2 uses the same RT9741CGV component as the Pi 3: 

I'm reading this guide from the Adafruit learning pages. It looks like Astroprint sets up an access point, not a client. That being the case, you won't see it on your network, and it won't show up in Fing. To set your Pi up you need to : 

They further claim that you can use 'any computer monitor or domestic TV that supports either HDMI, DVI or composite video inputs', and that 'you can mix any compatible screens... within a PiWall. This includes screens of different sizes, different aspect ratios (4:3 - old square TVs and 16:9 - widescreen), different resolutions and different orientations'. Their site includes a set of installation instructions which includes links to the relevant software packages. If, per your question, you plan on running 24 simultaneous screens, the main concern I'd have would be the power requirements. Be very sure that you know how much current you're going to draw from which outlets, and that you don't exceed the maximum ratings anywhere. At best that would trip a breaker somewhere, causing all your Pis to shut down unexpectedly. At worst (somewhat unlikely with modern electrics, but possible) you could start a fire somewhere. Exercise some caution/common sense when setting up. 

First you're going to need a superb, highly academic team, possibly from Cambridge. Then several years of customer building, international sales and relationship building with suppliers. Over time you may want to investigate revisions to your board to target light, heavy and industrial users. Possibly some kind of camera add-on might be a useful addition to the lineup. Then, and only then, should you attempt to build Zeros. You should aim to produce only enough to tantalise the masses (possibly a pre-Christmas release?) and then should trickle produce only enough to allow one sale per customer for several months. This should ensure gigantic demand and much consumer buzz. All Pi's are proprietary. There are no publically available plans on building one at home, and you would be strongly prohibited from selling them. Even if there were plans, it's a densely populated six layer board covered in SMD components. You'd need some chops. 

I don't think that's how that works. The client device (in this case the phone) connects to an access point (the Pi). It will use that network to attempt to source any requested data. If the network can't provide it, the request will fail. There's no server side protocol (at least not that I know of) that will instruct a client device to disconnect from one network and reconnect to another. That sounds like a serious security problem. You could, I think, create an Android application that behaved like this (request data -> no data received -> disable network connection -> reconnect to other specified network connection -> request data), or perhaps even something like an IFTTT recipe might do the job. The whole thing sounds like it would be nightmarishly slow and error prone, however. UPDATE I took a quick look over the Parrot drone behaviour. I believe that they provide simultaneous WiFi and 3G/4G access by implementing routing rules on the Android side of the connection using their proprietary software. This is client-side behaviour and requires a software implementation on the Android device, not server side behaviour from the Pi. 

If you're set on retaining a wireless adapter then your best bet is likely to muck about with environmental factors - the Edimax adapter should support higher speeds than you're seeing. Move the Pi closer, turn off the microwave, open doors, install a wireless repeater, etc. 

Similar approach to @patthoyts, but using Python rather than bash. Excuse my almost certainly sub-optimal Python. 

I don't think this works as intended. At least, the docs for the Python picamera library state that: 

This uses the select filter to define which frames to output. The documentation describes my expression components as: 

I haven't done enough UWP/IoT development to be fully competent on this one, but looking at this post on mtaulty.com it appears that it's not necessarily unusual for this value to be null. He uses a basic check () to establish that there's actually something there before continuing. 

I haven't quite gone so far as to hook up the LEDs, but I think that's going to look something like this: 

I've just been playing around with the command line version of fing. It does a decent job of finding everything on the network and spitting out CSV files containing: 

It's unlikely that a 'normal' sensor module would have a wireless interface baked in. That would massively increase its cost while appealing to a relatively small market segment. The cheapest, easiest method I'm aware of for adding wireless capabilities to sensors is to use an ESP8266 module, which is basically an Arduino with a WiFi antenna. The entry level modules (ES01) are available for a little over Â£1/unit from China via Ebay. You would connect sensors to the ESP8266 GPIO pins, relay the data over WiFi, and from there the easiest route to communicating with them would be with something like a Flask program run on the Pi. 

Your sensor requires 5V to function. You provided less than that, so it never turned on. Not enough supply voltage isn't normally a problem - just don't put more than 3.3V into a GPIO and you'll be fine. 

If, for whatever reason, you can't press the shift key and need to make a new layout with a colon, there are some instructions provided on matchbox's Github page: 

There's nothing to prevent you from interfacing with external boards to add functionality to your project. The Pi has a multitude of GPIO pins that can be used to communicate with external processors (e.g. an Arduino), as well as wired ethernet and optional wireless interfaces such as WiFi or Bluetooth. All of these can be used to distribute tasks to external connected devices which may offer capabilities beyond the Pi's. The Pi can also be overclocked to some degree, which can offer performance improvements. What isn't possible is slapping a magic board on top of the Pi which dramatically increases CPU speed or available RAM. There is no physically accessible interface by which these can be augmented. 

I don't think you can do that (yet). Raspberrypi.org forum user spl23, described as a 'Raspberry Pi Engineer & Forum Moderator', reported in October 2016 that: 

Looks like some enterprising soul optimised the memcpy and memset functions for Raspberry Pi, which ultimately sped up the programs that used them. Bouncing around Google gave me a few hints towards possible source code: Source: $URL$ 

The Pi's doesn't inherently support any wireless display standards. You need to install and configure software to do any kind of streaming. 'Normally' (lots of different use cases here), I would just use an HDMI cable and strap the Pi to the back of the TV. There appears to be an inactive (last update 2014) project called Piracast which could achieve Miracast streaming, provided you followed the instructions very precisely (specific USB dongle required, 3.5mm audio only). A second workaround would be using a Chromecast. The latest versions of Kodi and Yatse will allow you to cast footage from the HD connected to the Pi via Kodi, to Yatse on an Android phone, then on to the Chromecast attached to the TV. Bit of a long way round but (so far as I've tested it) reliable. 

This is extremely unlikely to work. The latest drivers for that card (that I can find) are from 2005, and are for the following versions of Windows only: 

Speed-wise there's not much to choose between USB OTG and ethernet/WiFi. The way the Pi's put together puts a maximum limit of around about 20MB/s on any data transfers. Both approaches should provide you with similar rates. 

At the point when you call , you're inside a conditional that tests . By my count lastStimOn is (((10 - 1) * 150) - 5) = 1345 at the time of the final loop iteration. You tell the camera to stop recording when , which should therefore be at Timer = 1469. Unfortunately, presumably to speed up testing, you're incrementing Timer every 0.1 seconds, which means that your video clip is going to be (1469 - 1345)/10 = 12 seconds long. That should be long enough to achieve some kind of capture, but I suppose it's just about possible that the warm-up time required is reducing that to such a degree that you get a 19 byte file output. 

The easiest method I can think of is using Kodi. This should work to a reasonable degree on lower end Pi's. 

I'm not sure that samba shares have ever shown up automatically for me. If you click into the navigation textbox at the top of your file explorer window you can get to the pi by prefixing its IP address with a double backslash. For example: 

Once you've selected your CEC adapter you should have a page of options which includes with an up-down control next to it. Flick through the options to 'None', then confirm with and try shutting down. 

You can see that the route returns a multipart response type object which is continually generated by the function. Without this approach I suspect a static image is all you'll ever see. There is a complete example of a picamera-to-Flask streaming application based on the above tutorial here. 

Apparently Bluetooth audio isn't supported in OpenELEC. There's a somewhat apologetic explanation as to why not on their wiki: 

Per the comments below the question, I can't really take the credit for this. jason.keisersmith had received a reply to a bug report posted to the Pi4J Github page here by user savageautomate on 18/03/16, which suggested: 

Per lornix's comment below the question, pressing the shift modifier key should change the semicolon to a colon. I'm reasonably sure that this is the relevant code used in the keyboard-extended.xml file which, I think, is the layout you're using at the moment: 

I think I might have figured this out as far as is possible. The schematics for various Pis are provided by the RPi Foundation here. The schematics for all revisions (1.0, 2.0 and 2.1) of the Raspberry Pi 1 Model A and B indicate that the HDMI power circuitry on each model is identical: 

There are new versions (v2.1) of both the standard and NoIR camera modules on sale as of this morning (see $URL$ for some brief coverage). The new modules use the Sony IMX219 sensor (also used as the front-facing camera in the Xiaomi Mi4 phone), rather than the Omnivision 5647 in the old modules. What (if any) are the major differences between the new and old sensors? Is one better than the other for low light images, for example? Are there any power consumption changes? Are there any capabilities on the new board which were not previously available (or vice versa)? 

You can take a look at the relevant chunk of screen refreshing code for the Adafruit Touchscreen Camera project here on Adafruit's Github page: 

Not exactly headless (as it has a non-disable-able GUI), but Kodi supports audio streaming very well and, using plugins, can provide access to several thousand radio stations. You can control it using its JSON API via a simple web server - Flask, for example, would do a solid job of taking GPIO inputs and using them as triggers for JSON request methods. There are many remote control client apps available, such as Yatse on Android, or the official Kodi iOS app. 

Working from the mechanical diagrams of the Parallella and Pi 3, there's a small chance you might be able to get a couple of screws through each board. As far as I can make out: Parallella: 

In /etc/network/interfaces the configuration option for dns servers is with an s, as opposed to singular. Correcting the typo solved the problem. 

There's a guide here describing the process for Jessie. Looks like it's based on LibreSwan and PPP. There are many dense looking configuration options in there which make it impractical for me to provide a full run-down in a single answer I'm afraid. 

There is absolutely no way that anything other than power can be transmitted through that connector. 

Nope. This isn't going to happen. You're describing attempting to run an x86 operating system (Windows) on a cluster of ARM devices. Wrong chipset, with CPUs which are too slow, linked together in non-optimal ways - it's just not a viable concept. 

An arstechnica.com article published today outlined Google's latest progress towards their IoT platform, Android Things (formerly Project Brillo). It looks like it supports the Pi 3. Is it possible to access the Pi's GPIO pins from a native Android application? Can you provide a brief example? 

There are one or two things you might play about with using minimal hardware. Kodi is one of the most popular media centre programs out there. It plays pretty much everything, and it has a fairly huge array of community built add-ons that allow streaming of radio, TV and movies. OpenELEC is a variant of Kodi which has been somewhat optimised for tiny computers like Raspberry Pis. I've run a copy of OpenELEC from a Pi 2 hooked up to my main TV for the last few years, and it's great. They have a decent write-up on the setup/installation process on their wiki page here. Makezine have a good tutorial on turning your Pi into a short range FM transmitter here. The sum total of the equipment required is a length of wire that you can connect (you might get away with wrapping a pin if you don't have a soldering iron or pin headers) to a GPIO pin. Make have provided a pre-built image file accompanying the tutorial, which contains a modified version of the venerable PiFM application by Oliver Mattos and Oskar Weigl. If you can get this project up and running you should be able to transmit audio from your Pi via the antenna to any nearby FM radios.