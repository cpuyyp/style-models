Note that assigning intermediate outputs to a variable in the first approach () should not carry any significant time (feel free to test). And your code will be a lot more readable than using nested calls: . 

You will notice another improvement: everywhere I am referring to columns using their name, for example, instead of their index like . It makes the code more readable and easier to maintain (Imagine what would happen if suddenly a column was inserted at the beginning of : you would have to modify all your indices...) 

where is a vector, so does not have to do any conversion. Note that you have a similar issue twice inside where you meant to use instead of . Second bottle neck With the iterative merge calls, you end up with pretty large data. What comes as pretty costly in that these calls, by default, also sort your data. That's where the second item in your profile () comes from. To get rid of it, which should not affect your results, add to all your calls. On my machine, these two changes cut the computation times by roughly two thirds. I hope this puts you on the right track. 

Here are a few pointers. I should first say that I am more familiar with R; I know next to nothing about Fortran but I could read your code and guess about a few things that will likely improve your code: both in simplicity and speed. 1) Why the need for two inputs and ? You know that in the end you will have a total of simulations: could there just be a single input that will be split evenly among your ? This should get you rid of the loop inside so it could only call once. 2) You should make your slave () as simple as possible. IMO, it should not know about things like or if you just tell it how many simulations it needs to do. Let R do the math upstream and pass it down to the slave. I don't know much about random generators but maybe the same can apply with the random seeds: if you could let R compute a seed for each slave and pass it down as an (optional) argument to the slave, that would be best. (However, if knowing the and is crucial for seed selection and can only happen on the Fortran side, then disregard my comment...) 3) This one I feel is important: do not compute averages too early. They are costly and can make you lose precision. This line in your code () is particularly problematic: you are doing so many unnecessary multiplications and divisions... Instead, you should just be counting the number of darts, i.e. incrementing a counter. Your slave should just be returning an integer. Let R add all these integers together and do a single division by at the end. To summarize 1, 2, and 3, it would be great (if possible) if you could just tell your slave: here is your seed number ; now throw darts and tell me how many ended up in the circle. 4) Now looking at your R code. Yes, the use of in your code is not very elegant. That's because you are trying to use which may not be the best option from the package. Instead, or are better suited for functional programming. Your code could look like this, I let you figure out the rest: 

Under both designs, it is my humble opinion that you are making it confusing for the user when you make the default when the user passes nothing. I would not provide any default. A third approach might be: 

(where transforms the data.frame into a single long vector.) An interesting aspect of that approach, apart from its conciseness, is that it guarantees than the output columns become numeric. Whereas your approach, by making incremental changes to the columns, would preserve the original class of your columns, i.e. "character". Also note that foods that are not included in the vector will be turned to since for example is . 

Disclaimer: I am not 100% confident that your nor my definitions of and are correct, given what you are trying to achieve. Try this for example: 

One improvement is you can use the vectorized function rather than . This way, you can precompute all hexadecimal pairs and feed them directly into and which are also vectorized. This removes the need for (a disguised and slowish loop). You could also use as a shortcut for . has been around for what seems like a couple years. If you are concerned about compatibility with older versions of R, then yes, it is safer to stick with . I could be wrong but I see no reason not to output a vector of integers instead of numerics. That integers use less memory and are not subject to floating point errors are two strong reasons to prefer them over numerics. It is also a good idea to add input checks to test your assumptions. Here it seems that the input must be a character vector of length 1. This comment is more subjective. You have crammed a lot of operations into a single statement. I can count 8 functions including the anonymous one you created. That really makes your code hard to understand. In all, I would have written the function like this: 

Note that I was not able to test because of some issues I had with your data. So it may need some tweaks. 

The code above might still be a bit too slow because of the computations inside the loop. If the dimensions of your matrix are not astronomical, you could compute the matrix of distances at first using a compiled function. I once tested about a dozen of packages and found that (written in Fortran) was the fastest. If you do not wish to install it, you can use the function. The code would look like this: 

First, why return a vector of characters when the output data is clearly about integers? Instead of initializing 

The use of in a loop is a common mistake. You'll probably agree that, by design, the code in the loop will be executed . Well, that's not exactly always the case. In particular, when is empty: . You would want the loop to be executed i.e. zero times. However, in this unfortunate case, would evaluate to i.e. . Instead of zero iteration, you'll have two and likely cause an error. Instead of , you should use or . Both and will do the right thing when their input is empty or zero respectively. The use of to dynamically create objects is, excuse my word, an abomination. I'll try to show you a couple reasons why. Via your loop, you have managed to create four objects: , , , which you later use in your code: 

You have written six times in two lines... Store it in a well named variable (maybe ?). Same goes for . Also, was not needed, you could just use R's recycling rule: 

I'll address the two main bottle necks in your code. First bottle neck To help understand the issue, let's first remind ourselves the difference between the and operators: 

Now regarding your design in general, I feel it would be nice to pre-split your data.frame every rows, and let the user know that there are for example 12 pages and that he is currently looking at page 4/12. In the prompt, also allow the user to jump to a specific page in addition to the next or previous page. Finally, make it easier to exit via a specific code like rather than wait for the user to go beyond the first or last page. Here is my attempt: 

Finally, a recommendation. Be careful using single characters as variable names, since R already uses a few of them for built-in variables or functions. You could for example confuse your variable for the function for transposing data. Other single character variable names used by R that come to mind are (concatenation), (quit), (TRUE), (FALSE), (inhibit). Anyway, it is always better to use descriptive variable names and that usually implies more than one character. 

There are a few cons with writing code that uses at each step. You probably know that these functions are disguised loops so it is as-if you where running at each line of your code. This will likely be: 

First step is to compute the distances between the main stations and the local stations. I use the because it is fast (compiled in Fortran), at least a lot faster than the loop inside . 

You can speed up your code by replacing the loop with more efficient (vectorized) functions. Your code can then be reduced to a simple one-liner: 

Add some spaces to your code to make it more readable. Have a look at the body of basic functions (e.g. ) to see what clean code should look like. In particular, spaces after commas and spaces on both sides of , , and all binary operators. Replace your hardcoded values ( and ) with variables. can be derived from the number of rows in and is an input to your process. By assigning it to a variable (or a function input), and reusing that variable throughout your code, your code becomes easier to read and maintain, and more robust to changes. Imagine for example what would be required of you if you wanted to change the size of the transition matrix or wanted to have 50 iterations instead of 25. Using a 1-row matrix is overkill and error-prone: use a vector. Choose well how you name your variables and comment your code. Again, to make it easier to read and understand. Learn the difference between numerics and integers. Here your states are obviously integers, yet your code stores numerics. Granted, it is not critical here, but using integers use less memory and can make your code faster. Integers are also not subject to floating point errors so they can make your code more robust in some instances. Marginal speed improvement. The 25 random calls to being independent, you can make a single call to and store the results. Think of your code in terms of inputs of outputs, then write a function. 

matches an input string to a pre-defined list. It allows for partial matches and handles the error in case it can't find a match. is like a smart for doing "the right thing" depending on the input. 

Now that's a start... If you try with a large prime, e.g. , it will take a very long time to converge towards though. So you will have to get more creative to make it converge faster. At least, you should be fixed about why your original code was so slow. 

If it were not for these solutions, there are a few things that could be improved in your code. First, you could have used directly instead of the variable you created. Second, the last two lines of your code could have been merged into one: . Also, if you look at the doc for , you could have saved yourself some typing by doing 

Here is how you can completely vectorize your code, making use of matrix functions such as , , and . Without loops, your code will be more concise and faster to execute. The construction of was indeed a problem. Incrementally growing an object like you did is very memory intensive: each time you add a row, a new object is built from scratch. On the other hand, your comment that I've read that making a matrix of the correct size and filling it with NA only to fill in its values later is very memory-intensive is not accurate. Here the object is created once and filled in-place by the loops. To summarize: growing an object iteratively is the worst. Initializing an object to its final size and filling it in place via for loops is preferable. Using a vectorized function to create the object in one shot is the best. Hope it helps! 

Instead of a top-down (very memory intensive) approach, I would recommend a somewhat bottom-up approach, where you add one column at a time then do the reductions, add another column, etc. Try this: 

Last, I'd like to take an extra step back and offer alternatives to the way you computed the incidence matrix. Your code is rather optimal, despite a double for loop. I think you can make it simpler and maybe more robust, at only small costs to computation times. First alternative: instead of treating the diagonal separately, include it to the for loops by changing the indices to: 

I am not a data.table expert so I can't tell if there is a faster approach, though $URL$ suggests you are already using something efficient at each step. The changes I have to suggest would however make your code a lot easier to read and maintain. First, define a function that can be applied at each step: 

Question 3 Is the design correct? As I mentioned, I frequently will invoke this function on the columns of a data.frame. For example, I'd frequently need to do my_filtered_df <- filter_by_mz(my_df$mz, target_mz, ...). Would it be better to write the function to work on data.frames rather than just vectors? Your function returns a vector of booleans, not a data.frame. So you would have to do: 

Another solution would be to use the or functions to handle the conditions you have on . These functions become really handy when you have many cases ("breaks") in mind, although here you only have three. You could do: 

So this converts the lists into data.frames and rbinds everything together. You do not really need for that. You can first turn the lists into data.frames by doing . And you can do the binding using , so: 

Here are some ideas, somewhat sorted by order of importance. I hope it helps. 1) There is a problem with your second function, see that 

If you need to convince yourself that was called a single time, you could add a somewhere inside its body (I did!). having been called only once, there is no need to say how fast the computation will be. Finally, if you want to store the distances in a three column (airport1, airport2, distance) data.frame rather than a matrix, you can do: 

I feel you wrote some very complicated code when the hardest part (from an algorithm point of view) should be a single merge of your two data.frames. So my rewrite is centered around a call to the base function. The only trick is to add an column to both data.frames before merging so the output data.frame will contain two and columns telling us from which of the two input data.frames the output rows are coming from. From here, contains everything you need to know, and forming the output is just a few lines of vectorized operations to add , the new data, the retained data, and the comparisons. I hope you will agree that it is much more readable and easier to maintain this way. (similarly ) is a great tool for speeds or for making clean/concise code, but I don't think it applied well here. Also notice how I used in a concise manner for doing all your input checks. 

However, as pointed, an exhaustive search will not work well for large input vectors. A much faster approach is indeed to use dynamic programming. Here is a tentative implementation: 

Thanks for providing the link, it helped a lot in understanding what you were after. I will provide two versions for you to consider. The first one is algorithmically similar to yours, except written a little more in the "R style". The second one will make a more efficient use of memory since that seems to be important too. I will also assume that the input file in is like the one in the link, i.e. contains lines like the two below: 

seems completely unnecessary since the two matrices are symmetric by construction. Next, your string manipulation for the output filenames seems a bit complicated. If I get it correctly, you just want to change the extension from to ? If so, I think you should use as follows: 

Notice how I improved your code regarding the use of , since you had not accounted for the possibility that your user does not have the package installed. If you want to make the package a requirement, then calling is prefered to , the blog here $URL$ offers a nice explanation. If you absolutely want your function to allow to pass "minutes", "days", etc. (though I would stay away from it), you can do: