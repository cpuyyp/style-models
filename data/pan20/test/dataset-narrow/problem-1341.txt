We use svn at work, but the repository is getting pretty large, so checkout times are long, as is update when artists batch process all assets. The problem is that we also store work in progress, prototypes, small tests, legacy stuff and other 'junk'. Now theoretically, some of it can remain local and uncommitted until it is ready to be included, and a lot could be deleted and cleaned, but that's irrelevant for this question. Imagine a new asset, a level for example. The artists and designers want it shared and in version control so several of them can work on it, but everybody else does not need it. Obviously multiple repositories are an answer: one for artists, one for programmers and one for the main project (for testers, building demo versions and finally the main product), which would be really tight and minimal, with everything needed for the game and no more. And then when an asset or some code is 'mature', it can be copied into the main project and committed. Here's my questions: is it possible to have multiple repositories overlapping so that the artists can have one with everything they need, likewise for programmers. And only when ready commit the same file into the project repository too? This would eliminate bloat of having multiple copies of files and avoid conflicts between repositories. I know old svn versions stored invisible files in all directories, so it would be impossible, but new svn versions store all meta data in the root directory right? So it might be possible. I imaging the answer will be 'impossible', or even if possible, yuck! I suppose it would cause all kinds of headaches. Like checking it out in one repository would mean it would need to be committed/deleted in another. But how about making a svn_commit script, that overrides svn commit with additional checks and housekeeping? This is just a thought experiment really. I was wondering if anyone has ever done anything like this, and what would be the issues to be resolved. Cheers 

Note that these are just recommendations, not cut-and-dry human thresholds for epileptic triggers. If your game violates any of these guiding principles, there is a good chance it may be dangerous; however, if it doesn't, that's still no guarantee that it is safe. Sources: $URL$ $URL$ 

That's a pretty standard solution. Try hiding the mouse cursor and superimposing a fixed targeting reticule (if your game needs one) if it's a distraction 

It appears that my Update function was being called at least twice before anything was being displayed, and that even though the bullets were part of the collection they were becoming disabled before being drawn and thus textures not loaded (?!?). By setting the lifetime (which is decremented once per Update, and when lifetime = 0 the bullets are no longer Visible/Enabled) of each Bullet to 3 or greater (this may vary depending on CPU speed?) when I instantiate the Bullets as part of the ship class, the textures are properly loaded at the beginning of the game. I'm still not sure why manually setting them to Enabled/Visible at creation doesn't force the texture to be loaded. 

This is the simplest I can make it. If it were me, I would do something a bit more complicated to antialias the meniscus and apply more refraction there or something, but I can't tell you what because it would take aesthetic iterations. Also, I would tint and blur the water sample. But I'll leave all that up to you. 

Have a value in the shader that specifies wetness. Smaller than 0 means air, greater than 1 means water, and in between means meniscus. Here is some pseudo code: 

I'm making a SpaceWar!-esque game using XNA. I want to limit my ships to 5 active bullets at any time. I have a Bullet and a Ship . My Ship has an array of 5 Bullet. What is the best way to manage the Bullet textures? Specifically, when should I be calling ? Right now, my solution is to populate the Bullet array in the Ship's constructor, with being called in the Bullet constructor. The Bullet objects will be disabled/not visible except when they are active. Does the texture really need to be loaded once for each individual instance of the bullet object? This seems like a very processor-intensive operation. Note: This is a small-scale project, so I'm OK with not implementing a huge texture-management framework since there won't be more than half a dozen or so in the entire game. I'd still like to hear about scalable solutions for future applications, though. 

Everything that is not affected by the difficulty value should be constant and consistent, so that there is just a single variable to tweak for difficulty. This is to make level design and tweaking as simple as possible, which is incredibly important for balancing. It's a bit of a vague answer, but I hope it gives you some ideas. 

It may be that when calculating the coordinates of each tile's corners, you are losing some precision. So, for example, you think the bottom right vertex of tile 0 is in exactly the same place as the bottom left vertex of tile 1, but actually it is not. One idea to fix it would be to calculate a temporary grid of coordinates at the beginning, and then copy the appropriate position when constructing the tile geometry. Does that make sense? 

I'm working on a SpaceWar-esque project to get comfortable with XNA. I have a Ship DrawableGameComponent and a Bullet DrawableGameComponent. The player's Ship is created at the start of the game, and the Bullets are created for each Ship as part of its constructor. In my Ship constructor, I have the following code: 

Many implementations may lead to a random weighted chance for moves -- say, a chance to make an optimal move and a chance to make a suboptimal move. Determining how suboptimal a move is could be a very tricky problem, but will also lead your AI to making much more seemingly-intelligent decisions. Important note: No matter the difficulty setting, it would probably be a bad idea to have the AI pass up a chance to immediately win the game. If there is a possibility to make a move that would finish the game that turn, it should always be taken. If not, it will absolutely destroy the player's impression of how the AI is acting. 

So, to sum up, here is a list of keywords to research to improve your simulation: leapfrog integration, runge-kutta integration, verlet integration, adaptive timestep, collision detection/resolution, rigid body stacking, resting contact, impulse collisions, You can easily find lots of easy to understand tutorials, samples and papers relating to this. That's probably a lot deeper than you need/desire to go. But writing a simple, but solid, physics simulation is a great learning experience and a whole lot of fun. 

First of all, let me say that most calculations were done with integer maths because without FPUs real values were slooooooow. I'd say that in the vast majority of cases it would be axis aligned rectangles, simply because that is the fastest way, which as Seth pointed out, is just a special case of separate axis testing. In some cases collisions would be with circles, but when doing that the square of the distances were used to avoid square roots. These were very slow back in the day, and although it's not such an issue today, it's still done this way because why do unnecessary work? A faster but far less accurate distance measure is using 'manhattan distance', which is simply abs(dx)+abs(dy). This might be used for coarse collsion detection before a more expensive version. I doubt per pixel testing was ever used since it is very costly, except for simple sampling, such as the ground beneath rodent feet in Lemmings. 

You're on the right track with figuring out when the mouse is transitioning from down to up and writing a handler for that. For a lot of games, it's good enough to treat a mouseUp event as a click. Depending on your game, you're probably want to handle both events -- for example, in an RTS, you'll probably want to incorporate drag-box selecting as well as single-click selecting. The difference is in determining how long the mouse was in the Down state before it's released. (Yes, you basically answered your own question) 

First of all, you need to learn the basics of vectors. Just find a good tutorial. It will not take long. Try this. For simulating a physical object: Newton's first law of motion: "An object at rest remains at rest unless acted upon by a force. An object in motion remains in motion, and at a constant velocity, unless acted upon by a force." What this means is that it takes no energy for an object to remain at its current velocity (linear and angular). It only takes energy to change the velocity. (Note: speed is the magnitude of velocity and is a scalar). This energy can come from thrusters, gravity, explosions, collisions, and even light falling on it. Newton's second law of motion: "The acceleration of a body is directly proportional to, and in the same direction as, the net force acting on the body, and inversely proportional to its mass. Thus, F = ma, where F is the net force acting on the object, m is the mass of the object and a is the acceleration of the object." This means that we can calculate the acceleration on a body if we know the total force acting upon it, and its mass. Newton's third law of motion: "When one body exerts a force on a second body, the second body simultaneously exerts a force equal in magnitude and opposite in direction to that of the first body." I won't deal with collisions here, but this means that in a collision both bodies receive the exact same collision force in the same position, but in opposite directions. Once you can calculate acceleration, you can integrate it to find velocity, and integrate velocity to find position. If your object looks like this: 

I have a small 2D game I'm working on in XNA. So far, I have a player-controlled ship that operates on vector thrust and is terribly fun to spin around in circles. I've implemented this as a DrawableGameComponent and registered it with the game using game.Components.Add(this) in the Ship object constructor. How can I implement features like pausing and a menu system with my current implementation? Is it possible to set certain GameComponents to not update? Is this something for which I should even be using a DrawableGameComponent? If not, what are more appropriate uses for this?