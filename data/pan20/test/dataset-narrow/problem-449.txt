Methods I'm assuming this chunk of code sits in your method, and I think one quick way of improving it is to break it into two methods - one that returns a validated user input (at least 5 chars with a space), and one for the actual work. When you separate them, you will also realize that you only need to print your validation message once, instead of twice as you are doing currently (to check for length, and to check for a space). Stricter input validation 

The first step also takes care of a array, by treating it as an empty stream. The second step replaces each element with its contents on a resulting . 

This is one of the few places where you may want to use a temporary variable, and employ the help of line formatting: 

Eh, what? One, why are you printing out on the standard error stream? Two, how do you complete the so-called 'testing'? By manually checking the output matches? This is where unit testing comes in! A proper unit test should let a developer: 

I'll leave it to others to for the GUI review, I only have a suggestion for your class: Constructor arguments positioning It is sometimes recommended to order constructor arguments by their requirements, e.g. 

Instead of writing in full, you can simply write . class You can consider having a method that helps you create a new and add the number of hours worked. This eliminates the code repetition you have currently. For example: 

Iterating through a collection of objects Following @Robby Cornelissen's suggestion of using a , you will not need to create 'dummy' objects just to compare account numbers. Alternatively, your class can have a method to perform this check, instead of doing it within your class. Understanding methods Setting a , comparing it case-insensitive to some values inside , and then performing the appropriate steps is convoluted. Just have methods like or with the relevant arguments and call them from your class. There is no simpler way to describe this. 

Your font specification is repeated throughout, you can set this as a variable so that your UI elements need to only reference one of it: 

(BTW, a 'true' will have a third generic type for the return type, but since we know we want an instance of to be returned, we'll take a short-cut here.) Then, modify to accept this additional argument: 

Here, we update our map by and compare against / sequentially. The use of and is slightly better too, as they ensure the results are immutable. 

Java 8 stream processing A can be your friend here, as you recognize you are doing something similar in both: 

Also, technically speaking, this is not a simple numbers-to-english translation, but an English representation of monetary values. You can alternatively call your class as . 

Relying on ... If you can modify the implementation of your implementing classes, you should do that instead. The body of can be as simple as: 

Please on your instance, so that it can be safely closed when your program terminates. Consider putting the calculation logic into its own method, so that you can call it by passing it two arguments (start and end). In fact, this can also return a of prime numbers for the caller to handle the results (print it out on console, display on a GUI, save to a file, etc.), so that the logic and the input/output of your program are properly separated. Do prompt your user by printing out a descriptive line before the input, e.g. 

Varags Since Java 1.5, you can use varargs in your method so that you can pass in a sequence of elements, instead of an explicit array: 

vs I also wonder if the comparison might be a bit more trivial if you convert the file content into a 2D array. This allows you to navigate the 2D array by 'blocks', which may make for slightly better usage of the constant fields you have at the moment. vs output Since you are expected to produce numbers, I wonder if it's better to create (or some -based) values, instead of s. Of course, if account numbers start coming in with non-numeric characters, then as the vendor of the Award-Winning OCR enterprise system, you can start charging for these new features. :p Testing While it's expected that your inputs are in the form of a , you should make it such that the actual logic can be tested easily against a or input. Alternatively, you can consider something like Jimfs so that you can easily create files within an in-memory filesystem, good for testing purpose. 

Using the second approach as the foundation, you can attempt to parallelize the process by adding the , and if you are OK to drop the -handling, a tweaked solution can be just: 

Of course, you may want to perform extra validation, for example making sure that the input is a positive number. Hard-coding (and approach) 

Enum names and comparison and should be renamed as and respectively, as Java types are usually not in CAPS. Also, when you want to compare equality of an , you shouldn't have to compare on its , but rather on the value itself: 

By making it clear what your parameters are, we can now care about how to explain your logic. Explaining logic vs implementation Similar to what was pointed out in @Josiah's answer, have a think about how you will explain your logic, and then reflect if that was as elegant as saying "loop through each character and count the number of matches for my 'value' character". It's easy to commingle short code as elegant code, but as you have to deal with more complex logic in larger code bases, you will learn that you have to care about how it can be explained rather than how short it reads. It is not as elegant to understand a simple 'count-the-occurrence' method as having to get the length of the input string, and subtract that with a copy that does not have the matching 'value' character. Performance To be frank, you really should not have to care about performance for a simple method as this, as that reeks of micro-optimization. However, if you are interested in comparing your solution and a simple loop, you can roughly think in terms of the memory required by your code as it goes along. Your solution already knows about its input, and it needs to create a copy of that input, albeit shorter. A loop requires an additional to count. It doesn't require making that extra copy. On the other hand, the stream-able way has more 'plumbing' underneath, but its advantage come in terms of a more declarative way of approach, instead of the imperative approaches we traditionally have. 

Since Java 7, it's recommend to use on instances, e.g. in this case, for safe and efficient handling of the underlying I/O resource. Methods The calculation itself can be encapsulated into a method: 

Inside your method, the code then becomes more readable (some small changes to your variable names): 

Putting it altogether, #2 If you were to take the whole -based approach one step further, you will realize that perhaps, even your looping for the steps can be 'converted' too: 

One generic (pun unintended) suggestion: Use braces for your statements to ensure you do not accidentally introduce bugs, because it makes the presentation clearer. Minor points: 

Java 8? If you happen to be on Java 8, then congratulations: the new classes ('Time APIs') are much better for chronological representations. You can then consider rewriting the same method as such: 

Minor comments here since scott_fakename has provided a pretty good start... Extract the user input part from into its own method, so that each method is only dealing with one thing. You have some idea of showing 'tracing' messages for debugging/troubleshooting, ever considered using a logging framework? Not sure if this is beyond what you need to hand in this assignment, just a thought... I also think using one static class-wide instance is good enough for all the random number generation. As for consolidating and methods into a single one that takes an extra parameter to control the calculation, you can consider using enumerations to indicate the different modes. E.g.: 

The empty constructor is redundant. :) Your code seems to rely a lot on , perhaps make that as a constant? Alternatively, if you are already on Java 7, there's . I'm not too sure about your implementation for ... For starters, why not make a field, and the same for the rest as well? You may also want to consider using over . You can also probably consider having only one per instance, as I don't think there's much benefit to instantiating every time when calling . 

I will suggest making these s instead, so that you do not need to on the fields explicitly before using them. 

Since you actually require the initial of the first name, you also need to check that the space is not at the start or the end of the input, as otherwise you only have one name. Consider this: 

Specifying a downstream for There is an alternative method that lets you specify further steps that you want to do with the intermediary values after the grouping. Then, with a bit of renaming, some help from method references, plus some convenience methods like having a : 

BTW, you have a spelling typo too: it should be , not in . Also, seems to be an unnecessary instance field, as you are operating directly on the object. Therefore, you can probably just stick with: 

The methods on the generated classes have the same parameter and return types. For the case of method, that returns the same type as the input object, i.e. recursion. 

This is the wrong approach to get your method to loop, by having it call itself recursively. At a sufficiently large number, your program will eventually crash as it can no longer reliably track the nested method calls. You should use a simple loop mechanism outside of the method, so that can return quickly and normally for its next invocation by the loop. For example: 

You may want to (slightly) optimize your initial validation by skipping values as well. Over here, I used as the initial contents of the . Helpfully, the initial capacity adds another 16 on top of the input's length, so if there's only... 8 replacements, then it's pretty 'efficient' (for some definition of that word). Also, take note that the iteration is done from the end of the , to preserve the positioning of the character to replace. To visualize this in another manner, the replacement is always done to the right, while moving left-wise. 

@rolfl beat me to it, but I'll still offer my answer in case it is marginally more useful... First, in your method, you are expecting that the sorted list is in a low (not rated, yucks) to high (so many As!) order. This either means that your should really be calling 

Checking for differences I think the (renamed) method can be improved. Currently, there's just too much 'steps' to create the necessary arrays, loop through the s to populate said arrays, and them computing the differences. Instead of diving straight to arrays, you can consider constructing a 'letter map' first, get the differences, and then generate the desired array result. This is assuming you still want to stick to that type for the method. 

Parsing twice Instead of parsing twice, consider passing the object you have already constructed to the local time zone into . vs A object has arguably better semantics than a , so it may be easier to access the individual chronological fields (actually, in your case, just the day component). Lengthy block Your block in spans the entirety of the method, but it's generally recommended to keep them short and to-the-point so that you effectively get a fail-fast mechanism. It's also easier to understand what's the exact code that might plausibly throw the checked , so that it can be easier to refactor in the future. 

Leave as negative so that you're looking for the largest negative number, e.g. to find the smallest difference. Use so that the comparison afterwards can remain the same. 

This takes care of closing your at the end, so you do not have do perform an explicit . First input I am not too sure why are you ensuring cannot be less than 2, since the problem statement only mentioned . I'll take that to mean an implicit assumption for non-negative values, so yeah even is possibly a valid input. There is also an easier way of getting your first input than performing your validation twice, and while you're at that you should consider putting it in a method: 

In the unlikely (?) event that you still prefer/require the original iteration method by checking on , the -based implementation, coupled with stream-based processing, can also achieve the same outcome with the following, for simplicity: 

The , as you probably have already figured, is that you need to 'consume' the rest of the line first before moving to other inputs. Therefore, I will also suggesting reading as instead and then attempt to convert to an via . You can then catch the thrown as an invalid input, and re-prompt until a valid integer is entered. Validating your additional inputs Note: I'm not sure if integers are implied for numbers, so I'll just go along with what you have shown... First, I think you are missing the validation on your integers-to-be: 

Your approach As pointed out by the other answers, you are practically hard-coding whitespaces in your arguments, which can get non-standard easily, even in your example. Otherwise, the use of is sound, although it wouldn't deal nicely with a single value - the loop will fail as it implicitly tries to get an for it. Java 8 An alternative is to rely on the stream-based processing that Java 8 offers: 

I meant that partly in-jest, but if we really need to avoid any loops, we can also call each value one-by-one to print them: 

Miscellaneous You can opt to remove the final clause as is the final 'step' in your comparison. Again, I think this is a personal preferences thing, as some may prefer to see the 'boundaries' of the -blocks. 

This kind of code can be simplified as . Method names Your naming can be better refined to reflect what they are doing. For example, can be renamed as , following the standard prefix for methods returning a . can be renamed as . loop Your loop on can also be written as: 

Assuming if we're talking about the same SDK, then perhaps the worry that you'll need to support 100+ s is unnecessary... or you should really consider switching SDKs if you/the library developers do get to that stage. s values are ordered (hence the method), and the ordering the SDK uses seem to be: 

Besides the fact that you are using braces inconsistently, this method can be entirely replaced by : 

Formatting Your statement block should use braces to better identify the scope of each clause as a good practice. Also, you can consider renaming to respectively.