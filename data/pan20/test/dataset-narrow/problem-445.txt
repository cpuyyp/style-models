Correct (produces the desired result) Reliable (always produces the desired result) Robust (handles errors appropriately and is not brittle when things change around it) Readable and Maintainable (try working on someone else's code or even working on your own code 3 years after you wrote it) Appropriate Performance (most code does not need to be optimized for performance) 

You don't need to use since the data is already in an array. If you just process each file as it is read, you can avoid the iteration entirely. You can avoid some temporary variables. You should declare all local variables with , or as appropriate. 

So, all you're getting out of your implementation is a slightly more efficient length and every other operation is less efficient than just using the native code way of doing it. Is this collection really useful? There are some older browsers that don't offer the .keys() method, but there's a pretty simple shim that implements it if not available. In addition, your implementation loses functionality that a plain javascript object has. For example, you can't pass your collection to any function that expects a javascript object with the keys and values on it because those are hidden inside, they aren't actually properties of the collection object itself. Then further, you can't do custom iteration of the keys and values without first creating an array of all the keys because you've hidden the natural ability to iterate the keys of a javascript object. 

That depends entirely on your viewpoint. You certainly don't have to have a UserEntity, UserRepository, UserFactory, UserFinder, Email, Username and Password Value Objects, AuthenticationService AuthenticationAdapter and implementations. But you could have. Also, we could (no, we should) argue, whether storing the password hash in the user is a good idea. You'll only need it to authenticate and then never again, so that's one time in the application. After that, you can use a token or set a flag in the Session. There is no need to store the password then, regardless of where you do the authentication (a separate component sounds fine to me. You could inject that to the User and then delegate the call). The most important thing is that the code does what the enduser thinks it should do. However, it should also be implemented in a way that won't come back to haunt you, should your ever need to change the application. So whether it's "okay" or not pretty much depends on the scope of your project. Ask yourself: "is it good enough?" 

Yes, always. Except for when you can reasonably justify not to. Following SRP will make your code easier to maintain in the long run and will increase reuse possibilities. Once you assign multiple responsibilities, you will have to have the same set of responsibilities in another project if you want to reuse the class. And the chances for that are smaller than for single responsibilities. 

A slightly different way of writing the same list comprehension Paul Martel used. Many Haskell programmers prefer using map, filter, &c. directly; doing so, it would look like this instead: 

The module is imported qualified to avoid name clashes with various list functions. I've also renamed to to be more explicit about what it represents. 

I split into two functions--one that does a single turn, and one that loops until the game is done. This doesn't really change anything, but makes it easier if you want to have more complicated interaction than the same loop every time. The complete program using , along with some other minor changes I made along the way, can be found here. 

Converting the game state functions to use . They're much simpler this way, and some functions I've eliminated entirely. 

Here I've replaced with a smarter function that makes sure the requested heap number is valid, and returns the number of objects as well. 

There's no reason for to take an , so I've removed the superfluous and binding steps. This also allows using guards for the check, removing the conditional expression. 

As Paul Martel did, I've separated the string representation of the board from the printing. Note that is simply , so replicating suffices. The use of here is because of using rather than . 

No. Having many small classes is perfectly fine. It's a matter of appropriateness though again. I found it helps to keep things separated and small. However, it also gets harder to visualize the code flow in your head then the more classes you add. 

That gets us right back to the first question. If we assume User to be a class holding business logic, then technically, putting the db access into the User is a violation of SRP. However, when the impedance mismatch is small or doesn't exist, then using an ActiveRecord'ish pattern might be practical. So check how much impedance mismatch you have. When you notice your User to turn into a ORM, consider using an ORM instead. The other option would be that your User doesnt have any business logic and is really just a Gateway to the storage engine. Then it's okay to have db logic in it. It just shouldn't be called a User then though. 

A good general set of rules to follow is GRASP. Another easy test is to look at what the class does and then check that the name matches that what it does. Your User apparently loads things from the database and checks passwords. Not exactly what I'd expect from a User. 

Your functions will need to accept either a completion callback or they will need to return a promise because that's how the caller gets completion and error information. 

Here's how you could use a table array for the widths. I didn't fill in all the character widths (I just did lowercase) because it's tedious to build, but you can extend it to contain all the typeable characters that you want to support. I also made it a jQuery method that you can call like this: 

This mostly seems like a layer of sugar coating that just adds overhead and doesn't add any improved functionality over what a javascript object already has. The only new functionality I see is keeping track of a length, but this is a lot of extra overhead just for that. The length could be calculated at any time on a plain javascript object. Here are the analogs to your methods: 

One potential problem I see is that you initialize the variable once at time and then you use that value in several event handlers. But the window width is a dynamic value that can be changed over time so your event handlers can be using a stale value for . You should probably be fetching anytime you need it so it is always correct. 

I've left the algorithm unchanged for now. It could be improved, as Paul Martel shows, but using lists for this purpose at all is really not ideal. I'll return to this point later. 

The function gives zero-based indexing into a list, so we adjust to account for heap numbers starting from 1. It takes an argument, as noted above. Using --or any sort of indexing into a list--continues to be less than ideal, and a sign that some other data structure should be used. I'll be correcting the spelling of "prompt" as I go, incidentally. Now, we could try the following to tidy up : 

You'll probably reinvent large sections of the standard library at various points while learning Haskell. Figuring out that you've done so is half the fun. 

It's more typical to have begin a new line, in order to clearly distinguish a clause from a multi-line expression. Using tends to be tidier than repeated , and again improving a name--for an arbitrary predicate makes sense, but here we have a specific predicate, and should indicate such. 

Initializing the game doesn't need to change much, but note the construction using , assigning specific keys to each heap by counting from 1. 

This "hides" the , and instance variables in a constructor closure so they are only accessible to methods defined within the constructor. This does not use the prototype for methods and may (depending upon JS implementation) consume a bit more memory per object, but does give you property privacy. 

My general rule of thumb is to cache a selector lookup within a given function so you only look it up once for each function invocation, but to not cache it globally. If something was being called hundreds or thousands of times in a loop, you would want to cache it outside the loop just for common sense efficiency. Caching things globally is pretty much never needed for user event types of things because the performance of looking up a few objects in the DOM is super fast when compared to any sort of user action time. In other words, you wouldn't be able to tell the difference so you might as well go with the most maintainable and reliable code which avoids unnecessary globals. 

And, you'd have appropriate CSS for a testItem span (see the jsFiddle demo for details): jsFiddle demo: $URL$ 

Having individual setters has a couple of advantages: A dedicated setter allows you to put dedicated validations for these properties. You could obviously put them in the bulk setter as well, but that will make the bulk setter large and unwieldy very quickly. You want methods to do one dedicated thing instead. That keeps them maintainable. Dedicated setters clearly communicate which properties can be set. With a bulk setter, it needs documentation or a look at the source code to learn what I can legally set. I usually don't want to look at your class code. I just want to look at the public API and understand how I can use that class. That's not to say bulk setters are bad per se. If you know folks are likely to set two or more values after another because they naturally go together, you could allow for a method. But as you can see, that's still much more explicit than a generic . Also one could argue that if you need to set arguments that naturally go together, you rather want them to be in an object of their own and pass that object then. On a side note: Your bulk setter will create properties on the fly for those keys that are not properties in the class. While you could consider that a feature, it makes debugging harder because a developer has to know the object's current state at runtime to know what properties it has. On another side note: a base class is usually a code smell. It tends to amass unrelated functionality and turn in a God object quickly. It also hampers reuse because all your classes will depend on it then. 

If you move and into an object called rather than just top level variables, you could also use a map-driven approach like this: 

Key concepts here: - get all the desired tags into a jQuery collection so we can iterate over them. - iterates over a jQuery collection building a new jQuery object containing the values that the callback returns. Note, the callback will be passed as each successive element in the original jQuery collection and the id value can be referenced simply as . - get the array out of the jQuery object that was returned so you have just an array, not a jQuery object any more. - take all the elements of the array and join them into a string with the passed in separator between them. 

In the interest of eliminating all duplicate code, here's a way to make the nested showupN pieces of code all get executed in one function: 

Then, once you've fixed the above issues, you'll find that you've hardly changed and much at all. Pretty much all you will have done is default the encoding to since everythning will be pretty much the same. I'd have to say that this module doesn't really seem worth it.