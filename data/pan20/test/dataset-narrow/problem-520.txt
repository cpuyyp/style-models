There are so many things going on, it is a bit worry-some. Also, you might want to add a space around the operator, causing the need for yet some more work. By using string formatting ($URL$ you can make it a bit simpler: 

Wow, we saved a few lines of code. If we're lucky, it's also going to gain us some performance. Next, you have . This can be replaced by (as that's how dict containment checking works). Furthermore, can be replaced by . Furthermore, you write followed by . You can simplify this to . 

The first thing I notice is the deep nesting in . Deep nesting like that is generally undesirable. We'll get to that later. Second, for the parenthesis, my instinct would be to say: "Use instead of .". But after some benchmarking: is actually fastest on my machine, so probably also on yours. (I also checked using a tuple instead, again slower than using a ). However, a more Pythonic declaration of the set would be . Regarding the regular expression and the method : it could be faster by using a compiled regex instead of using . Also, convention has it that you use raw strings for regular expressions. 

That's just my particular style, but even if you don't like mine, there should be a consistent structure you use throughout your code. 

This is of course pretty subjective, but this variable name is really, really verbose, even by Java standards. would be sufficient, or even just for these purposes. Just an opinion. 

One last note: I could have just had them all be statements as well, since each only returns and removes the method call from the stack anyway, but I find that it makes the code more readable to have s, since it means the conditionals are logically joined to the reader. EDIT: I actually had to expand the initial checks slightly. Technically speaking, given your rules, if the is passed in as , it should return , not the empty string. 

To me this is cleaner, having separated out the logic from the dicts. Though merely theoretical, I think this should save on memory usage due to there not being as much key-value pairs in memory all the time. Of course, if you still want , you should be able to do something like 

Not going into the question as to whether or not this is a good idea, I can see very little wrong with the solution. One thing I would very much like to suggest is the following. Instead of 

Ok, so we do not get a string, but a list of characters. That's what is for. Finally, we need to convert it back to an integer, we can do that using . 

You actually have no need for this since Reflection gives you direct access to methods and method signatures, as you'll see in my modified version of your code below. 

If you don't know what an enum is, now's a great time to learn. It's a very useful data structure which lets you define exactly what its potential values are. Here, it seems like your missile types are PAC-3s, GEM-Cs, and GEM-Ts, so that's what we have above. This is why object-oriented programming is so powerful. A missile is a thing in the world with its own properties, and so it is here. This enum may have been more appropriately named , depending on your preference, since technically it will hold values for multiple missiles, like the . But having this data structure set up is what will let us completely rewrite your method in just five lines. 

This makes it easier to add extra parsers, and the is no longer called multiple times. Parsing files The following piece of code is quite suspect. 

Ideally, you'd split out the parsing of the -chunked blocks from the iteration, but this is good enough for now, I think. 

You're basically asking a question, and then "What is the answer to the question?". Better to just ask the question alone. Instead of writing , you could write or . Another thing of note: the score (I assume that's what you mean with ) gets reset to each time you get a new problem statement, but the score () is only printed at the end of the rounds. That is, you have (pseudo-code) 

You should try to use consistent style throughout your code. Above, you switch between having spaces between your assignment operator () and not having spaces. What I tell my coders is that it doesn't really matter which one you use, as long as you're consistent. The vast majority of work that will be done on the code you write will be done by people who have never looked at it before in their lives trying to do maintenance, so consistency really helps. 

Constants should almost always go at the top of your classes rather than being spread out through the file. Same with inner classes, as a matter of fact: group them all together either at the top or the bottom of the main class. In general, I tend to lay out my classes like this: 

(Disclaimer: I'm not a Java-expert). Moving the tile You intentionally left this one as a black box, to keep it out of scope, I think, but I'd still like to comment. 

Better: use a testing framework like unittest, py.test or doctest. Here's how it looks like doctest: 

Now, let's start analysing the large method . First of all, we could apply the same trick as we did for to speed up the lookup for . That's going to make your code a bit more efficient. It's a tad large, so let's first talk about the branch. 

The algorithm itself. Your algorithm is also far from optimal, calculating collatz(16) several times. First, when trying to add 3, it goes 

I'll leave an in-depth analysis to the true Python experts, but here are just some quick notes: Variable and function names: As far as I'm aware, variable and function names should have words/elements separated by underscores (e.g., , ) main() function: Instead of having your functionality on the first/default level of indentation, it's good form to wrap it in a and call it via: 

This will let us set the references for each missile type upon initialization. With these references, each missile will be able to calculate its values on its own. 

Also, if possible, could you give the variables better names? The first three are fairly self-explanatory, but once you get into all your random letters, it gets pretty hard to follow what you're trying to do in your code. For example: 

I'm going to look at the code without the intermediate print statements. They expose an implementation detail, and not the end-result. 

First of all, the could as well be written , but the point is: sometimes returns 1 (and other times 0 or 2). In that case, you'd call , which is basically a do-nothing operation. In fact, I'd hope that would throw an error in this case, but I can't check your code there, so I'll assume it will happily move whatever you tell it to. Unreachable conditional? One of the conditionals in your code is the following: 

Don't know if it's faster, but at least it is more readable! And I expect faster. But the main gain might be in the next section The main loop Your code was written as 

I think the biggest thing here is that you need to create some functions and encapsulate stuff. Big Points 

That's the general principle behind getters and setters. You should be able to extend that logic to all of the other methods as well once you understand the logic. 

Break up the big multi-line message at the beginning rather than having it stretch on for 200 characters. (Purists will still say that the implemenation below has the second line too long, as the Python standard is to have no line exceeding 80 characters, but you get the idea.) 

means the previous count of a given missile; anywhere you use the infix or , it means something like "operational"; and, anywhere you use the infix or , it means something like "adjustment". 

The reason is that you copy over a bunch of items in , but not in the . Whitelisting vs blacklisting In you copy several items over using a . Why not explicitly define the items you want to copy over instead? Actually, why copy at all? Performance would be a proper reason, but then I'd suggest copying just the items that have proven to be necessary to copy (after profiling). 

And we can probably shave some extra lines off it even more, but I don't think that's necessary because now it is a bit more understandable. As for the points @GarethRees mentioned: those should also be taken care of, as it does not make much sense like this. Probably best to ask for a new code-review after you made these changes.