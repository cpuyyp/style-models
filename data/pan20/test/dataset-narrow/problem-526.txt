Personally, I would also ditch the prefix and just call this routine . The underscore holds a special place in VBA. It typically denotes either an Event procedure or an Interface implementation, so I would avoid using underscores in procedure names elsewhere. 

But now we're verging on arrow code. There are two main parts to the implementation, comparing undefined fractions and comparing defined fractions. Those sound like pretty good private function names to me. 

What happens if you add columns to your spreadsheet beyond ? You'll have to update your code to handle it. I'm thinking you can use getLastRow and offset to do this instead. Something like this untested code here. 

Are , , and zero or one? Only declare one variable per line and we donâ€™t ever have to think about it. 

While we're at it, we should take note that does not (and should not) be changed at runtime. Thus, it should be declared as a constant. 

Which is a start, but we're calling to send us to the next iteration in three different places. That's not very DRY is it? Also, some people don't care for . That's okay, we can solve those things by extracting a method to validate that it's okay to add the object to the result. This greatly reduces the amount of nesting going on here. 

As it is, you couldn't take your class and use it in a different context. Your implementation shouldn't depend on Excel. It should take some values in, do some work on them, and return them in a new form. Your class (bad name by the way) should be responsible for fetching those values and passing them to . I would recommend making its constructor take in , , , and as arguments instead. This breaks the dependency and makes it so you could use the class in a console program (or anywhere really) if you so chose. 

But, I think you made a wise decision to do so here. It reads very nicely. I think expanding the braces to newlines would have hurt a bit. What are all these magic numbers though? What do they mean? It could certainly use some constants. 

For anyone interested, the reason you can call these functions without creating a new instance is setting creates a default instance of the class. 

Unfortunately, I don't see a way to do it that wouldn't add an extra loop and given a loop would be much more inefficient than accessing the property repeatedly, I think it's good. 

I could review your implementation a bit more, but I have a more general concern. You seem to be concerned about multi-threading, yet you've exposed a synchronous API and are sleeping threads. I don't find it likely that this what you actually want, nor is manually dealing with threads very common since the introduction of the async/await pattern several versions ago. I would think deeply about whether you've actually solved your problem. You're forcing your entire application to stop and wait for to run. This means nothing else can happen until it returns at an indeterminate time in the future. If there's a user at the other end, the app will appear frozen. If it's running headless on a server or in the background, then you're merely wasting resources that could be put to better use. 

You should also throw new argument error here instead of returning a string from your function if it hits the default case. Instead of 

A player doesn't move left or right, they move a game piece A rook is not a player. A player has a rook (2 actually, but I digress). 

Extract the fixtures into fields and create a routine. If you need to change them later, then you have a different fixture and should create a new test class anyway. It helps to keep your test classes small, focused, and clean. The method is useful for getting your test to initially pass, but I get hesitant when I see it sticking around in code that's "done". I get doubly hesitant when I see it in a . 

Execute your stored procedure once, and store the result in a variable. Try to reduce the layers of nesting. You anytime you reach for cntl+c, stop and consider how you could reuse that particular piece of code. 

Assert statements They're awesome. I should use them more myself, but they're not always appropriate. Let's start with when they're appropriate and then look at how you've used them. Assert statements are fantastic for internally checking conditions during development. They get compiled away in our release build, so use them liberally anywhere we need to check a precondition... internally, in places where we have direct control on the input and if conditions don't meet our expectations, something is wrong that the dev needs to look into right now. When I say internal, I really mean internal. I'm not up to speed with Java's scoping keywords, but in C# this would be in private, internal, and (maybe) protected methods. Anytime we're in a public method, we need to be a bit more robust with our argument checking, because we have zero control over what the client hands us. So, back to how you used them. 

Which is hopelessly confusing because the second call is actually starting the . Consider renaming your private field. The chained calls in main are also confusing. I'd recommend an intermediate variable to clarify it. 

I was inspired by Processing a list to build an IP in String Format to reinvent the wheel a little bit and play around with explicit struct layouts. You see, an IP address is really made up of four, 1-byte numbers. Each Octet of an IP address is one byte. So, this means that an IP address can be represented by either 4 bytes, or a single 32 bit unsigned integer. In other words, this is why the "largest" IPv4 address is . 

I'd introduce another variable, but I'm having a hard time thinking of good names at the moment. I'd also consider extracting the logic into private methods to clarify the intent. It doesn't matter that you're unlikely to ever call them from anywhere else, some well named methods can really clarify what code is doing. You can always look inside them if you're interested in the implementation, but at this level, I don't care how we're calculating these numbers, I just care that we are. 

You seem to be making the assumption that any string containing a period or comma is able to be parsed into a double. How will your code react to me sending this string into it? 

If you replace with the more standard name, you could get rid of the comment saying . I think it just reads more naturally that way. Give it some breathing space around comments too. Removing comments like is also a good idea. 

Unfortunately, I don't really have time to draft up an example at the moment. I hope this still helps. 

This would be perfectly fine if you distinguished the field by using the keyword or an underscore to make it look different from your methods. 

The "Happy Number" code is tightly bound to your main routine and user interface. As it is, you couldn't take the code and plug it into another program. It would be best to break this code out into its own class and call it from . 

I love that this is sealed. That's great. Security sensitive things should be sealed. But again, storing a for the life of the class defeats the purpose. Now you're at the mercy of the garbage collector. When you do need to access the actual value, you want to make sure that the unmanaged copy is removed as quickly as possible. Here is an example implementation that I submitted to the LibGit2Sharp project. 

If for some reason that doesn't work, I would recommend switching from to . The latter forces you to assign some value to the arg before the method exits. 

Naming It's standard style to use PascalCase for classes and methods; camelCase for variables and arguments. At no time should there be underscores in your names. It's not a big deal if you will be the only developer to ever touch the code, but if you work on a team or expect to open source the code, it will be important to code in a style that other C# devs expect. For more information, please see The Official Microsoft C# Style Guide. 

Speaking of method names, I really recommend method names. It distinguishes them from variable names. 

Ultimately I realized there's never actually a need to check the flag, so you could probably just drop the Enum and change to a Boolean with a default value of . Abstracting this to work on columns instead of rows is easy. The logic doesn't change at all. You just call it with the row number passed into the column argument and the column number passed into the row argument. So, really, naming the hard part and I'm drawing a blank on any actually useful names, but for the sake of giving an example... 

While your function does not break my Single Screen Principle, I do see an opportunity to clarify it by breaking it down into a few distinct functions. Keep in mind that VB6's operator does not short-circuit. This means that when checking to see if is not a number, the code will evaluate both calls every time. So, first, a quick refactor to resolve the slight inefficiency. 

Well done right there. All too often there is no documentation about what references a piece of code needs to work. Someone will thank you for that someday without a doubt.