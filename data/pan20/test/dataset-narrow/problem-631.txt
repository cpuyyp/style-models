You can avoid use of by using as the key type in the for keeping track of occurrences of elements in the container. 

Suggestion 1: Create a separate function to get user input I would put the code to get user input for and in a separate function. Also, add the option to let the user quit the game if they want to: 

Change to just Including in the class name does not add any more meaning to the type than simply using . With that change, you will have: 

Is an Ace is to be put before a Two or after a King? Is an Ace of Diamonds to be equal in ordering to an Ace of Clubs? Is Two of Diamonds to be less or greater than Three of Clubs? 

Non-symmetric class names You have and . You should have either and or and . I think it makes more sense to change to rather than change to . Duplicate member variable You have as a member variable in as well as in and . You should: 

in a .h file. In brings the entire namespace into the scope of any file that s the .h file. If you need anything from the namespace, just use them explicitly -- i.e. use instead of . Use for member variable. I agree with @kraskevich that you should change the member variable to 

You are forcing the user to construct a temporary object before they can use the allocator. It will be better to leave to do couple of things and do them well. Allocate memory when needed and deallocate memory when it is destructed. You can let the client classes use to implement and . I would add a function template that returns an . 

When you read the numbers, make sure that the user hasn't entered a number that is beyond the suggested range. 

FWIW, your function has a bug. If you change the input string to , you will notice the problem. The reason for the bug it that the null character is neither a digit nor an alphabetical character. Here's an updated version of the function that fixes the bug. 

I would encourage you to change to use for its coordinates instead of . However, I have a hunch your program is getting killed by too many creations and deletions of in . I would update the function to not create at all by moving the logic of to . 

You have many functions, none of which are . All getter functions should be made member functions. The idea behind objects and member function is too long to be included here as an answer. More can be found at Wikipedia and other resources on the web. Briefly, when an object is declared , it is meant to be read-only. When a member function is declared , in that function, the object on which the function is called is meant to be read-only. has many functions even though it doesn't derive from any base class and it is not a base class of any other classes. I would remove the specifier from those functions unless there is a need for it. 

It's not used anywhere in your posted code. It's not clear what the purpose of the macro is. Unclear purpose of macro You also have 

No need to use an array for The value is read and used inside every iteration of the loop. It can be a simple . Not only that, it can be in the scope of the loop instead of being in the function scope. 

My suggestions: Don't use to compute the power of an integral number Floating point math can lead to errors since they are not guaranteed to be precise. It will be better to create a version of that works only with integers. The following should work: 

A general physical layout guideline: Put all members, functions as well as variables, first, followed by members, and members at the end. You want users to see members first, followed by members. Hopefully, they don't have to see members at all. I added white spaces around functions to make them more readable. 

My suggestions: Move from being a public member plays an important role in the event manager. Making such a crucial part of the event management system a publically accessible member variable seems risky to me. I would make that accessible only as a member function. 

First of all, I would change to . is the better term to be used as a super-class of , , etc. When I think of the Strategy Pattern I think of a set of concrete classes that implement an algorithm. While your use of provides a mode of transport to its users, I think use of something like would make your example more appropriate to be called a user of the Strategy Pattern. 

can easily be implemented without the construct if has a function, such as , that returns the right object. 

There is no need to return a . It can be just . If you want to return a , you need to change the statement to: 

You have most functions named consistently -- with a verb as the first term -- except . That should be changed to . 

That works for small and short lived projects but quickly becomes a problem when the types of errors you have deal with keep increasing. s are best when the enumerators are fixed for most part. For example, you can create a simple like below: 

Using as an argument type` I am not a fan of using as an argument type. Just works without any problem. YMMV. The line 

This is a oh-so-weak suggestion. I would change to . If you do that, the implementation of would be: 

Considering that you had 15 minutes to implement the class, I think you did pretty good. I have the following suggestions in addition to those offered by the other answer. Store both the value and the minimum value in 

You don't need the variable. The variables , etc. should be , etc. The type of can be . I also think that is a better name for the member. 

You can use the former syntactic construct by providing and non- versions of user defined conversion operators. 

Make a of does not need to be exposed to users of . It's best to make it a of the class. Don't hard code as the sole target to output It will be better to provide an function to output . 

I would change to work with a functor type and use a traits approach to deduce the return type and the argument type. 

which is used only in . I would move the global object to an to be local variable in the function scope. You also have: 

You will be able to avoid one call to by returning from the function or breaking from the loop when . Of course, you don't need to check whether in that case. 

This does not sound right to me. If you ever decide to create a set of s or sort a collection of s, I assume you are going to rely on this function. In order to sort a collection of s, you have to answer the following questions: 

These lines are in a function that has as return type. These also produce compile errors. They need to be changed to: 

In addition to all the helpful suggestions made by others... Using a console interactively to get input is so old style!! It's more convenient to have the input data in a file and just read them directly without the lines for the prompt. Just use: 

My reason for recommending this is that it is possible to overload the addressof operator, . If that were the case, 

Suggestion for physical layout of members A user of the class is most interested in the section of the class. They are least interested in the section of the class. Ideally, we would like to hide the section of a . Hence, it makes sense to me to move the section of the class to the top of the class and move the section of the class to the bottom. 

to test the code. Change to just after the has been introduced The part of becomes redundant since is now a . 

which will print the values using an index that is off by one. I would recommend converting the loop to a loop: 

I think this not only avoids code repetition but also uses the right abstraction in the computation. 

A matrix multiplication algorithm usually involves three loops. The fact that you are using two loops and use some obtuse logic to reset indices point to unclear thinking on your part. As a matter of fact, there is an error in your logic and is easily exposed if you allow for multiplication of matrices that don't result in square matrices. If you change 

Decide how to deal with use of If you use , the function will always return . For that use case, there is no way to tell whether a function returned with success or failure. One way to deal with the problem will be to prevent use of using . 

For the sake of naming consistency, I would change the class to . I would put the declarations of the classes in three header files - User.h, Display.h, and Timer.h. I would move the implementations to User.cpp, Display.cpp, and Timer.cpp, respectively. I would put the declarations of all the helper functions in a .h file (call it tileFunctions.h, for example), and put the definitions of the helper functions in a corresponding .cpp file (call it tileFunctions.cpp, for example). Reduce objects in global scope You have 

My suggestions: Use a to define the classes/functions for the game Using s is good way to contain all the classes and functions that help define the game. 

I tried the following change to your function. It does not use . It does the tokenizing in the function itself. I got a little bit of speed up. 

Time complexity is not \$O(N)\$. It is \$O(N^2)\$. When i = 0, the number of swaps is N. When i = 1, the number of swaps is N-1. ... when i = N-1, the number of swaps is 1. Total number of swaps is \$1 + 2 + ... + N-1 + N = N*(N+1)/2\$ Use the following updated code to verify the number of swaps. 

Separating the data involved in the program to three distinct abstractions makes it easier to understand the code. It allows the program to be divided into smaller chunks that are easier to understand. From a functionality point of view, it is better to divide the functionality into two main functions. One can independently implement them and check them for accuracy. Construction of the set of equations is separate from solving them. One can implement the code to parse the set of equations without solving them. The parsing code can be verified for accuracy before passing the parsed data to the solving function. Solving the set of equations is independent of the method to construct them. The function to solve a set of equations can be implemented and tested with a set of hard coded equations. Once both functions are independently tested and verified for accuracy, they can be combined very easily. Here's my implementation that captures those notions. 

could potentially be different and incorrect. Both methods will work equally well if is not overloaded but only the first one will work if it is. 

That is probably my personal preference to keep functions as simple as possible and build from there. Suggestion 3 Use of to store the number of entries in the file seems a strange choice. Most of us are used to using as a looping variable. I would recommend using or instead of for keeping track of the number of entries in the file. 

Remove the explicitly defined copy constructor. The compiler generated copy constructor will work just fine.. You'll need it since you have an overloaded templated constructor. You can simplify the logic of rounding. 

The reasons for failure is ever expanding in real world projects. It's best to capture the different types of errors through simple class hierarchies. Example: 

That will make some of the functions simpler. BTW, you have a memory leak since you are not deleting the stack of minimum values in the destructor. Replace with Use of 

I would go with . The fact that it is reference counted is evident from the goal of . Provide a version of the function The current version of is a non- function. If a function has a object of type , it won't be able to use the function get access the contents of the object. You should provide a version of the function.