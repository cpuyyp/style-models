A couple of years ago I wrote a pair of class templates to encapsulate specifications which have one or more of a minimum, typical, and/or maximum value, e.g. on a datasheet like this one for the 741 op amp: 

Alternative solution I would map each character in the two strings to the number of times it occurs. If all the characters in one string are present in the other (the two maps have the same character keys) and all the characters occur the same number of times, then the strings are anagrams. Once you've built the strings' maps you can use to check that the two maps are equal. Here's a demo: 

Check your inputs in You don't check that the user entered a valid vector index. For example, if I enter a as the row and/or column number the program crashes. You should reject an input if the user enters an invalid row and/or column number (like you do if the user selects a space that is already taken). All control paths of should return a value You only ever in . If none of the check conditions are true then you should explicitly at the end of the function. Use the correct type for indexing You have for loops like , which compare the signed integer to the unsigned integer . Use . Use a type alias / type definition for the container Use a type alias like if your compiler supports it, otherwise use a type definition like . You can put it after the statements so you can use it for all your functions. This is useful for a couple of reasons: 

I'm looking for suggestions regarding the class design, naming, etc. Also, a few specific concerns that I'd appreciate reviewers to comment on: 

Note that it's better to use instead of to check if a character is whitespace. If you need to count how many times each character occurs in the string, simply replace with a which maps each character to the number of times it occurs (as shown in @TobySpeight's answer). 

, , , and are only defined if can represent the ratio, and indeed on my system they are not defined. Is there a way for me to detect when those types are defined on the system so that I can provide conversions for those types yet avoid compiler errors when they are not defined? Eventually I plan to expand this library to support additional types, not just . Are there any issues with this design which will cause problems when I add this support? The SI symbol for "micro" is really "µ" but I'm using "u" for simplicity (and since the character type of is ). Since I plan to expand this library for wider character types, is it possible to determine if "µ" can be represented properly for a given character type? 

1 When I played with the private inheritance solution in the demo program's I discovered that Intellisense shows all of the underlying container's member functions despite the fact that most of them are inaccessible: 

Not only is this an opportunity to refactor that code into a function, but the numbers and (arguments to here) appear multiple times in your code with the same purpose. Instead, define a constant (e.g. ) and use that constant. This means that if you ever want to change that value you'd only have to change the value of that constant once (the value of the ) instead of trying to find the literal all over your program. Use meaningful comments Your functions are commented as so: 

End the loop with Instead of ending the loop with , it's more idiomatic to use . It requires less typing and avoids an unnecessary subtraction. 

You could do the same with the code that acquires the expenses inputs (in fact, you could write one function for both). Don't use magic numbers You've got a lot of repeated code like this: 

But there are a lot of instances where needs to be replaced. At the very minimum you should define 4 as a constant and use that constant in the code: 

I like the way this turned out despite the fact that there's some extra typing compared to the private inheritance solution:1 

I'm looking for suggestions to improve any aspect of the code. In particular, I'm looking for suggestions to improve my use of C++11 and C++14 (I'm compiling with Visual Studio 2017 but most of my C++ experience has been with a C++03 compiler). Also, some specific questions: 

Avoid It's a security risk, not portable, and introduces unnecessary overhead. Variables should use the proper types The return type for is (which is usually an unsigned type), so that should be the type for , not . Similarly, should be of type because: 

That code required me to re-invent the wheel a bit since I was using an old compiler, and I had not discovered / yet. I've re-written that code to use a single class template called , C++11 and C++14 features, and or . I've also included some additional utilities (inserting a into a , clamping values, computing spec limits based on a value and a % tolerance, etc.). I have not added yet support for guardbands as in the previous implementation, but I plan to do so later. Here is the implementation using . My compiler is Visual Studio 2017 (which can use C++17's ), but I'm only using C++14 features in the project this will be used in. I've provided commented-out code below to use instead: 

Use more whitespace in your code It's difficult to read code like . Instead, use more whitespace as in . 

Check the length before sorting It takes constant time to determine the length of a string but is \$O(N\log(N))\$. If the lengths don't match then you don't have to sort. 

you are comparing it to on the line . The two variables should both be unsigned for proper comparison, and preferably the exact same type. you are using it as the argument type for , which uses as the argument type. 

I would still avoid On Stack Overflow, I once saw an even shorter program which failed to compile due to -- the programmer attempted to define a function which conflicted with . Your program may have less than 100 lines of code, but that just means there aren't too many instances in which you have to qualify a name with . Plus, it's best to get into the habit of not using for when you write longer programs. 

These two structs hold the same categories of data, just that one holds budget data and the other holds expenses data. You can just create one (called, e.g. ) and use one variable of that type for all the budget data and another variable of that type for all the expenses data. Using one for both reduces the amount of code you have to write and, more importantly, reduces the risk of bugs if you need to add or remove categories: instead of having to remember to modify both of your structs you'd only have to modify the one struct. Similarly, you have a lot of code like this: 

Can my solution be improved? Are there any C++11 or C++14 features I forgot to use that would improve it (I'm compiling with Visual Studio 2017)? Is the name for the container a good choice or is it too similar to the objects it contains? Also, I've made the constructor private and deleted the copy constructor to try to make sure only a can construct a and nothing can copy one -- are there any other ways to construct or copy a that I've missed? Is it a good idea to prevent construction/copies or is it unnecessarily restrictive? 

I would take a different approach to solve the problem. With your approach, you have to iterate through the string at least once to sort it (step 1), then again to remove the whitespace (step 2), then a third time to look for duplicates. If you copy the string in step 3 that's yet another iteration. You only need to iterate through the string once. Here's one way to do that: Iterate through the string's characters (skipping the whitespace characters) and put each character in a if you haven't encountered it before. If you've already encountered it (it's in the ) put it in a separate of duplicates. Once you've iterated through the string's character's once, you can iterate through the set of duplicates to print them. Here's a demo: 

Your comments could use some improvement Your code doesn't contain many comments, and it would be helpful to see more of them. For example, it's not immediately obvious why there's a separate function to delete the head () vs. a different position (). You should add comments to explain the requirements of the different functions. Even if you know why you have two different functions today, you might not remember if you look at the code again in a month. Some of the comments you do have aren't very useful. For example: 

While it's a good idea to provide documentation on the parameters for your functions, these comments as is are not helpful. They just take up space and are distracting -- after all, I can see the names of the parameters just a few lines below the comments. Instead of simply listing the parameter name, provide some explanation of what values it is allowed to take (e.g. should be between 1 and 12, inclusive), what happens if the parameter value is not valid, etc. 

While a minor annoyance, this seems further evidence to me that the private inheritance solution should be avoided even if it is temptingly compact. 

It's a shorter name for the container. This comes in handy when referring to the container and/or its , for example: is shorter and easier to read than . It's easier to change the container. You may decide later to use a instead, in which case you only need to modify the statement rather than all instances of . 

Pass strings to by reference You are passing the arguments to by value, which means you have to copy the strings. That function doesn't need a copy of the strings nor does it need to modify them, so you can pass them as references to avoid the copy: 

Avoid This can cause name collisions because it adds every name in the namespace to the global namespace. For a small program like this one it's unlikely that you'll run into any problems (then again, maybe not) but it's best to get into the habit of using the prefix on names in the namespace. Alternatively, you can introduce using declarations like to add specific names to the global namespace. Avoid in favor of flushes the stream, which can cause a loss in performance. Don't reinvent the wheel Since you've tagged this homework you may be required to implement a linked list as part of the assignment. If not, however, you can use with your struct or something similar as the data type for the (you'd be able to remove the field of the struct). Here's a basic demo of what such a contacts list would look like: 

Now I just need to change the definition of once to use a number other than 4. Use to enforce the condition that \$N > 1\$ If your compiler supports you can ensure that \$N > 1\$ at compile time and cause a compilation failure with a simple message to explain the problem. Function template The multiplication algorithm is basically the same for any \$N > 1\$, so this function is a good candidate for a function template based on the dimension \$N\$. For example, you have with , but in the same program you could have a matrix (2D array) with and the same code is used to multiply with both matrices. Here's a demo using a function template: 

For the conversions, is intended to be specialized by users if desired for specific time periods. Here is a little demo program demonstrating the conversions and a specialization of for a time period corresponding to a day: 

Good job breaking up the logic in into different functions. However, some improvements can be made. Avoid This can cause name collisions because it adds every name in the namespace to the global namespace. For a small program like this one it's unlikely that you'll run into any problems (then again, maybe not) but it's best to get into the habit of using the prefix on names in the namespace. Alternatively, you can introduce using declarations like to add specific names to the global namespace. Make your code more re-useable / Don't Repeat Yourself (DRY) There are places where you've written a lot of code that does essentially the same thing. For example: 

Avoid This can cause name collisions because it adds every name in the namespace to the global namespace. For a small program like this one it's unlikely that you'll run into any problems (then again, maybe not) but it's best to get into the habit of using the prefix on names in the namespace. Alternatively, you can introduce using declarations like to add specific names to the global namespace. Avoid in favor of flushes the stream, which can cause a loss in performance. Declare variables in the most local scope possible You declare at the beginning of but you don't actually use it (and initialize it to 0) until you're inside the loop. It's better to simply declare and initialize it in the same place and in the place where you start to use it. I would also rename it to be more descriptive (e.g. or ). Avoid hard-coded numbers Your code works with \$4\times 4\$ matrices but you've got hard-coded all over the place. You say