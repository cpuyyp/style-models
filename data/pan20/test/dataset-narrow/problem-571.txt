You have a compile error since has 2 identical methods; I assume this is a copy-paste error and the second should have instead of as its parameter. 

By taking as a parameter, we make it so that we don't need two separate utilities for sorting ascending vs descending. The user can specify they want to sort descending by passing in . 

Note also that pointers need to be compared using , so you should probably specify the value type ( compares using ): 

I know that, at this point, this removes the ability to use member functions at all, but we can use to remedy that: 

Everything is static. You could be using Object Oriented Programming, but you are simply using static functions and variables in the main function. Better would be to have a class which you instantiate (preferably to the initial state of the board). Something like this: 

It might even be better to forgo the operator altogether, as with this operator, you might have , but because the is different. This breaks some expectations. You were defining the for use with a , but you could just as well define a comparator struct. 

What is this? How am I "moving from the most significant digit towards 16^0"? Oh, you must mean "iterate over the digits, starting from the leftmost". 

You can expect your reader to know this. We all know that hexadecimal is 0-9 then a-f, so just leave this comment out. 

Yes this is bad form. A operator or a operator already stand out enough; if they are not, then your code is too complicated. This is easy to miss: 

You might notice that this removes the need for the comments. The name of the function makes it clear that means that empty strings aren't considered plural. Do note that you should use as a more descriptive function for what you are doing. 

For fun, I implemented a trampoline function for C++ functions, since the recursion limit for functions is much smaller (500 by default on gcc). It is a bit messy with the type deduction and the fact that the trampolined function must only take a as its argument. 

Don't implement all the functions in the header file. Instead, create and implement the functions in there. 

Extracting out the into a variable is fruitless. Also, the naming convention googletest uses is PascalCase for test names (IIRC). Finally, you should use a more descriptive name for the test. Finally, there is one real problem with your unit tests: You never test negative numbers. When you test your code, keep in mind equivalence partitioning. Basically, just split the input into ranges and ensure you test something from each range as well as edge cases. In your specific example, the class consists of two s. A is approximately a real number. The reals go from , so the natural ranges to split into are the negative and positive numbers. So I can partition the interval into: 

This can be made much cleaner with the use of a . It might not be the most performant way, but it's fast and easy to use. 

To me, the main problem with this design is that it is so easy to use wrong. Any class caching a static copy of the singleton will make the unit tests fail. The unit tests have to go blindly in and assume that there are no offending constructs anywhere. It might be a better idea to just have a which resets all the data stored in the singleton that the unit tests can call in the tear-down method. 

Along those lines, you don't need a comment if the function is named well. For example, these two functions' comments: 

I'm assuming that in OpenGL.h, you have . Don't do this. It is especially bad in a header. Also, if you find yourself using globals, you are almost certainly doing it wrong. These should either not exist at all (as in the calling code takes care of it), or they should be wrapped in a that the calling code passes around. These globals and the following point out that you really need to define a class. Maybe something like this: 

Returning a is fine IMO, but there is a caveat: you must not let the reference live longer than the object. Things like this will be invalid (I think, but at least it's questionable whether it's valid, which is a problem): 

However, if you don't want to use at all (this is generally a bad idea, but for programming practice, you might want to), notice that . Thus, for every 1.5 hex digits, we can obtain 1 base 64 digits. So take the last hex digits of the hex string: . In binary, this is . We only need to consider , which is . So we take the 45th element of the base 64 alphabet: . That's the last digit of the base 64 string. Now just shift the hex string over by 6 bits, and repeat (note, shifting by 6 bits won't be clean, so it's probably easier to instead process 3 hex digits to 2 base 64 digits, and take off the last two elements of the hex string). But noticing the "Cryptopals Rule": 

Your implementation of is doing way too much work. There's no need to recurse at all, you can simply do: 

variables are initialized to IIRC, but there's no harm in just adding the to make it clear what the initial value is. Also is an odd name for a variable that is not temporary. 

While exploring Boost Spirit X3 (documentation), I noticed that I couldn't find a parser directive that composed parsers. I dug through the source code to see how the existing directives were made, and built one. The idea is to have a parser with an attribute that can be coerced to , and a parser ; would run on the output of . I'm a bit worried that I re-invented the wheel, or that what I did goes against the spirit of Spirit X3. I'm also worried about the efficiency or usability of it - I use internally, which might also make error handling hard. compose.hpp 

At this point, there isn't more that I can say other than Louis Dionne's answer is much simpler than your solution: 

You are working too hard. Java has a Base64 class that does most of the work for you, all you need to do is combine it and the constructor for BigInteger, and you are done. 

If you don't own OpenGL, I'd recommend not naming your namespace after it. If they release OpenGL in a namespace, your code wouldn't be compatible. Try to use a namespace for your project. Similarly, I'd recommend not naming your header OpenGL.h, unless you put the header in a directory. 

In and , you return when the request cannot be met. However, this is a little bit unclear. I'd recommend instead using and as your return types so you can just do this: 

That is ... quite the constructor call. If you have six arguments to your constructor, one of the following is probably true: 

This function isn't actually converting base 16 to base 10. It seems like it is, but that's not really what it's doing. doesn't store its data in base 10 format, so this function would be better named , or something along those lines. 

This is because wouldn't know the width of the frame otherwise, and you'd get an off-center window. Except you appear to be trying to maximize the window, which is better done like so: 

Alternatively, you could use at the top of the file, although it is theoretically less portable. Leaking namespaces 

You aren't actually consuming ; that is, you don't take ownership of the vector (you wouldn't be making a copy anyway). This is a sign that it should be a . As a general rule of thumb, make function parameters unless you would be making a copy of them, then take them by value: 

However, if this is going to be called hundreds of thousands of times, the method might be faster, though you should encapsulate those into their own functions. You'd need to profile to be sure which is faster, but I believe it would be this because uses regular expressions: 

Calling main() is undefined behaviour It is not legal to call in your C++ code. You are using this to loop; you should instead learn how to use loops. This is one example of how to do so: 

Similarly, Java 8 code is not meant to be formatted like that. Regarding the concern of colleagues formatting away the line breaks, you could add a comment explaining why it is like that. But poorly chosen IDE format settings could still interfere, unless you did something like this (this isn't good in practice, though): 

Do note that this will likely lead to a virtual table lookup at runtime, unless you instead declare the in the header file and define in the header file: my-singleton.h 

If the user wanted to sort descending, they'd have to use . That does require that an is defined for their type, but they can always define their own comparator that defines a greater-than by using 

Also notice that I used the member initializer list for the constructor; it's good to get in the habit of doing so. The benefit of this code is that it is now difficult to get the memory safety wrong. If I wrote this function: 

This code should not be moved into its own function as it's highly specific to this location and refactoring into a function just seems useless. Don't do this for the Java 8 code. In all honesty, separating each call into temporary variables is probably cleaner than making new functions for everything. Additionally, formatting the Java 8 code across multiple lines isn't "relying on indentation and newlines" any more than the other code example is. Try reading this: 

Firstly, I recommend you format your code. In Eclipse, the shortcut is CTRL + SHIFT + F, in IntelliJ, it is CTRL + ALT + L. This is because of the following: 

is an implementation detail and does not need to be on the interface to this function. Also, note that you take a as your first parameter. You are effectively defining a member function on . Why not put it there? 

and are only used to initialize your s. They don't need to be member variables. The names and are not the best. First, what does "rpt" mean? Repeat? Report? Ramco-Gershenson Properties Trust (that's what comes up from a Google search of "rpt")? Second, it's hard to use in an English sentence: 

This is a nice first project. Since you are a beginner in C++, I'm not going to worry about the and a couple other details. Naming Your functions follow an inconsistent naming style and are not spelled correctly: 

While we are discussing iterator categories, it's useful to name after the iterator category you require, so or would be better names.