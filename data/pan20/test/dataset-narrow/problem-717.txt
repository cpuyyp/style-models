Another point is that you should have a symmetry in creating and closing a resource. Your LogService is now responsible to close the Writer but it doesn't create it. Either you provide a factory for the resource so the LogService is responsible for creating and closing it OR the user of the LogService that passes in the Writer should be aware of creation and closing. Nevertheless the maximum proximity for those operations is the goal. State handling Currently you micro manage the state handling (running/stopped). You should consider implementing a real state pattern as a great concept to make clear when which method is allowed to be called. You have some semantic things I find confusing. Logging is allowed only when the service is not stopped but you may always start and stop the service. Thread interrupt Your thread should not be stopped through the interrupt method. Try to reformulate your communication with the thread to stop without using such harsh mechanism that throws an exception. Restarting You do allow starting the loggerThread although this will cause an exception. I would expect either NOOP or a domain specific exception as the caller is not interested in a thread specific exception. Should the caller even know that a thead is working? Another possibility is to start over with a new thread. You already handle state so the obvious functionality for calling the start()-method on a stopped LogService is to start it again. Personal opinion As this is I would trust neither one nor the other implementation as they are riddled with semantic ambiguities, concurrency issues and micro management of state. I suggest to rethink the concept with real state handling and a proper monitor definition. Code State The state pattern will cover three methods: 

The trick is to use the factor 0 to wipe out the summands not needed and to keep the important summands with -1 or 1. For the other methods I think it will be much more effort. But it's worth a try. 

If you do not need to have control over the amount of threads used to perform the work, you could consider parallel streams and you are done with these simple lines: 

This parser searches for numbers and returns them. Whitespaces separate numbers as whitespaces are allowed to occur multiple times. If you input alphanumeric characters the machine goes into the Error-State. The main point is to avoid nested if-statements and have clear responsibilities during parsing. Furthermore your solution lacks extendability. If new requirements occur the state pattern helps you to manage them in a well-defined way. First I suggest to have a state chart. UML state machines are appropriate. 

You currently managed 1. and maybe 2. and you scratch at 3. But you are totally stuck at 4. Sometimes programming language mechanisms are overwhelming and it is difficult for beginners to apply them properly. As you are using Java I guess you want to apply the OO programming paradigm. So that will be my assumption. I have to say I had a hard time to figure out what this code is doing. And I think I did not get in in the whole until now. Without to insult but this could be considered as spaghetti code as input can happen everywhere and output can happen everywhere and the control flow is hard to grab. You mixed a lot of concerns while they should be better separated. You have global variables and less meaningful names. Identifiy responsibilities For each element in the usecase "Calculator with history" you should have a proper representation, a code fragment that is responsible for exactly one task AND is able to provide inner consistency (isolation and encapsulation). The general responsibilities in every program: 

Solution 2 The following solution is a summary of this discussion with some modifications to improve readability. It uses the binary search approach for efficiency and speed. Personally I am not that convinced of it because there are some specifics about Arrays.binarySearch(..) in the case of application and interpretation of the return value. The return value can hold (as far as I understand) up to two things. In the normal case (key was found) the index of the (any?) key is returned. In the case when the binary search returns a negative value it is considered as "not found". Furthermore the value can be multiplied by (-1) to receive an insertion index. Finally you have to decrement the insertion index by 1. 

After that we can start to produce elements asynchronously that will be registered in the "elementJoiner". You see that there is no difference in formulating the element source for the "other" and the "http request". 

I suggest to have ready parsed parameters that will be given to the function and not let the function itself parse its parameters. Separate following concerns: 

First implementation should be straight forward without thinking about bottlenecks After that you may think about unneccessary recalculation and go for enhancements without touching the implemention of 1. 

Within your anonymous functions you parse parameters: "input.nextCharsUntil(Predicate)" Within the "A_RayCode.run(int index)"-method you are parsing bracket contents Within the LoopCode you prepend parsing in the overriden method "run(int index)" before you call super. 

The second responsibility is a char sequence. CharSequence in this case is a class that wraps a StringBuffer to fit the needs of taking chars from the beginning. 

Everything else should be subordinated and follow this semantic because this is what you want to express. The artifacts expressed above formulate the first responsibility (SRP). So my suggestion for the top level code: 

There is only ONE problem that will be hard to eliminate because I assert that "ByteBuffer" is not within your domain. And this problem is not related to redundancy in the manner of duplicate code. The bytes read can be derived from the method called: read(address, 4).getInt(); So if you have any possibility to use "4" within "getInt()" then your code improves a little bit. Maybe extract the magic numbers as constants. Everything else you assume is of an error type 2. Assuming redundancy where there is not redundancy and acting unnecessarily. So everything you do to the code trying to eliminate redundancy will introduce problems. For example: Your generic suggestion will divide responsibility into half. The caller has to synchronize the expected return type with the called method. In the original solution there is no necessity to care. Leave the code presented as it is. There is no possibility to improve it in the way you expect it. 

General This looks much better as the initiallization of every component is glued together and at one place. Adding components The components should not add themselves to the parent. The should not know the parent explicitly. Add them in the constructor like this: 

Reformulating the init-method I don't think we need the "code"-attribute in this use case neither the data-HashMap. The first thing we will do is instantiating the ElementJoiner: 

Represent expressive game elements in extra classes (Players, Rock/Scissor/Paper, Result, Situation, ...) for OOP Try to reduce case handling, use proper let structures work for you Follow JAVA conventions in Naming 

Your implementation is minimalistic but it does what it does and it does it good. Your code consists basically of three elements: 

Finally The "finally" clause is for cleaning up resources and not for continued processing. Java does not prevent your kind of usage but their are some assertions to the finally clause your code does not make use of. So it can be placed in the try-block. try with resource Use the try with resource construct when loading the properties from the file. This ensures proper resource closing. In your case "input.close()" will never be called if an exception happens before. So you will introduce a memory leak. Extract method You should separate the concerns of loading the properties and connecting to the database. Exception handling I suggest to throw all exceptions instead of handling it. Maybe you should wrap it to a custom exception that is not signature relevant (RuntimeException). The alternative you provided leaves the caller in doubt why he gets null. I guess you currently check for null by the caller when the getConnection()-emtoh gets called. Instead of checking for null you should handle the exception there where some code has to decide what to if no connection could be established. Avoid null and not useful checks I suggest to remap missing values to a type specific neutral element (e.g.): 

Having the the whole construction at one place If you use the lazy getter only you do not have to care about the creation time. You are more flexible when rearranging the components 

Comment on the builder pattern I don't think that Joshua Bloch discovered any new version of the builder pattern. I suggest to follow the standard way and purposes from the GoF. The purposes of the builder pattern are: 

The "List" should be instantiated within the method "getFiles(...)". Make directory recursion part of WordSearch through template pattern Currently you are collecting all files recursively within the main-method. Make the algorithm part of the WordSearch objects. To do so, refactor the WordSearch-Interface to an abstract class and implement the directory recursion as a Template Method. 

What's this all about? My view on this is: There is a lot of confusion about adressing the correct level of abstraction. I have two glasses to put on. The "language mechanical/technical" and the "semantic". If we talk about datastructures that support speed then we are on a technical level. If we talk about a disjunct set of countries we face the semantic level. Technically using a String would do the job for some situations and maybe these are the only situations the use case describes. Semantically you have a subject. Because the semantic is not modeled into an equivalent datastructure. Nearly every answer provided adresses this. The semantic of your String is not "a set of countries". It's "a concatenation of country names". As some answers pointed out the "vulnerability" of this approach. The reason for this vulnerability is exactly the datastructure that does not match the semantic. After all this may be not a problem if you intentionally use a structure that deviates from the semantic to improve performance. But you have to know that any deviation from the real structure goes with drawbacks. You get redundancy, vulnerability, inextensibility, unmaintainability and all the stuff that code quality decreases. These drawbacks may be jusified to the goal you want to achieve. BUT: This does not release you from the responsibility to provide the "correct" datastructure representation of the semantic as other algorithms maybe want to work on it. You should always provide a sufficient correct model of the part of the reality the use case needs. After that you can think about mapping it to a datastructure that may have drawbacks but the algorithms will work under certain metrics. So my core statement is: Beside ANY performance subjects I do not want to adress: The String will technically do the job for ONE use case. But you have to expect drawbacks in OTHER use cases as the datastructure representation does not match reality as use cases came from reality. It is a distorted model of the reality and this is expected to be acceptable for a small area but error prone for other areas. Metaphor Think about a chair and a desk. You may have the idea to omit the chair in your model because you can also sit on the desk AND you have al lot of space left to put other things there. So why use a chair anyway? Technically you could put everything on a table. Semantically a table is not meant for that because both and a chair may have properties that are not that obvious but the algorithms want to work on it. One person may sit on the table, two or three will certainly break it. One person may sit on the table for an hour but not for a whole day. You will have drawbacks if you use objects in a way that they are not made for. So the concatenated names of countries. Suggestion Not that surprising: I would go for the "Set of Countries". But if you think the perfmormance can be better with another datastructure you should map the correct representation to the datastructure that provides more performance WITHOUT touching the model that represents reality best as you do not want other algorithms to take the burden of the drawbacks. 

This process applies the Open-Closed-Principle. It helps you do distinguish the different concerns and separating them into separate compilation units. So you will also satisfy the single responsibility principle. Your first implementation is straight forward. I would go with that and derive a new class that will implement caching concerns you introduced in your second implementation. The point is: Caches always come with scope and lifetime. These concerns should not flood you straight forward implementation. Caches should be transparent to clients. The interface contract should be the same or enhanced, but never changed or restricted (Liskov substitution principle). 

The internal deque will have a special behaviour if no elements are in the queue: If no element is available it will block a certain amount of time (here 5 seconds). Either a new element was insert that can be returned OR it will return null. Abstract from Thread "this" and other threads After all the only difference between registering elements from other "Threads" (UUIDs) and registering the elements of the http request is that you perform the registration in "this" Thread (the main-Thread). You only delay registration for a second (Thread.sleep(1000)). So the task is to abstract from where elements are received. Furthermore it doesn't matter from which thread the elements come from. We have to tell one thread... 

You need a key generator that continiously produces unique keys of a certain key length that are used to shift characters You need a Decoder that will decode an encoded Text with a given key You need an indicator that your decoding was potentially successful. 

"I change the state of the view AND ... I return the state of the validation." You already give yourself the answer: Two responsibilities. This is not because of that you combine UI issues and validation logic in one method. It is because of "and". Effectively you have two results out of one method. And this is a violation of SRP by itself. The more important thing is: you coupled things that should be separated. The UI should be informed in an abstract way, for example with an observer pattern. 

Solution 1 Maybe for readability a recursive function is a proper solution in this case. But think about it carefully because it will strain the stack. 

One other thing makes it hard to determine the quality of the code: All code is formulated in a sequence, no iteration and no selection. So there is inherently no room for concerns against the control flow. You feel that this code could be better? I share your feelings but I won't argue with it. You have gone the Spring way correctly: You comply the contracts. 

There is only one thing I considered as recognizable: the dolphin among the fishes. I really recommend to handle the artefact "userCanJoinAndLeave" in the method that is calling the method "getDatePeriodtext". It seems semantically anorganic here. This relates to the single responsibility principle. Be careful with multiple return statements as suggested. They hinder you to apply refactorings like "extract" method. But in this case it may be no problem at all. I also recommend full (metal) brackets ({...}) in general. The code is trivial. So no real issue here. After playing around I came up with a totally different structure with less null checks and less string redundancy. Do not take this too serious. But maybe you get the idea. 

General The example you gave is totally fine. I won't suggest you to make "Dog" and interface or an abstract class etc. The effects on the example of one or the other are negligible. But what you really should know is that this example is not more than an excercise to understand the language mechanics of classes, abstraction and inheritance (here in JAVA). To ask for advice to get a better OO design in this case is like asking to learn gear shifting on an expensive car after you learned it on a cheap car. It remains gear shifting and doesn't make sense. Is your implementation example for inheritance/abstraction fine? Definitely. Would this be a design in real life? I don't think so. In real life you would have one class "Dog" with some properties when you think of a software for veterinarians. Properties may be the owner, the dog breed, birthday etc. An other application can be the usage in biological systematics. Although there you would not use inheritance to model all types of dogs. You would go with composition and relational objects. What is my suggestion? There is no real world application I can think of that would model this case as presented. If you have one I like to see it. As long as you haven't: Keep this example for what it is meant for: Understanding mechanics of the JAVA language. 

Here you do not have a switch-case have you? Of course you have. But it is hidden in the structure we chose and not formulated with the JAVA language element "switch-case". Another way is to let a library make the mapping decision. A good library is "Jackson". Here is the Maven dependency: 

The tryAdvance-method handles the case if the supplier returns null to end the stream. The supplier in our case will be the "ElementJoiner" which getElement-method will return null if the timeout has passed. Defining simulation data Here I harmonized the return value to be a Set.