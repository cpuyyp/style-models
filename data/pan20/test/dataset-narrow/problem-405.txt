in this case and out only parameters. and you need say to caller - which api need use for free returned buffer. 

ansi function usage. such as CreateProcessA this is very bad. windows is unicode (utf-8) system. almost all api implemented as unicode. the ansi (A) api - is shell over unicode (W) api. the A shell convert input ansi strings to unicode, call W api and finally convert out unicode strings to ansi. this is very not efficient. more bad that use ansi strings simply wrong by design. ansi code page is not invariant. it different on different systems. if you hardcode some ansi string in code, which use characters > 0x80 - you got different unicode strings after convert, on different systems. finally not any unicode string can be converted to the current ansi code page. use ansi code page for cmd is wrong. cmd use for pipe input/output not ansi but oem code page. this is different code pages. when cmd read multi-byte string from stdin file - he convert it to unicode via with . and when he output something to stdout file - he translate unicode string to multi-byte via with . so until he output characters in range you not view different. but if will be say "not english" file name in output, or you pass some command with "not english" file name - will be error - because you and cmd use different code pages for translation. you pass him ansi but he wait oem. he pass to you oem strings, but you wait ansi. also note about inherited handles - begin from vista better use also with for restrict list of handles to be inherited by the child process - not all inheritable handles, but only one pipe handle. yes one but not two as you use. 

then reallocate caller supplied buffer - this is very bad idea. for reallocate you need exactly know how caller allocate buffer. you must add to interface contract - how caller must allocate initial buffer and free final. which concrete routine use. say for example caller must allocate initial buffer with and free with . but nobody do this. usual used 2 ways: 

you not need handle this at all. return number of bytes read. and you need use it. no any difference what bytes you read. 

then look for (full nightmare) ; you all time read to to buffer begin () and never change . so what sense try reallocate buffer if you any way try read only bytes. then you all time read to buffer begin - so new read overwrite previous data. you use wrong and senseless , , instead of . for what you use before ? when you try reallocate buffer after every read ? even if still exist free space in current buffer ? on which size you try realloc buffer ? on 1 byte ?? and every time anyway try read constant to begin ?? for dynamic buffer buffer usually used 2 strategy: allocate memory chunk (usually 0x1000..0x10000 size). read to this chunk until exist free space in it (of course not all time to the begin of chunk but to the begin of free space inside chunk). when no more free space in current chunk - allocate new chunk (not reallocate existing !!) and so on. but not copy anything. when read will be completed - once allocate new buffer and once copy content of chunks to this buffer. for example. 

One more thing, I forgot to mention one other idea. If you can sort the blockers by the position (rotation), then you can use the last position (last index to moved blocker) to check, whether that blocker is still current for next frame, if not, move to next. Removing the loop cycle completely and having just couple of basic s. 

one way is class holding the actual string, responsible for manipulation with it. other way is helper utility class providing only functions, not holding any string at all. 

I also modified the code to be PIC (position independent code). This is first time ever I tried that with assembly, so I'm not 100% sure I did+linked it correctly, but the code works, in debugger I see relative addressing, and stripped binary has only about 6kiB, so looks OK to me ... and now I tried to run it multiple times in debugger, and the code address is randomized, so the ASLR works too. And fixed some of your comments. And I test return value, so now the code upon invalid input will simply output the current sum, and the program can be terminated early by entering non-integer, or Ctrl+D. 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

The initial comment: not clear what is entering (deducting it's about byte ) and I would rather use "arguments" or "input" word. Not clear the description is about bits. Not all arguments are described (the code does use also address for ). Typos. Modified registers are incomplete too (again ). Etc.. 

The Model/View relation - how I like it - can be demonstrated on this classic: Consider having blog application, so for each article you have date+time of publishing the article. Then Model should contain UTC timestamp value (can be unix timestamp, if you need only dates since 1970 onward). And View will do all the formatting magic, ie showing "5 seconds ago" for fresh article, or "previous millennium" for some really old article, also converting the date/time to local time zone of user (source data stored on server being in UTC, time zone agnostic). 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

Just one remark: When handling resources, I'd strongly suggest using for resources that are obtained at some point and later released. Not only it makes your code much safer, it clearly demarcates which resource is used in which parts. And that also prevents separating opening and closing of resources, which is often a hard-to-find error. 

(I'm making my comment into an answer.) You can separate everything that is static (not using the state of instances of ) into a companion object (and import the object at the beginning of the class for convenience). This way, it is clear what functions use directly or indirectly (by accessing class variables). This often helps me make my code clearer, and prevents stupid mistakes such as confuse class variables with function arguments etc. 

Definitely a good idea. You might later decide to internally represent the data type differently, for example in , and this way you can do it without breaking the interface. But depending on the expected usage, you might include such conversion functions. 

indexing with in the right part is wrong. I'd suggest you to create a function that converts a list into a (ideally a blanced one), and then test if indexing into the list produces the same result as indexing into the . Also the implementation of is missing, but this is a crucial part of the code, without it it can't be really reviewed. I'd also suggest to implement other operations on s, in particular creating a singleton list and concatenation, perhaps also prepending/appending an element to a list. Finally, you're using a instance for tagging the tree. This is in general a good idea, but the assignment doesn't say anythong about monoids, sobe sure to understand how the monoid there should be used. You never use the fact that a monoid in your code. If you're unsure, I'd suggest to forget about monoids at this point and use just the provided data type. 

If you don't need any user state, you can just ignore it. And the argument allows you to run your parser in another monad - is a monad transformer. If you don't need it, just use , which is exactly how is defined. You might be interested in using , a conceptually simpler parser bundled with GHC. Also this blog post about writing your own, simple parser, might be useful for you. 

And I recommend reading various ways of constructing Serpinski triangle, it's quite likely that it's possible to build one straight from the top very easily. 

SetCommTimeouts again - senseless code. this api simply send control code to device on which file open. usually only serial controller driver handle this ioctl. the npfs.sys, which implement pipes - not understand and not support this ioctl. driver return to you ( mapped to win32 error) but you not check for errors here. 

another way - use for buffer. windows let reserve memory space. we can reserve tens of megabytes how minimum. this operation not allocate any memory but simply mark memory region as reserved. then we can already commit memory to region begin. when, after read, will be not enough committed memory - we commit more and so on. advantage - we from begin will be have contiguous memory - we never will be need copy/move/reallocate memory with this way. this solution is better when we assume big enough final data. example: 

if buffer not big enough - error is returned - (in case no valid data in buffer at all) or - in case exist some valid data in buffer, but need large buffer anyway. anyway you need here additional out parameter allocate buffer yourself 

but main question - are you need Contiguous Memory buffer at all ? for what you need cmd output ? for send it to remote system, display it in interface ? for this not need. after you read some data from cmd in fixed size buffer - just display this chunk in interface or send to remote system. and begin read new data chunk. of course you need absolute another interface for this. for parsing cmd output ? for this yes - need Contiguous Memory buffer.. but we never need parse cmd output. for what ?! if say we want list files/folders - we need do this yourself but not run dir command 

interface of course also must be absolute another. here faster need export class with virtual functions. class implement cmd exec and write commands to it. virtual callbacks with read data from cmd. you inherit own class from this base interface class, implement your own on read data handler and cmd exit (disconect). some basic implementation of class: 

again bad and wrong. for what you create 2 pipe pairs ?? when 1 pipe pair only need. one pipe handle in you process and one connected pipe end in cmd. pipe must be duplex. what you write to this pipe end in self process - will be read in cmd. what cmd write to self handle - you read via handle in self process. so not need additional pipe pair. next - always need use asynchronous pipes and io here. synchronous is not efficient and can deadlock. 

Why name like ? Was it just for this review, or is it actual label? Use rather something more descriptive. 

(I would also write as , but I think the compiler will optimize that one anyway, just old habits from ASM times die hard). 

Hmmm... anyway, I really like what you wrote here: "I'm noticing that reading doesn't really help much as much as writing programs and running into issues and solving them." This is absolutely spot on. All this general babbling around usually makes little sense when hit by real world problem. Also refactor a lot. Not just the code, and implementations, but as learning is your goal, dive deep into finished project and go trough all the API, all the abstraction, and try to imagine something better, easier to use, easier to understand it's responsibilities, easier to read and get the idea and eventually easier to implement (although sometimes to get better API and abstraction the implementation can be more bloated, but the cost of bloat has to be clearly justified by the cleanliness of resulting API/abstraction). 

To get forward from this situation, there are two basic paths possible: 1) keep using HW floating point numbers This has huge performance bonus, so that's why the / are first choice citizens in C++ floating point number calculations. Usually the tiny inaccuracy of results is small price to pay for the HW boost of calculations. Then you should arrange your calculations in such way, that the cumulative error is smallest possible, and store around the values with maximum possible precision for any record purpose. You then round the value to proper number of decimal places only during output formatting, for example like to get the rounded to two decimal places in form of "string". Of course you should be aware of total possible cumulative error, and make sure it's within the acceptable level of inaccuracy for your software. 2) use other encoding of your numbers: some big numbers library One of the possibilities is to use some library for arbitrary precision [decimal] numbers (like Java's class, can't recall any C++ one from head). These encode numbers in some custom binary way (or even as string), and have their own versions of common math operations, working with these numbers. Usually imitating human base 10 number format - which is not perfect either! For example you have two forms for every integer number: , or numbers like Pi can't be written down without infinite number of decimal places. These work like charm for financial software, where human base 10 formatting is actually perfect fit, with all it's quirks and imperfections. The price is of course the performance, as each operation is emulated by several HW instructions, so even thing like simple addition may be 10-100 times slower than the HW . 3) use other encoding of your numbers: fixed math When you need only exact number of decimal places, like for example you want uniform distribution of space coordinates, you can use integers, and assign some bits for decimal part. For example 16b can be split into 8:8 whole:decimal part, supporting numbers from 0.0 to 255.99609375 (255 + 255/256), with constant 256 (inclusive) granularity between every two integer values. It may look a bit confusing at first, but these are easy to use in ASM with bit shifting (to get the whole part of number you only shift the value by 8 bits to right, to add two values you simply add them as two integers, etc). This is also sometimes used for financial software to calculate amounts with 2 decimal places, this is done not by allocating exact number of bits for the decimal part, but by simply having all values multiplied by 100, i.e. $3.59 is stored internally as integer, and when the value is displayed to human, it is temporarily formatted as . The limitation of this method is, that you have to decide the fixed precision for particular values, so it's not universal silver bullet. But compared to the big number libraries, the fixed math has performance very close to HW floating point numbers, on some CPU architectures it may be actually faster (like back in ages Intel 80486).