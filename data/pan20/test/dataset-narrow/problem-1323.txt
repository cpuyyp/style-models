If you are not using OpenGL, then most games load sprite sheets with rotation already done (see other image).. You only need a quadrant worth of rotation pre-calculated. It saves memory and you can rotate on the fly to 90/180/270 without loosing quality to cover the other 4 quadrant (going back to the first figure, notice that the grids will align perfectly with rotations of 90/180/270 degrees). 

Finally, you have the equipment which work just the same way: all defined in a file using a custom format 

So as you can see, if you are doing some scaling in ObjectB.Start() and expect that setting the scale right after the instanciation will overwrite the values, that won't work... Of course that's just one possibility, but it did happen to me a few times so that's the first thing that jump to my mind. 

Not really. How does shaders know where to take texture pixels? You must bind texture outside shader too. Basic algorithm for drawing multiple objects is: 

AFAIK not all keyboards supports multiple key presses at once or implement it not quite correctly. You must dig into it before coding. 

No free cookies. Precision is often an antonym of performance. You will need to find a right balance between them. 

Achievements (wiki). Now they are everywhere: in MMOs, Online games, even Visual Studio has extensions with achievements system. Even StackOverflow has it! =) [Kill 1000 rabits], [Win 20 poker games in a in a row], [Come online every day for 1 year], [Write over 9000 stupid answers]... They are just a pop up shiny boxes or a table in a player profile, but players just play achievements. Not sure why. You can add ranking table on a main page. Also you can make achievement points as base for another awards: titles, special avatars, badges as said Markus von Broady. 

I'm in a bit of crunch time and I find myself spending way too much time tinkering with an algo, so I would like some help. In the game I am working on, there are some old-style, pixelated minigames. One of the minigame is a spaceship in a cavern. The caverns curves and narrows down over time until the ship crashes in a wall. I want them to be generated at random during runtime. I'm having a problem creating the walls of the cavern and narrowing them while keeping a smooth curve on them. For the narrowing, I keep track of it with a variable that decreases over time, but how about the curving and how to keep it natural? I've though of a keeping a target point that goes up and down randomly and have the wall try to reach for it, therefore smoothing the randomized number but it is not working great. Any ideas/algo? 

It depends on your needs, but mostly it is a good idea to implement it as it implemented in real life: by physics! =) You can use 3rd party libraries or write your own stuff. AFAIK most popular lib now is Bullet. If you don't need all of this, just implement mass, jumping force, gravity force and use Newton laws to calculate position (so your objects will jump with decceleration and fall with acceleration with parabolic trajectories). It will look accurately for any game entity, because its like a real. 

" is not real" Floating point types are an approximation of real numbers implementable on binary machines. For example: there is a real number , however, there is no IEEE-754 floating point number that is exactly , as this value cannot be represented exactly in this system. The closest representable value is . If you are performing operations on floats they slowly accumulate some minor errors. See canonical: "What Every Computer Scientist Should Know About Floating-Point Arithmetic". See also: Wiki - IEEE-754 floating point 

I am having what is probably a newbie problem with Unity, but for the life of me, I can't find a decent solution to it. In short: my rigid bodies collide, but sometimes, they interpenetrate and stay stuck. I am looking for a solution that would either 1- stop the interpenetration from even happening 2- or at least eject the bodies to 'unstuck' the collision. By making the physics fixed step 0.01 instead of the default 0.02, I can avoid some of the interpenetration. However, that hardly sound like the proper way to fix this problem. Here is a screen shot of the bodies colliding. The car on the right is shown completely and you can notice that the ones behind have penetrated the others to some extent. 

Don't forget to set up depth state and depth buffer. There are advanced techniques to reduce draw calls number. Even better and more general solution will be to google up complete OpenGL tutorial course. There are plenty on the web. 

I don't see how storing original vectors can help to overcome floating point types limitations. Vectors will acummulate errors the same way quaternions or matrices do. They will probably accumulate even more errors, because you will need to convert them to quaternions/matrices and back, additionally to quaternions/matrices operations, this increasing number of operations performed (supposing you want to perform your transforms with quaternions/matrices). It will also introduce performance and memory overhead. 

I don't think HTML5 is there yet for cross platform... maybe one day. I have the additional requirements that my games must work on the Blackberry as well... 

The object you instanciate, does it have some scripts attached to it? The instanciated object doesn't run its awake()/start() until the next chance it gets and not when you call Instanciate(). In the following code 

What you are trying to do is also fairly similar to what older MUDs did. I am more familiar with the Diku variety and I'll explain it briefly here. If you think that is what you are looking for, you can look up the source code, it is fairly straightforward. First, the different stats and skills are all hardcoded. Strength is a concept known at the code level. Same for hp, armor, stealth, fire resist and so on. All the skills like backstab, spells, hide, etc., also exist in code. All the rest of the data is loaded from a database, even races and classes. So a character structure would be 

There is no such thing exist. Neither "best ways", nor "should". Think critical, try, measure and find a right performance/precision/convenience balance in context of your application. Few illustrative examples: You are doing gamedev: s will do the trick, and most of the time you will never notice any errors. Scientific calculations: or is probably your way. You are building a Mars rover, aircraft flight controls or a national banking system: well, here you probably shouldn't use floats at all. We are on GameDev site, so just remember that "float is not real"... but it is very close. 

Not sure it is perfect or exa—Åtly what you looking for and its for single-player, but try something like that (adapted from some books for newbies):