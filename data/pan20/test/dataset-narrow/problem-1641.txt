Once you have isolated where the problem is (Pi, router, Mac), you can troubleshoot the specific problem. 

Your points to a different directory than where your executable is located. Per your question, the JAVA_HOME directory is: 

Note the "$URL$ prefix which was incorrectly spelled in your pasted example. Can you retry with these fixes? 

This site isn't made for "which works best for my requirements" as this is highly subjective and likely to change, but a couple of alternatives are: 

There is an command-line utility called which will use the Raspberry Pi's VideoCore IV GPU to play video at 1080p resolution. Open up a terminal window (from the Desktop menu or by pressing Windows-key+R and then typing ). On the command line type and the video should play. 

I have noticed that for ntp to work correctly, the Pi needs to have a working internet connection from boot onwards. When I connected the Pi to a WiFi network after boot, it would not refresh the date/time on the Pi and basically start with the time as it was when the Pi was last shut down. I recommend you try restarting your Pi after you have configured the network to autoconnect to either Ethernet or a known WiFi network. 

You would need a common ground between 1&2, and if you leave the JD-VCC/VCC jumper in place, you would need to also need a common ground for 3. #4 can be independently grounded. Check this link on raspberrypi.org for a lengthy discussion on how to set up such a relay board: $URL$ 

Minecraft-Pi does not create screen images the same way as "normal" apps do - it is optimized to work directly with the GPU outside of the normal Linux kernel routines. So the GUI has no knowledge of what Minecraft-Pi is projecting in the window (it only renders the window outline) and your screenshot mechanism reflects this. You can also see the results of this "special" treatment when you open up another program when Minecraft Pi is running - the content of Minecraft-Pi shows up on top of the other program, without the borders of the window. To make a screenshot of Minecraft-Pi, use the program on GitHub. I have used this successfully in the past. 

"She's dead, Jim." All symptoms show that you have a defect rPi. Unless you are an electronics wiz and want to measure and test each component, I would recommend you just purchase another one (or, if this is a recent purchase, contact the supplier. I managed to get a 6-month old rPi B replaced when I discovered that my intermittent freezing problem was due to a tombstoned capacitor at C51). 

According to this example, you should only have 1 reference to your PiFaceRelayPlus (the line). The first argument of PiFaceRelayPlus is the add-on board you used (in your case the Motor DC board). Once initialized through this assignment, you can now use the , and lists to access motors and relays at the same time. 

For complete compatibility information, check out $URL$ There are 2 models of a Kingston 16GB microSDHC card listed, one that is reported to work, and one that seems to have issues. The one you link to in 16GB capacity is of type "SDC10" which is reported to NOT WORK. Same for the 8GB capacity. The 32GB version of the card you picked DOES seem to work. 

You have indeed edited the right file (/etc/network/interfaces) The permissions and ownership of this file are correct The IP addresses are correct 

Apart from you needing to reformat your post above to make it less rambling and more a compact description of what you want to achieve (Use a local database on your Raspberry Pi) and what you have tried (pulling a Firebird RPM package from "somewhere"), you should take a look at the available packages in Raspbian. I'm not sure how familiar you are with the inner workings of Raspbian, and if you are looking for a purely GUI (Graphical/Desktop) way of installing software or are fine with doing it all via the command line, but there are several ways to get a database: 

It all depends on the size of wire and the length. There are numerous online calculators that can give you the Ohmic resistance of a given wire length and thickness (AWG-gauge in the US). For a 50ft 24 AWG wire that resistance is about 1.2 Ohm. Using Ohm's law you can find out the voltage drop this would give in series with the reed switch (assuming you know its characteristics) - so you can make sure the resulting voltage at the GPIO pin is still within the threshold for a high signal. I doubt that 50 ft is going to be a problem though. Plus, you can always try it out, just make sure you unwind the wire to avoid inductive effects. 50ft of wire shouldn't be too expensive to procure. 

Your infinite loop condition is wrong - is the same as , which means the loop never gets run. Change this to and you get an infinite loop. Regarding the first code - since the main loop only has a in it, it will terminate as soon as the is over, since you have your and calls straight after this. You might want to study up a bit on how to write programs in C, as the above issues are very trivial. 

Both these installs include DLNA servers, web-queues, AirPlay and OpenHome support, and you can just control the playback via a web interface from any device (even from the Internet if you're so inclined). DO NOTE that both of them are full OS images, so you couldn't just add it on to your current setup, you would have to recreate your AP setup within the image. 

From the instructions and screendumps it looks like you are using a Python3 version of RPi.GPIO, but the output of WebIOPi shows it is using Python2.7. Python2 and Python3 are NOT compatible with eachother. You will need to look for a Python2 version of RPi.GPIO such as this one. This package should have been installed by default on Raspbian, but if it didn't or if you messed it up, you can reinstall it by issuing . UPDATE: For Installation patches on an RPI2, please check out this WebIOPi forum thread with a link to a patch that makes WebIOPi work on B+ and 2B. 

On higher resolutions you might have to make overscan adjustments, otherwise you get a black box around the screen (i.e. The display from the RPi does not fill the entire screen). When either your screen goes into sleep mode, or you switch screens if you have a KVM switch, you might need to replug the converter to get the RPi to display again. 

Yes you can. You can simply mount the hard drive to one of the Pi's as an extra drive, and then install Samba () on every Pi. Configure the drive on the Pi it's mounted on as a shared Samba resource, and each Pi sees the drive - you can automount it in fstab if you want to. For better performance (but possibly giving up the ability to mount the drive in other computers on your network such as Windows PCs) you can look into NFS to accomplish the same - this would allow full Linux/Unix ownership and permissions across the content. Finally - you could also consider buying a NAS - many of them can be configured as an NFS mount - this way all Pis have the same configuration. The added benefit is that a NAS often allows RAID setup of multiple drives, so you get redundancy and fault-tolerance, as well as shared access to the drive. One NAS that is relatively inexpensive and does NFS is the Lenovo IX2. 

Note that I have no experience with using any of these products, but I stumbled upon a couple of options: This VGA to USB capture device. According to the specs it can grab AND convert any VGA input source, and has software that works with Linux. However, at 300 bucks this might be a bit more than you were willing to spend, or you might have even been considering to replace this device with an rPi because of this reason. It does look like an entire out-of-the-box solution for your end-to-end problem though. There are alternatives as well, such as this device from StarTech priced at $188. This captures HDMI as well as VGA, but I'm not sure of its Linux compatibility. EDIT: As you correctly mentioned in a comment, this device uses USB3. There is a similar USB2 device from StarTech.com as well, which currently sells for $123 on Amazon. Works with component, composite and HDMI, including pass-through, so you can see the feed on a monitor while the device records the input and delivers it to you via USB 2.0. Unfortunately, I cannot find anything promising regarding Linux support. Your best bet however is the Hauppage USB-Live2, currently selling for $43. There have been some efforts to get this device to work with Raspbian (see here at Raspberrypi.org) 3 years ago, and you might find that you can get this to work in the current release. The RaspberryPi.org forum post contains quite some details on what to look for. It does require some kernel recompilations though.