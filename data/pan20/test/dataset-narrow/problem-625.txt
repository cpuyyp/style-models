OK, this question may seem a little strange at first; however I'd like to have your comments on it. Background: I do Java. A lot. Java is a statically typed language, it has means to restrict visibility of instance variables, etc. And as such the builder pattern (see here) is quite adapted to it. I took this pattern a step further. The builder pattern is a one-step process: once you , you obtain an instance, preferrably immutable; but once you have the instance, there is no going back. The freeze/thaw pattern is a "reversible builder". I implemented it in Java and this gives the following interfaces, which I use quite a lot in my own projects (one-sided discussion about this pattern here): 

Then you use can use . Note however that since this is an enum you can always access this via . And NEVER do that: 

What is more interesting is now how such an instruction is implemented. I will not show the whole implementation file but instead a small section of it: ByteCode.cpp 

What you see is the that each instruction if constructed is automatically be stored in the global array you have seen in the header file. This shall insure that every instruction ever instantiated is accessible via this very array just mentioned. This is important later on. An saves 4 kinds of information 

The function from the class does what you expect. it stores some kind of Measurement(here time). It's not really well coded and if you interested please look up the code at my repository it is in the same project. The Argument given to calls the lambda of our Opcode/Instruction and Measures how long it takes to execute and stores this information for analysis later. I did this because it seems interesting to me to know just how fast is my Virtual Machine. 

This pattern means that if you have a frozen instance , you can obtained a thawed instance of that instance by calling , modify it (since returns a builder) and freeze it again: 

this is not thread safe! What is more, the value is never assigned to ... (thanks @DaveJarvis for noticing this!) 

I'd just say to go with your implementation; just because it is easier to read! Also, you only from the list once, whereas the proposed solution does it twice. Shorter is not a synonym for better! However, the generics are not good; you should at least use . Not sure why the proposed solution uses as a lower bound... 

The class needs to implement and (on fields and but obviously not !). Also, it has a constructure which is now package private (so that the factory can access it) and whose prototype is: 

The main programm Here you see the snippet containing an array of Type. This shall be the code executed by the VM. I tried to make the definition of this array more readable by using c-style macros. The project is not yet at the point that i can read from a file and execute the code stored there. Any code must be hard coded right know. 

What i personally find awesome is I do not have an awfull crazy long switch statement which chooses what code must be executed. In an earlier version i had such an switch statement and it drove me crazy looking at it. So i came up the with global array. The Array you find the Bytecode.h file; where the bytecode corresponds to the index of the array for appropriate instruction need if accessed. 

I use this pattern a lot; I find it useful. Do you? What would be your gripes against it? Sample implementation of a simple pair: 

Delegate the computation of and to a method, say, . Since we want to spy this method's execution, we will suppose that we have Guava and its useful annotation, and make the method : 

Then have a in which you would pair keys with implementations of . If no entry exists, of course, the method call is wrong. While this is easy, however, it is not practical. Many frameworks, including light ones, include annotation systems which will do the job automatically for you -- you should try and find one, and use it. There is also another solution -- since this is JDK 7 you are using, you'll have it: . It also requires that you implement an interface, but using this, you can load your method implementations easily. This is what I use in one of my projects, and it works quite well; the only trouble with it is you need to create a file in , but it's a trouble you only have to do once for each method you create; or if you use Maven, there is a plugin to generate it for you. 

The member function cpu() is quite interesting and a bit difficult to read. It first checks if the stacktrace is enabled; if so it prints the first line as you can read. Then we enter our interpreting loop; for each instruction contained in our code given to the constructor earlier. this loop runs as long as our instruction pointer is less than the code size, otherwise we would try to access code which does not exist. The first step is to fetch now our first Opcode and increase our IP by one. We than check if the recived opcode is valid and if so proceed. 

I want present to you my little Virtual Machine. It nothing really sophisticated. It is an stack only virtual machine with the exception for some 'global' variables which i would count as registers but besides that all calculation done by my VM is done on stack. What i planning now is to show the most interesting parts of the project How i implement this VM. Reason why I do not post the complete code directly is you can find it on GitHub where you can clone it and test out locally. I recommend if you really interested download the project, execute and take a look the code and THEN comeback and read the post. It makes it probably easier to understand. It's not that i do have a lot of files but to keep the code readable I think that this is the best choice. Let me know if you think otherwise! Also Unfortunately i am not good writer, not just only because English is my second language... I try my best to correct as much orthographic and grammatical mistakes as possible. 

After all, the method returns a boolean! Also, I'd put out of the method, so that it needn't be recreated on each method call... 

The "drawback" here is that it is up to the caller to remind what predicates where in what order in the calling lists, of course. As to your hypothetical class: 

Here is a solution which replicates Guava's interface. Since this interface is really easy, here is how it is done: 

You may want a static method in your class, named, for instance, taking a as an argument and returning an : 

Note: the way your class is currently written, it is NOT thread safe. The quick, coarse way to fix it is to make . EDIT Discussion on a different design to get the value of This requires a creation of a new factory class for instances of class ; it would have the responsibility to create new instances and compute :