Suggested rewrite ES6 If your code base is not to large, or if you are willing to put the time in for refactoring, I would suggest you wrap fetch with your own function, like in the following code sample. You know that will return a , so create your own version of , which you could then export if necessary, and redirect your files that point to the functionality to your own implementation. 

You also define some variables only inside the for loops and although in most languages that would be fine, in JavaScript 5 they don't belong inside the for loops. ES6 really made huge improvements by adding the block scoped keywords and , so if you would have the chance to use them now, I would really suggest you do so. So as a rule of thumb, keep all definitions on the top of your function, or where you define the first variable. Extract similar code to functions Code duplication is one of the most annoying things in a code base that you could have. Even if you know your code perfectly, still changes to certain parts of your algorithm could be forgotten if you copied the code to other parts. One piece of code that could definitely be extracted into a function, would be this beautiful block of duplication 

From the demo page, I have to say, it looks very nice. I am very curious why you do not use the constructor to call that seems a bit verbose for any user, neither does it look very good to use as it is not a constructor in the strict sense, you don't even need it. For a detailed description, please find it on MDN, where this explanation is of importance to you. If you return anything else but undefined, you will not receive a new Slider object, but just the returned object. 

It returns it's own promise, and uses the . In case the result is returned (or another error is thrown), the is called and the promise gets handled by either resolve or reject. In case the interval occurs, the promise gets rejected, and the is also called. Note that if you run the test (at least the es6 one), you can see the time it took before the timeout occured, and it will not run longer. Neither does the then method of the fetch still execute. It is true however that your httprequest will still be open, but I don't think that should be such a huge problem, as it will not interact with your own code anymore. It is still important though to handle the catch of the fetch and pipe it through, so that the interval gets cleared, but that you also get notified of the other errors that might have occured during the request. 

A nice addition might be a method that simultaneously returns the head of the linked list, and removes it from the list. 

Make it iterable by having return a generator: by returning a generator that yields consecutive node elements, users can traverse the list of nodes (see below example) 

Yes: your code could be optimised by calculating (with respect to each slice of ) only once per outer loop, instead of times (where is the value of ) as per your current implementation. In the full example below, I show how you can use to make this much more efficient in the function. Re-using calculations is more efficient, but a procedure that doesn't alter the dataframe is more flexible: in the exmaple below, the calculations are re-used, but the main dataset isn't changed (everything is done from a copy). This may not be desiarable if: (a) you don't intend on using this code for any other purpose (or for more than one use, where keeping the original dataset untouched means you can re-run the procedure), or (b) if the size of the data in memory is large. It could be improved: if I have understood corretly, the results of calculating in the inner most loop is actually used number of times (except when the column being passed to is within columns from the end of the dataset). We can reduce the number of calculations of by a factor of , therefore, if we re-use the results. In the example I've given below, I show how you can do this to improve performance. Only if you don't know your data structure ahead of time; you've used indexing by position rather than label to good effect. Apart from the points above: your code was easy to read (thanks, too, for the detailed question!)! 

My suggested re-write using the above suggestions is given below. The main function to run is (nb: this uses label indexing instead of the positional indexes that you use - this could be switch out if you prefer). This will create csv files in the same format as your example code. NB: I have assumed that the order of the rows in each column of the output CSVs doesn't matter. If this does matter, I can suggest a change. 

True, the code is longer, however, it's commented, there is a clear definition of what the function will do, and what the user of the function can expect. Splitting up single parts of your code into there own functions is a good way of structuring your code, and promote re-usability. Now, another instant observation I might have is your interesting mix of different for statements. Especially seen that they are so close together, I really wonder if there was a reason for you to mix it up, or again, you felt like experimenting different forms of iterating an array 

Here you really have to be consistent with your choice. There is no reason why a statement brings benefit to your code, as you are iterating arrays and not an object. It makes the code less readable if such unexpected twists are added. Subtopic variable scoping The use of the keyword in JavaScript and it's scope has been confusing since the dawn of JavaScript. It is important to know that in JavaScript, defined variables are not block scoped, but they are function scoped variables, as this small snippet demonstrates 

more about plugin creation for jQuery can be learned here Currently, I believe your method takes a bit to much control, and as a user of the slider function, I cannot really do a lot. I can only start the slider, I do not have any actions available to me where I could stop the slider (eg: ) or decide how fast it should slide, and though you offer the it is completely unused at the moment. There is also no way to interact with the slider from a different place in your code, to for example show a specific slide on the click of a button. So I think your plugin is to much in control. 

I think one of the most common errors in today times, is for example handling potential errors, as you try to do here: 

This answer applies only when you want to have well defined messages across whole application. I would use neither. Let me first explain why and then my proposition. Critique Assuming you are going to use your enum elsewhere some duplication might occur. Imagine souch example: you decided to use switch in some method in catch closure and this looks good because it is clean enough. However since you built an entire enum for simply displaying the message to the user you probably would want to use it in other method or class which is very handy. What do I propose ? I propose something what I like to call "descriptors", it is somewhat between dictionary and switch. What would you do is create attributes over each enum with it's description : 

If I understood you correctly what you need is to make this method faster. Firstly, you need to answer one simple question is that really what you NEED, this method does not look that time consuming at all (unless you have hundreads of elements in that string). Have you benchmarked it and saw that it consumes a lot of time? EDIT: it came to me that you might be asking about performance of your idea, if so - for me it looks good enough. If you really need to make this method faster here is what I can see: 1. Do not use loop. If you decided to make a list take advantage of it. Change your loop to 2. Do not use LINQ at all, it is known for being time consuming (since it enumerates everythingcall enumerator in every function). 

can be changed to loop when you do by method and by simply checking every element. Exactly the same thing is applicable to and in the latter I think you do not need to make but I have no compiler at hand to check it. Note Those changes are micro optimalisations, if your application is slow it is probably because of some other part. Plase do propper benchmark to check this. Also : I think there should be