I added some formatting to that nested ternery to try to understand what it's doing, and it still took me a while! 

It seems to have 3 possible paths, and only one of them actually does anything (since the other two just set to ). So it looks like this is actually trying to say: 

Notice that by replacing iteration with this tail recursive style, you no longer have to have mutable state in the form of a collection which gets updated. This (and the fact that recursive algorithms often read as more declarative than iterative ones), mean that tail recursion is generally preferred over iteration in F#. 

Probably the best way to decide what extension methods to include is to look at LINQ and decide what methods are applicable, and whether they need to be renamed. For example, is useful, but might be better named . is also useful if we think of it as (in the same sense as null coalescing). However, we're sort of cheating here. By making internal, we can write the extension methods we need, but only in this project. By contrast, lets anyone extend it by exposing the underlying properties needed to use it. We could fix this by just exposing , but this again is potentially confusing to consumers, and could be thought of as an implementation detail. It's somewhat a judgement call, but an alternative would be: 

Sure, your method is better. It's a pretty straightforward example of some fundamental programming and design concepts: 

But now this really seems like a mess. We're relying on two different things- the unit of work and the query helper- to do our data access, at two different levels of abstraction. Which level do we actually want? Well, I think the answer is straightforward. We added specifically because we found ourselves wanting that abstraction over accessing the directly. Moreover, if we look at the problems above, can solve all four of them. It solves 1,2 and 4 by its nature, and it can simply solve 3 by keeping its return types as rather than , and by not exposing any methods which take an arbitrary or to use as a filter. All that remains is to extract the methods that we consume onto , narrowing them and making them more specific to keep them at the right abstraction level when possible. You can probably see the punchline coming- what we actually end up with isn't , but . This can follow the standard generic repository pattern you'll find described all over the place. If you look back at the root problems, you can see these are solved too: now everything relies on a much smaller, more targeted interface, and data access concerns are kept in data access classes, rather than spreading out to every service that cares about entities. Conclusion But what about KISS? Possibly you were already aware of the generic repository, and you wanted to avoid it because of its apparently needless complexity and indirection. Well, yes, as always there's the tradeoff- in a small, simple application, at what point does further SOLIDifying your code consume more development resources than it'll ever buy you back? That's a judgement call you'll have to make. But hopefully I've given some reasons beyond just "So I can swap my ORM" for why you might pick this more complex pattern. Also note that the generic repository is, at its core, not actually all that complex or bulky to implement. It really starts out as just a thin wrapper over . But don't be misled! A repository should not just be an adapter from to an interface you control, it should be a full-blown abstraction layer! So if you do find yourself adding more methods, that's probably vindicating the choice of that pattern. 

Despite my comment, I'll try to give a bit of a review. It is difficult though - a Hello World application will never need to be extended, and has such an extremely simple function that it's very hard to distinguish between a good and bad test. Unnecessary comments Generally, for comments within methods, I view them as a last resort. If I have to add a comment, it means the code itself isn't readable, which I treat as a code smell. For Javadoc comments, I'm a bit looser. It's often just plain not possible to communicate everything you need to in a message signature. Having said that, there is such a thing as too much here too. If you write something that's just a simple restatement of what's already available in the signature, you're repeating yourself. As violations of the Don't Repeat Yourself principle go, it's a relatively benign one, but it's still a waste of everyone's time, and still means that you now have two places to maintain if that signature changes, rather than one. So for example in your code you have: 

If there aren't any cycles, there's no growth, so we go to the magic number 1. But where's 1 coming from? It's the starting height. Is that encoded somewhere? Yes! Just two lines later: 

Of those, the first would be my preference. In terms of choosing approaches, with the above changes made I would prefer the second. In my opinion, returning early makes code easier to read because, mentally, you can completely discount paths through the code which have already returned. Having to only temporarily make that mental switch as you enter an statement means having to maintain a more complex mental "stack" of possible paths through the method. True, you could scroll all the way to end end of the statement and see that there's no more code afterwards, but it's much nicer to be able to read code start-to-finish, rather than jumping back and forth. 

As you already said in your question, your algorithm is a bit strange. Your alternative algorithm is much better. Writing it in the same recursive style, an outline would look something like: 

You will minimize the likelihood of having to make changes, and minimize the magnitude and risk of the changes you have to make. With just the information from the OP, I wouldn't create an actual class, because all I know is that code files need to be read and they need to be validated, and without answers to some of the previous questions, I would have no idea whether it's appropriate to group those two pieces of functionality into a file reader class. Potentially it might turn out to be more appropriate for the validator to be used by the code that calls , rather than an actual implementation. But if I did find out more and that seemed appropriate, and it turned out that invalid files were exceptional, the design would probably be: 

(Not that I've changed to . This practically shouldn't have an effect but is a slightly more appropriate method for the situation) Okay, that's a little better, and we could extract the conditional to its own method for readability. But it's still problematic: 

In general, when trying to reimplement basic collections like this, you're going to have a lot of difficulty getting near the performance of the in-built .NET collections. As others have said, removing frequently from the beginning of a has very poor performance. However, just looking at the circular buffer article already linked, my immediate reaction is "yeesh, that is not complexity I'd want to add to my code!" Especially when I know somebody's already done it for me in the existing ! So in situations like this, the answer is usually to either be willing to sacrifice performance, or to try to make use of the actual collection as much as possible. In fact, all you want is a queue that has a little extra functionality, so why not do just that, using composition? There's no interface in .NET, so we can't implement the decorator pattern, but we can get close: 

You're right that this is problematic. What it means is that your class can be in a "not fully initialized" state. Like you mentioned, that means you have to remember to initialize it. It also means that if you ever pass it around, you can't rely on your configuration staying the same- some other code might change the without you realizing. There's a pretty common solution to this- just pass it into the constructor. That way a always has one for its entire lifetime, which won't be changed. I'm not immediately sure which IoC container you're using, but any mainstream one will have support for constructors with parameters- you just need to make sure the dependencies are bound too. 

You're doing a worrying amount with statics. Not only are you holding state in , you're also accessing what I can only assume is some dependency in . While you say multi-threading isn't an issue, over-reliance on statics also sacrifices your ability to take full advantage of OO features like polymorphism. The variable is fixible easily enough by just moving it inside the method, where it should be anyway. But I think more generally you should make sure you're not making things static over-eagerly. 

This isn't very easy to do neatly. As you've seen, if you pass the into your repository, then mocking the just for querying is a bit nasty, and you'll run into further problems if you want to mock the context to check if is called. I'm not fully up on how people tend to deal with this, but one strategy might be to define an interface like: 

The comment isn't adding any information here. The line below is clearly a call to that method, there's no need to say that twice. Comments like this are actually a form of repetition, so it arguably violates the DRY (Don't Repeat Yourself) principle. To see this, imagine you had to change that line to call something else instead. Now you have two places to update rather than one- the line itself and its comment. I don't think the "end of..." comments are all that useful either. These usually only serve any purpose when you have lots of nesting and large blocks, and in that case they're more of a code smell that you're doing something wrong. In cases where the code doesn't express enough, maybe it's the code that should change rather than adding a comment. For example: 

Now instead of many very similar methods, we have one parameterized method. We've cut out a lot of repetition- all the aspects of the messages which were the same every time were being repeated over and over. This principle of not repeating information is called Don't Repeat Yourself. SRP You know what would make your game great? A graphical interface. Well, okay, maybe that's a more than you want to add at the moment. But what about a menu like in many keyboard-controlled games where instead of everything having a number, you have a current selected item in the menu, and you can move up and down, then press enter to select? Or, I dunno, maybe you want to highlight some words in different colours, or have the player type words rather than numbers or translate the game to Spanish. Maybe (in fact, probably), you'll never want to do any of those things, but the important point to notice is that all of those are to do with how you present the game (get input/output), and none of them have any impact at all on how the game itself works. In reality, the rules and logic of your game are completely separate concerns to how you want to display your game. But in your code, they're so mixed together they'd be extremely difficult to pull apart. Any of the changes I mentioned would require changing almost everything. So with this in mind, let's look at how we might print our club selection menu: 

This may or may not be something you actually want to do, but it's a good example of how a class like can add value through doing validation. And speaking of value: What is the purpose of ? Wrapping a collection in a class which serves as a gateway to making calls on that collection is relatively common, and often a good idea. But make sure there's good reason for it first. The name is the first indication that this may not be a case where you actually want to do this. Usually if a collection should have its own class, it's because that collection is its own conceptual entity. For example, a might be wrapped in a or , or a might be wrapped in a . These can all perform functions related to what they actually are which a simple cannot. For example: 

Generally, your naming is good. I never like as a name, but sometimes, like in this case, it's hard to see anything more descriptive. Perhaps just . is also not a great name, though since this is testing something so specific, there probably aren't many candidates. or similar might be better, cumbersome as it is. 

Given that this program has a single class, and in fact a single method, it doesn't really matter where you declare things. However, in general if you're only using a variable inside a method, you should declare it in that method rather than at the class level like you have. Even if you were using it throughout the class, you should still keep it private, not public, unless you explicitly want to expose it to other classes. 

Either the method should have an return value, or you should be returning instead of . Either you have a potential waiting to happen if can truly not have a value, or you're needlessly giving your caller extra work having to do its own check. 

So what's happening, causing both these problems, is that you're trying to do something inside the loop which is actually meant to happen when the loop is finished. That should happen outside the loop. Fortunately in this case it's a simple fix- just move your failure exception outside the loop: 

Okay, now we see the problem more clearly, those first lines before the while loop are checked again at the end of the loop. That's definitely something we can improve on, so let's do it: 

I think the above should be your default starting point. Building a design means making decisions, and every decision is a potential wrong decision, which becomes technical debt. So you should never build more or earlier than you're driven to by your requirements. But there are some reasons you may immediately want a heavier design than this. For example: 

While it's much more likely that you'll add to rather than modifying either of those methods, even simple controller methods may be refactored. For example, it's quite likely that you'll want to add paging, which will mean refactoring . Unit tests could be valuable there. Mock commands, not queries You may have heard of the idea of "command-query separation" (CQS). To quote wikipedia: 

Update As a couple of people have noted in comments, using a instead of a may be preferable, as it is more in fitting with the meaning of these structures. This makes the add/subtract tick logic slightly more verbose, but not prohibitively. 

Instead of predicates, you can now create and use classes which implement this interface. This gives better adherence to the design principles I mentioned before, and allows you take full advantage of polymorphism (for more complicated validation you might find that inheritance is useful, for example). At this point your original method would be: 

Depending on your wider design, this might be enough. However, since you asked about extensibility, you can see that having to build predicates isn't the nicest business. For example, you had your 'less than 8' predicate. What if elsewhere in the code you wanted 'less than 7'? You'd have to repeat the (albeit very simple in this example) logic, just with a different number. If you tried to refactor this to adhere to the Don't Repeat Yourself principle, you might then end up with something like a class which exists purely to build common predicates based on parameters. But this isn't fantastic design either. It would likely end up as a monolith of public methods without much cohesion, and violate the open/closed and single responsibility principle. A better option might be to create an interface like: 

Then that's a pretty good sign that you should instead have a method on , with a different implementation for and . That's a core part of OO design, and one that's easy to apply here (as Dmitry's answer shows) Note that this also lets you encapsulate your data- those integer fields can be private to the implementations. Your classes aren't just bags to hold data for anyone to read, they provide useful behaviour. 

Looks to me like its own method. There's quite a lot of information here that the brain has to do some reading/calculation to work out: 

OO or not The first thing to do is decide whether or not you want an object-oriented design for this problem. From the requirements you've described, there's a very simple solution that doesn't need any real design work at all: