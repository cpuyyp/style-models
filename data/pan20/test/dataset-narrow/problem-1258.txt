There will only be a slight performance hit if you calculate the orthographic and perspective projection matrix each time you render to the frame buffer. I suggest caching them in a variable, calculating and storing them once in the initialization code, and then using to load the matrix. The rendering method would look like this in pseudo-code: 

You should most definitely calculate the matrices in client cod, since the matrices do not change on a vertex-to-vertex basis. You are essentially repeating one calculation - of which you know the answer will be the same - for every time the vertex program is run. 

I would suggest using the fixed function pipeline as a backbone of your program. I find it to be easier to have something show up using it instead of purely shaders. Then, when you know you haven't messed up your vertices or normals, you can slowly but surely inch your way into the shading world. 

In my case I maintain the state of the keyboard by listening for the and events in the client. When one of these events is fired the client sends a message to the server and then updates its own state. This allows the client to employ client-side prediction (see this article for more details) and gives the server the minimal amount of information it needs to execute the move. When the server receives one of these events it updates its own internal state and then rebroadcasts the event to all other clients so they can handle it as well. To keep everything in sync the server will periodically (every 10 ticks of the engine in my case) send a "sync state" message to all of the clients giving them the exact positions of all players. You never want to sync the state of a client to the server as that opens up all sorts of cheating opportunities. EDIT To be clear, state syncing should only ever go from the server to the client, never the other way around. END EDIT I found Maple.js to be quite useful as a reference for a concrete implementation in Javascript. 

The benefit of this over checking if a point is within your frustum is that with the latter you need to iterate over each point instead of using some simple array where you always itterate over a set amount of tiles that is equal to the amount of horizontal tiles * vertical tiles that actually need to draw. This way you can have huge maps and still have a good frame rate. Unfortunately this gets harder and trickier when using 3D but gets exponentially harder with the freedom the user gets with the camera. You can imagine a fixed perspective camera that moves with the character just needs a couple of hardcoded variables to do the same tricks on an array of meshes that represent your map. 

Based upon this I will create my abilities. I used a build pattern for my ability class to help myself out. Just look it up, it's easy to create. Here I create a stun shot. 

Are there any particular technical contraints that make one option more attractive than the other? Frame-by-frame animations will tend to use more memory than skeletal ones. Skeletal animations will require more complex code to implement. Are there any design constraints that make one option more attractive than the other? Do you want your character to bounce around like a rag doll when he dies? Do you need to be able to change the animation at runtime? These things will be easier to do with skeletal animation. What tools does your artist prefer? What workflow does your programmer like? 

That's certainly a legitimate approach, how successful it will be is another matter. This article is about an iOS game called Gasketball that took a similar approach and how that worked out for them (spoiler: not so great). Based on this article I don't think players are enraged by the idea of getting a free-to-play game then paying some amount of money to unlock the full game. 

You can go two roads with game development as you have described it. The Hard Way - OpenGL or Direct3D You use the LWJGL or JOGL for Java or OpenGL with Wiggle or GLFW in C++. This method is notoriously difficult and will consume a lot of your time (upwards of 50 hours probably). However, it will pay off in the long run and you will have learned a lot. You will spend more time with the graphics, and less time with the game. The Easy Way - Slick2D Here you use a high-level library that abstracts from all of the intricacies of game development. It's much easier to learn than plain OpenGL or, even worse, Direct3D. Since Slick2D is a Java library, you can generally distribute it easily to Windows, Mac, and Linux. The downside is that it isn't as flexible as OpenGL or Direct3D and you don't have as much control. You will spend less time with the graphics and more with the game. 

As you can see the face gets shadowed as a whole. The face next to it has the same problem on the opposite corner you see the same effect but much less hard. 

So the fireball ability is created and the player chooses to use it on a target, in my case this can be a position to shoot at something he cannot see. 

I love to work with Vectors this way so whether you use this or not, I hope you learned something from it. I have created a very basic program for you that does what you want. Get it from github: $URL$ The readme shows how to make it work. 

Since you are using a tilemap you do not have to check each and every rectangle. Just the ones around the player. You setup a loop with a inner loop and set the start and end coordinates in it. This way you just have to check 9 tiles each loop or maybe 12 since you sprite is a bit bigger. Once you have a overlap with other rectangles you can check check more precisely what is happening. You only ever have to check 2 direction because if the sprite is moving down and right the collision could never have been taking place above or at the left of the object. So let's assume the player moves right and due to gravity (simulating or not) was pressed down as well and collided with something. So we have to check the bottom of the character and the right of the rectangle/character. 

In your collision processing you need to get a list of all rectangles that your player is definitely colliding with. As you loop through this list you need to test the intersection of the player and each rectangle. This intersection will give you and values. Compare and . Whichever value is smaller is the axis you want to resolve along. That is, if , adjust your player's position along the x axis. If , adjust the player along the y axis. Loop until done. 

I've used A Bitwise Method For Applying Tilemaps and found it to be a very elegant solution. The article provides a concrete example and discusses how to extend the algorithm to handle multiple terrain types. 

Write a script to parse the JSON format you have into the Cocos 2D format you need. Recreate the tps file so you can easily export whatever format you may need in the future. This assumes you have the source sprites that are packed into your atlas.