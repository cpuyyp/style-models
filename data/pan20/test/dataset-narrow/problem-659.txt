Don't output system-level messages to standard out. Consider throwing exceptions in this class and letting calling code handle user-friendly error messaging. 

Look for opportunities to remove code paths and complex nesting by getting rid of unnecessary blocks (many of which truly are unnecessary) and exiting early by inverting conditions. The fewer code paths you have in your code, the less fragile, easier to test, and easier to maintain it will be. 

You are doing nothing in code shown here to validate/sanitize the inputs. Both and are use input and should be validated/sanitized accordingly before passing these values further into the application (or especially placing back into user cookie). Maybe something as simple as function. 

Here you commit to passing a valid SqlObject dependency to the code that needs it. If this contract is not met, an exception will be thrown. This also alleviates the need to do any checking within the subsequent code to validate the dependency, instantiate the dependency if it doesn't exist, etc. Here the function is made to expect the hard dependency and not even be able to execute without it. 

This approach is scalable as you add more elements into your test cases, as you could just add new id keys into the element array and not worry about polluting your global namespace with a bunch of variables. You also now have the ability to simply look at the value stored at each key to determine if the element was found. So for example, if you are going to perform a test action against a certain element, you can test for it like: 

This gives you the benefit of knowing that you have a valid DB connection via PDO before you even try to set the session save handler. You can bail out in your bootstrapping process rather than having exceptions/error taking place when you are actually trying to interact with session functionality. 

I am concerned with the whole approach in comparing $_POST['pass'] against some stored password variable (I am assuming this is defined in the include file). Does this mean you have a single password that, if compromised, gives any user of the system the ability to modify any record? This seems like a poor security strategy, not to mention the apparent plain text nature of this as already noted. You should like have a separate user authentication/authorization mechanism rather having a single password passed at the time of especially since I am seeing nothing in your .htaccess or code (maybe this is in include) that is forcing HTTPS protocol to be used. 

One query populates your entire table. If you then want to populate some of your table which I noted above as potentially being "over-normalized" you can do it from this table For example: 

It looks like you are trying to implement in this class, so why does the class definition not state this? 

If you truly want to make this code re-usable, you may want to consider making this functionality into a proper "class" and internalize all references to state and DOM bindings. This would allow you to place multiple instances of these slide shows onto a page at once. Putting it all together might yield something like: 

You should familiarize yourself with dependency injection as preffered means to deliver dependencies (such as a database object) to code that needs to use it. This prevents you from having to use patterns like singleton to instantiate these dependencies within classes that need these dependencies. So for example, rather than singleton pattern like this: 

Some good commentary from @Iwresteldabearonce so I won't get into any of those points. I think you are missing some higher-level concerns: 

What do and mean? Use meaningful field names in your table and variable names in your code. You gain nothing by cutting a field name short other than possible confusion down the line. Your current prepared statement logic assumes happy path execution. What happens if fails? 

Consider or for use in validating/sanitizing your input data. You should absolutely not be working with POST data (especially sending it off to other servers), until you have validated/sanitized it. Here you just work with it freely, just hoping for the best. This is a no security posture. So when you ask about application security, please understand that you effectively have no security right now. 

I like you use of . You might want to consider here instead. This might allow you to more easily decouple the validation configuration/definitions from the actual validation step. For example, if you add a new field down the line, you can just change validation config instead of adding a new line of code to check that new field. This would also allow you to potentially skip the steps where build an array of errors. Usage: 

With you either passing PDO object defined in you bootstrap sequence upon instantiation, or possibly using singleton provider like this: 

I honestly disagree with this whole approach. First, storing files IN a relational database is rarely a good strategy, limited almost exclusively to use cases where you want to perform binary searches against the binary artifacts. That is not your use case here. Outside of that, you are just adding a lot of overhead to your typical database management operations (making DB backups/snapshots, replicating data across DB servers, etc.) without really any added value in having the files in the DB. Your use case is simply one of needing to operate on the file in it's entirety, so I would think typical directory-based disk storage or cloud-based file storage mechanisms would make much more sense in terms of being able to operate against the collection of files as you typically would a collection of files. Your database could then only store reference to the files. I would have a strong bias towards using OS-based mechanisms for archiving, syncing, encrypting/decrypting, etc. PHP obviously can give you entry points to these sorts of operations. I also VERY much question your encryption approach (and the approach for trying to roll your own logic). You are talking about what would seem to be an assymmetric cryptography use case here, but you are attempting to execute this using a symmetric encryption approach. This approach seems to not make sense, because, as soon as the end user passes their key to the application, the application can now decrypt the data, as it now has the shared symmetric encryption key. In this case you then need to generate a shared key for each user. This would beg the question as to why the user even needs to pass the shared key, since the application should theoretically already store it. This means the application could decrypt the data without user interaction, which seems to not be what you desire. If you truly want an assymmetric approach, then you probably need to forfeit the idea of the application performing ANY decryption at all. That should be up to the end user and/or a client-side application where this operation takes place. Outside of that, it seems you are defeating the entire purpose of what you are trying to do, which is storage of an encrypted file without the ability for the application to decrypt it, without the user having a key. 

If you properly separate concerns, you move away from having to implement hacky uses of output buffers - something which should typically be reserved for very targeted use cases. Speaking of your output buffer, I don't see where you are flushing it. I would think it really poor practice to begin buffering in one area of code and have the buffer flushed/closed in another area of code. You are opening up your code to having to deal with the complexity/fragility of nested buffers if you have this behavior in other areas of code. 

Your class names are really throwing me off. Perhaps because they are so generically named. By looking at these classes I have a hard time understanding the interfaces you are trying to expose. What is a ? Why does a chat hold references to (which seems to only be a single "offer" so should perhaps be named )? Why would a object need a method to check if the it holds is (which perhaps should be named since it returns boolean.)? I just honestly can't make heads or tails of it because I don't think your classes are defined upon real-world lines. Make sure you name your classes meaningfully and specifically, and most importantly with relevance to real-word concepts. 9 times out of 10, if you find yourself thinking of you objects in real-world terms, you will come up with a better design. In the real world, does a chat have the ability to determine if it has something to do with a lawyer? No, a chat may need to know about the parties chatting, have some send/receive message functionality, maybe store messaging history, etc. What does it have to do with lawyers or offers? What is a CategoryService (ServiceCategory?) and what does it have to do with lawyers (are lawyer services one category of service?) 

Answered this before I saw your all-zeroes use case. Added some additional logic above to handle this case. 

Outside of the other answers about the general utility of this function, I figured I would add some additional thoughts on the code itself. I do agree with those other opinions though that this function just seems to obfuscate your code behavior. 'typeof' is so universally used and understood, that I don't know why you would want to introduce this potential point of complexity and confusion. The first thing goat jumps out to me is all the unnecessary nesting. You are doing a good job of returning from the function as quickly as possible, but then still leave a bunch of unnecessary else code paths. If you return in the if. The else should not be there. Remove them and de-nest your code. You will also find this would eliminate need to check for function or regex multiple times. I do not understand why you would return lowercase first characters in your return values. If your are testing "Object" for example why return "object"? This especially seems odd when your very last line of code for the fall through use case does not apply this same pattern. 

From a performance standpoint, your best best is to actually load test your application to see if it is going to meet your needs. I am guessing when you say 5000 users, you don't mean 500 concurrent users. How many users do you truly expect executing this script concurrently? How much memory does this take on typical execution? How does that compare against your server hardware? Is the user experience on your hardware (i.e. the time that this takes to execute) appropriate? Does that time to complete change under concurrent load? Really your performance is going to have more to do with the questions I just asked than your code. 

Be consistent in using either camelCase or snake_case in your method names. Don't mix them in the same code section like you are doing in your unit tests. 

Your solution is very "functional programming" in approach, with nested function declarations and such. This in of itself is not "wrong", it is just a little bit unusual in the PHP world. I would consider moving this into an object-oriented paradigm which is more common in PHP. I would think in this case perhaps only a class with static functions might be needed, so you could make calls against the validator like: 

Consider using require() here as my guess is that this script will not execute without this dependency. You should fail fast if dependencies are not met. 

With regards to using , I would get in the habit of always using this for animations, assuming that your are primary targeting modern borwser that support it. You can use or as fallback for those browsers that do not support it. This arcticle does a good job explaning high-level use of as well as give sample polyfill (fallback code) for borwsers that do not support it. 

The inheritance model does not make much sense to me. It seems like you have made an arbitrary line of separation of responsibility between the classes. For example, the base class has responsibility for: 

I question why you would want to put a critical dependency like a config setting into a mutable variable in global scope vs. something immutable (like a constant). So perhaps something like this is more appropriate: 

There is no reason to ever perform two queries in . The first select is just a wasteful query against the database and it seems your code just assumes the record will exist anyway. You can go directly to trying the update (after validating and sanitizing input of course), setting the new values based on the old value. That query might look like the following (of course you should parametrize this):