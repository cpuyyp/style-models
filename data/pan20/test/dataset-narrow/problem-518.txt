I like using exponents to factor each digit into its value place. I don't like having to define a mapping for each number from 1 to 3 and 6 to 8, and repeat that for the 10s, 100s, and 1000s digits. 

But since Rails is pretty well tested, I feel like I can trust its JSON return. I'm not sure if this approach makes my tests brittle, since any change in the response body will cause the tests to fail. But maybe that's a good thing? Here's another example: 

The second method returns a JSON representation of an object, and accepts options. This is what I expect the response to be. So I compare the output of this method to the actual response. 

When integration testing Rails applications HTTP request helpers can take a string or a named route as the first argument. I find myself writing: 

The first check is for the length of the string: If it's odd, the can't be balanced. I then iterate over the chars of the string: 

I think some of your expectations might lead to brittle tests. I would modify the expectations a little. For example: 

Using a hash instead of an array alleviates the problems of 0 index when using arrays. It makes more sense. 

I wrote a random world generator for the classic Snakes and Ladders board game. Snakes and Ladders is a dice game played over a grid, usually 10x10. You win by reaching the last square first. The board has ladders and snakes that connect specific squares. Land at the base of a ladder and you climb to the ladder's head (good). Land on the head of a snake and you slide down to the snake's tail (bad). Snakes and ladders are key value pairs; the represents the start point, and the represents the end point. Both are identical except that a snake's start point must be greater than its end point, while the opposite is true for a ladder. World rules: 

Also, I use inline comments to help the reader and my future self to understand complex statements such as 

Since the best-case runtime complexity did not change, we only see minor performance improvements. The runtime is dominated by parsing speed. Worst case - input queries repeated 

Style Instead of I suggest the more self-documenting as the length can never be negative. Also, don't needlessly mix vs. for strings. Specification Right now you are returning a distance of when there is no path and a distance of if equals . I suggest following the common definition of path length and return and instead. You might also want to pass the alphabet as a parameter instead of having a hard-coded 'magic' constant in your function. It can easily be computed from your dictionary as . Also, you currently allow any word for while must be part of the dictionary. I recommend allowing non-dictionary words in both cases for consistency. Performance Your main performance bottleneck is the function. If you keep track of a set of open words which you haven't visited yet, you can replace that function call with a simple . Set lookup time is constant and thus much faster than iterating the whole array. You then have to pass the set to . The map is no longer needed. Another performance drain is performing string splitting via in the inner loop of . You can push that to the outer loop. Also, you currently treat as a special 'shortcut' case. You could generalize this to . Sample code Applying all those modifications to your code yields: 

Notes Declaring some of your variables as can protect you against erroneous reassignment or rebinding, as any assignment to variables will throw a at runtime instead of silently continuing execution. Instead of I recommend using the unary plus operator which is "the fastest and preferred way of converting something into a number" according to MDN. Parsing I like your separation of input parsing and the actual program logic. However, you create a lot of temporary copies by first splitting and then mapping the array. If you like, you can use iterators or generator functions to parse input with only constant additional required space: 

It accepts a grid. A grid is just a has to cells and portals. It doesn't care what, and how. As long as it gets a hash, it works. The old method had a bug. If a player rolled in excess of the board size, it would exit its cell, even though it had no where to go. The new fixes that. The player only exits if it enters another cell. If no movement happens the method returns nil. 

I honestly think your first version is the best one. It's readable, and makes more sense at a glance than the refactorings. That said, I would consider a couple of things. 

The idea is to isolate presentation logic that is only needed for the report, in the report class itself. You then have cleanly defined responsibilities for each class. 

The best way to ensure a bullet proof implementation is to avoid having a square contain more than one object. For example, there's an edge case where a square can contain a ladder's head and a tail, causing you to progress even further. To do that, the placement should be delegated to a method that checks if the square is occupied. This requires tweaking the initialize method, but it's worth it: 

The following converts Arabic numbers to Roman numerals. I decided to factor each digit into its place value, then use a mapping to convert it to its Roman equivalent. For example, 1997 is factored to: \$(1 \times 10^3) + (9 \times 10^2) + (9 \times 10^1) + (7 \times 10^0) = 1000 + 900 + 90 + 7\$ The Roman numerals for those numbers are then retrieved from the mapping. 

A square can technically contain the tail of a snake and the base of a ladder, or head of the snake and head of a ladder. But this could have weird side effects (presumably why I've not seen a board with those characteristics): You slide down a snake only to reach the base of a ladder that takes you to the winning square; or you climb up a ladder only to reach the head of a snake that drags you down. While not fatal, such side effects muddle the role definition of ladders and snakes; in that, ladders are no longer necessarily good, and neither are snakes necessarily bad. Example World 

A better design would probably have the attributes on the colored buttons and not on hidden elements, introduce a mapping between pad and audio source and leverage the web audio API instead. Using shapes instead of heavily styled s for the UI might further simplify your markup. 

Edit: You could move the declaration of both event listeners out of the loop body. However, the dropdown toggle's 'click' event listener needs access to the dropdown element it belongs to. So you would still need a closure or alternatively bind the event listener's to the dropdown: 

Instance method vs. class method vs. function: You declared a constructor function whose instances all come with their own individual method. Since the method doesn't rely on other instance properties, it should probably be a class method instead. In JavaScript, a class method is simply a property of the constructor function: 

The resulting optimized function below runs about 30x faster in Firefox 52 compared to the original code. It turns out to be pretty similar to Flambino's exemplary code apart from replacing with a ternary operator and pushing a subtractions out of the inner loop: 

Create a circulant 10 x 9 matrix where each row is a circular shift of . For each round or column, replace the self-match with a match against team and let team play against the self-matched team. 

Your solution is a bit wasteful by generating and testing all integers in the desired range while you actually only need a handful of them. A big improvement in terms of performance is to avoid modulo arithmetic and increase the step-size tenfold whenever you finished iterating a sub-range 1-9, 10-99, 100-999 and so on: 

Also, it is not clear how strong the given assumptions are and whether or not violations of those assumptions can occur and should be dealt with. 

However, unless your will have additional properties later on, a simple instead of a class will do the job just fine. Instance properties and side effects: Within your calculate method, you create new instance properties such as , and holding the result of the calculation. This is called a side effect. Pure functions without such side effects are easier to understand and debug. Also, those property names are not very descriptive. Consistency: For different inputs, the values of and the return values of are inconsistent: 

If I find an opening bracket, I add it to an array. If I find a closing bracket, I remove the last element from the array and check if the brackets are a pair. If I find neither an opening or a closing bracket, the string must be invalid. 

Then you don't need to pass the credential to the initialize method. But you can should you need to. 

Your view will be simplified too. Instead of calling you can treat the decorator as the binder object. 

Personally, from my experience of reading and watching educational materials, the newer syntax is preferred where possible. It's also less keystrokes: instead of is easier for me. 

Ideally you will want a nice helper for this. Now you can helpers from inside the decorators using the context. 

I started out with this solution. It's iterative, and not very efficient. It multiplies all number combinations, adds the products to an array, finds the palindromes, then chooses the max. 

I would suggest using a service object. I would like to see what others think about this. It looks like there's too much going on for the controller. The controller should be responsible for execution and value return. The model for processing the object. The service for wiring up the object and giving it prepared params to do its job. This is not tested, but just to give you an idea. I would go further and condense the and methods in the model so that the service just receives an error or an OK to give back to the controller. 

You could refactor your block into something like this. But I don't think this is a good idea. I'll explain why below. 

I improved with my second iteration, but it still relies on iteration. I narrowed the range down reasoning that the largest palindrome is likely to be the product of two numbers within 901 and 999. This time I multiplied all the numbers, but only saved the palindromes in the array, then selected max, which saved a step. It's noticeably faster, but still not optimal.