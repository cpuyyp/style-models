Spiralize Vetting of the questions seems to be up to the students. From the question's wording I am left with the impression that you consider a question vetted after it's been used on an exam, and was understood by the students well enough to answer the way you expected them to. That leaves me wondering what happens when a question does not pass the test. I'm going to guess that the problem of disconnect between what you wanted and what you got, when it happens, is connected to the same issue programmers solve by using naming conventions: familiarity. Solve that problem by creating the tests in a spiral pattern. If you use the last bullet above, you can even make it a double spiral. This is a good place to use paper over digital, especially if the exams are issued on paper. Write down each problem you create in basic details. Using enough for you to recall it later without "fleshing it out" until later. Once written, so you won't forget it, move on to the next question. Having recorded all your ideas for question, return to the first and begin adding details, and cleaning up stray elements. What you "thought" the first time through is now muddied with everything you thought about since, and the question may be less clear than it was at first. Again, go through the questions, doing clean up, but not answers, yet. Once all the question are "polished", you can return to the first one and begin to create your answers. If the questions still need polishing, certainly do so now. This pass through you are in answering mode, and more resemble the student's approach to the question. It's not new material for you, but it shouldn't be new to them either. If you can answer the question in the same way, now, that you'd expect the students to, then it's probably vetted enough to add to the question bank. 

This is really difficult to communicate to anyone who hasn't lived through it (and even to those of us who have). I don't usually go back as far as the 60s. I show my students a picture of the ASCI RED supercomputer from ~1998, which was the first supercomputer to be able to perform 1 trillion floating point operations in a second (1 TFLOP). It's basically the size of a warehouse floor, with another floor consumed by its climate control system. It cost ~46 million dollars. Then I show my students a picture of a typical rack of servers from 2008, which could perform 2-4 TFLOPs. In a decade, the size had shrunk from a warehouse to a single rack, the computing power had doubled, and the cost was about $200K. Finally, I show my students a picture of a Nvidia K80 GPU card, which can perform over 2 TFLOPs. In less than a decade, the form factor has shrunk to a card you can put inside a desktop computer, with the same power. Launch price was about $5K. That is in less than 20 years. Extrapolating from that back another 20 years only gets you to 1978; you have to go 10 years beyond that to reach 1968. It's really hard to communicate the extent of this change. And that's just the change in raw computational power, ignoring other advances like the Internet... 

will cause more students to stumble, and not necessarily later. The emptiness might make apprehending the statement block concept more difficult than it already is. I'm also not so sure you should even divert into the infinite loop of at all. If you do use the LED-alertButton combination you presented in the question, modify it to respond as a toggle rather than a one-shot that turns on and then appears to ignore all future button presses. The program might loop forever, but it will look to the students like it turns on the LED and then stops responding. 

Not only will we tell students that, we should have that on the door lintel of every classroom and lecture hall where programming is taught. 

As a guest in the computer class, you could look for any instructors that rely on computer programs in their course material. Especially useful would be any that employ a program that is Free/OpenSource software. (If it is hosted on GitHub where they can also look at, that's even better.) A good candidate might be an art class that uses GIMP. 

The lesson looks pretty good to me. First, the last part, extending the lesson to show how the power of class is harnessed in the backend. Don't. 1) The students are presumed to already understand the OOP involved, and how the concept works. 2) Give them the remaining time, as you've indicated, to work on the project assigned. 3) Allowing them to explore what they learned, and maybe get a second sense about the power hiding under the hood will make them more receptive, and more curious, about that power, and its source. So, make that a separate lesson for the next class period. The only thing I can think of to make it possibly better, is to add some structure, or expectations, to the assignment. Possibly present a limited set of GUI templates to reproduce, allowing the students to pick the one they like to implement. Possibly add some constraints, such as that it must include 2 previously undiscussed objects from the library 

The answer depends on the desired outcomes for your program, as the capstone should accomplish at least some of your program outcomes. For better or worse, we have a variety of outcomes for our CS program, some of which are college-wide outcomes and others of which are CS-specific. We are unable to accomplish all of these in a single course, so we have our seniors complete two requirements: 

There have been some great answers so far; here is an approach I haven't seen described yet. I show my students how they can use the CLI to access our workstations from remote locations. My students have accounts in our lab of Linux workstations, but suppose they want to work on their project from their dorm room or off-campus apartment or home, or when the building housing our lab is closed? (Does anyone else have students who want to work on their homework over the holidays?) Using an ssh client and the CLI, they can login to a lab machine from their laptop (or even a tablet) and work on their project. Mastery of the CLI (combined with ssh) lets them work whenever and from wherever they want, regardless of when our lab is officially open. I happen to have an account on a Linux machine that's physically located in Asia. From my classroom in the US, I use this same approach to demonstrate to the students how I can login to that machine and edit/run a program there. That helps the students see that this generalizes beyond our campus to let a person access any machine on the Internet (on which you have an account) from across the world. In theory, this could be done using a GUI, but the amount of network bandwidth required to transmit a GUI's graphical information across the Internet makes this problematic. By contrast, the CLI just requires a modest number of characters to be transmitted back and forth, making this approach practical from just about anywhere. 

In the search for a "core set of concepts that is discrete mathematics as it applies to the study of Computer Science," I kept finding nebulous ideas, without concrete parameters. There seems to be a general consensus that there is the need for a firm foundation in discrete mathematics when studying CS. There is also a broad agreement that "graph theory, and other topics" is part of that foundation. Unfortunately the other topics portion of the requirements are seldom well specified, and seemingly never delineated with any specificity. I recognize that the question is in a high school (USA ages ~ 15-18) context. Be that as it may I've settled on a source from the university context for a solid, definitive, and delineated set of "core discrete mathematics material" to set as a touchstone. Williams College requires that students who select "Computer Science" as their major demonstrate a proficiency in discrete mathematics. This requirement is usually met with a "C", or better, grade in their MATH 200 course. In Spring 2017, the Computer Science department added an alternate method of satisfying the requirement: A "Discrete Mathematics Proficiency Exam." Williams is classified as "most selective" by U.S. News & World Report, admitting less than 20% of the applicants each year. As such it is expected that they have set standards, in all areas, rather high. However, I prefer to avoid the dangers alluded to by Michelangelo (disputed): The greatest danger for most of us is not that our aim is too high and we miss it, but that it is too low and we reach it. If I were to choose a target, aiming "high" has the advantage that I might reach the target. If I fail to reach the target, I will know how high I can go. If the aim is low, however, and I reach that target, I still will not know if I could have reached higher. Therefore, using the materials from Williams College as a guide for a high school course seems worthwhile. All that being said, here is the "short list" of their subject areas, (taken from their Preparing for the exam web page.) 

All of these require technical skills in the specific area, so your curriculum would probably need to provide courses to equip students with those skills. For example, if your department offers a database course, it might provide students with the skills to get hired as a DB Admin (or developer) somewhere. There are also "IT/Helpdesk Technician" jobs, in which the person helps people at the company who are having trouble with their desktop, laptop, or other computing devices. These require people skills, problem-solving skills, and a knowledge of the devices and/or the software on those devices, but little if any programming. If you can get students internships performing this role -- either at your college or at a local company -- that can provide a path to these jobs. There are also job titles like "Project Manager" that require people skills, plus an understanding of how the technology works and what it is capable of, but not the skills to create that technology. These people generally supervise software developers, and act as go-betweens between the developers and the clients, but don't do any actual programming themselves. We have a Software Engineering course in which students work in 4-6 person teams to complete a group project. One person serves as the Project Manager for that project, so they get a bit of training in this role; it's difficult to give all the students this opportunity in the confines of a single semester course. I'm guessing there are others, but those are some that come to mind. 

Another element to add to the solution is to slightly delay the HTML tags. You can start with a WYSIWYG web page tool. In that they create the web page that meets your listed objectives. Then you can switch from the visual results into the raw HTML. Using the generated HTML you can demonstrate simple changes to the code that are then visible in the rendered page. Add in simple CSS next, and they can witness the explosion of possibilities. If you can do that yourself on a large-screen, or projector, in a short demonstration first, then have them do it themselves, while making it all fit into one class session, that would be good. An additional tool would be a server for the room that each has a directory on that they can "publish" their page, and you can display it on the projector. Any simple server would work, even IIS on Windows XP could handle the task. That provides them with the chance to have their work on display as well, giving a nice ego boost, and likely increasing their investment in learning more to make it better. 

A few desks I've found online. Fairly basic version, with enough room for standard keyboard and monitor: 

Use a classroom activity, then present that as the analogy. An old campfire activity, for those that remember it. A growing story that nobody knows the end of, or even if it will end. The objective is to create a story, with everyone adding their parts, in turn. Someone starts the story by saying a few lines, and ending mid-sentence, just before some action happens. The next person repeats what the first persons said, and has to finish that sentence with something that makes sense, and then continues the story, using their own idea, since they don't know what the first person was thinking. Like the first person, the second stops mid-sentence in what they're saying. The third person repeats everything the second said (which includes what the first one said), and finishes the sentence left incomplete by the second. Adding more lines to the story, this person also ends mid-sentence. It continues in a similar fashion with each person repeating the whole story from the beginning, adding a couple lines, and ending mid-sentence. At some point the "next" person will not be able to repeat, even in their own words, the story so far, and the chain fails, hence ending. If it happens to be too short, or if not every student has had the opportunity to participate, a new story may be started, and try again. Once everyone has had a chance to participate, in as many rounds as you deem appropriate, you can pick up the chain and finish the sentence, and the story, bringing it to a successful completion. After the story, or stories, have run their course, you can relate the process to a blockchain. Each piece (except the first) depends upon the preceding piece, and is meaningless without it. If, at any point, someone in the chain doesn't hold up their part of the "contract," by completing the previous sentence, the story is ruined. Still, even without an end, everything up to the last incomplete sentence remains valid, and can be traced back to the original piece. This is totally non-technical, so it will not be of value in discussing blockchain implementations. It will, however, be memorable, and the students should be able to grasp the concepts behind a blockchain implementation when you do present it.