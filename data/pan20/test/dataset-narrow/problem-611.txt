Version 1: Basically OK, but the copying of elements to another list is unnecessary. Have a look at on how to create lists from a given index range. Additionally, you should change the return statement to so that the recursion does not take place if result is already false. (Look up short-circuiting in logical statements.) Version 2: NO. It is much better not to copy the elements and use indexes into the unmodified structure, but here you recurse for every element in the list, i.e. the recursion depth equals the list size. This is a total no-go, as it will definitely blow your stack if we are talking about serious data sizes. Nevertheless, explore the option of using indexes (maybe a start-index AND an end-index) into the given structure some more and combine it to a divide and conquer-approach as in your first solution. Happy coding! 

you can perform every possible action and return a detailed result ("performed 'A', but 'B' was not possible due to...") you can validate the actions, and only perform the complete set, if everything was possible ("no action taken as 'B' is invalid") 

You currently couple your SocketHolder class with the environment it exists in, as you have the comparable interface implemented in SocketHolder which in turn uses . I don't think that this is a good idea, as this dependency seems unnecessary and makes isolated testing difficult. (Or in other words: bad gut-feeling ;-)) Suggestion: as you set up your priority queue in a specific environment, and at that place it is probably OK to know the environment. So, use the constructor for priority queue where you pass a Comparator explicitly, and write a comparator which basically does the same as the compareTo-method you have in your SocketHolder right now. 

Added: As commented upon, your teacher is not fond of lists, so here is a version of the function without the list. Note that, in my opinion, it is a little better to change the order around, mainly because I'll expect the first case to be most prominent and should break out of the -block firstly. But that is a matter of taste, and your mileage may vary. 

To properly answer your question I would focus firstly on why you want differentiated test sets, and not carry all the eggs in one basket. After that I'll focus on using factories or not, before a little summary at the end. (Sorry in advance, for the somewhat lengthy response.) Some Test Levels Different test sets could and should have various focus and coverage area, which again will reveal various kind of errors in your code. Here is a list of various test areas (with my personal and simplified description): 

I tried compiling a new version using the online compilator at $URL$ but there was loads of errors and it seemed a little unstable. In addition, when trying to get information from OP regarding how you actually are running your code, and expected output, I didn't get much response. As such, I've failed getting you alternate refactored code better implementing a type dependent state machine in Idris. 

Complexity considerations Time complexity of any of these implementations (including your original one) will be \$O(n)\$. Slightly different memory complexity, but neither algorithm will use much extra memory (with the exception when using a list implementation of which duplicates the binary tree into a list thusly requiring more memory). 

Funny how nowbody seems to know the class... I agree with the previous answers, that try-with-resources is a good thing to do, but to perform the task in a real simple way, use : 

You failed to solve the "try to do this in one pass" part, as you iterate through the list once to find the total size and a second time to find the nth element from the start. The algorithmic idea is, to use two pointers into the list: 

Volatile won't do anything here, as this basically only affects the reference to the map, not the contents of the map. As for ConcurrentHashMap (as opposed to explicit synchronizing I suppose): this depends. If you want to make absolutely sure that no digest is ever computed twice, stick to your approach. If you just want general concurrency, but can accept that eventually in race-conditions, digest is called twice for the same input (sidenote: I suppose digest is deterministic, so that two calls with the same input yield the same result), you may simply repace the map with a ConcurrentHashMap and the whole method with: 

Search method: Search needs to loop to topPointer, not to size. As topPointer is already smaller than a starting i = 0 for an empty stack, you can leave out the precheck for emptyness: 

Furthermore, you can cut a bit of execution time by replacing the auto boxing and unboxing you do by using a mutable value class, something like this: 

AFAIR, styles are "heavy cost" objects in the workbook. Thus, create each XSSFCellStyle only once and reuse the XSSFCellStyle object for the same color. 

When timed (without the statements), this ran about 33% faster than the original. It does kind of reuse the random numbers slightly, but it shouldn't affect the overall randomness too much, I think. Other possible factors Just for the fun of it, I also tried exchanging the with a loop, but that only had a minor effect for the larger number of runs. NB! If you was using Python 2.x, there would most likely be a massive effect out of changing into . The could be eliminated, and the could be moved into the block. This also, has little to no effect in my tests. Lastly, using various python implementation will also effect timings. Using PyPy, IPython, C-Python(?), or other variations could change the time usage. I've used $URL$ which reports the following on : 

Having this helper class, , eases the task of the main class quite drastically, so I provided some extra methods to allow for retrieving the name/value combo by index, or by name, so that one could verify that the is in the right place. Some other comments related to the main class: 

The last one depending on the itertools.pairwise recipe, which returns all pairs of nodes from the start through end. Do however note, that neither of these methods are tested for efficiency or speed, but are mostly presented as alternate methods on how to do the check whether all the values are in sorted order which seems to the criteria for a binary search tree. 

Another algorithm Your algorithm builds up all permutations of substrings in the given text, and checks each and every one of these are palindromes. This gives a lot of extraneous checks as you keep on checking not taking advantage of known information. One option to get better response could be to check if the current word you're checking is already part of the results set, alongside with if you find a palindrome, then split it down into all the sub palindromes. Another option is to switch the algorithm around, and make the loop go through each character in the text, and see if you've got a palindrome when extending with the left and right character of your current character. This way you'll stop checking when it's not a palindrome and don't waste time checking non-palindromes. Here is that algorithm in working code: 

Process.waitFor will terminate the current thread until the process is terminated. Thus, at the place where you commented it out, it does not make any sense at all. You might consider putting a p.waitFor() after the loop, as to continue with your program only when the process has terminated. Apart from that, sorry to say so, your code is a mess. You use a very outdated method to start the process, you do not read stderr (which may lead to blocking conditions on stdout), code format is all over the place, p is declared outside the try block without any reason, exception handling is not present. To at least cover the basic necessities of reading both stdin and stderr, you should go for process builder and redirect stderr to stdout: 

You mix business logic with UI code. Normally, you'd go for separation of concerns and move the conversion functions into a separate class which is used by the UI, but does not belong to the UI. Running a separate thread: how long does the conversion take? 1 ms? 2? I really doubt that the overhead of thread-creation is necessary here. (Though it may indeed serve as an excercise!) Binary to ascii validation: if the amount of bits does not match, you overwrite the user input? Thus, if I, the user, make a little mistake, type 319 bits instead of 320, you actually force me to start over? /me pissed user :-) 

Regarding the method: you could at least eliminate the repeated call to s.length() for every loop operation: 

I'm coming back to this question as I'm not entirely satisfied with either answer or your original code. And I think the main part that is bothering me is the simple fact that you hide away an error situation. I think that both ways of detecting that the loop hasn't executed seems sensible, although the is a bit of a hack, but to me the main issue that you void the separation of concern by returning something when you don't find anything. This should be done in the outer code, in my meaning, and as such it would be proper to raise an exception instead of returning/yielding . So the last part of your code I think I would use something like: 

This patterns allows for your script to be called from the command line, and it also allows for use as an module, so that you reuse your function. And whilst at it, even though this is a rather simple functions, please look into using docstrings to document your function and potentially your module. 

I'm almost sorry to say, that it feels like you are naming things just because you can name them according to some coding principle. Calling a named tuple OOP, is stretching it very thin. Yes, it encapsulates something but it doesn't have any options to do actions on the object, and it's not a very good use of it. Could possibly use OOP if you used inheritance for the human player and the computer player incorporating the choice logic. But then again, that would ruin your so-called FP approach with lambdas and storing of functions. Which again is stretching it rather thin, as you don't use a functional approach avoiding state handling and mathemical functions on lists. So in the end it is mostly imperative programming, which most paradigms ends up with at some level deep within. And it's imperative programming with a very slight touch of OOP, and a very slight touch of FP. As this however is Code Review, lets add some review issues as well: 

I don't like the idea of modeling a common set of properties (or as you say "... for just about every API call..." probably a mostly common set of properties) as a superclass. IMO inheritance should be used to capture common business aspects, not common technical aspects. Or in other words, this feels somewhat like identifying a set of real world objects which have a lock, and then creating a HavingLock superclass with subclasses House, Car, Desk, ... - this simply does not sound right. Then, the CommonRequestCommand has the ring of something that is a pure data holder. It has a set of parameters and maybe even a specific execution logic that is tied to the service you call. Tying this this to the lookup logic in your own application will make this a hard-to-test mess. Thus, I agree that an immutable class will probably be the best, and furthermore recommend that you make that immutable class just a field in your commands. For the mutablility, you can always create a copy. All in all: 

This basically boils down to a grouping problem: you have an input list and want to group it by date, which yields a per-date list of a given length (1 to number of departments). Then, these list's contents get added to a collector list chosen by the list's size, i.e. add all contents of list with size 1 to collector 1, add all contents of lists with size 2 to collector 2, and so on. Using the stream API, you already have the grouping, the rest is a little footwork: 

Here is declaration of a three dimensional list of list of list (of ... :) ), where the first dimension is based upon your variables, the second dimension is the level (I only added 3, not 5 as you have), and the last dimension is for the two different randint-parameters. Have also added a print statement to list which combination is used for debug purposes, and some actual calls to the method. 

In this way you call the duplicated logic block both if there are data and you have a new owner, and if you've read the last record. Note that the will read records even though the condition is negated afterwards. Whether you feel this is a better approach or not, is left for you to decide, but it does avoid the duplication of logic you are concerned about. 

Here is another view on your class structure, in an attempt to make it both more readable and more pythonic so to speak. Let us start of with a yUml diagram of your class structure (somewhat simplified): 

Return at first fail The easiest way to handle this, is to make your own , which in addition to the normal parameters has a flag variable initiated within , where the local variant never executes the if the flag variable is set. This removes the possibility for changing the error code, and re-executing the after failing. Skip later executions An alternate version I've used in production code for a company is to have code which essentially behaves like the following: 

In the generalFizzBuzz method, replace the inner loop with a call to that function. Naming: "map" is a no-go-name. This is like calling start and stop "numberA" and "numberB". The map has a logical purpose, so you should reflect this in its naming. 

There's not much to add to @Imus excellent answer, apart from a little naming advice: your is in fact an edge in a graph. You even call the collection . So really should be renamed to to correctly grasp the business object behind it. (BTW: as an interviewer in a rush, that would probably the first point of criticism I came up with.) 

Harness the full power: Why stop at a single arg constructor and use a switch over the strings? Simply add a second arg, and set a final String for the name along with the number: 

Disclaimer: this has not been typed in an IDE or compiled, but just done on the fly, thus it might include bugs. But the concept should be clear. 

The most important problem I have with your code is, that it totally fails to achieve the goal you set yourself. This is not dynamic at all. Basically, you take the "normal" method body and put it into a lambda, but this lambda now is a complex function, which contains all of the business logic. Dynamically, you'd need a collection (probably list for being ordered) of lambdas, which each check a single input value and return an appropriate string representation (i.e. "fizz" or "buzz" or "whatever" or the empty string) and a method to apply this complete list on a single input, accumulate the results and perform the final check whether to output that string or the integer itself. Thus, start out with something like: