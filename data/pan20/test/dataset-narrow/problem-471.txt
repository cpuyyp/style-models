You are running into undefined behavior here, because you are reading from a union property without writing to it first. Unions should not be used to convert types to each other. It is not safe! I am sure, the code doesn't do what you expect. Your code says, you are converting a uint8_t pointer to uint16_t integer. You are not accessing the data, just the address! 

In the end I did not review the correctness of your code, I just stepped over the obviously mistakes you made in your code. 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

tl;dr Sort the , remove the duplicates and use a binary search instead of your linear approach and you will discover a huge performance benefit. 

Be aware of the fact, that you have to take care for the cases, where your vector size isn't a multiplication of thread count. There will be some elements left untouched, but I let this job as a task for you ;) 

As you can see, I renamed my class to SynchronizedValue, because I find it more descriptive than LockedValue. The behaviour of the class stays unchanged, I only did some minor changes and I want to describe why. In every state of this class, only one mutex gets locked. Even in the move parts, I only had to lock one at the same time. This prevents me from getting into a deadlock. The real important part is in the function. In the last state of this class I returned a rvalue reference, which was bad, because when I really started to move the value from other, outside of the function, the mutex already was getting unlocked. This means a race-condition could occur, which is absolutely bad. To fix this, my only change here is to return a real object instead of a rvalue reference. The second important change is no code change at all. It is also closely related to the function. I am talking about the move assignment operator. While I had to check the self assign in the previous version, I can now just take the value and store it safely. The cleanup, which is the bad thing of a self-move, already happened inside of the function. Thus, it should be absolutely safe to deal with the self-moving problem. Why no noexcept The lock functions of a might throw, this means I am not able to make a guarantee for exception safety, unless I would write the whole function inside of a block, which is never a good idea to deal with exceptions. It is not a mistake to declare a move-assign not ; it just makes some optimizations for some classes impossible. why a and copy ctor That's a good question. While I know, that usually a copy ctor is enough, unless you have to modify the original object, it is here required to make the templated ctor possible. If I delete the non-const version of the copy ctor, everything works fine, unless I try to copy from a non-const SynchronizedValue object. A conversion from to is required; and a templated overloading always has a closer match than an overloading which requires a conversation; even when it's just the to a reference. I played a little bit around with SFINAE, but I got no nice solution for that (there might be a solution; but I wasn't able to make it work), thus I used this easy way to deal with this issue. The problem is, I can't SFINAE the copy ctor, this is the wrong way. I have to remove the templated ctor from the match list when I want to copy; and that's the real issue here. The idea, which someone came up with, was to try this one: 

I would first write (or find) a function for shifting a vector by a given number of observations . The package has a function but it only allows to shift in one direction ( has to be )... Here is such a function that will work both ways, with positive or negative : 

Using your 2D example, doing is the obvious solution, both elegant and fast. So your way of generalizing the use of via to handle any number of dimensions is what I would consider the optimal approach. The rewrite below won't make the code faster but maybe a little more simple and robust. The main improvement is the computation of the using rather than a loop. And I added a number of checks to verify all the assumptions you are making regarding your inputs. 

This code has a baked-in assumption that there are four cutoffs. If you were to modify so its length is not four, then this would break. Instead, you could do: 

I'll give it a shot, as I read through from the top. I'll skip the comments but keep them, this is an excellent habit. You are doing well identifying your globals and leaving them at the top like you did: 

so we will be calling . All that is left is to write : a vectorized function that will take as inputs two vectors of airport names and return their distances. We could first put the important data in a matrix with airport names as row names for easy access: 

You are missing a key feature of the R language: "vectorization". A fancy word for saying that most functions are implemented in such a way that you can provide them vectors and they will apply the computations to each element. As an example, the multiplication function is vectorized so you can do and it will return the full vector of where goes from to . This is less typing than doing and also a lot faster as you can test. Applying that idea throughout your code, you can rewrite your as follows: 

You make your code more self-descriptive. your Socket class Your class suggests an other meaning, than it provides. It should handle the sending and receiving without the need, to specify the explicit. The user shouldn't be forced to pass the themselves. That's up to the class, to provide the correct socket (at least you are holding a socket as private member). Think about that, perhaps your class has simply the wrong name for its purpose. use instead of heap array You are using a heap array as a read buffer. This yields exception errors, and it isn't totally clear (at least for the user of the Socket class) who is responsible for the cleanup () of this buffer. It is never a good idea, to hand back a pointer, and let the user cleanup the stuff by themselves. Instead, you should simply return a . That's clean, smart and has no hidden traps. If the user decides, he doesn't need the buffer anymore, he can simply let it go out of scope and it will be deleted automatically. The problems are even bigger, when an is thrown by any part of your framework, the users code or any other part of the program. If you want to pass ownership, use the provided classes. For strings it's , for every other point it is or . When you think, "returning a char* has better performance than returning a ", that's not totally true. Most of modern compilers can optimize that. You should google for "" (). In it is guaranteed, but in or it might fail. But even in that cases, a simple move of the happens, which is not as bad as it sounds. 

It would be nice to get an explanation of what your "needs" are. But either way, here are some recommendations for your coding style and other simple stuff. enums You are using an , but instead of using it as a parameter, you are using ? In the comments above, you are explicit defining the values. That isn't necessary, when you accept a parameter of an type. You should also use the more strict type. This prevents users, to accidentally passing any other values than the types. That means, your enum would look like this: 

The main thing to note is that your profit function only uses vectorized functions ( and ) so it is vectorized with respect to its four inputs. This means that you do not have to create loops; instead you can just feed the functions with vector(s): one vector for the variable that you are shocking, and scalars for the other three fixed inputs. Here is my suggested rewrite, having put everything into a function: 

2) Your choice of will not properly handle the . Also, it does handle the case properly but it is a bit of luck considering you are looping over ... The robust alternative to the operator is to use or . Or you could just have a near the top of your functions. 3) While on the topic of corner cases, your code assumes that is a numerical vector. You could be checking for that by adding: 

I see nothing wrong with your implementation, in the sense it does exactly what you described in plain English, and somewhat efficiently. Here are however a few pieces of advice, mostly about improving your coding standards. 

This can be handled using matrix multiplication. Under the hood, matrix multiplication contains a for loop just like your code does, but it is a lot faster since it is all implemented in pre-compiled code. So first compute a matrix of and where each row corresponds to a combination and each column corresponds to one of your variables: 

Edit: And to handle a vector of as input, make these slight changes. It will return a list of matrices. 

If my first suggestion is still too slow and your matrix is so large that my second solution cannot be used, you might want to use a mix between the two approaches, where you loop on chunks of rows, i.e. rely on . But I'll leave that to you as an exercise :-) Finally, I will point out that if you are interested, you could search CRAN or the internet for a package that does exactly what you are after. KNN is a very common tool and there must be packages (compiled from C) that already do it much faster than this code will do. But not much to be learnt there... 

I think this is nasty: it modifies the string pointed to by . Granted, it is a instead of , but ultimately you're modifying the string from your s (BTW, the convention is to call that ). I would make a local copy of for that. That way, you could turn almost all your into (and const is good since it helps find accidental manipulation bugs). Standard compliance What is your option? Neither my GNU nor my BSD know it. Since you fall through to they're equivalent so you might be thinking recursive? It needs a comment, IMHO. Help If your tool is called with wrong or missing argument, it silently exits. IMHO a good command line tool should always have a help/syntax page. Return value from When you encounter an unsupported option you do: 

Either the call to succeeds or it doesn't. Your version doesn't make it clear that this really is an either/or. 

Instead of using a recursive algorithm (which might overflow the stack for large exponents) and calculating the power yourself, use the function which is likely pretty optimized. 

Now a few minor remarks about your original code: be sure to be more consistent with your coding style. For example: 

I think it's a not a good idea to have an and a newline without curly braces: either it's one line or it has to have braces. For reasons, see Apple's . Logic/intention This is also more on the personal opinion side: 

Apart from the fact that I think these s should be broken into several lines, I think they should be written as: 

Personally, I'd always either write it on one line as in the second example or if there is a newline, I'd always add braces. For reasons see Apple's . But it's actually a personal preference, you don't need to do it that way but I highly recommend that you chose one style and stick to it. (Same with whitespace: there should be a space after the in ) Consistency would also be nice here: 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

don't use You should not use because it eliminates some important information, which may lead to some conflicts with your classes or classes of other libraries. It is not uncommon to have a class, which has a totally other meaning than the . And to be honest, it isn't that much more work, to type in front of the classes/functions, is it? use You do everything with for loops, which is bloated and error prone. Use the algorithms of the namespace instead. I provide you with a short an clean example, how you could do the above task (and more) with less lines. your algorithm itself You should think about logical improvements. Is it necessary to store every score in a vector, when equal scores produce the same rankings, and the following scores just increments by one? Therefore I took the algorithm, which returns a . doesn't erase anything itself. It just moves duplicates to the end of the range (our ); you have to them manually. But, before you can use you have to order your elements. I don't know if it's guaranteed to get the score input in a descending order; thus I simply use to ensure this. After that, it's a simple (which is a binary search instead a linear search) to get the first iterator to an element, which is not less than the provided score (ok, I had to pass an other function object, because we want to check for greater and not for less). starts with a zero index. This means, we have to add 1 to our index, to get the official ranking. Easy, huh?