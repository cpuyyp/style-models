Then I point them to their notes for a myriad of examples for how to declare an integer variable, or even to a previous, simpler exercise where they had to do it. In other words, I make them find the answer themselves. This gives them a greater feeling of accomplishment and also makes them less dependent upon me. I find that by giving them this "scaffolding", I rarely have to provide an actual code solution, but will upon request. 

Of note from other posts: Reading the answers to Techniques for encouraging pair programming and What advantages/disadvantages have you seen with Pair Programming in the classroom offers insight into the problem of encouraging students to actually "work" together, which can be part of the problem here. The real issue, however, isn't that the other students aren't willing to do the work, rather that the Lone Ranger just does all the work, usually before work begins, without the others even having the opportunity to work. Two other questions, Is it possible to ensure division of labor on a group assignment?, and Problematic student at a very high level, help with creating the environment and assignments to enable group work, and determining if someone has gone rogue and done all the work. Neither deals with preventing the Lone Ranger from repeating once the problem has been identified. 

I'd like to introduce my students to Nodes and then require them to implement their own Linked Lists, Queues, and Stacks before showing them that their language (C#) provides implementations of these data structures. I suppose my motivation is that they will 1) understand better how these structures behave; 2) gain general language practice; and 3) appreciate libraries and be more motivated to search for an implementation before writing their own. Is my motivation valid? What are other reasons to ask them to implement these data structures? Is there any reason NOT to ask them to do this? Would I be wasting my and their time? 

Where is the inheritance? I'd like to point that I didn't use Python's subclassing at any point here, and it was on purpose: Python's subclassing is mostly about implementation inheritance, and here it's not necessary at all. Of course, if you use type hints, you should define an interface, but only in that case. Python is generally duck-typed and there's not much point in pretending it's not. However, you can also add some shared implementation to this example. Adding implementation inheritance There is at least one thing that all kinds of expressions may easily share: caching. Example base class could look like this: 

Implement nested arithmetic expressions. Let me start with what it can look like, and then I'll explain why it's a great example. It starts very simple: 

That may not be the best metric. Even if it's actually possible to tell apart populations of people with basic programming abilities and those lacking them, it's not enough of the solution. Some people may be quite capable, but still dislike the process. So there will be people trying to study CS that will eventually want to leave. Maybe it's better to just make these people leave quickly The way that my university was approching this was to put fast paced programming course with focus on algorithms in the first semester. The course, apart from teaching obvious skills, had an explicit purpose of failing or discouraging all the people without the skill or interest necessary to finish the studies¹. And then in the second semester, it was followed by writing a sizable GUI application as an individual project. While I don't have any numbers, I believe it worked kind of well. It seems that whoever survived the first year and was willing to stay, was well capable to finish the undergrad course and find work in IT. However, there are some caveats The main issue with the presented approach is that it's strongly negatively biased. It discourages all the people that should be discouraged, but perhaps discourages also some happened to be just a little bit to slow. And while a university sucking up in all the best country talents may afford being picky, I'm sure it doesn't work everywhere, at least not at this scale. It also must be more tricky in a private school. My university was public, and people generally paid no tuition. 

We all have them - students who want to write all the code themselves, who don't want to be part of a group project. They have poor social skills, or they don't know anyone else in the class, or they don't trust others, or they think other people "slow them down". So they go home after a group project is assigned, write all the code themselves, and bring it back to the first group meeting, completed. A typical situation is a group project done in a class or lab period over several days. The instructor or a lab assistant is present to watch over the students and give advice as needed. Different strategies might be needed if the project is done outside the view of faculty on the students' own time. This could also differentiate depending on whether the situation is the first occurrence (you are surprised by it), or if you are familiar with the Lone Ranger and know he or she has a history of going rogue. What are your practical ideas for preventing a student from taking over a group project, or dealing with it after it has occurred? 

I think this answer is a little different, please remand me if not - I provide an algorithm with my coding assignments, and I almost always have code I can point to in their notes or previous assignments that is exactly what they need to fill in the algorithm. First I give a general description of the problem: 

Do you allow students to submit "test corrections"? Meaning, do you allow them to take the questions they missed on a test, denote the correct answer in some way, and give them partial or full credit back if they then get the answer right? If so, why? If not, why not? I'm wondering, because I have a colleague who has ALWAYS allowed test corrections in her CS courses for half credit. I NEVER have. But this year, for some reason, I am getting a lot of lip from students like "What! No test corrections?! But Ms. Xxx always let us do test corrections!" I believe allowing test corrections (which is essentially a retake) does a disservice to the student because it allows them to be lazy. They don't do it right the first time. They don't study (or don't study as much as they should have) and depend upon "corrections" to make up for their laziness. My colleague believes allowing test corrections at least forces the student to "discover" correct answers to questions they may have never revisited otherwise, and that therefore they have another opportunity to learn. Am I being too hard? What do you think? 

Note: Initially my answer was just about computational complexity, but then it grew a bit, so I broke it into multiple sections and tweaked each a bit. Thanks to commenters for pointing out the details to fix. Understanding computational complexity That may be covered by your "understand better how these structures behave", but it important enough to deserve its own place. It is very hard to appreciate the computational complexity behind a library structure operations. You don't need or should care how things work under the hood, you should be happy with information that given operation is guaranteed to run in "O(log n)" or "O(container size)" or in "amortized linear time". But to get a good grasp what all that O-speak means, you should actually write the code that iterates over a linked list or finds stuff in a BST. Once you have some well set expectations of how things work, you can move on and perhaps never write own containers again - but you will forever remember what happens under the hood when you call some random library method (or at least have a rough estimate, see Certainty about behavior). General knowledge about writing containers (mostly inspired by Buffy's answer) If you ever happen to actually write a container (e.g. one missing in given language), you will not only benefit from specific knowledge about containers you wrote, but, more importantly, from general knowledge about writing containers. There are several reoccurring patterns about containers design, and knowing them from the "internal" perspective certainly helps. Certainty about behavior That one may be important for educational value. Only writing your own structure or algorithm gives you certainty that it behaves as you expect. Built-in structures may often contain extra optimizations and don't necessarily implement any "canonical" structures. They differ in details. Avoiding over-complex library APIs Library containers not only may behave in "non-canonical" way. Their APIs usually contain many additional functions that, while useful in production code, for learning are just unnecessary distraction. E.g. in C++ containers have multiple variants of every method just to allow optimized memory management, or some syntax shortcuts. C# is not very different. De-mistyfying library code Direct answer for question "why do we have to do this": to see that there is no magic. You can do all that things, using libraries is mostly just about saving time. Debugging your own components will likely help you appreciate that libraries are well tested and patched, but should also show that writing similar code isn't something unreachable. 

If that's all they need to read, they can go from there. If they need to read further, then what follows in the same document is the step by step algorithm, but not code. If they get stuck in the algorithm, on, for example, a line that says: 

My gut answer is "no", but that's all it is - a gut reaction. However, I do have a suggestion as an alternative: cross-curricular projects. At my school, we have developed several cross-curricular projects over the years that accomplish what I believe your school is seeking. For example, in the fall of their sophomore year, students are required to take programming, Earth Science or APES, and of course English II. The cross-curricular project for those three courses is one in which they must research ten population equations, find data for several geographical areas, write a program to accept user input and/or read data from files to calculate and output population statistics for their geographical areas, and then write a project summary paper for their English portfolio. That is just one example. There are two major cross-curricular projects each year of their high school career, and each project includes at least one technology course and one science course. These projects have taken years to develop. But through that development and execution they have provided synergy and cooperation between and among several departments without merging. 

Note: Like the OP, I teach high school. Some of the things I discuss may not be useful in a university setting. Resubmissions are not a factor for me because I will take anything from any student at any time. And it must be correct. So they get 100%, or they get nothing. Wait before you shoot me. Timing: When I assign an exercise (program), I let my students know when it is due. I create the assignment in the grade book with its due date but leave it blank (we use PowerSchool as well, mentioned in another answer). As the students complete exercises, I check them off on a paper checklist. When the due date for a particular exercise arrives, I transfer checkmarks from my list to the grade book. If the student has a check, they get the points. If they don't have a check, they get a zero. To get a check, their code has to be correct. It must have the expected output. It must adhere to all coding conventions. And it must use the structure suggested in the assignment (e.g., a foreach loop instead of a bounded for loop). Of course, I allow for personal variation that is not blatantly incorrect. Coding is a creative process and each student develops their own style. I use zeroes in the grade book because it creates a sense of urgency in most students. But the zero is just a place holder, a reminder that something is missing. The student may, at any time, turn in their missing items, up until exam day. I clearly communicate what the zeroes mean to both students and parents at the beginning of the semester. My students actually like this method and give me positive feedback about it. I allow what some might call "late" work because not everyone works at the same pace. Some students are just going to struggle (and Carol Dweck suggests that the student who struggles may actually learn the material better in the long run than the student who gets it immediately). Not everyone has a wonderfully happy, supportive home life. Not everyone has a two-parent family. Not everyone feels accepted and affirmed at school. Not everyone is healthy all the time. I don't know what my students face when they leave my classroom. If they really want to do the work, I want to take it, no matter how long it takes them to complete it. Do some students abuse this? I don't have many who try. Students who care about their grades will work diligently to get work in no matter when it was "due". Students who don't care weren't going to turn it in anyway, due date or not. Even with this system, I would say 90% of my students turn in their work "on time". Cheating: My best defense against shared code is my familiarity with each student's coding abilities and style (or lack thereof!). When not actively teaching, I am circulating the room, interacting with my students, watching what they are doing - not in a hawkish way, but in an interested, encouraging way - "oh, you decided to add graphics to the assignment, that's cool". This way I can watch progress, help with errors I see before the student gets completely off track or wastes a bunch of time, or notice a student go from blank screen to complete multi-page solution - still highlighted from the clipboard - within one circulation of the room ("hmmm, where'd that come from"?). I can also gain insight as to how and why they do things, become familiar with their coding style, and nip bad habits in the bud. When I first started teaching, I thought if they were coding quietly and there were no questions, I should just sit at my desk and ignore them. Not anymore! I stay engaged and give them my full attention the entire class time. They deserve it, and it really makes my job much easier in the long run. (Honestly, a very good rolling chair helps with this. I have my lab set up so I can easily roll and achieve maximized, efficient coverage). Checking code: I don't ask students to submit code electronically. I check code for assignments with the student at their computer. Meaning we scroll through it together, with me asking questions as I see fit. If it's good, they get a check. If it is not, I tell them what to fix (or guide them to it), and they call me back again for a re-check. This works for me because a) I'm familiar with the way they do things and can almost immediately tell if they are showing me code they didn't write; b) I'm an extremely fast reader; and c) I make sure I have written a solution myself ahead of time so I know what I'm looking for. Note: If I really feel I need it, I already have an electronic copy of students' work because of the way our network is set up. Every student has a virtual drive. All student work is maintained on their virtual drive that only they can access when they are logged in at school. Yes they have a lab computer, but they are restricted from accessing the C:\ drive. Any projects they create (code or otherwise) are saved to the virtual drive. Teachers can access all students' drives. So I can access each student's work from my own computer. If I have academic dishonesty suspicions, it is easy enough to compare time stamps or file sizes between or among students and determine if sharing has occurred. Johnnie was missing 10 projects yesterday, but now he has them all, and every folder was created at the same time (when he unzipped his friend's work)? Nada. In summary, "resubmission" is not an issue for me. If my students did the work, and they want to give it to me, then I want to take it. 

One problem with these examples is that the base class is more of a mixin than a real base. But I don't think you can do much better without going big. So, ultimately, you may want to go big. Want really interesting inheritance? Go big, use a framework. While little examples like above are good for understanding the basics, the most practical examples of implementation inheritance are big, all-inclusive classes provided by frameworks, like Django's views and forms. You may consider using them to show some practical uses of inheritance. While writing a Django¹ application is definitely an overkill, modifying one may be perfectly good task even on (relatively) early level. If you prepare a working application that needs relatively small modification, like adding a view with different sorting, it may be a good hands-on experience. However, this is risky, and may be daunting experience if either students or exercise are not prepared well enough, so proceed with great care (if at all). 

Starting languages for wannabe-developers Now, to the other question: "do you agree that starting with C/C++ is beneficial for a deep understating of programming"? Yes. For a person planning to do any serious programming, I'd perhaps recommend starting with C++ (where "++" stands for "streams, strings, vectors and maps", maybe now also "smart pointers"; the rest is confusing and unnecessary noise) or Pascal/Delphi (that's what I actually started with) for less opportunities to shoot your feet, and a good GUI library with IDE support. It is also very useful to do some programming in a functional language (OCaml? Scheme?) early, to get some different perspective on programming, with better structured framing. I'm not sure it's a good first choice though. However, I'd be careful to not go into too far into high-level programming in C++. C++ "high level" structures are actually thin wrappers around explicitly low-level stuff. To write classes and abstractions, take a proper high level language, perhaps Java or Scala. C++ is not a high level language, and I tend to treat it's high-level features as a kind of a last-resort: if you are bound to using C++ for performance and low level features, that is how you get some abstractions. As for starting with higher-level languages, my intuition is that thinking about classes and this kind of abstraction is unnecessary noise at the entry level, which is why I look with great suspicion at starting with Java (in which even a "Hello world" is in a way OO). I don't have any data-backed point here though. Additionally, I find the Java memory model (i.e. references everywhere) to be both confusing and misleading. 

In my experience, there are always students who are resistant to moving to more advanced constructs. They want to stay with what they already know. For example, when they are taught arrays, they continue to use individual variables when they are able. When introduced to the foreach loop, they continue to use bounded for loops. When they learn about functions, they resist modularizing their code. After working extensively with arrays, they don’t want to move to using built-in collection types that offer more flexibility and behavior. It is sometimes difficult to impress upon beginning programmers the usefulness of “new” constructs, because the exercises and programs they are capable of undertaking do not sufficiently demonstrate the power and usefulness of those constructs. What are ways to encourage beginning programmers to embrace more advanced constructs without penalizing them? I am looking for more "carrot-y" answers than "stick-y". 

Every career has "gotchas". There is something about every job that is undesirable. That's why it is called a "job". But students can make sure they are matched as well as possible - minimize the "gotchas", so to speak. I entered CS because I loved to write code. I stumbled into the field as a junior in college and immediately changed my educational course. I am thankful for that "accidental" encounter, but it wasn't an accident, I don't believe, that I loved computing as soon as I was exposed to it. My "desire" had been predicted. I remember taking a career assessment of some sort as a sophomore in high school. I remember the career assessment saying I was a good match for "computer science". I remember thinking "what the heck is that?" (this was prior to the PC revolution), and I remember immediately dismissing the results of my assessment. But the assessment was correct. I say all that to say this: students should be encouraged to use career and interest assessments in high school, maybe even repeatedly (once a year). A quick Google search reveals many free assessments, and my state's college foundation provides 7 of them for free in one place. Up until recently, the students at my high school had been required to do several of these assessments as sophomores. Unfortunately, with a change in management, that practice ceased. But I still have my students do them as part of my class. We all should, I think. Using assessments such as this at least helps students better understand themselves, and may prevent them from making a very bad career choice. Of course, sometimes the assessments will be downright wrong (I recently had a student, one of my very best programmers, who loves to write code, is good at it, and knows she wants to go into CS, have an assessment tell her she should be an artist; however, I don't believe it was entirely off track because her code is very creative and is an artistic outlet for her). But sometimes career and self-assessments will help a student think outside the box about what they want to "be". And that is a good thing. Another thing my school does is bring in professionals to share about their jobs. They speak briefly about their backgrounds, what they do, what they like about their jobs, and what they dislike about their jobs. They usually speak during lunch in a classroom. The kids eat their lunches while they speak. It is very informal and always well attended. The feedback from the students is always very positive. Our local CDC (career development coordinator) organizes these "Lunch and Learn" sessions, as we call them. We have 5-6 a year. These are tangible things you can "do" to help students get ideas about careers. Some students may still fall headlong into something that is not a good match for them, because of tunnel vision, or peer pressure, or parental wishes. But some of them will identify or reinforce what they love to do, and they will be willing to make the trade-off: you pay me to do what I love X% of the time, and I will put up with the 100-X% of the time I have to do stuff I don't necessarily like.