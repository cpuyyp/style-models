I think you're making it a little too complicated, or not complicated enough. One direction I would suggest would be to break apart getting health and doing damage interfaces. So maybe as an idea, your Armor component would look like this: 

A good coder is a good coder regardless of their specific background. It's really just a matter of how much time the company is willing to spend on training/learning for a new coder to become familiar with whatever tech they're working on. Some companies hire to fill positions. In that case if you have experience in X and they're looking for somebody who can do X, you'll be bumped to closer to the top of the queue. Other companies look for targets of opportunity and realize that learning new software and languages is easy for any mid/senior programmer worth his salt and would fit in with the company for other reasons (i.e. culture). It depends. That being said, not having any C++ experience can be a red flag companies doing at least some C++ work, as "getting pointers" is pretty fundamental. 

Check out the Unity engine. They've done a lot of work on making their tech work with a very wide range of hardware, and have nice tools like graphics emulation so you can see what an older machine would be drawing while on a newer machine. It's relatively cheap and has a really good workflow, so as long as you're not trying to squeeze all the performance you can out of an older machine it's hard to beat it's price/value ratio. Fundamentally, though, if you're dealing with old PCs, you're going to be limiting yourself to something probably DX7 level or so. OpenGL drivers are notoriously bad, so I'd suggest going the DirectX route. You're probably not going to have pixel shaders (those came out with DX8/9 cards I think), so you need to do everything fixed function. Unity handles all of this for you. Edit: You can download an use Unity free of charge, with certain restrictions. It doesn't play well with team development, but if you're doing small things by yourself then it's more than capable. 

Unity best practices are to never use in any of its incarnations at run time. It's slow and unnecessarily ties the name of the object with its functionality. Any time you call you can save off the return value and store it somewhere (i.e. a in some component your write). Then you can just iterate over the elements of that list to get what you want. So for your spawner example, your spawner could have a list of game objects that it has spawned. In you can iterate over that list and count the number of non-null gameobjects (to check for destroyed objects). Alternatively the enemy can have a reference to its spawner and remove itself from that list in . Then if that number is less than a certain value spawn a new one. 

Schooling isn't going to get you a job. If you're good at what you do, and you care about it, you don't need a degree. A game-focused degree is good at helping you getting your foot in the door since a lot of those schools have teachers or advisors who are actually in the industry. It'll also help you by providing you useful team experience. Also, and this is very important, a Computer Science degree is not about programming. You might have a class here and there that might be useful, but the degree as a whole is not about good programming practices or really anything pragmatic that you would need on a day to day basis. (Note: this may vary based on your school.) That being said, getting a CS degree usually implies going to a non-game-focused school, which also implies getting a more well rounded education, which might pay off int the end. Also a lot of regular schools have game development programs these days which could get you some connections to the local industry. At least in my experience, getting a certificate from one of these game development colleges is almost worthless on its own. Unless you have side projects or have some kind of way of proving that you care about whatever field you're interested in other than just going to school, you'll be going in the "maybe someday I'll get around to these people" pile of resumes (hint: I won't). Edit: since I really didn't answer the question, basically my opinion is this: If you have the motivation to work on games in your spare time, do that and get a traditional education. It'll pay off in more ways than if you just went to more of a niche school. If you're the kind of person that works better when somebody is telling them to do something, or if you need to feel like your money is on the line, try to go for a game dev school instead. If your sole focus in life is to get into the game industry (it shouldn't be), and you're smart and motivated enough, try taking a year and working on things in your spare time (mods, solo projects, demos, whatever) and bypassing both options. 

Well the first step is to verify that your OnTriggerEnter2D function is getting called. It's easy enough to put a debug log in there with who it collided to. An audio source is just that -- it's a "source" audio. It contains important things like positioning and so forth. On the audio source is a field for audio clip. Assuming you have a clip in there already (e.g. this is on a prefab and you can edit it in the inspector), then calling should play it. Check the audio source to see that it's not firing on startup, that might be another issue. 

I don't know the specific limitations of Unity Free, but I wrote a little editor tool to do something like that. Basically it consists of an editor window with a bunch of object fields setup to take game objects. Whenever one of those object fields changes, it uses something like to determine what components are on those objects. It then populates a list of which components are shared between all of the game objects. When the user selects the field, it uses standard .NET reflection to determine which fields are either 1) public or 2) marked with . From there, of those fields, it displays editor fields for those types that make sense. So int editor fields for int fields in the class, etc. I think I store this in a or something similar. I may store a bool with it as well so that you can check which fields you want to actually be applied. Then when the user clicks the editor button, it goes through each of those game objects, gets that component, and sets the field value to be what's in the editor gui fields. I think I also had to do this with reflection, I don't have the code in front of me. Now if you're going for something a little less general, you can do something similar where you only check for the predefined component instead of using reflection, but the concepts would be the same. Unfortunately I couldn't find any way of showing something like the inspector gui shows for a given component without using a specific instance of that component, and Unity doesn't have any nice built in editor fields for things like arrays of serializable types and that kind of thing. 

From my experience, most 2D games on the iPhone are written in OpenGL ES. Their 2D game demo is also written in OpenGL. I would go with OpenGL, if only because you're more likely to find a lot more resources for game-related problems in OGL instead of CoreGraphics. There are also some OS level features that make working in OpenGL less painful than on a few other platforms. For example, you can use the NSString class to render to an OpenGL context, and get full, dynamic, Unicode support right off the bat.