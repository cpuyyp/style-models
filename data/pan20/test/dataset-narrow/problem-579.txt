Calling with simple will not work. The code is only checking if the first of the string matches its end. Original reverses the contents of . This may be an very unhappy side effect for an application calling An efficient re-write of would find the length and then do compares. 

Further, consider using different constant names should you later want a rectangle matrix. Even if both are 50, this better self documents the code. Recommend to not declare many variables declares on a line. 

Code design has problems if is negative. After summing, the sum may have some LL nodes with positive values and other with negative ones. Additional code needed to handle this, including the shrinking of the LL, should there be cancellation. If code is only designed for positive numbers, then use 

The below could use or . These functions are typically optimized for speedy execution, especially long strings. The key performance assessment should be based on long strings and with sufficient space. Little need to optimize for undersized values of . 

C1. is OK code and like-wise allowing to free again a link list is good. Just clear the head node to an initial state. Detail: should be able to be followed by a another . 

is a problem. If it represents the result of , then it is not needed as can calculate that. If represents the of , then writing the is occurring outside the size of even with the above fix. If code uses , using makes more sense than . Consider returning something useful rather than . Suggest returning or a flag indicating some toggling occurred. 

On return, I'd expect a value that is enumerated like , etc. Rather than magic numbers . It could end up being a simple . As is , I see no value in making a field like . is simpler and sufficient. OTOH, if there is some value, then should also be as in . Delay/remove s. 

OP's use of a local would benefit with a "only the member is used" comment. The use of a temporary "root" makes for efficient code. Don't give up on this style. 

Poor use of . In , is a null pointer constant best used with pointers. is a , not a pointer. Suggest below: 

The following has problems. If input had 10,000 character before , would overfill when the was appended. At the other end, reads nothing into if the first character is . In both cases, following code is undefined behavior as is not set or is corrupted. UB. Better to use 

Small simplification with . Using a instead of allows a simplification that a compiler may not catch. Similar with 

Further improvements maintain prime lists (not shown) and use of the quick sieve of Sieve of Eratosthenes - practical when bits of memory are available. Many compilers when performing can calculate for little or no extra emitted code. Source code can use the quotient to stop the loop far sooner: about iterations rather than . This is better in many cases that than iterating to (using the function) as that invokes floating-point math with its rounding issues and potential less precision that the chosen integer type. 

Sample code. Use for the final code. Use for testing. Using a allows code to run just a portion of the values needed for testing. A of 50 took a few minutes. A of 20 took a 4 hours. Expect a of 1 would take years (5?). When , you need type that is really 128 bits, unlike the place-holder used here. 

Better to get return value of input functions (4 places). Even in learner code, it saves time during debug 

Good formatting. Yet look at the question's code. Is there a horizontal slide bar to show ? To me, that means code is too wide. Wrap to review's presentation width. Auto formatting should make that easy. Idiomatic compare that many compilers recognize and emit efficient code: 

Not too easy to re-organize too much without violating coding goal of "demonstrate the proper way to use format specifiers for different data types". Perhaps a helper function to print the common prefix and size to un-clutter the demonstration. 

Using a name that is close to standard names is tricky. C reserves name with certain prefixes, etc and so does *nix, etc. Maybe use and an optional . Corner case: Returning with does not make sense when . I'd expect . Underflow possible. The length of the may be longer or shorter than the 

Consider this 2nd style. Easier to code, less chance of coding error, easier to review and maintain. 

A small optimization would be to use an idiom recognized by many compilers for comparing two numbers. 

Functionality 1) Incorrect functionality when a few characters read followed by and not as it leaves without a null character termination. 2) Better to not consume from if no more room available. Do not read or put back with . 3) Return when nothing read. 

Magic numbers. No idea if 64/32 is sufficient. Consider a constant value derived from other limits if variables, use dynamic sized array or something, but not an unadorned constant. 

Good use of functions. In general, good naming convention of functions. I'd expect a function that returns the count of queue members. By naming, I was surprised that removed the top priority element and not just report it. Consider 2 functions, one to report and another to pop it off. "priority_queue.h" should document the interface more as this is what users see. In particular, detail the meaning of the return value of and how it affects the queue. Negative return bubble up or . What happens when return value is 0? Advanced concept: state that the must be consistent, like the compare function for . It must report the same sign of the result for the same argument pair each time it is called. specifies it this way 

Minor: is passed around a lot by value. Typically structures are passed by their address. Yet is small. Consider making it smaller 

Allocate to the size of the de-reference variable, not to a type. Easier to code, less chance of error, easier to review, easier to maintain. 

and are the same, yet the one used by OP does not match the one used by the C standard. When looking for clarity, recommend following the standard's practice. It is not stated if functions return true or false on match. For clarity, that should be detailed. OTOH. I eventually found it. For clarity, that should be detailed more obviously - at the top. 

Leak When a node is popped, the node is not free'd. compare() Avoid overflow which is undefined behavior (UB). Use the idiom . It is recognized by a number of compilers to make lean code and does not overflow. 

OP all ready knows "would be better if the the number of buckets was dynamic,". It is important to add that making the bucket size a prime number has performance benefits in that a prime makes a weak pre-hash function better. Rather than allocate the size of a type, allocate to the size of the pointer's reference type. It is easier to maintain and less likely to be wrong. 

C3. lacks a method for the called to abort the loop. Further, make more useful to also pass a state variable into 

OP's code is OK, but better to use idiom (than ) to allow a compiler to recognize that the mod and quotient can be calculated using related code - perhaps at the same time. A good compiler will recognize this. For performance, usually best to call output functions once and use a simply . 

Missing Avoid a hacker exploit. The first character read by may be a null character. Test result too. 

*** Useful for debugging, but not needed for production code. By setting to , errant uses of pointers are typically more likely to be found. YMMV. 

Leap year calculation is good back to 1583. For years 4 to 1582 it is 1582 has other complications. Before 4 has complications. Suggest return to indicate success or failure. 

Code performs as expected. Insertion sort has an expected O(n2) performance and OP's code has about 0.25*n2 compares per length of a linked list. By adding a to and providing various length lists with random data to , the below graph was determined. 

Pedantically this is not correct had we needed some other unsigned integer type like or . , assuming that what is, cannot have padding bits. Esoteric platforms could have padding bits with wider unsigned types. 

Take user input in a string and then parse it. Easier to cope with bad input. Suggests avoiding and use . Common code should exist in a helper function. Putting the above ideas together results in a not-so-simple code and it is certainly overkill for a simple exercise. Yet it is here to give you ideas of what it takes to handle general user input. 

is certainly some integer type. Looking forward, little reason to assume an is sufficient range to encompass a . So why be stingy? Use a very wide type when trying to print types of unknown width. 

Needs to be applied to both integer and FP test. allows trailing white-space. Both and allow leading white-space. Double is more complex as in the case of underflow like "1e-10000", the may set and that is usually not considered an error in many uses. The returned value will be either +/-0.0 or a small value. 

For array indexing and sizing is the Goldilocks type, neither too narrow or too wide, just the right size for all indexing. 

Some systems have a multitude of special integer types. Rather than guess at their width and potentially truncate, just go for the largest supported on printing 

Better to determine size by the referenced variable than the type. Easier to code correctly, review and maintain. 

Minor: Inconsistent to . A value of 0 in is 1900. A value of 0 in is January. I would expect adjusting both (making January 1) or neither. 

The size of user data may be 0 Although strange, there is no reason to not support a size of 0. Just need to modify the allocation check as a return of from is OK. 

Overflow may occur with or . This can only occur only if is greater than the "maximum value + 1" of the type. To cope, the algorithm is amended with a test to call a function that can handle large values of . 

Use of does not certainly use a consistent type as the types of and may differ. An would be better anyways. 

Correctness (tested code - but so far no holes) - especially overlapping src/dest cases. Design Portability (3 tried: MS, *nix, embedded) Efficiency 

Questionable code I am not confident work as expected for all , especially when the math quotient is just over a whole number, but rounds down before . Clearer alternative: 

For me, I would use the form below and let it handle all edge cases of zeros, overflow, allocation success, free-ing, updates. Be prepared for large buffer needs. 

Corner failure fails to get the right count when and the sought is 0. result is 0. I'd expect 1. Failure when as will result in a negative value. 

Good use of to avoid overflow issues - even though appears faster, the latter can fail. Minor. Returning rather than is rarely faster/less code as that type is usually the processor's "preferred" type. Return or . Profile code if this optimization is in doubt. 

Unavoidable out of range. has "If the value of the result cannot be represented, the behavior is undefined." Your could do better by preventing overflow. A simple method is to use a wider integer type. Of course that does not help if there is no wider type. If interested in code that prevents that without a wider type, let me know, as it is not technically needed, your function could have UB too if it is like . Proper use of Recommend use of . The list of charcters used in OP's code lacks the standard and other spaces characters that are locale dependable, functions are curious in that they are defined for values and . Avoid if may have a negative value. Similar idea for . 

Better to use than to index arrays - may be too narrow. Be careful though that is an unsigned integer. 

A simple test harness would help in evaluation of this code. is not valid without . Other include files missing too. 

Rather than initialize a pointer with a value the will shortly become invalid and non-testable, set to (or "yuck", a version of ) and adjust the to not de-reference the pointers. 

4) Code fails for the following. OP did say "prime factors of a positive number", so 0 and negative numbers are excusable to some degree. 

From a code layout, often is is best to qualify variables first, then proceed to the normal flow of code. Note: is possible, though rare. 

Nice use of to go back to a position derived from . This is better than which is UB for text files. The return type is weak. may be unsigned and returning could become . Suggest . About the sample usage: This allocates memory, and should demo proper usage including : 

Data abstraction Even though references the year 1900, a function called should either use a more neutral epoch or be renamed. Since this is a function - used only locally, not a strong need for this.