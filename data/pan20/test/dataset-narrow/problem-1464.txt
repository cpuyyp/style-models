The answer depends on the desired outcomes for your program, as the capstone should accomplish at least some of your program outcomes. For better or worse, we have a variety of outcomes for our CS program, some of which are college-wide outcomes and others of which are CS-specific. We are unable to accomplish all of these in a single course, so we have our seniors complete two requirements: 

All of these require technical skills in the specific area, so your curriculum would probably need to provide courses to equip students with those skills. For example, if your department offers a database course, it might provide students with the skills to get hired as a DB Admin (or developer) somewhere. There are also "IT/Helpdesk Technician" jobs, in which the person helps people at the company who are having trouble with their desktop, laptop, or other computing devices. These require people skills, problem-solving skills, and a knowledge of the devices and/or the software on those devices, but little if any programming. If you can get students internships performing this role -- either at your college or at a local company -- that can provide a path to these jobs. There are also job titles like "Project Manager" that require people skills, plus an understanding of how the technology works and what it is capable of, but not the skills to create that technology. These people generally supervise software developers, and act as go-betweens between the developers and the clients, but don't do any actual programming themselves. We have a Software Engineering course in which students work in 4-6 person teams to complete a group project. One person serves as the Project Manager for that project, so they get a bit of training in this role; it's difficult to give all the students this opportunity in the confines of a single semester course. I'm guessing there are others, but those are some that come to mind. 

There have been some great answers so far; here is an approach I haven't seen described yet. I show my students how they can use the CLI to access our workstations from remote locations. My students have accounts in our lab of Linux workstations, but suppose they want to work on their project from their dorm room or off-campus apartment or home, or when the building housing our lab is closed? (Does anyone else have students who want to work on their homework over the holidays?) Using an ssh client and the CLI, they can login to a lab machine from their laptop (or even a tablet) and work on their project. Mastery of the CLI (combined with ssh) lets them work whenever and from wherever they want, regardless of when our lab is officially open. I happen to have an account on a Linux machine that's physically located in Asia. From my classroom in the US, I use this same approach to demonstrate to the students how I can login to that machine and edit/run a program there. That helps the students see that this generalizes beyond our campus to let a person access any machine on the Internet (on which you have an account) from across the world. In theory, this could be done using a GUI, but the amount of network bandwidth required to transmit a GUI's graphical information across the Internet makes this problematic. By contrast, the CLI just requires a modest number of characters to be transmitted back and forth, making this approach practical from just about anywhere. 

I post solutions after the due date of an assignment. And usually, I'll go over them in class as well. Two birds... 

Yikes, that doesn't sound like a fun way to grade. Sounds about like what I do with students that are competing in ACSL competitions. But that's only 6 or 7 students, 4 times a year. I can't imagine trying it with 100 students all year. Here's what I'm doing, and what I've done. Online Autograder This is what I'm doing now. Kids login to Canvas and it launches an LTI tool embedded in an assignment. They do their coding in Chrome and click the Test button when they're ready. They can keep testing until their happy with the grade. Grades get sent back to Canvas. I still have to transfer them to our actual gradebook. I can then go back and download the submissions if I want to look at them for style or tips. Generally I try and do this with everybody on at least one lab per lab set. What I've found is that students average about 11 submissions before they move on to the next lab. I only grade the last one, although I'll go back and look to see how they progressed. Downside to this is that it works well for smaller labs, but not as much with larger projects. I can break down large projects into pieces that they can check, but eventually there has to be a full project turned in. JUnit Tests Before I moved online I would write a JUnit test for every lab, and usually I'd write two. One that I would include with the starter code and one, more in depth, that I would use to test. Students could run the test code as many times as they wanted. Then, they'd submit their solutions and I'd run it against the other test code. Biggest downside is it was pretty time consuming to write unit tests for every lab. I've gotten pretty quick, but it's still a time suck. Walk around Not ideal, but I can pick up a lot about students' code by walking around the room and watching them code. I do this a lot with projects to get a feel for where the kids are on the project. By the time it's turned in I've already got a pretty good idea on what they've done. Doesn't scale well though. Biggest class I've ever had was 34 students. "Participation Grades" Sometimes I fall into this trap, especially with my second and third year students. I give them labs, they work on their labs, and I assume that they're done correctly if they've been working in class. Only saving grace on this one is that labs are worth very little and tests make up a majority of their averages. So even with gimmie grades on labs, they can still get hammered on the tests. Admittedly not a good solution, and one that I'm trying to work my way out of next year. Eyeball It Skim the code and see if you think it works. Same as the participation, this only really works with smaller assignments and when labs aren't worth all that much. 

Teaching these concepts in this order should help to showcase the use cases for each of these features. Interfaces were brushed over when I was learning programming, and it took me a while to understand what their use case was; I would try to use inheritance anywhere I needed polymorphism, which doesn't make sense in the grand majority of cases. This teaching order should get over that misconception. 

As an tutor for introductory CS classes, I often come across students that have a very rigid understanding of a programming language up to what they have been taught so far. This most often manifests itself when they ask the question "I can do that? I thought that...". I've most often seen this when showing students that branching and looping statements can be nested. It has even occurred when dealing with parenthesis and order of operations in mathematical expressions. As a concrete example, in Python many containers allow access via brackets: 

Show them how integers are actually represented in a computer. This has the benefit of also helping to explain integer underflow and overflow. In addition, it provides the opportunity later on to actually write a program that can convert from one number format to the other. The two's complement system is not very difficult, and provides a good insight to some of the tricks that computers use to do basic operations. As a CS student, I think that these "go behind the scenes" opportunities help to generate a better appreciation for all the interesting problems students will encounter in the future in CS and Computer Engineering. 

Interfaces: This is language support for what was taught during APIs, and introduces the 'duck principle'. That is, if it walks like a duck, quacks like a duck, and behaves like a duck, its a duck. This is a good argument and explanation for the need for polymorphism. Polymorphism: What good is an interface if we can't swap out one implementation for another? Take for example, Java's interface, and two of its realizations: and ; without polymorphism, we can't write generic code that targets both of these types. Abstract Classes: Sometimes, when writing two different realizations of the same interface, we see that code can be shared between different types, while fundamental portions of the implementation remain separated. Take, for example, designing a and for a card game. Functionality relating to scoring and storing cards will be shared, but the act of choosing which card to play is fundamentally different, and cannot be shared. The interface, however, needs to be consistent. Inheritance: This is primarily for code reuse. Additional functionality or desired traits are added to a type that already is an object in its own right. Taking advantage of a somewhat nebulous implementation (such as extending Java's class) is another use case. You are customizing more than you are providing functionality. Unlike the other strategies listed, you don't have to use inheritance to implement an API. You could, for example, convert a regular binary tree into a balancing binary tree. 

Interfaces should be taught right after, or during the section on APIs, because they are simply a promise to implement a certain Application Programming Interface. It's why they are called interfaces in the first place. They are also more general than inheritance, which makes them a much better example as a polymorphic data type. With this in mind, I propose that after APIs, the following concepts are taught in order: 

Fingers crossed that this one doesn't get closed. I've tried to do something similar, but it hasn't come out well. Hoping that some others have suggestions. It looks like they're using some sort of overlay or whiteboarding software, and I assume a tablet or stylus. I can see a cursor where their pen is drawing. I've tried this, and it didn't go well. But, I think that's more a factor of my handwriting than of the idea. Enough years of typing being my main method of written communication has made my handwriting terrible. And it's even worse on a Wacom tablet. Same thing with some student created videos. They're just hard to read. I'd like to find whiteboard software that also allows typing. Haven't found one yet, although I haven't looked all that much either. A couple things that have worked... If I'm in a hurry, Powerpoint has enough animations built in that it's possible to do a fairly decent job. And, they can be exported to videos if you want to upload to YouTube. When I've had more time I've used Flash. It's deprecated now, but I still have an old copy on my computer. Takes longer, but gives me a little more freedom in what I build. Also can be exported to a video, which is especially important since browsers are starting to frown on Flash. Edit: Just played around with the pro version of Acrobat and it looks like it has a pen and text tool that might work for what I'm trying to do. Most of the time I'm just trying to annotate what's already typed out. Edit 2 - After "screen casting" was added This year I started capturing my screen as we work through problems and then uploading to YouTube for kids that missed the day or just want to go back for a refresher. I'm using a program called OBS. Works really well. A little Googling brought me to a Windows program called ZoomIt that will let me write and type over the screen as I'm demoing. Think I might bring my Wacom tablet to class tomorrow and give it a try. 

I use school colors and principal's name. If someone comes in tomorrow and says your principal is no longer Mr. Smith, it's now Ms. Jones then that change is made for every object (student) in the school. You don't have to go to each individual student and tell them that their principal has changed. It worked really well this year because we did get a new principal. 

The way our network is setup I have access to my students network shares. So, if a kid is absent I can get to their stuff and copy it for their partner. Not ideal, and definitely doesn't scale well if there are a bunch of students absent. Plus, I really don't like the privacy implications. But it works in a pinch. I've also had groups share a flash drive, and then leave that flash drive in the classroom. Works okay if there's no plan on working outside of class. Some groups will zip up and email themselves the work they've done at the end of class. Or, upload to DropBox, Google Drive, or something like that. My personal preference would be some type of source control. I've been looking for a reason to introduce git into my 2nd year course. Maybe this would be a good excuse.