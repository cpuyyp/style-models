Now, we need this process to work on a matrix instead of a flat list. This is straightforward enough, we can loop over the matrix (left to right, top to bottom) and ignore cells we have already dealt with. In the below code x is the row coordinate, and y is the column coordinate. 

I feel like this is the wrong approach to take though, as there is a lot of boilerplate for what is essentially a function which is used in two ways. Is there a better design pattern to use in this scenario? I suspect a more functional approach would suit, such as passing the encryption functions into a class that binds them together. My concern is I lose the option of providing metadata with the function with that style. 

Important Note: this presumes you are generating each row from left to right, so the value will already produced. I haven't tested the performance of such code, but since it doesn't have to recalculate half the triangle, I presume it would be faster 

This is only a quick review, since I don't know much in the area of rendering graphics Repeated Work 

Maybe a note that this formula assumes that the cannon is on ground level, it is a simplification of the formula for range Now this is up to you, I would just write the formula in comments, and remove the timeInAir 

The main improvements come from moving any work that is constant to outside the loop. We also avoid repeating work like working out the length of the snippet. For this kind of tricking about, profiling should be done to test the function. 

In other words, you only need to look each half once, at the moment you are checking the first and the second half, and then the second and the first half again. We can stop sooner 

This comment doesn't really achieve much. If I see a class called Players in a file called TicTacToe.cpp, I would assume it contains code relevant to players in the game. In general comments are useful if they explain why a block of code is there, or what it tries to do. 

Since this will be the name of the file too, (if you save it) I would recommend naming it something descriptive so that you don't have to open it in order to know what it hides. 

This is going to be the main slowdown of your code as product means factorial growth. I can't think of something that does this better right now, but I'll come back if I do find one. The issue at hand is that it isn't the shortest range of indexes which contain all the keywords, it is the shortest snippet. The words might vary in length, giving each index a weight. In addition, spaces mean it isn't the smallest sum of weights, it is the min sum of weights plus number of additions used. You could create a list of the length of each word in contentWords, and find the min sum(contentWordsLens[minPos:maxPos] + (maxPos - minPos)). The should be more performant as you are adding numbers instead of strings As for the code, there are a couple of tricks to squeeze down the time 

Input Split input, output and the algorithm up, they are tangled together and it makes the code much harder to read. Make the main modular, for example 

Spacing Use as much whitespace as needed, it makes it easier to read code, especially formulas or expressions with a lot of operators. 

Rather than a number of variables, a list would be a good way of storing this data. You can then just add "--" around which ever item you need to. Text = ["Single Player", "Settings", "Exit"] 

these two are different, so we know that one of these two must go* This gives us two choices "aabbaa" or "aabcaa" We can pass both of these in to our checkPalindrome function and we have an answer, and in roughly half the time (average case) *assuming that the string can be made into a palindrome with the removal of 1 or less characters. 

To get a real boost though, we need to look at the algorithm itself If we passed in "aabbcaa" currently it would loop through the string once to check if its a palindrome, and another 5 times before it finds the answer. While it is still O(n) best case, it is O(n^2) in the worst. For larger strings that is a nightmare So lets try and come up with something better looping through the string 

When you reverse the string, it remains the same The first half and the reverse of the second half are the same 

Since it is going to be the same character, why do we need to loop over the array? We could just print the character once and it would serve the same purpose 

This is completely up to you, but I would start the loops at 0, and go until n < r or i < r-n. That is because I would consider that a standard loop, and it is very quick to see how many times it loops, what stopping condition is, and what it loops over. I understand why you are starting from 1, the number of rows, but since this is never actually used, an off by one error wouldn't actually be noticeable. It is barely worth thinking about, but if you are writing for loops over and over, it makes it easier to read. Take this with a grain of salt. 

The rest of the code looks kinda dense right now, I would suggest going through the above suggestions and any other replies you get, make some improvements and post again with the next iteration of code. I hope to see you post an update soon, all the best! 

Sorting the contents of the matrix and then picking the index with the median value is a good approach. Lets see if we can do it with constant extra memory. 

I recommend the % operator, it will save you a lot of lines, and make it more obvious that this is a cyclic menu 

Why shorten the variable name? I can't think of a single reason to shorten this variable from something like player1_wins. Which one would you prefer to see in 6 months time or a year from now, long after you have forgotten the details of the program. Other names that could benefit from more descriptive names include anything with a comment directly beside it describing it. For instance void board(); // display board If you changed the function name to display_board or displayBoard (whatever convention the code follows) it would make everything that much simpler to read. 

I have written code to implement the nearest neighbour algorithm to produce a solution for the TSP problem On my machine, the code takes roughly 10 seconds. Since this is so short, a lot of the profilers I have tried don't get a chance to record it properly. How do I profile this code effectively? When I define the distance matrix and the size globally, the code takes around 6 seconds, what could cause this difference? The Code: 

You scan 3, and 10. That is it. All the rest of the input is ignored. There is a reason it tells you how many test cases there will be, its important to use that information. 

A final note, there are two parts to the function, getting the indexes, and checking which combination is the shortest. As such, we can move them to two functions. A cleaner version of the submitted code: 

There are many lines that are inside of a loop that do not need to be. Every time you move a pixel in the x direction, the inner loop, these results do not change, so you can save them in a variable outside of the x loop. This alone will save you a bunch of repeated calculations. 

I don't know what you are trying to achieve, so this is going to be just code refactoring since you are doing the same thing in 3 places, you can reduce it to a for loop 

I would suggest making a function to actually change to and from fullscreen, so you don't have to worry about changing anywhere near as much code later. 

The next column is just counting upwards, so if column is 1 or if it is row - 1 (both conditions presuming row > 0), we can just return row. 

Your code has a significant bug. If I ask it to chunk a list with None at a multiple of n plus 1 spot (c * n + 1), it will not return the rest of the list 

It is never necessary to have a condition with == True or == False. This is another good place for any and all to appear 

Huh? I didn't notice the global variable for quite a while, it looks like it is a method. I would move this to the top, above main. It would not be good practice, but if I was being lazy, I would just print the character before returning the length of the longest sequence, or return an array or list with both in it, rather than using a global. I just prefer not to use global variables until I have to. 

Spelling mistakes in comments and variable names Abbreviations, if you notice there is a lot of words highlighted, maybe there is a few too many abbreviations, and would benefit readability if they were given more descriptive names Give you another chance to read through the code in a different light. Sometimes reading code in a different editor or even without one can change your opinion on what is ugly and what looks nice. You might even spot a bug or a chance to improve things. 

So the updated version looks like that, and it should be roughly twice as fast for input that are palindromes. 

We can avoid generating some of the numbers of the triangle. From looking at the triangle, every single value in the first column, ie if column == 0, has to be a 1, if asked to generate it we can just return 1. Similarly we can do the same if the column equals the row. 

I don't like updating the board here, this seems very much like mixing business logic with input/output, which is generally a bad idea. 

Speaking of input, while a buffered reader is probably faster, I don't think the performance is worth it over the simplicity of a scanner. 

The fact you need a comment to explain that the difference between this and later code is the order, shows that this is perfect to abstract to a method. 

First check if they are the same length, if not then we can return false immediately. Next make a list which will store the frequency for each character in the first string. ord() converts a char to its ascii value. Then we go through the second string, and subtract 1 from each corresponding frequency, and if we go below 0, we know that a character is not in the original string (enough times). Since they are the same length, we dont' have to check the frequency list for left-over characters.