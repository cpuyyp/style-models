All in all I think this looks pretty good. Without proper inheritance, you're pretty much stuck with the boiler plate properties that simply call on the private untyped 's properties. Everything in regards to that was done right, vba just kinda sucks like that. The only thing I really noticed that I didn't like was the way you're using magic numbers to raise errors. 

You've shown us two different implementations of the same routine that outputs two two different places. I think what you really need is a class that gets initialized with an member. Then you can have different implementations of the interface, but only has to deal with and one routine can print out to anywhere. You're correct that is unsafe and is safer, but I'm not sure it's entirely safe. What if there's a namespace conflict because I implemented a ? of my custom dict would also be "Dictionary" and who knows what would happen then. is another option though. I've not tested it, but I believe you can do this. 

This here is overly verbose. It's obvious what the type is from the right hand side of the assignment. 

Go ahead and extract it into a private method of it's own. I have a minor concern about that snippet though. You ask the user to "n" to quit, but in reality, anything but "y" will exit the program. I'd consider that to be a bug. 

That may perform slightly worse because now it has to iterate twice if the user isn't an admin, but you're no longer repeating yourself. Any change to the logic would only have to occur in one place. Now there's this... 

I would think that the first query you tried would perform better, as it doesn't have to aggregate anything. I believe it's how I would approach it. I would just reformat it so we can read it a little easier. 

Rss.fs And the parsing code. The module contains all the record types and a single method that returns a record. 

Although, let's be honest. When will you ever treat a specific repository as an instance of the base class anyway... You've introduced a world of hurt on yourself for no gain what so ever. Please don't do this. 

When thinking about interfaces/class hierarchies it's useful to think in terms of "is a" or "has a" relationships. Bob is a player. A rook is a piece. A player has a rook. I would modify your interfaces a bit. 

Except, you really shouldn't have to do this in order to build a file path. The has a function that appends strings together as filepaths. If you used it instead of concatenation, you wouldn't have to worry about those pesky slashes. For example, both of these statements will print the exact same string. 

And now we're ready to serialize/deserialize this information. First, an example of reading (deserializing) this information from the XML. I keep this in a static class. You may want to do something different depending on your needs. 

Good name for the class. Very descriptive. Normally I wouldn’t advocate for abbreviating, but I actually think it’s best to abbreviate this one. Having worked in retail, everyone in the domain knows what an EAN is. Nearly no one knows what it stands for. Use the domain term and abbreviation for this one. (To be clear, I would normally tell you the opposite. Abbreviating things shouldn’t be the norm.) 

Note that I also removed the parameter, as we're replacing it with inherited classes. Now we can go about implementing child classes like so. 

It becomes easier to add and use the error number. The error numbers get exposed to the client code, so if an error gets raised, I can check the and handle it appropriately. 

I see a couple of issues with the code, but I'm afraid this isn't exactly the answer that you're looking for. Hopefully someone a little smarter than myself swings by... Anyway, in , you have this call. 

The second issue I see here is that your implementation is bound to the console. Many of your methods should be taking in arguments instead of directly getting input from the user. There should be another class solely responsible for interacting with the user. Main should be responsible for passing information to/from that class to/from the one that is calculating the solution. This will make it easier to use your class anywhere and put it under test. 

Which shows us a potential opportunity to extract a method to remove the duplication. Lastly, are you sure this does what you intend it to do? You didn't tell us exactly what you're trying to accomplish, but usually I would want to sort the results prior to selecting the top x results. I can't recall off the top of my head which order of and would produce the correct results, but you should definitely double check that you're getting the information that you think you are. *You might need to work on the Union syntax a bit. I'm not sitting in front of my IDE, so I didn't try to compile it. 

The declaration for is a bit verbose. Prefer the keyword when the type is obvious. (This use isn't entirely obvious, but certainly good enough.) Brackets. Use them. Always. 

I'm not overly familiar with using WinApi calls from VBA, but I'll do my best here, because this is a cool piece of code. Let's get started. 

You already have a reference to that worksheet stored in (which will henceforth be referred to as by the way), there's no reason to get the worksheet from the collection via its name. 

The variable names here are pretty obtuse. What exactly are , , and ? They're related somehow, but that's all I can readily gather from the names. Also, commented out code is dead code. Remove dead code. If you're worried that you'll need it, then I recommend you start using source control of some kind. Personally, I like Git. 

It's really not a great idea to return a from your method if you can help it. You've effectively bound your code to always using a list. What if your client wants to use a ? You'd have to do some messy casting. By all means, use the Linq that @TravisJ provider, but you should change the signature to return a instead. 

You got very good reviews of your code, but your basic business logic is flawed. I'm sure there's some user driving this requirement, but some times it's our job to push back and not let some cockamamie feature make the system unstable. If the employee or manager is not found, then the user should be redirected to some place where they can be added, given they have sufficient permissions, otherwise they should be shown a meaningful error message. The way you've implemented this is going to lead to many, many, many erroneously entered employee/manager records that will later need to be scrubbed from the database. Don't let your product owner destabilize the system because they're lazy. 

Note that I removed the "type" enum. If we ever really just have to know exactly what concrete type we're working with, we can call instead. Now we move the interesting code that used to be in to . 

There is a pretty big flaw with your logic. This query might work okay here, but wouldn't work as well on a site like Stack Overflow where it's more likely for an answer to get upvoted long after it was originally posted. The problem is that the query will be naturally skewed toward older answers simply because they've had longer to accrue votes. Unfortunately, I don't know quite enough about the schema to offer an alternative approach. 

I haven't done any web dev in a very long time, so I'll leave your actual question to the experts. I just want to point out a small style point. Your variable assignments could use some breathing space. 

Saying "where is or not" results in the same thing as not including the statement at all. Either you're not getting the right results, or this could be removed. 

has a definite smell to it, but I suspect that's because you're manually changing those prior to each run. I'm not sure what to do about it though. 

Now, note that we're referencing the column positions within the results range, instead of the position relative to the worksheet. This is easier for a person to comprehend while only looking at the code.