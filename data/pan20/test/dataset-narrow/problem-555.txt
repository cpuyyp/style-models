There is a Bug in the Code The code in contains at least one bug, it might have been easier to prevent if the multiple if statements were a switch/case statement. 

Process any arguments (argc and argv). Set up the environment. This includes setting up any error handling. Call a function to execute the program. Handle any errors. 

This would be pretty good code in PHP4, but PHP has become more object oriented. Implement this code as a class. A class gets you multiple benefits 

The variable com1 should probably be created as vector com1; This would provide a variable sized array of companies. The code for inputing the companies wouldn't change, but the code for displaying a company or searching for a company can change: 

There are two coding standards that might be applicable, either C99 or C11. C11 would probably be the proper choice for new programs. Many compilers today will allow the programmer to select a standard, in the gcc online documents: 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The KIS(S) principle simply states Keep it simple. Some possible functions that could be added std::vector inputBrands(); std::unordered_map mapBrands(std::vector brands); void inputPrices(std::unordered_map> dict, std::vectorbrands); The for loop above can be broken into at least 2 functions, I'm just not sure what to call them. Another benefit of breaking the program up into functions is that it can be profiled and you can find out where the program is spending the most time. 

Your use of descriptive variable names and function names is good. Main is too long Your main() function contains too much code which makes it difficult to maintain. You have code for at least 2 more functions in main(). Both of the for loops are good candidates for functions. A well written function performs one and only one action. Define functions before use If you define your functions before you use them in main() you don't need these declarations at the top of the file. 

There are 2 constants defined in stdlib.h and stdlib, these are and . These make more readable rather than return 0, return EXIT_SUCCESS or EXIT_FAILURE from main, this will also allow error handling to be added at some point in the future. Symbolic constants help programmers in a number of ways: 

For performance reasons you don't want to call a function. Check the file, may be a macro, in older versions of C (pre C89 for sure, possible pre C99 ) all functions provided by were macros. Type Issues The variables and in main are declared as unsigned long long, however the functions are expecting pointers to long long. It's also unclear that long long is required since 2^32 is the max value for either or . 

To make it easier to use the code you might want to have comments at the top of the file that the user can copy and paste rather than having the macros. 

Note: in C++11 initialization uses {} rather than (). Comparison of Different Types The reason for my comment above is that the following code compares an int to a size_t 

It identifies what the number means. If at some point in the future the number has to be changed for all uses, the code only needs to be changed in one place. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines well. Multiple functions in the program are overly complex and could be broken up. The function could be broken up into at multiple functions, especially the outer while loop. The while loop seems to be a good candidate for a function, the two clauses of the if statement also seem to be good candidates for functions. The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. You might also want to look at SOLID programming 

Global Variables Whether this is C or C++, global variables such as are always a bad idea. Global variables make writing and debugging code very difficult and allow for unintended side affects. The array arr should be defined in main and passed to all of the other functions. Using std::ANYTHING You as a software engineer may in your career write your own and . To do this you would have to have your own namespace so that std::cin and std::cout did not break your code. Including the namespace in the symbolic identified identifies which symbol you are using. This allows you to write programs and libraries that have the most meaningful names. Use Container Classes C++ has a great many container classes, some of which are , , and . These container classes reduce the amount of code you need to write, and provide functionality such as the size of the array so that you don't have to write . It would be much simpler to use the containers provided by the Standard Template Library. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines well. The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. The functions and would both benefit from being broken up into at multiple functions, they are almost duplicates of each other. One of these functions can almost be implemented by calling the other function. The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. One good candidate for a function is the following code: 

It has implemented a lot of functions such as isspace(), , , , , , and as macros. This should be more portable than that the check you have for ' '. 

Functions in Main.cpp: If you reverse the order of pause() and main() in Main.cpp you don't need the function prototype of void pause(); prior to main(). Having main() as the last function in the file is fairly common for this reason. In the past on certain operating systems, pause(); has been a system call. I would avoid it's use, although the system call did return int so the signature is different. It also isn't the most descriptive name you could give this function. 

In the loop where the calculation is done the deletion of the zero element is costing too much time. Rather than erasing the zero element in each loop just index through the vector. 

I recently interviewed with a company that needed a C/C++ programmer to work on the iOS side of the products. The job description indicated they needed someone with 4 years of Objective-C and iOS programming and I was surprised that they wanted to interview me. Prior to this coding challenge I have never worked in Xcode, or programmed in iOS, Objective-c or swift. I am an absolute beginner in these areas. I still don't think I know these programming environments but I am learning. Environtment 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The function can be broken up into smaller functions to make it more readable, and to allow you to profile the program to see where you are spending the most time. The following is a good candidate for a function: 

Decrease Function Complexity Another software engineering principle is the Single Responsibility Principle. A function should only be responsible for one action, this makes each function easier to read, write, debug and use multiple times. It is much better to write smaller more concise functions() so that the can be used in multiple places and only need to be debugged once. The functions and would both benefit from applying this principle. General Comments The program should guide the user better. It's not clear what the input should be, there should be prompts for each input. The program might be more fun if the user could enter colors rather than numbers. 

Generally the variable and function naming is clear and makes the code easier to read. If this program is for a first or second year computer science class it's really very good. If you are new to C programming it is also very good. Having modular programs is always good because it allows reuse of the code and minimizes side effects. Module Partitioning There is a software design principle called The Single Responsibility Principle. This principle applies to functions and structs in C and functions and classes in C++, Java and other programming languages. The principle states that a function or struct should be designed to do one thing and only one thing. This makes it easier to read, write, test and debug programs. Another important software design principle is to reduce coupling between modules and data structures. Coupling should be reduced to make each module of a program as independent as possible to reduce side effects. Decoupling modules allow the addition of features or bug fixing in one module without breaking code in another module. This is why global variables are generally frowned upon, they create tighter coupling. Here are some general guides to software design. The way the files are currently partitioned creates a tight coupling between main.c and map.h. The main() function really only needs to know about the functions in pathfinder.h. The map variable only needs to be available in the pathfind.c file, The map header file contains 7 character constants. This creates the static variables in every file that includes it. The static constants should only be included in the files that use them. The map.c file is the only file that uses these constants so all the static variables should be declared there. Currently these static variables are being defined in all files. If they were not staticly defined the linker would be reporting multiply defined errors. The function inBounds() should be declared as 

Because I used Visual Studio 2015, this alternate solution is not portable without edits to remove from source files and replace with guard bandes in the header files. A specific question about the code is there a single STL construct I can use to replace this function, I don't think will work since one vector is always length 15 and the other will vary between length 5 and length 10. 

The Good The choice of variable and function names is very descriptive. The code is properly indented but. The consistent use of camelCode is excellent. MAGIC NUMBERS The term Magic Numbers refers to numerical constants in the code. A good programing practice is to used named constants rather than numbers. Named constants make the code more self documenting, and allow easier modification of the code. When a named constant is used the code only needs to be changed in one location rather than multiple locations. An example of this in the code would be to increase or decrease the size of the arrays. Example Named Constants: 

It's a bad habit to declare all of the variables on one line. Each variable should be on it's own line to make it easier to find the declaration. If you have read the chapter on pointer variables you might want to use 

Note: The code above would be more efficient if you had an array of color strings and indexed into the the array using randColor as follows: 

Variable Names While the original code had the variable name ANTS for the array of ants, the C coding standard indicates that constants should be defined using all capitals and variable names should be a combination of capitals and lower case, but mostly lower case. In the ant.c file the variable might be better named ant, and the struct might be better name Ant. this might improve the readability of the code. The field in the ant structure could be name position if the struct position was renamed to Position or the variable could be named either location. or pos. It's not clear in the code what and mean in the kinetix struct. Are they vectors or velocities? In physics or math the shortest form of change in location might be dx and dy for and In what exactly is ? The second page of the PDF coding standard in the cited in the first section provides some good tips on variable naming. MAGIC Numbers There are already symbolic constants in use in parts of the program, however, their use could be expanded. It is unclear what the numbers 2, -2, 320 and 240 mean in the functions and void Draw_Ground(void). It is also unclear what the numbers -2 and 2 mean in the function . Symbolic constants help programmers in a number of ways: 

Using a state machine is generally a very elegant way to parse input. This is actually how parsers generated by YACC or Bison work, and it's also how lexical analysers generated by LEX work. It allows the parsing to be more flexible. Generally the variable names you used are quite descriptive and makes the code easier to use, the one exception is naming the matrix A. Things That Would Have Improved This Question It would have been much easier to review this question if the following had been provided: 1. The definition of the . 2. The header files necessary (, , and ). 3. If the 2 different versions of had been separated and included as matrix_fill1() and matrix_fill2(). 4. If the program had been compiled using and all warnings addressed prior to asking. I have included the reformated code that allowed me to compile at the end of my answer to show what would have made this a better question and easier to answer. During development of code it is a good idea to compilte the code with -Wall compiler switch so that all warnings are reported. The warning can also be treated as errors. The type size_t is not completely compatible with the printf() statements in the commented out algorithm: Parse2DMatrix.c:142: warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘size_t’ Parse2DMatrix.c:142: warning: format ‘%d’ expects type ‘int’, but argument 3 has type ‘size_t’ The matrix struct should be presented so that we could have suggested possible error handling, there are times when i or j may cause memory access problems because they are outside the scope of the matrix. The choice of types is interesting, I would have used double instead of float, and unsigned int instead of size_t. Error Reporting Rather than using and for this portion of the code it would have been better if there was an internal error handling mechanism providing a better description of the errors. Invalid argument is a little too general, "Missing { at start of expression" might have been more meaningful. Exit Versus Return Calling exit(-1) does not allow the code to clean up after itself, returning an error value allows the calling code to clean up any allocated memory and reset all items that need to be reset. If this code was part of an operating system or a daemon that calling exit() is actually not an option because you wouldn't want the system to crash. Switch Statement Without Default Case There should always be a case in a switch statement to handle unknown/undefined behavior. In this specific instance rather than having a in case of errors the case could have been used to handle the errors on the next iteration through the loop. There could be one additional enum value in the enum, could be a status type. Enum Coding Standards It would be better to call attention to the enumerators in the ENUM, and follow general C Coding Standards (UCSD has published this coding standard). By making the enumerators ALL_CAPITALS the code would be clearer and show that these are defined someplace. It is possible that the status/state might be used elsewhere so it would be better to define the enum type outside the function, and possibly in a header file. A better way to define the enum would probably be: