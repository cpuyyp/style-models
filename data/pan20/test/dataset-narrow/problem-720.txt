In , you say that and are attributes but you are not treating them like attributes. You pass them to the function when that function could just access them as instance variables using and syntax. This will first require you to set those variables, however. Either pass them in to the initializer and set them explicitly, or you could use in much the same way as above to create the and methods. Then you can set the variables whenever you want by calling, for example, 

(Note that I dropped the , the parentheses, and the as per my previous point). You typically don't use parentheses on conditionals unless it would be prohibitively confusing without; see the style guide Make a similar fix for this and other lines: 

This is currently not the case and it looks like something you could improve on. If it were the case, you could then decide in your controller which of those Repositories to choose. This might either be an option in your api, or something you can do in a service container before the request is handled. I dont know your requirements here. (See $URL$ for service container, dependency injection ...) So e.g. 

if submitted and valid (button 1) => update some values on the entity and re-render the form if submitted and valid (button 2) => perform another controller action that shows a pdf print of the entity if submitted and valid (button 3) => save entity and redirect if not submitted or not valid => render form (plus errors) 

That's a direct translation and a much more 'ruby' way of doing it. There's another way to do it as well, but it's not necessarily better. It lends itself nicely to extending the number of players - imagine you later wanted a 4 player tic-tac-toe game. 

I wouldn't use this with your current requirements, but the possibility is there if you needed the extensibility. 

Avoid using . In this case it's not too bad, but imagine in the future you want people to also be able to answer "q" to quit the process and "a" to automatically rename them and "c" to move them but keep a separate copy, etc. You'd need a separate condition in the elsif for each. Instead you should use a case statement: 

If enforcing the same interface for all the repositories is not what you´d like to choose, you could also introduce another layer of abstraction through some kind of mediator object that decides the repository for you and does the work to provide a consistent output for the controller. Instead of returning an array from your repositories, you could instead return objects relevant to your domain. E.g. an object, that knows nothing of databases and the sort. Each of the repositories can then populate such an object, and the controller can use another layer of abstraction to turn the array ob s into arrays/json. Update The package is implementing the ActiveRecord pattern which is certainly useful. However it means that you comes with a lot of stuff that is not relevant to an per se. It inherits all the Active Record methods provided by Eloquent. I find when I have the need to swap backends, the ActiveRecord pattern is less useful. The object relevant to you domain could simply look like 

On top of the comments provided by Billal BEGEURADJ, you also have the possibility of a stack recursion error in your code: calls calls calls calls calls calls And calls To fix this it may be worth making the game get started from outside of the class in a loop: 

I'm writing a very simple engine which I hope to use to create a game at some point and felt that I needed buttons to allow the user to select options in a menu, so I wrote up a rudimentary button class. Think of this as similar to Windows forms if you like. Whilst what I've produced works and I can detect the button presses I feel like this is not the simplest way to do it (although note that I would like to do it myself as a learning exercise rather than using an existing library to produce the buttons). One of my biggest problems is that the buttons are done using rather than and so have a top left anchor and working based on window width and height in pixels rather than a center anchor ranging from -1 to 1, needless to say this makes rendering buttons a chore. Any advice on how to improve that alongside general scrutiny would be much obliged. display.h 

So you don´t have to query the dom again when appending the list items. Also it is better to build the list items in memory and only append the complete list to the dom. This way you only trigger one reflow. So in the $.each loop I would 

Now what is ? This could either be the ElasticSearch or the relational DB oder the NoSql version of a MusicRepository. To do that you would have all those Repositories implement the same interface e.g. 

This doesn´t look all too repetitive to me, I see no obvious duplication. You could extract a local variable or two to make the naming more explicit and to not query for the same element twice. That would however be a tradeoff between function size and readability. Also you see a few references to the variable in one place, this indicates that this could be pulled into its own function. 

As a small suggestion, I noticed that your s have an odd line at the right hand side due to drawing them with the outline of an oval (as you noticed and commented in the function). You can fix that by instead using two filled ovals, a big one which is filled using and a smaller one filled using (Although this does require adjusting the to compensate for the missing width): 

The following is a .wav file generator that I wrote briefly while (re)learning about audio sampling: 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

Not knowing anything about any datastore. Your different Repositories / backends would then simply populate this entity. Compare to the Doctrine Project which is more of a Data Mapper pattern implementation. Update 2 As posted above, "pluggin in" a different backend is as simple as getting the relevant repository from the service locator. You can do this by either aliasing the "selected" one to , or by selecting it on the fly in the controller 

Actually there are two buttons like button1, I left one out for brevity of the example. Idea 1: I have tried to extract this into a EntityFormWizard of some sort but this ended up as a cluttered Object with too many dependencies (Router, Templating, Form) which was also a pain to test. Idea 2: Using FormEvents I wanted to extract at least the altering of the entity depending on which button was pressed into a FormEventListener, but the only place where I can alter the Entity is the FormEvents::PRE_SET_DATA event, but in there I have problems figuring out which button was clicked. So the question: Do I have to live with my integration test for this behavior or is there a way to extract it and test it with a unit test? 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

I have a fairly ugly controller method I would like to refactor / extract. I can only test this in a integration type test which kind of signals a code smell. The method processes the form and needs to do one of 5 things, depending on which button was pressed 

I think your current solution is already right on track, you just need to take it further along. To combine the currently two controllers into one, lets write the code we wish we had. You want your controller to know almost nothing about the source the data comes from. Since your two actions are similar in interface already, lets start with this: