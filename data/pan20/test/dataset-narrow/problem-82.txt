Great topic. I'd like to preface my answers with some relevant information, then answer your questions as you've asked. "Roaming" is defined as a wireless client migrating from one access point to another. "Seamless" roaming (aka Fast Roaming, aka Zero Handoff, aka IEEE 802.11r) is defined as a wireless client migrating from one base station to another in a fast, seamless, and "secure" manner. Now to your questions. You asked, "I expect that somehow the new AP must inform the old one the station has roamed successfully and I suspect it must be done with packets sent through the switch. I really wanted to know: How It's done in practice?". Answer: The new AP does not inform the old ap that the station has roamed successfully. In fact, the two access points do not communicate to eachother at all. Even if they were the same model, they don't communicate to eachother. A wireless network designed as described above is not capable of "fast roaming", just "roaming". A real-world test to prove this to yourself is to connect a wireless VOIP phone to the wireless network, then have a phone conversation on it while roaming. You will hear a signifigant interruption in your conversation. Fast roaming would be achieved with another wireless design using a wireless controller (or a bridge). But your question is, "How is it done in practice" ("it" being how the communication occurs for a successful wireless client migration from one ap to another). Here's how it happens in the network you have designed, which is a normal SOHO network. The client is already connected to an access point. As it physically moves, the client wirelessly probes and finds that another access point also has the BSSID it uses AND has a stronger wireless signal (aka RSSI value) than the one it's currently connected to. Before we continue, let's state one fact. A wireless client can only be associated to one access point at a time. So knowing this, it must "disassociate" from the one it's connected to now before it can "associate" to the stronger one. So the wireless client sends it's current access point a "disassociation request" (aka Disassociation Frame) and disconnects from it. Then, the wireless client connects to the new access point by going through its association and authentication process. Once the wireless client is accepted onto the new access point, that access point communicates to the switch that the mac address can now be found on this switchport. The switch updates its mac address table and moves the wireless client's mac from the old access point's switchport (in the table) to the new switchport belonging to the new ap. At this point, the wireless client begins network communication. All of that was done and the two ap's did not communicate to eachother at all. Your second question is: (translated) What would those packets look like? Answer: On your wireless client, load the latest version of Wireshark and begin a packet capture before you roam. After you roam, stop the capture. You can analyze your traffic to whatever degree you are comfortable with. NOTE: It would be best to make sure you have the latest wireless "driver" on your device first. You mentioned that you tried sniffing on the switch and saw nothing. You now know that to see the migration, you need to sniff on your wlan adapter. Your last question is: "I read a CISCO networking book about this topic, but It only contains a recommendation about this process, and It says implementation depends on the manufacturer. But what if the APs made by different manufacturer?". Answer: Cisco is correct. The implementation does depend on the manufacturer. Each manufacturer thinks they have a better way for a wireless access point to handle clients. As such, they program their devices in their engineering vision. So if the ap's are made by a different manufacturer, that's OK. Here's why. The access points themselves do not have discussions with eachother in any way, no matter if they're "autonomous ap's" (like the ones you setup in your network) or "thin ap's" that are directed by a controller. So in your scenario, having two different ap manufacturer's is OK because both MUST follow IEEE standards when communicating with the wireless client(s) and the switch. SOURCES CITED: WIFI ROAMING ANALYSIS: $URL$ 802.11 ASSOCIATION PROCESS EXPLAINED: $URL$ 

If we look at RFC 792 (pages 14-15) it clearly only defines code 0 for ICMP types 0 and 8, this corresponds to IANA's definitions for reply and request. This means above all that 9 does not have a meaning, so it does not mean as used in the Destination Unreachable message. The next point is if any other code than is allowed. RFC 792 is quite old and does not really follow the more strict SHOULD/MUST/MAY/... conventions. The remainder of the RFC only states sections like or . It actually never states what should be done if code is not zero. One might intuitively interpret it as the opposite of what is defined, so , another might say that if it's not explicitly disallowed it's okay. There is nothing in the RFC that even hints at what's right, so behavior will likely be very implementation-specific. There is also RFC 1122 but this does not provide any extra specific limitation on the field. Now as for why the reply also uses , easiest bet is to look at implementation. A simple echo reply would just take the incoming packet, replace the type with type , recalculate the checksum and send back. This is simpler and more efficient than building the reply from scratch, but of course leaves the code. 

So in short, when it comes to deprecation you can make sure that a SLAAC address is no longer used for new connections (set preferred lifetime to 0) but you cannot kill ongoing sessions as long as the valid lifetime is running. Of course various implementations might provide administrative interfaces to forcefully remove an address, but that's outside of RFC scope. As far as the RFC goes, you can put the preferred lifetime to anything, though does not make sense. The valid lifetime cannot be except when deprecating. Preferred must always be bigger than valid. So what time you put it is your own choice and depends on your use case. What RFC 4862 states about prefix lifetimes has nothing to do with SLAAC, this is pure about how long on-link prefixes are valid to perform neighbor discovery. 

If you're speaking about regular L2 ethernet switches this is not that hard. Forwarding works just because you're still working in a single broadcast domain. The server can differentiate between hosts by using chaddr instead of the MAC address on ethernet layer. Of course this requires the operator to know the MAC address of each student's laptop, which might be tedious. Alternatively (still L2) the switches might intercept DHCP packets and insert option-82, more specifically circuit-id. In this option it can reflect on which circuit (i.e. cable) the packet came in, this will usually translate directly to a room. The DHCP server then does reservations based on this identifier. So then administration is a bit easier and you can just assign addresses per room. If it are L3 switches (basically routers), there are 2 options. Either they do DHCP themselves which returns us to the trivial case. Alternatively, the routers implement DHCP relay where they usually also fill out option-82 with something sensible. Again chaddr and/or option-82 can be used by the server for address reservation. Note that while option 82 is officially called relay agent information, it's often enough inserted/modified by L2 aggregation that don't perform any relay function. 

To answer your question, it is correct to say that the IP address range cannot be determined by the network number alone, such as 192.168.70.0. The subnet mask must be known. To answer the network vs subnetwork question, let's use the subnet you provided. If you have a network of 192.168.70.0/24 (/24 = 255.255.255.0), you can break that network into multiple SUBnetworks (aka subnetting) by simply changing the subnet mask. 

So I want to answer the questions as they appear. Question: And when turning encryption on on all passwords like: service password-encryption, does it encrypt the encrypted password above, or does only encrypt the clear text password? Answer: Only clear text passwords are changed. Question: If it encrypts the clear text password it will only be necessary to do enable password without encrypting it first, since service password-encryption will do it, how about that? Answer: Correct. The person entering the command will enter the password in clear text because the Cisco security mechanism will obscure it with a hash. Question: One more thing. The key used for service password-encryption and enable secret is this dynamically made for each router or is it a static key, equal to all cisco routers(probably not)? Answer: No "encryption keys" are dynamically made because the password is not being encrypted. Instead, it's being "hashed". When you show the running config and look at the non-clear text password, it's in that format because the device took that clear text password and passed it through the MD5 hashing algorithm and saved the result in the config. So not even the device knows your clear-text password. Here's how it works. Let's say you type in your password to login. The device takes the password that you typed in and runs it through the MD5 hash and gets a result. If THAT result matches what's in the config file, you're in. No encryption needed. BONUS: ENCRYPTION VS HASH To keep it simple since this bonus would be for another forum: Hashing algorithms such as MD5 are "cryptographic" by nature. BUT - the difference between a HASH and ENCRYPTION is that encryption is always "reversible" via DEcryption (the key that you spoke of earlier). A HASH is not mathematically reversible. It simply takes a character string, runs it through a mind numbing mathematical process then outputs a result. For example, if you take the letter A and put it through a mathematical hash algorithm like MD5, A would always (ALWAYS) result as 7FC56270E7A70FA81A5935B72EACBE29 (see onlinemd5.com). B would be something completely different than A's output, but the hash would ALWAYS give the same output for B every time. The more "complex" your hashing algorithm, the more "cryptographic" (not encrypted) your password is. 

I don't have a spare 3750X to validate this with but I think I got it... John Kennedy gave a great answer if you want to give a hard limit to the amount of traffic that Client A and B can send but your question was how to guarantee a minimum amount of bandwidth and still allow bursting if BW is available. In order to accomplish this we will have a policer on each of the Client A and B ingress interfaces. The set of policers will classify the traffic into 4-classes, Client-A conforming (the first 30Mb, set DSCP to AF31, decimal value 26), Client-A non-conforming (everything above 30Mb, set as DSCP AF32, decimal value 28), Client-B conforming (first 20Mb, DSCP AF21, 18), Client-B non-conforming (over 20Mb, set DSCP AF22, 20). We will then map each of these classes to a queue on egress and allocate the bandwidth in a manner that should allow each client the minimum required bandwidth but still have the ability to use more if it is available. first let's map dscp values (in decimal) to egress queues 

I can confirm that the Steelheads will reduce printer traffic volume. I have seen a consistent 90+% reduction in traffic volume for JetDirect (TCP/9100) and LDP (TCP/515) protocols on my network. These protocols are highly used on my network and I am unaware of any issues that have occurred in about 18 months since we deployed the Steelheads. 

Expanding upon @javano's answer... I would change one thing, instead of policing the email traffic (which will drop traffic exceeding that rate) I would recommend just setting aside a small amount of bandwidth for that traffic. Therefore, if nobody else is using the link the email can utilize the unused bandwidth 

you can reduce the interval in which the SNMP counters are updated to something like 1 second. This should result in a more accurate value for the throughput when you are polling every 10 seconds. FYI, this is a hidden command. 

In addition to , you should also use so that if someone creates a loop by plugging in things where they should not then the switch port will go into error disabled mode when it sees a BPDU rather than creating a loop and potentially bringing down the network. As well, if your goal is to track down the unmanaged switches you should enable 

I have seen both of the following methods of switch interface configuration for supporting IP Phones.