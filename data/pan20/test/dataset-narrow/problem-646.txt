Scope It is generally good practice to scope variables in the minimum possible scope. I don't like this: 

This way they are outside of the running code and clearly constants. Similarly should (almost) always by an instance or class variable as having more than one is (almost) never useful. Use for outputting formatted messages: 

And yet you continue with your program knowing that it cannot possibly work. Either throw an exception (which will be reported to the user, and be ugly) or simply to exit and terminate the program: 

The has no idea that we've won - it carries on and still emits that we lost. is a busy wait, so causes one CPU to "spin" while it's checking the time leaving it unavailable for anything else. 

The other comments cover the code quite well, I have a few points to add. First, obviously this is a critical error: 

What do you notice about the pairs 1. <-> 5. and 2. <-> 4.? There is a simpler solution to this problem than brute force... 

Are horrible! If you need to label a variable declaration with what that variable is, you have picked the wrong name. Further, if you are going to use inline comments, avoid the case where the comment makes the line so long that it's illegible. 

Here we do the to get the , we then out and to a . We then use the (often overlooked) to first the resulting and then to return if the joined is empty. The main work now becomes as simple as: 

You forgot to check the result of your recursing calls. Your steps are fine, if you meant the following in step 7 

What would Bob do? You've written an interactive program, but the user does not know what your program does. Therefore, Bob—the generic user—might accidentally write "test" instead of a number, and suddenly your program runs wild. A first step in the right direction would be to tell the user what your program will do—as long as its interactive. Note that this is not C++ specific. We can do so by starting with: 

Could this be a valid use case? Who knows. Is it likely to be a valid use case? Rather not. Get back to the original inspiration for : 

Note that is fine here, since always decreases the number of elements in the accumulating list, therefore you end up with a singleton. Also note that is usually lazier on lists. ... and the oddities While the previous section was concerned with laziness and , this one contains general remarks: 

By the way, 's type signature makes 's type unambigous, and therefore you don't need an explicit type in anymore. Use syntactic sugar is , which is easier to change and to read (in my opionion). That way, we get: 

While that's better than just a , it's still not optimal if you have an application that's creating those numbers. Since sum types aren't expensive to write, let's use one: 

One way to make it easier to follow is to construct your merged documents result separately from your input (above code is not tested). Construct a dictionary to easily get the document to append to, based on type. It also ensures a fast operation. For each document from the input, append its pages in the dictionary: 

If I understood correctly what you are trying to achieve (concatenating objects for owners), I think one way is to actually process all the data on SQL Server. Setup: 

1. Functionality extension - besides already mentioned answers, I would extend your functionality with a back-off mechanism which can prove useful in some situations (e.g. a SQL deadlock). Since the options are quite a few now, these can be contained into a special class: 

in $configFile = !isset($configFile) ? $defaultConfigFilePath : $configFile; Hopefully, they will introduce a coalesce operator soon to simply write: 

Besides great performance improvement due to 's suggestion, the code can also be improved. I have put comments to indicate changes: 

2) Variable declaration closer to usage C++ allows you to declare your variables anywhere before they are actually used and it is a good idea to be as close as possible. The first part of your program may look like this: 

Things that just pop up in my mind when seeing the code (more of the architecture and robustness rather than language constructs): 1) Harcoding path to ini file The path might have a meaning in your development environment, but it will mean nothing in a test or production environment. I would set it in an included file and use it from there. Something like: 

Even though you noted that boost includes them in their headers, it's better to include them in your code too. That way, you know what features you're going to use. Include guards will make sure that there's no compile-time overhead. Next, it's a little bit difficult to differentiate between the type and your functions. Everything you've written uses camelCase. An IDE makes this simple, of course, but since all your names are available in a single file, it's a little bit overwhelming at first. Magic numbers 

HTML has elements that carry semantics. For example is an ordered list, an unordered one. Programs can use that meaning for ease of navigation, reader mode, better search results and so on. Certain elements don't carry that semantic, and is one of them. Let's have a look at one of your snippets to see what one can improve. 

Note: I've changed to , since it was too quick with . However, the times above don't give enough information where you actually lose that time. That's what was for. contains the following data: 

The function uses , a standard library function We check user input for validity We don't values multiple times We show our intentions for the user's action with a data type We provide a succinct and let other functions handle the actual work We share common problems (getting an integer from the user) and don't repeat ourselfs. 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread. 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: 

never create a in a loop, and always close resources. never write this is ugly and error prone ( also compiles). you only need to check once; after reading user input. 

As runs in a separate , we need to consider visibility and atomicity of any variables used to communicate. So an seems the natural choice: 

I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

4. Simpler and more natural iteration Your logic is fine, however a chess board is 8 x 8 and a natural way to iterate is by rows and columns, rather than tile by tile. 

HashMap operations have a complexity of , so function's overall complexity is , where n is string length. [edit] Based on correct observation, a HashSet is a better choice (elements only, no key and values): 

Some things that just pop out when seeing your code: 1) Classes/POCOs definition They do not seem properly written, probably reproduced from memory. A better version would be: 

Also, table is not required anymore and the whole block is slimier. 7) Proper data types suggests that Sales_Closing_Date is not a DATE (maybe a or ). If possible, use the most appropriate data type to avoid explicit or implicit (silently occurring in queries) casts. 8) Comments It's a matter of taste, but I like comments written as normal text, not using CAPS 

5) Try to use mainstream frameworks such as EntityFramework to handle data fetch dirty work. Fetch would look like this: 

Your models project should contain only functionality related to data models such as: data models themselves, data context, repositories. Provided code does a simple thing: gets a model based on its identifier, so this can be included in a Repository. E.g: 

This last function is particularly useful to debug some persistence errors which are quite hidden. 5) Base service (optional) Since almost all your services use unit of work, it would make sense to spare unit of work factory and assignment, by having them in a . 

Also, which one has which type, and which one is more general? Arrows are great if you want to abstract functions. But throughout your small script, you're still just working with , not any other instance of . For a small script like this, is too much. For example the pointwise definition above is actually a character shorter than the pointfree one. Sure, the pointfree one is clever, but it's also very beginner-unfriendly. About randomness introduces a dependency between your point coordinates \$x\$ and \$y\$, since both draw from the same sequence. This usually leads to points on hyperplanes (see disadvantages of LCG and spectral test). Your friends variant doesn't have this immediate problem: 

Haskell is lazy, therefore isn't evaluated until it's actually needed. Therefore we allocate \$\mathcal O(\log_2 p)\$ additional terms. This isn't necessary. We can provide a small fix to make sure that has been fully evaluated: 

That's a reasonable implementation if you want to use . Keep in mind that is lazy in the monoid, so you can end up with a space leak. Also, bubblesort doesn't look at the last element after the first iteration, e.g. 

So if all your (standard-layout) structures were only involved, we would actually have defined behaviour. But there's the , and that's not guaranteed to be even memory compatible to the almost trivial struct. Yes, even and aren't guaranteed to be memory compatible. Even if they were memory compatible, the standard doesn't describe the behaviour of 

4) Defensive set If by any chance, the select for year returns more that one year, set statement will fail. You might consider assigning with and/or using , just to be sure it does not fail (however, it may return an incorrect value). 

However, logic for the dates is unclear for me, even after reading operator precedence (AND takes precedence over OR and BETWEEN). It is strongly recommended to use parenthesis when using multiple operators with close precedence. 6) Set based logic WHILE and other looping constructs are intruders in T-SQL language. They will usually behave (much) poorer than set based approaches. So, your WHILE can be converted into something this: 

Can this code be improved? As already mentioned, performance is not an issue, so I am asking mostly for an architectural perspective. 

One way is to have a function that returns a table composed of two s, corresponding to each of your s: 

Usage in markup: It is very concise, as I want notification to look homogeneously across the entire application. Customization is possible through methods exposed by the factory: 

I have also added some defaults to make it easier to use for the caller. 2. Changed function to support back-off [edit] Changed from to as suggested by 

where contains definitions for all public methods in the class above, thus allowing the repository to be injected. So, your service layer should not work directly with EF data context, but rather using the appropriate repository: