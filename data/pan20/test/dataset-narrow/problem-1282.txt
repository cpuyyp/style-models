It's worth mentioning that I also plan to use UV-mapping so that only the walls facing the light source will be illuminated, rather than the pre-shaded tiles I'm using as an example. However, that would mean that the tiles adjacent to a wall in shadow may be lit and I don't think this would look quite right. Alternatively... B) Occlude light from the entirety of the wall tile 

It sounds like you don't want to create a whole bunch of instances for the GC to clean up, so how about using one or more to hold the text file data? 

You're already part of the way there with recognising that your targets have a constant velocity - as well as the speed they are moving at, they're also moving in a specific direction (which is the difference between a speed and a velocity). If you know where the bullet is travelling (given its current location and velocity) you can calculate that after x time it'll be at a new location. Using a bit of basic maths with this, the position of the turret and the velocity of the bullets it fires, you can then calculate the position you want to be aiming at to hit after x time. 

Edit I have created a fully functional example of that. It runs as a command line program and works in visual studio. I've added comments to try to answer OP's questions. 

There is no standard way of doing this. This is purely a marketing feature. The most logical way to do this would be to use the default language of the OS of the mobile device as all mobile devices have that feature. Don't ask the user. Then in the options offer to change the language if you want. You could consider it a hassle, a wast of time and money as often the option will not be used. 

as well. These functions are called each frame instead of only the first frame there is a contact. In fact, you should probably only implement these as otherwise on the first frame you'd get 2 life reductions instead of only one. 

One of the things you can do is work with it. Really, this depends on what you want to do, but Orteil made Cookie Clicker. The game is clear javascript/html. He took into account that the game was really open source and he added a "cheat" mode. The cheat mode allows you to cheat, but it also "records" it in your stats. This is not available to any kind of game, but you could try and sneak it into your game and make it a feature. It's harder to do with multiplayer games, but if you make some features server computed only, and let the users "cheat" for trivial thing, this could make an interesting feature :) 

I'm also working on a pixel-based (i.e. not tile-based) lighting and shadows implementation. I'm currently struggling with trying to decide how/where to project from a light source on intersections with these wall tiles. 

Go is difficult for computers because there are many, many possible moves for the player in each board state, too many for the computer to brute-force and calculate all possible outcomes (unlike, for example, tic-tac-toe). Traditionally, chess playing computer programs would calculate all possible moves a few turns into the future and pick one of the moves that would lead to the "best" state, maximising the possible advantage of the computer player and minimising the possible advantage of the other player. However, there's more possible moves in a complete game of chess than there are atoms in the universe, and this applies even moreso for Go, where there are many more possible board states. There are simply too many possible moves for a modern computer to calculate in any reasonable time. Instead, different approaches to AI need to be used to play "better" at games like Go, such as deepmind being able to "learn" how to get better at a task in a similar way to how real intelligence works (learning from trial and error). So if you want to make an "open information" game hard for a computer? Have a very large amount of possible moves to make, nearly all of which could be a good move for the player. 

All of these tools have a purpose, and must be executed in the proper order on the assets. Each company has its own unique set of pipelines for different purposes (e.g. one for 3d models, one for the audio, one for the AI, etc.): they evolve out of the needs of the company and the engineers who think about them. 

Don't use Euler angles for that, you'll get in trouble with a Gimbal lock in some situation and you'll be clueless about what the angles will be doing. I would suggest you use a space for your object, i.e. the option 2 you suggest. To make a space you need 3 vectors: the front vector, which represent the front of your model and the heading, and the side, which is arbitrarily left or right (be consistent across all of your system), in the case of a plane, it would represent one of the wings. From these 2 you can infer the 3rd vector with a cross product. The vectors represent the local space of the plane in world space. 

This seems more realistic for the ground tiles but does not let me easily illuminate the wall "sides". I'm not really happy with either solution so my question is: is there another alternative which will give more realistic shadow-casting in a 2.5D view? I'd also rather keep the sides of the walls visible rather than use a top-down only perspective as I feel this would force the rest of the art into a top-down perspective, rather than pseudo side-on. 

I can't decide where on these tiles should occlude light cast out by light sources. If the red highlighted areas are the "top" of the wall, and the blue highlighted areas are the "side" of the wall, I believe I have two options: A) Only occlude light from the "top" of the wall 

I'm working on a tile-based 2D pseudo top-down/side-on game very much in the graphical style of Prison Archiect. More specifically, I'm referencing their style of drawing wall tiles where you can see the south, east and west sides of the wall at once. Here's an example from my engine: