This script has been in use now for close on 10 years.... it has been extended, modified, and 'fixed', but has never been reviewed. Because of its age, it does not use the latest perl goodies..... sorry. The output from the program looks like the following: 

and then feed those states on to a Concurrent*Queue on the notify side. Then, have a seperate thread that reads from that queue (guaranteeing the order) and feeds the events to the listeners. This also removes potentially long-running method calls from the service that provides you the notification events.... (i.e. this may make the OS more responsive to other applications) 

That would also remove the ugly exceptions you declare to throw... as it is, I would probably (bad practice) 'try' the whole loop, and 'catch' the ugly exceptions and replace them with a wrapper of an that explains that an inner Collection could not be instantiated. General Overall your method is neat, and well structured. I can't really fault it, given the constraints of the problem. Update: Actually, the method should have a lower-case 's' to start the name. How did I miss that the first time? Should be not I would prefer that the method declared the input as : because that is a habit I am in... Typically I would recommend against returning the data typed as an because the implementation should not be reflected, it should just be , but, again, in this case, the specification requires an ArrayList return value. Bonus A Java 8 implementation of this would be a good exercise. This is what I would try: 

Your faith in your input data is absolute... you do not do any validation. This is not a 'best practice'. You should at least be doing an input range check on the . Once you have the range-check done, you can avoid the whole switch statement, and skip to some simple math for the index lookup: 

Note how, from point 10 onwards, all we did was add a 5? So, the proof, for your situation, is that you can divide the total by 5 until your value is less than 10.... and then choose one of your canned solutions.... using some... as a consequence, you only need to solve the puzzle for the value less than 10, adter you have removed the 5-coins needed after that. In psuedocode: 

It looks like what you are trying to do is a binary search on your dict, but you have a number of flaws: 

By suggesting that the complexity is \$O(n^2)\$ you are showing a gap in your knowledge of complexity. For a start, there is no defined in your problem... what is it? Also, if time complexity really was significant/applicable, a complexity of \$O(2^n)\$ is huge. Every time you add an input value, you double the execution time. So, for example if you currently had 4 input values, and it takes 4 seconds, then it will take 8 seconds with 5 input values, and 16 seconds with 6 input values, and, with 20 input values, it will take ..... almost a day. and 24 values will take a month, and 30 values... 8.5 years .... 

YES The game is cheatable. Like most software, the game is cheatable whenever there is a debugger available. In this case, I have loaded up FireBug in Firefox, and learned a few tricks. Here's how the game is cheatable. Note, this is based on playing the game from your source here: 

Note how is the sum of all memebers to the left of , and then just needs to find the difference. Remember, optimization often involves solving expensive problems fewer times, and reusing the results of the expensive calculation to derive other answers. As for your code, the LeetCode Javascript format is not a great one for good code quality..... but your use is simple enough to not have any real issues. Try it out here: 

So, you are creating a future that will result in a ChannelDecoderEvent output (that is what the ExecutorService.submit(...) does). But, when you pull values from the queue with: 

OK, so, with the above class, you can get (with a timed delay, if you want) the URL, and you can set it too. This encapsulates the logic for the process well... but, the problem is that you need to have one, and only one instance of this for each source/fileName. This is solved with a single ConcurrentMap... (using the same key/value instances). 

I extended Mike's script, and then ended up rewriting it in . Over time things have changed. I now have a RAID array mounted on which contains things that are supposedly 'valuable' to me. The regular filesystem is still mounted as . The destination for these snapshots is the disk (also a RAID array) mounted at . There is about 2TB of valuable data (many large photographs from the whole family, e-mails from decades, and documents, etc.) An example configuration file for the script is: 

The problem here is that your class is not symmetrical. If you gave a 'getter' that can return Direction.BOTH (when ), then you should have a matching 'setter'. In your class, I imagine you have a setHazards, as well as the method . You should replace those methods with a simple , and remove the boolean. This would make your API symmetrical, and the logic clearer: 

begin a transaction query-with-update-lock and update just that one record insert into the V table commit the transaction 

Notice something in there - using the "TCP" versions of the various Dial, Resolve, and Listen methods. They help with getting instances in to the right/useful types. The above code also changes the "String()" results in some places.... and I think that is causing some other tests to fail... maybe. Also, it Still Has a race condition - it may not close the listener socket before the next system tries to use the port. That's OK, though, because the next attempt to do a listener should choose a different port. Testing In your tests, you use a combination of and also . Instead of using you should just use the While the above is a bit messy, it's plain wrong to have in your tests. Use instead. For what it's worth, I am not getting the tests to run.... hmmmm you have a go-routine bug in your code. This is creating a race condition: 

For example, suppose your stream is split in two, and the two parts are accumulated in two maps and . Your collector should produce the same results regardless of whether or whether . Your streams will produce non-deterministic values for your inputs because your Collector is non-deterministic. I am not certain how I would solve this problem.... there has to be a way to 'tag' the data at the beginning of the stream such that it is labelled with a 'key' sooner.... instead of arbitrarily, and non-deterministically assigning one later. Conclusion I believe the code produces results that are 'correct' for the context of the way you use it, but the results are non-deterministic, and thus are going to be a problem in the future when things go wrong. You need to do something to fix the non-determinisim earlier in the stream: 

There are a couple of things I think you should consider, on top of what Sanchit has pointed out. The two things I can see are: 

You will need to change a couple of references to after the above change. I find FlagSet to be useful especially when using go-like sub-command processing. handling In your code you use regular expressions to parse error messages, and simplify them for presentation. The parsing of error messages is an anti-pattern in Go. An improved mechanism is to do type assertion on the error, and to directly manipulate the results. So, for example, the package is documented to normally return instances of an . You can use this in your code to handle the error better (see Error handling and go blog and more specifically type switches): 

it searches for thelower-case remove from the previous position, saves the value to find, and checks that the result is 'positive'.... all in the condition of a while loop. The full code is: 

This problem is a common problem in coding challenges, and it's a nice one, because there's a really elegant solution which is really fast. It does not even need dynamic programming.... just a little trick of logic. Your solution takes each position, and for each position, sums all values to the left, and right, then it repeats that until it hits a match. Your solution thus scans all N elements about N/2 times (on average, you scan half the data until you hit a match). This makes your solution a time-complexity of \$O(n^2)\$. If you double the size of the input, the solution takes 4 times longer. Now, a simple solution is to scan the entire data once, and calculate the sum of all the values: 

In general, with the name-pollution of having a class with 'Link' in the name (probably because it's not a horrible name', but it conflicts with LinkedList, so try to avoid Objects with Link as the name. Additionally, note that your variable was not an index in to the source data, but an index of the output segment. Including it as part of the original 'for' loop implied that it was used as an index in to that. The reality is that it is independent. I have edited it to make that clear. 

Which will preserve any of the tokens inside the value part. EDIT: You have suggested in your edit that this is for sending data to an external command. If you are using Java to initialize the external command, then please, please, please use the version of exec() that takes a command array, or use the ProcessBuilder which allows you to send all the command-line parameters as separate values in an array!!! 

Normally I am against updating a loop-counter index inside the loop, but there are times when it makes sense. This is one of those times. Note, the skip variable is being calculated naively in this code. It should be smarter about taking the sample-size into consideration, and making sure it hits the beginning of the sample rectangle properly on the next line.... as it stands, if the rectangle is an odd-size, it may cause the start position of the next row to not be on the rectangle boundary. On average, I don't think this will make a difference, but that is your call. 

There are two concerns here of significance. First up, I am not certain that reflection is the right tool for the job. You've done it in an effective (if messy) way, but a better approach would be to have each problem implement an interface, something like: 

This will try to create a symbolic link at that points to the (presumably pre-existing) file This means that whenever anyone processes your settings script, they all modify the same file and, since the first person will replace the tokens with their name, the other users will have nothing to do.... I presume the line: 

About that Semaphore.... Your code is asymmetrical in the sense that the semaphore is acquired in one class, and released in another (the Runnable)., This makes it hard to follow. Fundamentally, though, your system is a poor example of using the package, and there are more 'idiomatic' ways to do this: 

There are a number of things here which concern me. First up, the stderr log file does not have the time on the file name (missing ). This is a classic copy-paste+partial-fix issue, you copied the same code to multiple places, then needed to fix it, but you only fixed some of them. The solution to that is to extract the code to just one place, and reuse that: 

You can avoid the conditional checks on 1 or 2 steps, and you can also remove the calls because the square of negative numbers are always positive. Try-With-Resources I really like that you have used a try-with-resources to open the buffered reader (though again, @spyr03's suggestion to use a Scanner is a good one. My special point here, though, is that one of the main reasons that try-with-resources was introduced, is to ensure the resources are always closed in a sane order. There is no need to explicitly close the buffered reader at all... the try block is designed to do that for you. 

I realize that you were only supposed to implement the method, but, the rest of the queue is code that can be significantly improved too. Your queue is a fixed-capacity queue. There is nothing wrong with that (except that the array should be declared as ... ), and, it actually makes some things easier. Like, one of the most complicated things with a circular buffer/queue is to manage whether the queue is full, or empty. at both times, the rear and front cursor are the same. There is a really nice way to solve that problem, which is to not use a rear pointer at all, and to only use the front, and size. Now, your code has the front, rear, and size variables, and it sometimes uses the rear variable, and other times uses the size... and this leads to confusing code. The thing is, that you can easily calculate the rear from the front and size... or, alternatively, you can calculate any one of those three variables from the other two. Bottom line, is you only need two of them, and keeping the size makes other things easy. Here's your code, stripping out the entire 'rear' variable.... Other things I did are: