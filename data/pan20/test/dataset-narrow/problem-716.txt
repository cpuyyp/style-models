Your code is pretty neat looking but, alas, I think the architecture is wrong. Packet should be an immutable object acting as a passive container IMO.... by doing this you are removing the following fields : 

for additions : one test that prove that a matrix M + a matrix full of zeroes give the matrix M for scale : one test that proves that a matrix M * 0 is a matrix full of zeroes for scale : one test that proves that a matrix M * 1 is the matrix M for multiplications : one test that proves that a matrix M * a matrix full of zeroes give the matrix full of zeroes for multiplications : one test that proves that a matrix M * the identity matrix is the matrix M for additions : one test that prove that a matrix A + a matrix B gives the same result as a matrix B + the matrix A for additions and multiplications and scale : show that your method(s) are associative for division : show that your method(s) are NOT associative 

by the simpler 2) I think the is fine overall, but maybe you should consider checking the library that do all necessary checks on the and methods ;) 3) however, the doesn't test much :s Most of your tests are basically comparing the result from your mutable methods with the result of the immutable variant of you methods... so if both are bugged, then your test may pass while it should not. The only tests that are real tests are testExponentiation and testOrthogonal Consider creating some tests with matrix (with random values) for the operations with "special behaviours" : 

I would remove the try catch and do not return any boolean. As a general rule, you should only catch exceptions you can handle. For example, if you use this piece of code in a user interface, the boolean cuts any possibility to give feedback to the user. Instead, if the method will simply throw, you can probably handle it in a more convenient way and display a message to the user (for example, can't connect to...) Additionaly, if you catch and return booleans everywhere, your cyclomatic complexity just grows as your code will look to something like this 

You can probably still improve the loop but I guess you will lost readability, so I would leave it like this unless you face a real performance issue. Regards 

5) Validation rules are set somewhere on the fly and it is impossible to figure out what are the validation rules of your data class just by looking at your data class. 

Don't take it personal but your approach is not good and will be very difficult to mantain. Reflection is the way to go but take a look to validation attributes, component model and data annotations. Here is a link that may point you to a better direction: $URL$ You can create your own validation attributes or use existing and have a class that takes by reflection those attributes and evalute them. Edit Some reasons why the approach is not good 1) A field can't have multiple validations (mail + required + maxlength,...) 2) Your validation can't compare values with other values (bigger than x, required if,...) 3) class will become soon fat class, as it handles all the validation rules. 4) You will have to duplicate this code every time you want to validate, what could be in multiple places and in multiple applications, if new rules are comming you will have to update all those places. 

If you are using java 8+, you should take a look the new static methods in the class (nio package) and how to manipulate objects. About your interface, yeah... it's better removed, because it is so coupled to the rest of your code you will probably never have another implementation besides . 

You are putting a value in cache (which is cool BTW) but since your object is mutable, you may have strange behaviours. You should either remove the cache manually in all methods that do a mutation, remove mutation altogether (recommended :P) or remove the cache. Avoid declaring two variables on the same line and don't use label (they basically are s). You should be able to solve this by using the method from ;) 11) Lastly, I find it more readable when the // methods are at the very end of the class 12) Your and methods are bugged IMO as they use 13) The method is not used anywhere and, thus, should be removed Now onto the tests classes ! 1) Basically, the same as before : avoid using for every test, you can replace the 

So we are unless we have more than maxOccurence, in which case the will always give us maxOccurence as a result. That's not very palatable though IMO, I'll use static import to make it cleaner. Let's also not forget to store the result. 

That's quite complicated just to read something from the console consider using for such a simple use case 

DALEmployee What is the concept behind this class? Do you really need it? If yes, my recommendation would be to inject IService1. You can google dependency injection to get more details. Controller If you don't need DALEmployee, you can simply inject IService1 directly in the controller. getEmployees Generally is weird to me how you achieve the pagination. Generally i would use as parameters CurrentPage and PageSize and for me it seems you that you are using the employee id. How would you extend this if you have to sort by other criteria rather than employee id? Additionaly, you are using a different where on the get count and on the procedure itself, what will lead to wrong pages. Finally, depending on your sql server version, you may use this operators to paginate. SELECT * FROM TableName ORDER BY whatever OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY; 

I totally agree with @RobH answer but I would like to mention some extra things. You have 2 unused fields that I guess are there for testing reasons but they are good to illustrate the concept of readonly fields/properties as you only set them in the constructor. Your class could look like this. 

regarding your concerns. 1) I do not believe this initialization is a problem but if later on it will be a problem, you can always change it to lazy initialization. 2,3) I just paste a similar code that I find more readable and improves your loop when you want to find the parent area.