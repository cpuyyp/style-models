Don't become an casualty. Determine what your business rule is for an "empty" cell, and test that instead. In your case, it would probably be . 

Default Instancing Don't do this unless you have a really good reason to, and I don't mean "not typing a separate assignment" by "good reason": 

Style comments were covered by other posters, although I'll add a couple more. First, you have some conditionals that don't do anything. For example on this one... 

This implementation actually looks really solid. A couple stylistic and micro-performance issues I would personally address: Array base: I'd remove and explicitly declare your array dimensions. The problem with using is that it is a module level option, and it "taints" all of the code in the module with a non-default setting. I consider it similar to using in C - it alters the semantics of your code. There's not even really a reason to use it in this case because you are always using the to initialize your loop counters anyway. Changing this line... 

Finally, just as an aside - I have no idea what is doing in , but from the block it appears that is calculating both and when it only ever returns one of them. I'm guessing this would be a more efficient structure: 

Note, it isn't clear from your question if the numbers in the have meaning outside of the code that you posted. If they are, just make them a property of Advisor. Throw in a couple factory functions to easily generate objects (curse you VBA for not having constructors)... 

Blocks - Use them. They aren't just a convenient way to avoid typing the variable name repeatedly - they hold a reference. This means that the VBA runtime doesn't have to resolve them repeatedly. That makes a big difference. Wrap the largest section that you can (I'd probably do the whole loop) and wrap it with the object you use the most: 

Brass tacks time - let's see how much overhead this wrapper really adds. This is the called routine: 

Fourth - Get into the habit of declaring the scope of your Subs and Functions to make sure that you are only exposing the ones that you intend to. If you leave these off, they will default to public and start showing up in your function list in the Workbook and be available for auto-complete. If it isn't something you would want to show up in a cell, i.e. , declare it as . Finally - Declare your function return types. It isn't clear what the code below returns, and the comment makes it worse - it doesn't return a at all, it returns a . 

String v. Variant Functions: You may have noticed that most string handling functions have 2 versions - the "normal" function, and a version that ends in "$". The ones that end in "$" return a , the others return a . If you are assigning the return value to a or passing it to a function that takes a as a parameter, you should use the function that returns a . The reason is that there is an implicit cast performed, so this... 

Since the previous posts covered most of the structural issues (VB6 data structures v .NET, enumerating the payment modes, etc.), I'll address the remaining elephant in the room here. Looping through dates like this is similar to counting on your fingers to find out how many fingers you have on your hands. Nobody would even consider (or maybe "should" is the better word) doing this with a numeric type: 

If you are early bound, the name information is available via both Intellisense and the object browser. If you are late bound, it actually adds more overhead for the runtime to resolve them. Just use the ordinal argument positions: 

Removing variable declarations makes them implicitly . The following are undeclared in : , , , and . This is a huge performance penalty, because every time you use them, the underlying values need to be coerced out of the . You also can't store strongly typed objects in a , so that means every single one of your calls to and is late-bound instead of early-bound (that's why you don't get any Intellisense when you type or . That's a ton of needless overhead, especially when you're in a loop. If you can early-bind, do it. Put at the top of the module, and then declare everything. Put the strong typing back in. Note that the original code had this wrong too - lines like... 

The dynamic parameter generation isn't ideal, but isn't really avoidable if you need a general purpose function. I'm guessing that a large amount of the inefficiency is repeatedly creating new OleDbCommand objects (as well as the SQL string) when they can be re-used. In fact, parameterized OleDbCommand objects are optimized for looping over with multiple inserts. Add your parameter list without values before you go into the main loop, and then assign to them by index. This should speed you up quite a bit. If that doesn't get you into the ballpark of where you need to be performance-wise, the Access object model will let you automate a bulk insert from a tab delimited file. You may want to benchmark how long it takes Access to import the file and explore this possibility too, especially if you control the datafile generation. One last note: Don't forget to "'TODO: Write the row and the exception somewhere" and keep swallowing the exceptions. EDIT: Good starting place for Access automation is here - there are some community links at the bottom of the page that are pretty good. I'd only use this as a last resort as it pulls in lots of dependencies and requires starting an Access process. I'm fairly sure managing the OleDbCommand outside the loop is going to give the best performance. 

You have it as , which means that all of the parameters are implicitly . Granted, you're basically using for everything, but again, you just added at least 3 extra unboxings for every call. Not to mention the extra work that Excel needs to do when you pass them as indexers to . Put the strong typing back in. 

Then, all you have to do in the calling code is grab the Dictionary from your parsing function and grab the lines as needed based on the keys: 

You should remove dead code instead of commenting it out. I realize you're actively working on this, but that points to a need for source code management. 

That leads to another readability issue. In a procedure this long, declaring everything in a block at the top of the procedure makes it more difficult to keep track of what everything is, especially when you're using identifiers like . It's usually more readable to declare a variable immediately before you use it the first time. 

You forgot when you extracted the function. You have at the top of ...and the repeat that call at the top of both and . If you want to make the 2 functions a bit more reusable, give them a Workbook parameter and pass that in. If you don't care, skip the variable declaration all together and just use explicitly. Note that this isn't the same as - it's a hard reference to the class in the project the code is in. 

General 1 - The first line in is setting the return value to its default. At this point in the function it is already : 

First, I thought I'd mention that your code is stylistically really good - variable and function names make sense, indentation is great (with one small exception noted below), and the functions are focused and readable. Just one minor point: The code under each in a is typically indented one more level: 

That out of the way, you should try to use the tools that the host application offers when possible (and performance allows). Excel actually keeps track of blank cells in its collection. You can identify all of them by calling , which replaces the need for manually identifying them cell by cell. The method also works on non-contiguous cells, so the entire can basically just be replaced with a one-liner: 

Even with the overhead for the API call, this is blazingly fast. It also completely eliminates the need to call repeatedly, completely eliminates the need to pad every byte to 2 characters individually, and involves exactly zero math operations. Once you have the in the byte order you want, all you need to do is call once (note that it also has a returning variation - kudos on using the one for ): 

2. User cancellation is not an error condition I'd consider this section to be an abuse of the error handler: 

Overloading VBA Keywords Don't do this. It not only makes your code hard to read and understand, it also makes it really easy to do something unintentional. In this bit of code it's obvious that is an enum (other than the fact you declare the variable as with your prefix and the member of returns who knows what because it's declared as - looking at you, Hungarian notation...): 

I'm not sure what you mean by "This does the trick but not very efficiently". I don't really see a way to make the algorithm more efficient, as it is just making a single pass over the array and exits early when it gets the answer. If the input is really long, you could convert it to a byte array instead of splitting it to cut down on the casts, but then you would have to nest the loops, add a subtraction to convert the ascii codes to numbers, add multiplications to keep track of multiples of 10, etc. This would likely be a lot slower than the current method unless you were working with strings on the order of kilobytes. That said, a couple of observations about the code. I'd personally use a For loop instead of a While loop to prevent you from running outside of the array bounds for inputs where the target number you are looking for is higher than the sum of the complete array. For example, with the input string of "6-7-7-10-7-6", a target higher than 43 will overrun the array bound and throw an error. You'll get a similar error if it is passed an empty string (Split will happily give you an array with an upper bound of -1 in that case). Also note that you are not returning the zero based index, you are returning the one based position of the token in the string. If this is the desired behavior, I'd rename the function to make it obvious that you can't use the return value to index into the array. About the only thing that I would do to make this a tiny bit more efficient would be to use a String array instead of a Variant and use explicit casting so the run-time doesn't have to resolve the Variants for you more than once. Even this improvement will likely be unnoticeable on any reasonable sized input (you'll overflow an Integer long before you'd notice the performance increase anyway). Maybe something like this: 

OK, thought I might get a quick win if you were using a version of Access old enough to be using the Jet engine (in that case DAO is inherently much faster). First thing: Don't go down the road of your "Logic 2". The fact that you realized you have to escape any quotes in the input file should be a great reminder as to why using parameters is good practice - it sanitizes input and avoids SQL injection. Second, and this is the main one. You are looping over code that should always execute with the same results. Pull these out of you loop so you only do them once: 

There are a couple helper functions for managing the array indexes - the first skips matching substrings in the 2 arrays: 

Both calls are going to return the exact same result, and they involve 3 function calls on sheet. In general, you should be looking for function calls that are always the same and pull them into a local reference - same thing with calculations that you know will always have the same result. For example: 

The first call to returns the sheet that was added. You can ditch the call to to pick it up, and avoid the need to find it the second time in the collection by simply doing this: 

This is the first of (hopefully) several posts as I reimplement an ancient (and unfortunately long lost) Excel VBA Tetris clone. The main workhorse class in the game engine is the display driver, which uses a rectangular area of a Worksheet to emulate a monitor. The display is sprite based, so the class holds a Dictionary loaded with IDrawables, which are basically bitmaps. The interface is as follows: 

This means that the calling function doesn't have an easy way to determine if there are any results other than the non-obvious method of checking to see if there are 2 items in the returned array. Since you are returning a , I would suggest returning either or some other non-array value if there are no results - this makes checking the return value simply . Still on the topic of arrays, resizing arrays in a loop is horribly inefficient. Every time you use , the entire memory area of the array is copied. Using a is roughly 10 times faster (benchmarked with 100,000 inserts). A is slightly faster than a , and makes it much easier to return a containing an array (it has a method). Excel specific Calculating offsets and requesting objects from Excel is also expensive. You already have your conditions set up to "short circuit VBA style", but each time you go through the loop you collect all of the 's before you know whether you'll need them or not. For example, if this test fails you don't need to retrieve any of the others: 

Finally, there's a helper function that formats the output. This could be pretty much anything - in this case it's a comma delimited string of 1 based character indexes (that was the convenient output for the original calling code): 

You need to remember to dispose of your FileStream and StreamReader if you are accessing them this way. The easier and safer way to do this is with the using syntax, which will close and dispose of them at the ending braces. I'd get into the habit of using this with any object with a .Dispose() method. 

The reason is that it completely bypasses all of the few legitimate reasons to (see Setting objects to ) because it allows VBA to auto-instantiate one for you: 

...makes it immediately obvious that the array is 1 based without having to scroll to the top of the module or remember that the base is non-default. Variable naming: and are about as meaningful as and . Something like and would make it a little more obvious what your code is dealing with. Worksheet references: You are currently using magic numbers to locate the worksheets that you're operating on, and the indexes are based on the ordinal of where the sheet is in the collection. If this is intended to operate on two fixed worksheets, use their class names instead. This has two benefits: first, you aren't using 2 procedure calls ( and the implicit ) to get a reference that you already know and have access to . Second, your won't break the first time you add a new worksheet. For example, use (or whatever it is) instead of . Binding: There is no reason to late bind to the scripting runtime. The interface hasn't changed in this century, and is unlikely to. This is a pretty good performance hit in exchange for absolutely zero upside. Add a reference to Microsoft Scripting Runtime and declare it explicitly: 

Properties - This is a one cell that determines where the display rectangle will be placed. It will raise an error if more than one cell is passed. and are the row and column number of the in the parent Worksheet's coordinates. These are read-only and are derived from the . and set the dimensions of the display. is the size of each "pixel", and the rows and columns in the display range are set to this width and height (in pixels). Currently I have it limited to CGA resolution (mainly for convenience when I test it), but the limits can be set by altering the appropriate constants. sets the background color for the display. Any pixel in an that matches the will be "transparent". 

First, I'd like to echo @Mat'sMug's distaste for your multi-lined statements. There's absolutely no reason to do this at all having them prefixed with makes it completely obvious that I'm looking at a declaration block. It took me a good minute to realize that it wasn't a continuation of declaration, because the literally disappears into a huge wall of code. You aren't saving any time typing it either - last time I checked, and were both 3 characters, and the former is a lot easier to type on a qwerty keyboard. 

The beauty of this approach is that because you now have the underlying data structure of the array in a variable, you can just change the pointer to any memory that has been allocated, and set to the the data type of the list. An function is then just shifting memory one element higher in memory from your insert offset and dropping in the new item, and is the opposite. What makes this really slick is that you can just point an back at the , and VB6 won't even blink because it is exactly what it expects to see. About now, you're probably wondering when I'm going to get to typing. Gimme a second, because I want to go over Variants first. Again, keep in mind that we are dealing with a COM object and not strictly a VB object. Microsoft put Variants into COM specifically to allow loosely typed languages a way to marshal data via the API to and from strongly typed languages. The way this works is by passing a structure that includes all of the information that the receiving API needs to determine what the underlying data represents. In that VB6 only implements a very small sub-set of the available data types that a Variant can represent (see the MSDN link a couple sentences back), you could conceivably enforce data typing that VB6 doesn't even natively know about. All you have to do is to examine the Variant as a memory structure instead of passing it through the built in function. This is basically what it is doing anyway (and although I can't verify this, I believe the casting functions use the Variant's union to determine whether a Variant can be cast to a strong type). By directly examining these you can bypass the VB runtime and also avoid all of the string handling involved with using . This article is a good place to start, although most of the links seem to have died. Finally, and not for the faint of heart - if you want to have your List return its type without using the function, you can always hook the VB runtime dll itself and intercept function calls to native VB functions. I wouldn't do this in production code personally, but you can get a good start on that here if you want to really start mucking around in the internals. Scroll down and read about trampoline functions. I've never hooked the VB runtime itself, but it shouldn't be different than any other dll as long as you are really careful what functions you use while you're shuffling its memory around. Disclaimer If you try this, you will crash your IDE at least once while you are debugging it. Make a habit of never starting a debugging session when you are manually handling memory without saving your source code first.