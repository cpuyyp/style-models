In the image above there's on the left, in the middle there's and on the right you can see the blend mode I would propose for this setup. 

The collision test will be between your and your platforms, but the shape of the object will be used as collision shape of your platform. 

Your best bet is probably to mod an existing game. Some people are even modding Starcraft 2 to an MMO, but that looks like a lot more work than modding a game that already has some RPG features. There's an active modding community for Diablo 2, so this might be a starting point? I'm making this answer CW, because I'm not a modding expert and somebody might add some better suggestions for easy moddable RPGs or MMOs. 

There's no such thing as best physics engine. It heavily depends on what you need. Take Box2D as an Example: It is a fully featured 2D Physics Engine, originally developed in C++ and ported to ActionScript. It is great for realistic 2D physics simulation, including gravity, forces, friction, continuous collision detection and much more. An Engine like Box2D is going to use quite a lot of your CPU cycles, especially when using it in Flash. It is also not trivial to set up and to create appropriate collider-bodies for your Entities. If you wanted to create a game like Breakout, an Engine like Box2D would be overkill. A game that heavily uses physics for gameplay like Totem-Destroyer, is probably easier to implement when you can make use of a good Physics-Engine though :-) There are also other implementations like the one provided with the Flixel Game-Engine. It isn't a physics-engine per se, but it contains a solid collision-detection algorithm. The engine also updates entity velocity and gravity. In most cases, the tools provided by Flixel or similar engines are good enough. Just keep in mind that using a physic engine is going to be CPU intensive and you should choose the implementation that best fits your game. 

I wonder why you're choosing a pixel based collision detection here? A game like Farmville works with a tile-grid. I assume you have such a data-structure in your game that holds all the tiles? Why not simply query this data-structure and look up if a tile is already occupied? If yes, snap the new tile to an adjacent field, or simply prevent the user from dropping a new element there. Update: Have a look at the following screenshot: 

If it's just for a prototype, I'd say go with the approach you're most familiar with or the one you think you'll get some fast results (that's usually the same as the one you're most familiar with :)) After the prototype is done, I suggest you switch to a game-engine. GUI-Frameworks for business apps might work for some games, but in the long run you'll benefit from the game engine. Also: You should switch tech to implement your real game, so you don't get tempted to just turn your prototype into the real game. This could be an excellent way to learn about a game engine. 

It isn't the program that makes a good artist. Expensive software like Photoshop or Illustrator (or the free counterparts GIMP and Inkscape) won't magically turn your art into masterpieces. Use the software that you feel comfortable with. The better you know a tool, the less it will stand in your way, increasing productivity and creativity. I don't share your opinion on the Flash vector graphics though. I think a lot of these games look awful, but that's just personal taste. Sadly, there's no best or most efficient way to achieve good results. However, I think it's important to sketch out a style and then stick with it. If an asset doesn't fit into the overall style of your game, redo it. Familiarize yourself with your tools, so that you can turn your ideas into artwork. Personally I always use paper and pencil first, because it's the "tool" I feel most comfortable with and I can achieve results fast. When I'm happy with the drawings, I can scan them and continue working on them in another tool. 

Now imagine that the nodes of that graph lie in a 3D environment. They would have a position (X,Y,Z) and using that you can also calculate the distance to the neighbor nodes, which in turn can be used for the heuristic function in A* (for speed, simply use the squared length and skip the sqrt). Of course the graph can also be changed dynamically. Maybe you'll even have to use several graphs. One that just models connections between rooms (fast calculation of: can I get from here to this other room?) and one fine-grained graph for the actual movement. There are also 3D "flood-fill" algorithms that can create such a graph for you, given some 3D data. These are rather CPU heavy though and you shouldn't run them during game. For dynamic objects, I would probably use steering behaviors to avoid them (eg. a barrel or a chair in the way). There's usually no need to update the graph for objects like this. 

The property of an is the object that triggered the event! So if you mouse-down on a sprite on your stage, the "moon" object will get attached to the clicked sprite (because events bubble)! So no, these examples don't do the same thing! If you did this, then it would be the same thing: 

If you want your bullets to behave like realistic physical objects (eg. your bullets are more like arrows or stones from a catapult rather than gun-fire), then you could also try to increase the frequency of your physics-updates. So while your game might run with 60 frames per second, your physic-simulation could run at 120 updates per second (here's the ubiquitous fix your timestep article that explains a good physics setup that can run at different speed than the render-loop). Of course, increasing the update-interval on the physics-engine will put a bigger load on the CPU. So this approach is only sensible if your projectiles aren't very fast moving (which I was assuming since you are able to tell that your projectiles are moving in arc). 

A lot of RDMBS can also do load balancing, so if you're really going to hit a DB performance bottleneck, you could scale up your DB servers. 

If your cells are dependent on the current state of the other cell during collision (eg. if the predator gains more speed if he "eats" bigger prey), then you can't apply effects of the collision directly. Here's why: 

If you just create animations and maybe have some frame-labels to jump to, this is going to work fine. It won't work if you have scripted animations, since all AS2 code will be lost when embedding. It's probably good practice anyway to have plain animations without scripting and let the actual game code control the animations. 

Why not let the Artist/Level-Designer draw the rough outline of the cave, then use an algorithm like the ear-clip algorithm to create convex polygons from that outline? You could even use a tool like potrace or autotrace to create vector outline from you images. Then use these directly or provide them to your Artist/Level-Designer as a starting-point. 

Blender is really picky when it comes to curve orientations and mostly doesn't do what you would expect. Your chess piece should have the same orientation as the circle, eg. don't rotate the bevel shape in an upwards position, rather keep it on the same "plane" as the circle, as shown in this image: 

Actions (sadly) can't be re-used or run multiple times. Instead you'll have to instantiate two actions or copy an existing one. Something like this should work: 

where is a float ranging from to . Update: As requested in the comments, here's a shader-example that uses two textures. One for RGBA and the other for the cutoff. You can create a new shader in Unity and replace the automatically generated code with the following: 

The workflow for 3D models is most likely less complicated than rendering all your models to sprites. If you change some detail in a texture, you don't have to render all the sprites again etc. Since you're targeting flash, you'll have to consider the limitations of the platform as well. The new 3D APIs (molehill) are capable of performant 3D graphics, however it might take quite some time till this player will be released and has a wide user-base. Current flash 3D engines like Papervision or Away3D could work, they will put a heavy load on the CPU though, even with low poly-count. Also z-fighting is a constant issue with these engines. If you plan to use a fixed viewing-angle, you can prepare your models in a way that minimizes these issues though. If you go the sprite-route, you can leverage existing frameworks like Flixel or Flashpunk and it won't matter how complex your models are. Also the amount of monsters/entities you can display on screen will be much higher with the sprite approach. There's probably lots of people that play games on Facebook that have an old and/or slow CPU (eg. netbooks), so performance can be an issue. So for your target audience, it would be best to go the sprite/bitmap route as of now. 3D will become viable with the new flash 3D APIs. If you're interested in that, this project might be a good way to learn about this new technology. Early adoption might give you more visitors, but it's also harder to do since APIs might change or tools/frameworks aren't mature yet. 

You can animate your model in a 3D animation-software that supports skeletal animation. The process of applying a skeleton to a mesh is called rigging. Depending on the current pose of the model, the rigging can be easier or more difficult to do. Normally you'll want a pose with arms spread out, much like in this drawing of Leonardo da Vinci: 

If you have Export classes in frame: 2 in your publish settings and use Export in Frame 2 on your shared assets, then you really don't need the meta-directive, as it's a Flex SDK thing. Also having everything in your library is going to be clearer. So now the question is: How do you simulate the behavior of using the flash library? Using the Flex SDK you would embed an image like this: 

There are two weights: The "bullet-weight" (grey) is the danger imposed by a bullet. The closer the bullet is to the enemy, the higher the "bullet-weight" (, where 1 is highest danger). Lanes without a bullet have a weight of 0. The second weight is the "distance-weight" (lime-green). For every lane I add movement cost (this value is kinda arbitrary now and could be tweaked). Then I simply add the weights (white) and go to the lane with the lowest weight (red). But this approach has an obvious flaw, because it can easily miss local minima as the optimal place to go would be simply between two incoming bullets (as denoted with the white arrow). So here's what I'm looking for: 

With the plethora of currently available JavaScript game engines/libraries the second solution seems unlikely, as a lot of engines will already have their own means of loading assets and depending on how the game was implemented, JS conflicts can occur. It would work well in an environment where the game-engine is already known, eg. for a showcase of an engine developer. Another approach are packaged applications. Google allows this as a way to package apps for their web store. Packaged apps can be downloaded and can also use the Chrome Extension APIs. This could be a great way to distribute games but if there's ever going to be a cross-browser standard is questionable. 

What that means is: Unless you're using a color managed application (eg. Photoshop) where you're specifically using a profile that's different from sRGB, you will actually work in the sRGB color-space. So if you're using an application without color-management (eg. Paint.NET), you will work in sRGB color-space. As I mentioned in my comment, the GIMP might be a good candidate for your needs (it also uses sRGB as default color-space, but does support color managment if you need to convert from one color-space to another). 

If you're using classes, there's an option in the Actionscript-3 settings, where you can specify a frame where classes should be imported to. So if your class is , just call something like this on frame 2: 

I wouldn't use a tile-editor for a game like chess. The board is really simple and you can easily draw it without the help of a tile-editor. These maps make much more sense if you have a large world/board with lots of different tiles. I don't know the GeekGameBoard you linked to, but it looks like it's a framework for card and board-games, so this seems much more suited for your task. It seems like this framework provides several UI elements, so you'll probably either choose GeekGameBoard or Cocos2d. Mixing the two would most likely force you to rewrite/refactor a lot of the GeekGameBoard code (which might be more work than starting your game-code from scratch). 

This feature is not limited to Game-Objects. You can use it for almost any type, eg. use an for hitpoints, for velocity, etc. It's a really powerful concept and you should use it (you can also modify these values on the fly while running your game in the editor to test/tweak your game). 

That's entirely dependent on the type of game and the requirements. In a game where there are lots of entities and therefore lots of path-finding queries, a lookup-table will come in handy. In highly dynamic worlds or worlds with lots of possible paths, lookup-tables are either useless or not practicable (as they would potentially consume huge amounts of memory). Albeit my insight into "the industry" is quite limited, I think it's common sense to use the tool that's best suited for the job. In some cases this might be a lookup table, in other cases real-time search is the way to go. 

It depends on what you want to do... if the user should be able to move one object at a time, it should be sufficient to find the closest object and move that upon movement. If you need to handle multiple touches, you should first and foremost set: