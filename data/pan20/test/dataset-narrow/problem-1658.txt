I am writing a data logging python script and I would like it to find out if the system clock has been synchronized via NTP recently, and if not, to attempt to cause it to happen before proceeding. Starting from this answer, I've found that for the status 

appears when trying to kill it. So for almost a minute, the DAEMON is a zombie (so to speak). This means that the idea of quickly turning it off and then on again is a bad one. Instead, if the OP (me) really wants to do this with Python, the script has to honor this transient zombie status and not just start and stop it willy-nilly. 

I've turned the WiFi off about five minutes ago so that explains the watchdog timer being 372 seconds. Is the value for frequency what I'm looking for? Question 1: Is using the lowest value for "when" a reasonable way to gauge roughly how long it's been since the system time has been checked against internet servers? Question 2: Does the ntp daemon make an estimate of system clock drift rate available in any way? If it's say 10 ppm or 100 ppm, is this reported somehow? Question 3: What do the characters in the first column such as '+', '*', '-', or absence thereof indicate? System: using Raspbian GNU/Linux 8 (jessie) 

Question: What could cause to fail to start pigpiod successfully some of the time, but still always return and throw no exceptions? edit: RPi 3, Python 2.7, Raspian 8.0 jessie Failure looks like this: 

edit 1: I've taken a look at Install NTP on CentOS which turned up in a search for help trying to understand what "lithium.constan" meant, and I found the command: 

After disconnecting the WiFi, I captured a few responses. According to the page 22.13. Checking the Status of NTP the column labeled is "how long since last poll (in seconds)" and it increases with time as expected. But I don't understand why between 155 and 434 seconds that "jitter" changes, or between 434 and 687 seconds "delay" changes. Right now I'm classifying that as an inconsequential bug and ignoring it. To me, the value of "when" is most important 

I'm using pigpio bit-banging script (download, GitHub) that interprets the pulse durations generated by the DH22 Temperature/Humidity sensor. It sets a 200 ms pigpio watchdog to the GPIO pin and attaches a callback, passing the tick count and new level. Here's a generic example: 

Comments by @Joan (above) were extremely helpful! MCP3008 does indeed use , where I had it erroneously set to . The following works very nicely! 

My PiBox module, I've left the verbose print statements in to help explain what I believe each step is doing. It's certainly safe to ignore or delete them: 

but it seems like a bad idea to do that if it wasn't necessary. edit: using Raspbian GNU/Linux 8 (jessie) Question: How can I test the status and then conditionally force a synchronization only if needed? This answer suggests the package $URL$ but I'm not sure if this is advisable or not, so I thought I'd ask before installing and running it, and I'd still have to guess the status by comparing the results to the system clock and deciding if the agreement were good enough or not. I'd still like to know if ntp is active and that it believes the synchronization is close. 

This is a partial answer; I am going to try to understand further why this is so. If someone is able to explain further that would be wonderful. The behavior described by the OP (in this case, me) is: 

edit 1: per @Joan's comment: pigs, the socket interface to pigpio also returns random bytes. The following are the pigs equivalents to bb_i2c_open, bb_i2c_zip, and bb_i2c_close. All bytes are non-repeating. 

I started to try to read an MCP3008 ADC using SPI bit banging with pigpio. I wrote the unattractive little script below, starting from the example in the pigpio documentation and here is a screenshot of my output. I believe that this should read the lowest four channels of the ADC and print the output. Channels 0 to 3 are connected to +5V, GND, +5V, floating, so I expected to see values like 1023, 0, 1023, xxx where the last would be noise. Instead I see all 1023's. Have I done something terribly wrong? 

will display the results on the console, but I don't know how I can get the python script to see if ntp is active or not, since this call returns only . I could always just force a reset even if not needed using 

Questions are at the bottom. When adding a time stamp based on the Pi's system time to a data file, I'd like to include some information about how reliable that time is. For example, if the Pi has not yet made an internet connection since power up, the system time will be quite wrong by hours, days, or worse. If the last opportunity for synching to ntp servers was say 24 hours ago, it could potentially be off by many seconds, and if it were ten minutes ago, it's "good" as far as I'm concerned. I'm using the following python to capture all of the lines in the response so I can decide later how to interpret them, the suppresses the header of column labels 

I'm trying to learn how to safely and reliably start and stop the pigipod DEOMON process from within a python script. If pigpiod happens to be running already, then this script is always successful. It stops pigpiod and then starts it again. But if pigpiod is NOT running when I run this, then MOST of the time it fails, and the standard message block that starts with "Can't connect to pigpio at localhost(8888)" appears when I try to instantiate pi = This happens even though returns , there are no exceptions, and a was executed "just to make sure". 

Today's announcement at raspberrypi.org: Raspberry Pi 3 Model B+ On Sale Now at $35 describes several improvements. In the linked YouTube video changes to the power supply are discussed between and , but I'm not quite sure which parts are historical review, and which are related to the most recent changes. Could someone point out which are the main points they make here about the new Pi 3B+ power supply? 

After turning WiFi on again and letting it run for a bit, I see the following, which suggests that it's periodically checking. 

You should learn Python , especially NumPy. Look at this example project utilizing those techniques : $URL$ 

Everything you assume from traditional Windows systems is irrelevant in IoT Core. Wintel binaries like apache.exe , php.exe and mysql.exe are positively unwelcome and simply won't work. Windows 10 IoT core is best regarded as vehicle to run one (1) full-screen Universal Windows Platform App all the time - there is no Desktop , no explorer.exe and definetely not multiple Windows - by design. Also there is no regard to backwards compability - by design. 90 % of the worlds Windows software (including XAMPP and relatives) doesn't work on it - by design. Raspbian can transform into a solid LAMP (Linux , Apache , MySQL , PHP) system with one apt-get invocation - by design. 

Since Silverlight is dead since three years at least , it is very very unlikely it will ever work on the Windows 10 IoT Core SKU. Silverlight didn't even work on Windows 8 RT , but only on Windows 8 Home/Professional/Enterprise. As usual, Silverlight on Windows 10 Home does work fine. 

Replace the call to @epiphany to a call to @lxterminal. Epiphany is a browser and obviously the wrong program to execute bash scripts. LXTerminal is the Terminal program of LXDE, the Lightweight X Desktop Environment. LXDE has been heavily customised but is still the foundation of the "Raspberry Pi Desktop". 

Since the Raspberry Pi has no consumer-grade video inputs , your project is - as defined - impossible. If you allow at least some additional components , it might be possible (Composite and HDMI USB framegrabbers , if expensive , do exist). Note that still leaves the software question unanswered , that is , if those devices work on Raspbian Linux in a satisfactory manner (or at all). 

Yes it is possible to overclock the GPU and yes , this leads to a performance improvement. Look at following resources: 

omxplayer does not save a RTMP stream to a file by default. Use a tool like rtmpdump to actually do this. 

Electron alone might manage 720p@30fps , but not full HD on the Pi. Launch and control omxplayerGUI from inside Electron instead , it should manage full HD. omxplayerGUI : $URL$ Read the manual , especially section 9 ("Developers Section"). 

The target is not people looking for a cheap Android box. It is for developers and OEMs which want to create medium-to-high powered IoT (Internet of Things) devices. 

Wouldn't you actually have the opposite problem ? You cannot use those Pi-specific GPIO libraries on your PC while developing unless you always deploy and test on a remote Pi (which is not unusual , but might need a bit more setup). 

The most important thing is that the seller makes references to device tree overlays. This guarantees that the driver is maintained by Linux/Raspbian and will always be updated and working, whether the manufacturer goes bankrupt or not. This is infinitely better than random images with random included drivers. Those are of no use if you are already using a configured Raspbian or Arch Linux ARM system. 

PiCAST uses a completely custom protocol incompatible with devices which actually support Google Chromecast. Furthermore , just like Apple Google is always modifying the protocol which has completely broken projects like leapcast already. If your device supports MiraCast , try using the "Miraclecast" project , it used to work on Raspberries and is based on a purportedly vendor-neutral standard. 

Many filesystems beat FAT on some points, but only FAT meets them all (esp. 3 and 5). Don't forget that Microsoft being a member of the UEFI forum was almost mandatory due the significance of the the products and the company itself. 

The image effects are built into the closed-source firmware and likely a low priority feature. All camara APIs and libraires interface with this firmware, which finally controls the camera. You can apply any post-processing you want with NumPy or Pillow yourself, though. 

gedit is a graphical text editor similiar to Windows' notepad.exe. All software in Windows and Linux can be started from the commandline irrespective whether they are commandline applications or not as long the graphical environment is running. gedit is no different. Whether a piece of software is a "command" therefore depends solely if it resides in the PATH or not. Both Linux and Windows work with a PATH variable. Learn more here. Please note that gedit is not preinstalled. Use leafpad instead if you don't want to download new software. 

Shrink your second partition with gparted to eliminate free space and use dd to only backup the parts you need. I suggest using a gparted Live CD (based on Linux) to modify RPi partitions. You can boot from such a disk without touching your Windows install at all. This is much safer. 

No , you cannot use PCI cards with any Raspberry Pi. No , you cannot "bitbang" PCI over the Raspberrys GPIO. 

After four years , Android for any Raspberry Pi model is still in beta state. You can follow the progress of the community porting efforts here. After 2012 , the foundation took the stance that they see little benefit in supporting Android , as they now percieve it as mainly encouraging consumption instead of creation. 

Silverlight does not run the RaspberryPi , there is nothing you can do about it. The Moonlight project (for Silverlight on Linux) never supported DRM and has no hardware-acceleration either. Both technologies have been abandoned by their authors too. Furthermore no Android builds are hardware-accelerated , stable or even Google "certified" which might be needed for DRM support. 

Working with Raspberry Pi SD cards is painful on Windows. I suggest using a gparted Live CD (based on Linux) to modify RPi partitions. You can boot from such a disk without touching your Windows install at all. This is much safer. 

Since consumer SD cards use top-secret Flash Translation Layers and actually have more capacity than advertised to remap bad blocks or for general wear leveling this is impossible via shred. The writes to a file might not end up at the same place where it currently exists on the disk at all. You have four choices : 

Neither Debian 7 (wheezy) or Debian 8 (jessie) support the Raspberry Pi3 in AArch64 mode. Debian 9 (stretch) will very likely support the Pi3 in 64bit mode , though. Progress can be monitored here: $URL$ 

to open the manual page with the given name. Almost all Linux commands have a manpage with the same name. Unsurprisingly