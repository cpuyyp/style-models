p.s., Python's iterator has the same semantics that you want as far as I can tell. You might want to give a look at the equivalent implementation. 

Otherwise if you're not able to change it, you should still create a separate logging method and disable to actual printing in the method there. That way your method is called but does nothing. 

Or alternatively, use the class to do your logging. As long as you have no listeners registered, you will not see any of the logging messages. When debugging, add a to the collection. 

It might be beneficial to add positional and keyword arguments to the method. That way you'll get your for any call you attempt to make, rather than just the no-argument call. You may want to add methods to delete or redefine singletons if necessary or restructure your class to address naming conflicts. It breaks if you define one singleton and use it, then later redefine a new singleton using the same name. Consider making a property rather than a method. Consider using "new-style" class syntax explicitly. 

This assumes they are in sorted order and there are no duplicates. If not sorted, add a call on beforehand. If there's duplicates, make it a beforehand. 

The function is just a function that frees ("deletes") dynamically allocated memory (memory that was requested from the runtime by a program when running). You will usually see it in conjunction with or (functions that request memory from the runtime). Think of it this way, functions like allow you to ask the operating system for some memory. You're free to do whatever you want with that memory for the lifetime of your program. When you're done with that memory, you'd use to give that memory back to the operating system. 

I'd use a format string instead. Any seasoned programmer will not find anything hard to read when using format strings. Though if you have multiple arguments for a multiple argument string (e.g., localization strings), it might be confusing with their orders or how much it requires, but they should be sufficiently documented anyway. It's a shame that the formatting features weren't a lot like python's. If you'd prefer not to use this approach for whatever reason, then I'm afraid you're catering to the wrong crowd for the wrong reasons IMHO. Alternatively, I know you said that you'd prefer not to use this but using would most likely be the fastest and most efficient of these approaches. There isn't anything to parse nor are there any intermediate strings you need to work with. You get your complete string in one shot. Now I've gotta admit, it isn't the prettiest of syntaxes and I too avoid them at times but there are ways to make it a bit more attractive. But at least the arguments should be immediately identifiable as they'd typically not be string constants but variables (which are highlighted differently in any decent IDE). First and foremost, your variable should always have the appropriate and descriptive names. This should be a given. Nothing kills readability as much as having crappy variable names, especially when you have a lot of them. And when dealing with large bodies of text, nothing's stopping you from moving that text into a separate method to encapsulate it. That way you can give your parameters better names when needed, you'd find the string all in one place and it isn't mixed in with your code as much. These could easily be tied in with your resource files to make it that much better. This also applies to with using the format strings as well. e.g., 

Other than that, you've made great use of the computed observables. A big mistake I see a lot on Stack Overflow IMHO is when I see people putting all that logic in the view. I might change the name of the properties however to be more descriptive of what they represent. In particular, change to . Personally, I'd change it around a bit. I'd add an "Other" option in the cars list and make the car input enabled/visible based on that value. Also, consider making not observable. If this is going to be a fixed list and you won't be dynamically adding to it, making it observable may be unnecessary. In fact, I'd pull that array out of the view model as it appears to be a constant value. That way if you have multiple view models instantiated in the future, they all can share the same instance. 

Converting back to the generic type won't be as straight forward. When casting between an and a value type, no conversions will be made and you are just boxing/unboxing the value. Since you have a constraint that the type be a value type, the casts won't really work here. In fact, I don't think it's even possible to do so generically. If a conversion exists from to the type you wouldn't be able to express that here. And you won't be able to use the Convert class to do the conversion, there's no way to "add" conversions to existing convertible types. Your best (and probably only) option would be to convert it to a variable and let the runtime figure out whether or not that conversion exists. That way if you have a custom here that has an implicit or explicit conversion from a , it will be used. 

My only real criticism is the variable names. Local variables or parameters should not be prefixed with an underscore. IMHO, it should only be allowed for private instance fields. So rather than using , it would be better off as (though I used for the name here instead). Parameter names are very much part of the documentation as well (especially so in C# and .NET in general). The method is called which suggests you provide a . The parameter name should reflect that. Call it since that's what it is. Personal preference but I also prefer to write out the full/reasonable-length variable names in queries. I reserve significantly shortened variable names (i.e., one character variable names) in lambda expressions. 

If you asked me, a pythonic solution would be the most readable solution. However in general, readable solutions are not always going to be the fastest. You can't have both, these are conflicting goals. Pedro has covered what changes you can do to make it bit more pythonic so I won't repeat that. I can't think of anything else you can do to optimize that any further. However if you want a more purely pythonic solution (IMO), you can do this. Use . It groups consecutive items together with a common key into groups. Group them by whether they are capitalized and filter out the non-capitalized words. This could be done as a one-liner but for readability, I'd write it like this: 

Make it general purpose using generics. Though I'd strongly suggest you rename your attribute to follow .NET guidelines. It should always be in the form . Enum values should be in CamelCase. And it is common to name classes containing extension methods to be named the same as the class it is extending followed by . Otherwise, that's pretty much how you'd get custom attributes of a field. 

The function is an integral function. It's arguments and return type should be integers, not doubles. By using floating-point arithmetic here, it is also probably not as fast as it should be. Also, your loop may start at , save yourself the iteration. :) There's no sense in making in your function a . They should be typed based on how you use it in this case so it is absolutely clear. It would also be a good idea to rename it as it is not a standard function (that only works for positive integer exponents). That assumes you're not intending to expose it for use outside your module. If so, you should probably make it as well (same for ). Also, the similar arguments with your function. There's no sense in making your loop variable a , it should be an integer anyway. With the above two fixes in place, you can easily fix this. Rather than looping through all the terms, alternating between positive and negative terms, it might be a good idea to help the compiler and processor out here and split these up as separate loops to remove the branches. That way the compiler could possibly unroll this better and you're not potentially confusing the branch predictors. Try it out like this: 

On a stylistic note, you should name your lambda parameters after the object they represent, not after what the entire lambda is supposed to represent. Judging by the names you chose in the method calls, you used for key, for element, and for value. These would be poor names and would be prone to confusion for other developers. In the call, I would name the lambda parameter either (or whatever is more appropriate) or simply as the parameter represents the that you are grouping. The call is operating on objects so I tend to use in that case. 

I would however not do your loop like that using a loop but instead use a loop. Then you wouldn't even need the increment statement there. 

Is there another way you could effectively count something within a range? I'm not sure how I can really explain this but consider this example: 

Your code looks fine. It certainly works. The only thing I'd say about it is that you are repeating the incrementation in all blocks. You could just move that out of and after them and you'll achieve the same thing. 

First of all, don't reuse variables to hold values that represent different things. That only makes your code even more confusing to read, especially if it spans many lines. You should declare a variable for each different use you have (a set of variables for today, tomorrow and after tomorrow). That might be a sign to move some code into a separate function in those cases. The query is the same all around, only the date ranges change so you should put them into a function to minimize repetition. I would write it like this: 

Looking at this at a much higher level, what are we doing here? We're adding up the sizes limiting each size by some factor (a maximum). Write your code to do that. This is how I'd write it: 

First let me point out that you shouldn't name this extension method as you have named: . The name already exists and will return the intersection of two collections. Your method is intersecting a collection of collections with each other. It should must be named differently. I would suggest or possibly . I feel your implementation for the case of a single collection is wrong. You are performing a set operation here. You need to ensure that for all cases, you maintain set semantics. You assume that for a single collection that you may return that collection. But what if that collection contains duplicates? You would need to filter out those duplicates. The aggregated version should as well. 

Consider renaming to something that would indicate it is a . I'd usually go with something like . You already did that for the constructor parameter and property, I don't know why you didn't do the same for the field. Your method should not ever throw exceptions. What would happen if you passed in something that was not a ? 

If you want to optimize for speed and possibly memory, just use regular loops to build up your dictionary, though it may hurt readability. The idea is simple, scan the string for keys and values simultaneously. Don't extract substrings until you know what you need. Scan each token until you hit a delimiter and add the corresponding keys and values to your dictionary. Assuming none of your keys or values do not contain any of your delimiters and everything is well formed and you have the same amount of values as you do keys for every string.