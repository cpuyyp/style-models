Given that you're encapsulating the integer implementation of the bit field, you should probably add a parameter to the constructor to allow the accessor methods to make sure the given is within bounds. 

It's been a long time since I played with NIO, and I never used it in a real project, but I'm pretty sure it provides facilities for efficiently copying between s. You can see I've added a byte count to each item. This is so you can know how many bytes to read from the file and advance the pointer. Second, let the I/O subsystem decide how best to order the seek/read/write steps by moving the read/write of the byte arrays outside synchronization. Since you've already serialized the object during , you know exactly how many bytes to read/write and advance the pointers. Now is maximally concurrent: 

Testability This implementation will make testing difficult. Moving the static local variable to a private static property would allow clearing it using reflection in a unit test. 

I have fully embraced Clean Code's goal of five-line methods, and my life of reading code has absolutely improved as a result. Right at the start I see this and am stumped: 

Given that works solely with files, you can drop from the public method names leaving and , assuming these aren't reserved in vba. It looks like the built-in automatically adds a newline unless you specify the new character position afterwards. If that's easy, e.g. without knowing how long the file currently is, it might be nice to add a method that does so. 

Double-checked locking is broken and must be avoided. The article explains the reasons in depth and provides several alternatives. In this case you can follow the advice in the "Making it work for static singletons" section by immediately initializing the static field. 

If you want to perform full file validation, I'd suggest extracting that functionality to a utility class. This is overkill in this instance, but it will give you more ideas on how to separate responsibilities so that each method does one thing and each class has a single responsibility. 

Allow the user to update the values on a form. Here another user may come along and do the same thing. Because there are two values, this could cause a problem. For example, user A fixes the person's name while user B fixes their age (both were incorrect). Without some form of locking, one of the updates would be overwritten. Store the new values and timestamp while checking the old timestamp. 

The only real problem I see is that the lists will grow unconstrained. Create a new list as a copy of the unacquired URLs. 

I'd go with Option #3: extract and to a new class whose sole responsibility is providing the expensive data. Whether it caches it and how should be up to the new class. This new class will look just like Option #2 but be separated from the existing class that needs the data. This provides encapsulation and increases testability. Update The ideal design that allows maximal flexibility must always be weighed against the current needs. If the former may give you 4 degrees of awesomeness but you only need 1 in the current application, you are probably better off going with a design that satisfies the latter until you need those extra features. Encapsulation doesn't need to be applied at the class level in every instance. You can apply it at the method level until you need something more complex. What would be more complex? One controller needs the data as a PHP model while another needs the JSON, but both may be required multiple times. In this case you'll get gains by caching each form separately. Now you'll want to separate the code to produce and transform the various data representations where the JSON producer can reuse the data-model producer. By making the JSON controller depend on the JSON producer alone, that producer is free to reuse the data-model producer, hit the database directly, or use test data provided in a fixture for unit tests. Now you're ready to separate all these concerns. Until then, however, a static variable hidden inside a controller method is sufficient for your needs while providing a basic level of encapsulation. In other words, go with Option #1 and call it a day. 

You are using a loop where a loop would be more obvious. As written, you have to scan the whole body to see that only gets incremented once at the end. Use this instead: 

The next step which I didn't implement in my Scala version is to model the intersections between every pair of groups. For example, imagine the only known numbers are 1 through 6 on the first row starting from the left. 

Combining this with the Null Object pattern would simplify others even further. Instead of storing in the root, left, or right child when there is no key stored there, store a shared instance of which implements most methods by doing nothing or returning . Since it doesn't store any data, it can be a static member of shared by all trees. 

The first part that updates the selected credit card has a lot of code duplication that could be made generic. 

If you really must have the first thread perform the initial loading rather than a separate thread that calls on its own, you can add back your beloved . This would be my last choice, however. 

You can gain a lot of readability by formatting the code (every decent editor will do a passable job at this with a single keystroke) and extracting several small functions (refactoring). I'll start with this but only extract the reusable functions. 

I haven't used MongoDB, but I have a few suggestions based on experiences with optimization and other databases. 

Alternate Forms Update: This section shows a couple variations of configuring service objects as compared with the above method of passing individual parameters to the constructor. For components with complex configuration you can either use a builder 

From my reading of the documentation, your code looks like it should handle parallel usage. Each list of URLs is owned by exactly one spliterator while they all share the thread-safe set of scraped URLs. If you're concerned about performance, you may want to switch to , but is sufficient for example code. I believe you can add two more characteristics: 

Worse, since the last two extend concrete classes they will need to pass special values to their superclass that will pass validation but not block the possibility of using real values. For example, would call . Here are my main questions, though please don't hesitate to throw out any suggestions you have. 

This version won't modify the original array passed to . How does this differ from writing your own loop using ? Mostly in style. You'll pay a minor performance penalty switching between system and user space (once for each call to the callback), but you won't notice this unless is huge. It looks much nicer when the callback returns an immediate expression instead of using one statement to modify and another to return. You can do this here using . In fact, this also allows you to refactor into a generic helper function. 

You'll have one implementation per type of segment you need to create, but it will make testing easier by splitting out the creation of segments from their parsing and the result that eventually gets built. Here's the new implementation for : 

The handler sets the virtue, issues a warning if the virtue is already set, and changes the scene text. It does not, however, handle changing the scene text if it was bypassed on the first attempt. I'll leave that to you. 

I enjoyed playing and won on my first attempt. I suppose that means I'm quite virtuous! :) Quick Tips 

If you have control over the implementation, I would prefer to move the constants and switch into it and add . 

And now for something completely different. You could completely bypass the question and simplify the API by employing two Null Objects: one each for an empty set of contacts and resources. 

has a lot of logic in it that may be better implemented using inheritance. There seem to be several possibilities: 

To avoid exposing the underlying map you could go further by using a closure (Java 8) or anonymous visitor class: 

As you found, the key is to reduce the number of buffer manipulations. You could reduce it further by inserting the remainder of the previous buffer into the beginning of the new chunk, assuming supports this operation and that doesn't already optimize this by keeping both buffers separate and bridging the gap in . I'm not familiar with any of these libraries so I won't attempt to code it up exactly. 

These small refactorings improve the readability only a little, but they don't alter it significantly. The real gains will require expanding the model and moving away from a single, static method. Starting Over If you're going to model the stations with classes to solve this, go all in and model the lines and entry/exit times properly to avoid confusion. 

Bug Be very careful when negating boolean expressions. will never pass because no value equals the string when it's negated. This should be to correct the operator precedence, but is clearer. Finally, the best way to see how it performs is to time it repeatedly and take the average. 

Now clearly the second method name is not correct because you don't end the game with the first miniboard win. But that's the beauty of extracting methods: incomprehensible code and possibly incorrect comments are replaced with easily-refactored method names. Mistakes in reading and coding are more readily apparent because they lie closer together. Doing that for every three-to-five lines of code allows you to delete all those incorrect and misleading comments while improving readability. Yes, the code might be a little longer, but it will be much faster to read and verify. 

Extract an abstract base class that implements the better-named interface by moving all code that's duplicated between and (all but the table and column names). This is a major step in the DRY direction that will simplify your code. I won't attempt to produce this code on my phone, but the key is for those concrete implementations to contain only unique code. The end result will be with a simple one-line constructor. Another improvement would be to decouple reading the table contents from picking random words by splitting these functions between that reads words from a database table into an array and that provides various ways to consume it, including choosing random words and subsets. 

You can create a helper method with a suggestive name that does the full check and use that in your clause. 

The enum class provides both a generic conversion method and specific methods for each modeled unit, e.g., . You could do something similar and still provide the third-party method if you want. Here's the implementation of : 

This design will allow moving the bulk of the algorithm into the model. You may not even need to model the lines themselves if you store the next stations in each station. 

A line segment is defined as the set of all points directly between two endpoints. It has a length equal to the distance between its endpoints. 

tracks unique word sets, one per word length. It maps word length to a set of unique words. Whenever a new word appears in 1 above, add it to the set. When it is seen again for the first time in 2, remove it. Next sort those entries by their keys (word length) in reverse and pull the first word from the first set. Note that you may end up with ties of same-length words. The standard set will return an undefined "first" word. That may be okay. 

The problem is that it now hides the logging inside a method that doesn't seem like it should log, and the method returns a success status which is less desirable to exceptions in my view. Starting over, another simple improvement would be to extract the full code between pairs of into a new method of the same class. Again you have three possible exits: continue processing normally if the job is marked completed okay, continue the loop early if it fails to be marked but rolls back, or exit the method entirely if it cannot be rolled back. Here's where specific exceptions as İnanç Gümüş recommended could help: 

All this would be done while reading the file and at the end while generating the final sentences to output. 

Check out Guava's helpers for some ideas, specifically . But first let's look at what you have in the first method: 

The Basics As you said, I think as each handler grows in size and the base handler adds more common features, the prototypes will pay off in spades. Honestly, the biggest readability issue for me is the require-and-instantiate style you're using. Is this common? I haven't seen it in any of the code for the tools I mentioned in my comment above. Compare 

This pattern can be difficult to understand outside of an application with many modes of operation. There are two advantages to using the factory patterns: you can swap in different implementations, and you can vary the construction parameters without changing client code. Where do these advantages shine? Testing! In the case of a game, randomness is a good example. When playing the game for real, you want your monsters to vary their behavior randomly. But when testing, you need to be able to choose from their possible behaviors. The real factory will initialize each monster with a real random number generator, but tests must be able to specify the behavior choices. Take this example monster action: