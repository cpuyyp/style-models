You can get at this concept very intuitively in strings before you ever get to arrays. Take a string like "hello world" and ask them a subtle-sounding point: does the string begin here: , or here: . They'll certainly be able to identify the correct answer. Then ask, "how far from the start of the string do we have to go to get to the 'h'? Answer in a number of characters. Do we have to move 5 characters away? 3? 1?" Again, they should be able to identify 0. Now, it's time for the big reveal. (My description here is in Java) "When I want to get at that first character, , I do it with . Given what we just discussed, why do you think I would use , and not ?" At this point, they will naturally move to the idea that it is at the beginning, and that we have moved no steps from the beginning. "Excellent. This is an example of an index value. And, in Java, when we do index values, we don't count from '1', we actually count the DISTANCE from the start. So, if we want the first character, we move no distance. And how far do we move to get the 3rd character? ..." When you later get to arrays, you can remind them of the concept, and just say that it is being used again here. 

Teaching about the existence of such tools is totally ethical. We need people who understand computer security, period. Mentioning the law is also almost self-apparently necessary. In my district, I am lucky, because I can get folks from the district IT staff to run the port scanner in front of my hacking class and discuss the results themselves. No one in my prior district would have allowed such an activity (or, for that matter, a hacking class in the first place). In situations where IT would not be as understanding, I would recommend discussing the tool, discussing the ramifications, and going to YouTube to find an example of someone using your tool of choice. 

Pointer arithmetic means changing the address you're looking at. The actual formula used to find the location of spot in an array (which shows why that first address needs to be : Therefore, indexing in arrays can be characterized as a distance from the start. Array items are packed together with no wasted space and no separators between the data. That, in fact, these are the only two tools that computers possess to locate themselves in memory: having items packed next to each other so that they can go from one item to the next, to the next, or saving pointers in memory so that we can go back to places later. Every other thing that computers do with memory can be reduced to one of these two actions. 

What follows are 16 short questions in a table. And just to give you a flavor for the kinds of questions asked, the first question is: 

We need tests that actually show what you really know, which is not always the same thing as what you can produce with prompting help from an IDE. 

What is important about this graph for our purposes is that it shows that this is a relatively new area of study. As far as I can tell, there are not yet, as of this time, studies about retrieval learning specifically within the realm of CS. However, there are few reasons to doubt that the strong results found in other fields would ultimately apply here as well, as the kind of mental modelling needed to attempt this sort of retrieval combines both big-picture and detailed understandings. 

Giving the same assessments from year to year causes fairly obvious problems. Cheating becomes more and more of a potential issue. Basic testing security dictates that we must create new assessments. However, generating new material has a few problems of its own: 

This is in line with a prior question I asked about teaching induction, but this is specific to the loop invariant step. I have not had great success helping my students see how to choose a loop invariant that will (1) always be correct (ie. actually be a loop invariant) and (2) create the structure that will allow them to actually prove that the algorithm in question will be able to behave correctly. My personal mental process is simply to look at the final item you are trying to prove, and figure out what property of the loop will mimic that statement. While this seems to work well enough as an idiosyncratic process for me, it does not translate into a clear thought-process for the students who don't 'get it' naturally. Does anyone have an idea about how to approach this with students to make it obvious? 

First, I dispute your statement that "the summative exam does nothing other than provide a coarse measure of the candidate's performance during the exam." Assessments are not merely chances for us to discover how the students are doing, they are also useful in the learning process itself. They provide a focus for study, and they provide vital motivators for memory retreival, and they provide the stakes that allow strong enough emotions to trigger memory. Now, as for your question itself, I have also particularly struggled with summative assessments, and I ultimately concluded that I did not really believe in the model, and could not administer strict summative assessments in good conscience. You've pinpointed the problem perfectly: once you've given a summative assessment, where do you go from there? Instead, I utilize a test-retest model for all assessments provided throughout the year. Every retest is provided with a lower maximum attainable grade. At my current institution, I have calibrated this at 6 points per makeup. (At a previous institution, I used 8 points.) This is not a deduction, it is a cap. So, earning a 65 on a first makeup will net you a 65, but earning a 98 will net you a 94. My goal is to encourage targeted study, so I do not allow for further makeup penalties. This means that the highest grade always wins, so you cannot lose points by taking a makeup. Now, I also create a practice quiz or test for every assessment. This approach certainly involves a lot of work on my part (as I am always making 3 versions for practice-test-retest, and sometimes have to create 4, or even 5, assessments), but I love the net results I get in my class. This system has virtually eliminated students falling seriously behind. I do have a rule that students who fall below a certain grade (a) must take a makeup, and (b) must check in with me or a pre-approved student (roughly a TA) before they are allowed to take it. This prevents the problem that some students have of simply taking makeup after makeup, with no appreciable improvement from one exam to the next. 

So, I am preparing to teach about P and NP for the first time. I know that I need to teach about Mapping Reducibility (aka One-to-One Reducibility). Can anyone recommend a set of algorithms that are easy to use to clearly illustrate the idea? The algorithms in this first brush with the topic don't, themselves, have to be NP - I just want to show a remapping that is extremely clear in order to impart the concept. 

I agree with Buffy that, if the goal is to actually understand functional programming, using a true functional language makes more sense. Get rid of the temptation to move back into imperative programming, or the odds your students have of really understanding this new mindset diminish considerably. You may want to take a look at the discussions over here. When I asked that question, I was unsure whether to use Haskell or Scheme, and the answers there (especially this one) ultimately led me to choose Scheme (DrRacket in particular). The idea of pedagogical sub-languages for distilling the key ideas was very persuasive. I think that this is a great way to get into functional programming. 

At this point, you can reveal, for those that hadn't figured it out yet, that all 3 of these bits of code were the same function. Ask them what made the later versions easier. They should be able to pinpoint the two problems pretty easily. Point out that loops can grow to be very, very large - hundreds, or even thousands of lines of code long. Ask them why the version of the loop would be especially problematic in longer code examples. Ask them where, in their opinion, would it be best in such long code for the coder to make clear when the loop will actually end. All of which brings us to the final principle: we want to be able to figure out, at least in 99.9% of the cases, the basic logic of what will cause a loop to terminate at the moment that the loop is declared, because otherwise, we are left hunting and guessing. 1 - Any time you mention the number of seconds along with the number of minutes, the kids suddenly feel time pressure. It's a very consistent trick to get the kids to focus on a short task. 

Develop a course in soft skills for developers. Include a full evaluation in order to address areas of weakness that you cannot reasonably cover in class (such as English), and spend the course time talking about the things that you can do. The advantage here is that students who sign up for the class will clearly want it. Keep incorporating the material into your regular coursework, but make some of it optional for students who want it. And, as already said, always pay very careful attention to setting the expectations of your students with clear communication. 

My school is BYOD (Bring Your Own Device). This has a lot of benefits in terms of technology, but it also gives us no control over what is on the laptops kids bring into class. During lab time, kids will often try to sneak in game playing. This year, I made a policy that, if I catch someone playing a video game during class, they will owe me a small project. This has reduced game playing quite a bit from my previous technique (which was just telling them to cut it out), but the problem persists. How do you prevent kids from playing games during lab periods and during lectures? 

I'm familiar with two schools of thinking for approaching an introductory level class in an object oriented language: objects-late, and objects-early. In objects-late, you teach various procedural aspects (variables, loops, boolean manipulations, etc) before you delve into objects at all, and then use objects as a way to organize larger chunks of code. In objects-early, you begin with the object-oriented paradigm, and then delve into method construction, and finally into the procedural aspects of coding that way. I truly don't understand this second approach or its merits. What are potential benefits of beginning with objects, and how can you structure the early parts of a course in order to even permit this? Important note I know that Buffy's answer (the one that I accepted) is quite long, but it is also one of the most comprehensive and insightful things I have ever read on StackExchange. If you are interested in this question, his answer, while long, is worth the time to read and absorb. Sometimes, life brings us unexpectedly beautiful things, and the best we can do is appreciate them and be grateful. 

The first step is for the students to design their own projects. I give them a timeframe, and make clear that they will be held accountable (within reason) for finishing the project. I don't just accept the project proposals blindly - there is a negotiation here. There's an odd twist to this step, actually: I often have to persuade the students to lower their sights a little bit, because they often have a poor sense of how long their grand idea will actually take. Any changes after my approval, however, must run through me. Every other Monday, the students and I negotiate/create biweekly mini-milestones. They know how many weeks they have to complete the entire project, and they then tell me what they feel they can get done within a week. It has to be highly specific (so that it can be evaluated), and both the students and I must feel that it would mark sufficient progress towards their overall project goal. (In my experience, I find that I simply accept their goals directly about 75% of the time, and in the remaining 25%, I have to steer students towards easier goals about as often as harder ones.) When the actual evaluation takes place, if they have met the goal, then they only need to tell me what they intend to accomplish for the next week. If they have not met their goal, then we have a more in-depth conversation to figure out how to recover so that the project still reaches completion. That's the mechanics of it. A few interesting takeaways: 

I am a strong advocate for code interviews. I make principles of style into about 50% of a lab grade (though I do permit kids to go back and refactor after an interview for full credit.) For some context, I discuss regularly that there are two audiences of code: computers, and people, and that these audiences have very different needs. Since my high school class is structured with lab periods, I will grade lab 1 during lab 2 work times (and so on). This gives me class time to get my interviews done. At the start, the code needs a lot of work. However, by the time we have arrived at lab 3, the kids are mostly creating crystal clear code. Don't drop that autograder! Even with code interviews, it is still tremendously useful. Having a good autograder means that, during the interview, I only need to look for style issues. I can assume that even the strangest of their code (and boy, is there ever strange code at the beginning!) produces the correct output. That permits the interview process to focus in, laser-like, on how well the student wrote for the second audience. 

I have been rewriting my unit on nested for loops for AP Computer Science (thus, we are using Java). I would like to use some sort of physical activity to drive home the differences between roughly these three ideas: Fully Un-nested