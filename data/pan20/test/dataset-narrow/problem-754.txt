looks for the last element in a list that satisfies a condition then returns that list up to that point (e.g. -> . (Note that it differs from , since will start at the beginning of the list and stops as soon as it encounters an element that does not satisfy the condition. My function starts at the end of the list and looks for the last element that satisfies the condition, regardless of whether there are elements before that that don't satisfy the condition, e.g. . This is useful to check a list of consecutive prime sums (e.g. ) and get the longest one that adds to a prime, for instance: 

These two checks give us the option to filter out StraightFlush, Flush and Straight. If it's neither a straight nor a flush, we need to look at grouping the ranks. Then we match the length of the list of similar ranks to find everything from to . The values are in this case the concatenation of the list of similar cards (e.g. rather than the ranks from high to low (e.g. ), to make sure the relevant values for the ranking (e.g. ) are compared first. A line is parsed by removing the spaces, then splitting (resulting in a tuple , which then mapped over by , and then the first value is compared to the second value, resulting in a boolean that is if player 1 wins the hand. This is then used as a filter to count the length of the list of hands in which player 1 wins. My implementation works perfectly and is very fast (100,000 lines in 10 sec in ghci, actual problem is instant), so I'm not necessarily looking for performance improvements; any kind of feedback is more than welcome. 

This is the highest consecutive prime sum that results in a prime number that you can get with prime numbers starting from 2 (2+3+5+7+11+13+17+19+23+29+31+37+41+43 = 281). To start from the next prime, you simply drop the first prime, and so forth, e.g. 

and enables us to remove the global variable and the unneccessary which would be in C++11 terms . Because we pass a reference we have to use to allow the template magic to find the right . Going forward, your classes and are redundant as well because there are std::condition_variable and std::mutex which do pretty much the same thing. Instead of and we use and (which describes their use cases and similarity better). To lock the mutex we use which works like your . A real difference is in because it takes the lock and not the mutex as a parameter . I know everyone (in C/C++) likes to implement their linked lists, but why bother when there is no real benefit. It takes more work, it increases cache misses because the objects are scattered in the memory and in your implementation it locks to this implementation without a reason. should just be a data structure regardless of the container it is put in. So I removed from it. To accomodate has to change as well. I decided to put a std::queue in it because it is exactly what we need. 

While I was at it I changed to a std::unique_ptr. I saw you used std::auto_ptr, do not use it, it is deprecated and will be removed in C++17. unique_ptr is not copy-constructible/-assignable therefore we have to move it into in and out of it in . A more drastic change is the wait logic. I could have used in a while loop but there is an overload of wait() which takes a predicate to check if waiting is over and it fits this perfectly. In your I created the using std::make_uniqe() which is the highly recommended way to create s. While I was at it I made it static because it removes the need to instantiate . Destroy all the things! Wait what?! Even though I wanted to show you all these neat ways which simplify your code in the end I deleted all your thread code and most of my changes because there is a simpler solution to your problem. You know that IO takes time and blocks so you thought of a way to make it asynchronous. The common approach, as you did, is to implement some kind of threadpool logic with workers and creators. But there is an alternative, std::async. It encapsulates the asynchronous logic and is required to act like if it was a . Most implementations problably use a threadpool so it is exactly what you did, just less work for you. I removed and changed (not being a thread anymore) 

If you were looking reduce the amount of code further, you could probably skip the whole dictionary part of this, and just compare the lists returned from the , by intersecting them and subtracting one list from the other. I just had to try :) 

I see no reason to have be a non-static class. You are not taking advantage of the fact that you are remembering the path and worksheet name, and you aren't keeping some sort of open connection to the workbook. And always feel free to make your code look more complex by removing variables that are only being used once (optional). There is no reason to this, because you are returning an anyway. 

As far as the methods you've created and are calling I see no problem with (as per your doubts). Functions calling functions is a good thing. Functions should pull all of their own weight, calling other functions when necessary, the coder shouldn't have to call those functions beforehand and pass in the parameters, unless of course there is a situation where you (the coder) do at times need to specify specific running values. Your main looks good, however as far as aesthetics of your code goes, I would add spaces between your operators and symbols... 

Note: This will work with your specific case... don't do this if you have with set values that contain gaps between values. 

If you don't want/need someone using your class, than encapsulate it. However I feel that you will at some point want to be able to re-use this excel reader, in which case I would move these methods into a Static . And your first class I would just make a method in your original program. 

I would suggest not blanket catching all . Catch exceptions you know are going to be thrown explicitly, you should also take preventative measures to make sure exceptions are not thrown. Also instead of completely closing down the application when this calculation fails, perhaps just show an error message on screen and continue. 

Something I want to add to the other answers. Normally in finance money is saved in cents, etc., i.e. an integer. 

This fits better because we don't have intervals. Moreover floating point arithmetic has its own problems which you can avoid when using s. 

So instead of using as a safe assumption for our threads I used hardware_concurrency() to ask the system how many cores it has/we can utilize. The constructor of is more generic than and takes the function as a parameter. being templated we can safely use a C++ function with arbitrary arguments which allows us to change to 

First of all, I really liked your C++ code and even though I am not a professional I think there are some points to consider. To the future! It is 2016 so I would say we can safely use C++11 today (at least if you are not held back by embedded, an ancient compiler, etc.). There being at least three major compilers with C++11 support this shoud not be a problem. I went through your code from top to bottom and the first thing was . It is good but we do not need it because there is std::thread 

The call to returns a std::future which gives a way to retrieve the return value of our operation. Moreover, it enables you to join the operation, if you want that or not. Because the destructor automatically joins the operation if it is not finished we have to keep the s around. One might want to clean these up, but this is left as an exercise for the reader ;) Going experimental Huh C++11/C++14 is not enough? How about the Filesystem TS which will someday (might be C++17) be in the standard. Nevertheless there are implementations in gcc (5.x+ I guess) and VS (2015) (clang says no work started) which you can use with . It has a clean and portable API to work with filesystems, even though I only used it in one place I think it is more descriptive. 

...saves 3 characters, and makes more logical sense. Also, instead of checking that index, it could be re-written to store the result, then only modify the 3rd indexed location and that. 

This lack of spacing is in other parts of the code, but I'm not going to point out everywhere. Aesthetically this block of code could be re-factored a few different ways. 

I realize this is complex, and the average person wont be able to read it. I use magic numbers, and I do some things specifically to keep the glory on 1 line. Feel free to bask in the presence of psychedelic code (which just wants to be your friend). 

You could just combine the logic into one statement, assuming there is not other things occurring during your if-else blocks and stuff. If there is, then this won't necessarily work for you, and you should post the real code, because a lot of times these problems are subjective to the code. I guess one lesson to possibly learn from this is just to realize the end result, and build a condition that matches the necessary conditions to do something. 

I've ran my code on talentbuddy, and I think their back-end is broken, because it says my test case fails from missing data (far down the line), and when I run the test on my machine with the same inputs it prints out the right amount and correct data, in 30-80 Milliseconds. SO IT WORKS. I am looking for a general review of my code and practices. Keep in mind that efficiency is key here. I've added useful comments to document the flow of the program (even though they make it look ugly) 

The most inefficient thing about your code though, and the reason it is taking so long to process is most likely your quadruple nested 

Now just use some linq to only grab results from the Combinations function where the sum of the numbers in the list equates to 0. Foreach of them, print it to the console. 

I'm making an app with a Flask API backend using a Flask-Peewee ORM and an AngularJS frontend. The Flask-Peewee ORM doesn't support token based authentication, so I decided to try to implement this myself. This is quite a bit beyond what I usually do, and I have in fact no idea whether this is secure or not. It does work, but that's all I know. Any feedback, from pointing out obvious security flaws to advice on good practices, is more than welcome. This is my implementation: Models I made an extra model for the api-key: 

If the user is not logged in, they will be taken to a login window (this app is for logged-in users only), that posts the username and password as follows: 

I defined a data type for the ranking, which is something like high card or flush. A HandValue is the combination of the ranking and the values of the cards related to the ranking + the kickers from high to low. For instance: . Note that even though I have an ace, the values that are relevant (i.e. the two pairs) come first. This allows to compare two HandValues with the same ranking (i.e. ). The instance for HandValue looks at the ranking first, and looks only at the values if the rankings are the same. To actually rate a hand, the suits and the ranks are separated, then: 

This is the highest consecutive prime sum that results in a prime number that you can get with prime numbers starting from 3. The rest is fairly obvious; it checks for each starting prime the greatest prime below 1,000,000, gets the length and the prime it adds up to, then gets the prime with the maximum length. Any advice is welcome, specifically on: 

Controllers I made controllers for logging in, logging out, and registration. These all return a response, which is then used by AngularJS. Basically, it creates an APIKey on succesful login and destroys all APIkeys related to the user on logout. 

In your code, you are getting the subsection of the extension, then removing it from the original. Instead you should simply just get the subsection of the string without the extension. 

They are practically the same. But now let me explain how this works a bit now. in .Net inherits from the class which has the Where() overloaded extension method from the Linq library. Using linq in combination with a lambda expression I was able to specify to the method exactly what values to give back. I specifically did this with some math involving the index of the item that was being iterated over internally. Suffice to say, the Where method loops over given list, and returns all values which meet the criteria given in that lambda expression. At the end I convert the to a to work like the data you had before. 

Over all, your program could look like this. Note: I didn't programatically address the issue of the user escaping your program, I noticed you updated your OP with that. 

Note: I used < Numbers.Length, this way if you ever increase the size of the array, you can support more numbers without having to re-write this part. 

You should give the user a way to close the program. While this isn't incredibly necessary for simple learning programs, it is a good habit to get into. You should avoid throwing exceptions, they break up your program's flow. Certainly use them where necessary, but this is not one of those places. Exceptions should be used in situations when your function doesn't have the ability to handle a situation/error. In the following snippet, I've declared the DateTime object, and a Boolean which will tell us if the string entered by the user was able to be parsed. Notice how I am calling the TryParse Method. The TryParse method takes in a string, and an . This is important, the out keyword is a bit more advanced than you have come accross. It is a keyword which implements functionality programmers were used to in C using pointers. Suffice to say that this function will set whatever object you pass in, to be the parsed value.