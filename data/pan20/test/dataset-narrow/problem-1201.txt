Googling "learning boolean function problem" from M. Alaggan says that BBB and BBB-F is at most NP-Hard and you can optimize the problem for certain inputs. 

Anything to do with Machine Learning has a lot of career prospects because you could be employed by either finance or technology companies in general. 

Currently bitcoin has a proof of work (PoW) system using SHA256. Other hash functions use a proof of work system use graphs, partial hash function inversion. Is it possible to use a Decision problem in Knot Theory such as Knot recognition and make it into a proof of work function? Also has anyone done this before? Also, when we have this Proof of Work function will it be more useful than what is being currently computed? 

What kinds of systems are available that accept a certain program $P$ and attempts to figure out "the program does terminate" or "the program does not terminate" and output a proof of one or the other? 

PSPACE proof attempt of Portal 2 by reduction from TQBF Application of section 2.2 of Gaming is a hard job, but someone has to do it! On portal 2. A direct proof of the statement: Given Portal 2 can you encode a TQBF in the game? We disallow portals in certain parts to simplify the proof since this is allowed in the game but, we will show that if all surfaces were white then this would allow you to bypass the proof. This either changes the topology of the graph or collapses quantifiers into being the same quantifier. 

--Begin amended algorithm-- Step 5 is due to @vzn answer: Add a visualization of local regions. Therefore we define a region as a set of points that are "close" due to some locality measure. Pagerank is an example so you have a pagerank of 2 you are in the region. 

I am old school and just use files and folders to organize everything. I have it in Dropbox and I share it with my professors or other students. I think using files and folders although it isn't very fancy but it works well. I have tried special organizers but never used them. 

If I arrange the disks into a spiral pattern then the problem is NP-hard. It may be even harder in your general case. This would be a variation on the polygon covering problem. See $URL$ 

A course I'm currently taking from Bill Gasarch is called: Ramsey Theory and Its 'Applications' -- the quotes are in the official course title. Interpret that as you wish. >_> Here is a link to the course website (with lecture notes): $URL$ Here is a link to Bill's "Apps of Ramsey Theory" page: $URL$ The latter link is very likely the most complete collection of information for the question you're asking. 

Here is a technical paper on the LMAX Architecture (I just followed a link found on the blog you linked here): $URL$ An example of a multicast graph is on page 9 of the PDF. There are also examples of multicast graphs (compared to various other options) here: $URL$ 

Very interesting thought! Here's an extended comment that was too long to post as such: Regarding the definition in (1) as such, that is: 

At SODA 2006, Martin Grohe and D$\acute{\rm a}$niel Marx's paper "Constraint solving via fractional edge covers" (ACM citation) showed that for the class of hypergraphs $H$ with bounded fractional hypertree width, CSP($H$) $\in PTIME$. Definitions, etc. For a great survey of standard tree decompositions and treewidth, see here (Thanks ahead of time, JeffE!). Let $H$ be a hypergraph. Then for a hypergraph $H$ and a mapping $\gamma : E(H) \rightarrow [0,\infty)$, $B(\gamma) = ${$v \in V(H) : \sum_{e \in V(H), v \in e} \gamma(e) \ge 1$}. Additionally, let weight($\gamma$) = $\sum_{e \in E}\gamma(e)$. Then a fractional hypertree decomposition of $H$ is a triple $(T, (B_t)_{t \in V(T)}, (\gamma_t)_{t \in V(T)})$, where: 

Addendum to below, clarifying the $k(k-1)$ terms: So, if you examine the terms in the expression, you can envision (as analogy) the $n-1 \choose k$ term is an enumeration of all binary strings containing $k$ 1's that have a 1 in the first position. In other words, we let each position in the binary string represent the choice of whether a given one of the $n$ cities in the problem are in the exact subset we are considering at the time. So, for 5 cities, 10101 corresponds to the subset {1,3,5}. Thus, to compute across all subsets of {1,...,$n$}, we simply count through each binary subset (i.e. count through binary strings) of size=2 (i.e. binary strings of size $n$ that contain two 1's), then size=3, then size=4, ...then size=n. (Note that the size=1 subset must contain only the first city, and thus it's irrelevant to compute its partial distance, since the distance from 1 -> all other cities in the subset -> 1 is exactly 0.) At each subset with $k$ cities, we have to consider up to $k-1$ candidate-optimal, partial paths. Specifically, the optimal, total path could conceivably traverse through the given subset and end up on any of the $k-1$ cities, excluding the first city. Then, for each such candidate sub-path, we compute the optimal tour up to that point as the minimum of any of the previous, size=$k-1$ sub-paths plus the distance from the terminal city for that sub-path to the terminal city for the current candidate sub-path. This gives $(k-1)(k-2)$ such comparisons that we must make. The discrepancy between my $(k-1)(k-2)$ term, and the $k(k-1)$ term in the analysis linked is a notational difference (I would sum over a different range, given my definition of $k$ than they did). At the very least, however, it should illustrate the quadratic-order complexity of that term. 

In the movie Inception Cobb asks a asks Ariadne to design a maze that takes twice as much time to design. This lends itself to a generalized problem where we have an situation where we are resource limited by some amount and whoever will verify that this problem is in the given complexity class that either will take more time and or space to solve. Is this a novel problem? 

If I wanted to define my own complexity class would you first define it as a set of problems with reductions to those problems? How would one go about doing this? 

Which corresponds to $3_1$ in the above table by Rolfesen. Now, lets see a trivial task. Once again using racket 

Below is a sketch of an algorithm I thought up. Specifically one that you can pan around and zoom? I thought of the following algorithm. 

Clause Satisfaction I model clause satisfaction by companion cubes. Assuming you can always move companion cubes between rooms if one companion cube is with you then the $or$ operation satisfies and you can pass. Note that each door is dependent on the next one if they are in a line in portal or if they are in one path. For the reverse operation on 2.a I allow you to portal backwards and have a piston allow you to go up. Removal of Portal Restriction If we allow for unrestricted portals and your portal simplifies the problem occurs then this removes quantifiers and sets the variable to be true. For 2.a and 2.b if there is the ability to shoot a portal past the door then you skip the quantifier. For 2.c if you allow successful portaling you skip the whole clause. Further work What does the physics engine do for computational complexity? 

Now lets see a knot table made up of mosaic knots: a knot mosaic is a type of representation of knots which use tiles instead of being strings in a three dimentional space. 

Are there any algorithms to draw a billion node graph or to aggregate the information? The idea would be to allow for it to be parallelized using map reduce so it could be done in realtime I was wondering if there were any other algorithms? A google search turned up nothing. Very large graph drawing I have found are as follows 

In addition to the above discussion, my motivation is an interest in exploring algorithmic options for LWE (of which we currently have relatively few to choose from). In particular, the only restriction known to provide good algorithms for the problem is related to the magnitude of the error terms. Here, the magnitude remains the same, but the range of error in each equation is now "monotone" in a certain way. (A final comment: I'm unaware of this formulation of the problem appearing in the literature; it appears to be original.) References: [1] Regev, Oded. "On Lattices, Learning with Errors, Random Linear Codes, and Cryptography," in JACM 2009 (originally at STOC 2005) (PDF) [2] Regev, Oded. "The Learning with Errors Problem," invited survey at CCC 2010 (PDF) [3] Arora, Sanjeev and Ge, Rong. "New Algorithms for Learning in Presence of Errors," at ICALP 2011 (PDF) 

Discussion: I've been spending some personal time lately learning various things in communication complexity. For instance, I've re-familiarized myself with the relevant chapter in Arora/Barak, started reading some papers, and ordered the book by Kushilevitz/Nisan. Intuitively, I want to contrast communication complexity with computational complexity. And in particular, I'm struck by the fact that computational complexity has developed into a rich theory of placing computational problems into complexity classes, some of which can be in turn (from one perspective, at least) envisioned in terms of complete problems for each given class. For instance, when explaining $NP$ to someone for the first time, it's hard to avoid comparisons to SAT or some other NP-complete problem. By comparison, I've never heard anything of an analogous concept for communication complexity classes. There are many examples that I'm aware of, of problems "complete for a theorem." For instance, as a general framework, the authors might describe a given communication problem $P$ and then prove that a related theorem $T$ holds $iff$ the communication problem can be solved in $X$ or less bits (for some $X$ that depends on the specific theorem/problem pair in question). The terminology used then in literature is that $P$ is "complete" for $T$. Further, there is a tantalizing line in the Arora/Barak communication complexity chapter draft (that seems to have been removed/tweaked in the final printing) that states "In general, one can consider communication protocols analogous to $NP$, $coNP$, $PH$ etc." However, I notice two important omissions: 

From $URL$ A knot mosaic is the representation of a knot on an n × n grid composed of 11 tiles here are them below. This is my starting point in asking you for a mosaic knot table with a set of restrictions. What I want to ask you is to give me a table with the following properties 

No there is no current system that does all four steps in your system. If you want to design a system one of the first requirements is homoiconic language. At minimum you would want your core programming language that you have as small as possible so that when you enter the system and start to make it interpret itself it will work. So therefore you want a metacircular interpreter which was pioneered in lisp. Other languages have done it also but there is a enormous amount of existing research on lisp. The first step if you want to do this is to have a homoiconic language like Lisp or some framework where you can reason about a running program. Lisp is used for this for the sole reason that you could define a metacircular interpreter in the language or you can just treat your code as data. Treating the code as data is the most important thing. There is along discussion about what homoiconic means on c2 wiki. For example in Lisp your "Program" datatype is valid lisp programs. You pass the lisp programs to an interpreter and it computes something. It gets rejected by the interpreter if you don't program a valid "Program". Therefore a homoiconic language does three of your requirements. You can even in lisp define the idea of a formal program. Can you model lisp inside lisp? Yes this is frequently done mainly as an exercise at the end of a lisp programming book to test your abilities. SICP At the current time issue four is a research question and below is what I have found that attempts to answer this question. I would say there are many types of programs that attempt to do this. Below is all of the programs that I know about. 

Description of each gadget I define a door as two tiles of deadly water that can't be jumped over. To unlock a door you place a block on it and the door unlocks. 

Addendum: Since considering the comments of others about coffee, I have discovered the wonders of a fresh cup of hot tea. :) Allow me amend this comment by saying:Try identifying the things that get you "in the mood" to work. It might be a cup of coffee, a cup of tea, the right type of music, or whatever. Some things will make you perform BETTER, some things will make you perform WORSE (coffee putting you on edge/giving you the jitters, the wrong type of music distracting you, etc). Importantly, these can be very personalized types of triggers, but it is DEFINITELY worthwhile to find the things that work for you! Practice discipline. Having a regular time set aside to work on research, and absolutely never missing it can work wonders. You can then consciously tweak the frequency and duration of these regular times to suit yourself. When you take breaks, make sure it's a full break. Some people are naturally better at this than others, but I believe it's important to find periodic times to completely forget about TCS/research/work/school/etc for a full day and go do something completely recreational. (Of course, do this in moderation, or you won't get anything done!) 

How interesting -- I just finished coding this exact algorithm up in C++ a few minutes ago. (So forgive the tangent from pure theory into a little practical discussion. :)) It costs $O(2^n n^2)$ time and $O(2^n n)$ space -- at least under my implementation. Practically speaking though, when your space requirements grow that fast, they become way more painful than the time requirements. For instance, on my PC (with 4 GB of RAM), I can solve instances with up to 24 cities -- any more than that, and I run out of memory. Of course, I could just be a bad programmer, and you might be able to do better than me in practice. :) Edit: A little more specifics on one detail of your question: The $k(k-1)$ term comes from the fact that you have to, in the worst case, calculate the partial, optimal distance from the previous subsets (there are at most $n$ of them; note that $k$ is summed over $n$ in the analysis you linked) to the current one. This requires, again in the worst case, $O(k)$ comparisons with subsets of size $k-1$ for a total of $O(k^2)$. Also, if my explanation wasn't clear enough, here are some nice lecture notes of Vazirani's (PDF). Scroll down to P. 188 for a discussion of TSP, including an analysis of Held-Karp.