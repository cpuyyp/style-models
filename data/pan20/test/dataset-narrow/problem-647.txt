Don't nest your conditions like this. Validate the input up front and fail out if need be. For example that might look like this: 

I do want to emphasize Magnus' second point as well and add a tangible example, in case you miss the meaning. Having a bunch of code in a closure in your callback is going to make testing extremely difficult. So instead of this: 

Do the and methods have any value outside the context of the function? If not, consider nesting them inside gather as "private" functions only in context of ; 

Even though you are using an adaptive encryption approach, you are not really doing anything to facilitate the "adaptive" part. Let's say this code has been working in an application for a year or two and you decide at some point that you want to increase your number of iterations from 10K to 20K, or change the underlying encryption algorithm, or any of the other settings. What happens when you verify a password against a hash made using old settings? Your code, as shown, could still handle the verification part in that the hash contains all the needed information for re-hashing the password being verified. This is a very common and reasonable way to be able to perform password verification. However, a password verification event is the only opportunity you have to update the stored hash to a new hash based on new default settings. As such, you may consider being able to trigger an update of the password hash to a new hash if the current hash settings are different than the ones for the stored hash that is being used for verification. Of course this logic doesn't need to exist in this specific module (it could exist outside this module higher up in application call stack), but it might mean that the function might need to be aware of current settings and trigger a callback to update password hash, or change the return such that caller gets indication that there is need to update hash upon successful verification of password in old hash format. 

Your class is wonky. It looks like you are trying to implement singleton pattern here, but it is not properly implemented. There is nothing here (i.e, private constructor or abstract class declaration) from preventing hundreds or thousands of copies of objects from being created in code, each with their own DB connection. At that point you do not have a singleton. If you truly want to use a singleton here (which I generally discourage as a pattern in favor of dependency injection), you need to prevent the class from being instantiated publicly, and you probably need to remove the method otherwise there is nothing stopping objects using this class from setting up and tearing down connections all throughout your code. The typical concept of the singleton is to provide a single authoritative source for a dependency throughout the entire life cycle of the script As it stands right now, this class adds no value vs. just direction instantiation of PDO objects. Don't but DB credentials in your code. This is a horrible practice. These should ideally be derived from configuration. Also some thoughts on variable naming in the class. is generic and doesn't hold much meaning. How about something like ? Your method doesn't really "connect" to the database (or at least it shouldn't other than the first time a PDO object is built_. It just provides a PDO instance, so maybe or similar might be more meaningful. 

Also, even though I don't think should be a class that is extended per above comments, I do want to note that should you have a case in the future where you build a base class like this that has no public properties, no public methods, and is clearly not intended to ever be instantiated, you really should make it an abstract class. 

I think this is a somewhat a matter of preference. What I try do to do when writing SQL in code context is adhere to the following guidelines: 

I guess I don't really see what value you are getting from these functions. Isn't the following in essence the same thing without ~100 extra lines of code that don't really do much other than provide some error handling. 

This seems an odd design choice considering you are working in a domain-specific tagging language. Why not have Wordpress code transform the post to HTML for you as it already does for your regular site? One of the unfortunate parts of the Wordpress architecture is that it does not cleanly decouple your data from your display concerns (as you are finding out). Since the Wordpress app "owns" translating the posts in the DB into HTML, why would't Wordpress still own this for your mobile view (perhaps via different template, even one that just contains HTML fragments for asynchronous delivery to mobile app). This will likely lead to less breakage as changes in your Wordpress site are made, as you would rely on the same view-generation logic. If you are truly trying to decouple your mobile app into a service, than perhaps you can work with the cached HTML that is generated by Wordpress vs. the actual database post entry? At least in this manner, you could work with DOM manipulation tools effectively to transform the HTML document (which is really your main problem here as your "caption" is not formatted as HTML). Even if you decide to forego these alternate approaches, I would say that your could go with a more optimized regex approach assuming that: 

You should always regenerate session id around authorization level changes (login, logout, escalation of privileges). I see no sign that this is happening here. 

You should consider using exact comparisons ( and ) as your default means for comparison as opposed to the loose comparisons you are doing. Loose comparisons tend to introduce bugs into code around unexpected truthy/falsey conditions. I find myself using them in only very specific cases where a truly loose comparison is warranted. 

This section of code looks REALLY problematic. You are, in essence, running against some arbitrary input file. Read documentation on and why it should be avoided at all costs. 

As I mentioned earlier accumulating these session files is like accumulating attack vectors, as you increase the opportunity for someone to execute a session hijacking or session fixation attack against your application. This coupled with the fact that you open the application to using session cookies over non-secure (HTTP) connection, means it would be trivial for a packet sniffer or man in the middle to grab a session ID from a legitimate user's request and use it FOREVER. And while destroying/regenerating session id's across IP change boundaries is a reasonable security measure, it is by no means enough. That attacker could be sitting in a Starbucks along with the legitimate user using a wifi network which has the same exact IP address. A sophisticated attacker can also easily spoof their IP address. Also, keep in mind that there are some legitimate use cases where a user might change IP address during a session (a user on a mobile device for example), so while, IP address can be used as one of the triggers for session invalidation, if you use some of the other takeaways about handling session securely, you might decide that it's importance as a criteria for session invalidation might not be worth a potentially bad user experiences if you had a high number of mobile users. 

Hmm... half my post went away :( I had also mentioned that you should look into naming your functions as a way to get away from the nesting that can be proliferated by anonymous functions. You could add named functions for handling you error and success logging/response formation. You could also add named functions to perform the callbacks, so as to flatten these callbacks out as well as provide re-use. Finally, I think you have some style problems: 

This isn't exactly optimized for your display loops (which do not require unique lookup capabilities by transaction id, category, etc. as are required to build this structure from the result set), but I don't think that it makes sense to reconfigure this structure for this simple use case. There is additionally some confusion on naming of family, categories, lines between the DB and what is being output to user. For example it seems in DB maps to for output which seem strange. You might consider aliasing your fields in your query to be able to use common terminology throughout both the section of code where you build the data structure and where you output it.