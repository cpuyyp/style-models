Now I have written my first program to test MCP4725. This is the first working version. It can set values of zero, one third, one quarter, one half, full scale etc. Next step is to add the read/write EEPROM part. My plan is to use the DAC to control the volume of an audio power amplifier PAM8610 

However, I very soon found OP's relay module spec a bit unusual. It says drive current at least 4mA Ib, to switch on PNP BJT Ic to drive the 55R coil at 90mA. This implies a DC current gain of 90/4 ~= 20. I found my first PNP to simulate OP's module is not suitable, because the Ic(sat) too big. So I replaced it by 2N5401 (see appendix below for a spec summary), which at Ib = 1mA, Ic = 50mA, hFE already is 50. In other words, this 2N5401 module input current of 1mA, 1/4 of OP's module, is enough to switch on the relay. So I cannot simulate OP's module of 4mA input, 2.4V+ relay switch off condition. Instead, I just tried to bias the PNP BJT to trigger at 1.0V+, which is high enough to entertain RPi's 0.6V- Low. And the trigger/activate deactivate band is around 0.2V-. I repeatedly verify that the trigger signal 0.2V to 1.0V will activate the relay and 1.0V to 2.4V (rpi's high So Rpi's High of 2.4V+ must be able to switch the relay off!. After manually tested the module using a 0~5V power supply unit to simulate Rpi/Arduino GPIO signals and found everything working as expected, the time has come to do the real thing: actually using Rpi GPIO signal instead of the 0~5v PSU, using an working python program. But to my surprise, the program does NOT work! The reason is that I forgot there is something called hysteresis. The relay switch hysteresis characteristic is as below. / to be continued, ... Why the set-GPIO-to-input trick can switch relay off 

I discovered I can use the keyboard combination CTRL+Alt+Fn (F1-F7) to switch between different virtual terminals. Only the first terminal (F1) will automatically login, so I can use different credentials on the others. However I don't think this is documented behaviour. I believe that service file should run on all virtual terminals and not just the first one, so if behaviour changes in the future then this guide for Arch might be relevant: 

Usually, no. As far as I know an LCD panel requires a driver chip or board to convert input signals for display, and many manufacturers/models use a different driver chip. Plus a linux-compatible software driver compiled for the RPi is needed to communicate with it. All this is possible but time-consuming and outside of my knowledge. I have had great success taking apart old portable TVs though (be careful of the high voltage parts) and using the screen + driver board on my RPi. If the driver board accepts HDMI input or RCA video then it's just a matter of making up a lead. Alternatively there are small LCD panels and even touchscreens available to buy online, which can interface with the RPi's DSI (Display Serial Interface) ribbon connector or I2C/GPIO pins. 

ULN2803 and especially UDN2981 are not so common. They have 8 channels and therefore have a bigger 18 pin DIP package size. For less channels, more common 74HC03/04 or 74HCT125 with 14 pin DIP package are more common and easier to handle.. 

I show below one similar relay module. I did the test without connecting to the rpi (especially not connected to the 5V pin on the RPi 40 pin socket. My module uses a different coil and NPN transistor instead of PNP. But I think the electrical characteristics should be very similar. 

Actually logic level shifting might not be the easist solution for you. You may consider throw away your BJT transistor input module and get photocoupler based module. Then you can keep you gpio pin signal at 3V3 logic level, and the 5V0 power at JD Vcc is strong enough to energize the coil. There are many advantages of using photocoupler. You might like to google to know more. 

Appendix C - Logical level converter using TXS0102 Now I know that Rpi GPIO can directly drive the relay module, but there are two problems. First, the GPIO signal with a long connecting wire is noisy, therefore not that reliable. Second, the flywheel diode 1N4148 might not completely suppress the coil back EMF, and if unluckily the 1N4148 breaks down, or not properly connected (poor contact, dry soldering joint etc), the back EMF might damage the Rpi. So I decided to use a logical level converter to shift up the Rpi GPIO signal from 3V3 to 5V. I first tried TXS102 converter and found it working well. Besides shifting up the GPIO siganl, the noise at the high level is also greatly reduced. 

tl;dr Can I override the auto-login feature sometimes, to log in as root? My Pi is running Raspbian Jessie and acting as a kiosk in a public location. For this reason I have renamed the user and removed privileges. To get auto-login working I used the command, boot options, CLI auto-login, to generate an autologin service file in and changed the username in that file. This works great. Normally I will use to remotely administer it, but in case of network failure I'd like the ability to log in locally. However even if I from the terminal it logs me right back in. Is there a way to override this and log in as root? 

Using Raspbian Jessie, when I try to output a short beep sound (approx 0.5s) through HDMI, the sound is somehow distorted. The first few 100ms of the audio is not played, or the audio is played too fast, or both. Sometimes it makes no sound at all. Symptoms can be reproduced with a sample WAV file: 

When I try with a long MP3 it works fine. When I add silence to the start and end of the beep file it also plays normally. Unfortunately the sound needs to be instant and short (as a touchscreen "tap" notification). What's causing this, and is there a fix? Edit: I also tried playing the beep through a web audio component using chromium-browser. The first beep is ignored, subsequent beeps seem to work fine. After a few minutes of no activity its silent again. Is an HDMI audio channel closing/opening somehow? Can I force it to remain open? 

Rpi has only one serial UART channel. So for 8 channels, you need to use software to config GPIO pins as UART. However, software UART on rpi/linux is not that reliable, even at low speed (9600baud). Or you can use 8 SC16IS750 modules for hobbyists (less than US$10 from eBay). SC16IS750 is a slave I2C-bus/SPI interface to a single-channel UART. 

Now I am trying to vary the IN to transistor base resistance from 220R to a higher value, hoping that now even Rpi GPIO High of 2.4V is high enough to turn off the relay. 

Below to be shortened or deleted # Appendices # # A1. Opto isolated / Photo coupler relay module board and schematic # Opto isolated relay module has a photo coupler which is 4 pin IC. The picture below shows a photoCoupler PC1 (with its 4 pins labelled 1, 2, 3, 4 in green) and a transistor Q1. The ICs are not always marked. In this picture, PC1 is EL354, and Q1 8050. 

I tried the HC04 output signal for the relay module in Low trigger mode (which requires sinking current, but not in High trigger mode (which requires sourcing current), . So I am going to add the HC04 hex NOT gate which can source current to the relay module. Appendix F - HC04 Level Converter Floating Input Problem Last time when I first tried the HC03 based level converter, on a photocoupler relay module, I found that if I left the input floating, the module picked up the noise and the relay switched on and off crazily. I thought the frequency was perhaps 1kHz. I was not sure if it was some sort of positive feedback oscillation. But when I used the scope to check out, I surprisingly found it was 50Hz! I guess it is some sort of resonance. But I don't know what is the difference between resonance and oscillation. Perhaps I should goggle again. Anyway, I think I need to add a pull up/down resistor somewhere. 

I'm using Plymouth boot splash on Raspbian Lite with great success, using this guide. By adding in it hides the blinking cursor during the boot sequence. Great! However now (of course) I don't have a blinking cursor when using local or SSH TTY. Is there a way to bring back the cursor once the system has completed booting? 

I found the solution in this thread. By adding (underlined cursor) or (block cursor) to my user's login script in TTY works again as normal. 

Maybe. A media centre and web server will operate fine together on any system, and this will be true for most combinations you can imagine. I'll run through my considerations when asking myself the same question... Conflicts Some media centres offer an HTTP-based remote control service which, when enabled, might try to use port 80 (which the web server will already be using) but this should be simple enough to change. Ports 81 or 8080 are common alternatives - the latter because it doesn't require root permission to acquire. Load / performance This depends how complex a website and how much traffic it will be expected to handle. A simple web server serving flat HTML files and assets uses hardly any processing power. Small websites can be cached in RAM reducing disk access. A Wordpress or Drupal site will require dependencies such as a database server, PHP server, caching layers and so on which need a lot of disk access, CPU time and potentially memory too. The media centre will also be heavy on disk access, and memory/CPU while you browse the UI, but most of the work will be done by the video decoder. Chances are the media centre is using an SQLite or similar database which you could share. Using a front-end cache or Cloudflare will reduce load also. Security Last but foremost in my mind. Is it acceptable to have your video and music collections on a server accessable from the Internet? Yes probably. In fact your media centre software will perform much better when connected. Be aware your Pi will receive undesirable attention, especially with a domain name pointing at it. Forward only the ports you require through your router, run a firewall, secure your SSH server, use only private/public keys for authentication and look up port knocking :) 

I think it is important to use the 2N2222 based logical level shift up and buffer to take the 10~20mA sinking current from the optocoupler. If Rpi GPIO is directly connected to the optocoupler, the 15mA current might damage the GPIO pin circuitry. Rpi-SainsmartRelay-Wiring My suggested wiring is as below. 

Use functions whenever possible. It is easy to convert functions to objects, but not the other way round. Do not use wiringPi for now. Python can just read and write to MCP with one write and one read I2C command. So wiring Pi is sort of over kill. I know python can use wiringPi. But I am not sure if Python wiring pi is 100% compatible with C++ wiringPi. So I think it is easy to first play with Python, then C++, then wiring Pi. Time for me to go to bed. Sorry for misspellings etc. See you tomorrow. ZZZ. 

Appendix E - Logical level converter using HC04 HCT125 is not so common. So I tried one more converter circuit, using HC03 quad open drain NAND gate and HC04 hex inverter. When I tested the HC04 output, I found it very noisy. I guessed one reason was that I was using dirrerent power supplies, one for rpi, another for the converter. Even I connected the ground points of the power supplies to make a common point, the noise did not go away. I then used one power supply for both rpi and converter, and the noise disappeared.