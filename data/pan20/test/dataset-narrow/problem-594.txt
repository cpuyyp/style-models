The syntax for specifying multi-dimensional types in C++ is messy. For example, to specify a two-dimensional , one has to write . The syntax doesn't scale. So, I wrote a handy tool that provides easy syntax for this. Any kinds of comments are welcome ^_^ (original version of the code can be found here with unit test code here) 

Binary heap construction and maintenance boil down to the two basic operations: sift up and sift down. Following are generic template implementations of the two operations. Any comments are welcome. I'm preparing for an interview, and I hope my code will appeal to the interviewer :-) 

and both have move constructors. I try to avoid writing each factory from scratch with CRTP. The code is also at github. Thanks. Result: 

I want to make factories that can chained together to create a pile of layers. One of the advantage of chained factories is that later factories can pass specifications to earlier factories. For example, if I want to make a tree on top of an array, I wouldn't know the correct size of the array until I know the size of the tree. In the code I posted for review, the bottom layer of any pile must be an (or any other class of memory layer in the actual library). can only be the lowest layer in a pile. Here is an example of chaining the factories. 

I was recently given a Sudoku Puzzle to solve, and since I began solving many Sudoku puzzles after, I decided to attempt to create a Sudoku Puzzle viewer with JavaFX. I am not done yet, but have decided to split it into parts so that it is easier to fix future problems. Part 1 is the class. The class does: 

The second line is only two-spaced. Make sure that your spacing is consistent through your code. Don't import the whole package: 

Though, as mentioned in the Bugs section, it doesn't really work. In Hmm... Here you don't do ... Also, here: 

I don't intend to faithfully follow the interface specified by the standard/draft, because it's too cumbersome. Specifically, I didn't implement some methods and modified the signature of some others. Refining memory order requirements is left to future work. 

Following is my solution for your reference. It's much less code, and I think it's functionally equivalent to yours. 

Sometimes, we create a one-dimensional object, but want to access it in a multi-dimensional way. For example, you can access an array object in a 2x2x2 way. So, I made a class template to make this easy. Any comments are welcome~ Original code can be found here and documentation here. 

where n is how many false you have. generates a number between 1 and n, and checks if it is one. It has a 1 in chance of returning true, just like what you have. This increases the efficiency and is much less of a pain to type. 

Naming should be : names are concise names that shouldn't be abbreviated. could just be . I know you are using a , but is a more readable name. Final Code: 

It is often bad practice to catch every single exception in one catch block, especially if the exceptions can be predicted. In this case, we have and . First, we can identify where and why these exceptions can be thrown, and if they can be prevented. The can be thrown on the first line of your block because can be . You can prevent this by doing: 

Can write functions that only accept instantiation of a node template. This is enabled by and traits in the library. 

Each node is a location within a layer. A may be a pointer or an index. A is a container. There are 4 types of node per and types: 

Is the design ok? How to make the api more convenient? The the google tests and the code are at $URL$ demo_complete_tree_traversal: 

This is a random access iterator that stores an index and a reference to a container. It iterates over any container with indexing operation. It does not have copy assignment / move assignment operations. This is because I cannot re-assign the reference to a container to reference to another container. The iterator stores a reference instead of a pointer to the original container. If the iterator stores a pointer instead of reference to the container, will that affect performance? The inherits from the because I want implicit conversion from the non-const to const iterator even during template instantiation. The code and google tests are also at: $URL$ Thanks for reviewing this. Code: 

This looks confusing to me. return the title, which is understandable, but returns the old title and sets the title to the argument. What? I would rename the first methods to and the other to . Also, consider adding . This is the same with: 

It's really just performance. There's gotta be a better way to do this, but I can't think of a single way. 

How many warnings do you have? ANY of them means bad code. In this case, some of your variables are unused. Remove them. 

Of course I didn't include the numbers in the description... I am sure there is a better way to do this. I just did a simple solution, where I add all the numbers and take the first 10 digits. 

I made a tool set to facilitate bit manipulation as follows. Any comments are welcome, be it about the interface design, the implementation, or even the naming. Also, I want to make sure that the tool set is not lacking something for use-cases I failed to catch :-) Original code and unit tests can be found here and here. 

I'm trying to write a lock-free implementation for atomic shared pointer. Basically, there are two class templates and , each implemented in a header file of its own, for a total of two header files. The algorithm is inspired by the split reference counts idea used to implement a lock-free stack in C++ Concurrency in Action Sect. 7.2.4. This is my first time designing and writing lock-free algorithms, and I'm not confident. I want to have my code reviewed for possible flaws in the algorithm (quite likely ~>_<~) and room for improvement. Note that 

This way, programmers using it has a choice of being able to give less information, and add it later through the methods. Also, this allows them to prevent them from doing stuff like: 

Put spaces after the commas; this will make it easier to read. Naming Usually, setters' method names begin with . It is also suggested that it is so. should be . Immutable Class Suggestions 

Now let's do some actual reviewing... OOP Java is an Object Oriented Programming (OOP) language, which means it's based on objects. You did a good job trying, but if you leave a default constructor and let the calling code do the work, it's not OOP at all. Let's do some serious redesigning: 

Overview The following is a type system of layers (, , , ) and nodes for a library. A version that prints colored text for debugging is on github. Thanks in advance for reviewing this. 

a heap layer with a template parameter for selecting key from the content A hash layer for keeping track of items inserted into the tree. 

I implement a complete tree as a layer for adding a hash, heap, and other things on top of it. The Complete_tree_node templates can be reused regardless of the number of layers added to the tree. This tree layer helps to hide the memory organization of the nodes from the algorithms. Currently, the uses an array to hold the content of the nodes. Constructing the tree is kind of tedious because the tree does not own the data. I want to offer the option of the tree owning or not owning the data later... Currently, the operations do not accept rvalue. So things like doesn't work. The template parameter is log2(). Currently c++11 can build this but I don't mind using c++14. The next step is to write: 

Again, should be and should be . This is the same with and . I also see some poor naming. For example: 

At first glance, this makes no sense. These numbers are more like magic numbers: make them a constant: 

Since I don't have a C# compiler (sorry), so I converted both programs into Java in order to test. First Code: Average speed: 80000- 90000 nanoseconds Review: 

Note that this is not the final result. There are a lot more to add before it's good. Now to the actual code... First of all... In the main method, there is this: