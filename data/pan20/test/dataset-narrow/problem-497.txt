I don't like the concept that you have to chain the -calls for every property you want to modify in the copy process because you create a new instance for each call. A simple non-generic solution could be to use the and named parameters: 

When testing the algorithm against other implementations it seems to work as expected and without a thorough knowledge about calendars it is hard to comment on the details of the algorithm as is. From a computational or mathematical point of view it is possible to simplify or make the formulas a little clearer by removing unnecessary parenthesis and just rely on operator precedence: 

Writing something consecutively to the console is of very little value. OK, returns a list of primes, but you really can't use them until all primes are calculated in the domain of , and that's a lot. For instance, it is useless to write 

In contrast to radarbob I find a StringBuilder very useful in this context. Your code produces something like this: SELECT * FROM rw_db.v_sys_users WHERE 1 = 1 AND = @status AND((user_empid LIKE @param1 OR user_firstname LIKE @param1 OR user_lastname LIKE @param1 OR user_username LIKE @param1 ) AND(user_empid LIKE @param2 OR user_firstname LIKE @param2 OR user_lastname LIKE @param2 OR user_username LIKE @param2 ) AND(user_empid LIKE @param3 OR user_firstname LIKE @param3 OR user_lastname LIKE @param3 OR user_username LIKE @param3 ) ) which looks ok to me (except for 1 = 1 :-), but are you sure you want AND between the OR-sequences? I would say OR was a better choise. Below find my rainy sunday afternoon version with some inline comments: 

The explicit is ugly, but neccessary to not result in type casting, which is even more ugly, it is a limitation of the current type interference. It might be only an issue in IDE's and the javac compiler might actually compile it though. The usage of is pretty bloated, but our most reasonable option, besides creating a class ourselves and using . This will hopefully be easier if Java 9 includes tuples (which logically include pairs) as more or less first-class citizens. In the whole method we end up storing all the entries in memory once, with the , I am pretty sure there are ways around that, but not worth the effort here, only optimize this if it becomes a real bottleneck. I was hoping to use the method when processing the results, however this is not possible with the requirement that you want to have a counter. Again, more possibilities open up in Java 9 when we hopefully have s and tuples. 

I'm not familiar with Ruby, so I will write a no-code answer here, discussing what you could change. I am assuming that , etc. all extend a class, where extending is an OOP-definition here. Then you should make a method that takes the as input, and then calls something along the lines of: 

This is my first SQL post over here, and in fact, I have more or less the experience of a regular SQL programmer, except that the task at hand this time was way harder than normal. I am expecting, hoping and almost demanding a better version of my code, because my version is really bad, but I do not know how to make it better. My biggest gripe is that SQL does not know of the concept of Set, Array or List in traditional sense. I'm using MariaDB 5.5, which is a superset of MySQL 5.5, as far as I know I have not used any MariaDB-specific features. The task at hand, also visible at $URL$ With data: 

I assume that does not return a possible duplicate url-friendly title or else you maybe are positively redirecting to "Index" having a duplicate url-friendly title set on the model because is not checked for duplication before returning. 

If you've showed the environment the function is used in, the review could be more useful, but I think your reasoning is right, except that Lazy is used to defer instantiation and you actually use the lazy-created object () the first time it is called for by returning DataCache[key].Value. Therefore Lazy is of little use in this context as its object is instantiated at the same time as the Lazy. IMO your DataCache would give more meaning if you up front filled it with all possible queries without actually using them and then call them as needed. Alternatively you could just cache the queries directly in the DataCache without Lazy. 

It will make the function much faster. The - function is not tail-recursive, but can easily be changed to be: 

The properties of the Book class should be read only (or private setable) as the title etc. of a book will and should never change. I think Remove is a better word than Delete. I don't like the way the ExitCommand terminates the program, because the application has no way to do clean up. You do not check for a negative input value in the command selection loop. You should be more careful and distinct about how you name your variables etc. Stick to one convention for cases etc. 

This filters out a huge number of users who would otherwise be loaded from the database needlessly. Your if/else aren't actually correct, since your intent is to load all users with . You load all users, and then your looks for , but your doesn't. It affects all users with of or , and then sets their to false. 

If I were working on this code, I would refactor it in the following way to take advantage of the above few points: 

This also means you may safely access and from any other method, and not have to duplicate the initialization logic. 

There is really quite a lot wrong here. As a very simple improvement, why aren't you using ActiveRecord's associations? Why do you constantly do this... 

Yes, it's too complex. Make the elements relate to each other, so that you can use a single event handler. This is the typical pattern used to link two DOM elements together, so that one can hide/show/otherwise interact with the other. 

Either initialize the variables in your class's constructor or define accessor methods to isolate the initialization logic for each variable: 

Err, no, that's not at all what that tells you. Nothing has "an ActiveRecord" assigned to it, that isn't at all how ActiveRecord works. Every record in the database is wrapped in an ActiveRecord object as you read it from the database, it's impossible for some users to "have" ActiveRecords and others not to. See point 3. Your currently checks all records, including those with , and presumably those records don't have a set. It's really not clear what you're trying to do with . What is "1"? You have no unit, so it means "1 second". Your probably never going to hit that. 

Beside that I would change the flag to an too, because you can then distinguish between more levels like: 

I would let PDF.WrongPasswordException (because you don't have a choise) be the only exception to catch in this method, because all other exceptions have nothing to do with its Purpose (to check for password). If the file it self is missing or invalid, then you really can't tell if the file has a password or not and therefore returning false doesn't give the client valid information. If the IO exception instead is left to the client to respond to, he can react appropriately. 

This will cause your algorithm to check 39996 numbers (= column heights) for no reason. So a minor change in your code could make it a lot more efficient, although it isn't still a very efficient approach: 

In this way the first permutation is returned as soon as it has been computed and everything is running more smoothly. 

In general it looks OK to me, but you could maybe consider the following: 1) Return a instead of and then yield the positive results when found: 

Here the groups found so far are given as argument to the function and finally returned as the first part of the resulting tuple (with the remaining items as the last). Yet another aspect to consider is performance... 

There are a couple of simple errors: 1) In you replace the next line with the second part of the split instead of inserting it after the first part: 

What I did here, was passing in an , which really is nothing more than a function that converts an to an , a compatible signature would be any lambda of the form , which is where I used a method reference like , which is in its turn a shorthand for , which is a shorthand for . Note however that you now cannot change the calculations for the attack respectively defense attribute anymore, hence that would need to be configurable as well in some way. I'll update the answer when I have found a way to do so. 

I've been interested in writing something meaningful in C++ for a long time, yet I had a hard time not picking Java or C# for a new project... Now I've found something for which C++ seems to be the right tool: Writing a Database Management System. I'm going to show you the code for the first step: Storing databases. The code is written in Microsoft Visual C++ 17 and I'm trying to have code that is as modern as possible. I also didn't intend to build a serialization library, it just happened. This library exports its methods through a DLL. 

The others have already posted out most points, so I'll briefly recap my opinion on them and provide an easier example: 

I agree mostly with @Vogel612's answer, the second version is more concise and there is no need to litter variables all over the place as is done in the first version. Another point is that code should be self-documenting, which @Vogel612 also suggests, but else you can still add a comment behind the code lines. My review I wanted to talk about a more interesting point, as this question seems to be a subproblem of a bigger question of yours, which involves creating a high throughput program that does something with tweets. Perhaps this is a premature optimization given that I do not know how well your program performs, but your program may very well hit a threshold limit because of the way you handle regexes. You should consider what a does: 

You also do some weird things in with instance vairables. Your methods all seem to both return a value, and assign that same value to an instance vairable that is never used. There is no reason to do this: 

Never in the real world. That loads your entire table into memory and instantiates ActiveRecord models for every record. You want , which uses to load 1000 records at a time. Don't do simple filtering in Ruby, do it in the database. This... 

That alone would drastically improve the readability of your code. You can also make the loop in your action more idiomatic: 

A completely different approach would be to map each 's categories into a new hash, and then merge the resulting hashes. The problem is that you need a "deep" merge, like the one that comes with ActiveSupport: 

Second, you query Weights all over the place, over and over. You constantly go through the effort of typing out instead of just doing it once and reusing the returned set of weights. You even make multiple calculators for absolutely no reason, and inside the calculator you don't even reuse ! Just do things once, there is no reason to continually run the same queries over and over, even if they are being cached by ActiveRecord. 

Your index action is also pretty broken. First, You try to access to pass it to your before you set it, and then later you set it to , which returns an association, not a specific profile. Again, using associations, you probably just want