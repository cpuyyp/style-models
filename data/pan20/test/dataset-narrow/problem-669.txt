What Tom Lee said was great (and I'd upvote if I could), but I'd like to add a few misc remarks. On the constness of the method: without more knowledge of what you're trying to implement, I'd vote against it. The reason here is that your delegate reacts to an event, without returning any new computed value (as indicated by the return type); this would tend to indicate that the only way the delegate could do anything useful would be either by modifying itself or by having "external" side effects. The const restriction forces your delegates to only actively react to an event with external side effects. Of course, removing the const qualifier won't magically forbid you to make side effects, but it might remove the need for them. (Hope that's clear enough.) On the same topic, I don't see why you intend to pass as a const ref to ? The method modifies the Foo instance, maybe not programatically, but at least semantically: it'd be way more correct IMHO to have a non-const ref given to the method. As for trigger / add / remove, it seems to me you wouldn't need a friend declaration if publicly inherited from and were protected: it would publicly expose and , and you'd be able to call only from Foo methods, which is what you aim to do if I'm not mistaken? Did I miss something? Some design remarks concerning method. Is there a need for it to have a parameter? Wouldn't it be better to just give it a ? Another thing that bothers me is why you chose to put a registration method in the delegate object at all: you already have a registration method, which is . By adding StartListening, you make Bar "aware" of (or at least of ), which it doesn't need: theoretically, should and could work with any , not just with (just like works with any delegate, not just , which it doesn't know). That's why I'd move the registration call out of Bar and make the "link" at an upper level. My tuppence worth, hope that helps! 

It is not just the safety of your code that you should be worried about. You need a holistic approach; your question suggests to me that you have not looked at the bigger picture. Read this article and you will see you need to approach your question differently. For one, it depends on your server's configuration. Depending on how important the security requirements are for you, I'd suggest using a third party service; either one which takes the problem off your hands entirely, or if that's not an option, have a consultant guide you to making a setup that will stay secure even over time while code changes and cracks can slip through unnoticed. There are some services that can try to find holes in your system, but they are only of limited use. If you need a better answer than this, I think you're going to have to give a lot more info on the context of your code; where it's used, how it's used, etc. 

In general I like that you didn't try and force OO on something that works very well without it, but it would be simpler, cleaner if you were to just put all those functions in a namespace instead of a class (IIRC the metadata-generating macros for enums work outside classes, too). you can use global static functions or anonymous namespaces in your .cpp file for the private stuff. And also, it is very nice that you don't try to handle I/O and some other stuff that library writers are so keen on doing. SRP all the way, it's great :) Error handling There is one thing I don't particularly like about your code: 

It's important to note that it doesn't matter from the viewpoint of asymptotic complexity if you are doing an O(n) comparison here, since the O(n^2) later will dominate the complexity anyway. But for amortized complexity it matters, and that is important if you are dealing with small inputs. 

There is a PHP function specifically for filtering input. Funny enough, it's called You would use it like so: 

The first stage involves reading the string, parsing it from beginning to end, recording the logical aspects of what exists. The second stage involves manipulating the logical record that represents the tokens, transforming it from a representation of what exists, to a representation of what string manipulations are required. The third stage is executing the string manipulation. 

I would split up the code into objects, with good object oriented patterns. This should result in objects that have very distinct responsibilities. The pattern I think you should primarily look into is the "Proxy" pattern (See "Design Patterns" book by "Gang of four".) It can be used to extract the code that ensures security, for example. It makes the security code independent from the domain logic / data access / user interface. It may mean refactoring a lot of code, but once done, you can then write thorough unit-tests for the security proxy in isolation, giving you a rock solid foundation. Write tests, then write the testable code, (i.e. isolated) then refactor to the point where it's neat and tidy. 

The goal is to have fields in a class which are optional and can be determined if they are set in order to be able to leave them out of serialization. 

I can tell by your coding style that you try to follow the Qt coding guidelines, which is fantastic for a Qt library, but this kind of error handling is not particularly useful. You should stick to the / etc. kind of error reporting, since Q_ASSERT does that anyway (they can be redirected from external code, without modifying your library if your user wants to). Or even: use exceptions - Qt is huge, so avoiding exceptions does result in a great size reduction for them, but your little library would not suffer that much. The problem with the current approach is that it limits the caller to one way of handling the error: presenting the (by the way not localized) string to the user. Possible improvements There is some unneeded duplication, for example and looks quite similar, and I noticed other parts, too. Consistency in style: it's pretty good, and again, props for sticking to the Qt guidleines. One thing I noticed though, is that you use parentheses around case labels (which is alright, if somewhat alien to me personally), but you forget it in some places. Other 

This gives you a reliably clean way of doing what you want; no regex to get wrong, no ambiguous code (since does what it says on the tin), and an easy way to tell whether the key didn't exist and if the sanitization failed. It leaves nothing to chance. With the above conditionals, you can be sure that you get an int when you think you'll get an int, and that you'll know when you didn't get an int. When you want to sanitise for things other than an , or when you want to perform validation on email addresses and so on, this function takes all the hard work and error-prone code out of it. (No more regex! Woohoo!) It's a recent addition to PHP5 (PHP 5 >= 5.2.0, PHP 7), so it's not yet well known, but it's been added because there are all too many ways of trying to solve this problem, and even for those programmers that write comprehensive unit tests, there are always gotcha's which can leave security holes. PHP now has our back with this function; experts have written that function and tested it to death to fill the need. You should check out that page's "See Also" section for related functions that can be used to sanitise arrays of input etc.