If you look at the Pi kernel source -- it is distinct from the mainline "vanilla" kernel -- on github, you can see by the top level Makefile the current stable is 4.14.41. The most frequent change in that Makefile is the version number, so if you look at its commit history you can find the first commit using 4.14.34. To find the latest release for that version, start with the next one (4.14.35), "Browse files", and click through "releases" at the top. The latest one will actually be for 4.14.34 (since this is the first commit for 4.14.35, which at that point has no release version -- note not all versions have releases either), and if you follow the commit index (a six digit hex value next to the .zip and .tar.gz options), you can "Browse files" again to get to the top of the tree, from April 16th, and double check the Makefile (it is 4.14.34). $URL$ That's the source you want to use. You should then run to get the v7+ configuration. 

If the manufacturer only distributes binary drivers for x86(-64) then you are out of luck. Either they have an ARM driver for linux or they don't -- evidently they do not. Manufacturers often do not release source code for drivers, meaning somebody would need to reverse engineer this. 

This is because the pi doesn't have a clock. It gets its time from the network. When it first boots, it has no network connection, so it either uses the unix epoch or else a stamp from when the system shut down. If this is a reboot, that will probably be sometime < 1 minute ago. Once the internet is accessible, the correct time can be acquired and the clock is immediately updated; this will cause to system time to jump forward. A simple way to deal with this would be to just wait a period of time at boot to avoid the issue. Rather than starting it directly, use a shell wrapper like this: 

Yes: If you follow this path you will be begging and pleading to "drag" a keyboard from room to room instead within a few hours. Put another way, it may not be impossible, but it is going to require much more effort, not less. 

Should work, although I am not an arch user and do not know any potential caveats about their configuration. However, you will still need something other than a display manager listed in your xinitrc. 

I suspect your problem here is the Hifiberry and LCD board are both intended to fit over the GPIOs "hat" style. If the Hifiberry has a breakout on top, you should be able to put the LCD on that and use it without problems. As per the Adafruit page, that board only uses the I2C bus (plus power, presumably), and this can support multiple devices as long as they use different addresses (you can check that with ). If it doesn't, you could use a stacking header with the LCD board and put the Hifiberry over that. Otherwise, you will have to somehow attach the I2C and power pins to the LCD (I would guess the LCD is 5V, and probably doesn't also require 3.3V) without blocking the pins in order to attach the Hifiberry. Or you could do it the other way around if you can find out what pins the Hifiberry needs, although I suspect this will be more awkward because it probably needs more than just two. Also, if you separate the LCD, you could mount it on top/though a case, leaving the Hifiberry attached to the Pi inside. 

This is probably a daunting task if you've never worked with a datasheet or coding for SPI before, because you need to learn the latter in the context of the former. There's no way to work your way up from a generic "hello world" here. You either get the device to work or you don't. However, you can still at first focus on the simplest stand-alone verifiable task conceivable and forget everything else. I don't know what that is in this case -- I don't have one of these devices, or any ADC experience, or any SPI experience, but bare with me anyway. I did learn I2C in C++ starting with an Adafruit assembled gizmo, the chip datasheet, and their python library. I don't think this is too far removed from that. You are likely better off approaching this from the ground up, rather than viewing that lib as something you're going to "adapt". However, having it as a reference point will be very useful, particularly as it seems well documented and refers explicitly to the datasheet. You probably won't be able to lift much code directly from it unless you mimic the API very closely -- in which case that would be toward the end, once the appropriate pieces are in place, and not in the beginning. I would not worry about understanding the details of the I2C interface. It is not complex and should be transparent enough to follow in relation to how the datasheet specs are used in the library. Start by learning about SPI in the abstract from a high level -- that is, not how it is implemented, how timing and synchronization works on the wires, etc., but how the protocol is used. By analogy, you do not have to understand how ethernet works in order to do network programming but you do need to understand the purpose and structure of (higher level) network protocols. Once you have a basic grasp of that, you will want to start looking at the SPI API in python. You can then start putting that together with the datasheet, using the existing library as a guide. Come up with that simple verifiable task and contemplate an implementation while seeing if you can find it in the existing library, then go from there. 

The last command should report . If not, as joan says, something mysterious is going on with the hardware. 

This is probably a mistake. That OS image should be written directly to the card; you do not have to do anything before or after that. Any kind of formatting applied is at best a waste of time because the image will overwrite that information anyway, and at worst will muck things up. If you have another computer that can read or detect ext4 partitions you can check the card, but I'm guessing what you did was copy the image into a partition made with Rufus, which is another mistake. The image contains the boot sector (this is why you do not need to format the card) and three partitions, not one. The standard Raspbian image only uses two partitions, but it doesn't matter with regard to creating the card, so I recommend you follow the Foundation's recommendations (only the second half there, "Writing an image to the SD card"). 

Finishes right there -- the next line, , never happens. This is because replaces the current shell with the command. So all you've done here is start epiphany then matchbox. There's no loop. X exits when the xinit script ends (which is why some people use a loop here), so in this case, when matchbox dies, the whole GUI will shut down. Using matchbox in this keystone position may or may not serve a purpose. If instead you used no window manager, just one line: 

With the shell will give you the last A - B bytes, presuming "A" and "B" are actual numbers (or variables representing integers). That's not python, but that's the idea. 

No here and do it as the user you want this to apply to. If you aren't familiar with MIME types they're an internet standard; here's the official list of ones. Covering all your bases is obviously going to be a bit tedious ( just covers literal files, I believe), and as far as I can tell we can't use some form of glob or regex directly here, but you can use a very long list, so here's a trick pilfered from the Arch linux wiki: 

The person who wrote that blog is a bit of a twit. You do not need anything other than the cross-compiler to build and install a kernel. Ignore anything that involves the separate "tools" directory. 

The safest touchscreen would be one that is built for the pi and has in-tree kernel drivers so you do not get stuck having to use a manufacturer's OS image that is likely to fall (or already be) out of date and may cause you other kinds of subsequent grief. Unfortunately, navigating that realm is problematic because people in the latter category will still (fairly) advertise their screens as "made for the Raspberry Pi". The best thing to do is search around, especially here, for user reports about the screen. The safest kind of generic screen would use HDMI for the display and a usb connection for the touchscreen input, since these are standardized and should not require any further drivers. However, I'm not sure how many people actually make such things. In general avoid anything that refers to having to download drivers from somewhere and in particular things that refer to downloading entire OS images. The $20-30 you might save this way will for most people not be worth the hours of headaches and problems it may easily lead to. 

If it was a Raspbian package that installed it, either it was created post-installation or it comes from a repo which is not indexed properly. 

Should show an entry including , unless Arch's init renames things (it may), in which case there should be an entry that includes in the description. Regard that as below. If there's no such entry, check the leds around the jack. If they are not lit, something's physically wrong or you have a very strange kernel -- try another distro. Now try: 

Should guarantee you HD resolution (1080p @60 Hz) if you plug in a cable after power up, and in my experience will work with most modern TVs and monitors. For a complete list of the possible options see here. 

Which should allow you to tweak the value until the path works correctly. Note that setting an environment variable this way will not make it permanent, and it will only affect your current shell and its descendants. However, since setting and using env variables with bash (the default shell on Raspbian) is well documented elsewhere, I will not regurgitate anything further. 

If you want or anything special in that, use that too. This is the that will be used by the script and anything it spawns. The other option is to use absolute paths for every command that is not a shell built-in, both in and anything it spawns. Init scripts including should exit quickly, so you should background the python script with . You do not need the intermediate shell script with sudo, just put: 

That's the package you actually want. For "gcc-4.6-arm-linux-gnueabi", we could try -- but that returns nothing. The same regexp trick might work (just plan will return way too much again): 

Which provides a node, but what do I do with this? I have installed () and it correctly shows the address of the device. I am using Raspbian. The device comes with a lengthy datasheet, but it seems very abstract and I am not sure where to start with corresponding that to code. 

That may be the case anyway if it doesn't like how the disk is formatted; the number on the end indicates a partition number. What should exist is just plain , the physical device itself. If that exists, then the drive it there, but there is some issue with reading it. I believe has a problematic history but I am not a user and cannot comment further. 

Presuming you are logged in as the same user that's running the X display, this is fairly easy. First you need to know the display identifier; if there is only one running instance, it is probably . To check, use . You'll see output including stuff like this: 

Kind of weird. You might try -- under Internationalization Options there is a means of setting the keyboard type. Beware I think initially (or if after you choose "English"?) it shows only shows a variety of UK style layouts, none of which correspond to US ones; to see those you have to choose "other" first. Most people on the west side of the Atlantic have a US style 104 key PC keyboard. You have to reboot for this to take effect (or you could try plugging and unplugging the keyboard, but I think a reboot is needed). 

And end up with the same result as thread #1 (11.333), but they have not helped one another beyond step A, therefore having two of them pursue this goal is a waste of time. (Note that this example is not a literal one; it's intend to demonstrate a logical principle. The scale on which tasks are threaded in user code is much larger, but you don't need a real lesson in multi-threaded programming in order to grasp the idea here.) Exploiting multiple processors requires code that is written to do it. You cannot simply take anything and say, "oh use all 4 cores and do it faster!". That's not what would happen. Logically, a lot of (..or most) problems and tasks involve steps that cannot happen in parallel, they must happen in sequence. 

Notice the external hub (Belkin) and the external drive, plugged into the hub (ASMedia), are both visible. Again, the power for both the pi and the drive comes from the hub. The data cable is indicated in red. Notice it uses a special port. There is only one of these on the hub. 

Which seems redundant since that's the default, but sometimes I am dubious with wget (and why would they have a switch to turn on a default feature?). There is also if you still aren't getting anything in . Beware that is a volatile directory in RAM on most systems, so if you turn the pi on and off you will lose that information.