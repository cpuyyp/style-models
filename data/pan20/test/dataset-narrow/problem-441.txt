Yes, it seems thread safe. I run a test to prove it which I give the details at the bottom, but first are some code review comments. 

That's why we should first think about the primary concerns of our application, and try to seperate these concerns into classes, which can then also be re-used if designed modularity in mind. Therefore, Assuming what you are trying to achieve is something like this: 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

Method name is a common method name used by collection types to add a new element to the collection. An method with source as the first parameter and the items to be added as the second parameter does not make sense. and are bad names for parameters and should be changed at least to and or similar. And in Capitalization Conventions 

So, this is pretty much the same amount of code as what you had, the main difference being that this version has full error handling whereas your version did not handle errors from and the browser request was left permanently with no response upon error. 

First off, your code really breaks down to this logic and I find it helpful to write it out the longer version to full understand the logic flow before trying to shorten it: 

One potential problem I see is that you initialize the variable once at time and then you use that value in several event handlers. But the window width is a dynamic value that can be changed over time so your event handlers can be using a stale value for . You should probably be fetching anytime you need it so it is always correct. 

I'd really rather see this in a subclass of an Array rather than modifying the built-in Array object, but alas we can't subclass the Array object yet in most browsers. 

You can also change the method to be an extension method of . This will clearly state the purpose of the method if declared with a good name: 

The code is missing the class which I think is also important for the review. The cache items are added with keys and it is important for this method to return the same value for objects having the same credential values, and distinct values for instances with different credential values. Is it? Naming conventions. Class names should be PascalCase and the class violates this rule. Should be To achieve better encapsulation and seperation of concerns, (The creation of an empty credential object should be a concern for the Credentials class, which has control over the internals of itself) instead of having a field in this class, it is better to have a field (or property getter) in Credentials class. 

I'm not suggesting to change to and to of course. The parameters should have descriptive names in the first place. You can consider and or similar. Possible Improvements Being consistent with code formatting is important. Consider using curly brackets, always: 

You can combine the two identical assignments at the end into the same line rather than recalculating the same value again: 

You can rearrange the if/else to be a little more efficient. You can retrieve the length a little more efficiently. And, use (pre jQuery 1.7) or (jQuery 1.7+) with a selector of a parent object close to the elements. That will perform much better than for large numbers of elements. It could look something like this: 

I also fixed your condition in the loop so that it safely checks both values. You could also avoid some of the intermediate values, but I personally would preserve them the way you have them because of the readability/understandability advantage of having it this way vs. putting them all in one giant formula. 

If you define the sort function inline as an anonymous function, you can use a local variable to determine the attribute to sort on like this: 

So, all you're getting out of your implementation is a slightly more efficient length and every other operation is less efficient than just using the native code way of doing it. Is this collection really useful? There are some older browsers that don't offer the .keys() method, but there's a pretty simple shim that implements it if not available. In addition, your implementation loses functionality that a plain javascript object has. For example, you can't pass your collection to any function that expects a javascript object with the keys and values on it because those are hidden inside, they aren't actually properties of the collection object itself. Then further, you can't do custom iteration of the keys and values without first creating an array of all the keys because you've hidden the natural ability to iterate the keys of a javascript object. 

You should always check if the parameters are passed in as null. Your code would fail with a null refererence exception at if is passed as null. 

Therefore, You can simplify the exact same behaviour at least in terms of the final state as follows: 

And here are the results of the test, which shows the method is invoked a total of 5 times for all the 100 threads. The test created 100 threads which access the method randomly within 500 ms. There is another thread for removing the item from the cache in 100 ms continuously (This is because, the cache policy doesn't seem to effectively remove the item at the exact point of time of expiration). The method lasts for a random time between 0 and 500 ms With the following results, it can be seen that the method is invoked a total of 5 times (which is the number of the cache not containing a instance for the given credentials, first one because the cache is empty, and for 4 more times because it is removed from the cache) I can't help myself thinking why the of returns when the item is added to the cache. This would have been implemented differently (as returning the added instance as ConcurrentDictionary does) 

Here's the original answer before the actual HTML and actual rendering intent was disclosed It would be useful to both see the HTML and understand what you're really trying to do here. It may be much easier to add some appropriate classes and do things a simpler way, but we can't really tell without seeing the whole problem including the HTML and a description of what you're really trying to accomplish. From purely studying your code, it can be deduced to a pattern and that pattern can be generated with javascript rather than repeatedly typed out. Here's my first analysis of deducing the pattern to a couple loops of code. There's one loop to create each event handler and another loop inside each event handler to loop through each item and apply the desired change to each one: 

Comparisons are done with or , not with which is an assignment. Item 3: does not exist in versions of IE before IE9, so you will need to use if is not present. Item 4: Here's a version I've done that gets rid of all globals except (which I renamed and made it a boolean. It also uses anonymous functions (less global namespace pollution) for the handlers and makes some other cleanups. You can see it work here: $URL$ 

The following is the IL generated for There seems to be full optimization by inlining , and The CIL runtime stack works only with 4 byte or 8 byte integers, even the LDC_I4_S pushes a byte as a 4 byte integer to the stack, so, there is no performance gain in changing parameter types to smaller integers, byte or short A slight improvement (may be); These methods need not to be instance members and can be defined static. Changing them to static will remove 1 push instruction to the stack (argument 0, the instance to invoke the method on) at the caller site. That's all. 100 million iterations on my 2-cpu 8 core windows 7 HP machine executes in 17-18 ms, and 8-9 ms of it seems to be the iteration (empty loop) itself. 

EDIT 1: You also don't have to check and assign moannie if it is passed in as euro because it already has the value euro: 

Something tells me that requirejs probably has some features to help with this, but I'm not finding them at the moment. Your situation is complicated by the fact that you have to run custom code after es6-promise is loaded before fetch is loaded and by the fact that a usual tool for these kinds of problems is promises, but you can't use them here because they may not yet be loaded. Here's a solution that is not less overall code, but is more DRY and is more general purpose and could be reused in other projects: The code to do the custom loading would look like this: 

Is repeated each time. Since there can't be a case where is an object that has a property and where , then you can figure out once before all the comparisons whether there is a property or not and just use that knowledge. This also simplifies the comparisons. I'm also assuming that the variable in your code is just something you are temporarily using and not something you're really trying to set (it appears to be an accidental global and is not being used elsewhere so I've removed it). You can extract out some of the repeated code like this: 

To prove that it is properly working, I run a 100 concurrent threads test with random access to the operation with the same credential instance. This test revealed that, 

Then, why restricting the second method parameter to ? Let's get that as an . This way, your method can also operate on or instances 

The access is synchronized to the method. OK. For the threads that call at the same time passing the same instance, after the call to , is for only the first invoking thread. OK. All other threads get the existing instance after calling and is . OK is called on one of the first threads that call , most of the time the adding thread, but sometimes on another. OK After the call to , all requesting threads get the same instance out of one by one, as returned by . OK The first thread that gets the instance calls and succeeds. OK. After the instance is removed, other threads continue to get the old instance because they have the removed instance. OK