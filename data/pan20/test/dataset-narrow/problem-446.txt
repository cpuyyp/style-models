Too complex As the other answer pointed out your solution is too complex. The number of bits you test in the function is proportional to the number of off bits in the value. For the value 0 you loop inside a total of 32 (off bits) * 32 (checks) for a total of 1024 iteration. With the mean number of off bits in any random 32bit int being 16 the mean iteration count (bit checks) is 512. The whole thing can be done in an average of 31 iterations per value. Bad testing Also your testing is very poor. The problem is easily scaled to a different number of bits. For 8 bits you can test all 256 combinations and will give you all possible types of patterns you are looking for. The ideal test is against a known working algorithm and check every unique combination. IE you dont have to test 0b1111000 if you have tested 0b111100 Example of a quicker test It only does 8 bits 

Some extras The problem states "image" and "pixel" which give a hint that this may be judged on performance. They would tell you if it was. But if you get a similar challenge and performance is important then its best to use good old loops, avoiding any iterators that use callbacks. Also a performance oriented function would swap in place rather than create new arrays. If you had to do that realtime with images for modern displays your code would be making big GC hits (Garbage Collection). An alternative Another way it can be done by rotating 4 pixels at a time can reduce memory overheads and processing time. Destructing lets you swap 4 corners in one go without the need to create temp variables. I would never recommend you submit the following unless there was a clear directive for performance, and thinking outside the box. 

Hard coding outside data source should be avoided. Hard coding outside data sources will present an ongoing workload. This will be compounded by the fact there is no validation of data. At anytime the data source may change, add, or remove properties. You will not know about the change (if you don't personally follow the source doc feed) until it fails or a customer/consumer reports the problem, or worse just stops using it. Testing for a valid response will not protect against modified data. Even if you validate the data it will just improve response time for the fix / update but not the underlying problem. The cost. Every change will require an update, test, documentation, deploy, monitor, release, and pray cycle for the life of the service. As a business I would have to pass this cost/ risk on to the client or revenue source, and having a programmer on call is very expensive. In other words this type of design can kill a service. For the sake of auto complete it is not worth it. You are best of generating something that Vs2017 can read (I don't use it so you will have to look in the docs) and hard coding as little as possible that is outside your direct control. 

Even the comments repeat, there are 12 ,3 and , and 9 I removed only the relevant content and counted the characters. ~80% of the the above code is redundant. with only 12 unique values in there, the filenames of the audio, and the element ids, which you repeat again in the rest of the code, and HTML. I don't think you know, but What makes it even more not dry is that every modern browser already has all the variables names created for you. Each line is simply replacing the existing global variable. Removing all the get element lines and your code would run just as well. 

Random values. There is no real way to test random values. You can only say how random it is and what type of distribution it gives. Eg the string "aaaaaaa" could be generated by a perfect random generator, that is the nature of random. (as the infinite monkeys randomly typing can produce all the written works of man, and if possible a perfect random number generator) Also take it as a given that scaling a random value does not affect its randomness. Just as you don't have to test code that adds numbers ( needless testing) the same applies to a scaled random value (within floating point limits that is). For most applications is still as random as Testing random First of 

, and When declaring variables use the appropriate type. is the preferred type, unless you need to modify the value then use . If you wish to use let in preference to that is up to you, but be warned that is not hoisted. Avoid reserved words. There is a set of words that are reserved and represent existing, or possible future tokens. Two of these are , and you should avoid using reserved words. There are also many context specific words that you should try to avoid unless you are sure you are not overwriting an existing global property. For example , though you safely use it, I do not know if that is just luck or knowledge that is a global scope object AKA and you are in function scope thus not overwriting the global. Anti pattern I consider this as an anti pattern 

the variable can be assigned a new value which is all good if that is the intention. But many time you assign a variable a value only once. If you at some stage accidentally assign that variable a value due to a typo in the source code, you may spend hours, days even looking for the problem, as where the problems occur may not be where the problem starts. And worse, you may not spot the problem due to lack of testing until your code is out there. This tells Javascript that the variable is a constant and will never change. If you try to change it (via typo in source code) Javascript will throw an error, letting you detect the problem and direct you to the location of the problem. You can fix it there and then saving a lot of time and effort. Though it is not a major point in this example, using the correct variable type in every situation helps build good habits. 

This is a very crude set of reg expressions, and I am sure there are better ones, I leave that to you if you think these approaches suit you. Returning best hands All that is then left to do is test each of the 21 hands and giving them a score. Once scored you sort them from best score down and filter keeping only hands that have the same score as the best. You then get an array of best hands, each with a score that can be directly tested against any other hand. No need to have the high card. No need to have an object holding array of card objects, that is all irrelevant to the result. Example Putting it all together you can create a hand evaluater that will return all the equal best hands from the parsed array of 7 cards. For fun (and to make sure it worked) I have added an interface. Click cards to create a deck, when 7 cards selected they are evaluated. Click on selected cards to remove. Evaluates and names all combos. Best hand has lowest score. 

Note V8 has made some amazing improvements over the past months. It always pays to test performance when in doubt. Rewrite The following will be about the fastest possible. the only performance increase you could get is using a typed array and implementing your own stack (which is worth the effort for larger array sizes) 

Quadratics can also include fractions or . You should also be able to add the equations strings together, two or more 2nd order polynomials added together (joined with a "+" or "-") should equate into a valid quadratic. Naming The function naming is rather bad. To name a few examples 

Where is the property name being tested, is an array of property names up to the current object. is the current object the property belongs to. The function returns if the test passes, and any other value if the test fails. Only paths that the predicate returns true for are returned in the array of paths found. Example code The function is very versatile and below it will find all paths to properties that are named "x" and the second search will find all paths named x and contain a string 

Dont recreate DOM elements every time there is a change in the task list. When a new task is created create the listItem as well and store it with the task. When you create a DOM element 

See rewrite for similar example. Do your best to reduce memory thrashing and GC hits. Reuse object rather than delete and create a new one while in time critical code. As an example Each time the snake moves you create a new head, and delete the tail. It is more efficient to just move the tail to the head position and only create a new tail each time you eat an apple. Try to avoid using the canvas context functions and . You can get better performance if you code in such a way as to know what states need to be changed and which are known. Control the game stages (states) by using a variable to hold the state function. You then just change the function to change the game state. I have added a slightly more complex game state system. See the rewrite for more info. The rewrite I tried to stay as close to your original as possible, I dropped a few things that to me looked like debugging code. There may be some slight variations to game speeds. I also added a ready to play game state. Use this as just an example, it is not how I would write such a game but there would be no point in a total rewrite, and not much to learn if your basic structure where not still being used. 

Look and Learn Look at other examples of similar applications and learn from them. This particular type of app is not new and there is a lot of open source code to learn from. Some sources of code examples are Google search, Github, MDN (MDN's DB indexed API reference will have some data retrieval examples I am sure) and even the fiddle page you gave. The code windows are syntax highlighted. Yay I will say it is good to see you use to trigger visual updates. This is seldom used and is best practice for any sort of visual DOM changes. 

Additional notes. I don't know what your intention is but the triangle seems a little odd not being centered on the mouse click. Also I would define the triangle as a abstract path rather than hard coded to the function. Is there a reason you put the code in the head of the document. You could have placed it at the bottom of the page and avoided having to wait for the page load event. Also, maybe you are wanting to learn easelJS, but the load time of easelJS is substantial and what you do can just as easily be done using the native 2D API. I strongly believe that you should have a very good reason to use a 3rd party library, especially when you are learning. You are best spending your time learning the native (and very good and performant) APIs. You may not always be able to use the library, but you will always have access to the native API Rewrite without easelJS To match your code I have implemented a very simple stage. Though what you do does not require a stage object and could be a lot simplier.