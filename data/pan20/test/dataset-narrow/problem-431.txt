You don't initialize the members. Since the members are POD they have indeterminate values and thus reading them is undefined behavior (unless you assign something to them). So the move assignment operator has the same problems as the assignment operator as it reads the value of (only a problem when called from the move constructor). 

An alternative to my first version. If you don't want to use streams. Then I would go with a version that does not modify the original string. 

In my opinion (so its perfectly valid to believe differently) this buys you nothing and makes the code less readable. 

Have a working version of MySQL implementation of ThorsSQL library done. If you want to check it out you can find the whole thing on github ThorsSQL. This is a follow on to previous code Reviews: Part 3: Layer 5 Req/Resp Part 3: Layer 4 Part 3: Layer 3 Part 3: Layer 2 Part 3: Layer 1 Part 2 Part 1 The documentation for these classes is here: Part 3 (Layer 5): The HandShake Resp and Reply When you first connect to a MySQL server; the first action of the server is to send you a package. The client should check the package make sure it knows the protocol suggested by the server. Then send a message to the server. If everything goes well the server will send back response. If we look at the code I posted for Layer 4 you may have spotted this happening when the object was initially created (added below for reference). 

Threading Sure you can use the C language threading model. But C++ has its own threading model you should probably look into. 

Next I would exit early rather than have nested code. This is a debatable point on style but I don;t think having to scroll down a long way to see a one lineer for failure helps in readability. And since you already exit early that is not a problem. 

But now that it is a function (rather than a class) it has accesses to the members. So we don't actually need to pass all those parameters. So we can simplify even more: 

Your producer adds lots of items to the queue. But only signals once. You should signal once for every item added to the queue. 

The trouble with the socketaddr_in type is that a lot of the data is unspecified. So you need to make sure you manually zero the whole structure before you use it: 

Use a Sentinel Value. If you add a fake value to the list. So the list always has one node (the sentinel can not be deleted). Then you make the list circular so the head points to the tail and the tail points back at the tail. Then you can get rid of all the checks. This makes the code much simpler to read and write. Pass by reference. You pass your parameters by value. When they data type is an integer this is not a problem. But sice this is a templated class the data type can be anything. As a result when you pass by value you generate a copy of the object. So pass the parameter by const reference to avoid the copy. 

It is hard to tell if numbers was dynamically allocated! You actually have to go and look that up in the function . So if you change you also need to go through your code and find every place that calls to make sure they also use it correctly. Also its not exception safe. If an exception propagates through your code then you leak memory. The function is special. If you don't specify a return then the compiler generates a for you. If your code can do nothing else apart from exit successfully then leave the out to indicate that there are no failure states. If there are error exit states then is an indication that the reader of the code should look for exit failures attempts. Here: 

Write DRY code. Make the constructor call clear(). But also make the destructor catch all exceptions (unlike clear). This way if a user wants to check for errors they call clear. If they don't care then the destructor will clean up and catch any exceptions (as you should never allow an exception to escape a destructor). 

So it looks like both my reasons for disliking recursive template functions have been addressed by the new version of the language. But I still prefer the style of the unrolling the argument loop in a function. So I present my version of the same function to show readers how it is done without using recursion (template iterative style). 

This is enough to hold the terminating but nothing else. You probably want to hold a longer string try. 

I think not. I agree it should be but that is not something you can guarantee and thus your code should not guarantee that it does not. So this should probably be: 

Next it is not usual in modern C++ to see pointers. Pointers do not have any ownership symantics. So we don't know who is supposed to clean up the memory they point at (if at all). This is the largest failing of C and requires extensive use of documentation. In C++ we have a bunch of types for handling ownership semantics directly in the application code. So you should go an learn about reference and smart pointers. Creating an array and assigning values in the array at the same time. 

Technique used. I would not have bothered to read the data into its own buffer (then tokenize it). The C library has a perfectly good stream reading library in scanf(). The same functionality can be achieved using: 

If the size of the dictionary is not huge (couple of Meg). I personally would just load it into memory and let the standard data structures handle it. Alternatively You could map the file to memory and do a more standard search. 

Each move has some seemingly intrinsic characteristics. In particular, each of their name should be lower case Strings, and their values are limited to some given set of words. My impression is that these rules aren't bound to change that much anyway, so why rely on the rules engine to impose them? For one, instead of checking if their names are lower case, why don't we just ensure that they always are? Instead of making it a rule, why not turn it into a basic assumption? 

Normally, I do this for methods I have yet to implement while I work on specified methods one by one. 

As for the restriction about what their names can be, since it's not very convenient to use enum, then I'd suggest using a plain text file of comma separated values, added in the classpath. For example a file in the directory could look like: 

Admittedly, I don't know much about Drools, but guessing from how the rules are defined here, using this class, rules can be defined like (this is not Drools syntax): 

I'm not really sure, but somehow I feel like this can be an instance of a refused bequest, or some sort of breach of contract. I think you have few options here: 

My personal view in methods like this is that instead of making them setters/mutators, you turn them into actions/features. So instead of having a that takes a from a client component, I think it would be a bit more sensible to have something like: 

If we're speaking of actual efficiency (as in performance) though, I don't know how much more efficient pattern matching is compared to iteration of characters. However, this is much more readable. In any case, notice that the actual translation logic is wrapped inside the condition that the input string does not contain a number. This way, you return from the method as soon as you determine the input is unacceptable. To check whether the input string starts with a vowel, you can also use pattern matching like: 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: 

Ideally, class should be itself the , but since Drools seem to rely on POJOs and, the constructor for can't be made private, I think this is an acceptable compromise. With this, there probably won't be a need to have separate rule for validating unless there are expected, more complex checking. Also, since the application is checking an external file for values, there isn't a need to recompile or rebuild the code when a new Move like Jedi is introduced into the system. As for the rules on game proper, I'd say they should have been applied to a and not to separate players. The system doesn't even seem to be interested enough in Players to give them names like "Player 1", or "Player 2"; they merely carry a Move in them. A contains 2 objects, each from 2 opponents. The fact that there is a class seems to suggest there should have been a class to begin with. 

Hopefully the class illustrates my point about classes being in charge of their own state, actions, etc. Lastly, about , I will also say that this class is weak, and overly transparent. My idea is that once a object is created, it will never change. Because of this, I think that should be defined this way: 

Hopefully there's a way to make this work both ways. Anyway, I don't expect to get everything correctly here, but I hope somehow I raised interesting points regarding your code structure, and domain design 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

Conceptual Framework for Domain Model In your application, there's a rule imposed (via your Drools XML) that there is a fixed set of values to a 's move. My opinion here is that your domain model should reflect that requirement, and seeing as you have generics in your code, your application should also be able to support Java enum. I think it's better to capture this restriction on valid moves by creating an enum called like the following: 

This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: