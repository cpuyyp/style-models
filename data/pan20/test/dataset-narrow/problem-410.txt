A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

But now you have this weird thing where at the start, you say "I had changes", which seems wrong... and you always want to go in the loop at the start. So convert it to a do-while: 

Did you mean and ? Actually, your method naming could use some work. Let's go over some of them. But first, Java convention. It's Java convention that your function names are . So, let's look at your method names: 

I'd like to know if there's a better way to make enumerations or if there's an easier way to provide , and from the class. I'm also interested in general improvements. 

This sort of thing could REALLY use some documentation. You wanted harsh and constructive, and that's what you're gonna get: (some of the critisms may not apply because you're in school) 

Algorithmic An insertion sort is generally described simply as: read each element in turn, and insert it in the right position among the previous read (and sorted) elements. The cost of the algorithm is thus: 

You do not have to use those exact requirements, of course. In this case, though, I really advise you to use a constant-time method: all standard containers have a constant-time method since was brought back into the fold in C++11. Without this constant-time requirement, there are two valid implementations of , one using and one using a data-member. With this requirement, only the implementation using is valid. 

We place at the end of the array, then have it "bubble down" (as in the bubble sort algorithm) using swaps until it's in place and we've shifted all the elements after it one step to the right. The same can be done, but bubbling the element to be removed up, with : 

This pollutes the current namespace with all symbols. If new symbols are introduced, they might clash with existing ones, silently switch the methods being called, ... it's better to be explicit, really. 

Like here, I don't know what the VBA call is, but isn't there some version of MAX that you could use? Or here, 

Broken Code Your code is broken right now. If I make a 2 by 2 by 2 cube. And I put in it a 3 by 1 by 1 stick. Then you say "sure, okay!" 

You could do this by incrementing another variable for every move operation, and decrementing this variable after the -for loop (with a minimum of 0). Start at + this other variable. Like that, it would, after the 3 moves in the first iteration, start the second iteration off at index 4 (i = 2, move counter = 3 - 1 iteration passed = 2). 

are unused. I think this is because you've stuffed everything in one class. If you use multiple classes (via SRP, as Kolargol00 says), you'll have smaller classes and it will be easier to find these unused variables. Specifically, I'd make a class for Keyboard input, a class for the hero character, and a class for a wall to start with. 

Unfortunately, the C++ standard library does not allow one to pass an existing buffer to a string (sigh) and is generally pretty lacking in raw buffers (sigh), so you'll have to roll your own. I would do so in two steps: an abstract base class which exposes a way to write bytes in slices and a ready-made implementation based on + size + capacity (not , because it zeroes the memory when resizing...). The second is an issue for extension, and performance. In order to format their own types, users are encouraged to "pre-format" their own types into strings, which will result in needless temporary allocations. There is unfortunately no simple way to solve this issue, it's a fundamental limitation of -based solution. It will be up to the users of the solution to decide whether the cost of temporary allocations is worth bearing, or not, on a per-call-site basis. 

Now that we have the helper methods, we will also alter the set of constants: checking a single constant is faster than checking individual ones, and having a pre-calculated "total" length is risky in the face of change. So here we go: 

There's no real need for all those checks if is already true. After all, it's not going to change the variable. So relocate the check: 

So given the rather large amount of indentation, I'd suggest that you'd negate the if statement and turn it into a guard clause: 

Use the class you were using earlier Make use of java's char to byte casting; use Define the value as a constant Add a comment . 

Wait, you only have one? ... You're missing the test cases where you add multiple values to the map and see if it actually can store multiple values. But no, don't inline. That'd be annoying. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

No checks occur here, so both threads start the application. You now have 2 application threads running. 

There is no need to put something back into the map when you have retrieved it, because you are retrieving a pointer to a list, and you're using it to add to a list. See this Ideone that lists you put and later retrieve from the map are the same lists. Okay, so back to this snippet.