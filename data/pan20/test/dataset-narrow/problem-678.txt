You are not using at all in determining your offset for the LIMIT clause, so your pagination is not really working. 

Consider passing a valid database object in the constructor (dependency injection) vs. getting is statically. The problem with your static invocation here is that you are doing nothing to validate that you actually are returned a valid PDO object. You just assume that it is always going to work. If you did something like: 

All of your DB operations are happy-path. You just assume they will work (which is especially problematic based on data validation concern noted earlier). What is prepares fail? What if execution fails? 

The gap between what you currently have and an MVC-based, object-oriented framework is quite large. I would expect your best learning opportunity would be to work with one or two of the popular PHP frameworks to see how they structure things. It is really quite hard to give you a meaningful review, as you have just shown some assorted fragments of code, none of which gives clear understanding to what is taking place in your application. From looking at what you have posted, my guess is your framework has significant problems with regards to security (for example, you seem to be trusting user input without performing any validation) and with regards to truly separating your code along areas of responsibility. 

then you can run your validation filter against each individual element of the array up in the validation steps and already have an array to work with, eliminating the need for this call. 

If you are going to use doc blocks (something I would encourage), you should, at a very minimum, include annotations for your public methods (but ideally for all methods - this helps you when working with the class in a modern IDE). 

You seem to only be adding visible / unlocked layers to your data structure. Will this cause you problems? If one of these settings is later changed for any single layer, you would then have to recalculate all of these data structures. Is this desirable? 

But let's assume you can't do that, and think of ways we can get you the information make this whole thing more dynamic. I am not sure what is even used for, so I am discarding this. 

I am guessing the GET path doesn't actually work as you are closing your DB connection before retrieving rows! 

Consider working with a more reliable mailer than PHP's function, which is notoriously bad in terms of generating useful errors and in terms of configuration. As it stands right now, you are not even handling the error path if fails. 

Incorporating the above thoughts should allow you to greatly streamline both the performance of your script as well as just simplify how it works. You might end up with something like: 

I don't fully understand the desire for a "generic" data mapper. Oftentimes, flexibility leads to complexity and fragility in your application. Take for example your method. It just arbitrarily accepts whatever object is passed and starts deleting things from the database. What is to stop someone from just creating a new object named similarly to a table you don't want deletes happening against (like a configuration table) and arbitrarily destroying records in the database? This flexibility can lead to bad habits like doing queries, overuse of publicly accessible properties on your objects, and using PDO::fetch_object() which can circumvent class constructor behavior. I guess as an educational exercise like this perhaps has value, but for a real-world production-level application, I think this class is pretty much a non-starter. I know it might seem like a lot of extra code to have to build "model" classes for each of your database entities, but I would strongly suggest doing just this, as you will likely find over time that a one-size-fits all mapper such as this just becomes a mess when trying to adapt it to the various use cases you may have in a more complex application. I DO think that what you have may be informative towards such classes, as a lot of what you have written might be well-aligned with an abstract base model class which is extended for each entity type. A "search by id" function for example, is probably pretty common across all classes, where you might find that an update method might be hard to implement in a base class and should perhaps be defined as an abstract method there. Some more specific notes follow. 

Note that we apply a data attribute called on the container of each situation "page" to uniquely identify it amongst all situations. We also have data attributes on each option specifying the that option relates to (i.e. which situation will be shown when the button is clicked). I have added another class to show which situation(s) are visible for display on initial page load. Finally, I have also introduced a class for here that is not used in the javascript at all, but could perhaps give you a handle for applying CSS styling. You use these data attributes within your javascipt to implement the logic as to what situation is shown when an option is clicked. 

Think about validating requests against the object more stringently. For example, this code that you use in your get/set magic methods: 

Here, and really in general, you should consider using exact comparison if you are really trying to compare that calculated value vs. as an integer. It is probably a good habit to use exact comparisons as the default way you write code, and you will find your code less fragile to unexpected truthy/falsey evaluation behavior. Only use loose comparisons when there is a very specific reason to do so. 

Consider adding some parameter validation anytime you have public methods. Ideally this could be a combination of type hinting and/or variable inspection to make sure you are being passed a valid parameter. What happens now you if your method is passed an integer, array, object, empty string, etc.? 

Your data structure is not optimal for the use case where determining a point of insertion is not a matter of determining whether something already blocks that position. I do suppose that with the limitation you have placed of only having a single day in the schedule, this might not be important, but assuming that you decided to modify this schedule to accommodate times well out in the future, and assuming that you want to perform an operation to determine where you can fit something in the schedule in less than O(n) time, you might need to look at implementing some sort of a tree (i.e. B-tree, Binary search tree, or similar) or graph structure to best optimize this use case. Depending on expected ratio of reads vs. writes across all methods in the class, one might even find it useful to maintain multiple data structures to provide O(1) reads where possible like you are doing now as well as O(log n) lookups for the use case. This of course would come at the cost of more expensive writes. 

I am guessing all of these properties should be protected/private as they should only be modified using the methods exposed by the class. This means you might need to specify getters for these. 

You may also consider building this as a proper jQuery plug-in or class (though not shown in my example above). This would allow you to better encapsulate state of the slider functionality, such that state would not need to be held in main scope. This also potentially makes this simple functionality re-usable in the future - just pass in config for DOM selectors, class name(s) to apply (i.e. ), interval time, etc. I would rather see a usage pattern like: 

Not sure I like method name here. perhaps? You seem to end up with weird key/value pair here: . Maybe this is based on underlying Guzzle client but seems like it would make more sense to have two key-value pairs here like . This is also a good example of a line that could be broken up like: 

However, that might not be getting you where you ultimately would like to go. I would suggest that with a config with as many "properties" (your array keys) as you have, that you might consider creating an actual config class to be passed to constructor. This would allow you to type hint against the object type and place logic for validating the config into its own class. This class would then be 100% assured the dependencies it needs in its constructor are met. This approach could easily be achieved without much change to the calling code. Instead of something like: 

Don't have functions like and tucked away in the middle of code that is creating side effects, like outputting to user, changing data stores, etc. If you are not familiar with the PHP Standards Recommendations, I would highly recommend that you familiirize yourself with them and try to follow them. This is pretty much the best set of standards that exists for trying to codify what the behaviors for professional PHP development should be. Note that in PSR-1 (basic coding standards), one of the first sections talks about side effects, stating: 

These classes should have no business in performing client redirection. They should handle voting functionality and that's it. Something further up the stack should handle routing concerns.