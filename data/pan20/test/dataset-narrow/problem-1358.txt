This may not be the case but I see you are only doing the rotations when holding down a key. In your checks for if you are Not holding the key down, you reset carSteer to 0, but you do not do anything with the rotations to put the spaceship back to a 0 rotation as well. Based on your comment this does seem to be the issue but you want a way to ease the ship back to its flat orientation as opposed to a quick snap back. You basically want to do the same thing you are doing to get it to tilt but in reverse and based off of a secondary variable so it does not affect your steering as well. NOTE: I only show the changes to one of the key presses. You would want to do the same for the other one as well. (It can use the same tracking variable though) 

This is not a component system. This is not to say its not a bad system, but in this case you should be able to cast the pointer to any of the interfaces (or just cast it to a Gun object and it should Contain the interfaces) and then use it as appropriate. As for determining what kind of object it is that the player has collided with, you can attempt to use the internal RTTI abilities like dynamic_cast<>() or potentially implement your own RTTI (Run Time Type Information) system and add in an IType object to query if an object is of a specific type or to return the type that it is, etc. Once you validate the type you can safely cast it as desired. If you do have a component system and we are just not meshing on nomenclature, then just leave me a comment and explain how the components are related to each other. Often this is done by an ID of the object they are a part of. Hope this Helps 

Rule 1) Only handle what you are designing for. If you are developing a game where assets are being made by someone Other than you, then generally you will want to validate them. If they are only being made by you then it might be overkill to do upfront. Secondly.. If you are running some sort of compression on your assets prior to use (I prefer in-memory expansion of pre-loaded data chunks because its where ya get the nice few second load times from :D), then you can have whatever it is that is compression or otherwise compiling your assets do the checks as well. Remember Rule #1 ;) Too often people (read, programmers) try to handle every situation under the sun, because that is what we are taught.. All your application ever needs to handle is what it will run into. As for a way to validate an overall asset set to make sure people havent screwed with it. Generate a hash value (Sha1, MD5, both?) and store it internal to your application. Then if the has value of your assets does not match what is stored, they are not running what you gave them. 

Delta's are a very very rare thing in networking in games as far as I can tell. They almost always run into syncing issues. Most of the time when you see a person do some funny sliding or the like, its not because a delta system is being used and then corrected at intervals. In general its because of a momentary packet loss of some kind, even if its just delayed data, and then a forced correction on top of the predictive side of the networking. So I actually suggest that you look into manners of packet compression as opposed to delta networking. Some things to consider: 

In general nature of the Developer-Publisher relationship, it is true that the developer will make the game at a loss to themselves and then receive compensation from the publisher. 20% of the revenue however seems first fairly high to me, and second it is -very- easy to show how very little 'revenue' is being generated by something to make this kind of agreement even more frustrating. You may want to consider alternates that are more tangible or lump sum payments for completion (given), target sales ranges, completion dates met, etc. Also, depending on how long your development cycles are, you might want to negotiate milestone deliverables and payment schedule, so its not an all or nothing sort of deal. Split the development cycle into 3 substantial collections of functionality and upon completing terms of the each deliverable you would receive partial payments towards the development costs. Another large thing to be aware of, almost every publisher -will- require you to give them ownership of any IP they are publishing, regardless of who came up with the idea. Make sure the terms in that area are well understood by all parties. Hope this helps. 

There are no drawbacks really. What you have described looks like not only a perfectly valid way to do it, but the way that I would recommend to many people when working with a component based system.. They are designed for situations just like this, where a new object can be created in an editor as opposed to in code. To chime in a bit with The Duck, you may want to look into an instancing-beyond-xml-definition method. Use the XML to load up base templates of components (default values instead of tracked values) then instanced versions placed in a level or an inventory or a characters save file.. whatever. This might just save you on the amount of processing you have to do. (This is more for memory concerns however, not load speed performance) Now, those are the main reasons to use this kind of system. Load speeds should not be a deterrent from this as there are many Many ways to improve load speeds. Having an asset pipeline and an engine that can understand the assets in a few ways is very handy for development. The raw text XML version is nice for editors as well as being human readable for quick iteration and debugging if need be. Having a production or compiled version of the assets (instead of raw text load binary data directly) will remove any concerns over load speed. If you still want to be faster then you compile assets to their complete run time format, they can be loaded into memory, their pointers fixed up, and away you go. While it is always good to try and look down the road, this one is free and clear with many solutions if your concerns ever do become an issue. 

You are looking for a basic side scrolling tile engine.. In the case of later Mario games it has multiple layers for the parallax scrolling background (which just makes what is really far away scrolls slower than what is close by). A quick google search should give you quite a few ways to accomplish this task. In later Mario games, as far as screen scrolling goes, using two bounding boxes is also a good idea. One central box that mario can move around in that does not require the screen to scroll. As soon as mario gets outside that box the game should move slowly to keep him in it.. A secondary box thats a bit larger would be used as a 'mario cant get out of this box' sort of deal. This would be when the game Has to scroll at the speed mario is moving at. Hope this helps, those were the major things I had to accomplish when I made a mario clone for school all those years ago. 

With out knowing more I can not give you more detailed information but here are some things to look for: Look for critical failures you may be handling in your code silently that could cause this.. and do not rule out that that is what is happening in the XNA code. This could be anything that you would assume would never happen but put in for good code theory. Areas to look for are where you are access the data of the other user. Maybe a system is still tracking the remote user on a Mini map that is no longer there or the like. Pretty much any sort of data that you are guaranteed is there when not dealing with remote players but might disappear when dealing with remote players. I will update if you get more specifics. Hope this helps. 

For general C++ optimization considerations I can not recommend the Effective C++ and More Effective C++ books enough. I will also add in that I have contacted this author a few times and he has not only been very forth coming with additional clarifications if need be, but genuine interest in the information.