You can also explore some data types and traffic optimizations - you can for example use half float instead of float (if you don't need really accurate positions). If it's not enough and you want to decrease traffic, you can use ARB_vertex_type_2_10_10_10_rev, which is even smaller (4 coordinates - xyzw - in 32 bits). If you have more models with few vertices (few indices), you can also use ARB_draw_elements_base_vertex (you can find some material here), you can send unsigned short or byte indices instead of unsigned int (you will save 3/4 or 1/2 of its size). If you have more VBOs and you frequently use glBindBuffer, you can use NV_vertex_buffer_unified_memory (there is also example on that site). These OpenGL extensions don't increase performance too much if you have just few vertices, but you have a lot of triangles, so it could be worth a try. There is also more such extensions, like Vertex array range. You have to search. 

So your terrain is made of triangles (Mesh faces). Each mesh face has 3 vertices (A, B, C). I don't exactly know what AB, BC and CA are, but they're always 1, so they're probably some normals or scale factors or whatever. Your solution is to find out in which triangle your object currently is and by interpolation of those 3 vertices find out correct height on exact location in triangle. So first you will ignore Y coordinate (height) and just find (with some heuristic) the correct triangle - triangle containing your object position. Then you should use these steps (let's say you have point X in triangle ABC): You will get line CX and find intersection of this line and AB - let's call this point I. You will interpolate height of A and B points to get height of I. Then you will interpolate I and C to get height of X. And you are done ;) Terrain is usually represented by a uniform grid of quads, not triangles. So it's much easier to find quad containing your object. I don't know if your mesh is also uniform grid - it that case, it would be really easy. 

I think you should rather use VertexPositionTexture structure instead of VertexPoisitionColor to define vertex and texture coordinates. Also set: to true. And to your DrawUserIndexedPrimitives call: 

I think, that if you want to draw just 2D sprite on screen, you can simply draw textured rectangle. If sprite should be square, you can also draw point with point size set bigger than 1 and some texture enabled. But I don't know, if you can set some texture coordinates in vertex shader (but probably not, because you have just one point). Other way is to split this one point in geometry shader and assign corresponding texture coordinates. 

If you see your font in fonts directory, just try to restart Visual Studio or whole system. It should help. I tried it - I installed new font, add it into running MSVS project, then compile and get the same error as you. When I restarted MSVS and compile again, it worked. 

You can find something here and also here. And if you want, you can find a lot of information in GPU Gems 1, 2, 3 and Shaders for Game Programming and Artists (I think, it's not about GLSL, but about HSL and shaders and games generally). 

where x and z are your x and z coordinates and function f returns height in point (x, z). From this, you can calculate tangent as this: 

You can have bound only one index array at a time. So you cann't use separate index array for each vertex attribute. So only choice is to rearrange all arrays according to one index array. 

If you are using OpenGL, you can use DrawInstanced. This is useful for cases, where you have one model and want to draw it many times (for example grass). In vertex shader you will get unique ID, and according to this ID you can set per model transformation (for example take it from big array of transformation). It's really fast and useful. I think in DirectX there will be something similar. If you want to draw separate (but similar) models with different materials, it will slow your application down. Material switching is not too cheap operation (again - I'm talking about OpenGL). 

I know two ways how to do this: 1) Use frame buffer, where you render all objects, each with different color (no lighing, no texturing, ...). Then render normal scene. When you click with your mouse, you read 2D coordinates, look in frame buffer and find color of pixel, where you have clicked. Then you will find object according to this color. This method is called pixel picking. 2) Render your scene, read clicked coordinates. Now you have to transfer 2D point back to 3D - create ray from camera to clicked point. Then do ray tracing and find first object in path (ray object collision). // EDIT: I have found this article, it could be useful. Or you can create 3D points - your screen coordinates (x, y) - devided by screen size (you have to get coords in interval <-1,1>), and z coordinate will be -1 (starting point) and 1 (ending point). These are NDC (normalized device coordinates). Then multiply them by inverse projection matrix and inverse modelview matrix. Results should be starting and ending points of ray. You can find something here - it will help you understand those transformations. Maybe you can use gluUnProject for this purpose... 

OpenGL depth buffer is not linear. The furhter you go, the worse resolution it has. I recommend to read this. Something taken from there (12.070): 

I don't know, if you want to use just OpenGL or it's also possible to use other libraries. If you can use others, you can try AntTweakBar - gui library for OGL. I have never used it for text input, but there is also string type for variables, so it should work. You just create bar, add there variable of type string and set callback. When data are changed, you store them to your own variable. Then you add there button. When user presses it, you will just use stored text to whatever you want. 

If you want do it this way (render colors for color picking and use texture for texturing in one rendering), I think you have to use frame buffer objects or / and shaders. You can use only frame buffers but you have to render your scene twice - first use only colors and store output image (render) to frame buffer, then draw scene normally (with textures) and use first render for color picking. If you use shaders, you can store colors for picking (in frame buffer) and use texturing in the same time. But you have to write your own fragment (pixel) shader. 

I would try ordinary linear interpolation. If your destination vector is D (dx, dy, dz) and away vector is A (ax, ay, az), and your 0-1 value is V, then final vector F would be: 

You should try function Quaterion.CreateFromYawPitchRoll. It should create the correct quaterion. Or if you are using this only for view matrix, you may want also try Matrix.CreateFromYawPitchRoll. 

I dont understand Unity and MonoDevelop, bud I think, you don't have objects in array intialized. You created array, but objects in it are null. You have to call new GridInfo on each of them. Somethink like: 

If you have a lot of quads (with shared vertices), but each quad needs its own texcoords, you can't use shared vertices, but each quad has to be defined separately. It's better to use interleaved arrays in each case, because you have stored all attributes for one vertex consecutively in memory. So if you are trying to read for example vertex position, also some surrounding data from memory (in your case color and texcoords) are send to cache. If you have a lot of data, it's more efficient. And you don't have to use glDrawElements in this case, you can just use glDrawArrays (you don't have to pass indices, if they are just sequence of increasing numbers). I also hope, you are using VBOs (data are stored in GPU memory instead of system memory). 

It's possible, your model is exported with some transformation. I don't use Max, but you should try to find something like Freeze transformation (so your Rotation, Transformation and Scale are all default). 

I don't know, if it's what you are looking for, but you can try this video and this paper from GDC 2011. It's about: Mega Meshes - Modelling, rendering and lighting a world made of 100 billion polygons. And there is a lot about texturing. 

I think this can be transfered to simple ray casting / ray tracing. You shoot ray, find hit, reflect, find other hit, etc. The easiest way is brute force. You construct ray (position, direction) and calculate collision with all polygons (you should divide polygons on triangles) in scene. And find closest one. Of course you can't take collision behind rays origin, but only in front of it. If you find closest intersection, look on material of polygon. If this is reflective, do whole procedure again. If it's not reflective, you are done. If you have huge scene with lots of polygons and you need to shoot again and again, you can construct some kind of acceleration structure (kD-tree, BVH). But this is more complicated. If you want more information, just google ray tracing or ray casting. You will find a lot of information. 

Here is how I understand it (I'm not saying that it's also how author of that script meant it): Column count is total number of tiles in sheet. (the same for row) Column number is number of a tile, where your animation begins (in picture in your question, it should be always 0, but you could also have for example 2 rows and 8 columns - 2 colors in one row). Total cells is total number of tiles in animation. Lets say you have the picture as is in your question, but you only want to animate last two faces (quick blinking) - these two: 8-) and :-) So you will call function as this: SetSpriteAnimation(4, 4, 2, 2, 2, 10); ColCount = 4 RowCount = 4 RowNumber = 2 (zero based and it's calculated from the top, because in the code author is inverting them) ColNumber = 2 (zero based, so this is 3th column) TotalCells = 2 (our animation has only 2 tiles) FPS = 10 (doesn't matter) If you try to put these values in script, index can be only 0 or 1 after line index = index % totalCells and OffsetX can be 0.5 or 0.75. Lets say you want to animate blue faces from 2nd row (1 based indexing). What is important: Your ColNumber has to be number of first tile of animation. TotalCells is total count of tiles in animation. ============================= And about your comment to the question: let's take 11, 11%16 = 11, then 11 % 4 (colCount) = 3, then (3+4) * 0.25 = 1.75 ... So the fourth blue head is at offsetX = 1.75 ? I don't understand. Total cells count can't be 16 (it should be 4, because you are animating just one row, not all 4 rows), when your ColNumber is 4 (it should be 3, because it's 0 based). If you take ColCount = 3, your animation starts in 4th row and has only 1 frame. If you have any questions to my answer, don't hesitate to ask. It's little complicated :)