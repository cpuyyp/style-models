There's really not much we can help you, given the low level of detail in the question. There are somethings you have in this code snippet that are generally considered a Very Bad Idea, so I'll give what help I can in that regard. Null Checks There are a bunch of these types of checks in the posted code: 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

I don't believe there's any good use-case for this code. I know it makes for a boring answer, but sometimes the correct thing really is simple and boring. As you say, the Struts framework should always redirect to the appropriate method and fail entirely otherwise. Even the scant lines you posted have some bad/useless programming practices, so my guess is that the developer thought he was being thorough and clever by tacking on needless framework. 

No need for these lengthy declarations since they all do the same thing and all you're doing is printing the stack trace. will do and make your code more sensible. 

In general, you should try to have more descriptive method names. Following Java naming conventions, they should always be verbs or verb phrases. It just makes your code more readable and easier to follow. For example, this could be called or something. 

This works thanks to autoboxing, and it's a handy trick to remember as you move forward with Java. Even though this bit of code now works, it's still really bad practice since it's a completely unchecked (and therefore unsafe) downcast. In other words, you're just assuming that will return something that can be cast to an . We'll return to this later to add some sanity checking and error handling. 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

Lazy Version It's possible to build a tree in a tail-recursive manner. It's much more difficult to do that with the references to the parent node. So I cheated by making it a lazy data structure instead. The first version was pretty basic. 

If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

I found about 5 things that can be improved, or maybe it's more accurate to say that I did 5 passes over the code in my efforts to improve it. Here's the changes I would recommend, in the order that I encountered them. Better Names The first change was mostly cosmetic, but it was very helpful laying the groundwork for more changes later. 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

One last note: I could have just had them all be statements as well, since each only returns and removes the method call from the stack anyway, but I find that it makes the code more readable to have s, since it means the conditionals are logically joined to the reader. EDIT: I actually had to expand the initial checks slightly. Technically speaking, given your rules, if the is passed in as , it should return , not the empty string. 

You should definitely go with Swing before trying to integrate Java code into a web-app. If you're interested in making Android apps, though, you can download the Android SDK and start toying around with that API. I'm sure there are tutorials out there for that. Setting up your environment might be a pain, though (your programs have to run in an emulator or be deployed to an actual phone). 

I'm sure there's a lot more, but that's what I noticed off the bat. If you shorten the code a bit given the above comments, I'll take a deeper look at it all. Good luck! 

You should try to use consistent style in your code. If you're going to put these checks and return statements at the beginning, either put them on the same line as the statement or don't. It doesn't matter which you do, as long as you do the same thing throughout. Makes your code much more readable and easier to maintain. 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

Normally, I'd suggest trying to get rid of as much mutable state as possible. That's not really possible here, the circular reference to the parent pretty much guarantees that something is going to need to be mutable. Vanilla Version Without deviating much from your original design, there are a few cleanup suggestions that I can make. First, as suggested by @Carcigenicate , could use some naming fixes. In the version below I used , but it could have been any number of choices. I also inlined the creation of . 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

(Note that in your code, it's actually impossible for a draw to occur, since you check both of the winning conditions with and , meaning that the condition will be caught in one of those. This may be a bug in your program. :) ) I might even make a function to avoid some copy-and-pasting: 

Also, if possible, could you give the variables better names? The first three are fairly self-explanatory, but once you get into all your random letters, it gets pretty hard to follow what you're trying to do in your code. For example: 

He already checks for and then checks for . The only reason to use the second construction for a comparison is to avoid a ... which he's already done by checking against . So either he doesn't know that Java short-circuits conditions, or he has no idea what the purpose is behind the second construction. Also, it's generally a bad idea to have huge wrappers around entire method bodies. It would be a better design to have something like this (if it were needed at all): 

This is a curious method. All method names should be verb phrases, firstly, and if this is taken as a verb phrase then it means you are executing the code to play again. But the really curious thing about it is this: you return if the user does not want to play again, and if they do want to play again. That's bizarre and completely counterintuitive. 

Along those same lines, became because that's really what it does. I also moved the helper functions into 's companion object. It's a good default organization strategy. itself had mostly structural changes. I changed the visibility of , so that mutating it has to pass through the helpers. It also became a Set, as the OS doesn't generally make guarantees about listing order, so I wanted to avoid implying that the order was something that could be relied on not to change. became just and passes a defensive copy of the internal set. That gives us this final version, with a small driver to make testing easier. 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

This is just general nitpicking, but you should only expose methods as which actually need to be . The method makes sense as a method because it's the part of the API that you will want to use in other parts of the application. This method, however, is purely internal and thus should be . Also, method names should pretty much always be verbs or verb phrases. I might rename this method to something like or . Actually, because of the nature of how I rewrote your loops above, I would change it to or that way my usage of it is more intuitive. These notes also apply to your method, which is and might use a more intuitive name for code readability. Also, in those two methods, what happened to your beautiful variable names?!? Why did you suddenly move to using single letters instead of something more descriptive? 

Now we can simply call this method whenever we need to get numbers from the user. Much easier, and we've reduced the complexity of our code. Another thing that's redundant is your constant re-declaration of . You really only need to do this once. If it were me, I'd have it as a static field for the entire class, e.g., 

This will let us set the references for each missile type upon initialization. With these references, each missile will be able to calculate its values on its own. 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Now that we are using a more appropriate data structure, we have regained the simplicity we had before, and don't run out of stack space. 

By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

You've got a nice idea, planning for extensibility. There is one issue that I see with the way you've implemented it. 

If the block throws an exception, give priority to this exception. The exception thrown by is added as a suppressed exception, and the modified exception is thrown. If the block did not throw an exception, allow the exception from close to propagate upward. 

I'll leave an in-depth analysis to the true Python experts, but here are just some quick notes: Variable and function names: As far as I'm aware, variable and function names should have words/elements separated by underscores (e.g., , ) main() function: Instead of having your functionality on the first/default level of indentation, it's good form to wrap it in a and call it via: 

I'm being forced to use the common anti-pattern of a which many classes in this project implement. Long story short, I need to have a constant which is pre-populated with values. Normally I would do this like so: 

Your code is really good and very well written. I think that's why you haven't received a response; not much to critique! You have good comments, good style, pretty much good everything. I wish I saw code like this in my production environment. The only thing I noticed that you might clean your code up a bit is this part: 

I think the biggest thing here is that you need to create some functions and encapsulate stuff. Big Points 

Constants should almost always go at the top of your classes rather than being spread out through the file. Same with inner classes, as a matter of fact: group them all together either at the top or the bottom of the main class. In general, I tend to lay out my classes like this: