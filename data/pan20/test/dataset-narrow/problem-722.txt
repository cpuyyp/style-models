First of all, you are right, what you have there is not a builder class, but more like a factory class. Which is roughly equivalent to a static factory method. Now, the question of using constructors vs static factory methods is one over which there has been a lot of talk, and for the most part no conclusive, universally-applicable answers. (Just search for "c# constructor vs static factory method" and you will see.) However, specifically for your case, where both the constructed class and the code constructing it are private within another class, the advantages of "discoverability" and "recognizability" that the keyword has are not applicable, so I'd definitely go with a factory method or class. With regards to whether you should be using a factory class or a static factory method, I think that the factory class is fine. The overhead for the generation of an additional object which gets immediately discarded is negligible, (especially compared to the amount of work that the object will do,) and might even be optimized away by the compiler. On the other hand, having a factory class instead of a static factory method could turn out to be useful if in the future you decide to introduce some state into your builder. 

Version A is definitely better, as it employs a more familiar pattern to get the job done, and it makes use of bit of trivial code () to save you from duplication of non-trivial code. () I would trivialize the trivial code even more, by saying right before entering the loop, and as the last instruction of the loop. Note that even though this is two lines of code instead of one, its complexity is smaller, because it deals with constants, not with variables. I could perhaps give more advise if you explained what you mean by 'algorithm to position boxes in a grid'. A grid is generally thought of as a two-dimensional structure, but I only see operations in one dimension, on variables which are defined outside of the code fragment that you provided, so... what is this code trying to accomplish? 

Another solution would be to properly filter your input. It is easier, and it is also more dangerous, because it is easy to miss something. For the example at hand, you need to parse the user input into a number, and then convert that number back to string in order to append it to your SQL string, as follows: 

You could, perhaps, derive RecursiveObject from FlatObject. In the degenerate case in which all objects belong to a single lineage (every object has one and only one child, except the last one) and you have lots of objects, then your recursive method will try to use an awful lot of stack space, possibly failing with a stack overflow exception. The way to correct this is by avoiding recursion and adding a stack data structure within your function, which then works in a loop. But of course you would not want to do that unless there is a very clear possibility of such a degenerate case ever occurring. 

This class has a well defined role and by keeping it intact you are satisfying the Single Responsibility Principle. So, I would leave it like that. Perhaps you might want to look into how you could refactor some common code out of each method and into a separate utility class, but that's all. 

As GregS pointed out, macro arguments need parentheses. does not really do what its name says, nor what the comment above it says, because when we say "whitespace" we don't only mean the space character. You need to use from to tell if a character is whitespace or not, and this applies to all places in the code that compare against the space character. The comment looks like it has been added after the fact, in order to describe what the code will actually do, rather than to specify a requirement for the code. I would suggest that you replace it with a comment saying , because if you ever decide to implement that function differently in the future, you don't want to have to do tricks in order to precisely emulate the bizarre functionality of the old version, do you? Obviously, will fail if it is ever given to parse some text containing a word larger than some buffer, and the way it is written precludes the possibility of ever having any control over this so as to prevent it from happening, because the size of the output buffer is not passed as a parameter. In the test code, you would have a failure if you used a word longer than 100 characters. You might say, "you gotta be kidding, who would ever write a word longer than 100 characters?" One answer is, my son did, when he was 1.5 years old, and got a hold of my computer while I was in the kitchen, and he typed his first word document by holding the z key down for a couple of minutes and watching the 'z's fly by on the screen. If Microsoft Word was using your code, it would have crashed. Another answer is that this is precisely the kind of stuff that buffer overrun exploits are made of: the hacker will intentionally give the kind of input that the programmer did not expect. 

within a class scope, the Extension object seems to extend the calling objects prototypes allowing me to bind a callback within the class scope. And then attach a handler after I have instantiated the class. 

Don't use jQuery to... Modify CSS unless it is absolutely required (ie CSS alone can't achieve what you want). In this case CSS can handle you're requirements easily. If you find you need to change a lot of CSS and would like this CSS to change due to a jQuery or javascript event. use and . Applying the styles in CSS rather than in jQuery. This is far more efficient in terms of code and your eyes. :) Cache your jQuery objects 

The logic is really confusing me, I understand how call() and apply() work in the simple example above but I have no idea how or why the prototypes of the object are extended when I call . Could anyone help me shed some light on this? 

There is nothing wrong with this approach at all. Rather than say you should or shouldn't do it any other way I'm going to give you an alternative approach that allows you to write less code in your file. I've noticed that your deals with a lot of different types of requests. This can get very hard to manage when your application grows. It's a good idea to separate out your controllers into manageable classes that deal with one area or feature of your application. The example below would ideally be in a class for example. Taking this chunk: 

There is some form of JS voodoo going on here that I can't programatically work out, can anyone help me shed light on how JS is interpreting this and why when I call: 

It's fairly obvious what .call() is doing in context. I recently came across some articles that went into depth on abstracting the .call() function. The premise is along these lines (this code is verging on pseudo code as I have stripped it down for ease of reading) : 

Only functions parenthesis start on the same vertical. Objects and arrays are always indented 4 spaces beyond the function. 

I agree with Gerard a little, you have made (in my eyes) a common error with interfaces where you've tried to make them specific to a certain type rather than what they actually do, I see this a lot in the wild (excuse the pun). This isn't to say that interfaces based on type are bad, they have their place but in general an abstract would be better suited for types as types will have unique properties that you could not declare in an interface (nor would you want to). As an example I'll elaborate on the "Dog is also capable of chasing" example. Declaring a as makes no sense when trying to describe what a Dog is, instead, make it capable of doing something. 

Make your code scalable By this I mean using techniques that allow you to do some relatively advanced things without the need for re-writes / re-factors in the future. One of these is to bind events to a lower level element with rather than or . If in the future you modify the menu for some reason with jQuery/JS and DOM elements are removed / re-added, event bindings will be lost. Using avoids this problem. Refactoring your code I've deliberately not included any CSS changes in this code as you can and should include these in your CSS rather than dynamically with jQuery / JS. I have however added and removed a class, this should contain all the style changes required for the mouseenter and mouseleave events. 

Normally it would disgust me, but you appear to have a valid reason to use it, which stems from the pre-existing disgusting situation that you have to cope with these data objects that use ints. The only thing I would ask is, why can these data objects not use enums? What is it about their auto-generation that precludes enums from being used? I do not think that enums receive any special handling at the IL level, they are handled just like primitive types are. 

By looking at your code it appears to me that your basic problem is that , and are distinct boolean variables instead of an . If you just turned them all into an enum things would be a lot more simple, there would be no possibility of inconsistencies between their values, and you would not even have this multiple-choice issue. 

is an awful name for a class. The name of a class should always be a noun. No exceptions. Read-only fields should be marked as read-only using the keyword. is an awful name for a function. It does not give any hints as to what it means by 'File Status', nor any hints as to what it means by 'Checking' it. Looking inside, I see that it performs operations that change the state of the system, so 'Check' is an awful choice of a name for what it does. When a function begins with 'Check' it is supposed to return and to perform absolutely nothing that would change any state anywhere at all. No exceptions. is not a good name for a function that checks whether a file is empty, because it may be confused with a function that actually empties the file. Call it instead, and make it a property, not a function. This is lame: 

If you cannot modify , then write two helper methods, one for getting and one for setting the value of the day member of : Each method has a and modifies the appropriate member of . Good luck and have fun. 

There is a much, much, much easier way to do this. You can use real values for order, so when you want to move the row from position 16 to position 7 you give it an order value which is the average between the order values of rows 6 and 7. The precision of real numbers is huge, and I presume that the re-orderings of images in your database will be happening at human reaction speeds, so you probably won't run into precision problems during the remainder of the expected lifetime of the universe. But if you are really insecure about the possibility of precision problems, you can rectify your table every once in a while, by reading the rows sorted by their order, and writing them into a new table, re-assigning the order values by copying them from an integer identity field. Then you delete the old table and rename the new table to the old name. 

Add a parameter of type called, say, . Replace the fields , , etc. with a that has a key of type and use to access values within that dictionary. Do the same for your , etc. global variables. (For which you will burn in hell, incidentally.) 

I think you should add a numeric field indicating the order of a card relative to the other cards. You do not need to use it for anything other than sorting. Also, instead of taking the identifier of the enum value and doing uppercase and lowercase tricks with it in order to turn it into something presentable to the user, you should just store the name, too, as a separate string in the enum. So, it would look like this: (where 0 indicates lowest order for sorting.) Furthermore you can also add one more number, the 'weight' of a card, to use in calculations which determine whether a card beats another. In general, enums in java are very powerful, so powerful that you pretty much end up not having to use the switch statement with enums anymore, because you can include a big part of an enum's functionality within the enum itself. 

The main advantage to this is that the class can be extended easily using other design patterns such as a Facade that further simplifies the class API. It can also be added to easily with further methods within the class body itself rather than by a pure static call. The class can also be instantiated with the keyword providing the ability to create separate cache instances that utilise the same static properties and methods. I need to add this class is very much a prototype that I thought of when I saw your class above. I love cacheing stuff in general and providing standardised interfaces for it is always a great thing to do across all applications you write. 

The difference is that your routes are mapped to the controller methods. Your GET route would map to the method in the controller. While the POST route would map to in the controller. Also, the GET route would be handled by in the controller. Changing the routes is a case of changing the controller methods. This means one place to change your routes rather than two. 

First things first, you're creating no less than 5 jQuery objects for each time someone hovers and moves out of a menu item. Two things on this : 

You're jQuery can be written in one simple function as a catch all for the entire navigation. As you stated you think it could be condensed, you'd be right. As a rule of thumb if you see yourself writing the same thing over and over you should be able to cut it all down into one function. Starting with one of your methods I'll step through it to show how you can condense this and make it more efficient. 

Going into the nuances of having a single Cat that can bark out of a set of possibly hundreds of Cat instances is beyond what you're trying to learn but I'm hoping you get the gist of where I'm going with this, behaviour as interfaces generally work better than types and give you a lot more flexibility when actually determining what your classes do. I'm making general statements a lot here, but you will see that your interfaces become very specific to actions. As such they are smaller and make more sense. I have found it much easier to have a class that implements 5 smaller interfaces than 1 or 2 monolithic interfaces due to the increased flexibility available and it keeps things DRY. 

I'm unhappy with the one jQuery call with $.extend() but this proved the easiest way to accomplish an object merge and I use jQuery quite predominantly in the majority of my projects. Despite that can anyone suggest a different way to do this? While this works fine I know it's far from perfect as it's limited to one search term. My thought was to add in another loop within but I'd prefer to avoid doing that, my second thought was to map the object and perform the lookup once I'd found an object with the first property match. Again any suggestions on how I might accomplish this whilst keeping the script clean and fast I'd really appreciate it. Any other suggestions welcome, thank you for taking a look. :) 

I've written this relatively simple class to help with managing arrays of anonymous objects in my scripts. 

So you now have interfaces that describe what they do. It now makes sense that both a Dog and a Lion can implement . Not only this, any animal class you create are capable of using it without semantic issues. Your interface suffers from the same problem (to a lesser degree). Having a canine interface is probably not a bad thing, declaring that canines only bark or howl is true. Is it true to say that no other animal species can bark or howl? what happens when this cat turns up on your doorstep? (stupid example but I found it amusing) Cat videos aside, we now have a strange edge case where a cat is displaying canine behaviour, but it is not a canine. Enter the interface (that I find both funny and embarrassing).