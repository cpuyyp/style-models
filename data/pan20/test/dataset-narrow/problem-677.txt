Bingo. You're assigning a non-const, non-rvalue reference from a temporary, which is actually not allowed by the standard (and my compiler rejects it correctly). However, even if it were, you'd have a problem anyways: Since the lifetime of the temporary ends immediately, you now have a dangling reference that points to an invalid location in memory (= a location where no object of type lives). Doing accesses through such a reference is undefined behavior, and thus your whole program becomes undefined. Fixing this, however, is not at all difficult: Just remove the reference and let be a normal object of type . In general, avoid using references as members unless you are 100% percent sure of what you're doing. In almost all cases, you are running a high risk of shooting yourself in the foot and blowing your whole leg off in the process. Regarding As far as my knowledge of the STL goes, there is no single function that would do what you require here. However, I came up with an implementation using both as well as , which, in my opinion, is about as concise as it will get: 

These tips are just that - tips. There is a lot more to be said about your code, I'm sure, but I will leave that to someone with a little more time on their hands. The biggest improvement you can do to your current code is, to my mind at least, putting those globals in their own struct. This will put a lot of people more at ease using your code and make your whole program more idiomatic. 

This review is not comprehensive. There is likely much more in your code that needs to be addressed, but as it currently is with code structure and readability, I am unwilling to spend my time analyzing the logic of your code (maybe someone else will be kind enough). I suggest you read my suggestions, then take a look at a good C++ book, then read the C++ core guidelines. Afterwards, you should improve your code and submit it for a second review. Do not become discouraged, writing good code is hard. 

Is it good practice to have a debug function that is dependent on preprocessor flags defined in the normal header and source file, or should such functions only be defined and implemented in test files? Are there better alternatives for error handling? I realize that passing two callbacks to a function is not the optimal pattern, but just logging to cannot be the right way, and integrating an error code into the return value would mean adding another layer of s which does not seem desirable either. In the same line of thought as 2., should a library-like function like this just be allowed to call when encountering an error that makes successful program continuation extremely difficult (such as an out-of-memory error), or should the task of terminating the program be left to the calling function? If yes, how should the information that such an error has occured be passed back? 

Much better, isn't it? Actually, seeing that is only ever one character long, why not make it type instead and use the convenience of a switch statement? 

Review Requests Please feel free to review anything and everything that comes to mind! That said, I do have a few concrete questions: 

There is a lot of room for improvement here, but first, let us talk about code style and best practices. 

is misleading because can also fail if, for example, the file exists but you have no reading permissions for it. 

Remove the include guards from your files. They are unnecessary (see point Must change/1). Leave some space, vertically as well as horizontally. For example, let's look at 

instead. About Time Complexity You state that your code is \$O(\log n)\$, which is obviously incorrect. The reason for this is that you need to iterate over every char in your input file, which is an \$O(n)\$ operation. Although you are right that inserting into a BST is an \$O(\log n)\$ operation, this term considers the size of the BST for \$n\$, which is separate from the length of your input. About Memory Problems You say that you are afraid of memory problems, but you really do not have to be. Apart from the missing in your -loop in (see Memory Leaks), I did not spot any problems with forgotten s or the like. The functions and are a bit of a performance issue because they do so many allocations, but if you stick to the tips I gave you then that should be fine. If you are worried about running out of memory, don't be. There is hardly anything you can do against it, and exiting gracefully if a call to or fails is really the best you can do. One could argue that you might run into memory fragmentation problems because of the tree data structure you employ, but this is very difficult to work around. If you are really concerned about memory usage, e.g. because you process gigabyte-sized files, there is one optimization that you could apply: Instead of making separate copies of each word you find, just store offsets to where the word begins and ends in your memory buffer. In the best case, this could roughly cut memory usage in half (although maybe a 20% improvement is more realistic, but I am just guessing anyway). As I said before, you could also try replacing you BST with a normal array, although this will, of course, increase the cost of inserting elements quite drastically. 

is dangerous for containers which offer RandomAccessIterators, but aren't contiguous. In particular, invokes undefined behavior if and do not belong to the same memory area, which they might if the underlying container is not contiguous (also, sometimes is overwritten, which can cause a lot of problems on its own). To prepare against this, I would advise you to rename to or something in that line of wording. You are probably aware of this already, but your code is not really portable. For one, there is , which is a gcc builtin. Also, is a type from , which is a posix header and might not be available on non-posix-conformant operating systems (also, you do currently not include this header, which is a bug). is easily replaceable by in most cases, but if you care for that much of correctness, you could also write something like and use that instead. For , if the optimization value you get by using it is really that important for you, you should wrap it in some compiler identifying macro. If it is not important (which is probably the case), you could do a variety of things, for example replace it with a expression or just return a default value. is a very confusing template parameter name, at least to me. I would expect it to stand for "random number generator", which is not fitting here. Choosing a different name would likely be beneficial here. You should consider passing s instead of separate iterators. This makes clear that one begin- and one end-iterator always belong together, and helps cleaning up the parameters of your functions. . Please don't. This code is just ugly. The reason is that 1) you are relying on implicit conversion for all your values (why not write instead?) and 2) there is no reason here to use at all. Stick to integer types unless you do something that actually requires floating point features. 

Don't use . You are going to run into name resolution issues down the line, and the additional five chars () every few lines are not going to kill you or your productivity. Don't use relative includes (such as ). This is prone to breakage if you ever change your project layout or move files around. The right place to specify what directories to consider for inclusion is your build script (or, in the most basic case, the command line invocation of your compiler of choice). Don't use as the null pointer constant, use . The latter has an added layer of type safety. Don't use and friends. Since C++11, the standard library contains a much more fine-grained and flexible support for random number generation. Take a look at the random header. Why did you write as opposed to ? There is no need to use a pointer here. In fact, in modern C++ a raw pointer is indicative that something is not right most of the times. This is true for every single pointer usage throughout your code; none of them are actually necessary or useful. is far too long and overloaded with code. Split it up into multiple smaller functions with a clearly defined purpose. This will make your code much easier to read and correct. Relating back to point 5, don't write constructors of the form . You want to copy here, so you should write a copy constructor. The signature for , for example, should be . However, sometimes C++ is nice to its users: You actually don't need to worry about copy and move constructors unless your class does something fancy; C++ will implicitly generate them for you. Pass types which are expensive to copy by reference or reference. In particular, should be passed as in most cases. Use for-each loops when looping through a whole container. For example,