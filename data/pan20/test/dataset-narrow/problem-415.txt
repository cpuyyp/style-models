If you want keep something for the part then introduce two local variables to store the hash codes. There is also the general requirement that if two objects compare as equal then their hash codes should be equal. While this is implicitly caught by the tests I'd actually consider adding another test which checks that explicitly. 

You could make a class similar to your class with a virtual however that's not a good idea for the same reasons why it's not a good idea for . Make virtual in all factories. Easy to forget. Create a marker interface and use that instead. Smells. 

This way the mutex will automatically get unlocked when the lock guard goes out of scope (either via return or through an exception). 

It has also the advantage that the application code doesn't have to know what menus exist so they could easily come from a database or other configuration file. When adding a new menu no code has to change. Example implementation could be: 

since will automatically insert elements for you if the current size is smaller than the requested size. 

"reasonably safe against deadlocks" is a strange expression :) In the can be turned into an . Your code in indicates that some exceptions might be expected because you handle them and continue. The problem is if that happens while you have the semaphore acquired then it will not release it. You should move the release into block. In you join on all threads in multiple places and this code gets repeated several times. Should be refactored into a method. I'm not sure what the point of the semaphore is. The way I read you code is: 

Given that is probably around the order of and that the scaling is more or less an arbitrary choice you could just not use for the . 

This will prevent anyone from changing the map obtained via . Make your class implement which allows iteration over the internal map rather than exposing the map through a get function. Return an from (and probably call it instead). 

These may make sense now but in the future (say 2 weeks from now when you've been deep in another part of your game's code) it might not be so clear why you chose these numbers. So in order to make this code a bit more readable and maintainable I would suggest making them constants (or at least variables depending if they're changed or are calculated). 

In addition to the already existing answers I thought it be wise to add some things they may indirectly affect your application's performance. What I mean is these suggestions don't necessarily help your performance but they can make it a lot easier to understand and debug your program a lot easier (both you and others). This can allow you to evaluate the performance much easier and faster. Naming doesn't quite tell me anything about what it's purpose is other than determining if the state is 'happy'. Something like or is much more clear in its purpose. Which you already have a variable for so why not use it and subtract the final day before you print (or even after the loop). Hungarian Notation is quite unnecessary additionally you're only using it for two variables. is just as clear in its use and purpose as (as the 's' implies a collection) your functions and classes shouldn't be so long that you need such a naming scheme. Intuitive Try to keep your code as intuitive as possible so that others (or you 6+ months later) can understand it quickly. These suggestions might just be me but I think at the least they can demonstrate what I mean. The goal is to compare the plant to the one at its left. So why not start at the second and go until you've reached the end? Here is some pseudo-code to demonstrate/explain what I mean about intuitive code: 

I probably got the purpose of the magic numbers wrong, but I think you get the point. Make them have a meaningful name. Worst case scenario you give them as good of a name as you can think of and place a comment above the const/variable declaration describing its purpose. Minor Suggestions 

First, bear in mind that does not place a terminator at the end of the string if the buffer size limit is reached (but it does in every other case!). Thus, you have to be extremely careful when using . Second, you're copying a large (256-byte) buffer into a smaller (100-byte) buffer, and you're (presumably) passing the length of the larger buffer to . If holds a string that's too long, you'll get a buffer overflow. 

Now and point to the same object, but they are distinct variables. Now let's do something funky with references: 

However, it looks like you're deleting the trailing newline returned by . I'm not even sure your code works. 

The good news is, we can get rid of the multiply and even the shift! Just increment by 5 each iteration: 

Let's look at the line, which looks wrong to me. Here's the condition we want to test (simple, but inefficient): 

I wrote a string escaping function in C, and I'm trying to rewrite it to Haskell. The C version, along with comments explaining why it does what it does, can be found on GitHub. Here's a naïve implementation based on : 

gets all remaining input, using lazy IO. The second call to throws an error because the first call has already claimed the data, in a sense. What I would do is have a separate thread tunnel data from the handle to standard output, and have the main thread tunnel data from standard input to the handle: 

This made a difference. It's even slower, 300 times slower than the C version. I thought blaze-builder was supposed to be really fast! Simply summing bytes, by folding over the input in a similar fashion as I do above, is reasonably fast (takes 5 times longer than the C version of the escaping code): 

If you don't like writing out the transformations "backwards" like this, you can use the operator from Control.Category: 

The biggest obvious issue is the violation of encapsulation. All methods which allow you to modify the id set are public which means that outside code can change it and break the inherent assumption that each instance will have a unique id. The only code which should be able to modify the id set are the constructor and destructor. If you now say "ah, that won't matter it's just my code and I know not to do this" - programming is a skill and like any skill you get better at it through practice. Which typically means writing code. Therefore you should take any opportunity to practicing writing good code since that helps to form good habits. There is no excuse for being sloppy. This: 

Adding additional braces and formatting makes it very explicit what the scope of each loop is and adding additional statements you're less likely to accidentally forget to add a brace. 

Update: Turns out that enums generally don't implement . The best option in that case would probably be to allow the user to optionally pass in an defaulting to and again not impose any additional type restrictions. 

So my general advise would be: Create a dedicated class which encapsulates the board access and operations performed on the board. As backing store I'd probably chose a 2d int-array representing the cells. If you need to print it on screen you can have a convenient output method which converts it into the string representation. This will get rid of a lot of unnecessary converting to and from strings and should result in some speedup (how much exactly I can't say). It will also provide a starting point for a better code structure. 

Why do you initialize with a default initial capacity of 10? According to the Java documentation the default initial capacity is 11. Why is 10 any better? 

In this case there is not much code and it's not terribly complicated but you should get into the habit of choosing good names. is not a good name for the as it doesn't represent a dictionary in itself - it's a reader which reads lines from a file. All your code is in the method. You should get into the habit of building reusable pieces of code - in the case of Java this means creating reusable classes. So I'd suggest your create a dedicated class which holds your lookup structure and provide as well defined interface for adding valid words and looking up a word. Something like this: 

Above the consent checkbox is updated just like in your original code. Then afterward we update each element based on and the validity function of each element. Conclusion This got really long really quick. Anyways, my goal with this was to help you make your code more modular since it appeared to me that it was causing you some possible confusion (based on conversion in the comments of SirPython's answer). So I hope this helps you with that, whether you go with my solution, SirPython's, or your own. JSFiddle: Here The fiddle only has the logic for a simple "is empty" check on the "email" input, but I hope you can see the potential. 

Sometimes it seems unnecessary when you're doing OOP in a scenario in which you could easily do it all in one function but it helps significantly when debugging, reading, or maintaining (or in this case when other's are reviewing your code :D). 

Updating a Single Liberty You need a function that does the / update that you do 8 times in your function. Something like so you don't need to copy/paste the if-statement for checking a single liberty when you have 4. 

Method Extensions I've found it incredibly useful when dealing with Selenium to create some method extensions to do some common activities for me (instead of having to code the same things over and over again). 

From this line we quickly see "Downloaded Applications Remove all". So does this really add any value to your code? It seems like that comment just adds clutter. Clutter & Variables used only Once You want to reduce your for-loop there's a few things you can do aside from the typical suggestions you're going to find (i.e. Modularize into functions). One of them being reducing the number of declarations you have (if conditions allow). For example, both and are only used once. If you know you are only ever going to use them once in this scope/context just remove the declaration and use the value where needed. Another quick note, I noticed you're declaring , , and towards the top but not using them until the bottom half of the for-loop. Why not just declare them right before you use them? That way it's obvious where they are being used. RuntimeDetails A key place you can reduce the amount of code in your for-loop is your instance of . appears to be getting its data from 3 core places: , , and . 

Your current code finds "holes" in the numbering. If that is not required (or desired) then you could parse the numbers of the end and find the max and return max + 1. Something along these lines: 

Maybe it's a result of your simplification for the example but your looks like an over-engineered enum to me. What do you gain from it over using an and a for the current state? In general whenever you need to check for the specific type in order to execute some specific logic then your abstraction is probably flawed from an OO point of view. One design I've chosen in the past for more complicated parser is to have the state execute the transition. Something along these lines (does not compile just showing the idea): 

Is there a particular reason to use for the parameter to ? It doesn't seem exactly necessary and I usually prefer methods without side effects. reads clumsy. I would rename it to something like or . You should take a bit more care naming method parameters. Parameter names form an important part of the method documentation and should convey their intent clearly. For example here it is not exactly clear what and mean: 

Clearly formatted code is a lot easier to read, maintain and is less prone to contain bugs. Naming is inconsistent as well, e.g. vs vs . There is no need to place braces around the value like this: . It should simply be . is not a function call. In order to append blocks to the end of each of the lists you currently iterate to find the end. It would pay off to keep a tail pointer pointing to the last element of each of the lists which avoids that. I think there is a bug when calling on the last block allocated. Example: 

Space required is 2 * O(n) (array and final string) and time is 2 * O(n) (encoding string into array, building final string)