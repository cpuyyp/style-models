I'd say that there is no "right" or "wrong" argument about which of these approaches is correct. The last approach is perhaps a little quicker to read exactly what it's doing since the routes are all laid out there for you and the handler function is all right there and there's no mixing of the logic of the two, but that's as much a personal opinion as anything else, not really a firm argument one way or the other. 

The other statements are what you do from a handler to turn the promise chain into a rejected promise. You could also do , but works just as well. 

Here's a description of how the code works: cycles through all the images, calling a custom function for each item. The return value from the custom callback is added to an array and the final result of the call is an array of all the returned values. returns from the callback, the promise that returns. So, when the is done, it will have an array of ajax promises. passes the array of promises to which then waits until all the promises are resolved (e.g. all the ajax calls have completed) before calling the handler. In the handler, the results of all the ajax calls are passed as arguments. Each argument is an array of length three. in each array is the returned data from the ajax call. is the status from the ajax call, is the jqXHR object from the ajax call. In this case, you just need because we already know the status. So, then handler cycles through all the object passed to the handler with one array passed as an argument for each ajax call that was executed and the in each of those arrays is the ajax result. Then, after processing all the ajax results, is called. 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

Currently each future processes elements (increasing the increases the total workload ()). Instead you want to divide the workload between each of the futures: 

Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

As sorting by frequency works for every input type and not only strings, I would use a parameterized class instead of to support all types. Possible implementation: 

Besides that I would rename the method as it prints the combinations, with the current name I would assume that the method returns the combinations. permutation This method is effectively a recursively written loop that returns the product of the range (=factorial, thus method should be renamed to factorial) and thus can be replaced with: 

In the array version you can use post/pre increment and pre decrement (most likely no difference in terms of performance but shorter and in my opinion better readable). 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

Current implementation You can reduce the variable scope of your static variables by accepting the array input as parameter and returning the queue. You are currently iterating the queue three times if the queue contains the word (, iterator loop, ), this can be reduced to one iteration by only using the iterator. 

A further optimization will come from not using as a loop counter. You can determine if the loop is completed by looking at the array index. 

Not only does this clobber the registers , , and , it also uses the instruction variant that produces an 128-bit result. Intel advices against this form when the upper 64-bits of the result are not needed which is the case in your program. A better multiplication then comes from using the 2 operand form of . 

Your code performs 1 iteration too many! Consider then this code will jump back to outerLoop when , but there it will instantely be incremented to and so the code will superfluously process the case where the control variable = upper limit. 

You didn't initialize the register because you know it has the correct value from the code above. That's fine but given the separation between setting it up and using it, and considering the note you've included, ... 

Because all of your variables Sum, CurrentPrime, CurrentN, and PrimeMode reside in registers your code could/should benefit from this fact. You've calculated using: 

And here you only want to increment the qhigh variable when there's a carry from the previous operation 

This is a misconception. The following only depends on and for its operation. It will leave a result in DX:AX, but does not have to be initialized beforehand. 

You've used a WHILE-loop here. A REPEAT-loop would have been more optimal. Also a better way to zero a register is by -ing it with itself. Furthermore by using the register you eliminate the need for the and : 

You don't even have to compare to 8 at all! When you shift the counter in 3 times to the right in order to find out how many qwords you have to process, you can look at the zero flag. If the ZF is set (meaning no qwords at all), you instantely know that the counter is in the range [1,7], and so the above snippet becomes: 

(I would initialize with a ternary operator instead.) Types As the values of , and are always in the range , you can use instead of for these variables, arithmetic is likely to be faster than arithmetic. Alternative implementation The remaining range is quite small -> you could cache the results for every number in the range to avoid calculating the sum on each invocation. 

If you cannot/do not want to change the interface, you can use an intermediate abstract class to have the forwarding method only once for all implementations 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

Alternative implementation Your current implementation supports arrays with a maximum length of 30, you could provide a method to support arrays with up to 64 elements (or a larger datatype than to support way larger input arrays). 

MyWord Your / implementation is not conform with the specification of - equal objects can currently return different hash codes. The implementation of should return the hash code of instead of . The constructor performs no argument checks -> it is possible to create i.e. an instance with , which will lead to s thrown by the method. The method could return . Alternative implementation A priority queue is not a good data structure to determine the frequencies as you have to iterate the queue for each input element. You can use a to convert the input array to the frequencies with complexity (plus additional to sort the resulting frequencies, or to create a heap). Using the stream api this could be written as: 

The implementation 'does not count' as it overloads the method and does not override it. You can use generics to specify the expected parameter type. If you can change the interface: 

In this case, it makes no difference at all. This IIFE really has no reason for even being there because all it contains is a single function. Your code does use any of the usual benefits of an IIFE (like a local and protected scope) or capturing the arguments in a closure. So the additional code that doesn't have any local variables of its own and doesn't use the passed in argument does not benefit at all from being in the IIFE, but there is no harm in putting it in the IIFE either. 

You could also remove some redundancy from the table by making the table only be the steem method name you want to call. 

Creating modules to contain shared code is a generally good idea. But, when working with async functions and their responses, you need to make sure you preserve full async response and error handling when you write cover functions that use async library functions. In this case, you missed some of that, rendering your cover function not fully functional. In addition, when covering a built-in function, you should pretty much make sure you're adding enough value to justify a new interface. Simple defaulting one argument is probably not enough change/improvement to justify creating a whole new set of functions that someone learning or modifying your code would have to become familiar with in order to be productive in your code (which would not be an issue if you just used the standard functions). 

If you don't actually need or type behavior, it's even more performant to avoid the need for event propagation and bind the event handlers directly to the input elements themselves so no selector matching must be done on each key event: 

Just call initially rather than duplicate its code Generate the 5 items in a loop since they are all the same code except a name which you can generate with code in the loop Store the 5 items in an array rather than named variables so they are easier to iterate over. Use only one timer and process all five items in the array from that one loop. Switched to just using one paper object instead of 6. 

Here you need to verify your understanding of the count in . It specifies the number of characters that you want to draw. The hexadecimal value 1000h equals 4096 in decimal, but the usual 80x25 textscreen only has 2000 characters to play with! In your program it seems to work OK only because the video memory is much larger than that single display page you're looking at. Nonetheless you should correct it to avoid developing the bad habit of buffer overflows. 

Smaller instructions are generally better With the 32-bit immediate value, the instruction in the MainLoop is quite long (7 bytes). You can store the zero in and move that to memory. This also eliminates the need for the mention "qword ptr ": 

My version. The worst case runs in 108 cycles. This happens with values from 190 to 199. The best case for this code runs in just 44 cycles. Not surprisingly this is for inputs from 0 to 9. I personally don't like the decimal mode of the 6502 and so this solution doesn't use it. 

What this BIOS function returns in , , and are the highest allowed values for Cylinder, Head, and Sector. Cylinder of course also partly in ! I don't think there's any reason to believe that the total number of heads could never be 256. If BIOS returned (indicating 256 heads) your code would simply fail. I suggest you define the hdPerCyl variable word-sized and set it up using: 

The way you find out about the number of left over bytes is too complicated. It's correct but needlessly involved. Basically all it takes is anding the original counter with 7 to extract the lowest 3 bits. Simpler, shorter, and using one register less which in future programs will always be handy: 

In my opinion returning an is the best option as the method requires ints, anything else would imply additional conversions. 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

For O(1) performance you could precompute the factorials for values up to 12 (all factorials in int range). 

calculateCombinations Your method does a lot of not required iterating. You only have to iterate up to in the outer loop as afterwards the if statement evaluates always to false (-> you can remove the number variable and thus the call). The value of and is the same on each iteration -> you can drop the variable. The if statement can be removed by starting the inner loop at . The resulting code would look something like: