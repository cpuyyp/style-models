Make sure to have a look at the flash script to see what they do with dtoverlay to get access to the I2C; you might need that if the system is in an unfriendly state. 

Your Ubuntu box is blocking outbound TCP/22 to specific IPs or interfaces. There's basically a zero % chance of this because you can get your LT to talk to the Pi sometimes (i.e. when the pi is wired). Your Pi has some form of SSH interface listening interface or firewalling configured. I'm thinking this is unlikely, as you'd likely remember you did that through something like ufw. Your router/AP is blocking packets bound from one wireless station to another. I'm thinking this one's likely, as it's just a check box in your router's UI. From the TL-WR841N manual 

There's no particularly good way to make the board as-delivered make sound. Audio by default goes out over HDMI (which is the best option IMO). You can pop a relatively simple lowpass filter and amp on the alternate function of two GPIO pins for PWM (cheap and not horrible audio). I did a project like that for a little gag gift I have a co-worker last year. See adafruit's site for details. Alternatively, you could hook up an I2S codec or just use a low-end USB speaker with built-in codec.. You might even be able to jam the zero into the speaker chassis itself if the dimensions are right :-) 

You need to add a condition in that While loop to let it break and then process your Flask code. Currently, its just going to spin in there forever and never complete to allow the flask route method to end and return the result to the client. You might want to consider pushing the while loop into a method and having the start that as on a thread via add to top 

Best bet is to ask the supplier for support since by the looks of this was built for the Pi. There doesn't like like anything in that script that should cause problems but since it is, a few suggestions that might work. The blunt approach would be to just run it as root via then and see if that makes it happy. I'd tried this in a Raspbian Jessie Docker container as root after copying in boot and creating some of the directories that you should have if you have have the GUI and the script ran to completion. That said, it worked fine for a normal user + sudo too. You could try running the command as in case its relying on some special environment variable, which i can't see... or might work in case the shell isn't quite interpreting the lack of shebang directive at the top correctly. 

There is no problem using any Linux host (pi included) as both server and router. As long as there's not some port 53 port forward, it'll serve on your pi's ip just fine. You should probably understand, however, that routing usually makes sense only when more than one interface is involved. This can be two Ethernet NICs, an Ethernet and a wireless, or some combination of those and a virtual interface like a VPN, VLAN, or similar (or really, any combination of any of these). And forwarding is not the same as connection sharing (related, but different). Plus the hosts intending to use your device as a router will need routing updated to use it (e.g. by using it as their default gateway or similar). In short, there's way more to making routing useful than what's in the linked guide. So be careful and have fun learning how all this works! 

This board appears to use the SPI interface and some additional pins from the old 26-pin RasPi connector (their claimed compatibility with the various plus models tell me that the minor changes to the header since 1.0 don't affect them much). This particular panel is designed to attach directly to the Pi with no intervening cable at all. SPI is not a hugely tricky protocol, so you might be able to get away with an extension cable if you need some distance between display and board, like this one from Adafruit. But otherwise you should be able to line up pin one with pin one and plug it right in so the Pi and the LCD are front-to-back. Getting the software to drive it configured correctly might be the trickier part, but it looks like the guys have their own preinjected Raspbian image for that.. $20 is decently cheap for what you get; I'm tempted to get one myself and try it out. Good luck! 

I'm setting it for 50%, you should be able to control it via the UI though. Now you should be able to fire up whatever you want on your phone and it'll play over Bluetooth. I had issues where pulseaudio (via pactl) needed muting and unmuting a few times before it would co-operate. If you aren't using a desktop (Raspbian Lite / Arch) then you probably won't have PulseAudio running by default and you'll have to do some extra work. I've got this working too but it's a little more involved - I can update this with those steps if that's what you are after. There are errors in the Bluetooth log will probably show them. The Sap one can be made to go away if you really want (you tell bluetoothd to not load that). I've never looked at the RFCOMM voice gateway one.... 

Both DD and the disk imager will 'naively' just create an exact replica of the SD card, empty space and all hence why they are 16GB. These backups you can simply image directly onto SD card and its back where you left off. If you want to snapshot your compilation process outcomes you might want to look at alternatives to entire backups. Using Docker containers would let you incrementally build on what you have done by committing the containers at each step and only pay for (in storage terms) the differences between each version. There is a recent Raspbian base image on the docker hub for the Pi which should give you an accurate enough base system, you can even copy your existing work directly into it to avoid starting from scratch. If you want to backup your work now, you only have to export your docker containers which will be Base Image size + changes, probably under 1gb. This way you can test anyway and if it goes south just bin the image and return to a known good state. 

I am running "Sixaxis" PS3 controller on RetroPi (RPi 3). In the beginning i had some trouble but following this tutorial i could pair the controller without issues. They are working great with the RetroPi. On this Github site is a list of other controllers and how connect them to the RetroPi. But mostly there are no comments how good they are working later. Imho the PS3 controller feels little bit more laggy than on the PS3. This is my very subjective experience... maybe this would disappear with some tweaks. 

You should have a fixed IP address for your Raspberry (static or DHCP with fixed MAC - IP allocation). This address comes in the first "to" field. the first "from"should be your gateway address. with IPv4 could be like 

There are many approaches. Guess the simplest is to use a HTTP form that send to a cgi (in your case directly a python script) You need to 

it is not nessesary to expand the file system, but gives you the maximum of available space of the SD card. Therefore it's recommended and in newer releases the resize will be done automatically ( i think i was reading something like that) Auto resize a part of NOOBs and will not be done in Raspbian. The downloaded images are mostly smaller than a SD Card and there will be disk space unused left on the card. By expanding the space this will be available for additional package installations or for data as user data, logs, ... The addidional space made available by resize cant be there by default, because after copying the image to the card raspbian doesn't know how much space is there or if the user wants to create another partitions with it. 

Embed your custom data in a manufacturer custom data atom in the HAT's EEPROM format (note there are tools linked there to read/write flashes from 4kbyte up to 128kbyte so you can just get a bigger one, to a point). Or... Put your data in after the HAT atoms, basically hiding it after the formatted bits. The HAT spec doesn't require that the atoms fill the flash, so most HATs will have unused space after the formatted part. Or... Slave in another I2C flash just for your data on a different address. If it changes often, this might not be a bad idea to reduce the risk of bricking your board. Or... Do something else entirely and don't mess with the I2C. :-) 

On a typical home network, I'd turn this on in a heartbeat to reduce the possibility of malware spread through the LAN by zombified Windoze boxen. If you didn't set up the router/AP, this is a good thing to check (since it's trivial to look at as long as you have login creds on the router). Another thing you can check is to hit something else on the Pi (e.g. a simple "ping address_of_pi") to see if any packets are getting through at all. Given that you're getting "no route to host," I'm thinking that all IP to the pi is chopped off (if it were a port or interface block, you'd usually get something like "connection refused"). Another dead giveaway would be to use nmap to ping your whole local subnet (but that's an advanced topic...). If it's not the AP, I'd double-check netstat and iptables on the Pi: 

You might want to check what GitLab actually put in your apt sources. if you take a look in you should see a gitlab entry. It should include raspberry pi in it somewhere. It may have mistaken Ubuntu Mate as the x86 version and apt is giving up. The link you posted looks a lot like the instructions for x86 (rather than ARM). The Pi instructions are here The install script itself more-or-less just runs: (you can view it here $URL$ - my line numbers are as per this file) Add signing key (line 107): 

Assuming you already have said loop to fetch those strings and you only want the GPRMC and not GPGGA bit of it. Then, in python3, something like 

I've just gone a roundabout way of flashing an SD card with IoT core as my Win10 machine has no SD card reader. Using the IoT dashboard I've downloaded the image onto a USB stick and cloned it onto SD using a linux laptop (using dd with error checking disabled , otherwise it blows up a little past 8GB). However, the IoT image is resolutely read-only, I can make any changes I want, hostname (via PowerShell or the web interface), adding new files, changing the password (which then sticks for that session) but after I restart it's exactly back to stock . Is there something in the imaging process that ties the image to the SD card? Seems like that would prevent you restoring a device from a borked SD or is that all part of the IoT dream? None of the settings provided from the Dashboard installer are reflected in the image either? Edit: Bad SD card - could not get it to perform any write operations, gparted, and fdisk would all happily report it was blitzed only for the partitions to still be there. Very odd. I would expect flashing the card this way would in fact work, coincidence proved its undoing in this case however. 

If using MSSQL you can also create a CSV file with python and import it using bulk insert or SSIS. I would recommend the python module - but if you don't have a SQL user with the permission to connect and insert into your table MS SQL tools are a great alternative. for inserting a variable you can try something like this: 

does the response give the IP of the Raspberry? If not there is a DNS issue. If you know the IP of your Raspberry try to connect using the IP: 

The question has already a great age but has been pumped by Community. Some months ago I stumbled again about a Linux distribution that i used a decade ago. This project offers a rpi packages. Unfortunately it is still in development and not feature complete. Here are is a tutorial (translated to English w/ Google). As others here mentioned, a PRi as DSL cant replace a dedicated hardware - it works more as PoC. 

Considering your script, the code could be like this. It is also possible to open and clode the DB Connection once, outside of the while loop... both have advantages and disadvantages. #!/usr/bin/env python # -- coding: utf8 -- from os import getenv import pymssql import RPi.GPIO as GPIO import MFRC522 import signal import time