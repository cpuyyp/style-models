It's not described in the documentation. It's not described in the function name. The purpose of the class is unclear. You've managed to write so many words and explain so little. Perhaps I'm being rude. But there's so much here to confuse your fellow programmer! 

Clarity Minor comment; use instead of checking for . Additionally, the comment itself is wrong; "The input array is null." is not the case. The input array is EMPTY. You should make the exception message reflect that. 

Because all it serves as is a local store to help "explain" the code, but is not a very helpful descriptor. 

You could choose this way of writing things or you could just directly return the response. That said... 

This is expensive. Specifically, string construction that is done over and over via creating longer and longer strings. You're basically building the same string over and over and over. And strings are basically arrays of char, so that's a lot of copying. And there's nothing you can do about it because of this rule: 

Maybe it's faster because it does a whole block in one go. Maybe it's slower because a whole native call for copying a few items is adding a lot of overhead. Do the profiling and find out. 

You have a massive bug in your application. Logging in with JUST a password will succeed, provided the password is "correct". Even if you've technically "patched" this hole because setting the location header doesn't apply if content has already been written (see documentation on header), this sort of thing shouldn't be hinging on a tiny footnote in some documentation somewhere. Not supplying a username should be a hard reject by your algorithm. This hole, as is right now, allows users that have provided the correct password (but not the username) to obtain a session token, which they can then use by manually navigating to a protected page. 

And there's only one check in between. So I think you could simplify by getting rid of the 0 case and just relying on the check to keep the stack from overflowing. (Also, have you considered a stack of size 0?) 

Think about how Dominoes and other pizza ordering places work. You can pick a size, a bunch of toppings, and this "recipe" is sent to the Pizzeria. You personally don't have to know all the details to get delicious pizza. I'd even say that in the pseudo code example, the bake time and temperature should be based on dough type and size (pizza business logic!) and not something the customer provides. How is a customer supposed to know how long they want their pizza baked? They just want a "regular dough medium sized meat lovers pizza". Anyway, I think I've rambled on enough about how I think you could model the Builder pattern better with pizza. Let's take a look at the code. 

The auth token is weird. Your class can't protect itself against reflection as far as I'm aware, so all this is doing is covering up a bad design. From the documentation I can sort of see it's supposed to guarantee thread safety - I don't understand why you'd go to such lengths; there are better ways of handling thread safety. Synchronizing on a comes to mind. The function names are also weird. 

No unit defined, so tracking down business logica bugs is hard. Put it in comments, or, even better, in the function name. Something like . 

Next, remove duplication by creating a separate function that allows you to create the part in one call. 

By doing these things, you can reduce the mental capacity required to understand what the code does. 

It's been alluded to in the comments by others already, but I feel it needs mentioning as an answer: Your variable naming should be improved, and some comments would help. In your entire code I find exactly 2 comments: 

returns "undefined", which might not be what you want. Same goes for fractional values, although I guess that case could be waved... if you only support integers. Even so, you might want to add a check. At the very least, add a comment - problem descriptions are kept separate from your code right now, and that makes it non-obvious that it doesn't support such things! Negative numbers could be supported via prepending "minus", then . 

You should also consider removing the pivot variable and seeing if that makes a difference. That said, all performance optimizations should be profiled and benchmarked properly. Who knows what optimizations the JVM will make for you. But if you were a human who executed the code by hand, these optimizations would speed the code up for you. Looking deeper at it (why not?) shows me one more problem: if you made no swaps, you will still split around your pivot, reiterating the entire array except one element. That's really, really bad. You'll basically have \$T_{end-start}\$ iterations, where \$T\$ is a triangular number. In other words: 100 elements sorted gives you 5050 iterations or so. That's bad. Let's add a boolean for that. 

The thing is, as a junior backend developer, yeah, you'd be pretty workable. Depending on how badly I needed people, I'd hire you, if the personality was a match. I don't know what kind of job you applied to. For a higher experienced job, I'd expect better. On the other hand, I don't know how much time you spent on this. An hour? Three hours? A day? If it was a day I'd think it to be a bit much but if you did this in an hour then I'd say it'd just need a bit of polishing. I mean, I did kinda tear into it, but most of my comments were minor. I'm not really spotting any bugs either. I think the most important thing you should take away from this review is that you should have sensible javadoc. And, where possible, provide an explanation from your point of view when you're presenting your work. Why did you make certain choices? For instance, why does a BidTracker accept random items to be bidded on, items it has never seen before? Maybe you take it as a given that you can just let a BidTracker work like that for demonstration purposes. Maybe they see it as a law of Demeter violation. 

This bit of code contains a weird structure. It's for "adding a player choice to pattern", according to the function name. And that's what the first line does. adds the player's choice to the list. Then it goes on to validate. Why is it validating here? Instead, make a function called . Thinking in turns makes it easier to handle flow too. Its body can be something like this: 

It's still not clear enough. That's because I have no idea what means! Additionally, we still didn't get it clear enough. 

Same here... I think if you went through the code and cleaned mini-messes like those, you could chop off a quarter of the complexity. 

Alternatively, accept that sorting sheets is likely to be fast already, and don't spend time on this beyond adding the two simple improvements. Maybe store and in temporary variables.