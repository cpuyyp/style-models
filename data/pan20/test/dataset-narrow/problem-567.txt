Another remark: since you are reading char's and not strings, I suggest using (so replace with ). Or you can also use . 

Introduction to the Algorithm A system can be in N different, unobservable states, (i.e, we never know in which state the system actually is). The system also has a finite number of possible observable "outputs" which depend on the actual (unobservable) state of the system. The input of Viterbi algorithm is a list of observations in a time sequence, and the algorithm calculates the state that was most probable for each time frame, corresponding to the observation. What is also given, besides the list of observations, is the following: 

Handle the case for invalid operators (now it defaults to taking modulo) Explicitly handle the case of division by zero (now, the modulo will be taken, instead of dividing by zero) Handle invalid numbers: 

Of course, this holds also for all the other numeric constant, and the strings "AM" and "PM", which are repeated more than once as well. (Btw., I would suggest introducing these constants even if each value was used only once, because this makes the code easier to understand.) Organising code There are some blocks of code, which could be separated into subroutines, in order to make the main code shorter, and thus more readable. E.g.: 

In Java, Strings are objects, and thus the comparison with the operator checks that they are referring to the very same object, which, in this case, is of course not true. You should use the method instead, like this (not tested): 

Possible improvement You could even further improve either your solution, or that of the book to use dynamic allocation (malloc/realloc/free) instead of fixed size arrays. 

For more details, see e.g. Wikipedia. Some remarks on design Besides having a correct implementation of the algorithm, I mostly had these goals in mind: 

Both throw an exception, due to in being called with zero arguments. I suggest the following change, in order to handle this case: 

EDIT: Clarification of this last point, as per the answer of Josh. The question is: what is the best practice, in Clojure, for checking the equality of two sets of floating point numbers? Let's say, that we have a set with values , and want to compare it against the set . Attempted solutions: 

Is this a correct implementation of the Trie data structure? If not, then what are the mistakes? Can the performance or the effectiveness (both in speed, as well as in readability) of the implementation be improved? Can you think of any test case, which would cause an issue in this implementation, besides the trivial NPE issues, if is passed to the methods (I intentionally left out the checks to make the code shorter)? (In other words, a test that exposes a bug.) Would you improve anything in the unit tests? 

In order to understand how the lazy sequences work in Clojure, I decided to implement the quick-sort example from the "The Joy of Clojure, Second Edition" book simulating lazy sequences in Java. Of course my version of (lazy) sequence is much more simplified than the Clojure one. From the linked source, I basically implemented function as and as class. is a rudimentary representation of the functions passed to to produce the next value. The main question of this review is, whether my Java program grasps the analogy correctly, i.e. if my code represents what is going on in with a Clojure . Besides that, I would be interested whether the implementation could be made "nicer" in some way (I especially do not like the loop in the body of , but I could not think of any better. Also, I wonder if the field could be anything better than , given that it has to store s and s of s at the same time. Last but not least, any further suggestions for unit tests would be welcome. (Of course, any other remark or suggestion is also very much appreciated.) One last remark: I have only very basic knowledge of the new Java 8 functional constructs, that's why I did not use them in this example (also I am not sure if they would apply at all). Any suggestion taking advantage of Java 8 is still very much welcome, though. NextValueProducer.java: 

Post Condition The post condition would pass even if the result is something like "PlingPlongNUMBER". (If I understood correctly, then the result should be either NUMBER or any combination of Pling/Plong/Plang, but never both.) Therefore, I suggest a post condition like the following (not tested!): 

Readability could be improved (Besides what @J_H mentioned), by giving meaningful variable names (e.g. , , etc. could have more descriptive names). Regarding performance, I noticed that the same csv file () is read again and again for each date. It would be better to read it once and keep contents in memory. 

Although I did not run the above code, I am convinced that it would just work also for the first pair (or it could be fixed with minimal changes), since it would just check the second point against the first one, and set their distance as the minimum. Going one step further, you also don't need to check that there are at least two points, when calling . In this case, the iteration would never start at all. 

The code N.B.: I include only relevant portions. A full, working version can be found on GitHub. As external library, the code uses Guava. (And JUnit / Hamcrest for testing.) Implementation 

Code organization improvement: I suggest not polluting with 's, but have it return error codes, and then in the function. This makes it easier to unit test that function. Invalid characters: the case for is now silently ignored, both in the reading function, as well as in the running function (where, e.g., you could add a "default" branch in the switch statement to cover that). Instead, I recommend returning some error codes for such cases, in both functions, and then bail out the program in . New feature: maximum size of memory and instruction could be parameters of the program, with possible fall-back to the now hard-coded values. Unit tests: in the repo, there is currently only one example/test. I recommend adding more tests for valid and invalid usages as well. In particular, I suggest testing with such invalid cases, that would be caught by the parser, i.e. they would never get to the interpreter. The purpose is to make sure that this function is also robust, independently of the parser. 

As a side note, I would also recommend more descriptive variable names, to make the code more readable. E.g. instead of , and instead of and . 

Performace I see one possible way of (maybe?) improving performance (in case it really matters for 9 milli seconds :) ). Namely, caching whether a given row or column has a queen. Let's look at rows (cols would be similar): you need an array of booleans, with the size of , with originally all elements set to . When you put a queen in row #i, you also set the element at position i to true, in the array. And set it back to false, in case the queen is removed. In this way, does not have to iterate on the whole table, but can look up the rows/cols arrays instead. (I am not sure if there is such an optimization for diagonals as well, maybe...) 

A modified version I have modified the original code to demonstrate usage of exceptions, and include some of the other suggested changes. Note, that by removing some of the methods most of the "illegal state" problems can be fixed as well. I did not address the "idempotency" issue. 

Again, starting from the main entry point, it is not possible to trigger this situation, because the user does not provide any positions. However, in case the helper functions were to be reused in a library, this is a question that should be addressed. Corner case #4 

Besides the answer of @200_success, I have one further suggestion for improvement: I recommend making the record separator (currently comma) and the line separator (currently new-line) optional parameters, instead of hard-coding them. (If not provided, the default values could still be comma and new-line.) Of course, the separator parameters could be arrays of strings, so that you can provide e.g. more types of new-line. 

I will focus on the main question, i.e. how to decompose the code so that checks are kept, but the code does not get bloated with them. Regarding the first part: I recommend to factor out the code asking for input, and split the initialization function into two separate ones. Something like this: 

N.B.: I usually prefer calling the method on the constant (if there is one), in order to avoid possible s, e.g.: 

You can simplify the last part (getting the original stack back) a bit, if you use another stack, instead of the queue. Then, you can directly read back the elements of the second stack, and put them back in the first stack. Something like this: 

In case the right element has a bigger second coordinate than the left one, the result is always . I'm not sure if this is by design, but if not, then I'd suggest to make sure, that vertical gap is calculated correctly also in such cases, by taking the absolute value of the difference, instead of the difference itself: 

Background Bloom-filter is a data structure to which we can insert elements, and check if it already contains a given element. The peculiarity is, that if a query returns , then it might still be possible, that in fact, this element was not inserted to the filter. (If, on the other hand, it returns , then the element was definitely not inserted previously.) The implementation consists of a bit-vector of length (originally all bits are ), and of hash functions, which map any input value into the range of (, i.e. inclusive, exclusive). When adding an element, we compute its mapped value for all of the hash functions, and set the corresponding bits to one, in the bit vector. Similarly, when querying if an element was added, we compute the value for all the hash functions and return , if all the corresponding bits are , and otherwise (i.e., if the corresponding bit for at least one function is zero). Objectives of the review While any remark/suggestion is always welcome, I'm mostly interested in the following aspects: 

As it is now, it is the responsibility of the clients (in this case the repositories), to take care of this. Also, it is only true for entities created within the same repository. So, I would recommend either moving the description of the constraint to the repositories (this solution would still have another disadvantage, i.e., that it prevents passing 's to -- more on that below), or really make it the responsibility of this class to enforce that. One possible solution is the following: ID should not be a constructor parameter, but should be assigned to , increased in every call to the constructor: