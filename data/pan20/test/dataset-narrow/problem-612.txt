Doing this in a loop will be slow, and doubling the calls by retrieving each column with a different query will make things worse. Why not use a JOIN between your original query, something like this:- SELECT database.job_id, job_sheet.qty, job_sheet.row FROM database INNER JOIN job_sheet ON database.job_id = job_sheet.job_id In your loop this would mean a single query rather than ~20000 queries. If you do need to do a separate query for each time through the loop then a prepared statement would help but peformance will likely still be poor. 

Use explicit joins with the columns to join on in an ON clause. In this case it will make little difference but when queries are more complex it makes things easier to understand. Better to get into the habit now. Don't use SELECT * in real code. It is a useful shortcut when testing but can cause a potential problem in future. Best to use an integer unique key of the customer on the orders table rather than the email address. This should be faster, take less space and will not cause problems should 2 customers have the same email address, or should a customer change their email address. Orderid looks like the primary key of the orders table and as I would suspect that an order can only apply to one customer you should not have any duplicates to worry about removing. If Orderid is unique then you can just do all the processing of the rows in a single foreach, with no need to store copies of the data in an array. 

Looking at your original query I think you might have issues with the precedence of the AND and OR parts of the WHERE clause. However I agree with the above comments on the duplicate subselects, but not sure whether keeping those will still be the most efficient solution (might well depend on your data), as I can't really see a clean way of eliminating them. First suggestion would be to split off the join to one specifying the userid columns, and then doing joins to the 2 subselects. The sub selects are both the same but the columns they join on are different. This might mean the join(s) are more efficient. 

The only drawback is that explicit bounds have to be determined for each level function. This approach computes in about half a second. 

Note since we are multiplying everything by 100 that the value in is just the value 1, not the conventional 0.01. Given two patterns, and , we say they are close if 

I know it's hard to name things, but try to come up with more descriptive names for your functions. As a general rule, I would avoid using the prefix for pure functions. It's just noise and doesn't help the reader understand what the function is. In Haskell we try to describe what things are and less how things are done. Some names which I think are somewhat better... 

Nothing really wrong here, but I have a suggestion... it is customary to repeat the key if it isn't long enough for the entire message. I.e., if the key was and the message was , you would repeat the key as many times as was needed to cover every letter of the message. The key used to encode the message in this case would be . You can use the function to repeat a list forever: 

Due to laziness it may not make any difference. This is something that perhaps should be benchmarked. To form the groups the first way use the function from like this: 

Note - my JS is a little rusty, but this should illustrate the idea. Update: Per our discussion in the notes, I am suggesting changing this code: 

This may or may not result in faster code, but you can avoid checking that is defined as well as avoid returning it by writing the code this way: 

Note that the list concatenation is O(n) where n is the size of . That is, basically gets copied, so this method of rotating a list is not efficient. In practice this probably won't matter since the list will be small, but it is something to keep in mind. A data structure which amortizes the copying might work better in this case is a difference list such as is implemented by the dlist package. Alternatively just use a where the key is a player number, and keep track of whose turn it is with an Int modulo the number of players - much like you would do in a conventional language. --- playerIsInValidState You should have a bounds check here. If (x,y) is out of bounds then will throw an exception. --- general organization Games typically have the following types and organization: 

The program first determines the set of all possible values that can be entered into every blank square in the puzzle board. The possibility set is determined by iterating through the row, column and the block, and eliminating the set of numbers already present. The possibility-set is stored as a bit-filed value for each square. Every blank square with a single possibility gets the number entered into it. The algorithm is repeated from the first step again, until there isn't a square with just one possibility. If there aren't any blank squares left, the current board's state is returned as the result. It chooses a blank square and enters a value into it. The process of choosing the blank square, out of all the available blank squares is guided by an analysis algorithm. The value entered into this blank square is chosen from all the possible values that can be entered into the square. A recursive call to this function is initiated with a clone of the current board's state. Note that the current board state now contains the modification done to it at the 4th step (entering one of the possible values). Steps 4 and 5 are carried over until all the possible values in each of the available blank squares are tested with, or until the puzzle gets solved. 

The class's function solves the entire puzzle. Understanding the functioning of this function will be enough to understand the working of the algorithm. The following, 

These are the definitions of the generator functions. This shows the vital functions involved in the analysis process (the process to determine the priority of selecting blank squares): 

This Sudoku puzzle solving algorithm follows a brute-force approach mixed with rule-based approach. To further improve performance, an extra analysis step is added, to determine which squares to be prioritized while choosing it to be filled. The priority value is inversely dependent on the number of possible values that can be filled into a particular square. This value is used in computing the priority weight value of each of the blank square that is to be filled. This priority weight value helps in ordering which squares must be filled first. 

The prediction algorithm then boils down to a nearest neighbor search in a high number of dimensions (e.g. the length of the pattern array.) 

more There is a much faster way to compute the shift of a letter using the fact that Char is an enumeration (i.e. an instance of the Enum class) and therefore the following functions are available: 

is a standard way to copy blocks of memory, and most C libraries implement it with special processor instructions to speed it up. Another coding style issue... instead of: 

First of all, the class describes a player in the game, so maybe reflect that in the name of the class, e.g. . In that respect the name name is good because it gives clues to the reader as to how the object is used. Secondly, if I read and correctly, you are just returning a copy of an object. Surely there must be a more idiomatic way to create a shallow copy of a JS object that doesn't require explicit looping? Or, how about just returning and hope that the caller doesn't modify it? Or, why do you do even need to expose ? I don't see where you call it. And for you don't need to expose the entire object - you just need to know if a player has a weakness for a specific user name. In the class , just expose this function: 

The other thing which will help is to keep in mind that the type represents a a combinator which is able to memoize a function whose argument type is . So: 

An advantage of this approach over splitting each line is that if there are large chunks of your program which do not have any comments they will transferred to the list in one piece instead of as separate lines. Update I would also try using a regexp replace approach - it could be even faster: 

The only thing I have to say is that the use of and means that the output will depend on the current locale setting. This may be a bug or a feature depending on what your original intention was. Also, the use of seems rather small for today's processors. The only way that is going to fail is if it can't fit all of the output in the buffer. Since memory is cheap, you might as well make it or . This kinda of ties in with with the question of whether you expect to use this with custom locales. Alternatives: 

Though this algorithm may seem to provide an alarmingly bad worse-time complexity, this algorithm almost never hits the worse time complexity regardless of the (legal) puzzle entered. List of types defined and used throughout the program : I. BoardGrid 

type represents the set of all values that can/can't be filled in a square. This type is specifically defined for storing bit-fields for representing a set of values. This follows the following convention: 

The value represents a null-set. The values starting from to represent the values in the Sudoku board. For example, the bit-field value represents the set of numbers: . Therefore, unlike this stores multiple numbers in an integer field. An object of this type is used for holding the possible list of values that can be inserted into a particular square. 

I had written a Sudoku puzzle solver that accepts puzzle boards, and completes them with the least possible time. Rather than purely depending on brute-force, my algorithm first attempts to fill in the squares that have an obvious solution. And for each square being filled this way, the amount of information increases (I.e.., more number of squares get filled which aids in filling in the remaining squares) which makes the further iteration process easier. Once this method fails (this happens if there isn't an obvious answer to fill-into any of the squares), the algorithm immediately switches over to brute-force search. (Note, the source contains a few spelling mistakes, like the word recursive misspelled as Recrussive. Please ignore spelling errors. Anyway, it has been a while since I touched this code, and this was my first object oriented code written in C++). The basic working (High level view) 

The following defines bit-field values associated with each symbol accepted by the sudoku board puzzle: 

This holds the priority value of each square in the puzzle board. This is used during the evaluation process, where each instance is sorted based on the . A detailed explanation will be provided in the later sections. 

Each of these steps can be put into their own helper function which are also called "subroutines". The will make the body of the while loop a lot more readable. Here is an example of a subroutine to get a valid number from the player (again, pseudo-code): 

Note how the while loop avoids the duplication of code that you have in your program. Here is another idea for a subroutine - one that updates a player's score and returns how to report it. Either the computer's or player's score can be updated with this: 

First of all, there are so many pitfalls associated with programming that I prefer to write all except the most trivial scripts in a language like perl, python or even awk. I realize that availability is a concern, but all of those languages are pretty standard now. If you write the script in a better scripting language you can get rid of the duplicate call to which is one thing that I presume bothers you about the code. If you must write in /bin/sh, then run your code through one of the following static analyzers to help you find potential coding problems: 

The main difference is that and now take an argument instead of referencing global variables. Also, do the same with ... 

array reshaping array row, column and diagonal slices to compute the product of all elements in an array flipping the array to get anti-diagonals 

e.g. is all the ways of removing one element from the list . Also, using the polymorphic signature alerts the reader that the function isn't specific to Ints. I would also introduce a type alias: 

Not that recursion is bad, but using streams results in a more declarative definition. append I would avoid in a Lisp or a Scheme. I'm sure it's not efficient for use on lists. , however, is always efficient, so in you should use: 

Note that is a pure function which makes it very easy to test. You can create unit tests for your code which may be run automatically by your build process. Pure functions are also a lot easier to test directly in a ghci session. Your game loop can now look like this: