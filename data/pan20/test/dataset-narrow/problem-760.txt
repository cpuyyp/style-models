It's flawed, in several ways. Premature Optimization The code smell I get is that the whole point is avoiding instantiating and then disposing elements. Reasons we stay away from optimizing up front 

I think you're over-thinking the solution My first thought is that I'd like to iterate a collection, and give each rule the dice roll results. 

I sense that you think too much about SOLID, padawon. You need to think about what the game IS, and the things that ARE. Objects do things. What they do defines what they are. Properties capture the state of a thing as it does stuff. Leave the search for the unified field theory of object oriented design for later. Obsesssing over Open/Close results in one-method classes. Single Responsibility is THE force w/in the SOLID universe. Your midiclorians are too low, padawon. What, in all the universe, is not an object? To name a thing "obj" (or xxxObj) is to deny its purpose, padawon. Send Obj.cs to CERN, for you have discovered the one, fundamental particle that underlies the fabric of the universe. It is an amorphous abstraction that informs all entities derived therefrom that they have no purpose; that each obj is a distinction without a difference. The secret is, Mr. Anderson, that there is no spoon - or Apple, or Barrier, or anything; not in this Snake Game corner of the universe. There is not a single coherent class here. 

I'm going to try to attack from a perspective of refactoring. In my mind "re-write" means starting over. In you want to say this: 

Focused methods are easier to read, understand, and change Changing focused methods tend to have no side effects - other methods don't have to change. Add checking for non-numbers in and does not change at all. Completely rewrite the prime number algorithm in and does not change at all. Modify any of the methods and the control logic in does not change. Coding errors are fewer. Debugging is easier. 

There is an answer in here I hope, and it is a polymorphic perspective. Your description is very reminiscent of a problem where using simplified the hell out of things. Ask yourself if each enum member represents a different class or perhaps groups of enum members represent states for given classes. ... and/or ... Where's the context in such an abstract array? It's hidden in a morass of es. Does the length and/or value of certain element(s) determine the "type?" If so then a three step process will break apart the existing code, simplify, and clarify. 1) Evaluate for the type, 2) instantiate via a factory 3) do whatever with the instance. Create a class that will hold the array (whole, intact) plus appropriate key fields (values extracted from the array). A super-set of key fields so any byte array "type" can be held there. Add a field for the type itself (likely an enum), as distinct from your Code enum. This class will take an object in its constructor. I had a case where seven distinct "types" were clearly in two groups (per data meaning/use by the users). It was convenient and practical to design only 2 classes. Create "Processor" classes as needed that do stuff with and to these "byte[]-EqualtityComparer" instances individually and in collections. If you need collections I strongly uge you to create type-specific collections (2 in my case) that by design know how to use the class. In my case I was looking for duplicates. 

One final word... Not just on this thread, but everywhere there is way too much over emphasis on creating s. 

DropDown and textbox work together. This focused interaction is independent of the calendar The dropDown and Textbox should be one class, and the calendar another. Further the calendar requires a object so we aggregate them: 

Multiple Add methods Makes no sense. Why would a method arguement be validated sometimes and other times not? How would a maintenance programmer be expected to know when or why to call one or the other? If indeed multiple "add" methods are needed then overloading is what you want. Overloading is a fabulous way of saying "hey, you can do the same thing, but differently" Not overloading obscures the fact that the methods all do the same thing. Then, overloading highlights what's important - that with different object types we get the same result. 

Move If's to the top If the table is null or has no columns then there's no point in going on. So check for this up front. This removes 2 nesting levels. 

We have business rules for a "start object" interacting with a "stop object" For example "cannot stop earlier than we started" 

Exceptions Use to capture context. It will be very handy to know parameter values when things blow up. To facilitate the above, and should override . Then you can do this. 

If this method then I want to see the dependencies. So The general idea here is to name things in business terms. It's fine that the thing we're dealing with is a file, but so what? That's just an implementation detail. However if this method is already a well encapsulated, "rubber finally meeting the road" kind of code then there isn't much to fuss with. Are we talking about "dependencies of a file" or "the dependencies are files?" If the former then I'd look upwards in the code structure and figure out just what this "file" is in terms of your domain and potentially rename some things. 

Do not assume class behavior, define it. I suspect the classes' s are coming from a database because they're constructor parameters. I say this because I wonder how id's are generated and are guaranteed unique. I assume they are unique! Just because it's name is "id" means nothing. The code assumes that I am assuming that id's are unique and are used for object identity. That a heluva lot of assuming all around!! Definitively declare the uniqueness concept in the class design by overriding . This leverages the often untapped power of .NET collections - they automatically use the override in , , etc. Embedding desired class behavior in the class itself makes that behavior consistant, enforced, and required (so to speak) throughout the application. Relying on client code to assume desired behavior and to implement it consistantly is the recipe for a lifetime of debugging frustration. Oh, the final gross assumption is that DB data is consistant and valid. Your class design should enforce all the business rules. IMHO if there is some redundancy in the DB, that's fine. But realize that relational database integrity and business rules are different things. 

You said - then why pass it in? This constructor is depending on the client to provide valid and correct state. You can call one constructor from another. But if the hand evaluation code were not in that other constructor (and it should not be) then this constructor probably goes away altogether. Then there's . This should not be injected by any outside client code. Use more fool proof constructor parameter, perhaps a . Then is calculated internally and should not be exposed otherwise. If needs it there is - which is also more descriptive of what it is. Write properties and methods so client code is basically forced, and limited, to doing the right thing. is perhaps the best example of the incoherent mix of exposed raw program implementation and poker domain objects and terminology. The same implementation detail is exposed in multiple contexts. This, along with those constructor parameters force the client to understand virtually the entire class' implementation; thus client code is left to figure out what, where, and when to use this mashup and the callee is fully trusting the caller to do it right. 

The can have a "type" - with all the types defined in an enum. This eliminates the need for subclasses. 

To illustrate #1 above: do you really want to throw an exception if there is no regex match? Then do not put that in the block. And it should not be in that method in the first place. 

Customize test messages. Without it one gets and that's it. I like to know the expected & actual values without having to read test code. When running hundreds of tests this becomes essential, IMHO. Further, it has a self-documentation quality. 

Use messages in tests I strongly urge in the most emphatic way that you add a message parameter to every test. When you are reading oodles of useless generic test output that says, like, "expected to be equal but was not" you'll understand. Also the test method signature becomes more self documenting and is a huge help for anyone reading the code. Again, imagine dozens and hundreds of tests that you need to make sense of. 

SRP Revisited Given the concept of "request types" as a distinct thing, then I'd say that makes the inside of a SRP violation. 

If you're wanting to encapsulate for the sake of testing per-se take a look at the NUnit CustomConstraint 

What is about? debugging? And why does this constructor not care about score and HandRank? How is it that two very different constructors both build valid objects? Why pass a card array when defines a ? Use names that use poker terminology. Not , rather for example. The scoring/evaluation must be refactored out of this constructor. If you did I suppose you would not be passing in that other constructor. My initial cut (a little DSL there) would be separate methods for each score type. 

Extract the busy-work code of transforming the to into another method. From what I'm seeing I would think about the concepts you want to express in your code vis-a-vis some technical adherence to "encapsulation". If you want users to have no concept of an imbedded in a fine, but as it stands I'm not thinking message is inadequately encapsulated. Alternatively if there are some public getters that you simply do not want users to access, then that's OK rational too. In this case then the alternative is, in the class, a public - and likewise for all properties you want public. If, as far as Page users are concerned, the message's subject is the message, then rename the methods: ; but it still returns a . You can take that one step further by having implement iterator methods so the calling code looks like , , etc. and whatever. But again, the caller has to iterate. This doesn't feel like much bang for get buck to me, although it seems to fanatically adhere to the law of demeter. 

The problem with the OP's code is that is trying be-and-do-everything-at-once. THERE ARE 2 THINGS HERE. Groups of items, and then the "Pricing Rule". OO programming is about identifying the parts in our puzzle and then putting them in the appropriate places. 

type safe avoid typos self documenting - all the possible class-types are defined here. Query string validation - now that we have a definitive list of all possible class-types we can verify the query string contents against the intelisense in visual studio 

Generating and handling exceptions is considered to be an expensive operation, so is better. Yeah, the code example I see in MSDN uses try/catch but that's to illustrate the exception not advocate that as "best practice." Documentation I've read is pretty adamant about not throwing exceptions needlessly. And you don't need try/catch to trap the duplicate key; just an to the above . 

Superfluous Tests I argue that the two "addToCart" tests is one too many. There's nothing specical about adding one and then several others; unless there are special requirements like duplicate items not allowed. Or something special about adding objects with particular different properties. Instead I rather see how passing null works. This is clearly a different/special case. 

Design a data object that holds the parameters for your method calls in your test. Imagine a property for each parameter for each call - including the s. You might want to design a data object factory such that you simply pass in construction arguments, probably in some kind of array arrangement. One object for each test; bundle them all in a single collection of some kind. A driver that iterates the collection and passes each data object to... A method that maps the data to the method parameter variables. Then call the test methods. 

All validation logic should be in an appropriate "validation service" class as @meWantToLearn said. I assume something like this is possible in : 

should not be checking the validity of the returned data. This method should be concerned with only "getting a member number by the user id". This is an example of violating the Single Responsibility Principle. Exceptions - "covering" database calls with is idiomatic. To put a fine point on, and perhaps contradict, a couple of previous answers: 

I infer that doing the calcs in the constructor is trivial as well - no problematic user-perceived lag, hesitation, slowness. 

One More Thing This: seems "orphaned" from an OO perspective. feels like a class property, so maybe you should instantiate a ; this implies a "validation service" class for . The above class stuff may seem like overkill, but there is no OO principle that says "if something seems simple, ignore OO principles". 

EDIT This pretty much supercedes my original post, which remains below has been deleted. Strive For Structure "Structure" is any Class or Class composite that helps organize and use the data. The next two lines of code will replace over half the original code. I kid you not.