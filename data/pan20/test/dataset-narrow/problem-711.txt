I really hope you head my warning about diving head first into a consumer facing app. you need to spend a great deal of time learning and developing 

Here's an alternative implementation. This seems to be more readable to me, by using to define ,, and . In the end its a matter of personal style, but i think the following provides a logical approach to how you would ideally like to layout your code for matching a route in a MVC application. 

array is never initialized as a variable. in strict error reporting, this code will fail. should be initialized as so before you can begin assigning keys. its a moot point though, since response is completely unnecessary. it serves no purpose whatsoever. using in registration and in login is a dead give away that you have no idea what you are doing. for your users sake i hope you aren't storing any customer data or accepting payments. you should consider actually learning the language before you go slapping together apps and releasing them into the wild. not using prepared statements. you can either learn to do it manually or use an library like that handles it for you. closing php tags are not necessary, and i'm pretty sure that your tag is wrong . its just . never gets reached, because you are using die to return the message. don't use to output responses. 

A couple observations: setRoute() can result in a fatal exception if . you could fix this by utilizing short circuiting to eliminate the nested loop in your first condition check: 

Actually Vedran, mysql functions aren't insecure when done properly. in this particulary case though, he is wide open. should be like this 

here's a bare minimum version of registration that is secure in that it won't get SQL injected. you still need to perform validations about the input, such as insuring the email and username are available, but thats an exercise i leave to you. you also need to take this lesson and apply it to the login. 

If you were dealing with two properties that were in the then you'd probably be able to use a derived property. But since one of the properties in an association, a derived property won't work. Instead, you can do this: 

This makes use of to handle most of the building, instead of looping and appending to . The only comes in during the case of 3 or more items. Revised It's possible to knock out one of the cases like this: 

The meta-programming You can start with a Groovy Category that adds the method Writable moveLine(Object, Object) to a class, such as an InputStream. 

In order to resolve the client with a GORM/Hibernate query you basically need to persist the resolved client value. Based on your method I'm assuming your domain class model goes something like this: 

How it works It's actually quite simple. The method signatures are gathered from the class's MetaClass. Then some hefty formatting is applied to write the method signatures correctly. Also, final methods are excluded. Example 

If you're interested in creating some Groovy mixins, you can make your Fizz Buzz program quite simple, while getting some reusable Excel functionality out of it. The Fizz Buzz Program Here's the business logic of the Fizz Buzz program: 

In addition, since in the JVM is immutable, concatenation can create temporary objects which the JVM must then dispose of. It's typically better to use . Testability To make the code testable, meaning that it can be executed via a method call and the output can be validated, I placed most of the code into the method. As a consequence, I converted the closure into a method. I know the challenge states If a map is invalid, STDOUT 'Invalid map.' (That includes if the map is unsolvable). However, I disagree with using the same error message for multiple problems. That's one reason I replaced these messages with insightful exceptions. The other reason is to keep the Groovy Console from exiting. 

An implementation, that I believe works, is below. The matrices are in column order. The ws parameter is workspace, 4*C doubles (though only C doubles are used in the second routine). Note that v is assumed to have dimension C, while really U is CxC, but could be stored in a RxC array. If you are using square matrices set R to be C. The function mat_ut_vec( R, C, U, v, w); computes U*v (for upper triangular U) in w. 

It may seem that no progress has been made -- we have to do m factorisation and multiply up the results -- but in fact Z can be computed simply, and so can the products. We note, by Woodbury, that 

Depending on how big the maximum test case can be, and how many test cases you are to get, it might be quicker to fill out a table of the answers for all possible cases. Then the test cases can be answered by just indexing into the table. One way to fill out the table would be to first set the entries to 0 for all powers, and then to fill in the rest according to how far thay are from the nearest power. Unfortunately I don't know java but in case it is of interest here is a C program that on my machine fills in (and prints) the table for the first million numbers in 70 milliseconds, while the fist 100 million numbers takes 7 seconds. 

This lends itself very well to being implemented as a fold. In the particular case of chebychev polynomials (and other orthogonal families) it is even better to use their recurrence relation. Not only does this avoid the (sometimes unpleasant) calculation of the coefficients, but will also compute the first n polynomials in a single order n loop. For chebychev polynomials T the recurrence is 

This has the additional benefit of not having side-effects. Another improvement is to change the location s to s so that instead of you can do . This improves readability. To build the path , I think using is better suited than because it helps clarify the code's intent. can be used on the output of , but that would have been more trouble than it's worth due to the need to keep multiple things in context (accumulator). So I used instead. 

You can use Groovy to generate the Groovy source code. The source code generator Here's an example source code generator. 

The new property , which is maintained by the and methods, takes care of saving the current resolved client to the GORM store (database). With that value persisted you can use it in GORM queries: 

With some meta-programming you can add a method to the InputStream class that would allow you to move a line ahead of another using concise code like this: 

Leverage the GDK Early in the script, you have a variable which is used to ensure all of the rows in the map are of the same length. The variable is not used elsewhere. So to limit its scope, you can refactor the validation using : 

In this example, is an interface with four implementations, (only one of which I coded), one for each of the possible directions. The methods accept a and any other necessary parameters which are not part of the . The implementations can then get , , and from the . Sure, this breaks some object-oriented programming rules, but as the adage says: some rules are meant to be broken :) Note that it still involves passing the current state of the . Alternatively, you can implement as an abstract class containing and the equivalent of the methods as abstract methods. Then, you can remove all together and implement four s; one for each direction.