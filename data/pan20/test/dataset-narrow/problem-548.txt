That's better, but we still need to loop through all the views to find out which ones need our data. Perhaps there are hundreds of views and only three need the data. A better approach would be to use a publish-subscribe model. Instead of having to loop through all the views, each view that needs data would subscribe itself on the view who's data it needs. When the data for that view is loaded, it would publish this data to all its subscribers For example: 

Prefer over ; it is more idiomatic and easier to read. However, having an explicit condition in your loop head is preferred to ing out of the body in most cases. Use and other integer data types where appropriate. As an example, is an in your -method. This allows the user to input a negative number as well, which your program handles gracefully by doing nothing and exiting. Still, it makes no sense to have -5 Ghouls, so should at the very least be . Prefer pre-increment (and -decrement) over post-increment (-decrement) (i.e. over ). The reason for this is that, while it does not matter for integral types, it can incur a performance cost for types which overload both operators (this is because post-increment might need to make a copy, increment and then return said copy). So while it does not matter here, you should make it a habit to avoid unnecessary performance losses in different circumstances. 

You should avoid mixing calculations with input/output. It would be better if your would not call the output function directly, but instead would just return the result of its calculations: 

Regarding a plan to implement them recursively, I would suggest you instead look into implementing an algorithm like merge sort or quick sort, which are recursive in nature. 

Like ojdo has pointed out, using plain regexes to parse something like BBCode is too complicated of a route to take. It would be too long of a task to educate you on building proper parsers, but here's a short simplified example, of how one would go on parsing something like BBCode. First tokenize First off, we transform the input text into some higher level data structure which we can then work on more easily. For the BBCode, let's tokenize the input into begin tags, end tags, and text in between: 

Putting all of this (and some bits of supporting code) together, a reworked version of your program could look something like this: 

Design Issues If there is one thing that bothers me about your code, it's that template parameter. First off all, why would you code that into your class if you could just use and be done? Secondly, I would argue against adding additional functionality to iterators. After all, the reason for having iterators in the first place is to have a uniform, pointer-like access to the contents of a collection. Adding additional functionality into this interface violates the principle of minimalism that the design is based on. Other Things 

Another step to simplify code is to filter out the invalid numbers before doing any calculations on them. helps us here: 

You generally should not to nest your components. Though when the component is small enough, like a one-liner, it's fine to do so. In your specific case, you can make use of withComponent method to change the tag name of an existing component: 

But all the places where method is used, could actually use the method instead. This should make one realize that this whole Tile class could be completely eliminated and replaced with a plain boolean value instead. Other smells 

Although this code should be reasonably efficient for relatively small numbers, there are faster algorithms to solve this problem. However, most of these are not as easy to implement, and if you are not planning on doing this for very large integers, then you should be fine with the changes I suggested. If you are still interested in improving effiency, I point you to the Wikipedia article about the prime-counting function for a start. 

You said that your code has a lot stripped out. However, if you really want us to help you, you should restructure your code into multiple smaller units and ask for review of each of these units alone. As is, your code may be big and bulky, but refactoring can help to limit the scope of functionality for certain classes and make effective code review possible. 

So you load data for each view, but then you also go through all other views to pass this data to them when they happen to need it. However you don't only pass the data from currently loaded view, but you try to cover all the views (some of which have not been loaded yet). So the first optimization to make is to eliminate this third loop through all the views. Just passing the data from currently loaded view to the views that need it: 

First of all, this is remarkably good and clean code! Nevertheless, I do have some things to nitpick on: Code Formatting Let's talk about line length. As of right now, you have a (physical) line in your program weighing in at a whopping 160 characters. First off all, this is easily enough to make the code blocks here on code review have a horizontal scrollbar, which is impractical and not very beautiful. Second of all, 160 chars is too much for many of us to handle in a typical development environment. Maybe you have a nice, big monitor or two which allow having open four files simultaneously at a line width of 200 or more. However, I certainly don't, and making me work with your program on my 14" diagonal laptop with about 200 characters line width for the whole screen is not very accommodating of you. Now, the correct maximal line width has been a matter of ongoing debate. I'm an advocate of the good old 80 characters standard, but I'd argue that anything around 100 characters is fine. However, in my opinion, 160 is not; and you are likely to upset some people by sticking to it. Another issue I see is horizontal spacing. For example, let's take a look at two lines from your code: 

Most importantly, try to care about your code. If you put your code out for others to see (by posting it here), try to first make it as good as you possibly can. Remove dead code. Fix the problems that you know about. Post a complete example, not half-finished one. Structure it so that it's as easy to read and understand as possible. Run it through JSHint and fix all the warnings, so you that people will not need to point out the mistakes that a stupid machine could have told you about. 

...and some other things more, but these are the most urgent issues in my opinion. Why is your code so slow? You do not provide any benchmark data or other performance evaluation, so I can only make some guesses. However, there are some things that, from a performance point of view, are quite alarming: 

is a reference to a -object. References as class members are rare and very dangerous, so let's pull out our alarm lights and go investigate whether the reference is justified and used correctly: 

And don't take my word for it. Run your JavaScript through an analyzer like JSHint - it will warn you about these and other issues. PS. I think overall your code is very nicely and cleanly written. It just falls short on looking and feeling like JavaScript. 

This code is bothering us with the minutiae of how user data is stored within the session. These details shouldn't be our concern while deciding what to display on Payments page. All we really want to ask is: