makes a new list containing all but the last element, which the recursive call will promptly clone (in its entirety). So that's two copies for each element after the second. It would be better if we could tell the recursive call to only treat up to a certain point in the list, and everything after that. To do this, we put the bulk of the code into a helper function: 

Do the microsecond ones really need to be functions at all? They seem like they'd be used only rarely (probably at the end points, reading and writing to a database), and since they're one trivial calculation, a small comment at the call site would be sufficient. Some of these really seem like they belong as instance methods on the object. In fact, a lot of them are in newer stdlib, and the entire point of your code is to also support versions of Python from before that was the case. So, it might be a good idea to simply offer a compatible interface. There's a few ways to do that. First, the stdlib module is implemented in Python, so you could include a newer version of it wholesale and have your module do this: 

I wrote this code for an assignment. It was originally meant to be written in Maple, but got very frustrated with some of Maple's idiosyncrasies that I decided to play around with Pandas instead. This is a very trivial multi-linear regression model, which calculates variable weights using least-squares optimisation, and also allows for basic forward selection and backward elimination for model refinement (both without any form of backtracking). All suggestions welcome. 

An arguably better option is to put it up front with an explicit test, even if that means duplicating some of your logic: 

But this is the major data structure in your class. It contains all the information that this class is designed to parse. So, I think all of this should be done in , with this structure - and only this structure - captured as an attribute. The only other attribute you store is the filename that gets passed to . I think it would make more sense as an argument to your method - the only method that uses it - because the filename to write it to is a decision that goes with "I want to write this data to disk" more than "I want to scrape some data from a website". So, you're left with a class with one attribute, and two methods - one of which is , and the other is fairly trivial. In fact, becomes even more trivial with a list of namedtuples, since you wouldn't need to it. Similarly if you use a pandas DataFrame, it has it's own CSV routines that you can use. That means there is no need for a class. Instead, use what your has grown to as a standalone function - call it . Have it return the list or DataFrame. Then drop the function entirely and just put that in the main line of your program. 

I'm not sure I completely follow exactly what processing you're doing to your data. The comments in the code suggest it's meant to be a matrix multiplication, the description you've provided above it suggests it's a cartesian product, but your code looks like does the sum of (flattened) outer products of corresponding rows. I'll proceed on the assumption that your code is doing the right thing, but hopefully you can clarify. There are two general pieces of advice that apply here: 

is discouraged in most languages, because it spreads details about what is really one logical operation across your code. The preferred Python for this is: 

There's no need to turn that result into a list. Anything you can pass to you can also iterate over directly. Only bother turning it into a list if you need to iterate over it more than once (you don't). 

Consider using a generator expression, especially if you're in Py2 where builds a list (at least use there) - but I'm quite sure I'm not alone in finding more direct and easier to read. 

If you prefer to instead ignore any surplus values, use instead of - they take the same arguments, but will just return one result instead of a list of them. 

That is a lovely abomination. It.. looks like you're trying to handle the page being in an arbitrary encoding, and standardise it to UTF8? If that's the case, do this: 

Once you're happy with that, you can count how many are True just by adding them up (try these: , ). That means that this (dropping the to make it a generator expression because we don't need it as a list to do this): 

But since that's kind of clunky, and you do it every time you update the dictionary, use make a , and it's just . 

isn't quite as easy as that, but we can still simplify it a little. First, the flag completely changes the behaviour of the function (causes it to choose between mostly disjoint codepaths), and would usually be specified as a literal in the source. It makes more sense to have it as a separate function instead. If you do need to decide between them based on user input, you can always write a short wrapper function. I'll reuse the name for the clobbering version, and use for the non-clobbering version. The clobbering version is then really just as simple as : 

I've also removed your exception handling for generic errors in here, because I don't think this is the right place to handle them. Instead, let them bubble up to the main line and deal with them there. This has a flow on implication down here: 

Do put spaces between arguments (after the commands), don't between the function name () and the opening bracket. 

isn't actually doing what you want. It looks like you mean , otherwise is full of single-length lists whose only item is a collection of some kind whereas it would make more sense for those collections to be in directly. You would then make a corresponding change down in so that the test there reads: 

But we can do better even then this - we don't need to do all these swaps at all. Instead, find where the last element should go, and put it directly there. This is exactly the type of job the module is good for: 

You can flatten this and save a level of indentation by reversing the order of the conditions and using . While we're at it, the preferred way of testing if a set (or any other collection) is empty is just 

Some general style suggestions; incomplete due to lack of time, but they should give you some things to think about. Upgrade to Python 3 if possible. You appear to only be using stdlib code, so this should be reasonable painless. You have a lot of java-esque naming conventions. Python style (see especially PEP 8) prefers methods and variables to be named rather than . Names of classes should be capitalised, so instead of . You have some of your methods named according to this style already - you should generally try to pick one style and stick with it; preferably follow the conventions in PEP 8 unless there's a compelling reason not to. You use strings as flags a lot - eg, 

To get the same effect as returning the digits, but it might make more sense to print the equation, eg: 

Assigning a string to something that's otherwise always a number is odd, and this value is never used anyway. Nix this line. 

Should be docstrings - basically, make it an unassigned string literal, and put it directly inside the function definition. The first argument to is another string-as-flag. Use a bool instead, and all it . But even better, split this into two functions. The one that does it automatically could actually be a method of called , and document it as placing them randomly. The one that places them manually does belong out in the main flow of your program, since it continually does IO. This will simplify your code greatly. The second argument is called but actually expects a Grid instance. Just call it . could just be called . If you want to document its structure (which isn't a bad idea), you can do better than giving it a clunky name that only documents some of it's structure - in your docstring, do this: