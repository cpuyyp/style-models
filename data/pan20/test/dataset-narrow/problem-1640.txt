The processor is the same as the B+, albeit stamped with a higher frequency, and I believe inferior power regulation on the 5V rail, which has some consequences for USB (don't expect it to power much). It also has the awkward "mini" (not micro) HDMI jack for which you will need an adapter if you need to debug something using a local display. Which you will. In the end you are not going to save anything much (taking shipping issues into account, you will pay more) -- if you pay $5 for the pi, $2 for the OTG adapter, and $10 for the ethernet adapter, you are almost halfway to the $40-$50 you would pay for a Pi 3, which has 4 (faster) cores and built in ethernet. So in fact using zeros you would end up spending twice as much for the same processing power, and have to put up with all the hassles that come with the oddball form factor. That's without taking into account what I mentioned about per unit shipping costs, vs. no such restriction on the Pi 3. 

You could, but this would not be an image that could be run on an actual Raspberry Pi. You might have a look into QEMU, although note that the combination of hardware emulation and the less performance oriented ARM ISA will probably mean it is noticeably slower than VirtualBox. However, I believe you can run unadulterated Raspbian in it. 

Implementing a unikernal which runs an application that mimics or duplicates exactly, and would be interoperable with, an existing Android application, is almost certainly possible. A caveat here is that if the app depends on network connectivity to a proprietary service, that is a major and possibly insurmountable obstacle. Implementing a unikernel which actually runs an existing Android app is probably possible, if you need to deal with the caveat just mentioned, or want to keep updates of the app in step. However, it will not save you any labour, since implementing such a unikernel environment will be much more work than implementing one that duplicates the functionality of the app (this approach likely stretches the definition of "unikernel" a bit, and would be a task much better suited to a normal OS). 

Where "nnnn" is the PID number. Then check to see it is gone. If not, try . If it is still running after that, reboot. However, I do not think there will be much trouble that way; hopefully it isn't running at all. If it is, this is probably because it is being run automatically by the networking service you configured, in which case you will have to disable that. Once you sort that out: 

You don't need to install this on the Pi, as long as it is possible for you to copy some files back and forth. I mention this because my current version of it is 8.1 GB -- however, I've been updating (various branches of) it for years and 7.9 GB of that are in the directory, so a fresh download should be much smaller. For the raspicam stuff, you only need what's in the directory. Beware there's also an (no ), and seems to confirm that, as implied, these are not compiled with hardware floating point support (which is likely significant for graphics applications, although most of the heavy lifting should be done on the GPU anyway). You can copy all that straight into the top level of you root file system as on the Pi. You then need to let the dynamic linker know about the libraries: 

Will show you the top 10 largest directories in descending order; logically the top one will be , since it includes everything inside. Don't try this on as it will take a long time. You can try it on , which will probably give you a long list (somewhere might help) but the last line is always the grand total, meaning it is easy to tell whether this is the place or not. If not check and . There is more information on in . 

There is no machine at the resolved IP address, although there is a known route which should reach it if it is online. The machine at the address is using (or behind) a firewall that drops the packets. This is an unconventional thing for a firewall to do, because it creates more traffic for the machine running the firewall, since innocent applications will keep retrying until they time out. The normal way for a firewall to respond is with an ICMP packet saying the access is prohibited. However, it is still something a firewall can do if someone configures it to do so. 

If this is about video motion detection, this could be much longer. You could use something in the range of at least 100 - 200 ms and everything will work the same anyway. 

But (as with normal linux distro kernels) this includes a lot of stuff I will never need, and some things that I'd like to change. What are the options that are actually required to make various common pi-centric things work? 

Don't do that. All of those commands are implemented in C in the first place and are open source. Many of them are just wrappers on system calls. 

You can do the math yourself since you already have the numbers, but obviously this depends on the battery and how long "long" is, but going with 2000 mAh for the former I doubt it very much. The Pi is not an ultra low power device and battery operation was probably not given priority consideration in the design; making it so would have increased the cost, and making keeping the cost down in this case took precedence. 

Wifi speeds are often rated in Mbps -- the dongle you are using on the pi is probably 150 or 300 Mbps. If you have a decent router and are running an unencrypted dedicated 802.11n network, you may be able to get close to that when transferring data between two points in your WLAN (but I very much doubt it). I'm not sure the extent to which WEP/WPA slow things down -- I have not benchmarked this, and searching for such doesn't turn much up, so lets assume it is not particularly significant. So, going with 8 megabits per megabyte and 3600 seconds in an hour, at 200 Mbps: 

1. I'd guess it was not and this in part reflects much successful overclocking on the pi -- congratulations gang! 

No, this is one figure sometimes floated as a total maximum for all GPIO pins. Note the pure 3.3V/5V power pins are not considered GPIOs and can supply much more than this, perhaps 1 A in total. In the picture you are using a 5V pin, which should be fine. I've routinely drawn 100-150 mA total without issues (but YMMV!). The limit per pin is usually (and I believe officially) given as 16 mA, but again from experience and observations by others here, 20-25 mA should be okay. In this case you are only using a GPIO to toggle the transistor, which can be done with a few mA or less. Going back to your picture, the big 10k resistor is between the GPIO and ground, but there is no resistor between the GPIO and the transistor base. The one that's there is to provide a pull-down to ground, so that if the pin is set as an input it does not float, which would mean in theory it might trigger the base. This is probably not very necessary. What is more important is you have a resistor between the GPIO and the transistor -- so you can remove the ground connection there and just put the resistor inline with the connection to the transistor base pin. There should really also be a resistor somewhere between the power pin and the LEDs or the LEDs and the transistor. The LEDs have a forward voltage drop of 1.3V and there are two in series = 2.6V. So that resistor should be about: