It really depends on what you intend to use it for, but the on-board audio is definitely "not hifi". For a beep or voice prompt, it may be fine. Your most obvious options are: 

One huge hurdle you need to address is compliance with HIPAA requirements, at least if you're in the US. Those requirements are part of why simple healthcare services cost so much. Assuming you get through those hurdles... For the day-to-day pushing of reminders and patient responses, look into using an Internet-based MQTT broker. It is well suited to this sort of usage, and works behind a variety of firewalls without any complicated setup on the patient end. It would also work well with any physical buttons you add onto the device with minimal complications. So far as the patient registering the device, it could be as simple as an identifier applied to the device case that the patient enters into an enrollment web site. That could be linked to the identifier used for MQTT (see above) that is used to "talk" to the device. If you provide a cell modem and service, it might be simple enough for an elderly patient to call a number and enter the information via phone. Otherwise, you do have to deal with walking them through setting up their wifi. A small display on the RPi would be useful for this. A lot of what you are asking is open-ended, but there are answers that take advantage of the RPi that are worth discussing to help you focus your questions. Good luck with this. It sounds like the sort of worthy cause that we should strive to encourage supporting here. 

The NST page mentions including many of the sectools.org tools, and many of those are available on Raspbian. I have installed many of those on RPis and used them during network configuration and security testing work. They work well, so long as you are cognizant of the limitations of the RPi in terms of network throughput. You are not going to be able to sniff traffic on a busy network that saturates the RPi interface reliably, especially at 1 Gbps+ speeds. It really depends on how busy your home network is. If you're willing to live with possibly missing some traffic, it's probably more than adequate for such use. It works very well for things like scanning (), limited traffic sniffing that doesn't saturate the interface (, ), firewall testing (). should work within bandwidth limits, although I haven't tried it yet on the RPi myself. 

A common solution is to power the high voltage device from a dedicated power source, but control the current flow via a logic-level MOSFET or transistor from a 3.3V or 5V microcontroller. Adafruit has a good tutorial on powering 12V LEDs and controlling them from a microcontroller using MOSFETs that might be useful -- it's more info with images than I can summarize here. You could, of course, simply control power to the buzzer using a relay, but this will be a more bulky and possibly expensive approach. 

Is it possible that the DHCP DNS server configuration varies between your Ubuntu and RPi dnsmasq configurations? Have you confirmed the DNS settings on the client machines? This highlights one possible shortcoming of your approach: It will only work for clients that play along by using your DNS server settings. Bypassing it by using an external DNS server is trivial. If you are concerned about this, and the RPi is to be your router, you might try redirecting web traffic using iptables instead. 

We're getting fussed at that our discussion is too long, and I think I've got enough detail to formulate an answer. It is possible to bridge without having an IP interface up. This is exactly what most network switches do, in fact, unless they're inadvisably being managed on a user subnet. What may have happened is that your RPi,for whatever reason, stopped responding to IP on the wired interface, but is still passing bridged traffic through. You don't need a Layer 3 address to pass Layer 2 traffic. Your computers connected to it are still able to talk to their default gateway on the other side, and even get DHCP addresses assigned from a server on the wired side. If this "just happened", a restart might resolve your issue. To be clear, were you able to ssh on the wireless side before this happened? I won't have time to test this myself any time soon, unfortunately. 

Have you tried increasing the memory split? I had no luck with my little portrait display project until I increased it to 256 IIRC. I also had some odd issues when I disabled the logo display on boot. Note the ability to do this may vary depending on which RPi you're using. 

All good news, since you've eliminated a lot of things as the problem (bad cabling, defective hardware). To communicate off the local subnet with IP, your RPi needs to have a properly configured default gateway. Enter the command. You should see a line that says . If not, that's likely your problem. Check to make sure your dhcp server (likely your router) is giving out a default gateway with the address lease. If your routing is correct, you should be able to ping external IP address (e.g. for google). If that still doesn't work, it is possible that your router is not forwarding traffic (doing Network Address Translation - NAT) for the RPi, but I'd say this is unlikely since it sounds like other computers can get out. If you get to where you can ping external addresses by IP address (e.g. ) but not by name (e.g. ), then you have a dns issue. Try using a "known good" dns server such as google's at 8.8.8.8 and try again. 

Dave Conroy has a nice howto, including links to a version of modified for the Edimax nano wifi adapter that I use for creating hostspots. His tutorial uses bridged mode, which is suitable for a simple repeater, but you'll want to replace the bridging configuration with a routed+NAT configuration. None of these steps are particularly hard, but there is one major consideration. The throughput of the cheap wifi adapters is dismal. I found that none of the 3 I tried (Edimax, TP-Link and generic) would provide more than 45-56 Mbps on a full desktop system, despite claims of 802.11n support. In a bridged or routed configuration, I was never able to get more than 10 Mbps of throughput on my 60 Mbps Internet connection. Local tests using confirmed this. Testing with 2 bridged USB3 1 Gbps (wired) Ethernet showed that the RPi can handle over 100 Mbps throughout, so the problem is the wifi adapters. Performance is mediocre at best. 

I've run Debian linux since the 1990s, and am now playing with Raspbian on my RPis which is based on Debian. Two main differences come to mind: 

Have you tried using to select a font? Here's what my looks like using a 16x32 Terminus font that looks good on a large 1080p display: 

Have you updated the RPi firmware recently? That's not an official RPi camera, and support may have been added since you last updated it. If you're running raspbian, doing an update (e.g. ) will update to the latest stable firmware. 

Enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward Assuming 192.168.1.1 is the default gateway for the 192.168.1.0/24 network, it will need a route (probably a static route) for the 192.168.43.0/24 network that points to the RPi at 192.168.1.20. How to do this will depend on your router. You'll want to set the Wireless router as the RPi's default gateway over the wireless network. 

Tying Jenkins and other software tools together with the RPi. I'd suggest looking at MQTT as a simple way of "wiring" systems together via networks simply. Interfacing the RPi to your display. Being in a start-up, I'm going to assume you've got talent around that you could hand the status data off to and work it into a nice dashboard display of git stats. Interfacing the RPi to hardware. There are a wealth of projects around on interfacing the low (3.3v) RPi GPIO pins to higher-voltage physical devices safely. You'll need to learn some rudimentary electronics, but it's not overly complex. 

So long as performance is adequate with a single RPi, I wouldn't separate them. I've gone the other way in migrating more services to my always-on RPi B, in fact. Migrating from an older B/B+ to a 2B makes good sense. Other than backing up your configs and installing the prerequisite packages for each service, there shouldn't be any huge challenges doing what you've described. I like to install unattended-upgrades to make sure at least critical security updates are applied even when I don't get to all my systems regularly. I also install molly-guard to make sure I don't shut the wrong one down. If these are exposed to the Internet (sounds like it), I'd definitely isolate them on one or, better, multiple DMZs. 

From your description, I'm understanding that you have created a DNS entry for the RPi's Ethernet (static IP) interface, but want the same convenience for your wifi (dhcp) interface. There are two ways to accomplish this: 

You seem to be getting down-votes, and this isn't really a great question for SE, but what you're asking about -- interfacing the RPi to physical indicators of some sort -- is definitely on-topic. If you can frame your question(s) in more specific RPi interfacing terms, you'll get better responses. It would be fairly straightforward to interface the RPi to some sort of hardware -- check out Google's Paper Signals for inspiration -- to indicate all sorts of status. While Paper Signals is based on Arduino controllers, you could use the RPi for the same or even more sophisticated status indicators. There are projects using the RPi to provide visual feedback on bus arrivals, traffic loading, bathroom availability and a host of other topics that might be useful and even fun in your office. Tying it into your actual development process adds some legitimacy to the project. Break it into sub-projects: 

You're going to need drivers somewhere, but you may be in luck if the drivers are available for the OS on the computer you're printing from. Look under the Adding Your Printer section of the article you linked to. It mentions: 

Once your system is up and running with the required software, administration and operation is pretty much the same. Most of the skills I've developed using Debian have transferred directly over to the RPi, with hardware differences accounting for most of the challenges. 

I'm assuming you want the video to be visible from the Internet and not just within the hotel, correct? Assuming you can redirect ports internally on your home network, you could simply create a tunnel from the RPi to your home server and use port redirection with ssh (assuming you can install ssh on your home server). I've done something similar using a virtual server hosted on Amazon's AWS cloud. Performance might be pretty poor though since traffic will have to travel in and out of your home connection, then back through the tunnel over sometimes-spotty hotel wireless. It will certainly vary by hotel. Does it need to be real-time live video? It might be better to record, then transfer the recording to your home or Internet-hosted server. 

With only 1 GB RAM, the RPi 2B is unlikely to do be able to handle 3 virtual machines running Vista (??). 

You could write something to communicate directly between the ESP8266 and RPi, but a flexible option is to use something like a MQTT broker. The broker itself can run on your RPi, or on another computer. Writing clients to talk to the MQTT broker is trivial on both the ESP8266 (using Arduino IDE) and on the RPi using a variety of libraries, including python. The beauty of this approach is that you can easily add clients and features using the publish and subscribe mode of communications. 

I wouldn't recommend it. Considering that syslog is used to track sensitive system information, there's no sense handing out such information to the general public. If nothing else, you should redact sensitive information that is not relevant to the problem you're working with. As @Ghanima notes, it's really up to individual programs using syslog to decide how much info to dump, and this may vary depending on settings (e.g. debug or verbosity settings). A lot of sensitive information has been revealed on pastebin and similar sites by people troubleshooting problems. 

You could configure the RPi to auto-login as the pi user. You can configure this via . To do the same thing manually, create a file containing: 

I did something similar here. A key point in response to your 3rd paragraph: X is implemented very differently than Windows or MacOS. It's not "all or nothing", so you never need to load "the full desktop" if you don't need it. There are several layers which can be simplistically summarized as: 

If you want your new user to have the exact same rights as the pi user, add the new username to all of the groups except the group that the pi user belongs to. You can save some typing by doing this in one pass: 

You need to be clear: Is your RPi on a wired or wireless network? If it's wireless and you didn't configure your new router with the exact same wireless settings, you will have to connect it via a wired connection and try to locate it. Plugging an Ethernet cable from your RPi to the router should work, assuming the router hands out DHCP addresses and your RPi is still using DHCP for the Ethernet interface. If you RPi is using a wired network connection and you hard coded the IP information, just plug a PC into that same network and configure it also with a hard coded IP address in the same range, then locate it using nmap. Multiple IP subnets can co-exist on the same network/switch. 

You can install and start ufw for testing without enabling the service. If you make a mistake, reboot. Also, IIRC, it won't bump out an established session. Open a window to install and configure, the leave this window open with the login session active while you open another and connect to test. Avoid the compulsion to close every session as you go and you should be fine. 

On the computer you will sit at, the one running PuTTY, you need both a public and private key. You need to append that same public key to the ~/.ssh/authorized_keys file for your account on the remote computer, the RPi, in order to use it. (It's not a good idea to delete or overwrite authorized_keys if you've got more than one remote key you want to connect with.) It sounds to me like you're generating the keys on the remote computer, the RPi, not the one you will sit at, running PuTTY, to access that remote computer. I may have misunderstood. You need to have both the private and corresponding private keys on the PuTTY computer, then copy the public key to the authorized_keys for your account on the RPi. You should then be able to configure PuTTY to use the private key and be able to connect to the RPi on your account without a password. 

might be what you're after. It provides interface management with both GUI and CLI options for configuration. By default, it will disable wireless if the wired Ethernet interface becomes active and re-enable it when the wired interface drops. You can configure this behavior. I use the package under Raspbian on my RPis to do exactly what you are describing. wicd also gives a host of other helpful options for connecting to multiple SSIDs or specific APs. 

Looking at the Debian Network Configuration documentation and other documentation online, my understanding is that is only necessary for removable network adapters, or if you're using dhcp on an adapter that might not be present at boot in order to avoid long dhcp timeouts. Try removing the line if you're using a static configuration. I tried replicating your problem with several variations, but only obtained a single IP address as show with . Do you by any chance have anything under the various directories? 

You are only redirecting port 80. If you redirect all traffic, it's possible the detection mechanism will also use traffic that is redirected, increasing your odds of success. Of course, if the detection is looking for fixed IP addresses, this might not work. 

You need to verify what interface the plotter uses. Some older HP plotters used RS-232, or a proprietary connection. Your first challenge will be getting the RPi physically able to communicate over this interface. A USB-Serial adapter might be all you need. Once that's working, I believe you can just send postscript files to the printer. I've not done this myself, so you might want to check out some of the other howto guides for getting this plotter working under linux. Once you get the RPi working with it, you should be able to share the plotter over your network using CUPS+Samba.