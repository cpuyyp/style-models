Sometimes math can be confusing, sometimes it can help, but, using some math, the solution to this problem is: 

This makes it easier to compare/validate your code. My next suggestion is to shift the data as you pull values off... This way you don't need to do 'brain-mushing' thinking when doing the manipulation. 

In other words, the values have to appear next to each other in the data.... ... this was not explicit in the question. Later comments indicate that the sequence can 'skip' values. The rules for 'skipping' appear to be that you can skip any value that is smaller than the first value in the sequence. The above example, if you include skipping has two additional solutions: 

So, here's the thing, what you have is not a generic method. What you have is a generic class. Now, it's a clearly defined generic class, but, it is not what the question asked for. (as a generic class it has a number of issues too, but let's get the method/class issue resolved first). Generic methods A generic method is just that, a method, except the parameters (or return value) are of a generic type. A generic method always has a structure before the return-type declaration. A normal method is: 

but, you want to share a texture, so the idiomatic approach is a 'pool', with a counter of the pool usage, and a pool shutdown when the pool is empty.... i would go further, and abstract the pool from the off-heap management. Let the pool deal with the reference counting, and let the off-heap management deal with the JNI crap. Consider a three-level tiered approach (note the generic methods...): 

In the above code, if is nil, but that's not what you expect, then you do the .... which is OK, but, if is nil, and there's a pattern you expect, then you get a Nil pointer reference in the setup. Some other things to consider: 

In cases like this, I like taking a default-unless-better approach... Consider this re-working of your code to do the same thing in a different order. The basic premise is: 

XML based configuration structures often tend to change during the development-cycle of the product. It is good to plan ahead, but you should also expect to run in to something that needs a format change. First though, the structure you have for your XML appears clean, and good. The presentation you have is good and neat. That makes it nice to review. There are some suggestions I have that will help you though. 

Now, since you synchronize outside the add method (and outside the loop), there's no other thread that can call the add anyway. Still, that's not a problem, because your main method does: 

Time-sequence data - your Product table contains the Product cost value. Are your products going to be the same cost forever? If the cost changes, it will screw up your invoice data..... Address has a PersonID attached to it. This is not completely unusual, but, when you have Invoice, you have both a BillToPersonId, and a BillToAddressId (and the address has a person), so what if they are different? Is the PersonId on the Address redundant? I think there's a contradiction in there somewhere.... 

is not controlled with any synchronization. Even though you pre-size the list to have a slot 'available' for each task, there's no reason to believe that on the completion of the task, when you run: 

Then, I recommend you process the fields you don't need, and it helps you keep track of the specification: 

don't mix memory model strategies - volatile, and synchronized (and I see you removed the concurrent-based imports) all exist in your code. Typically, you only need one of them (which one it is depends on your circumstances) don't override Thread, implement instead. don't log in synchronized blocks 

Note, the requirements stipulate that each list is sorted, not that all the members of successive lists are larger than all members of previous lists. The hashCode method is appalling.... it calcualtes the hashCode on only the first and last nodes (if any), and does nothing with the 'down' or 'inbetween' The equals() method is worse ... it does not work if either list has any down-dimension values.... because it simply ignores that dimension. Since you rely on your equals method to test your implementation, and you don't test your equals method, your tests are useless. In fact, they are worse than useless because they have given you a false sense of correctness, when it's not correct. 

Then, your variable is useless. It's never set to . Instead you return immediately if it's not a palindrome (which is a good thing). Further, consider that your input is a which is a double-linked implementation (as you pointed out) which means a reversed iteration is "easy". 

Your code does not have a base case and a recursive case..... unless you consider to be the base case... but that is just the recursion-terminating statement. What I mean, is that, consider this loop: 

You can see the above running in ideone: $URL$ Note that the concept of describing an element in an output array as a function of the output index is sometimes a nice "trick" and neatens things up. You have to be able to spot this, though, in real code. Note that the above code basically says where is some function taking as an argument. Your code, on the other hand, works off the source index, and it tries to calculate the indexes in the output array from the source location. That's not "wrong", but as you can see, it makes for a nested, and ugly loop. Knowing when to reverse the logic is more of an art than a science, but being able to identify these logic inversions is important. 

Notice how the thread-2 can get in after the thread-1 has got the value, and before it has set the value? What you need is an atomic operation, one which gets, adds, and sets the values all in one locked process. You can do it with your code using: 

That will create a stream of long values that increases from 0 (and loops, and so on... it will create the stream . Now, you can 'peek' in to a stream, and see the current value, and do things with it, so, we can have a progress function: 

Yes, you should be opening/closing the printwriters each time. Yes, conceptually it's a decent way to convert the stack trace..... but... there are concerns, and is there a better way? The most significant concern is that, if there's a problem writing to the , the call will fail, and the method will return a default value. This is not ideal. The reality, though, is that those methods can never fail because the IO is to a StringWriter, and there's no actual IO component. A failure there would be..... inconceivable. None of your exception handling can really happen... it's just not going to fail (the "Titanic Logger"). The issue is that your code is checking for impossible conditions in a way that's overkill. Still, using some Java 7 semantics, you can use try-with-resource functionality, and get a much more concise method: 

MergeSort is a nice sort algorithm because the concepts are relatively simple, even the recursion makes sense, and it all just 'fits'. You have done a good job at describing the algorithm through your code. Putting performance aside, I think you did a good job. Small items to consider: 

Finally, inside the check method, you should not need to check for null values in the input, because you should not have added nulls when initializing the array. This strips a bit of code out. Also, the String concatenation line is 'bad form'. You should, instead, simply be able to do something like: 

I was brewing an answer to this question at the same time as the others, and it overlaps a lot with Syborg's .... but, it is different enough to present it. The reasons why this is an improvement over your code is that it has just the one variable. Additionally, it has tight loops without conditionals. Even though there is an outer loop, in many instances (long strings of words with few spaces, or words with many huge gaps), the tight loops will make the code highly optimizable. So, here's how I would code it (note that Java is my strongest language, so I normally get help with C....).