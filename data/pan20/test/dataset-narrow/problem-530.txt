Note that you're using a separate thread (on a threadpool) each time you write something to log, so there will be contention between multiple threads if you write to log quickly enough. I would recommend using existing logging frameworks like NLog or log4net to avoid inventing a wheel. 

Your example does show IoC tecnhique by passing interface to rather than actual implementation, but doesn't show the power of DI containers like auto-wiring and object lifetime management. In your example IoC container looks like just a replacement of a local variable that holds the instance . Example of DI autowiring using Autofac (use in NuGet console to install it). I borrowed 's definition of Oracle, it is more appropriate and demonstrates the IoC better than original code. I register before registering classes it depends on to show that the order is not significant here. Note that is initialized through constructor while is injected via property (just for demonstration, it would be better to use common approach): 

Operator overloads cannot be reused, you would have to reimplement them anyway. Both structures have references to each other which is not great. appears to add a very little value on top of . 

So, based on your update it looks like you've switched to reading from - good decision. A bit simplified/cleaner approach for reading int is: 

I don't think you need class there, I would replace it with interface and move the implementation to . And you don't need here, just use instead (yes, it will use boxing for most cases except strings, but it's more efficient than dynamics). 

Other than that encryption/decryption looks properly implemented, and I completely agree with original code writer that initialization/duplicate steps should be taken to constructor. It will reduce the number of parameters in Encrypt/Decrypt methods to one - actual payload. Depending on your specifics you can also expose methods accepting and returning encrypting/decrypting streams for large encryption volumes if necessary. 

Note that will never be true, because you create a new , and it does not implement interface. In addition to @mjolka's description why you have a 50% CPU load, I would like to suggest how you can avoid it. Currently you have a central place that manages all sockets in one place. I suggest to do it differently - have each endpoint handle the data on its own, and manage all sockets only as a collection of ongoing processing (tasks) like this: 

It's hard to suggest good solution based on the information you've provided... Will the number of entities change over time? Can they "loose" SpriteComponent? Assuming that the number of entities is the same and only Z will slightly change you can cache the sorted list from previous run, and apply TimSort or Insertion sort (you would need to implement it yourselves or grab from Wikipedia) to nearly-sorted list. 

Note that semantically these options are not equal. There is a chance (very-very small) that first option will output smth like , so second option is better at least because it will always generate consistent results (3 consecutive years). But second option is also quite cluttered. There is a method that is able to combine different values with separator, so your code may look like: 

Note that I already change the container type to . Otherwise the random access through would not work and you'd have to use again (or save the iterators instead of indices). 

Includes I figured your has some includes for , , and stuff. While you might find that helpful to only have one header , it's rather bad practice. A header should only include the stuff it really needs, no more. Otherwise you might create false dependencies. E.g. your is the only one that uses , which it only gets through including that doesn't need it. So if you change the includes in you might break . Also every header should have include guards, to prevent double inclusion. Avoid using Don't use to print the end of a line to your stream. It flushes the stream unnecessarily and makes your output slower. Simply use . For more information see here. Don't use Your header has a somewhere. Don't use that, you are poluting the global namespace with a lot of simple and common names. It's also less readable that way. The name is the namespace is so short on purpose, so that's it not a hassle to write. Again, for more info on that matter read here. Don't use magic numbers You are using hard coded numbers in your code for specific checks (required age for reproduction and max population). While it's easy to see what they are used for it gets harder to change them later on, the more your program grows. Use named variables for them, so it's easier to understand and you can see where they are actually used. Don't repeat yourself Whenever you write the same code twice, you should ask yourself, how you can prevent that in the first place. There are multiple instance where you create random numbers in some interval or check whether an event happened with a certain chance. Make those two things functions that can be reused and more easily read. And while you're at it, replace the random number generator with a better one(you can watch this to see why is considered very bad)). You could write a small namespace for such utility functions, e.g.: 

I'm currently using the Advent of Code programming challenges as an opportunity to learn some python. The following code is my solution for the Day 8 challenge, where the task is to write a programm that reads a set of instructions which are then performed on registers. Registers start with a value of 0. Each instruction may increase or decrease the value of a register. The programm should return the maximum value in any register at the end of execution as well as the maximum that any register had during the whole process. An instructions looks as follows: . Where is a name of a register, is either to increase the value of a register, or to decrease its value. is a comparison operator. The instruction should only be executed if the condition is true, e.g. will increase the value of the register by 10 if the current value for register is less than 0. I read the input from a file called . An example input can be found here. The expected output for this input would be . 

Other than that I don't see memory leak from the graphs you provided. Threads may still be alive in a thread pool, and memory may not be collected by GC yet. Here is what I've got as a result (note that it may consume more memory as you need to store all the chunks that are currently being sent in memory): 

Nice thing in participating/answering in forums like this is that you learn while you answer questions. I haven't heard about SpecsFor framework. Looks a bit tricky, but will definitely have a look later. Ok, back to your question :) About your first question, setting up the mock - you can definitely do that, there are a number of overloaded methods accepting delegate/lambda, depending on the number of parameters in the method being setup (here I setup the method to always return the same query regardless of the query passed: 

There are a number of articles describing why a is quite a bad idea when defined on top of ORM framework. Main reasons are leaked abstractions and abstraction on top of abstraction. And your example shows why - any optimization requires the knowledge of underlying implementation (Entity Framework). Running this process in multiple threads may help, but will put additional load on the database server and thus is not scalable. Note that Entity Framework's is not thread-safe, so you cannot share the in multiple threads unless you spin up a new per request there (which I wouldn't recommend doing). Assuming that you're using Entity Framework 6.0, method returns , you can try asynchronous implementation of the data retrieval: 

It is safe, but can be refactored using .NET built-in class. There can be several solutions depending on whether results of the execution can be cached. Simplest solution is when you can cache the results of the execution for the lifetime of your parent object. In this case the code can be as simple as (move initialization to constructor if is not static): 

This code is simple because it doesn't shut down the worker thread in case when there are no tasks. If you do need this functionality you'll need to add some more thread management code: 

You don't need to change anything as long as the code performs what you need. If you want to insert records to another table on every update (and not only in this place) you should probably take a look at triggers 

Naming. Methods should use verb phrases to denote the action they perform and try to be specific. So your method should become something like , or just if kind of dates is obvious in your case. Test naming. Do spend some time on composing a name for your unit test method that describes what exactly is being verified. does not provide any information except that it deals with method somehow. Incorrect responsibilities. Let's look at interface. It is an interface to obtain a list of dates (probably). And this functionality may be used in different places, not just to render this list in the HTML. But instead of returning or any other type of collection, it returns , which is only useful for HTTP communication. The only class that knows about specifics of how the list of dates should be used - is your class. And in your case (no special HTTP response or different HTTP codes) - method can return as well. Do use method when you perform read-only queries. Test expected resulting behavior instead of the way it was done. If your class manages to satisfy all your tests without calling the mocked instance, then either result of the mocked instance call is insignificant, or you should improve tests by adding new test(s) to verify the change in behavior depending on outcome of the call to mocked instance. Your test currently expose such a problem, as the only thing that it verifies is that controller calls to render the output. Instead, you should setup to return some list, and verify that the return value of the controller method returns the data in expected way. If the class under test does not call the mocked instance - it will fail such a verification anyway. In general the usage of is not recommended.