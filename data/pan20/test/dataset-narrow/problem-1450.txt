There is a tool you can use to do it manually that is relatively painless: $URL$ And there is a tutorial here: $URL$ I can share something automated on github if people are interested, the main catch is that if the frames are not even in size which is common, you may need to adjust them manually anyway. What normally happens when I work with sprites is that the frames are put into an even grid for ease of use. Then every sprite depending on the frame size is in . If that is not the case cause the artist is not aware of programming needs, I cook up a tool that displays the sprite sheet on screen and saves my click's positions into a file. I then use that file to split the spritesheet. I can elaborate on how to create a tool like this or you could use Ivan's advice. If you do go with making a tool, you may want to both save the first click (for frame's top-left corner, and another click in the bottom-right to get the width and height). I personally prefer the grid method, have your artist or friend cut and paste the frames into an even grid made of sufficiently large blocks. It would save you time if you have several sprites. Otherwise if there are many spritesheets and they are not in an even grid, you may want to cook up a tool or look for one online(I am not aware of any). They are not difficult to make. I can upload the source for the tool I use myself to a github for you to download. It saves the results into a text file organize by a list of four values for each frame. example: x, y, width, height, x2, y2, width2, height2, ... ,xn, yn, widthn, heightn You will have to sort (in the code which frame is which) to use the animation correctly. 

To do one, iterate over all tiles on the chain and find their , , and and that is your bounding box or AABB. Two is trivial. Iterating over the frame is simple, just make sure not to flood-fill outside the grid. You can learn how to flood-fill in Wikipedia. For number four you can start by only checking tiles adjacent to the chain. You could flood-fill from any tile you find that is not marked to locate more tiles. 

Now when you randomize the timer you should probably take the power level into account. For instance you could multiply the timer result by the square root of the next monsters power. 

You can use BFS to accomplish this exactly. You connect all obstacles as nodes (vertices) to the source node. Then simply connect each grid square to the it's neighbors. You don't actually have to do the connecting. You could simply start with all obstacles in the Queue and keep adding neighbors. Breadth-First-Search Time complexity is O ( V + E) so in this case, grid squares plus grid edged = grid squares * 5. Pseudo code: 

The buyer receives full copyrights on the game engine(code) and receives no rights over the game assets. The seller retains the license to distribute the game in it's original form without modifying and/or reselling the engine(code). 

I know this is not trivial so if you choose to take the leap, feel free to comment and I will elaborate. 

I would place them on the large map background and include their initial movement path on that map. That way I could change the camera path later in a meaningful way instead of needing to change both path and the timing separately. 

I think you should use something more natural.. give the players goals (quests) they need to accomplish in order to proceed. The goals will implicitly require the players to kill monsters in order to progress to higher level areas. So yes organically restrict higher level zones by making the player progress to them by completing quests. Another option I suggest is to make monsters run away if they don't get killed quickly enough so players will know a high level monsters is not a likely target and focus on lower levels until they are able to take it down quickly. This will give a sense of urgency to battle which is missing when the play cannot lose. Give players new weapons and tools that make higher level monsters more attractive. Make the best XP - per - second area a same level area. The players can kill higher level monsters but it will lower their xp - per - second. Later give them a weapon that makes higher level an easier and more profitable target because they can farm more xp that way. 

I will keep it short and sweet. There are two "servers" running. One locally and one remotely online. The user simply operates the mouse and keyboard to control the game. Input is parsed by the client and converted to commands (e.g. move forward / turn left / jump). The client sends these commands to the local server and remote server. They both process these commands. Very often, the remote server sends the correct state to the local server and the local one quickly interpolates it's "predicted" state with the true global state on the remote server. All rendering is done from the model on the local server. 

Latency, the client will need to send the user's input to the server and wait for the visual feedback from the server, this could take as much as half a second for clients abroad. Even if it only takes 0.1 seconds, it makes the game seem sluggish an less responsive. Rendering costs: first, you would need a GPU per client(?) to render the graphics. What about game logic and physics, you will need pretty much a CPU and ~3Gig memory per user. Compression: When Netflix sends video, it's a compressed format. Compressing the video just in time would be hard, which would contribute to latency and hardware costs. 

You know the factorial component of the UV values. It is represented by the black square's center in the second image; Based on its corners' positions (each 0.5 pixels away in both axises) you pick the four closest four pixels. This is the texture up close (4x4 pixels) 

Check where they are positioned (in the tile-map 2d array) after moving one step right: ie . Check in which tile they are positioned in. ie , same with for the other corner. Iterate from the tile the upper corner is to the one the bottom corner is in. ie : 

Divide each piece in the middle recursively until it is small enough, lets say 10 pixels or less, then build the bezier roughly from boxes and use Box2d for the physics cause it is possible that writing all this collision detection code will prove to be a great time sink that doesn't enhance the gameplay much. Using Box2d has proven itself in countless projects in the past. 

What you are asking about is called acceleration. Easing out and easing in. It is achieved by computing the elements current speed before you move it. The simplest way to do that if your goal is only smoothness in motion is to use acceleration. You do this like this (pseudo code): 

The main difference is, do we target someone or an area? You can write an abstract action type for these two kinds of actions. These actions will have access to the rules which is a service object that when given the situation and the action taken, can compute to probability of success, roll the virtual dies and also decide on the proper damage formula. The issue is that the the action, needs to know and be compatible with the characters' attributes and the tools used in the action. So in the general case, you need to allow others to input a list of attributes and compatible value ranges and distributions, representing a character and a tool. Allow actions to access that data and modify it. The commands or rules will need to be programmable items. It is very convoluted to describe how commands work without code and requires that you'll have predictive knowledge of everything that will ever be done with the system. What you can do is make some basic types of actions and allow others to inherit from those base types to create their own. The issue there is that the computation of probability and damage output will change depending on the game play system. 

This is suitable for any character in any 2d game with a top down view and with minor adjustments could be used for 3d games as well. Some images for intuition: Top down overview 

You could probably get away with running all the logic on the server side; I would never recommend running the rendering on the server side. Also, you should leverage the power of the client to respond to input (even if you correct it afterwards) before response is coming back from the service to improve fluidity. 

You would be wise to keep a state of this object. Then decide on the behavior based on the state and the input from the user. 

Then the bullet that originates from with direction will hit the sphere at of size You may hit multiple targets and then may simply need to check which target is closest to the origin afterwards. That depends on the complexity of your game, if there is not instance where targets overlap, that will suffice. You can use this to prune the targets. After that you would need to check for ray to polygon intersection. You can define an axis aligned box around your target, then find the box inside it with which the ray intersects. You will probably need to check for ray / polygon intersection after that. There are many example available online. 

You should not mix the view which defines how things look, like the teams' HUDs with the teams' model, their data structure or class instance. Like @pctroll said, the teams could be instances of a class. In my opinion, the class should simply be a glorified array of players and some methods that tally up score. The player class should have a pointer to it's team. Warning this is pseudo code: 

So this is how I would define a weapon: Factory component, Container component, Physical (position & velocity) component and health component. 

The first thing I would suggest is to use a 2d implementation like the one in Teleglitch, like you said yourself, you found solutions, this is a lot simpler. Line of sight is a gameplay mechanic. If the game is top-down, the gameplay is essentially 2d and there is likely a limited benefit to using actual 3d line of sight. No, you are absolutely right. This is not a simple problem. Imagine that without knowing anything about the content (without making assumptions about the visual space / the geometry of the environment), you actually "need" to send a ray for each tiny spot you wish to decide on. It is like checking collisions for a bunch of infinitely small balls moving towards all directions that are within the viewing angle of the source. It is not simple in 2d either if the data is complex enough, the advantage is that in 2d, you only need to sample a 1d space. In 3d you need to sample a 2d matrix so the amount of work needed especially for real time applications is very daunting. Using shadow volumes is probably your best bet. Octrees could help to reduce the amount of work too but those are both suggestion you alread made. 

How do I decide on an RGB color based on multiple different light sources? Is it simply additive by nature? What do I do about cases where the angle is not a sufficient way to determine intensity? For instance when there is a deep caveat in the surface and a higher elevated area is blocking the light to that lower shaded area? How do you handle something like that? 

Well, you could cheat like they mentioned:) You can make a sprite-sheet from the imagery, there is no need to zip it nowadays unless it saves a ton of space. After you create a sprite-sheet or several sprite-sheets from the images, you could simply rename their extensions. Most Gamers will not bother to check and why not leave that option to Artists who may want to mod your game in the future? That way they can too create a sprite-sheet, rename it's extension and start rolling. With the text files, I would humbly suggest you convert that data into binary form. I am pretty sure you will find a simple way to do it.. For instance, if you only use A-Z, a-z and the 0-9, you can use 6 bits to represent each character, that will somewhat protect your copyrighted material, it will also prevent others from editing maps.. You can always add a map converter if you like. Zipping is completely reasonable for text though.