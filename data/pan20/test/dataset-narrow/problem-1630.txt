The default settings are that if the Pi uses allot of resources during 1 minute period it will do a hard reset. You can test with a fork bomb. Type this into the console. It should restart within a minute. If it doesn't check the configuration. 

I have several of these modules. The problem with the slow ping is a bit strange? It should be less than 1 second, even more like 100ms. The other problem is this module only supports GPRS (115kbs) if your GSM supports dual band GPRS (or 2.5G). Most networks do not support this any more (or are deliberately switched off because it affects voice) so your speed is only going to be a max of (57.5kbps) and even that is optimistic. I would say you are getting about ~36.6kbs. Ping should be good at these speeds but browsing modern websites is fatal. It doesn't matter if you have 3G/4G or better in the area. The reason is that GPRS extends the GSM Circuit switch and the more people logged on within the area the slower things become. So what is this module for then? Well, at 8 bucks a piece its great for sending compressed JSON to servers for logging data. 

the denotes the format to output in. It does not mean it will transcode it like H264 to FLV just gets wrapped in the FLV format. then change the address to your clients VLC player. for example VLC does not seem to work too well on the Pi. I had very little success pushing the Pi cmaera module to my PC using UDP. It worked but it was not stable. You may also look at install nginx with rtmp module that works a treat. Look at this guide but you will need to tweak the settings a bit. You then connect your VLC player to the nginx-rtmp stream and it will work like a charm. 

I would suggest getting a better power supply. If you try and run an Amp and the Pi off that crappy, cheap power supply you are going to have issues, especially with WiFi on the Pi because of the incredible noise generated on them. Also, you might run out of power when your crank up the volume causing the Pi to reset (brown out) I usually suggest switching power supplies, like the ones used in computer. They provide high quality, clean power and are very efficient. You can find them on dx.com and ebay12 volt ($10-$15) for 5Amp, but then you still need 5volt right? Many people suggest an ubec dc-dc 

After disconnecting the WiFi, I captured a few responses. According to the page 22.13. Checking the Status of NTP the column labeled is "how long since last poll (in seconds)" and it increases with time as expected. But I don't understand why between 155 and 434 seconds that "jitter" changes, or between 434 and 687 seconds "delay" changes. Right now I'm classifying that as an inconsequential bug and ignoring it. To me, the value of "when" is most important 

For the next 1000 milliseconds, a transition in either direction on pin 22 will result in a call to , passing the new level and the tick number (microseconds). If I understand correctly, in pigpio one can set up one watchdog per GPIO pin, so there could in principle be many running at the same time. My question is what are these watchdogs? Are they CPU threads, or are they running in the GPIO electronics itself, or something else? Like real dogs, can they compete, conflict, or collide (say two watchdogged GPIO pins experience edges at exactly the same time), or do they get along nicely with each other? This is from and may be of some help: 

It turns out that this sluggishness in the pigpiod DAEMON's status is real. It's not a problem in the script. I saw this by accident while trying to stop and then restart pigpio while debugging a DHT22 script. Here's some text from the Pi's terminal. After the killall, pigpiod can not be started between and . The message: 

Comments by @Joan (above) were extremely helpful! MCP3008 does indeed use , where I had it erroneously set to . The following works very nicely! 

This is a partial answer; I am going to try to understand further why this is so. If someone is able to explain further that would be wonderful. The behavior described by the OP (in this case, me) is: 

I'm using pigpio bit-banging script (download, GitHub) that interprets the pulse durations generated by the DH22 Temperature/Humidity sensor. It sets a 200 ms pigpio watchdog to the GPIO pin and attaches a callback, passing the tick count and new level. Here's a generic example: 

Sorry, we do not do product recommendations on Raspberry Pi exchange. You are on the right track. GSM You can buy any GSM module that has SPI or UART. The cheaper the better you just need to send SMS, doenst have to be a 3G or 4G one! ANy cheap eBay one. They usually use UART (Serial Console) some are SPI but a USB one would be good? SIM CARD Find a security sim card. You top them up for example 10EURO and it lasts over a year. You can only send SMS on them, or only GPRS and they work on any network. So if it gets stolen nobody can use it. PRESSURE SENSOR The pressure sensor for 100PSI (NSCDANN100PAUNV) should work fine. It is a bit pricey at 30Euro but it seems like the good one. I would search a bit more I am sure there are cheaper ones for maybe 10PSI/20PSI from the same company. The problem with these sensors that are Analogue. You will need an A2D chip (analgue to digital) becasue the Pi cannot read Analogue. Basically how it works is that 0PSI is probably 0Volts (0% Input Voltage) and 100PSI is maxVolts (100% of input voltage) Because 6PSI is only 6% of 100PSI its difficult to detect edge using some resistors and other tricks. BATTERY The size of the battery depends on the circuit wattage used. It defiantly cannot be 4xAA batteries. Lead crystal batteries are good but you would probably need a car sized one to last a decent 4-6 months without having to change it every few weeks. POWER CONSERVATION You could use "Hall Effect Water Flow Meters" because they basically do not use any power. They get activated by a switch from a magnet. Pressure gauge is not to bad power usage but its still power used when you dont need it. Do not have GSM power on always. Have a switch to turn it on when you need to send SMS. Raspberry Pi. You would have to go for the A model and disable allot of stuff to get down to hundreds of milliAmps usage. Its doable though. Solar panel? You can charge the battery using a small panel or wind propeller? If you want to run on AA batteries, you cannot use Rasberry Pi. You would have to go to Arduino or PIC programming and circuit creation. With these things you can use a small battery pack (like NiCD used in RC racing) that could last 6-12 months. 

appears when trying to kill it. So for almost a minute, the DAEMON is a zombie (so to speak). This means that the idea of quickly turning it off and then on again is a bad one. Instead, if the OP (me) really wants to do this with Python, the script has to honor this transient zombie status and not just start and stop it willy-nilly. 

The scripts and the results mostly speak for themselves. returns good data when I use the standard I2C GPIO pins, but the bit banging I2C returns what looks like random data. What might I try to debug this? note: I didn't forget to move the SDL and SCA leads to the appropriate pins. Using 3.3V to supply the DS3231 Real Time Clock. 

Today's announcement at raspberrypi.org: Raspberry Pi 3 Model B+ On Sale Now at $35 describes several improvements. In the linked YouTube video changes to the power supply are discussed between and , but I'm not quite sure which parts are historical review, and which are related to the most recent changes. Could someone point out which are the main points they make here about the new Pi 3B+ power supply? 

Question: What could cause to fail to start pigpiod successfully some of the time, but still always return and throw no exceptions? edit: RPi 3, Python 2.7, Raspian 8.0 jessie Failure looks like this: 

After turning WiFi on again and letting it run for a bit, I see the following, which suggests that it's periodically checking. 

I started to try to read an MCP3008 ADC using SPI bit banging with pigpio. I wrote the unattractive little script below, starting from the example in the pigpio documentation and here is a screenshot of my output. I believe that this should read the lowest four channels of the ADC and print the output. Channels 0 to 3 are connected to +5V, GND, +5V, floating, so I expected to see values like 1023, 0, 1023, xxx where the last would be noise. Instead I see all 1023's. Have I done something terribly wrong? 

When you get the you just stop transmitting and when you get you start transmitting again. Obviosly from the Pi's side you will never need to send because the Pi has enough processor power to handle 115kbs of text without backing up its "buffer" reference: Implemenation abstract 

A really really cheap solution to enable your existing home phones to use VoiP instead- If you want to recieve phone calls on your existing number, you can buy a cheap DID for voip and then redirect all incoming land line calls to your VoIP DID. Sorted 

You need to download the source code, open it in Visual Studio and work out where the class is coming from. 

Please read my comment on your question. That still stands. The only thing I can suggest as a possible answer to help you get started is to make some kind of plan. 

What I would suggest is to use an IP Phone instead. It may save you the whole sound problem headache but I hope you will see the benefits. This would mean installing Asterisk on your Raspberry Pi and resigning from using the Pi as a VoiP "IP" Phone. Also, having an IP Phone means you can directly connect the IP Phone to your VoiP provider defeating the purpose you have in mind. You can get fairly cheap IP Phones that run off LAN or WiFi. 

You then have the freedom to code in Python (I2C Library), Mono C# (sharp IO) or direct from the console with scripts (using GPIO Utility). 

Multiplexing can also be applied the other way, by turning on things at specific places in the matrix. A nice example are LED's cubes, where you can trigger LED's in a 3D matrix using the correct sequence of GPIO's. 

And here is a PDF on how to configure the tn5250 So when you say it doe not support the features you need. What features are you talking about? 

That is why it seems to be popular for adapters like this, that avoid cutting the cables and should work with 5 volts no longer than 6foot away, otherwise you need 12volts with a step down DC-DC for up to 30metres. 

I am writing a data logging python script and I would like it to find out if the system clock has been synchronized via NTP recently, and if not, to attempt to cause it to happen before proceeding. Starting from this answer, I've found that for the status 

smbus works. When I convert these back from BCD to ints, I get a reasonable time object, with seconds increasing at 1 Hz. 

edit 1: per @Joan's comment: pigs, the socket interface to pigpio also returns random bytes. The following are the pigs equivalents to bb_i2c_open, bb_i2c_zip, and bb_i2c_close. All bytes are non-repeating. 

What caught my eye is the "stability" measurement. I'll let it run for a while to see if it becomes non-zero, hoping it might address Question 2 below. edit 2: Looking at the question timed out, nothing received on ntpdc> loopinfo? I found the command 

edit 1: I've taken a look at Install NTP on CentOS which turned up in a search for help trying to understand what "lithium.constan" meant, and I found the command: 

will display the results on the console, but I don't know how I can get the python script to see if ntp is active or not, since this call returns only . I could always just force a reset even if not needed using 

I'm trying to check on the status of the pigpiod process from within a python script. These two methods both appear to work so far. Are there any significant advantages or disadvantages of one over the other? Are these likely to be reliable ways to do this? 

but it seems like a bad idea to do that if it wasn't necessary. edit: using Raspbian GNU/Linux 8 (jessie) Question: How can I test the status and then conditionally force a synchronization only if needed? This answer suggests the package $URL$ but I'm not sure if this is advisable or not, so I thought I'd ask before installing and running it, and I'd still have to guess the status by comparing the results to the system clock and deciding if the agreement were good enough or not. I'd still like to know if ntp is active and that it believes the synchronization is close.