Then you should probably cancel incomplete processing when input changes. If you are going to discard the result anyway, then there is no reason to wait for completion. 3s is a lot of time. I don't have a clear understanding on how recursion works with . It can behave differently. Maybe you should take extra precautions to make sure that stack can not overflow. I'm not a fan of prefixes. But that's a personal preference. name is a bit confusing. I think something like would do a better job at explaining what this flag is for. Also postfix is unnecessary, prefix already hints, that it is a field. 

As for your first question: you can override method of your class to return Name+Price the same way it is done for . Then you can simply call 

why content can not be null? I would assume that at some point you are going to add an element with no children/content. Should I pass in that case? I would rather just pass (or pass nothing at all). 

It depends on your design entirely. If classes (2) and (3) can not operate on their own, should not be instanciated and are there to serve as base classes only, then you are justified to make them abstract, and i think you should. Also, you should probably reflect your intent in class names by adding suffix to (2) and (3) (or prefix, but i think it is less common). Edit Objects with protected constructor can still be instanciated. For example, you can create them from some method in derived class. It is not a realistic use-case in most cases, but you should not leave such holes nonetheless. If you want to forbid instanciation completely, the only way to do it is to mark the class abstract. 

You should use multithreading for reading if you are after performance, so solution which uses is definetely better. For really big files, you should not read all the text into memory. Instead you should create multiple file streams, split your file into reading sections and read those asynchroniously. For smaller files (200 lines is really small) your approach is fine. Your algorithm can be simplified if you'd use method. For example: 

Loops and Enumerators Loops should generally be avoided in ruby. The one exception is maybe a / loop. A loop should be avoided since it has different scoping rules from using an enumerator + block. Instead, try to use enumerators. They are shorter, simpler, safer (extra scope, usually hide loop counters, reduce mutable state, often remove the need for conditionals), and more explicit (e.g. what does this code do ). Stlye Guide The community style guide is an excellent guide. It doesn't just tell you what to do, but also why. And despite the name, it isn't merely about style either. You'll want to read it. The style guide comes with a great gem that does a lot of checking automatically (but do read the guide): Rubocop 

I always find that the literals , and are code smells in ruby. This is because ruby expressions are always implicitly truthy or falsey and either or not . This means that the expression can almost always be written more succinctly and more efficiently as just (the exception being when you really need and not just truthy). Game I found this rather complex to read. A first suggestion would be to use attributes. That will get rid of all those signs :). In you are calling . But start screen has nothing to do with initializing. It is already running the game. Why not move it to the method? Should all methods be ? What methods do you want clients to call? You are setting up the player defaults in start_screen, only to then potentially change them later. Why not set them once and only once? The method is a predicate, so should be named . The method is not a predicate, so should be named or perhaps something else like . I like the name of the method , but should it be responsible for drawing the board and checking the result as well? You might be better of using a plain old instead of a case statement in Example code Here are some mostly complete examples. I feel that there is more room to move stuff around, but they should indicate the things I touched upon. I feel that the example class still has to much conditions and to much raw data. 

You should probably remove the constructors you don't actually use. Otherwise they look fine. What does not look fine is the way you use exceptions. Exceptions are... "exceptional". They signal that something really bad happened: an invalid state or an error in the workflow which your class can't handle. Exceptions should NOT be used as part of your regular workflow, especially not if you catch those exceptions straight away with an empty catch statements (which are bad enough on their own). In those situations use instead. Here is a quote from MSDN: 

The usage is fairly straightforward. You inject the service into your form's constructor (or instantiate it there if you do not care much about IoC) and store it as a field, say . Then you just wire your UI to appropriate methods. For example, if we take the API above, you can refresh the list as follows: 

To answer your question: those solutions are identical performance-wise. There is no "magic" in or methods: they do the same thing you do in your first solution - compare the two values using operator. There is no significant performance cost for a method call or for an extra assignment - those operations are so cheap, that you won't solve any real-life performance issue with this kind of optimization. If you will become obsessed with those small things - it will have a negative effect on your code quality. So, instead of asking, which is faster, you should ask yourself which is more clean, readable and OOP-ish. I would go with second solution. If you want to really speed things up - you should first identify the real problem. In your example - it is the number of iterations, not the number of assignments. So the faster solution would probably involve multi-threading and iterating through different parts of your array simultaneously. 

I think name is too generic. Class name should reflect its purpose. is an example of better naming. Same goes for and . Using operator after using should generally be avoided. You should either use and then use strong cast, or use and then a check. The second option is usually better since this way you only cast object once. You should split your class in two. One class to contain implementation, which you will use in your view models (), and another class to contain page-specific properties, such as header, "back" reference, etc. (). is really confusing name for a property, which holds a view model reference. There is a potential issue with your setter. Calling will probably crash your software, as it will leave in disposed state. You should check viewmodels for equality first, and only then you should dispose the old viewmodel (your method does not currently allow that). Your method has a similar issue, as it might set to already disposed object. I would also use in your to store back locations instead of storing them in each individual page. Otherwise you will run into issues for more complex scenarious such as "page1 -> page2 -> page3 -> page2". Will you be able to return to page1? Or will you circle between page2 and page3 instead? I think you should avoid using events in this scenario, it complicates things too much. Use interfaces instead. 

My Question: Do you think this is an appropriate design? I believe the biggest drawback to this is that the is mutable. Brainstorming a few other ways: 

I've implemented the coin change algorithm using Dynamic Programming and Greedy Algorithm w/ backtracking. The description is as follows: 

There is one catch to this idea. The and are mutable (which I believe immutability is strongly suggested by Spring). It's possible that the and/or fields are supplied by the client/UI, or they might not be (orgId will always be supplied from the UI form). If they are not supplied, we query our database for them. If they do not exist in our database, then we throw an error. They almost always will NOT be supplied. To do that, I change the to override the methods and look up the or if they are not provided 

It would be nice to have a code review to show me where I can improve on readability (along with other things you may find!). I've been trying to clean it up and refactor a bit, but a fresh set of eyes would be nice. I went a bit crazy on comments because I wanted to make sure I would be able to look at this in a few months and not forget why I did something the way I did. But perhaps putting some of that info in a github wiki would have been better. 

I'm integrating with a 3rd party vendor that has and in it. My tool is a user administration tool that allows us to store information in our local database about the and that we manage in the 3rd party vendor. So the and are stored in the 3rd party vendor as well as our database (we act as the middle man sort of). I'm at a crossroads with some ideas and would like to hear what others thought of the following problem and my solution. Before I dive in, we're using Grails 2.4.4 One use case for the tool is creating a . We create the user in the 3rd party vendor via an API call, and then we store information about that user in our database. There are many uses cases like this and there are 3 fields that are always in common between them, an a and an . These 3 fields are required for just about every API call we make to our 3rd party vendor and most of the result in an API call being made. For this reason, I had the idea to make a "Common" with these 3 fields on it that can be extended by another Command Object.