is a shell script in on Raspbian. In the version I'm looking at from a 2015-01-31 image, the "Advanced Option": 

That will mimic Ctrl-C. Alternately, you could install a signal handler for SIGTERM. That wikipedia bit refers to "the signal() system call"; system calls are native C, but python has an interface; you can read about that on the page from the first link, "Set handlers for asynchronous events". 

I don't know how you're measuring that, but it is well beyond the maximum recommended operating temperature of 85Â°C and implies the SoC is now garbage. 

Measuring the passage of time like this is very accurate; the system calls have a nanosecond granularity and will give the real time in relation to other calls. This is implementing a passive delay: 

The pi's USB ports are 2.0; your PC, and the drive, probably have (much faster) USB 3.0 ports (which are backward compatible with 2.0, but then limited to 2.0 standards). While USB 2.0 has a max theoretical throughput of 480 Mbps (= 60 MB/s), it is often acknowledged that realistically, including protocol overhead, the max average data transfer rate is more like 280 Mbps (= 35 MB/s). If you have ever studied serial communication protocols, you will understand that they are far from "zero cost" and that hardware standardization does not take them into account. So you are getting about what is to be expected. I've used external drives on pis regularly for 2 or 3 years now and I've never noticed them exceed 30 MB/s. Also note... All the USB ports and the ethernet jack share the same hub/bus, so that limitation applies to transfers for all of them combined. 

The last line of output is just an example but that's more or less what you should see. There might be two exclamation marks. Now open , find that line (the one starting with , or whatever name you used) and remove the (or two) from between the first two colons, so it is . This makes this a passwordless account. Now: 

Chromium is the fully open source version of Chrome. Since the complete source code is available, anyone can try and compile it, so pre-compiled versions for a variety of platforms including the Pi are available. Chrome proper includes proprietary bits, so the only binaries available are from Google. Their download page is a bit high on glitz, low on information, but it is fairly implicit there is no ARM version viable on any model of Pi. 

It's not clear what you mean by "a lot" here: As in, the number of consecutive waves, or the pins that can generate waves simultaneously? If the latter, basic PWM generation on the Pi only has two independent channels, which can be accessed via 4 pins; GPIOs 12 and 18 for channel 0, 13 and 19 for channel 1. I believe pigpio has a number of other ways of generating pulses by making use of some of the other clocks on the Pi and joan's links should lead you to examples of that. With regard to the basic hardware mentioned in the last paragraph, here's a simple C program using libbcm2835 to generate a 40 khz pulse. This should work on all models.1 Part of my point is whatever implementation simulink uses, it probably only makes use of these two basic channels. Note most of the code is actually OS signal handling so you can start it, let it run in the foreground, then stop it with ctrl-c and have the pin reset as an input. Actually turning on the wave in hardware only take a few lines and the process then just sleeps indefinitely as it does not have to do anything except wait for SIGTERM. 

Here should be whatever you've named the kernel binary. You may also want to look at , which contains parameters passed to the kernel by the bootloader. Lots of documentation, etc., on the official github page. Beware that people have already made various efforts to port Android to the pi and as far as I am aware none of them have been very successful. 

-- or at, least, the "improved" version, -- is a great piece of software, but it is not easy to use, and the default configuration, which does not indicate the difference between insert and command modes, is awkward (the basic philosophy is that features are not enabled, making it seem pretty "featureless"). I totally encourage you to learn vim at some point, if it holds some appeal for you. However, what I don't recommend is trying to hack-use it while you are also trying to do some other thing for the first time -- as you observe, this will probably be a very frustrating, "WTF?" laden experience. A lot of linux/unix instructions include references to vi because it is required software on such systems, so it is guaranteed to be there. Some stuff replaces this with , which is not required, and therefore might not be available, but it is a much much simpler beast than and should be easy; the functions at the bottom mean "ctrl-X", "ctrl-G", etc, and one of them is a help. I think nano is included in the base raspbian but if not, just . Then you can just use instead of for simple tasks like this. WRT "are there any instructions for the vi app" -- yes, there are entire books on it, and a built-in help feature with plenty of available reading. I recommend you add this to the top of 

1. I'm guessing the second, discarded , has to do with whatever protocol/mechanism is at play -- note and consider the .... 

So there's three additional reasons for this that have to do with interprocess communication, which makes sense. Those three reasons may have negative consequences for the application involved, but probably don't indicate any wider issue (as a failed memory request would). You can have a look at the list of processes currently using the C++ base library with: 

This will put it in , which should override the normal one -- double check is at the beginning of . You can also check with . 

The repo likely contains packages from the testing branch (v.10, Buster). Sometimes it is feasible to install them manually, but it can get pretty tedious (so you might want to try a source build instead first). First: 

1. Regarding that and something in your question: it is NOT 5V on the pi, it is 3.3V. There is a 5V output for powering 5V devices, but never connect that directly to any other GPIO pin or use it as the supply in a circuit such as we are discussing. 

Using to run a boot service. But that's not the cause of this particular problem. The Pi does not have a real time clock like standard computers. The system has no way of knowing the actual time when booted. Raspbian uses an NTP client to get the correct current time from the network, but obviously this requires a connection to a network and may take tens of seconds to complete, during which time your program has already started. Prior to getting an update via NTP, the system either uses the Unix epoch as the time (you may notice files time stamped 1969 or 1970 because of this) or else a timestamp created by the OS during the last run (I am not sure of the details; I believe it should happen at shutdown). 

"abdb-123" here should be the output from when you know the correct drive is attached (i.e., it's the UUID of the first partition, if it has one). Beware that if you reformat that partition, the UUID will change. With regard to unmounting, you could create a parallel script in that stops the server then s the drives. Then you just call that instead of doing the yourself. 

Again, this depends on how the other computer can be turned on and off. Many of them will respond to wake-on-LAN, in which case the answer is yes. If not, and simply turning power on is sufficient, then as joan points out, the pi can be used to control a relay. 

Get rid of all the keys you've generated so far. As in remove everything in ~/.ssh on both pi's. Create a new key-pair (with or w/o passphrase) on the first pi. Copy the id_rsa.pub half and rename the copy "authorized_keys" (no suffix), and move that into on the other pi using a means that you are certain of, eg, by putting it right on the SD card. You could use the superpi instructions recommended method, but do not do keep doing it over and over. Which is probably why it is just easier to copy it onto the card or use some other such direct method, since you don't have 63 more pi's to do anyway ;). 

There is no substantial difference, operating system wise, between one model of Pi and another, if that operating system userland is compiled for ARMv6 (matching the processor in the original BCM2835 SoC). The Pi 2 and 3 require a different kernel, but that is usually shipped with the rest of the OS ("the rest of the OS" being the userland). If the OS is compiled for ARMv7, it will only work on the Pi 2 or 3. If it is compiled for ARMv8, it will only work on the Pi 3. Note that Raspbian (and hence likely Minibian, since they probably do not compile themselves) has only ever been released in an ARMv6 version compatible with all Pis. There are likely aspects of the various models that need specific drivers, but that should be covered by using a recent kernel (and you will need the in the boot partition for the Pi 2 and 3). The Pi Zero uses the same SoC as the original Pis, with a higher max clock rating stamped on it. So any OS distro that's ever been released for the Pi (except those compiled for ARMv7/8) will work. The Pi Zero W has an added bluetooth/wifi component that will require a kernel with the right drivers. The Pi 3 was the first model to sport that component. I think the drivers were actually in the kernel before the Pi 3 was released, but just to be sure you should look for something from March 2016 or later. Which was exactly when the last Minibian image was released, and their homepage indicates support for the Pi 3. But this implies it is no longer being maintained, making it a poor choice of OS. 

You'll need to if it isn't already installed. Hopefully it says something, revealing who the culprit is. If it says nothing, try ; if that fails, wait 5 minutes and try again. If it doesn't work at that point, something very strange is going going on; have a look at 

This is a misreading of the linked information. That's not what it requires. It is the "recommended PSU capacity". PSU = power supply unit. I am pretty sure there is a hard limit of 2A on how much can actually be drawn through the microUSB jack (only the 3 is higher); after that you risk triggering a polyfuse (which if you aren't going over much will just mean the board shuts off and won't go back on for a little bit, but probably most likely: A drop in voltage that shuts the board off first). The "typical bare-board active current consumption" from that chart -- 330 mA -- is a (minimal) figure for how much the Pi 2 itself will use, and that seems reasonable enough. Round it up to 0.5 A, then start considering your peripherals. You should have enough for the camera (250 mA), the display (0.5 A), a USB keyboard (<150 mA) and normal size wifi dongle (<250 mA) and/or ethernet link, and with some headroom left over. 

Not a chance. Unfortunately, most manufacturers do not support linux and so other people have to write the drivers, which is why there is not necessarily a perfect one for every device. WRT the rpi specifically, if you are buying stuff for use with it, check the verified peripherals page. The wifi adapters have a page of their own linked in that one, and if you check that page you'll see a couple of (slightly conflicting) reports about the TL-WN725N...I would not trust the one about "manual driver installation" as this person seems to have made an incorrect assumption about what model numbers correlate to what driver. 

This is a serious misconception about how operating systems work. Sans GUI, linux needs very very little memory. Here's my raspbian pi right now: 

If you downloaded the source from github, put it in and symlink it to , which is mentioned in your module makefile. 

Perhaps you missed the linux instructions because they're the simplest, so if you are scrolling down a page filled with Windows and OSX screenshots that short paragraph could be hard to spot. You run: 

One flash is unusual; my first guess would be the SD card got corrupted or is not inserted properly. Two flashes is the norm, indicating it got through booting firmware and loaded a kernel. More than two flashes indicates an issue as per the elinux page. 

Call that and run it . The time reported by will change every three seconds if nothing else does. Note this will occupy a terminal until you stop it with Ctrl-C. 

If that does not work out, try ; you should get . If instead you get another segmentation fault or other errors, try .