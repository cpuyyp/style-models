Look closely at the left side of both holders. The one on the left is missing part of the plastic that is still present on the (unbroken) holder on the right. I did not even notice this happen, but I did see the 2 millimeter wide (and 1/2 mm thick) piece of plastic lying on a table where I had been using the pi. Those holders are not very sturdy and, particularly after a few years of sliding cards in and out, it would be easy to break one and never know. Also worth noting is that the case on the right has a layer of thick acrylic all the way across, pressing firmly against the holder, which is probably why it is not also broken. Adding to the stress on the flimsy holder, and part of the cause of the subsequent problem, is that the metal connectors at the end are springy -- not because there is anything behind them which yields when a card is inserted, but because the metal is suppose to press flat, squeezing the card against the flimsy plastic. Without that little strip on the left, this pi usually will not boot as is; it behaves exactly as if there is no card there. However, inserting a card feels the same, and it stays in place, and pretty much looks the same as well. My fix for this was to wedge some pieces of pull tie across the holder, wedged into the case. It is not a very good fix but it is fine for what I use that pi for now (note the hint of velcro at the bottom though :) it has been in a used in a few strange positions before). It is easy to tell if the holder is broken this way if you have another one to compare it to. I think it could be difficult otherwise -- the contrast and shadow in that image exaggerate the slight roughness I can see with my (20/20) eyes in bright light. And that's only because I squinted at it after finding the same color plastic sliver on the table. It is also easy to tell if it is the cause of the booting problem by inserting a card you know should work, holding it firmly in place with your thumb directly over the business end where the connectors are, and plugging the pi in. Obviously: Do not let your grip slip at all if you must then turn the pi to look at the green ACT light. 

I'm interested in compiling a custom kernel for the pi. I have the source from the github archive, which includes a make target for a default configuration: 

If that works, you can try reducing the subset of things it includes explained here, since the resolution this way will be low. For example, it may be that all you actually need is 

From here. On linux Ctrl-C generates SIGINT, so you get an exception, which you've handled. But if you use : 

is NOT a "startup" file. It is a configuration file for POSIX shells such as , the default shell used on Raspbian and GNU/Linux generally. If you want the shell to run a command at startup for all users, the place to do that is . However, this should NOT be a persistent process. This defeats the whole purpose of the shell. "But I don't care" is not a good reason to do it, and if you are determined to do things the wrong way, then there is no point in asking for advice online when things go awry. Anyway, if you want to start a persistent program in the GUI, there are several ways to do it: 

I think a lot of people are hypnotized by the low price tag and some of the things some people with a lot of savvy and expertise have gotten it to do. I think a lot of those same people have been sadly disappointed when they get it and realize what <$50 worth of parts really adds up to. You get what you pay for. It is not a miracle device from a more technologically advanced alien species. It is a clever little thing from the UK. One thing that is unusual about it and attracts a lot of people, vs. a PC or phone, is the GPIO breakout. While adding comparable bits to a normal computer may (or in fact, may not) be possible, it is going to cost you a lot more that a Pi just for the adapters (and put much more valuable equipment at risk of damage). 

You may want to have a read over the invocation section here, and note that on Raspbian is actually a link to , which will conform to type behavior when invoked that way. However, because of the naming collision with "remote shell", which the latter won, is not what you are looking for. I'd try instead. 

I'm not sure, but based on what you are saying about the fact that it doesn't happen under load, I'd guess it may be because the baud rate is tied to processor frequency, which is governed by the OS. Check the output of the following: 

is the output (an error message). The command you were intended to use here is actually . The reason was used instead is sometimes people will have this defined to expand to the name of something that will fulfill the function of . This is a bit esoteric, because it really assumes you know something about , which are generally written using variables with specific conventional names to refer to generic tools. In the context of executing a makefile, has some of them predefined, including , and whoever wrote that presumably thinks you will recognize that. Which is pretty presumptuous, since it probably isn't defined in most people's environment. Anyway, what you should be doing is: 

This isn't exactly a way to keep it on directly, but it is a way to disable it completely so if it is already on it can't be turned off. This only works in an X server setting (i.e., with the GUI desktop). First: 

It certainly won't be , because that path isn't in $PATH. If there's a node in $PATH, it would use that. If there isn't, that variable will be "which: no node in (...)". You could add to path at beginning: 

The latest version upstream from Rasbian 8 -- "upstream" being Debian, not the owncloud direct releases -- is 7.0.4. I don't know if that is the client, the server, or both. I'm not an Owncloud user but it looks at first glance to be pure PHP, meaning you don't need to dig around for a version compiled for ARM. I could easily be wrong about that though. Of course, WRT this doesn't matter anyway; the version in the repo is the version in the repo. Debian has an official policy of being fairly conservative with version upgrades, meaning they rarely offer the latest version of anything in their stable branch. In this case there doesn't appear to be a corresponding package in the "unstable" branch, so that's pretty much that. 

If you want something on a light fixture that can both control and report the state wirelessly, I do not think there are any options that are going to set you back much less than ~$20. This is because you need something to integrate whatever it is you need to control the light (e.g., a relay), with something that can report the state of the power to the light independently of the state of the relay (I presume this is why you have differentiated between controlling the light and associating a sensor with it), with something that can communicate wirelessly with the pi. At the high end of the range, I believe there are XBee units that will fit this bill, for which you will also need a corresponding transmitter/reciever on the pi (note, I think XBees are not necessarily both, and since you want two-way communication at both ends, that's what you need, and a transmitter/receiver cost more than just a receiver). You also need a way to covert the high voltage AC at the fixture to the low voltage DC of the XBee; that is probably another $5-10. Plus the relay. You could also use an Arduino nano clone, ~$5, and use 433 Mhz radios, which are similarly cheap for a transmitter / reciever pair (or a wifi module, potentially also very cheap).1 Although in theory I think the range on these should be fine inside a house powered from Pis and Arduinos, I have (yet...they are in a drawer...) to try it myself so cannot say for sure; presumably the wifi definitely is. I think this is one of the cheapest options, but it is also probably one of the more complex to implement and you still need that power supply, so again, another $5 - $10, plus the relay, for a total $15 - $25 per unit. Probably still less than the XBee solution. You could use a pi zero much the same way (also $5 -- not including an SD card, which an Arduino nano does not require), but these are in high demand and very hard to actually get right now for $5. Put another way, it is unlikely you are going to be able to do this using DIY tech with a Pi in a manner that cost less than plug n' play, smartphone app controlled things you can buy that screw into light fixtures and install into switch boxes on the wall. The simple reason here is that there is a growing, already large, market for such products and many manufacturers can easily produce devices dedicated specifically to this at much lower cost than you could create yourself. This is generally true of any pragmatic pi project (although there are no doubt exceptions) -- e.g., if you just want an indoor home security camera, you are better off buying an integrated unit if your motivation for using the pi is you think you will save a few bucks. By the time you have all the stuff you actually need, you won't. However, if you want to do it as a DIY project out of interest, it is not necessarily that much more expensive, discounting the additional time it will take.