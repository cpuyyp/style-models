You should consult a lawyer. It may be possible to do this, depending on the products in question, your legal jurisdiction, the legal jurisdiction(s) in which the products have IP protections, and so on. You're going to need a lawyer to help you unravel all the tangled, varied license legalese though. You specifically cite the example of laptops, and the branding on those laptops. That branding is almost certainly going to require complying with license terms (here are legal notices containing relevant data for Acer, Apple, HP, Lenovo and Microsoft, just to name a few... and some of those are US-specific). Other sorts of products may vary, you're going to want to do research and confirm the legality of using every single item you want, probably individually, as there aren't really many blanket rules. Guns and cars do require licensing from the appropriate manufacturers, for example. And while it might be acceptable to model a coffee mug that is "exactly like" some other generic coffee mug, you probably can't model it exactly like a specific coffee mug because the logos on the mug might be protected by intellectual property laws, as before. There are even logos and branding that one might assume is safe for public use, being from government agencies, but even that is often covered by some kind of protection. In short, even if you can afford a lawyer to help track down and make all the arrangements, I question that the result would be worth the time, effort and cost. Generally if you're trying to find out "how close" you can mimic a thing without legal repercussions you are on the wrong path and should find a new one. 

To my untrained eye, the "camera" is looking at the characters in question mainly from the side. You're seeing what would be the front of the bodies (the chest) because they are standing in a combat-ready pose (as you posited) that is akin to a fencer's pose (to help minimize the surface area presented to the foe). Not all of the characters have as much tilt to their body, which accounts for some of the variation. I don't think the actual "camera" is viewing the characters on a diagonal, like in your last sketch, because if you were to draw a horizontal line at the level of each sprite's heels you'd see the heel of both feet is generally on or quite near that line (unlike in your last sketch). Though the bottom pixel of the "back" feet is often lower than that of the front, that's due to perspective and the fact that the character's feet are at approximate right angles to eachother. 

This should get you off the ground. As your project grows, this kind of tight coupling between systems becomes very undesirable, because it increases the difficulty of maintenance. To avoid this, you can implement some kind of observer pattern to isolate dependencies. In such a world, incrementing the score would raise a "score incremented" event. External systems (like the game itself) interested could subscribe to that event and set up the enemy spawn. 

Use the function. The parameter list is a bit daunting, but most of the parameters are optional and can support null values. Do note, however, the comment for the parameter: 

To compute the nameplate position (in world space), start with the character's origin (in world space). Hopefully your character origins are defined such that they represent the center of the character on the ground, since that's the meaning that makes the most sense in general. If your character origins are something else, you'll need to account for that. Then, compute the character height plus some offset to allow for the padding between the top of the character and the nameplate. As you've noted, this is a floating point value. You can't add a float and a vector, but you can add two vectors, so if you simply construct a vector and add that to the origin of the character, you'll have your nameplate origin. This assumes, of course, Y is up in your world, but that is similarly easy to adjust for. If however "up" isn't always the same (for example if a character can stand on a 45-degree inline) you will instead want to construct the offset vector in a more general fashion. One way to do this is to take the normal vector of the plane the character is standing in (which should be normalizing it) and scaling that vector by the character height and offset. This also produces a vector you can add to the origin. This gives you the nameplate position in world space, which you can use directly or project to screen space if you need to. In some cases it may be more desirable to instead project the bounding box of the character to screen space, find it's highest Y position and use that (plus some offset) as the basis for the nameplate. Both methods (and many others) are valid, it depends primarily on what sort of effect and behavior you want out of the nameplate. 

You can then open the file up and alter the placeholder names to match what you actually see on the sprite sheet for that section. No matter you're going to be naming the tiles yourself. You could aid yourself in this process by adding the following features to your program: 

Beyond that, there isn't anything really special you need to do. You may want to consider something like git-annex to deal with large assets that you'll want to check in. 

Note that you don't need to create strict unit tests to actually employ a unit testing framework; it's perfect acceptable to use them to simply drive some quick automated tests. I would peruse the above, plus whatever else you might find on Google, pick a framework you like working with, and write your tests in that. When building tests, I find it beneficial to create one test for all classifications of input. This actually tends to be fairly easy when writing tests for mathematical operations -- for example, were I writing a set of tests for the sign() function I would have at least three: one for zero, one for a positive input, and one for a negative input. It's also helpful to work through the expected test results by hand prior to writing the test. This will both help you reinforce the math yourself and help ensure you use the same conventions used in your actual math routines. 

There are tools out there that can help you, such as Shoebox. But tools-recommendation questions aren't appropriate here, so instead I'll describe a basic process you could use to do this yourself. Since the sprites in the sheet are regular (that is, they're all the same size) you can pretty easily write a program that produce a set of rectangle data in JSON based on the size of the image. You only need to give this program the image file name, the desired tile size, and the output file name. It would then: 

Instead, build your asset bank as a regular class, and create a single instance of it when the game loads. Pass references to that interface to methods or other interfaces that have a need to load or otherwise access assets. This gives you the flexibility easily support multiple banks in the future, without constraining you a design that can be very hard to recover from. Making the class static is simple enough, but if you ever need to change that you may find yourself having to clean up a mess of dependencies in client code that assumed there would only ever been a single bank, rather than just working with the bank provided. Further, this method makes it obvious when you start to introduce dependency creep: when you find that you need to pass the asset bank reference to everything in your game, that is what tells you that your game's subsystems are not well separable and you should consider redesign their API boundaries. I don't really see any concrete benefits to using a static class for this sort of thing except, perhaps, in an extremely simple bit of tech demo code. Most of the things that appear to be advantages to the static class decision relate to "simplicity" but usually are anything but, in the long run (and simplicity at the expense of quality is not an advantage). 

They are file formats used to exchange data from one place (usually a program) to another (usually another program). You might also see them described as "intermediate" formats. Their main goal as a format is to describe data in a fashion that is straightforward and easy to parse, or in a standard, almost least-common-denominator sort of way. This makes them useful as ways to connect various programs into a data pipeline or toolchain that don't otherwise know about each other. (They're generally not suitable formats for consumption directly by a game as they usually aren't geared towards efficiency, although this is not always the case and may not matter in some scenarios.)