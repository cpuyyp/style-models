According to your current code, both the x- and the z-component of my movement need to be pointing up the slope for me to start climbing. Consider a slope with the normal (0,1,-1) normalised, and my horizontal motion (0,0,1). I would not pass the conditions in the x-direction, even though I'm going straight up the hill. I doubt that's what you're trying to accomplish. The dot product will tell you whether you're going up or down and by how much: 

Here, F is the magnitude of the force generated by the thrusters, rx and ry are x- and y-components of the vector from pivot point to thruster. Positive torques tend to rotate the ship counter-clockwise. Using the four formulae above, it is trivial to deduce the sign of the torque each thruster produces. For a modestly accurate representation of physics, you need not only know the sign of the thrust, but also its total magnitude and the rotational inertia. Moreover, you might not simply want to activate all properly aligned thrusters to do a rotation. 

Instead of hard coding them into the game, write a routine that would load your level from an external file such as a text file. This is the best way to do it and the way you really should do it. If you are worried about your level files being changed then encrypt them or something. However, if you really want them to remain coded into the game itself then you would not want to make separate classes. Each level acts like a level so they don't need different classes, they should all just be instances of your level class, perhaps a vector. would be one example. Then you could have another variable, say that would be used to access the level vector (I guess it could be a regular array if you wanted). Upon further thinking, that would also create a huge quagmire. Inheriting from a level base class would probably be better for making a hard coded level. You would declare the level stuff in a base class, then inherit this and use that to fill in the numbers. something like that. You could then use the default constructor to have the program initialize all the values. Then have an array of pointers or a vector of pointers and utilize to make the levels. This throws other problems into the mix though. You should really consider loading from external files. 

There is a similar expression for drag as well, and it is obtained in the same way: by solving the differential equation . It yields . Note that coefficient needs to be a negative number, because drag accelerates against the direction of the velocity. Assuming the coefficient does not change over time, the resulting velocity is independent of the timestep. Though the calculated velocity might be accurate at every step, by numerical integration, the position is not, but since is a known function, we can integrate analytically too: . 

Let's first discuss the dot product. A·B is a measure of A's component in the direction of B or vice versa; of the magnitudes of both vectors as well as their similarity in direction. Vectors pointing in the same direction have a dot product equal to the product of their lengths, perpendicular vectors have a dot product of zero. Turn the vectors even further apart, and the dot product becomes negative. Though normally defined as (x,y)·(u,v) = xu + yv, it has the property: A·B = A B cos θ, where θ is the angle between the two vectors. The sign of this product can be used to determine whether a vector B partly points in the same or opposing direction of a reference vector A, i.e. if A·B is positive, the angle is less than 90° (or greater than -90°). It doesn't tell us if the vector points left or right with respect to the reference. Below is a graphical description. Blue vectors B would yield a positive A·B, red vectors a negative. 

Another solution I'll add here is to make a money class. The class would be something like (could even simply be a struct). 

This would allow you to represent the cents in this case as an integer and the whole dollars as an integer. Since you have a seperate flag for being negative, you can use unsigned integers for your values which doubles the possible amount (you could also write a number class that applies this idea to numbers to get REALLY big numbers). All you would need to do is overload math operators and you could use this like any old datatype. It takes up more memory, but it really expands the value limits. This could further be expanded to include things like number of partial units per whole units so you could have currencies that subdivide on something other than 100 sub units, cents in this case, per dollar. You could have a 125 floopies make up one flooper for example. Edit: I'll expand the idea in that you could also have a look up table of sorts, that the money class can access that would provide an exchange rate for it's currency versus all other currencies. You could build this into your operator overloading functions. Therefore, if you automatically try to add 4 USD to 4 British pounds, it would automatically give you 6.6 pounds (as of writing). 

You can invent your own algorithm, as simple or fancy as you like. It'll be horribly broken, but it will have to suffice. You're asking for good ways to secure save-state passwords. There are none. At best, you can try to frustrate the player until he gives up. The reason these methods don't work is that they fundamentally try to do something out of their control. Assume I'm a dishonest player. If you tell the game not to do something (e.g. start in a different state) and I say otherwise, I win. My pc does what I tell it to do. To put it a different way, you can't trust the client. Perhaps more importantly, as long as my cheats don't harm the experience for other players, any effort you put into securing your password system goes straight to making the game less enjoyable. After all, if I didn't want to manipulate my saves, I wouldn't do it. In conclusion, unless you have a multiplayer mode to protect, this is a lost battle for a bad cause; I advise you not to fight it. 

You could have a pure virtual class called game state. Then inherit from this class whenever you make a different game state, such as main menu or in game. You would have an that would be for your game states. You would also need one that was for not making a change. If you need to change the game state the current state will request the change. Then in your main game loop you would have a place to check if you need to change. You can then utilize and to facilitate the change in states. For instance, when you first start the game, you would have something like this pseudo code: 

I would send the key they pressed and have the server determine what action this relates to and take the appropriate actions. For example, the player pushed the 'w' key. The server gets sent "Hey, this guy pushed the w key". The server would look and see what the W key should do for the player. It finds that this means the player should move forward. The server then moves the player forward in the world. At the same time, the client is predicting what is going to happen based on the assumption that what it is being told to do is valid. Then, every so often, the client receives data from the server and everything is set to what the server says. This is actually what causes the rubber band effect you can see sometimes in network games. The client is predicting where things will be at but gets it wrong. Then when it receives new data from the server, it snaps everything to where it should be (IE what the server says). You should, ideally, never send any significant data from the client to the server because of cheating. For example, if you sent velocity the player could be altering the data to be something it shouldn't. Even worse would be sending the position to the server. Even if you send just a bool value saying, hey I want to move this way, this could be done automatically by a hack of some sort. Even sending what keys were pressed is still vulnerable, but you can't get anymore unrelated from data than that. 

Only in exceptional circumstances will players notice or care about the accuracy of your physics simulation. Most games fake calculations like these, which has several advantages; fake calculations are easier to code, computationally less expensive and most importantly, they allow the behaviour of the game to be tweaked in favour of fun rather than realism. If playtesting reveals physically accurate bullet drag is less appealing than some other model, faking it becomes a deliberate design choice. If you still believe realistic drag is an important feature for your game, here's a bit of physics. The drag equation can be solved analytically, though if you should want to involve other forces on the bullet, you require numerical integration. Combining the drag equation with Newton's second law of motion, we get: m v'(t) = -½ v(t)² ρ A Cd, the solution of which is: v(t)=2 m / (ρ A Cd t + 2 m v(0)-1). This gives us the bullet's speed as a function of time, not of distance, but we can integrate v(t) over time to get the distance travelled x(t), then invert that to get the travel time as a function of distance: t(x) = 2 m(eρ A Cd x / (2 m)-1) / ( ρ A Cd v(0) ). The many symbols in this formula obscures its relatively simple exponential nature, which becomes apparent if we simplify v(t(x)), the speed the bullet has when it reaches x: v(x) = v(0) e-(ρ A Cd/ (2 m)) x. The plot below shows the bullet velocity against distance with the parameters you supplied (air density: 1.225 kg/m3; bullet radius: 11.43 mm; initial speed: 251 m/s; drag coefficient: 0.45; mass: 10 g). 

This way you only have to deal with one switch statement for your states and your main game loop only deals with the one game state instance. You just have to insure that your constructors will create the bits they need to create and the deconstructors do their job right. Content loading and what not will happen automatically when you create the new state if you put it in the constructors. You can also have engine tools such as a renderer or a collision detection tool pass a reference or pointer of themselves into the different functions so you game states can utilize that code in their functions if they need to. You could even have just gamestate-Run(); and run the three portions of events, logic, and rendering, inside the different gamestate classes. Up to you really. 

As far as graphical things go, all you need is an integer and then later have this multiplied by the tile width and height values to get the bit of image from the sprite sheet. You can have -1 represent no tile. For location, it's place in the array times tile height and width will give you x and y values, then add tile height and width to get the other side of the tile. I use 2D array for this because it makes it simpler to think about. For being solid or not, I use three layers; background, mid-ground, and foreground. Anything in the mid-ground is collidable. I draw it background, then mid-ground, then entities, then foreground. Tile width and height values are stored outside of the tile information as well. 

As drawn, full power to thrusters B, D and E will maximize the rotation, but will also accelerate the ship to the right. Shutting down D will prevent this. If instead, accelerating right is intended, but a clockwise rotation is not, the most efficient way to go is enabling both C and F at two thirds of full power along with D. If this isn't beyond the scope of what you're trying to do, you would have to write some sort of solver for the equations of motion, clearly not a simple task. 

So you're looking for a parabolic function y(x) that equals zero at two known points. Let's call those points r1 and r2, after robots 1 and 2. One solution is easily found: y(x) = ( x - r1 )( x - r2 ) On top of the robots, one of the terms in parentheses becomes zero, which, multiplied by something else, remains zero. For that reason, we can multiply the entire thing by a factor a. This stretches the parabola vertically (or flips it upside down for negative values) without changing the location of the zeroes. We manipulate a to make sure the curve passes through the vertex, defined by coordinates (xv, yv). We solve the following equation for a: y(xv) = yv a ( xv - r1 )( xv - r2 ) = yv This yields: a = yv / (( xv - r1 )( xv - r2 )) We get the function y(x) we want by multiplying our original function with the scaling factor a we just obtained: y(x) = ( x - r1 )( x - r2 ) yv / (( xv - r1 )( xv - r2 ))