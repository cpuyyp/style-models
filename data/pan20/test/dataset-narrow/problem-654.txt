Hold on. You are going for speed. BUT you first read the whole file into a string before processing? 

Otherwise your are testing the memory manager code. Which is very complex and will give you different results (because memory has all ready been messed with in a previous test). So pre-allocate the size of the vectors (so they don't reallocate during the test). 

I would make the structure a private implementation detail of stack. That way other people can not rely on that detail when they use your code. 

So this will hang your application. Try connecting to port 23 see what happens. Even web-servers can keep the port open longer for chaining (wrong word) requests and not requiring the cost of re-connecting. Global variables! 

Another thing you should consider is a sentinel link. This is a link in the list that does not contain data but is always there. Note: The list is empty when it only contains the sentinel element. The advantage to using a sentinel node is that you don't have to worry about when traversing the list. This drastically reduces the amount of code you need to write. So from that long description two changes I would make. 

You should include all header files that are required (no more than are required). In your case you use the following types in the header file. 

Making the construtor explicit in this case does nothing. only applies to single argument constructors; when books are created by auto-converting another type into a by using the single argument constructor. 

You allocate a buffer (str) of buflen bytes. This means you can index it (str) from 0 -> (buflen-1). Thus the accesses above is writing one past the end of the buffer and corrupting memory. You probably meant: 

Since is a char. Any numbers can only be single digit. So using atoi() seems a waste. But it is also wrong. Because atoi() expects a terminated C-String (you have not provided this you need a second character set to 

Technically still legal. But in my 40 years I have only needed to use twice and one of those times there was a better way. The goto makes your code less readable (many papers on the subject) and it has been shown that it can nearly always be replaced by higher level constructs. So unless you can prove that the makes the code more readable than the alternative I think you will have a big issue. So you need a big comment around the goto explaining why this is the better solution. Not Creating Objects in valid state Your code just uses to allocate an object. 

The use of your functions should be consistent. Getting the first and last children can be badly defined if the node has no children. But the generic GetChild() function will throw an exception if you try and retrieve a child from an invalid index. These two different behaviors makes using your code hard to be consistent. I would change these so that they all or none throw an exception. 

Your leaks very badly. You are creating a new node on each call. But only putting it in the tree at the root. 

The rule of three. If you do memory management in any of the first three methods above then the compiler generated versions will not be adequate (and you will need to do work). The rule of five is if you invoke the rule of three then you can probably get some benefit by using the move semantics but the default action should work (move will be disabled by default if you have followed the rule of three). Why it breaks your code. Consider this: 

Also (another personal preference) I like type names to begin with an uppercase letter. That way you can easily spot types in comparison to objects (ie runtime Vs compile time things). Its a shame the standard libraries does not use this convention but we are now stuck for backwards compatibility (But user defined types tend to be defined with an upper case letter (but thats not universal and a style thing so follow your local guidelines)). Personally I think should be not . I know this means things like splice go from to so there is a trade off and you probably chose the correct one (as thats how the standard version deals with it). But you could cache the size value so you calculate it on first it can be just returned on subsequent calls; then on you can mark it as dirty and recalculate the next time is called. 

Its technically valid. But the implications that T should be some class type (or user defined type) make me dislike this form. I prefer the modern version: 

There are a lot of similarities between a Player and an Enemy. You should probably pull all the same code into a common class so that you are not repeating code in two places. Reducing Code You fixed up nicely. You should probably move the rand number dye roll down close to the point it was used. But you can apply the same solution to . The functions and look very similar. Is there no way this code can be generalized so that it works the same if you are fighting an enemy or another player? The functions and also look very similar. Again can you not generalize these function into a single function? In fact I am pretty sure that if you have a common base class for Person and Enemy then all the above functions will very quickly simplify themselves. 

You seem to be making the problem more complex: I would take a step back to your original algorithm: 

You can use as an unordered container as is. If you have an unordered container it does not matter to you what order the elements are in. If they just happen to be ordered does that matter? The reason for using is that it provides faster access to the elements. You give up an ordered property to get better performance. 

Yes. std::pair<> and std::tupple<> (boost::tupple<>) spring to mind. Obvious hangovers from C Stop using macros where they are not needed (and there are very few places they are needed). Macros should be used to do conditional compilation based on some factor not known at development time (OS/Compiler etc). 

When you have an operator << it is usually a good idea to implement >> (in the long run you probably will). Thus when writing your output stream you want to write it in a way that makes reading it back in easy. So when you class contains things like vectors it is useful to prefix them with a count of elements (not a termination marker). Also any sub elements should be printed with their own stream operator << so you should probably write one for Edge as well. Typedef the iterators in terms of the container. That way if you change the container you only need to make one change (not a cascade of changes). 

So the above may not be accurate. You can add a fake set of cells at the top/bottom/left/right of type 'WALL' then you don't need the test as it can never reach outside the bounds of the maze (this can be forced to be true because it is part of the code and not part of the user input). This means you don't need as that is the only use case. My main issue is that actually mutates the object. Some form of visitor pattern may be a more re-usable technique, or would be better as a member of . 

This means there is a potential for your code to leave a mutex locked forever and your application will get stuck. 

You want the internals of the array (ie. the array members) to be aligned to . This is technically aligning the array (not its members). I have not read up on the requirements of the array (so this may work) but this seems a bit doggy. Just point this works because is a special case (guaranteed to only have one element that aligns with the specified data type). In general aligning containers on their content data type may not work. Initialization 

Returning by reference. The standard containers return reference to their members. This allows you to modify the members in place in the container. 

Declare variables as close to the point of usage as you need them. Declaring them out here seems like a waste. Also it makes the code more complex as you have to reset things manually rather than let the compiler do it. 

Not everybody will see as a divide by 2. Don't do that it just makes the code unclear. Use the divide operator it express intent much better (and does not have any worse performance). 

Tab characters are not 4 characters long. They are the length of required to get to the tab stop. So if you have a tab size of 4. Then you have tab stops at 4, 8, 12, 16, 20, 24, 28 .... So when you replace a tab you don't replace it with four spaces. You replace it with the number of spaces required to get the next character to tab stop. So if you find a tab at position 22 (ie there are 21 characters in front of it). Then you should replace the tab with only 2 spaces to make the next inserted character appear at position 24 (the next tab stop). ======================================================= 

The second thing to think about is returning by value. Usually when you have a container you return accesses to the element by reference. Thus allowing you to modify the value intuitively. This also makes writting simpler (then can be written in terms of . The third thing is that (without an expression is wrong). This is used to re-throw a currently propogating exception from within a . There is no here so this results in a call to 

You should probably have iterator with a lowercase . This is because a lot of the algorithms will use the type. Good start. 

USe standard algorithms when you can. There is a standard algorithm for removing space. Easier to use that. 

Output operator. Usually when you provide an output operator you also provide an equivalent input operator that is able to read the streamed output of the structure. Your list of elements has a trailing with no last element. Not a huge problem but it looks untidy. 

You will need C++17 to compile that is a C++17 feature I believe. Running here: $URL$ Note: This was fun. But if I catch you writing this in my code base I would fire you. :-) Stick to the slightly more verbose but readable version presented by @Quuxplusone 

Don't use underscore as a prefix. In most situations this is a reserved identifier. Defiantly never use double underscore in an identifier. This is reserved in all situations. 

Overall Not bad. Resizing. The maths is in favor of using a refactoring size of less than 1.63 as it potentially allows for memory to be reused after several allocations. 

C++ already has a std::swap() use that rather than doing it manually. use < rather than <= (it looks more natural for most C/C++ programmers). In your case it is especially a god thing as you are subtracting one anyway. 

Here Key and value are moved into place (which is generally less expensive than a copy). If you want to go super new age you can construct the value in place: 

Then prefixed all the boost stuff with . Just so I don't pollute the namespace. But as I say your technique is totally valid since you have bound the scope of the using declaration to the function. If I was code reviewing within your company I may have commented but I would not block your merge to mainline over it. 

The two languages have a basic similar syntax but they are different languages treat them as such. Know what is available from the standard libraries: 

Well you have lots of code in your loop that only happens once. You could manually hoist this out of the loop and decrease the size of the loop once. 

Copy the state of the src class into temporary objects. This is because making the copy can throw an exception and thus you should not put your object into a state wheere it can be invalid. Swap the state of you object with the temporary values. Swapping is an exception safe operation. Now you can destroy the old state (which is in the temporary values). This can also throw an exception, but your object will be in a consistent state. 

Don't see a anywhere in the code. To be honest I doubt you actually need that new at all. If you just made your container hold objects all these problems would go away. 

But I would go the other way. And use a factory object pattern. Factory object You are using a set of static methods as your factory. I would swing this around and actually create a factory object. The problem with static functions is that it is hard to use test code with them. It is much easier to mock an object than static API. Ownership Last. You are not expressing ownership semantics for the created object.