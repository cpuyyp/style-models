I hope this will give you at least an idea to get started with. I, for one, am really happy about your decision to go pro. 

Now over to the class. The method , by its name, should create an account with data fed to it. In case there is an error it should throw an exception. Take advantage of events as they happen Now, you need to take care of responsibilities once again, do not overload this method with mail sending, user login or stuff like that, the only responsibility of this method is to create an account. To handle the mail sending and other tasks you need to perform after creating an account you can use laravel's class or facade (Documentation here). My method would look like this 

You should reconsider the responsibilities of class , too many responsibilities may lead to a lot of dependencies in many cases. It is quite possible that this class is doing a lot of work that it should not, for example populating object with sales reports, earnings reports, or activating user, checking activation status etc. It is not clear in your question but looking at the names of dependencies it looks like it does a lot of checking and population, you should consider moving respective codes to respective repositories and also refactor the service object into separate classes. This will create a spreaded hierarchy like this: 

has the same shape as and the diagonals of are the anti-diagonals of . Solution Putting it all together: 

which helps to describe better what it is doing. Anywhere you can use the alias instead of will help the reader. In fact, I would even write the signature this way: 

array reshaping array row, column and diagonal slices to compute the product of all elements in an array flipping the array to get anti-diagonals 

This may or may not result in faster code, but you can avoid checking that is defined as well as avoid returning it by writing the code this way: 

Your base class your and should only have the methods that are in common to both. This means that should only define the following methods: 

Note here is represents the upper left corner of either the row, column or diagonal we are taking the product of. That's why both range from 0 to 16 We just run both and from 0 through 19. We examine a few extra products (some with less than 4 terms), but since we are looking for the maximum it doesn't matter. 

Note - my JS is a little rusty, but this should illustrate the idea. Update: Per our discussion in the notes, I am suggesting changing this code: 

read more about email queue here and at last, you can customize the validation error message for email:unique rule and make that include a link to login page. check out the custom error message section over here. basically you can just pass in an associative array to like this: 

which will validate the data and create new account. Take care of responsibilities The part of controller method defeats the purpose of REST thingy, I'd just issue a redirect to login page with an appropriate message instead of trying to log them in. all of login stuff and account activation status checking should be performed over login route so it clearly does not belongs to the account creator (or signup) route. with these 2 things in place the controller method would look like this 

Most of it has already sorted out, now you can catch the event and perform whatever action you want. My advice for sending out emails would be to queue emails instead of sending them in real time, this will decrease the response time since the codes will no longer poll for email to be dispatched 

There are many ways you can refactor this method but since you are using Laravel things are pretty easy. Here is my attempt on refactoring (I'd rather call it re-writing) this method. First of all, this controller is overloaded with so many responsibilities, a controllers sole job should only be to accept an , defer the execution to responsible object and deliver an , that is all a controller need to do. so lets refactor it first. Defer execution to service class I'd create a service class with name and inject it into (or whatever you call it in your case), then on I'd create a method named 

Not that recursion is bad, but using streams results in a more declarative definition. append I would avoid in a Lisp or a Scheme. I'm sure it's not efficient for use on lists. , however, is always efficient, so in you should use: 

is still a quadratic algorithm because starts the stepping process from the beginning instead of using the result of . If you really are going to be using the sequence of stepped configs, just use directly like does above. Finally, a some philosophical musings... What's going on here is that the code you've written for stepping n times turns out to be less efficient than just applying the step once function n times. Turning this around, if you have a "step once" function: 

Note that is a pure function which makes it very easy to test. You can create unit tests for your code which may be run automatically by your build process. Pure functions are also a lot easier to test directly in a ghci session. Your game loop can now look like this: 

Note that is an infinite stream. for, for/list When you get comfortable using the functions, look into Racket's sequence comprehensions: , , , etc. See $URL$ for more info. 

The prediction algorithm then boils down to a nearest neighbor search in a high number of dimensions (e.g. the length of the pattern array.)