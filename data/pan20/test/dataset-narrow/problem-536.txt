Normally, projects extract it into some kind of a so that you don't need to create and pass those headers all over the place, or duplicate error handlers, or do any other repetitive code. Basically, DRY. 

Not sure why this line can not be simplified to Similarly, I don't see much value in "type" if it's not really used as a type anywhere in the code. 

Now we need to change the component as well as it consumer. Why not make the as dumb as we can? Here's what it could look like. Notice that the component now expects the entire to be passed in via . It will also notify the consumer about receiving an answer (see . 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance): 

They are simply redundant as long as is enforced by base class/interface. @t3chb0t's answer with switch works as long as you know define all the branches properly. Meaning, you must know all implementations ahead of time (i.e. at compile time) which is a huge design limitation (imagine you would want to have plugins that provide additional operations in run time, or combine operations into complex ones). You will also have to not forget update this dispatching method every time you add a new class that implements... @Peter's implementation of relies on same assumption that we know all special classes ahead of time. Should I Be Constructive? I think, it would be better to have each child class (, , and ) define a single method that works against the parameter. There are no visible benefits in having triplets in addition to this one. However, it's totally fine to keep the triplets though and use them for result computation. For the consuming code method is 100% sufficient to achieve the result. The consumer will never want to, nor should be responsible for picking up a specific implementation to make a call. P.S. This answer is written in a review manner since we're on CodeReview SE. If the question is really about "how to make it work" rather than "how to make it object-oriented", it would make more sense to ask in StackOverflow. 

Psychology matters However, as you said, it takes time to adjust one's mindset, way of thinking, or habits — call it whatever you want — to harness functional programming aspects. Remember how you touched a declarative (e.g. SQL), logic (e.g. Prolog), functional (e.g. Haskell, Lisp, Scala) or any other fundamental paradigm language for the first time. I bet it was not easy to grasp. For the first several weeks or months everyone in this position will write a lot of imperfect code and it's totally fine (as long as he/she is willing to revisit and fix it). During this period the code may be more buggy, but this effect is temporary and diminishes with experience and learning time investments. It is important from the psychological standpoint to not make any conclusions at this point about whether the paradigm being adopted is good or bad. For the same reasons, it's extremely important to not judge a dev nor his code too strictly. Anesthesia? If you agree that the benefits are sweet, you want to push for functional code when possible. Still, the transition process may be painful. What do you do? Well, here're the good news. The Divide and Conquer principle can be successfully applied. In fact, this is how I learn functional programming myself. You don't need to learn all the aspects at once (just like the SOLID principles, or design patterns). 

Get "Enough" Test Samples Below is the "test bench" I used to compile your solution before feeding it to a profiler. If you uncomment the console output instruction in the block, you'll be able to see some unhandled exception which could be caused by either bad input my code generated or a bug in the parser code. 

Duplicate code is asking for extraction If I understand correctly, you have the same code repeated in several places, which are detected by the tool you're using. You can always find a way to extract such code into a function/method and invoke if from wherever it's being used. 

This is always a non-trivial API design question to answer. There are many factors you should keep in mind and I will mention a couple of important once. BTW, I'm assuming we're talking about RESTful APIs here. 

Refactoring Disclaimer: Sorry, I didn't have a solid chunk of time to test the code, so please consider it as a direction rather than an exact prescription. 

Disclaimer: I totally understand that my answer is very subjective, but you may still find it useful. I am myself a big proponent of functional programming, and from this perspective your code looks decent. It uses abstractions efficiently, and is DRY. Functional Programming is Great; Too Many Abstractions Is Questionable However, I'm also a big proponent of clean code. And in my very humble opinion, this code is very hard to understand (especially to anyone who is new to functional programming) because it is almost overly generalized. The code is dense -- that's cool, but not everyone can deal with so many levels of abstraction at once. Hard Things in Computer Science: Naming Things Unfortunately, I am unable to quickly find any abstractions that you can throw away. So there are a few other things we can look at. The naming. It suffers. Yes, I know we see the examples of home brewed composition functions with all over the place. I believe it's a bad practice and we should do better. It takes just a few keystrokes in your editor/IDE to rename all occurrences of a symbol. Similarly, the following names are just as bad: , , , , (in my real life example a developer once confused with , not kidding). I strongly recommend giving these entities much more context specific names. While things like and are commonly used and well-known, I still find them horrible: a) they unnecessarily complicate things, even a small "brain cycle" to interpret it is a distraction; b) they often cause OBOE; c) devs moved to for a reason. Last but not the list, many devs hold an opinion that one letter long variable name is a smell that suggests that the entity has no strong reason to exist. More Functions? Yes, over time developers working with JavaScript get used to structures like . Still, IMO each of this levels add extra "brain cycles" needed to understand what's available in which scope; or (more importantly?) what's not available. I think, that proper indentation or function extraction or both may help reducing the complexity here. Probably, some function will exist just to split a huge one into a set of smaller ones. (Otherwise, we could just rewrite inlining all the other functions, which would make the result a HUGE god-function -- while still functional, very hard to deal with). 

I'm a C# developer and still know too little about JavaScript/TypeScript. If you know how to make this code look more JS-idiomatic, I'm all ears. Or I can paraphrase the question as "am I going the right/common route?" You can see that there is a lot of structural repetition in the code that creates Promises from callbacks (e.g. , , functions). Not nice. Is there a way to apply functional programming ideas here? I have a feeling that functional composition may get handy here, but I don't know how to apply it (a sign, I haven't grasp the concept yet) Resolved It's also easy to notice that is a pass-through. No callbacks here. There must be an easier way to bind one object's function to another object's function, which I don't know how to do. Very similarly, accessor is a supposed to be a pass-through. 

There are minor style things that could be improved in the code, but that's unrelated to RxJs, so I'll not comment on that. 

Naming Things Naming is important. Method is not informative. You may want to rename it to something like . A symmetric counter part is now too easy too name – . 

Instead Of Preface My answer is split into three main parts. The first two explain how to make the small-ish code changes to improve readability and decrease fragility. The third part covers more of a design aspect which you may find important. A. Tactical Improvements 1. TypeScript is about Types Use explicit types wherever possible. This will: 

It's always possible to break away from loop execution interfering keywords like and . It is also almost always possible to quickly rewrite the code in a "more functional" way. Question is, what exactly is the motivation. First, in functional world it all about function. And even though my code below does not use function composition, I'm adding , , and to simplify a few conditions. Another benefit of that is that these local functions' names are replacing the ugly comments. Second, is used to find out whether there's an item close to top. This is made as an independent step in the code and IMO it's more expressive this way. If there's no item close to the top of window, we can try to find the last position before the scroll. Again, now it's implemented as a dedicated step (via and ). Hopefully, it's now closer to what you wanted the code to be. 

If you have in your code, you should have the corresponding as well. Otherwise, you get a memory leak and unnecessary CPU cycles. 

The Evil Triplets In my humble opinion, from the object-oriented design perspective it's strange to see these triplets in implementation classes: 

is better than because a) as a word denotes the result of summation rather than something that encapsulates the summation logic; b) reads better in the usage. In fact, you can even write , or if you prefer better consumer readability over function name -- . I know, these are tiny details, but for the reader they make a difference. Once mentioned it in another answer already -- I've witnessed a situation where in an inline function a developer interpreted as . Silly? Yeah, but who cares when one needs to work on Friday evening to fix a bug? 

Array-based double-stack We can also easily use a single array to implement two stacks. Each array boundary represents a bottom of a particular stack (if left boundary is the bottom of the first stack, the right boundary has to be the bottom of the second stack). The directions of growth for the two stacks will be opposite to each other. The end of the available array memory is detected when the two array headers are pointing to adjacent indices. Here's the illustration: 

I think, this disconnect is non-Redux idiomatic. I may be wrong. As soon as you use or any other non-command/reducer code to express relationship between entities in your application, you get "broken" store in my understanding. For example, it becomes impossible to track the command. It simply does not exist. Similarly and more importantly, it is impossible to replay it if you wanted to debug it. It is also hard to imagine how to unit test it. I understand that when everything is done in a clean redux/Event Store way, it may be hard to track what happens when. I'm still looking for a good way to visualize the flow. Coming back to Is this a reasonable time to step outside of the norm? question. I think, it's your call. On one hand, it's probably uncool to "blindly" follow the pattern. On another hand, redux is done the way it's done for a reason. And as soon as you diverge from it, you establish a precedent that may then be used as an excuse to not do something else the "right" way. I prefer to stay away from such, but your code is your code.