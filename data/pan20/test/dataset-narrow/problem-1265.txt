It's tough to be really "random" but this is how I would simulate it. Create a grid of equilateral triangles. The initial position and rotation of this grid can be random. Then overlay this grid onto your land mass. Now pick vertex points from that grid that fall on land. 

The way I did it for a sphere is similar to the way you'd do it for a cylinder. Choose a suitable radius (œÅ or "rho" in cylindrical coordinates) for your world. For each vertex, take the XZ coordinates of your world (assuming Y is height), then covert to cylindrical coordinates using the XZ and radius plus Y. If you don't add the Y, you'll get a flat cylinder. Then convert back to Cartesian coordinates to draw in game. 

The bullet's position changes based on it's trajectory. The trajectory you have is likely in a 2D vector? The simple update is: 

Yes, you can use layers, making the player and the power up different layers. This means they won't collide however, so it'll be difficult to detect when the player picks up the power up. Alternatively, you can make the power ups have a collider, but set it to trigger. This means the power ups will not collide with other objects but rather only cause the and events to fire when something collides with the power up. 

The first cube we add is the light source. A source is a special case. It's light value is set accordingly to the light source type (for example torches get a brighter value than lava). If a cube has its light value set above 0, we add all the transparent cubes adjacent to that cube to the list. For each cube on the list, we set its light value to its brightest neighbor minus one. This means that all the transparent cubes (this includes "air") next to the light source get a light value of 15. We continue walking the cubes around the light source, adding cubes that need to be checked and taking lit cubes off the list, util we no longer have any to add. That means that all the latest values set have been set to 0, which means we've reached the end of our light. That's a fairly simple explanation of lighting. I've done something a little more advanced, but I started with the same basic principle. This is an example of what it produces: 

Main stream developers go where the market takes them. 3D was (or thought to be) desired for games, so they made their games 3D. It has to do with market analysis for what's wanted along with what's cheaper. Hindsight is 20/20. I imagine if you were a gamer back when these games first came out and someone asked, "What about this 2D game you love, in 3D?!" you may have been really excited. You didn't know of any downsides, you had no idea the 3D would take away from the art. Just see how it's happening with 3D movies today. I expect 10 years from now people will wonder why they even bothered making movies in 3D when 2D was much better. (Though I'm bias because I think that now). Further, I imagine some people today wonder why they ever switched from 2D art to 3D art in cartoons. And why did they ever switch from real life special effects to CG effects? Money and market analysis. 

It appears to be under development by SoftEther Corporation. However, I imagine such a solution might be overkill. An alternative would be to use a GI Joe for your modeling. Record video of your GI Joe manipulations from the front, side and top. Using these synced videos, you can go frame by frame switching between a front, side and top view of your 3D model (or you may be able to do it with two cameras). For each frame align your model to match the GI Joe in the recorded video for that frame. This is similar to rotoscoping for 2D, but you're doing it on each axis to expand it to 3D. Another alternative would be to use a 3D camera like the Kinect. 

The process is the same as with a reticle that's fixed to the center of the screen as with a reticle that moves with the mouse. I'm familiar with the idea of 3rd person placement of cubes, I've implemented exactly that in my game Age of Goblins. New cubes are place adjacent to the selected face. The selected face is found by casting a ray from the camera, and detecting the cube and cube face the ray first passes through. For example: 

Now these are just global coordinates, it may be easier to use an internal local coordinate system, with a 3rd dimension that represents the cube face you're currently on. Either way, you need to have a unique coordinate for each grid space on the face of the cube. Traversing between them will depend on how you implement the coordinate system. You need to know where that coordinate maps to the surface of the sphere too. All this should eventually be abstracted away so that you don't even know about it. 

Then you can do additional things to strive for unique seeds, like add the distance from the center of the world. I should mention how I do this in my game. Since I'm generating terrain shape along with terrain type, I wanted to ensure that I'd have continuity between chunks. I did that by using a single world seed. Then the Perlin noise function takes the absolute world position as an input. This makes the transition between chunks seemless, which will not be the case if you're randomly generating each chunk distinct from the others. 

The point is to remove these constraints because it's not supposed to be a simulation. It's supposed to be a fun game. It's not fun to obey the laws of reality. Secondly, many people are not as educated as you or I. They know things make sound, so they expect things to make sound. When they don't, it's something wrong with the game and it's less entertaining. 

There's a little library called AssortedWidgets which is a GUI application using OpenTK. You can read a bit about it here. It allows GUI interfaces like this: 

Systems maintain a list of the entities they're interested in. Systems are just created once when the game is initialized. If you're creating systems with entities already in play, you're doing it wrong :). All the systems your game will use are to be created before any entities are created. When a new entity is created, each system will check to see if it's interested in that entity for processing. This is where your bitwise check comes into play, very fast. When an entities components change, each system should check that entity again to see if it's still interested in processing it. See an example of this check in the Artemis Framework code with the function. Now, when each system processes, it just iterates over the list of entities it has stored. Retrieving components is done with nested hash maps. The first layer is a map of maps indexed by the component ID, likely the long used for bitwise identification would work well here. The second layer is a map of components indexed by the entity ID. This would look something like the following in tree format: