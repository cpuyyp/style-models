As 200 said, the predicate should be first. Think of , , and similar functions. They take the predicate first. Also, it's usually a good idea to get rid of arguments that get repeated in every recursive call. GHC should take care of that, but we can help it a little bit: 

Don't repeat yourself Your code suffers from being WET. Your 's formatting function is repeated. So let us get rid of that first: 

that is you don't check the . Note that this is still a contrived example. * Technically, that's not true. You can use references, pointers, or wrap the return value in some /variant, but let's keep things simple 

Any identifier with two underscores is reserved for the implementation. Using such an identifier yields undefined behaviour. Change your include guard. Something along is perfectly fine. 

Add type signatures. Without type signatures, your integral types will default to . So let us add type signatures: 

Your code is fine, but I would suggest some small changes. Instead of , I would use . This captures your intend to take the first (and therefore largest) number from each . Next, I would use instead of , since is smaller than . Why? Because by default, will be used for types, if they were note specified. Therefore, you end up with handled as a , which is slower than . And last, but not least, I would stop at , since is a palindrome. We end up with: 

Note that instead of makes it possible to use an array. Also, is one of the functions that a user may overload. The documentation example above uses Doxygen with JavaDoc style, but it's just an example. Unfortunately, we lose the as 's underlying type on the way, but that's the price we pay for not knowing the container at all. We can model your original variant now as 

and could lead to without losing the original Caesar's meaning. It's just shifting in the alphabet. You, on the other hand, have two alphabets: 

Don't call things by wrong names does not create a deep copy. Instead, it does overwrite a list with its own (later) values and has two manage the same contents. That's due to your line. You could use here instead. If you provided an iterator interface, you could simply use 

You can then even provide keys to save/load your game, which helps tremendously with debugging. Keep it short and simple We've had this heading already, but it's here for a second time: make your functions shorter, if possible. Remember, code is written for two participants: the human reader, and the compiler. If the compiler doesn't understand your code, it will throw errors and warnings. If the human doesn't understand your code, it will get angry, sad, or stark raving mad. Your function is a valid candidate. The functionality of and can be split into and . Both functions will be short, and can be checked for correctness. Further remarks Now follow further remarks on your code, which aren't that important for a language learner, but still provide further feedback and place for improvement. Bugs and dead code 

Pattern matching or list element selection? It's possible to reduce the size of , , and so on if we use on a list instead of pattern matching. That's a completely other style though: 

However, that's again \$\mathcal O(n)\$. But we know the length of our current solution; almost. It's the number of recursive calls: 

doesn't change at all. The compiler will most likely throw that line away, but better don't include it. 

However, that just removes the constraint and makes your program less flexible in the long run. So let us go back to the drawing board. The data directory is part of the test configuration. That sounds like a valid new data type: 

Disclaimer: I'm a Rust beginner with a background in C and C++. Now that I've lost my credibility, let's have a look at your code. Use rustfmt, clippy and rustc There are (at least) three helpful tools when one writes Rust code: , and the compiler rustc itself. Rustfmt provides a common ground The compiler doesn't yield any warnings, but rustfmt will change your code. As many Rust developers use (or , which calls the former), you should also make a habit of using it. That way others will feel right at home if they look at your code, and the same will hold for you when you look at theirs. Clippy's warnings on the other hand will catch common mistakes. In this case its mostly the redundant in your functions: 

But that's just a demonstration of what you could do with that function. Back to your code. How would we capture ? 

Bases Vigenère has a "bug". That is due to your alphabet management. Strictly speaking, both Caesar and Vigenère advance characters in their respective alphabet. Therefore, your alphabet should be something like 

Use if you don't use in a similar situation. Prefer a single allocation for a field We don't need to call so often. A single call is fine if we access the cells like 

The last one is almost the same as your variant, but it doesn't contain any non-static members anymore. Either way, a guaranteed defined behaviour solution depends on your use case. 

but that's just a remark (Exercise: try to guess 's type. How would a valid implementation look like?). Next, we head over to . Let us assume for a second that the key is longer than the text we want to encrypt. We want to encrypt each character on its own. So if we have a string, we can pattern match. We start with the easier case: 

Short answer: don't use recursion. Slightly longer answer: don't use recursion if you have more than a single recursive call of your function in the non-trivial paths without memoization. 

If we enable , GHC will even tell us when we forgot to handle a DB environment that we might add later: 

Now add export lists and you have a nice, type safe vector/matrix multiplication library. However, I'm not sure whether for large matrices leads to problems in GHC. 

What happens if I answer ? Well, first of all, will return , and next won't get changed. So its value is unknown. If we use it, we end up with undefined behaviour, which is a fancy term to say "we have no idea what will happen". So in order to at least prevent something like and just because the input failed, make sure to initialize your values and maybe check whether succeeded: 

It doesn't need to be a class, it can also be a small struct, but it's usually a good idea to have something that handles the last few bytes. Your almost provides this functionality, although several variables are still global instead of local. That way, you can easily ask the user for a new game: 

but it's usually faster. Even better, if all your numbers are guaranteed to be positive, use , since and have some constraints on their result: 

It's an obvious way in imperative languages, which have a string as an array or similar data structure, since index-wise accessing is fast, and or other "append-single-character-at-end" functions are usually (amortized) constant. So if you're coming from an imperative language, yes, that would be the obvious way to implement it there (well, aside from the recursiveness). But in Haskell keep in mind that lists are, well, lists. If you want to access the 20th element, you have to skip the first 19. isn't a care-free operation like a vector access in several other operations. Neither is . That's why it's usually a good idea to pattern match (or use higher-order-functions) and create the list with . Exercises 

In case you don't know yet, that's a reference. A reference is an alias to an already existing object. A reference is an alias where we cannot change the value: 

Also, if you use , make sure to include the function's name in the error message; best practice include the completely qualified name, i.e. 

Note that you should compile your code if you want to check its performance. Alternatively, if you want to keep 's type, use : 

This means we can change it to a while loop, since the condition olds true. That's guaranteed by the : 

First of all, that's invalid markup. The and the tag intersect, which must not happen. Next, we have a list. It's apparently ordered, therefore we should use an . And last, the looks like a headline, so it should be a . For this small snippet, we see that the following snippet contains all the semantics: 

Make your functions easy to use, but hard to use wrong This one is hard to explain, so let's start with : 

This is a handful, but it works exactly as your previous variant. Encapsulate functionality in functions Now, my main critique point is that you don't provide a single function for your cipher. It's hard to test your functionality at the moment, so we better add one and some documentation: 

And that's all we can improve in terms of terseness at that point without changing your code fundamentally. The main difference between the Python and the Haskell implementation is the mutation of the original and the early exit from the function. I would recommend to check the "B" case earlier by the way: 

Which beats all other discussed solutions in terms of complexity and clarity. (*) Only counting filter and lookup, not actual concatenation. 

Next, your returns invalid values if the character isn't in the alphabet. That can then lead to problems if you use . But that's hard too catch since lives too long: 

It seems unlikely that you accidentally change . But why take a risk? puts an ease on your mind. Make exclusive branches exclusive We're still following your function top-to-bottom. And while your for finding the minimum and maximum of the range works, it's not really friendly to our PC: 

That's probably not what you intended. Use instead here. Furthermore, all your functions are fixed to , but one can implement all functions from for any number type. The following interface encapsulates that: 

Those names don't have any meaning. What is ? What is ? Naming is hard, but it's important. You're going to use them as numerator and denominator, or as dividend and divisor, so call them appropriately: 

It's now impossible to use outside of its loop. Also, we should try to initialize our variables whenever possible. Use for inputs that are not supposed to change That way we cannot accidentally modify your input values, e.g. 

The additional argument is error prone. For example, a user might provide and you end up with . So let us get rid of that first: 

but it isn't. Use or something else with a better name. Documentation, documentation, documentation Your class has no documentation, except for , and , and I wouldn't count those three lines as actual documentation. I'm not talking about implementers documentation, e.g. 

Yes. Don't use reserved names, if possible. is defined in the , you've used it to bind . Also don't use the same names twice. You've used both in your as well as in . This can lead to errors when you refactor your function. Other than that: Well done. For comparison, here is how I would write your function: 

To remove possible data races in have take two arguments. Then you don't have to store the in your class at all. 

Note the missing in . In order to make those modules type safe, you have to constrain the exports so that no or can be build or matched with their constructors our of their respective module. You had a similar loophole in your prime code, by the way. A based on GADTs does not have this problem: 

That simply breaks to much. Your Monad is also missing its Functor and Applicative instances, which would make it easy to "cheat". And if you implemented a that limits the number of s, you start to break Functor laws. Note that due to the Monad/Functor laws, we should be able to rewrite 

We can now use on any null-terminated string. We're able to reuse functionality. Note that both functions are very easy to check by hand. 

After all, there are (usually) no stack traces, and it's really nice to know where things went wrong. Note that you should add this behaviour in a documentation, since the type doesn't really tell what would happen on an empty list. Since is also an instance of , any fixed number could be feasible. Alternatively use as return type or as input. Use the tools you have at hand is from . Also, is an instance of , which means you can replace 

Now we know that will always return a number in the range 0-2. Foul magic However, what's ? What is ? All three numbers are magic numbers, which is usually a code smell. You, as a developer, have to remember what a certain number stands for. Save them somewhere, like 

A "clean" version without exceptions However, that's not how I would write the program, since exceptions are meant for exceptional cases. I would write 

You can, of course, keep the type to (you have to change back to ). Now to . Let's use proper types first: 

Your use prevents this kind of error, since you're using it only on valid combinations, but you shouldn't export them either. That's not really an issue here since you've wrote a module, but you should keep that in mind. However, those functions would be a lot nicer with the appropriate type: 

Note that I changed 's type, since we also changed 's type. In case you're not familiar with : in this context you can think of as 

"But wait", I here you say. "If I have now the following input, I would not have enough space for my digits:" 

But you need to be lazy enough for that. Use knowledge you already have In , you'll check whether you already reached the correct length: 

Add type signatures to top-level functions You should always add a type signature to top-level functions: 

Note: At some point, this review drifted into the realm of assembler and GMP. An actual review is at the end of this post, whereas the first section discusses the runtime-problems concerning , wrong data types and arbitrary large integers. No life time for run time 

While it's possible to use instead of the pattern matching, matching makes the base case more visible. Also, this is a perfect spot to use instead of . 

If we quint our eyes, both codes look the same (if we use the first variant). However, I wouldn't call a list , since lists are usually identified with a suffix called e.g. . Also, is somewhat of a misnomer: are we working with that list? Or does that list fulfill some requirement? As we currently accumulate elements in there, the usual or might be better, but naming is hard and left as an exercise. Other than that, unless you want to have little, test-able functions, your original variant was therefore fine to begin with, but contained some functions that can be re-used. 

Furthermore, you don't compare with in that case, which can lead to an infinite loop. But we only get a little bit more readable because and are completely meaningless in that context. You have a clear intent for your 's, but that intent gets lost due to its bland names. It's a nice interface for several functions in the standard library, but you can easily write 

I'll add an exercise for you at the end of this review. But let's have a look at your code. A review of your code You're not using , which is a great plus. However, you include , which isn't necessary here. You don't use any of the standard exception, instead, you throw . However, is in . You should include that one instead. Next, naming. 

I'll focus on the first detaill I've noticed, mainly the argument in both and . Only or are valid values. However, has many more values that are valid s, e.g. and . But those aren't valid database environments. Therefore, we should use a type to make sure that we don't need to check whether we have a valid environment at hand: 

A space goes in, a space goes out. We do not change the key. So now there is only one case missing: the one where we have a character that's not a space: 

Uh oh… If this was a program you want to use in a productive environment, you would check the sign of , and, after the discussion above, also check that tit doesn't get too large (or dismiss VLA). We can provide a small little helper to make sure that we get only positive integers: