From the plain system requirement, you can give it a try with a decently fast SD card (or probably run it from USB a hard disk. I never tried so the experience can be bad. Also you need to make sure that the program is compiled for ARMv6 instruction set. 

You can use one of those USB sound cards, or if you don't want to hog up USB ports but don't mind using the GPIO pins, you can use the Cirrus Logic Sound Card (audiophile-grade hardware though, fairly expensive) 

Alternatively if you're using something that is not Windows on your computer, you can set up and IPv6 on the Pi. The IPv6 link-local address assigned to the Pi can be discovered over bonjour. 

There are too much interference and/or blocking two rooms away. Microwaves, cordless phones, baby monitors, lots of things that uses a wireless connection use the 2.4GHz band now, hence too much interference. Also, this band (and the less interfered 5GHz band too) does not take physical obstacles like walls very well, especially when the concrete wall is thick enough, with steel reinforcement in it, that can totally block the signal. You can use some method of wired networking, like existing structure cabling or power-line communication, to either send a wired connection directly to your Pi, or set up another access point that forms wireless roaming network with your existing Time Capsule. In my apartment I have structural cabling preinstalled during renovation and I places wireless access points at either side of the signal-blocking concrete wall to guarantee a good connection. 

No heatsink is required, but this does not prevent you from adding one. If your operating environment can get a bit warm and you don't want it to thermal throttle, you can add one (optionally strap a fan on it.) I have all my Pi heatsinked since I use cases while put lots of stress on the core, and one of them have a fan strapped on it to improve cooling as it operates in a warm equipment roon with an average ambient temperature of 45ºC. 

I have a microSD card, loaded with and Cirrus Logic Audio Card driver that is shared among two Pi's, one Model B rev 1.2 (I have one of those short format adapter modules that takes a microSD without sticking out of the Model B PCB) and one Pi 2 Model B. when compiled with is very CPU intensive (e.g. streaming Ariana Grande's Focus from Apple Music via an iPhone running iOS 9.3.3 will almost guarantee to stutter on a Model 1 without overclock as spikes the CPU, but nothing except network issues can affect the Pi 2) It is not advisable to leave overclock settings as-is when moving from Pi 1 to Pi 2. How can I do this device-specific overclock settings? 

simulate this circuit – Schematic created using CircuitLab The Raspberry Pi have built-in pull-ups to 3.3V rail so you don't need your own pull-ups. The 4.7kΩ resistor on the line will prevent the current flowing from the 5V Arduino from burning out the 3.3V circuit, saving a translation mechanism. As of the code, it is mostly right. I cannot spot any issues yet. 

It is almost guaranteed if you can find the streaming address of the IP camera. You can use Kodi to handle the stream receiving. OpenELEC, LibreELEC and OSMC are three examples of Kodi-centric distributions for Raspberry Pi. Just keep in mind that the Pi 1 may have trouble decoding anything other than H.264 (plus VC-1 and MPEG-2 if you bought the CODECs) at 1080p, as the above three formats are decoded using the GPU, and the CPU may have trouble keeping up with the task alone. By the way, Raspberry Pi themselves makes excellent IP cameras too, using its camera module to capture the action. You may even run some OpenCV on it to identify and help capture critical moments of a crime scene. 

If you dare, you can implement PCI-E x1 with six pins: SM_SCL, SM_SDA (go to I2C bus as SMBus signal), PCIE_IRQ (open drain, shared by all cards), PCIE_CLK (Derive into differential signal with external circuitry, shared by all cards), PCIE_Tx (Derive into differential externally, one per channel) and PCIE_Rx (Derive from differential signaling externally, one per channel) Hardware part us easy, but bit-banging PCI-E protocol can be problematic since not all cards can be slowed down that much. 

Big normal caps are huge, supercaps can be smaller with a similar capacity. I have not used any supercap (just big normal caps) so I am not very sure there. 

I have no idea on how to do that in software, but I do have an idea on how to implement such a feature in hardware, using one GPIO from the Pi. You need a N-channel MOSFET like BS170 (It switches 500mA, maybe you want a bigger one) and a USB extension cord for this. Remove the protective shielding of the cable and find out its power wire, ususlly red. Cut that wire and insert the MOSFET, source pin to the MODEM and drain pin to your Pi, then wire the Gate pin to one of the GPIO on your Pi. When you are using the modem, write to the GPIO pin, turning the 3G modem on; and when you need to reset it, write to the GPIO and wait for a little while, write again to power cycle the modem. 

Just to throw it in, if you are into adding a bit of hardware, you can write a small daemon to poll the GPIO pins and upon assertion of a certain pin, reboot (or shutdown) the Pi. Also, all commands mentioned here can be ran over SSH. 

I have designed a few HATs. Now about driving it, does this sounds like a good way doing it? The architecture described below is the driver layer designed for my custom kernel, but a stripped down version can be run as user land library under Linux. The driver library includes two parts: standard interface classes and specific device classes. Standard interface classes, like , (extends and implements ) or (extends ) provides prototypes of standard operations of the bus it represents. Specific device classes derive from standard interface classes and implements the hardware interface itself, either by directly interfacing the hardware (like BSP class) or using another standard interface (like that implements SD card interface using a SPI bus object). When porting to Linux, a Linux-specific BSP class is used to translate access to hardware to Linux-style calls to file nodes in and Does this class model sounds sane? 

I am considering upgrading the kernel of my Raspberry Pi router to 3.19. But how can I do this? I have found an out-of-tree nl80211-compatible driver for that supports and acs, but it calls for a 3.19 kernel. How do I build this 3.19 kernel, maybe libc, and upgrade my Pi to it? I have a 20-core server running Ubuntu 14.04 and I have to cross compile using that, or the compiling time will not be tolerable. Please give me instructions on how that is to be done. EDIT: I have not tried to cary this out yet, as I don't have the expertise in debugging such situations (and previous experiences of failed LFS builds left me pretty scarred.) I need some clear instructions on how this should be done, Cross Linux From Scratch style. 

Since I use my Pi as the router with , I run a script to watch the file. For IPv6 environments can be monitored, and if your environment have an abundance of Apple devices you can also use to do this. 

An ethernet switch is indeed what you all need, besides a bunch of ethernet cables. If you are planning on a bigger cluster, like maybe with 20+ nodes, you should use those 8-port gigabit switches to form a subcluster for every 5-7 nodes; and then use a bigger gigabit switch to connect all those subclusters. This is to avoid network congestion caused by slow or congested links (A gigabit link cannot carry 20 100Mbps links at once.) The software is more straightforward as you can just preconfigure all software on one Pi and copy images over (don't forget to change the IP addresses!) 

You have to pre-program all microcontrollers before letting this system into the wild. Assuming you have done this you can use any communication protocol you like, SPI, I2C (my personal favourite) or maybe CAN. Language does not make a difference as all the microcontrollers (and the Pi) are doing is talking over a bunch of bus wires. Just make sure all your devices speak the same language - use the same protocol. 

Sorry Raspberry Pi is not capable of this on its own. However alternative methods exist. A possible alternative is coupling the Pi to a USB-capable Arduino like Leonardo, Due or Zero. The Pi parses the USB commands from the game controller and relays it over some other interface like SPI, I2C or UART, and the Arduino reconstruct the command exactly to the gaming console. This will introduce a lot of delay though and probably ruin your game experience. A better method is to use a real deal USB monitor, Expensive but it introduces virtually zero latency. 

You need some kind of daemon for this: export the pin with interrupt, on the pin and / the script when the pin go high and it when the pin go low. Most of the time your daemon will be blocked by so it will not hog CPU at all. 

I would suspect that the Pi is choking on its processor speed. Try stream the video feed off the Pi as a H.264 stream (encoding done using GPU so it will not choke the CPU too much) and use a more powerful computer (preferably something with a multi-gigahertz processor, 64-bit OS and gigabytes of RAM) to run SimpleCV against it. 

The Pi Zero uses the same silicon as Pi 1, so they have the same top speed 1GHz. Pi 1 came with a more conservative clock speed but Pi Zero came already maxed out, so it makes no sense to overclock Pi Zero (but on the other way Pi 1 should be able to be cranked to Pi Zero levels.) 

You cannot directly use GPIO to bit bang CAN signal due to timing issue, but you can use an interface chip like MCP2515 (SPI-to-CAN interface) to interface it from another bus. I did not found I2C-CAN interface, only SPI-CAN interface. 

You can get rid of that "blip" by adding a supercap (or maybe just a big 6800uF capacitor) to the supply wire of your Pi. They can momentarily power your Pi when the battery pack is flashing off. There are various ways to implement this: 

A friend of mine prefer Cubieboard over Pi. And there is Banana Pi which uses the same SoC as Cubie but have a Pi-compatible form and pinout. Also if you really dare to do so, you can check out the Allwinner A13 which is a full-blown Cortex-A8 MPU in hand-solderable eLQFP178 package (instead of BGA package) and roll your own board with it. 

If you can get Synopsys to give you the reference manual of the USB block used in BCM283[56], you can rewrite the USB driver to support such operation. The Model A/A+ have its USB port exported directly from the Broadcom chip so if you get this to work you can test it without hacking the hardware. Or you will need some sort of bridging mechanism like USB to Serial or USB slave to SPI slave adapter chips. The former is simple to implement and if you need more UART you can always use an NXP I2C UART chip (kernel driver included in latest Raspbian kernel). The latter option would also require you to acquire manuals of the chip and write a kernel driver. 

If you are realy concerned about this you can attach a button to a GPIO pin and have some code that starts with the system monitor the pin and halt the pi when the button is pressed. 

Here is an easier to use one: MAC address via IPv6 NDP auto configuration. This is a universal method that is applicable to any network interface. Every NIC, including the USB one used on the Pi, have an 48-bit MAC address, for example, . Every 48-bit MAC address have a unique one-to-one mapping to an EUI-64 address by masking off the last two bits in the third byte ( to ) and insert the bytes in between the third and fourth byte. The aforementioned 48-bit MAC can be mapped to the EUI-64: . The IPv6 address auto configuration process uses NDP protocol to discover the 64-bit network address in the 128-bit address. This process will give all your devices within the same network the same 64-bit prefix. The aforementioned EUI-64 is used to populate the 64-bit station address, resulting in a 128-bit globally unique IPv6 address. So if you have the IPv6 network prefix , the aforementioned network card, when used in this network, will be guaranteed to have an IPv6 globally routable address . As long as your management tool is configured to use IPv6, just plug this address into it and it should be good to go. 

job and some scripting. It is simple enough to use as what you need is only and which it is pretty much 100% there where you need it. 

The software part of this is simple: detect the button pressing event happening on GPIO and execute the command or . But to cut the power properly you will need something hardware. Considering the scenario that you are building a power management HAT that back powers the Pi. You can detect whether the Pi is off by observing the UART lines: then TX go low for extended period the Pi is off. Some circuitry should be built to detect this and turn off the pass transistor controlling power to the Pi. 

You can store your home directory, or at least the encrypted program, using some based technique. will work on both physical devices (e.g. encrypted USB thumb drive) or a disk image, and since you are using Raspberry Pi you can use write a bit of code to store the cryptographic key in I2C EEPROM, sort of like a hardware decrypt dongle. And if your code is not too big (<=2MB), you can store it in -enabled SPI DataFlash chips also. 

I have a similar configuration, with a Raspberry Pi functioning as a residential wireless router, dialing up using PPPoE over EPON to my ISP. 

I have a Pi with Wolfson Audio Card, running Raspbian with low latency kernel. Is it possible and feasible to use such a setup as a near real time digital audio processor, like a reconfigurable digital guitar stompbox? 

At the bare minimum I would use socketed optocouplers, and drive the board with a separate power supply. You will never be sure what a failure of the relays can bring to your driver board. If you are rolling your own interface PCB, route a slot between the sides of the optocouplers. 

You will need a separate BLE serial interface module. iPhone usually can with with those without MFi licensing, and you can establish connection between iPhone and API that way. Keep in mind that this does means that you have to write your own interfacing app for the phone. An alternative is to add a second Wi-Fi module on the Pi, for example a RTL8188CUS based one. This gives you a local Wi-Fi access point your iPhone can join, and SSH protocol can run on top of. 

Since you are having timing requirements Raspberry Pi is no longer the appropriate platform for this. It is not a real time platform and timing can be thrown off by a lot of different sources of interference. Instead you should use a microcontroller to measure this time, preferably using interrupts, and pass the information to the Pi later.