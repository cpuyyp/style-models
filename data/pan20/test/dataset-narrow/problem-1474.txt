The definition of these is as follows: Every cell from through is RED. Every cell from through is WHITE. Every cell from through the end is BLUE To establish the invariant prior to the loop: 

You can have a couple of teams give their own explanations. If you do this you can also have a vote on which one seems more complete. You can give a prize for the best explanation. It is also good if you can use a whiteboard or a projector to note the important elements of the solution given and can use this as a framework to fill in as students make comments. You can judge for yourself when the solution is complete enough that it can be implemented and then send them off to build the thing or keep the discussion going until it is more complete. You can make suggestions along the way, of course, to try to bring out missing parts. You can actually give feedback in a subtle fashion by asking the appropriate questions of the speaking team, rather than directly commenting. This technique works for lots of things, not just Arduino. 

A discussion group can work together to figure out answers to some questions. If the members are all novices this is not the same as consulting an Oracle and you learn different skills in any case. 

I will ask some rhetorical questions below - they aren't meant to be snarky. That, of course, depends on the textbook. I would think that the documentation alone would be a terrible idea. Would you teach a class in Shop by giving each student a box of tools and no instruction? The quality of the official documentation is, as you note, excellent, but there is nothing there about how to use it - about how to actually program. How would a student, faced with a project or a programming goal even begin to know where to begin in decomposing the problem into manageable chunks. Language documentation doesn't help with that - though of course, some text books don't either, just focusing on language tools. But a good plan is to use the documentation along with a site like SO in conjunction with a good textbook and your own skill. The problem decomposition is just as hard as the solution synthesis, and if the students are skilled in some paradigm other than OO, they will just hack code according to their older skills and learn very little about the essence of Java. The page you pointed to is just definitions. It won't help anyone build skill. Would you teach a composition class giving students a dictionary and nothing else? Yes, a class is .... BUT, how do I create a good class? What granularity of decomposition should I use? How do I gain skill in the various idioms of Java specifically and OO more generally? What simple (or complex) design patterns can be used to solve this problem? None of that will likely be found in the documentation, no matter how good. Use the documentation, but not exclusively. The interconnections are more important than the things actually discussed. 

Perhaps I'm wrong, but your question (and your example) seems to imply that your intention is too "teach them Ruby". For beginners that seems backwards to me. My intention would be to teach them to "solve interesting problems". Once someone already knows "how to program" in some language it seems fine to teach them a (different) language. But focusing on the language is the wrong way about. Find an interesting, if simple, problem and examine how to break that problem down. In an object-oriented language you break it down into objects first. The objects have behavior. The methods implement that behavior. So methods are natural, not something that you need to come up with examples to teach. Your examples should be example problems. Instead of giving them a hammer and a bunch of nails, give them a problem that a hammer would solve. Hammering isn't, in itself, a useful skill. Think about the problem first. This is one reason that a system like Greenfoot is useful in teaching beginners. It offers the possibility of a framework for posing problems (simulation) and a visual framework for solution (a flexible grid like world). Giving a person a full complement of carpenter tools doesn't make them a carpenter. In teaching programming to beginners, make the language and its features a secondary concern. I would introduce new language features only when a problem requires it. Of course you can choose the problem set so that you introduce "interesting" language features along the way, but make the problems "interesting" first. 

The reason is that it is based on English words and natural language is, itself, very messy. If I have a set of natural numbers, they are inherently ordered, but that isn't part of "set-ness". You need to define "well defined". The word "collection" is also messy and hard to define in a not-circular way. What do you mean by "element" (other than, circularly in relation to a set? Finally, I don't understand what you might mean by "repetition doesn't matter". This is where analogy and examples and poking around the edges can help. For example why isn't "The set of all black horses" a valid thing? It can get very subtle. 

I have a friend with a bachelors degree from a good school. He currently teaches Secondary School CS but wants to continue his education. However, he is limited in his ability to move except within a radius of a hundred or so miles from NYC. Short term travel outside his home range is probably a possibility, but not a residential program. He is bright and works hard and is focused, for now, on teaching Computer Science. His goals require an advanced degree, ultimately a research doctorate, not just self learning. He is looking to remain in teaching and to do research as well. What opportunities does my friend have for part time and/or distance graduate education? I've suggested to him that there are (must be) week-end and summer programs that, while intensive, only require part time presence outside his home range. What options do you know about that might help him and others like him? If you suggest a program/institution, please say why you think it is appealing. Note that MOOC type programs are not useful here. The program can be very intense, but needs to provide a solid, recognized degree. Serious and continuous contact and interaction with faculty and other students would be considered as an important plus. 

An infected cell can infect adjacent cells in an iteration of the simulation with a probability determined by the disease. Diseases can morph over time (or space, or other dimensions in general), so an update method is provided to allow this. Later we will see two implementation of this: SimpleDisease and VirulentDisease. The second interface is Population: 

Well, you won't do it by simply insisting. In fact, if your student has an alternate way to demonstrate the truth of the statement, he/she should be praised, not censured, even implicitly. Your students aren't like you. They don't think like you for the most part. It is useful, of course, to show them how you do think, but still, they are unique individuals. However, if you want to convince them to use Boolean, you could give them an assignment to actually compute boolean functions. Or, more interesting, you could create (or find) some active learning games that are both fun and rewarding. CSUnplugged may have such thing already. A search of their site will turn up a few things on Binary Numbers that might be adapted, and a few links on teaching Boolean Algebra. Discussing simple circuits (gates) might also give some an incentive to do more. Discussions of why nand and nor are preferred over and and or are instructive. 

Recent questions deal with the problem of too many applicants to CS programs, both in High School and University. Yes, this is a problem when only a smaller number can be accommodated for reasons of resource availability. One of the easier issues to deal with is whether the student's past performance indicates potential success, though even this is hard. If the student hasn't studied Computer Science in the past, what courses are predictors? But this question is focused elsewhere. Some students, in periods of high demand, choose a field simply because of its popularity at the time. While they may have the aptitude and background for it, their interest may be shallow or even misinformed. It would be good to help such students make better choices about their futures by informing them early of the nature of the field and how their future would likely play out if they stay in the field. The goal is to reduce the number of drop-outs: students who start a program, but leave it before completion. This potentially wastes both the student's time and resources as well as wasting institutional resources. It also risks denying other students an entrance slot that they might have had. In particular, such students may not know all of the things that CS professionals do on a daily basis. What are the interesting things? What are the boring things? What are the risks? What are the rewards? What frustrations? What will they ultimately need to do to become successful, in either the commercial or academic worlds. What resources can be brought to bear to assure that, possibly naive, students get a good look at the profession so as to better decide whether they want to enter? Google provides a lot of information for "What is Computer Science?" This includes the summaries given by a lot of colleges. However, most of it stresses only the positive things and so gives a somewhat incomplete picture. In the early 1960's as a teenager, I visited a local computer center. They had what was likely an IBM 650 with drum memory. I got to see what folks did back then and recall that I wasn't very impressed. I studied math. But CS wasn't an option then. But something more was needed in my case to generate interest. 

On a personal note, I studied Mathematics, but wound up in CS. I might have wound up as an actuary, but it sounded boring. I was meant to do mathematical research, but never really got the chance after I finished my doctorate. Up until about two years before I finished, the job prospects for mathematicians were fantastic. Like CS today, there were lots of jobs and good salaries. But it all fell apart in about a year. When I finished there were no such jobs - none. Several hundred applications resulted in no offers, though I was well respected at the time and wrote a very nice thesis. But I really wanted to teach, and so took a job that I was, in many ways, overqualified for. But it kept me in the profession, even though I had to change fields. I never programmed a computer until after I had a PhD. But I knew how to learn and how to work hard. 

I first programmed (FORTRAN IV) in 1972. At the time, the main program "editor" was a key punch machine that punched 80 column cards. You assembled [1] a deck with your program and certain control cards, possibly even including a copy of the Fortran Compiler into a deck and you submitted your deck at a window to another person. In a small shop, that person might be the operator and the computer might even be visible somewhere behind the operator - through a window, as computers were noisy and had to be enclosed. Twenty four hours later, you picked up the results at a window. If there was any error in your program (or elsewhere in the deck), what you got was a failure report and went back to the keypunch to correct it. When done, you started another twenty four hour cycle. As you can imagine, getting the syntax correct the first time was extremely important. Now, I program using Eclipse. The system is so efficient that it finds and highlights my syntax errors as I make them. It also finds and maybe corrects lexical (spelling) errors. It completes statement blocks and indents as I go. There are two lessons here. One is that "getting the syntax right the first time" was much more critical then than now. But also, Eclipse error highlighting and correction actually teaches the student over time not to make the mistakes that are the least important of all. Semantic and intent mistakes are what we need to focus on, and what the teaching (and grading) should focus on, not the kinds of things that tools like eclipse can (a) find/correct and (b) teach us incrementally. It is useful to be able to write code by hand. Sometimes you are on a bus and need to capture an idea and all you have available is a pencil and paper. But you don't need perfect syntax to capture the idea. The answer here from Peter notes that in some extremely important tests, students will need to write out code by hand. But the comments currently listed with it also indicate (correctly IMO) that the grading is very gentle on the kinds of things that tools can help us with. tl;dr: Use good tools in teaching. Focus on the higher level concepts and let the tools correct errors of the formal language as well as help the students see what they should have written. If you want them to really learn to get the syntax right the first time, use a key punch and 24 hour turnaround. Other forms of abuse might work just as well. But.... well, no, don't do that.