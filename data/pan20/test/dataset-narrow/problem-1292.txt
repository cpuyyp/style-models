As far as I know .x doesn't support vertex animation. What it does support, and what you're probably seeing, is an old style of 3D animation sometimes called "hierarchy animation". In this animation style, a model isn't a single mesh but rather a series of meshes all linked together in a hierarchy (eg. a human character isn't a single mesh but rather separate meshes for the head, torso, upper arm, lower arm, etc.) The individual meshes don't deform, but instead by applying rotations to the separate meshes the model is animated. Think of it like a robot arm. The pieces of the robot arm don't bend, but the overall arm bends when the pieces rotate. 

Now that's with regards physics. As for trigonometry, that's a bit more crucial. Again, not much more than what they teach in highschool, but a lot of people reject even that level of math and you're going to need to be comfortable with things like sines and the Pythagorean Theorum. Depending on exactly what you program, you might also need to use some 3D math concepts, but again it's not really a prerequisite and more stuff you can learn as you go. Here's one good resource $URL$ 

For example, to address the exact list you gave, here is how I learned that stuff: I first learned to work with shell commands because I started using computers back in the days of DOS. Obviously I was only doing the simplest command-line stuff, but the point is I got comfortable working that way and have no problem picking up other stuff on an as-needed basis. I learned about SVN at a job a few years ago. This was the clearest case of what you described, where other programmers at that job behaved as if everyone should just know stuff by default, but it wasn't hard to learn SVN and that is just one of several really useful things I learned at that job. I started learning how websites work back when I made my first website in highschool, and I've been gradually adding bits and pieces of knowledge over time. There's no clear moment of learning I can point to. I still don't know much about how databases work, because I'm mostly a client-side programmer. When I once needed to query a database directly I learned a few SQL commands on an as-needed basis, but beyond that I don't know much. shrug 

Are there any simple (or well documented) algorithms for basic CSG operations on 2D polygons? I'm looking for a way to 'add' a number of overlapping 2D collision shapes. These may be convex or concave, but will be closed shapes, defined as a set of line segments, with no self-intersections. The use of this would be to construct a clean set of collision edges, for use with a 2D physics engine, from a scene consisting of many arbitrarily placed (and frequently overlapping) objects, each with their own collision shape. To begin with, I only need to 'add' shapes, but the ability to 'subtract', to create holes, may also be useful. 

$URL$ is worth a look, it seems quite affordable for indies, if you can find tracks which suit your game. They offer two tiers of pricing - a basic license for up to 5000 copies distributed, and a 'mass-market' license for more than that. 

If you just want collision detection, and not a full physics engine, it might be worth taking a look at OPCODE - $URL$ (although it is a bit old now, there may be newer/better things out there?) 

3D with shutter glasses first appeared on the PC almost a decade ago. 3D cinemas (using polarised glasses) have been around for even longer, although primiarly at theme parks. It didn't take off then, and little has changed since then, really. Nobody wants to wear 3D glasses for their daily living room TV viewing, and it's not a whole lot more appealing for regular gaming. But even if you don't mind the glasses, there's another perhaps more serious problem. On current platforms, stereoscopic 3D often offers a significantly worse experience than 'flat 3D', as rendering the scene for each eye usually results in a halving of the framerate. I recently looked at Gran Turismo 5 on a 3D TV, it was not impressive. The framerate was all over the place, ruining the 3D effect. Switch off 3D mode and you've got a much nicer game, running at a lovely smooth 60fps. I'm sure there'll be a lot more games released with 3D support in the near future, simply becaust the hardware support is now there. But it's likely to be more as a 'tick the box' extra feature, rather than a fundamental part of the game, and at the price of a severe drop in framerate and/or image quality. The 3DS, on the other hand, is likely to be a big success. (Although Nintendo's only big hardware release failure was their last attempt at 3D, the Virtual Boy...). But I wouldn't be surprised if most gamers turn off the 3D effect after the novelty factor quickly wears off. 

One of the best GUI libraries that renders in OpenGL is CEGUI: $URL$ It isn't specifically designed to emulate WP7 but I would imagine you can accomplish that with customized graphics within CEGUI. 

Level design boils down to setting up decisions for the player to make. Thus, your first step when designing a level is planning out what decisions you want the player to make. Once you've planned out what decisions the player will make in your level, then you can more deliberately lay out elements in order to support those decisions. Note that the decisions aren't always complicated, and in simpler games it may even be the same decisions in a bunch of levels, in which case all those levels are just different permutations of the same set of decisions. Breakout is an example of the latter: in every level you want the player to make decisions about whether to chase after the falling power-up or stay under the ball. In a more complex game you'll be setting up decisions about which path to take, decisions about how to engage each enemy, decisions about when you use various resources, etc. 

I've been using TexturePacker to create sprites from a folder of PNG images. I'm porting a game originally developed in Flash, so I'm simply exporting each frame of the MovieClip to png and then importing those images in Texture Packer. Another similar tool is Zwoptex (The latter is Mac software, but TP has a version for Windows too.) 

The choices I would consider are either making the individual objects respond to different gamestates, or serve up different levels in different gamestates. The choice between those two would depend on what exactly I am trying to do in the game (what are the different states? how will the game transition between states? etc.) Either way however I wouldn't do it by hard-coding the states into the game code. Rather than a massive switch statement in NPC objects, I would instead of the NPC behaviors loaded into an associative array from a data file and then use that associative array to run different behavior for their associated states, something like this: 

I wouldn't recommend either Java or C++ unless you are already very familiar with those languages. The language I would recommend is Python, and the most obvious game library for that language is PyGame: $URL$ Another game development tool I am thinking of starting to use is Love2D, mostly because I have started programming in Lua: $URL$ That's for 2D games; if you want to develop 3D games then going with Unity is a great place to learn: $URL$ And then while I have no personal experience with C# a lot of people say good things about learning game development using XNA. 

As the engine is pretty well known and documented by the community I think you can will be able to find a lot of detailed information about that type of map rendering in the GemRB community. 

Now you see, in the fourth row in the second column, there is a grass tile. Left of it is a water tile and on top and bottom of it are sand tiles. When we look at the rendering only for this tile, this is what happens: 

Define your viewport (position and size of the viewport). If you have this, you can define your borders. When your viewport position defines the upper left corner of your screen its pretty easy to restrict the screen position. First of all you set the screen position to be centered on the player: 

Like this, you do not have to care about multiple terrain types getting together, as they are rendered from lowest to highest terrain type and the transtitions only concern the higher type. I know that it is a bit complicated at first, but I currently don't have more graphics, because I'm in the middle of refactoring my source. I will add some graphics representing what I do as soon as possible (also better explaining every step). I hope this will help you. One small addition: My mapper is built, that there is a default blend texture. But you can define specific blend textures for every terrain type. So for example if you want to make smoth transitions for all mappings besides the beach to water transition, you put the smooth transition as default and only set the custom transtition for the beach tiles. Also, my mapper allows to define multiple transition tiles for each tile type (so if you have a straight edge, you can make multiple blends, so they will alternate). ** Appended ** Because I currently have no assets to show, I created a schematic drawing in paint.net. Keep in mind, I'm a programmer and not and 2d artist, so artistically it is very badly drawn, but it should show, how I tackle the problem with multiple terrain types (>2) coming together). I left out optimizations for simplicity and applying the blending is also not mentioned, as I concentrate on the problem with the multiple terrains. I will add an example with real textures and blends as soon as I find the time to do so, so this gfx is only temporary. 

Don't 'spawn and move' individual tiles. That way will only lead to pain. Create a big 2-dimensional array of tile types (the 'tilemap') containing your whole level, and display the section that is currently on-screen. Just keep track of a 'scroll position' - either the location of the top-left or centre of your screen measured in pixels within the entire tilemap. Then use this to determine which range of tiles to draw, and where they should be on the screen. 

It may be of little practical use these days, but writing at a software renderer, at least a basic one (maybe just some spinning textured cubes), is a worthwhile exercise. Understanding how to transform, project, clip, depth-sort, rasterize, and texture map polygons yourself will give you a much better understanding of what 3D hardware and rendering APIs are doing 

For a neat little way to handle the spawning/deletion/update of particles, assuming you have a simple array of particles - Particles[MAX_PARTICLES]: Keep track of the active particles (starting with NumActiveParticles = 0) New particles are always added at the end of the array: 

Make a really good game. Get it on Steam. Market it effectively (generate enough buzz on gaming websites/forums) But the most important step is making a really good game. Kind of surprising to see suggestions of 'go for mobile development', given how oversaturated with $0.99 titles the iPhone app store is these days? - might have been a great idea 2 years or so ago - but isn't that gold rush well and truly over? - or have the new Apple devices re-ignited it? 

I strongly suspect that there's simply no market for it. (Except for a small number of geeks/developers that would be attracted to any new and open hardware) There's plenty of devices out there that can play games very well, many of which are open, or 'open enough' for indies. We can already develop for a wide variety of computers, phones, and tablets. Whilst consoles are much more limited, we do already have Xbox Indie Games (XNA), and there's active homebrew scenes for some of the older consoles such as the Dreamcast (and I wouldn't be surprised if we see a thriving PS3 homebrew scene soon?) I suspect that in the future, we'll see a mainstream 'box under the TV', maybe a future iteration of something like Apple TV, that's not a traditional console, but is good at playing casual/less demanding games, and has an app store which is reasonably open to indie devlopers. 

At one place in your code, you create your game container. If you followed the tutorials, that part will look something like this: 

I think I stumbled upon this link here on gamedev and I really found it enlighting. $URL$ It explains some basic methods of implementing tile based levels, but there are also some important parts about how certain mechanics work in 2d platformers. I think you should look into slopes, as they can solve many problems you come across in platformers. Good to know is, that most platformers don't even bother with implementing proper physics, but implement certain rules, that mimic some physical behavior (like gravity), but allow certain behaviors that wouldn't be allowed with proper physics (air control for example). 

The first two parameter define the window resolution, the third if slick should be opened in windowed or fullscreen mode (true for fullscreen mode). You should head to the slick2d wiki, as it has some beginner tutorials explaining such things. For example in this tutorial the basic things are explained step by step (also your question is answered there): Creating a Basic Game tutorial All tutorials: Slick2d Tutorials Index 

You should take a look at quad trees. Its a common datastructure to store spatial data in cells. When you do the collision testing, you simply test against the objects in the same cell... I use the same datastructure for rendering. I pass the rect that defines the viewport into a selection method of the tree and receive a list of cells. Now i just have to render all sprites from those nodes... When the object spans over multiple cells ,you can add it to both cells. Just make sure to remove the duplicates ,when you use the results from the selection method. I'm currently on my phone, so I have no code examples here ,but a quick google for quadtree should help. 

You can see, that you have some terrain textures and an alpha map. I handle the alpha map also as tiles, but they are half sized (terrain textures are 64x64, blend textures are 32x32), this means that every terrain can have up to four blend textures (northwest, northeast, southwest, southeast). Now basically what you do, when you have a transition is this: - Draw the ground texture (blends are always applied on the higher terrain types). - Draw the alpha map with ALPHA_MAP (this only renders the alpha channel) - Draw the second texture with ALPHA_BLEND (this uses the underlying alpha channel, we rendered out before as alpha for the tile). So basically this is the theory... But you need to do some things, that it works properly. What I do is following: