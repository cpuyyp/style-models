I recommend removing as "Neutral" is not an Element Type, it is the lack of an element and therefore makes element.type not applicable. With removed you can greatly simplify your solution: 

In some languages variable names like are common and expected but in Kotlin (and Java) I find it more common and expected to have variables names avoid abbreviations, use camel casing, etc. I recommend using instead of . You are returning a . This is fine but data classes are so much better and Kotlin makes it so easy to define and use them. I recommend creating your own type to return. e.g.: 

Instead of using you might check to see if the given product is greater than the currently known maximum product and then assign it if it is. This is minor but personally I prefer to avoid unnecessary assignments. I wouldn't worry about trying to do all of this in one pass. Each directional slice has different row/column bounds so I think four separate loops is the clearest/cleanest. You can remove some duplicated code when it comes to calculating the product and updating the maximum. 

which will avoid creating an intermediary list (small optimization in this case). Perhaps a minor issue but I personally prefer using "index" instead of "i" or "idx" to avoid any ambiguity. "idx" actually has several meanings. I find used with to often be more readable than combined with : 

While the function ReadGrid would be simple enough, the new IsPatternInGrid function would still be quite complex and could possibly also benefit from factoring out some its code into yet another function. Other things that I changed in the block of code above aren't as important for readability but are common for coding standards: 

Overall the principle idea of using a class with a virtual function that operates on a is a good one. But there's quite a lot of little issues/suggestions here... 

Getters and setters are normally a bad idea - might as well just make the variables public in that case. Other than , I don't believe the getters and setters are even used; just get rid of them. A player can't change their game piece in the middle of the game, so I would replace with passing it in with the constructor. 

These 2 functions in are breaking the point of using your class. Once the objects have been set there is no need for the to know whether those players are computer or human players. In fact, shouldn't even know that there's such a thing as a computer (or human) player. Your class is missing a virtual destructor. A virtual destructor is needed for inheritance where you are storing the objects by a pointer to the base class. 

If we're speaking of actual efficiency (as in performance) though, I don't know how much more efficient pattern matching is compared to iteration of characters. However, this is much more readable. In any case, notice that the actual translation logic is wrapped inside the condition that the input string does not contain a number. This way, you return from the method as soon as you determine the input is unacceptable. To check whether the input string starts with a vowel, you can also use pattern matching like: 

Each move has some seemingly intrinsic characteristics. In particular, each of their name should be lower case Strings, and their values are limited to some given set of words. My impression is that these rules aren't bound to change that much anyway, so why rely on the rules engine to impose them? For one, instead of checking if their names are lower case, why don't we just ensure that they always are? Instead of making it a rule, why not turn it into a basic assumption? 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

C-style is a bad habit to get into. The C++ library might look intimidating but is actually easy to use in practice. 

Your objects are being stored in raw pointers and are not being deleted. It's not a problem here because your application ends when they should be deleted, but in general will lead to memory leaks. Consider using instead as it will automatically manage the object's lifetime. You have a lot of input functions which all do approximately the same thing - prompt for a Yes/No answer. These can all be factored out into a single function (takes in the text prompt as a parameter). Your function is sharing the load of running the game with the class. I think you could benefit from a clearer separation of concerns by introducing a new class, , which includes GameLogic, Board, Players, etc. All user input would be done by the class - would be concerned with the "game logic" only, no user interface stuff. (In general we want as few classes interacting with the user as possible; helps with testing and reusability.) I suggest ordering your class sections , then , then . The interface (public) is the most used section; the private section is like the class's dirty laundry and you want to hide it away at the bottom of the class declaration. 

And you can even pre-compute the required capacity to avoid unnecessary array copying while building the string: 

You can use the slightly shorter instead of . You can also move trailing lambda arguments out of parentheses: 

Personally I prefer "row/column" instead of "y/x". Thinking "y" before "x" is unnatural. You can always define your own methods too which can improve readability. e.g.: 

Kotlin already guarantees that and are not as you've used for their type instead of . As such, the statements are unnecessary. I do not believe you gain much from and . and read clearly and are read in constant time so the additional variables seem unnecessary to me. You can place the last lambda argument in a function call into parentheses as you have done but I personally find moving it out of the parentheses easier to read and more idiomatic: 

If is never used then even itself can be eliminated and the tree string building logic can be placed in a single function: 

Sometimes in Kotlin you don't have to declare temporary variables so that you can do something with a return value before returning it. e.g.: 

For determining correctness of your implementation I recommend referring to an existing implementation such as Apache commons-lang or the newer commons-text: 

I don't know what field represents, but I kept it. However, due to the fact that it's not readily understandable, you should reconsider why it's there in the first place. In any case, notice that there are only getters for this class, and no setters. This is because, like I said, objects most likely won't need to change, there's no point enabling the state transitions in them. Rules Integration I missed a critical aspect of the problem you're trying to solve with your code, which is the rules engine primarily geared towards not-so-technical people. However, I still think that having those rules in the system does not mean we should completely forget about good OO design. I believe that rules should augment your design, not hijack it. Since having a enum is quite restrictive, my idea is to define it instead as a value object: 

Hopefully the class illustrates my point about classes being in charge of their own state, actions, etc. Lastly, about , I will also say that this class is weak, and overly transparent. My idea is that once a object is created, it will never change. Because of this, I think that should be defined this way: 

One final thing: the github version has replaced all the includes with a - that's a bad use of Visual C++ pre-compiled headers. Since pre-compiled headers are non-standard, I'd recommend just not using them, but if you have to, the pre-compiled header should be duplicating your (common) includes, not replacing them. 

This clearly defines what values and options can affect the result, and you can keep all the variables and calculations needed for doing one simulation local to this function. I would consider breaking this function down further, but just pulling out this one function will make things a lot neater and clearer. Other things in the code that aren't so serious and reflect my personal style preferences: 

This code would greatly benefit from being split into functions, the most important one for your logic being a function to run a single instance of the simulation. 

can then actually validate the move and make it on the Board. This keeps the "game logic" in the class. Finally, to your question about implementing a proper AI ... I'd strongly suggest starting with a simpler game than Connect-4 like Tic-Tac-Toe. If you persist, a starting point would be a minimax search. 

This isn't very convenient but thankfully Kotlin allows us to use reified type parameters to define an extension function to simplify this: 

You're method is not transitive (e.g. and but . See Any.equals - stdlib - Kotlin Programming Language for more details on the requirements for . You might also consider using from for testing your own implementations of . If you define your own method instead of defining a custom, non-transitive implementation than your existing solution can become much simpler: 

This also prevents printing a trailing space. You don't need to re-read "dict.txt" as it doesn't change with each word. 

will return . will return . If you want both to return then replace the with in . Marking as is purely optional but it seems to me like a good fit. 

You can still use a enum if you'd like but this function is very similar to so would seem to suffice. Every enum class has a function implementing (Enum Classes - Kotlin Programming Language). As such, would declare both and which seems confusing to me. I suggest defining superior and inferior check functions instead of but this may not be practical depending on how you are using : 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: 

Conceptual Framework for Domain Model In your application, there's a rule imposed (via your Drools XML) that there is a fixed set of values to a 's move. My opinion here is that your domain model should reflect that requirement, and seeing as you have generics in your code, your application should also be able to support Java enum. I think it's better to capture this restriction on valid moves by creating an enum called like the following: 

Using returns a new object but such isn't necessary in this case. You can use directly on the . You can reduce duplicated code by using classes and/or extension functions. e.g.: 

I wouldn't use or because it makes it appear that can be greater than which is not true. I recommend using . 

Unfortunately this can sometimes look a bit strange using , etc. but in Kotlin 1.1 you can use bound callable references: 

If however you actually need/want classes for tree components then I recommend making those components (or collections of those components) members of a class (e.g. a has ). 

However, the "problem" specified in LeetCode does not use arrays which are very different from linked lists. If you convert the Java code it provides you would get the following: 

"args" is more common and descriptive than "a" in a function signature "\n" is system-dependent; I recommend using instead can be used with a instead of first mapping an using a and then calling . e.g.: 

In my opinion, the main factor in preventing you from having a clean primary constructor is indeed the two paths to the super class (via or ) and having a super class define the property is in fact what also prevents you from making this a data class. I recommend making an or with no properties in its constructor. e.g.: 

I'm not really sure, but somehow I feel like this can be an instance of a refused bequest, or some sort of breach of contract. I think you have few options here: 

Admittedly, I don't know much about Drools, but guessing from how the rules are defined here, using this class, rules can be defined like (this is not Drools syntax): 

Hopefully there's a way to make this work both ways. Anyway, I don't expect to get everything correctly here, but I hope somehow I raised interesting points regarding your code structure, and domain design 

My personal view in methods like this is that instead of making them setters/mutators, you turn them into actions/features. So instead of having a that takes a from a client component, I think it would be a bit more sensible to have something like: 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: