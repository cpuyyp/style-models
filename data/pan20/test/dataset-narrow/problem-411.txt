Your loop iterates over the whole array even after it encounters a that is contained in . This is not necessary â€“ it is sufficient to terminate the loop once an array element is found to be contained in , which is also known as short-circuiting. The solution suggested by vishva is short-circuiting, as stated in its documentation. 

Note that, unlike , this only checks the classes for equality and returns if one class is a subclass of the other. If you want to consider subclasses as well, you can use . You should also be aware that, unless returns a primitive type, you are comparing the models based on reference equality rather than comparing their contents. I don't know what type returns, but even if it only returns a simple , will not consider the contents of the Strings but only check whether the two variables reference the same object (which might not necessarily be the case even if the String's contents are identical), so you would need to use if you want to compare the contents of the two Strings. 

Judging by your comment, you already seem to be aware of the method , so there's no need to explain how to chain those comparators using this method. Unfortunately, the forth comparison stage does not fit into this pattern. Of course, you could ditch the nulls-first comparator and write your own generalized version of it which, instead of comparing the two values with , checks a given against the values: 

Also, there is no need to handle the case (which, after deleting , would translate to ) separately. The result of the method will be unaffected if you remove this extra and simply let the loop take care of it. In fact, I don't see anything special in this case in the first place, so I wonder why you make a special case for it. Besides, I think it is strange that you let the main method read the number of test cases from the command line, but delegate the reading of the individual test cases to the method, not least because this requires you to create a new object for every single test case. Why don't you do all the reading from the command line in one method, and then pass each test case to the method as a parameter and let it do only do what its name suggest, namely calculating the result? Anyway, I would suggest separating user interface from program logic, because right now, the method not only calculates the result, but also prints it to , which goes a bit against the Single Responsibility Principle. I think the code would be clearer if returns a representing the result, so that the calling method can decide what to do with the result. 

Just for the sake of completeness, there are things that this parser doesn't support other than comments and elements with mixed content, such as processing instructions or character references (e.g. or instead of , i.e. references to unicode code points rather than entities). Processing instructions are meant to carry information relevant only to the application receiving the XML document and are not part of the data stored by the XML document, but the parser should recognize them nonetheless. And since you support references to the five predefined entities (i.e. , and so on), it would seem natural also to support character references. The parser also doesn't read the prolog, which consists of an optional XML declaration and a likewise optional document type declaration, although, admittely, the XML declaration only contains information specific to the process of parsing the document itself (such as the XML version, or the character encoding), and the document type declaration defines such things as the stucture of the document and entities to be referenced by an entity reference, so it might not make sense for the parser that parses the XML data to also parse the prolog. So now about what you have implemented: 

First, a general note on this answer: I am going to use the type names and , even though in your code they're both represented by s, because it's easier to understand that way. 

When you are collecting the unique integer values to a sorted list from the values of the original , you are doing work that has already been done, namely the elimination of duplicates by calling on the stream. You have already filtered out the duplicates when you populated the , so instead of collecting the values of the , you could instead collect the keys of the . Also, you are creating a , which stores its values in s (so it's like a ). This creates unneeded overhead, because the s containing the values of the multimap eliminate duplicates. But in this case, the multimap can never contain duplicate values in the first place, since its values are obtained from the key set of the original . It would therefore suffice to configure the multimap to store its values in s instead of s. By the way, the documentation says that the methods of the individual implementations will be deprecated in the future, and that should be used instead. Apart from that, you can omit the entirely by configuring the multimap to behave like a instead of a . This might also save a bit of performance, because you have two functionalities implemented in one data structure, as opposed to using a for associating each integer with one or more Strings, and an additional for sorting the integers. Of course, a does not index its keys, so you would have to maintain a counter yourself when you iterate over the keys of the multimap. Finally, the overall structure of your code sample is strange. Unit tests are meant to test whether some code works correctly. But your method not only performs the tests, it also contains the code to be tested. Of course, there's nothing wrong with placing assertions in code to test it. But what you wrote is not a unit test, because it doesn't test any defined unit (for example a method). It just executes some code and then uses assertions to check whether the code did what you thought it would do. Instead, I suggest that you first write a method that accepts a (or any where ) as a parameter and returns a "compressed" version of this map: 

Using to look for a in a seems to be faster than searching for a in a using . On the other hand, requires the to be sorted, which is why we need a second that stores all distinct characters in the order they were first encountered in the original , assuming the returned must fulfill this requirement (if it doesn't, then the array is actually not needed and you can return directly at the end of this method, which might speed up the process a little bit). To ensure that stays sorted, it is important to insert new s at the correct position when updating , which is why two calls to are needed. I did some simulations with random arrays, each containing 100000 random characters. Here are the results of a set of 10 simulations: 

This will probably not compile if you add it to your code, because in your code, is not and can therefore not be referenced from a static context. However, since does not depend on any of the three instance variables of , it would be more appropriate if were static as well. By the way, I don't think "" is a very good method name, because it doesn't really describe what the method does. A more informative name might be "". Now, with this helper method, the actual initialization of the object will be a piece of cake: 

So your code performed slightly better in all test cases listed here (although there also were some 10,000-size array test cases in other benchmark runs where the HashMap performed slightly better). Next, 10 test cases, same as above, but now the arrays contain 100,000 integers: 

As for your question of what happens to the intrinsic lock when the is thrown: As soon as is called, the thread relinquishes the lock, which is stated in the documentation of . Continuing to hold the lock would defeat the purpose of , which is to wait for some other thread to do something for which it needs the lock and be notified when that thread is finished with the task and no longer needs the lock, so that the current thread can start trying to re-acquire the lock. This means that, in order to return from and, if needed, execute the block, the thread has to acquire the lock again first. Once the thread does have the lock, however, entering the block will have no effect on the thread's ownership of the monitor. I found this question, which, along with the answer given there, might contain what you're interested in. Update Here's a test to demonstrate that, even if the block is not synchronized, it will still only be executed after the thread has re-acquired the lock, because the thread must first return from , which will only happen when it has the lock it was waiting on.