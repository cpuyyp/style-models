I seem to get the feeling you are either not comfortable using maps as others have suggested here...so why not throw in a switch instead? 

I've commented through your existing code below and noted what was removed/replaced/added (my comments are denoted by double 's): 

I made a few changes - namely normalizing the styling (PascalCase classname, lower_case properties, camelCase methods) and spacing. I then made the buildOptions() function shorter and renamed it to generateOption() as that is more adept to what it does. I also added an InvalidArgumentException in the construct that is tripped whenever you pass in an empty array. 

You are calling every time you call either or . Are you doing anything other than returning an instance of the class? If not, then just instantiate the class and making a construct would be more ideal. Doing so, your class would look like: 

Doing so shaves you 4 bytes from the returned iterator object, as well as all the variable assignments and the added function and compacts your code. EDIT Seems that does not memoize as I thought - it just returns an iterator. However, does so, though statically: 

Any ideas on how to improve this to improve performance or reduce calls? Any review, refactoring or just general thoughts would be highly appreciated. What did I do wrong? What would you change? Thanks all! EDIT: adding rudimentary html snipped this acts on 

Try this, just removed a couple of the repeated code (moved it to a function) and sets minified version or regular version based on a bool variable (getminified), thus you only have filePathFull (no longer have filePathMin): 

Again however, if some class extends it, they won't be able to access the var. Also, stay away from static. 

Memoizing a generator is a good idea to save having to rerun it. There are a few ways to do it - one is to handle it the way you're handling it, by returning the cached result if it exists, otherwise returning and caching the new result. The first way, is to the the method from . Such as follows: 

Ok, there are a couple of things wrong with your code and your method of organizing the code. I've pointed them out to you in the code below within comments. The comments preceded with are my comments. 

Now, we know that the Sexagenary cycle consists of 60 periods, thus, to determine what animal and element a certain year matches: 

Removed all semicolons - they are not required in Python Removed all parentheses around the variable as they're unnecessary Renamed the variable in to Renamed the function to Created new and functions to clean up print statements in code 

This class should handle only User related SQL interactions. It will then send those to the Database class which is shared over other models. 

And in the future you write another class that extends that class and it wants to update URL as below: 

The code below approximates the current functionality of the site that you linked to, using only CSS percentages. You can target certain screen sizes (for example, this code below breaks at 830px) by utilizing media queries. 

It's fine to have a wrapper to abstract PDO functionality, especially to avoid code duplication. The class itself looks ok to me as well - aside from some minor issues, as delineated in the comments in the code: 

Rather than tie yourself to only one type (string), you could use the package as well as interfaces to make it somewhat type indifferent. The following is my reworking of your code: 

However, unless you have hundreds of millions of visitors to your site, you don't have to hyper optimize this way. If its purely from an aesthetic point of view, then I would say just do: 

Obviously, there should be separation of concerns, which this does not implement, etc. ++++ EDIT ++++ Implemented comments 

The code below is good. I only changed the comments a bit to make them a bit clearer and more concise. However, one glaring issue is that it seems you have your setters and getters mixed up. Note the and functions you have in your class. Usually, setter and getter functions do exactly that: they set a value and get a value. What you seem to be doing is using the set* functions to get the value returned by another function. This is +wrong+. 

Like I said - very little to do with code from my POV - perhaps someone can skim through it and add their ideas on how to optimize it further. 

You should think more about how you arrange and style your code. Additionally, you should be aware of DRY methodology and keep from repeating code wherever possible. I made a couple of modifications to your code. Primarily, I cleaned up the arrangement and styling. After that, I added an Ohm class - which places all of your Ohm related functions as methods (again for code cleanliness): 

What you're doing with is a sign-propagating right shift. The interesting this is, you're doing a right shift by 0 (I'd imagine because you'd otherwise get . Your method of doing so is a cheap version (read: performance hack?) of doing . Here's your function with the SPRS removed and replaced with instead. I've also implemented simplification. 

Looks good to me! Now, if you want to include the dates, that's when you may want to start thinking about just using a database as a static lookup table. 

Use PDO, not mysql_* as they are deprecated and dangerous. Break up your code into functions, this makes it easier to call and test. Throw and catch exceptions. You can omit the ending ?> 

That way, we end up with 2 function calls to and 2 new variables (which are cheaper than a function call), but is still not as performant as your original one liner. 

The only real optimization I see if taking advantage of Pythons english comprehension to unify the return statement: So, would read: 

Break out the function into two - encrypt and decrypt. Your functions should do the least amount of things. return on trim - no need to set . In the encrypt, no need to have the second when you concat . Just concat on the initial call. 

I'm not quite sure that this question is on topic, however: You have to understand what each variable definition is and what it means for the accesibility of that variable. Say your class definition is as follows: 

To start, lets look for something that we can loop through. From your link to relevant dates, we can see that the associated animals loop through 12 animals, in order: 

I'm going to assume here (having done this myself before when I first started out with PHP), that you are storing the state data in a MySQL database, which you are pulling and storing in the var. Do not do that. You're slowing down the entire program by making a call out to the database for what is pretty much static data (the last state to join the union joined 55 years ago). Now, I would just have the dropdowns stored in functions which just return a string. One function for long name, one for abbreviated. However, using this as an exercise for you in DRY, I went ahead and created a class, , which contains an associative array of states/properties and their abbreviation. On initiation, the class generates the output form. If the contains 'abbr', then we use the abbreviated version after performing a . Otherwise, since the data in the array is static and already sorted as we prefer, we don't perform an and just go straight to storing the select form in a property . 

Why not go with a template like Twig or Blade which would make the syntax a lot cleaner, while retaining most of all the controls. Also, remember that the view is for showing data, try to maintain as much logic OUT of the view as possible. Here's an untested version of your code with Blade: 

So, ultimately, using two function calls to without arrays is faster overall than and with an array. EDIT Considering your newly added third point (non-fixed number of variables), it would be best to abstract this to a function, at the sacrifice of speed. 

For your code however, you'd have to make sure that you are your try/catch block is within another try/catch block, otherwise you will end up with an uncaught exception error. 

But without knowing how you want your JSON to be defined, at the moment I can only suggest the following, which fetches all records in the SQL query and shunts them to the JSON encoder. 

My little attempt basically takes items that are repeated and puts them into their own separate conf files and just include them into the main conf files. On my servers, I structure them as such: 

Basically, we're doing the check inline, as well as concatenating the php extension after check. Though this relies on the file not existing - you can replace with any other name. Additionally, we're not echoing on fail - rather we simply inform the user that the requested page does not exist. 

Just remember that when it comes to data, in 90% of situations it's best to let the database interweave the data for you than blocking CPU at the application level. PS: After you post a reply/update, I'll modify my code and answer accordingly. 

However, this set of 1000 integers while have a size of 4.2KB in memory. So its not ideal, nor memory efficient, but its an option. Now, the way that you did it, as follows: 

For birth year 1989, sYear should be period 6. Now, let's generate a function that will hold the animal-element array above ($assoc) and contain two loops. The outer loop will decrement through the ceiling of the sexagenarian cycle divided by 12, and the inner loop is a foreach() over the animal-element array. This method is accurate all the way back to 4AD. 

The way you did it is pretty much the standard way to bubble exceptions up the stack. Basically something like: 

Which is comparable in speed to the multiple str_replace call (which is what you're technically doing in the function. 

This is the Database class, which is dumb enough to just run queries and return an array with results. 

I absconded the preg_match() to return within the function INTO a variable - as it is less expensive than a function call within a function call (however, if you're doing more than just a preg_match() to validate, then revert it back to the isValid() function. I also reworked your if/else/if/else into an (if|if)/else statement - higher readability and saves you one else call. Also, I put your code into a function and made it return once, rather than echo three times. 

I took the liberty of going through your code - see the comments preceded with MOD (modification), STAT (statement), QUES (question), SOL (solution) and REMOVED (removed) 

Well, the function kind-of sort-of violates SRP...but according to Uncle Bob, I think your class violates the SRP moreso than the function. Your class above, has three functions within it: . One of them scans the directory, one of theme creates an array of theme names, and another loads the theme files. One of those methods should not be in there: should be in its own class called or something. Which means, by extension, that is in violation of SRP. To quote Atwood - SRP is about "choosing a single, clearly defined goal for any particular bit of code: Do One Thing ... But in choosing one thing, you are ruling out an infinite universe of other possible things you could have done. It also means consciously choosing what your code won't do.". So in the end, its up to you whether this violates SRP and whether you would choose to follow SRP so deeply that you violate OOP or DRY. Perhaps someone with more experience can chime in or prove me wrong (heck, always good to learn something from someone else) EDIT: See ($URL$ article as well for clarification. REVISIT 01/26/2015: Revisiting this answer, I would rewrite the code as follows: 

"I'm pretty confident it would be a bad thing to have the same code for opening a connection in each function of the class, that's why I've put the connection opening code in a function itself." 

This is the output of my version of the func (using the same calls and expected output as above in the original call) (output → expected_output): 

It defaults outside_mode to False, so that we can omit it and only give it a number to check if its within the range Checks if n is within a range elegantly Uses the retval var as a flip switch boolean Handles strings and outputs False if its a string Correctly outputs the expected output 

This function makes use of array_walk_recursive() to push into a placeholder array whatever value is pointed to by whichever key matches our needle key. Proof code: 

right off the bat. Just initialize to and it'll kick you into the loop. You can also move the and filenames to variables so they aren't hard coded. Ideally, you should move them to a config file or cli args. Below is the updated/cleaned up version of your code: 

Echoing will output (or an array if value0 is an array). As a side note, you could actually get completely rid of $i, and just do the following: 

This will leave you with an array with two main nodes: files and directories. I wrote this for a PHP distributed test-and-build-on-commit system and it worked well. More info on the PHP SPL Iterators can be found here: $URL$ By the way, the GetInfoArray is this: 

If you're going after readability and speed, then doing a preg_replace is actually a lot slower than doing a str_replace. I'm using this test code: 

After , it restarts again with . So let's put these into an associative array, with the associated element: 

If you wanted, you could even store the return value of in a property of the class so that you could call without injecting , as follows: 

I found a few minor issues. Amongst them, are not exiting early (performance enhancement: exit before the database query happens). Additionally, you're not handling certain errors. Lastly, your lack of braces is disturbing, as it can lead to bugs if the code is ever modified incompetently. I've left my comments within the code as . Below are the commented files, assuming Key.php for the key page and Forms.php for the forms page as pseudonames: Key.php 

(I'm leaving the original answer intact for posterity, but please read the edit at the bottom of the answer as the answer is wrong). Why create a complicated line of code, such as: 

And the includes are included in the SA conf files. Not good for performance, but negligible. Anyways, here's an idea: 

These are the two final products, one brute force, and one using built ins, and both return the same value when a word is found: 

I think it looks ok - though someone might want to add on if they notice any issues I may have missed. However, a bit of cleanup goes a long way: 

So, we'll use that as our baseline for improvement (further runs stay constant around .052/1000). Let's grab the low hanging fruit - caching the calls: 

Finally, we check if variable is None. If it is not None, then we print it, otherwise we print an error. As for your 'funny' error, remember that error messages should be informative (ie, should tell the end user where the error occurred and/or why it occurred):