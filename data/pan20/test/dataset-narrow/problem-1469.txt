Get physical. Even though high school kids resist physical activities in class, any time you can get them using their bodies, they will be engaged. Have them imitate the shape of a graph with their hands. Tell them to stand up and figure out with a partner how to mime recursion, or whatever concept you've just discussed. Use manipulables whenever you can. Honestly, even doing an elementary-school style "stand up and shake it out" can bring your kids back to you. Thumbs-up: comprehension self-ratings. After almost every concept I teach, I have my kids show me thumbs. Thumbs-up means that they think they get it. Thumbs-down means they're lost, and thumbs to the side means they're feeling a little fuzzy. This immediate feedback allows me to target the kids who know they need help right away. Modified pop-quizzes. One technique I used regularly in my old job was semi-announced pop-quizzes. If attention was floundering, I would announce that a pop quiz was possible in the next 10 minutes. I only actually ran a pop quiz about 20-25% of the time. Most of the time, the kids clicked in, and I didn't need to. The quizzes themselves didn't count for a lot, but the mere threat of them provided a very easy tool to gain total, focused attention at moments when I really needed it. Pair, explain, ask. This is a modification of the traditional pair and share, and is useful for concepts that you are already pretty sure that your kids don't entirely get. (I will use this in place of thumbs-up when I want to get a difficult point across). Ask kids to explain the concept we just learned to a neighbor, and announce the number of seconds available for the activity (why seconds? See footnote here). You'll get an immediate flurry of activity, and if you listen, you'll hear some very productive discussion going on. As soon as they're done, ask if any groups still have questions. Keep it silly. Even the driest topics are made more palatable with a dose of the silly. Mary Poppins got this right. "Just a spoonful of sugar..." It doesn't have to be world-class humor. It just needs to be off-kilter enough to keep the kids guessing a little about where you will go next. 

Every career has "gotchas". There is something about every job that is undesirable. That's why it is called a "job". But students can make sure they are matched as well as possible - minimize the "gotchas", so to speak. I entered CS because I loved to write code. I stumbled into the field as a junior in college and immediately changed my educational course. I am thankful for that "accidental" encounter, but it wasn't an accident, I don't believe, that I loved computing as soon as I was exposed to it. My "desire" had been predicted. I remember taking a career assessment of some sort as a sophomore in high school. I remember the career assessment saying I was a good match for "computer science". I remember thinking "what the heck is that?" (this was prior to the PC revolution), and I remember immediately dismissing the results of my assessment. But the assessment was correct. I say all that to say this: students should be encouraged to use career and interest assessments in high school, maybe even repeatedly (once a year). A quick Google search reveals many free assessments, and my state's college foundation provides 7 of them for free in one place. Up until recently, the students at my high school had been required to do several of these assessments as sophomores. Unfortunately, with a change in management, that practice ceased. But I still have my students do them as part of my class. We all should, I think. Using assessments such as this at least helps students better understand themselves, and may prevent them from making a very bad career choice. Of course, sometimes the assessments will be downright wrong (I recently had a student, one of my very best programmers, who loves to write code, is good at it, and knows she wants to go into CS, have an assessment tell her she should be an artist; however, I don't believe it was entirely off track because her code is very creative and is an artistic outlet for her). But sometimes career and self-assessments will help a student think outside the box about what they want to "be". And that is a good thing. Another thing my school does is bring in professionals to share about their jobs. They speak briefly about their backgrounds, what they do, what they like about their jobs, and what they dislike about their jobs. They usually speak during lunch in a classroom. The kids eat their lunches while they speak. It is very informal and always well attended. The feedback from the students is always very positive. Our local CDC (career development coordinator) organizes these "Lunch and Learn" sessions, as we call them. We have 5-6 a year. These are tangible things you can "do" to help students get ideas about careers. Some students may still fall headlong into something that is not a good match for them, because of tunnel vision, or peer pressure, or parental wishes. But some of them will identify or reinforce what they love to do, and they will be willing to make the trade-off: you pay me to do what I love X% of the time, and I will put up with the 100-X% of the time I have to do stuff I don't necessarily like. 

I have only lately started allowing (and encouraging!) paired programming, and it is going very well. The kids enjoy it, and they appear to be learning the material with less pain. Not everyone has done it yet, however. This is where I am beginning to sense trouble. I have a difficult major programming lab coming up soon, and my students are psyched to work together on it. I know that many more of them will want to try pairing, but I worry about odd numbers, and I'm not sure how to handle three students who desire to work together without destroying the benefits that the model can provide. Is there any way to extend the model of driver and navigator to a trio? My current intention is for each group to create the same product, with no "splitting" of the work. One monitor, two students. Driver and navigator. These are good and responsible kids, and they can usually find quite productive groupings on their own, though I have no problem stepping in to assist in this if I see things headed in a poor direction. 

Note: Like the OP, I teach high school. Some of the things I discuss may not be useful in a university setting. Resubmissions are not a factor for me because I will take anything from any student at any time. And it must be correct. So they get 100%, or they get nothing. Wait before you shoot me. Timing: When I assign an exercise (program), I let my students know when it is due. I create the assignment in the grade book with its due date but leave it blank (we use PowerSchool as well, mentioned in another answer). As the students complete exercises, I check them off on a paper checklist. When the due date for a particular exercise arrives, I transfer checkmarks from my list to the grade book. If the student has a check, they get the points. If they don't have a check, they get a zero. To get a check, their code has to be correct. It must have the expected output. It must adhere to all coding conventions. And it must use the structure suggested in the assignment (e.g., a foreach loop instead of a bounded for loop). Of course, I allow for personal variation that is not blatantly incorrect. Coding is a creative process and each student develops their own style. I use zeroes in the grade book because it creates a sense of urgency in most students. But the zero is just a place holder, a reminder that something is missing. The student may, at any time, turn in their missing items, up until exam day. I clearly communicate what the zeroes mean to both students and parents at the beginning of the semester. My students actually like this method and give me positive feedback about it. I allow what some might call "late" work because not everyone works at the same pace. Some students are just going to struggle (and Carol Dweck suggests that the student who struggles may actually learn the material better in the long run than the student who gets it immediately). Not everyone has a wonderfully happy, supportive home life. Not everyone has a two-parent family. Not everyone feels accepted and affirmed at school. Not everyone is healthy all the time. I don't know what my students face when they leave my classroom. If they really want to do the work, I want to take it, no matter how long it takes them to complete it. Do some students abuse this? I don't have many who try. Students who care about their grades will work diligently to get work in no matter when it was "due". Students who don't care weren't going to turn it in anyway, due date or not. Even with this system, I would say 90% of my students turn in their work "on time". Cheating: My best defense against shared code is my familiarity with each student's coding abilities and style (or lack thereof!). When not actively teaching, I am circulating the room, interacting with my students, watching what they are doing - not in a hawkish way, but in an interested, encouraging way - "oh, you decided to add graphics to the assignment, that's cool". This way I can watch progress, help with errors I see before the student gets completely off track or wastes a bunch of time, or notice a student go from blank screen to complete multi-page solution - still highlighted from the clipboard - within one circulation of the room ("hmmm, where'd that come from"?). I can also gain insight as to how and why they do things, become familiar with their coding style, and nip bad habits in the bud. When I first started teaching, I thought if they were coding quietly and there were no questions, I should just sit at my desk and ignore them. Not anymore! I stay engaged and give them my full attention the entire class time. They deserve it, and it really makes my job much easier in the long run. (Honestly, a very good rolling chair helps with this. I have my lab set up so I can easily roll and achieve maximized, efficient coverage). Checking code: I don't ask students to submit code electronically. I check code for assignments with the student at their computer. Meaning we scroll through it together, with me asking questions as I see fit. If it's good, they get a check. If it is not, I tell them what to fix (or guide them to it), and they call me back again for a re-check. This works for me because a) I'm familiar with the way they do things and can almost immediately tell if they are showing me code they didn't write; b) I'm an extremely fast reader; and c) I make sure I have written a solution myself ahead of time so I know what I'm looking for. Note: If I really feel I need it, I already have an electronic copy of students' work because of the way our network is set up. Every student has a virtual drive. All student work is maintained on their virtual drive that only they can access when they are logged in at school. Yes they have a lab computer, but they are restricted from accessing the C:\ drive. Any projects they create (code or otherwise) are saved to the virtual drive. Teachers can access all students' drives. So I can access each student's work from my own computer. If I have academic dishonesty suspicions, it is easy enough to compare time stamps or file sizes between or among students and determine if sharing has occurred. Johnnie was missing 10 projects yesterday, but now he has them all, and every folder was created at the same time (when he unzipped his friend's work)? Nada. In summary, "resubmission" is not an issue for me. If my students did the work, and they want to give it to me, then I want to take it. 

In essence, you have two choices. You can embrace the quirks, or you can hand-wave them away. Embrace "Now, take a look at this code. What do you think it will do? Let's check it ou--- whoa! What in the world just happened? Turn to your neighbor and see if you can figure out what's going on." Give them a moment to get their thoughts outlined, and then have them come back, and together discuss what is actually happening. Dismiss "So, you may want to be careful to avoid doing X. For now, I recommend that you stick with Y. X isn't wrong, but it has some unexpectedly complex behaviors, and we don't have time to go into them. If you want to see for yourself when X is better, Google is absolutely available to you! For the purposes of our assignments, however, I can promise you that you won't need it to be successful." How to choose? The main characteristic that I use to choose when to do a deep dive and when to skip it is by looking at whether the deep dive will support the goals of my class. If it will give us a chance to practice using concepts that are important to the overall goals, then I will usually take the time to dive in. Otherwise, I will probably skip it. 

I'd like to introduce my students to Nodes and then require them to implement their own Linked Lists, Queues, and Stacks before showing them that their language (C#) provides implementations of these data structures. I suppose my motivation is that they will 1) understand better how these structures behave; 2) gain general language practice; and 3) appreciate libraries and be more motivated to search for an implementation before writing their own. Is my motivation valid? What are other reasons to ask them to implement these data structures? Is there any reason NOT to ask them to do this? Would I be wasting my and their time? 

If that's all they need to read, they can go from there. If they need to read further, then what follows in the same document is the step by step algorithm, but not code. If they get stuck in the algorithm, on, for example, a line that says: 

I am currently teaching my students about using induction to prove that algorithms function as intended. These are simple algorithms for which we can do fairly easy inductive proofs. Here are a few examples: Prove that will correctly compute the sum of all of the elements in . 

You're absolutely right that it is unreasonable to expect students to pay attention 100% of the time, so we have to provide enough "fix-up" clues and cues that they can find the lesson again after a moment of wandering attention. I usually avoid having the kids watch me code for two reasons. One is exactly the problem that you've described: if the code example gets large enough that it doesn't fit onto the screen, they can't get un-lost after a moment of flagging attention. The second is that passivity decreases engagement. I typically do active code-alongs (as described here). Besides engagement, one advantage of a code-along is that there are almost always kids who will type things wrong the first time, which also usually means that they have misunderstood something that you are describing. Those run-time errors that your students get while doing a linked-list code-along are one of the most valuable fruits of the lesson, and they allow you to point out important aspects of the code that your students may not have caught while you spoke. 

We all have them - students who want to write all the code themselves, who don't want to be part of a group project. They have poor social skills, or they don't know anyone else in the class, or they don't trust others, or they think other people "slow them down". So they go home after a group project is assigned, write all the code themselves, and bring it back to the first group meeting, completed. A typical situation is a group project done in a class or lab period over several days. The instructor or a lab assistant is present to watch over the students and give advice as needed. Different strategies might be needed if the project is done outside the view of faculty on the students' own time. This could also differentiate depending on whether the situation is the first occurrence (you are surprised by it), or if you are familiar with the Lone Ranger and know he or she has a history of going rogue. What are your practical ideas for preventing a student from taking over a group project, or dealing with it after it has occurred? 

During our year-end exit interviews with our outgoing seniors, the students made an explicit request to include some graph theory within our curriculum. This seems like an excellent idea, but the only place where we can fit it is in AP CS A1. Obviously, graph theory is not within the AP curriculum per se, but I wonder if there is some way to shoe-horn at least a bit of it into a lab somewhere. Even so, I am having trouble finding a spot within the AP curriculum. Obviously, AP CS A focuses a great deal on arrays, loops, and objects. There's not a heavy emphasis on recursion (though it is present). Is there somewhere where graph theory can find some kind of "fit" within an AP class? 1 I'm unable to find a clean, succinct list of topics covered in AP for those unfamiliar, but this teacher's site has a list of unit headings that could serve as a very quick overview. 

In my experience, there are always students who are resistant to moving to more advanced constructs. They want to stay with what they already know. For example, when they are taught arrays, they continue to use individual variables when they are able. When introduced to the foreach loop, they continue to use bounded for loops. When they learn about functions, they resist modularizing their code. After working extensively with arrays, they don’t want to move to using built-in collection types that offer more flexibility and behavior. It is sometimes difficult to impress upon beginning programmers the usefulness of “new” constructs, because the exercises and programs they are capable of undertaking do not sufficiently demonstrate the power and usefulness of those constructs. What are ways to encourage beginning programmers to embrace more advanced constructs without penalizing them? I am looking for more "carrot-y" answers than "stick-y". 

How to Design Programs is released under the MIT license, and has the distinct advantage of being integrated directly into DrRacket. This allows you to work through bite-sized chunks of Scheme, and gives you an easy tutorial-style way to follow the textbook as you explore the language. Within DrRacket, go to the Language Menu, and the Teaching Languages are in there. They each reflect portions of How to Design Programs. The instructions for utilizing the Teaching Languages are contained in the preface to the book. 

There's a clear progression among these answers, and they represent vastly different levels of understanding. Unfortunately, our topic requires students to be able to pull together many different concepts in order to do almost anything. If we were to grade by whether the answer fulfills the prompt, they would all receive the same grade. I actually have come to believe that, in a good rubric for a coding example, "actually produces the proper final output" should either not be present at all, or should be worth a miniscule amount of credit. A good rubric will capture attempts at portions of the algorithm, and successfully achieving steps of the algorithm. This example above may have been extreme, and I doubt if most teachers would award exactly the same grade to answer 4 as they would to answer 1, I this cognitive bias certainly exists (I possess it myself), and it seems perfectly plausible to me that examples 1 and 2 might receive almost identical grades. The trick to get out of bimodal thinking, then, is to break down the skills into smaller subskills, and break those down into further and further tiny understandings. This has two benefits: first, you see the clearer progression among your students, and two, head-scratchers like answer #1 become actionable, and you can see how to help the student to improve. Student #1 may never quite get to a complete picture during your class - he or she clearly has a lot to learn! - but it is unreasonable to the student (and to you) to demand basically 100% comprehension in order to avoid failure. And taking a partial understanding as a partial success shouldn't just apply to the student. It's the teacher's success, too.