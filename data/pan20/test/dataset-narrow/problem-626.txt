I'm pretty sure (though I haven't measured yet) that my version is a lot faster than the legacy one on one of the target platforms which doesn't have hardware floating point support. I'm also guessing that on the other platforms the actual speed difference will be negligible. What I'm more concerned about: Do I correctly detect all circumstances where the conversion result will be +/- Infinity (when the source is not) and where the conversion error ( so to say) will be more than ( in my example call above)? Apart from that, any other suggestions on how to improve my code? Other ways to get the job done without any floating point arithmetic? 

test your code You really should! Every (in an ideal world) piece of code that you write should be tested. You might want to look into TDD (test driven development) and build up good habits from the start. making it faster Do you really need to obtain the length of both strings? Take these two strings as example: 

This point is highly debatable though, so if that's just "your style" then feel free to ignore it ;) C style arrays are out of fashion Instead of 

I think you do this to clearly separate between local variables / function parameters / global variables and the data members of the class. I've done this, too. But I think it's a reasonable assumption to make that somebody reading your code knows that data members can be accessed without , and to know (at least roughly) the rules regarding name resolution. And, moreover, you already have something in place to distinguish between data members and "the rest": That prefix. I read that as ember, or alternatively as atrix. Having both just means more to type and more to read. And the long lines suffer somewhat from that "more". Compare: 

Note that this is the bare minimum of information we need out of a test case: An indication when it fails and which test case failed. Testing frameworks can give you far better information, for example a comparison of the expected value of a function call and it's actual value. Start with a simple case: 

only iterate once over the characters Instead of first going one time over the characters to filter out non alphabetic characters and adjust the case of the alphabetic ones and then a second time to count, do it in one loop: 

This code lies directly on the (most) critical path, and felt very inelegant (and wrong?) to me, so I tried to improve it. Note that I don't intend to replicate the exact same behavior as the legacy code. 

How often do you need to mutate the initial value? Not a single time, of course! There's only one element which should take the initial value. Is this a real issue? I think so. Consider this example to generate all powers of two which can be stored in an : 

You can also go one step further and use , possibly making use of execution policies when (if) you switch to C++17. Getting rid of more "manual" loops Using you can get rid of more of these manual indexing loops: 

English please! Identifiers and comments reallly really should be in English for all code you write. Otherwise it will be hard to impossible to take part in the completely globalized IT world we're living in. Break long lines Your lines shouldn't be longer than 79 characters. Break them before binary operators: 

Be as precise as necessary when describing things. Generalize ("containers") when it helps to make things more clear. But don't say wrong things. These are no arrays, these are sets. Accessing the sets based on their content type. 

According to the above specification you accept elements of type ... What would you expect to be the result on these arrays: 

Of course you can also make an (template) member function of a class containing a named and drop the parameter. Your is then: 

You could make your code more general (as in usable for more than one single list instance) if you pass (a pointer to) such a head pointer in to your functions. Use blocks 

The fact that this set contains "tickables" is encoded twice in the line above: The type of that contains the type and the name (informally) tells us the same. While accessing this set as is a good and very readable option, this does not lend itself to template programming that much, because the compiler doesn't understand "tickables". It's just another identifier, the meaning (that we humans are able to understand) is lost. Thus I suggest accessing your sets like . This is still readable to us, but also provides information for the compiler about the content of the set. To be able to pull this off I wrap the sets in a helper struct: 

Note that this is not (entirely) "your fault" ... Probably the one writing the specification didn't even think about negative numbers here. Which is why you should always make sure there's no ambiguity in a specification / task statement handed to you. If you can't "re-negotiate" like in this case of some online coding task, then at least check that the assumptions you made hold up, e.g. by checking whether all (or just the smallest) numbers are actually positive. 

Here you call , discard its result (return value) and then call it again, this time assigning the result to the local variable. separate calculation and output Instead of 

Some thoughts: choose good names is IMO a bit "generic". Perhaps something more expressive like ? Moreover, the inner function's parameter is named , but it's actually not some count (number) but a text string. Furthermore you're using the term "sentence", but you're not actually requiring sentences, but rather character sequences / strings. don't call the function twice 

You could also solve this by accepting non-const references, though I'm not sure whether that's really better. (Accepting the function object by value does not solve the issue because then any changes to the internal state cannot be transferred "back up" the call chain or past "major" iterations of the top level loop.) 

You don't compare strings for equality. You (try to) compare their lengths. Also, your comments should explain why you wrote the code the way you did. Don't tell what the code is doing. With well written code that should be self apparent. do one thing per function calculates the length of two strings (code duplication!) and then compares these. That's too much. Delegate that length calculation to another function: . Or - for learning purpose only - write your own replacement. vs Wondered why returns a instead of a ? That's because a string might be longer than the maximum difference that can be represented by . Thus may actually be undefined behavior when done with really long strings. Better keep a that you increase while searching for the . program output should end with a This is only minor, but otherwise it may corrupt the controlling terminal a bit. Or like in ideone drop the output completely. 

but for consistency I would expect the result to be a list of two elements, the first being the part that was split off, the second being the rest of the list. Thus I'd expect a result like this: 

Test, test, test! Next, I'd like to introduce you to TDD (test driven development): Instead of first writing your code and then test it (as all - or almost all - code should be tested!) you start off writing tests, specifying the desired behavior, and then make these tests pass by actually implementing the logic to achieve that behavior. Normally, you'd look into some testing framework / library, but we can go with a simple macro here for now: 

Public interface I wouldn't expose the argument to the public. It is simply not meant for the user of the function to be used in any way. Thus, I'd use to define an "inner" function inside of . Don't . and then When you to a list, then that list needs to be fully traversed. Moreover, creates a new list, creating significant garbage since you don't need the lists passed to it anymore after the call. Same structure of return value When I run your split with 

Whether that's better in terms of readability is ... eh ... let's say "debatable", too. And of course it changes semantics: and are now used, instead of . Instead you could also keep the manual indexing, but make sure you run over the correct range: 

Oh, and I like indexing with as that's what's returned from the various member functions and may protect you from fallacies with the "usual arithmetic conversions" between unsigned and signed integer types. And of course when dealing with large amounts of data, might be too narrow to hold possible indices. But of course, this doesn't apply here. can be dangerous, better avoid it Instead of you could use the C++ (almost) equivalent . is a bad idea when using anything but plain old data types, and even then I'm not sure whether aliasing (and in the future also "laundering" or lack thereof) could still cause undefined behavior. Thus I recommend to avoid it. DRY using the evil preprocessor The definitions of , and the two are almost identical. You can use a macro to save you from that repetition: 

You use blank lines to separate parts of . I wouldn't here, because it hurts readability IMO too much. Function names 

For further information on why you want this see this SO question as well as the top answer to this one (but don't get confused about it's incorrect references to the points in the question). Going further, the best approach is to use as deduplicator suggested. The standard describes its effects as "" (where and are the parameters of ) and further imposes the "swappable" requirements, which state: 

This also shows one thing I'd consider an error in your code ... off by one Yes, it will do one superfluous mutation. Consider this example: 

(No tests?) Try to test your code as early as possible. Even more, at least according to TDD, you should write your tests first. I'm still looking for the object orientation I was promised ... Sorry to be the elephant in the room, but I don't see much of an object oriented design here. It's more like wrapping all the code in methods of some arbitrary classes. Let me try to explain: 

test corner cases Does your function work well with an empty string? A string with only vowels or consonants? A string with only punctuation? 

The first is the template definition that will be used when the template specialization (the second definition above) doesn't match, i.e. when there's no (more) content: . The specialization inherits from the previously defined wrapper (and thus gets a member of type ) and also inherits from a variation of its own type with the "removed". Accessing the sets is now almost trivial: 

Apart from this PEP rule, IMO function names should reflect what is being done, i.e. an action. Thus not but rather , not but . Comments 

You're wasting an opportunity for some useful testing output: For example, you could print something like . If you want to "beef it up" further, then keep a line / instruction count and output that as well. 

This hard codes as the function to use for swapping. C++ also has a powerful (and sometimes confusing) mechanism to allow multiple namespaces to be searched for a function: argument dependent lookup (ADL). To make use of it call swap unqualified, which performs ADL to find functions in the namespaces of the arguments, but also add as a "fallback": 

Why? As you already noticed, this is a lot of boilerplate code ... but for what improvement? Further, why do you need a type inferring and a non-inferring version of each of your function objects? and lambdas Do you know ? Basically it does what you want: Assign the results of successive function calls (which potentially mutate the function object) to the elements of some range. So, if you want it dead simple, consider this: 

Don't recur, iterate. Common Lisp has no guarantee for tail call optimization. Thus recursion might get expensive even if the recursive calls are in tail call position. To avoid this you can write your code in an iterative manner, e.g. using . 

The result of this expression is a (§6.5.6/9). Assigning it back to a pointer converts an integer type to a pointer, which IIRC should give you a compiler warning as it can lead to all kind of trouble. relational operators with pointers Comparing pointers with relative operators is undefined behavior if the pointers don't point into the same array (§6.5.8/5). 

This means one or more sentences! Why? Because they should explain why you wrote something the way you did, not what the code is doing!. Generally speaking your comments don't help in any way, they just hurt readability. Better remove them! It's important to make your code so readable that you don't need a comment to tell the reader what the code does. Enumerations Since Python 3.4 there's support for enumerations, which is exactly what this is: 

... you're creating a copy of every smart pointer in the set. This is not as bad as making a copy of the s, but it still degrades performance: Every time a smart pointer is created it needs to increment the reference counter, and on every destruction it decrements it again. Better add a reference to avoid those copies: 

The lambda returned by above function cannot be used with your unroller. To fix it (as a user of your unroller), you need another (non-mutable) lambda which references the original one: 

Handling of special values Ignoring for now, that the choice of returning a special value instead of throwing an exception (or using some other means of indicating error) when ing from an empty queue isn't that great. Then, if you have a special value ("magic value") like which will be returned on an empty queue, then it's crucial that you cannot push this value into the queue. So check for that in and . Useful testing 

This only holds a single set (with a single content type). I generalize to multiple content types (and multiple sets) via variable template arguments: 

All in all I really like your code. It's good and easy to read, and there's nothing really wrong with it AFAICS. In the following I'm writing down whatever's coming to my mind what could theoretically be improved/changed. Therefore don't take that as a list of things to change, but rather as points to think about. 

Don't. Of what use is ? This class is just a collection of functions. It serves no real purpose: It doesn't really bring any data and logic together. All it does is needlessly limit the access to the data structure with your records. In other words: It doesn't protect any(*) invariants. Why hide the in it? (*): Actually it does, of course, but I'm relatively sure that's not needed: You cannot add, sort, remove, ... any records. I'd guess this is what your instructor meant with the Java-ish comment. (Because in Java, everything needs to be inside some class). My suggestion; implement the following "interface" (as free functions): 

When you start at the first of each of those, at how many s do you need to look to determine which string is longer? 

You do not check whether allocation succeeded. Thus the next line will probably result in a crash in case returned . But it could also continue to seem to be working, failing at a potentially completely unrelated point in your program. That's the problem with undefined behavior. Thus, if you want an allocation failure to be a fatal failure, then you have to actually code such a failure mode: 

Ok, we can go on with these .. but this starts to look like a lookup table to me, so better implement that instead: 

This looks strange to me. First of all the (a typo? This shouldn't even compile.). But especially since your has the same content. So ...