When I first read chapter 3, Algorithm Analysis, I basically said to myself, "Yeah, I got that." After all, I'd been programming for a while, and I had a good sense about how complex an algorithm was, and didn't need any formal notation, or explanation for it. Later, after it had percolated through my brain for a while, I realized that it was rather handy to have a way to explain to others, including customers and managers, why doing it this way would take more time, even if it saved disk space, or, on the other hand, why that way was doing the job fast, but the disk access was the bottleneck in program speed. All I could remember from the first breeze through the chapter was that it had a lot of mathematics involved, including things like $O(n log n)$, $T(n)=O(f(n))$, and such. I knew I'd seen at least one $\sum_{i=0}^n = yada + yada$ type expression in there somewhere as well. Never having studied Calculus I was rather intimidated by the thought of all that math. (I like math pretty well, and I also know what I don't know.) Still, I had the book and I had the time, so it couldn't hurt to go back and study that chapter again. On the second reading I realized that while there was math involved, there wasn't really any math performed. Rather the concepts of math were used to explain what was being analyzed and how that affected teh growth rate. The concepts were important, but never once did an equation need to be solved. Furthermore, just in case the student did not understand the relationships between $10n$, $n log n$, $n^2$, $2^n$, and $n!$ the author included graphs and tables. 

Doing the same thing with multiplication for is easier, if they understand that anything multiplied by zero is zero. If they do not have that concept mastered, then it can become more difficult. Finding a demonstration for that can be dicey, but it is possible. One option could be to use unit pricing. Say it costs 8 dollars (or your local currency) for a pizza. if you get one pizza, that's . If you get four pizzas, that's . Now, if you get no pizzas, that's the same as zero pizzas, so The answer, of course, is nothing. What if the price of pizza goes up to 12 dollars, how much for no pizzas? ; still. No matter how much pizza costs, the total price for zero pizzas is zero dollars. Anything else could be used instead, such as speed and time for distance, or wage rate and hours for pay checks, etc. With the multiplication by zero concept under control, it's time to connect with multiplication. Using the same three setups from above gets three samples of the conversion. , . Converting to symbols gives us , , and . You can expand that into the distributive property, if you wish. [Again, the rule of only two values comes into play with the operator.] 

Operating on the key word, motivate, I do believe that Andrew T. had the best choice with Tower of Hanoi. Yes, it's an old one, and it does not lead to anything useful once it's done, (the code is not reusable for some other "real world" problem.) Yet it remains a classic for some reason. I'm going to speculate that the reason is that when presented properly it motivates the students to think about using recursion for other purposes. As to what the motivation is - simple: less work! AKA - unmitigated self-interest. Who doesn't like the idea of getting something done fast and easy, preferring instead to do it the long and hard way while getting the exact same results? That suggests that the motivation comes from the presentation, not from the example used. With the Tower of Hanoi example, adding in the "legend" of the back story can help with interest, but it can also be a waste of classroom time. Using the legend, or not, is a judgment call for your class and your style. (I have encountered at least three versions of the legend, and I am partial to the version that mentions the walls of the temple crumbling into dust and the world vanishing.) The key to the presentation is to begin with solving it using an iterative approach. Preferably even before you raise the idea of recursion, leaving the alternative as a way out of the maze later. In a comment, Eric Lippert states that it is easier to solve with an iterative algorithm using these steps and rules: "number the disks in order of size; never move a larger disk onto a smaller disk, never move an odd disk onto an odd disk or an even disk onto an even disk, and never move the same disk twice in a row." That sounds good, and you can present it, just as given, in the classroom. Before trying to code it, however, give it a try physically. Using that rule-set with 5 disks I get the following: 

In Java: Don't In programming language X: Don't Treat Regular Expression as its own language. Teach regex in a language-agnostic fashion using tools that process regular expressions rather than trying to teach regular expressions and their implementation in Java, or any other language. Each language has its own, idiosyncratic, engine and method of use. Different engines implement subsets of the entirety of the regular expression specifications. As a starting point, use an online version of a regular expression editor. There are two fairly good versions that I'm aware of. First is Regex101, which has a decent IDE style interface, including an live explanation of the current expression, and a token list to choose from. The one feature I like is that it allows you to "Save & Share" the expression, which adds it to a library of expressions available to others. Of course, that library is also available to you, so you can try to find one that's already written to do what you need. One major issue I have with this site is that it still does not implement the entire specification of regular expressions. Specifically, it does not handle If-Then-Else conditionals: and . A second site, which will handle the If-Then-Else conditionals, is Regex Storm. This one produces a nice set of tables for the "output" of the expression, but lacks the collection of tokens, and library of expressions of Regex101. As near as I have been able to determine, this editor implements the entire set of regular expressions available in all engines extant, including left-to-right text. There is also an extensive reference on this site that can be terse at times, but does include examples for most of the complex, or potentially confusing, constructs. After selecting the editor to use, local, online, etc., the problem now becomes how to work through the "language" of regex. I don't like to reinvent the wheel. Therefore, the best option I can think of is to follow the outline of the regex tutorial built in to Perl, "perlretut", which should be available from any complete Perl install by typing on the command line. Perl.org's documentation also has it online in HTML for all to use. Granted, all the samples there are given in the context of use within Perl, so they need to be converted for your classroom use. The idea isn't to, necessarily, use their examples, as to follow the sequence they have created. They've invented the wheel, now you get to design the rims and hub caps so that the vehicle you need is "road ready." To cover the very basic outline, below is the relevant sections from the Table of Contents for . For the "died-in-the-wool" purists, it even begins with the inexplicably obligatory "Hello World" of program language instruction. 

All things that demonstrate some subset of their skills, but don't require writing a complete program. Bonus for them: If they choose a career in code, is that they'll find a lot of their professional time is spent doing similar tasks. Teams might make a program, but each coder only does a part. Bonuses for you: You can see what concepts seem to have been the hardest to implement and can adjust your syllabus for the next term. The scope of each problem is small enough that you can grade them, collectively, faster than trying to evaluate an entire program, which will of necessity contain lots of standard code that's really boiler plate - such as the includes. Problems for you: You have to decide what concepts to test where, and you have to create new questions every term that still test the same concepts. 

One of the first principle to realize is that the students are not only learning from what you teach, they are also learning from what you do. They won't buy into a practice that you aren't following yourself. Would you purchase a Lincoln Towncar from a salesman that drives a Honda CRV to work every day? Your students are watching you, and they are evaluating you. Use that to enhance the lessons, not diminish them. Every time you produce "throw-away" code in demonstrations, problems, or handouts, make sure that you have followed whatever "best practices" you are trying to get them to follow. Then, don't make them create "throw-away" code. It might be the next lesson, it might not be for two weeks farther into the term, but as much as possible have the code created in one lesson be applied or modified in a later lesson. Emphasize your set of best practices early on, and help them understand them with code reviews on the earliest assignments that focus on those practices. For later assignments, place less emphasis on the review of best practices, and more on the code itself. Not knowing the language, and course objectives, I can't layout a definitive plan for the scaffolding. I'm sure that if you work backwards from the larger projects, you can design smaller projects that cover the earlier material that can end up in the finished version of the large one(s). If the students have enough time, and new material, between writing, and then reusing a program, they will see the benefits of best practices. Either from the hard work of rediscovering what the old ones do, or being able to easily see what they do from reading them if they did use best practices earlier. Of course, if they get to see other students' work, or have to figure out what other code does without best practices, that helps. Having to reuse their own code (when they think I'll always know what this does) will drive the point home in a firm, and memorable way. Summary