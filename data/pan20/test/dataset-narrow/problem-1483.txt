My attitude to this question (which I have often been asked) is radically different to the other answers. I've been involved in recruitment and selection of students for Computer Science degree programs for over 30 years (in one way and another). Parents, potential applicants and their teachers often ask "what feature of an applicants profile indicates their potential..?", which is quite similar to your question. They expect me to say something about their coding skills, or even computer gaming aptitude. No; we rarely look at that. To me there are other very good indicators of a mind set that is successful at Computing and will enjoy it. The classic indicator is Mathematics, but on its own it is a poor discriminator. I found that better indicators were musicianship and modern languages. Being fluent at more than one language and having skills at sight reading music and playing that instrument with others can be an indicator that they may excel at Computing. This combined with enjoying the structure of non-computer games (board games or Role-Playing) also are positive signs. As also noted, puzzle and problem solving is also a good sign. Why do I think this is so? It is the issue of reading a coded notation at speed, as one does in music, develops the mind to handle computer code as another form of instruction notation. The combining this with manual dexterity, as in performance also helps. Understanding that the music notation expresses the communication of the desire from one human to another is so similar to the function of computer code. This analogue also applies to other modern languages; someone who has to translate between languages appreciates the difficulty in expressing meaning in a different notation for others to act on. Why non-computer games? It is because of the reading and understanding of the rules that is required to understand the play. If they can absorb and mentally model the multi-tome rule sets to some of these games then they can read and mentally model large enough chunks of computer code to be successful. I could add more detailed analysis, but I will leave it at that for now. 

There's no "may" about it. With brief training they will be able to offer positive comments as well as negative ones, but to give constructive advice they need to know what they're talking about. For example, anyone can tell you "I couldn't follow the thread", but to suggest specific structural changes you need to know the broad types of structure which could have been used. There are various organisations which are dedicated to training in public speaking: Dale Carnegie and Toastmasters being perhaps the best known. (Disclaimer: I'm a member of Toastmasters and have previously held various offices in my local club, so I'm not unbiased). You could look at their approaches, and if you have a branch of such an organisation in your city (or even in your school/university) you could see whether they'd be interested in helping out. Speaking from the Toastmasters perspective, there are one or two projects which people on the leadership track can complete by running a training session with a recruitment plug: you may or may not consider that appropriate for your setting. In addition, particularly if there's a club in your school/university, you might be able to get a couple of members to come along to a lesson on the basis that one of them gives a speech for evaluation, your students offer their feedback, and then the other gives an evaluation which confirms or corrects the students' feedback. (If necessary, explain that the rules allow one project in five to be done outside club meetings provided that another member is present and gives a written evaluation. I haven't seen this option used much, so the members of your local club might not be aware of it). The good thing about this is that someone who's done a few projects in Toastmasters will be used to being evaluated by people with differing levels of experience, and being a volunteer will find it less stressful than your students. That way they can learn to give feedback without destroying their peers' confidence. The second visitor will also (I hope!) demonstrate how to give suggestions for improvement sandwiched between affirmation of positive observations in order to (quoting the title of the manual) "evaluate to motivate". Since you probably won't have volunteers to come to every lesson for several weeks in a row, this might be best saved as a final practice before getting into real peer evaluation. You could build up to it with a series of lessons in which you teach a specific skill (speech structure, body language, word choice and sentence structure, visual aids, ...), watch a video (maybe a talk from TED, Ignite, or something similar), and then ask the class to give feedback. 

I have been responsible for using performing and evaluating tools for detecting software plagiarism in my academic department. There are several published review articles in the scholarly journals. One such report Culwin, MacLeod & Lancaster, 2001, UK JISC, "Source Code Plagiarism in UK HE Computing Schools, Issues, Attitudes and Tools" gives an overview. Basically, there are published algorithms and methodologies you could implement yourself, open source software you can run locally, or an internet based service you can register and use. One such tool that you can run locally is JPLAG from the University of Karlsruhe in Germany. This has several language syntax implemented, and as it is open source you can amend as desired. The best online tool is MOSS from Stanford which is the one I ended up using. If you wanted to research the various published techniques for detection, Google Scholar is a good source. 

One technique we use is to work and present in groups. We give them guidance that different members of the team have different strengths and they all do not need to present. Some of the team can research, some create the presentation material and some can present. Those who are not presenting do not have to leave their classroom seat. Alternatively the time can be divided and each can have a small number of minutes and they can share the presentations. This way the less confident can play their strengths. I am an advocate of students with special needs, and in my experience they are less uncommon in computing classes than one might imagine, particularly in higher education. (Big Bang Theory citation perhaps). One should also see the "Imitation Game" to note how Alan Turing was portrayed; certainly "on the spectrum" in my view. This means a class can have some shy and reserved students but also some at the more extreme end with more extreme or radical responses public speaking situations. Some may be diagnosed but, in my experience, many have not yet been diagnosed and have managed to hide in the crowd so far. We have some very social phobic students, and the method of starting with group presentations allows them to participate without triggering their fear factors. We also find they end up contributing a bit more than they expected by the time of the final assessment, and over a period of a three year degree programme we can find ways for them to overcome or work with their particular issues. One of the ways we might use to help them present is to have the more senior students make their own videos, which can just be screen captures with voiceover (but often much more). We also find this eases them into making good presentational material. They then present by playing part of their video and just adding minor interjections and perhaps answering questions instead of the full blown "stand-up and talk". In conclusion, I wanted to illustrate that extreme social phobia is not unknown in our subject and we should be prepared to cope with it with innovative and inclusive techniques. I am wary that these problems can be solved by a single teacher in a single class just getting the shy ones to be brave, so wanted to speak up! 

As with the human languages, there are multiple programming languages. To develop in a certain language you usually write (text) files containing the instructions (you could now mention how this looks in a programming language you like). These text files are read and executed by the computer. Depending on whether the language is low- or high-level, the computer might need additional software (the interpreter) to understand the language. Often, developers use so called IDEs which make development easier as they offer hepful features (for example, automatically creating instruction(s) you normally use a lot or immediately pointing out errors). 

I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: 

What are the objects? You've sketched a database table definition and a visualisation, but I don't see a sketch of the application program's structures. As far as I can see, all of the additional information in the visualisation can be made available in a purely relational database view. I've done this kind of hierarchy visualisation with CTEs. 

These are very different situations. As you observe, the use of in C# is controversial, but using as the type of all variables (and then needing to cast any time you want to actually use the variable) is not controversial: it's just wrong. The first page of answers on the linked SO question about in C# is incomplete. It doesn't mention that using can avoid bugs due to typing in one edge case: vs . For legacy reasons, if is a but not a the latter is equivalent to , which is not especially obvious. (In fact I misremembered and was corrected in comments, which reinforces the advantage of using here). TL;DR: blanket prohibitions on are almost certainly going too far. 

Most of the maths in undergraduate CS is proof by structural induction (and we do at least in part deserve the reputation we have among mathematicians of not knowing that there are other proof techniques). That technique apart, the "non-CS" maths can be more than covered by chapters 2 and 4 of Concrete Mathematics, Graham, Knuth, and Patashnik, ISBN: 0-201-55802-5. This book contains many exercises and solutions thereof, or hints in the case of unsolved problems. There are PDFs available online, but I'm not sure whether they're authorised so I won't link to any. 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

I think whether and when the test cases should be released depends on a few factors. Not releasing the test cases You say that the assignments were only partially assessed by the unit tests, so in my understanding this means that there is somebody having a look at the source code. If (and only if) the assessment was fully automated and there were no human beings looking at the source code, you should not release the test cases before the assignment as otherwise it would be possible that somebody just created a program that has the required outputs for the test cases hard-coded and chooses the right one (using some kind of map or dictionary) depending on the input. If you plan to put the same (auto-graded) assignment again on students in e.g. multiple courses, you might also want to avoid releasing the test cases after the assignment - otherwise students that have completed the assignment could be able to hand the required test cases through to the students that haven't yet completed the assignment. If you however change the unit tests for an auto-graded system after releasing them (i.e. each course has it's own set of unit tests for the same task), then you could release them after the assignment. Releasing the test cases before the assignment I can imagine a situation where it's neccessary to release the test cases and to do this before the assignment: If you're doing test-driven development. In this case having all the unit tests available to everybody would be essential as otherwise the whole strategy wouldn't work. Furthermore, the test cases could help students as they are examples of the program's in- and output if they have trouble understanding the specification (as specifications can benefit from examples). I would even go further and would recommend you to release the test cases before the assignment in almost any case unless you have specific reasons against it. Releasing it after the assignment This could be an option if you want the students to figure out the algorithm without having examples (not sure when this is required, but maybe there are some sort of tasks that require that) but you want them to give a chance to review their mistakes after the assignment is done. I would always try to release them at the latest when the assignment is done. 

is far from the only controversial subject in programming praxis. The solution in industry is the style guide: whether as a formal written document or as an informal internalised set of opinions which are imparted to new team members by word of mouth when they submit changes which violate the house style. If you're explicitly preparing your students for industry, it is perfectly reasonable to dedicate a bit of time to explaining the concept of the house style, and then when you introduce new material to explain the house style you will enforce for that feature. The really heavy-duty approach would be to prepare a full industry-style style guide and then to produce a series of increasingly large subsets so that every couple of weeks you can give them a link to an updated style document which specifies how to use the new features you just introduced, or the new features you're about to introduce, and highlights the additions from the previous one. 

Re too broad: I don't think the question necessarily is, but "Azure" is. I think you could spend an entire 5-hour session just listing Azure services without going into any detail on any of them (and in evidence of that I've been to a two-day MS training course on Azure which only managed to scrape the surface of less than 5% of the available services: it was more a starting point for research back in the office than training. And that was aimed at experienced developers). IMO pricing considerations should be a small subsection of "Why cloud?". People signing up for a workshop, and especially if it's part of a technology club, expect to be doing hands-on practical training, and (excepting the introduction/overview) for the teaching to be geared towards the specific things they will be putting into practice. They can read price lists at home. With regards putting into practice, are they going to be working on a project which you define or bringing their own ideas to the table? If the latter, I'm not seeing where exactly you brief them on the right kind of project for the specific services you're going to cover. Or are you intending to choose the two or three data services which are the best fit for the majority of the projects after talking to the participants about what they're trying to build? But then point 3 looks like PAAS and point 4 like IAAS, so maybe they're going to be working on different projects in the different sections? 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

1 After reading through your question another time, I guess I've misunderstood the question and you only asked for a solution for the first item in my list. I think I will nevertheless share my thoughts on both - maybe they can be helpful for you or any future visitor. 

Why should you try to teach every interested student and assist them in reaching their different personal goals? I think you've already given the answer in your question: Because each of them is genuinely interested in learning something. In my opinion, one of the wonderful things about schools is that they are designed to be places where knowledge is spread. People who already know something about a topic (often these people are the teachers, but even this doesn't have to be the case every time) share their knowledge with people who want to gain knowledge about this topic (usually the students). In reality, this principle is sometimes hard to encounter: As there are usually a lot of required courses in most school systems, you'll always have students who aren't interested in learning something, but are just forced to attend. Still, as I want to focus on the idealism here, I think the reason why teachers should try to teach everyone who is interested is because teaching every interested person is the primary objective of a school. When discussing this question with some others, it might be good to reach a consensus on the level of the discussion: I could imagine that somebody argues with you about this question assuming you are talking about a given, realistic situation and wants to convince you that in certain situations it's (as you also already stated) just not possible or incredibly difficult to teach everybody.