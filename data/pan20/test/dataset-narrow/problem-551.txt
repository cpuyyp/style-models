Event if you want it in global scope. Use strict mode All beginners should have as the very first line of any javascript 

I have read the comment that this is a bit of copied code, which is far enough, why rewrite what is already done. You just happened to pick a rather odd code snippet. The author knew enough to be fancy but not enough to be smart. The is a short cut method for ensuring a value is an integer though would do the same. The in the second for statement means he did not have to add . The i is evaluated to true or false and if true then 1 is subtracted and the loop statements run. In reality it should be a while loop. But the worst part is that it is adding elements to an array from top down. This can result in the creation of a sparse array. Sparse arrays are significantly less efficient than a normal arrays. ALWAYS add to an array from the bottom up. Note that in javascript we have array like objects and this function is to convert from array like to array. If copying from an array 

Problem I am sorting an array of objects. Each element may have a property called or it may be . When defined, it is a user-provided string (which is why I use ). If the is not available, that element's relative position in the final list is irrelevant save that all blank references must appear grouped together at the end. Implementation 

Sync up with origin (we have only one), Figure out which branches have been merged into (or, optionally, a different branch, so far nobody has used that), Delete locally-merged branches, Optionally run the gc 

I have implemented the following jQuery (fragment) to clone each 'timesheet row' along with the tags, which are not caught by : 

I'm designing a small intranet-based time-tracking web app that accepts an unknown number of data "rows" which each consist of 7 form fields. Rows can by dynamically added by the browser. Can I do better? Given this (partial) example POST data: 

Background My team develops in a git monorepo. User stories are broken into very small discrete sub-tasks and merged directly into , rather than into a feature branch for the story. Topic branches Our topic branch names are all of the form . Those are pushed to origin and merged via a code-reviewed pull-request process. Release branches We also maintain long-lived release branches named used for hot-patching. Release branches are never re-merged to . The individual fixes, if relevant in the current release, are re-implemented in another branch or applied as a patch. There are few enough of them to manage manually. Work This works well for us, but it means we have hundreds of topic branches hanging around as developers often forget to delete them as they go. I wrote a simple bash script to 

Case 1 For case 1 you should avoid adding to the prototype, as you can not trust it. Someone else may have already added that name to the prototype and you clobber their code, or they may run after you and they clobber yours. If you must do it, first check 

Solution Using ms it is then just a matter of stepping over each day until the conditions of the search are met. In this case you want days of the weeks that start in the current month, a inner loop iterated the week days (day 0 to 6) only while the outer loop has the week's starting month the same as the current week's staring month. The results are just pushed to the array as they are found. The function 

25,793µs ±1,853µs. Using strings 30,418µs ±1,346µs. Using arrays and array.join 79,534µs ±1,142µs. Your code 

Though much the same as the first answer this is a little more minimalistic. Note that there is no need to specify (or ). The terminator is added by default in the function Also there is only one variable thus no need to set the new top after the function, as the top is used to move the items up the list and ends up at the top automatically. Also you can collapse two lines to one as you already have top you just need its thus can be shortened to 

You've got a nice idea, planning for extensibility. There is one issue that I see with the way you've implemented it. 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

Is this an efficient way of solving this problem in terms of time? I'm currently iterating over the initial array twice. Is there an elegant ES6 way to do this in a single pass that I'm not seeing? I believe memory to be less of a concern (because I exactly double the amount of memory used while processing by generating two new arrays that together are the size of the original); am I correct? Are there any scalability pitfalls doing it this way? As usual, any other comments are welcome. 

In general, is this iteration pattern safe and sensible? is a drop-down, is validated and will always be filled. 

The verbose prompting at every stage is intentional as reassurance. Concerns Primarily, is this "safe", meaning: 

Have I used an appropriate method to list branches? Have I used an appropriate method for deleting branches? Have I accounted for all possible pathways that could result in destruction of a local branch? Have I adequately guarded against destruction of a local branch not merged into ? Should I verify that topic branches have been merged into origin's and not the local , in the event that a user mistakenly merges locally and loses their branch? 

Alternate Implementation Another alternative, which is arguably simpler, is to implement this as a case class with function arguments. This implementation is exactly equivalent to the refactored version above, and is arguably simpler and easier to use. 

Along those same lines, became because that's really what it does. I also moved the helper functions into 's companion object. It's a good default organization strategy. itself had mostly structural changes. I changed the visibility of , so that mutating it has to pass through the helpers. It also became a Set, as the OS doesn't generally make guarantees about listing order, so I wanted to avoid implying that the order was something that could be relied on not to change. became just and passes a defensive copy of the internal set. That gives us this final version, with a small driver to make testing easier. 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

Your code would overwrite any global scoped variables, and is completely unsafe for general use. If on the other hand you had bound a specific object to the function to isolate the variables from the global or containing scope then you still have some problems. General issues The function needs to return if any 2 of the array's numbers add up to sum. In the loop you check for the match and set a flag. But the condition has been meet, there is no need to check for any more matched. You should return true at the first match, this saves CPU cycles and memory. 

That should do it Wow that was a lot. I better stop now. If you have question please do ask. The suggestions are not the only way to do things. If you find that it becomes too complex then it is better to do what you feel comfortable in rather than create something you find difficult to manage. Don't get caught up with Best practice, it is the user that comes first, and as long as they are happy you get to program another day... ;) 

Summing up. You need to ensure that you test as many possible inputs to a function as possible. Don't cherry pick inputs (as you did with the function) that you know will work. The aim of testing a function is to find out if you can break it. 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

Much simpler. Premature Optimizations If you ever have enough members in a room for the optimization to gain you anything, you'll probably be exceeding the length of the Mongodb query. This needlessly complicates your code. Ironically, any gains are lost when you forgot to use rather than , which needs to iterate through the lists you just made to avoid iterating through the lists. It looks like the accessors for the attributes already return values, so this can be much more readably rendered like this: 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version