All other things being equal, I don't see why not as long as you realize the side effects of the decisions you're making, and can balance the game appropriately given that certain players won't abide by self imposed rules of "cheapness". 

Ignoring the "menu" part of it (it's the same as any other UI element), for iOS games specifically you can use the built-in NSUserDefaults class to store key-value pair of settings. 

The question really isn't "what stats to track", but should be thought about in terms of "what problems might come up". As an example: 

This is more just a general programming question, and in general all of these kinds of questions boil down to subjective decisions on your part given that there are pros and cons of any given approach. But in general, your idea isn't necessarily a good one given that all you're really doing is making those objects globals. Global accessibility might mean you don't have to pass them around as much (possibly making your life easier), but it also means you might be inclined to make "sloppy" architecture decisions (which will make your life harder when/if you get around to refactoring). You should be striving to encapsulate as much as possible in one section of the code base to reduce dependencies and so on. Just look up any of hundreds of articles on whether or not you should make things global and you'll find a lot more on the subject matter. 

BioShock had several levels with pretty fancy water effects. Don't know how much that actually affected the gameplay, though. 

The usual way to do this is to use a RenderTexture. You point the camera to a render texture target and that texture updates with whatever the camera sees. This requires Unity Pro. There is an example project here: $URL$ Barring that, you can set up the second camera to render to a portion of the screen using the parameter and set it to a higher so it renders in that corner of the screen and after the primary camera. See the reference here: $URL$ 

Does this mean your code isn't doing what you think it should be doing or do you have some feature that you need to implement that you don't know how or do you want advice on what feature to implement next? Either way... 

How you synchronize the games is going to be very different from game to game. You just need to figure out what both clients are going to need to send across, package that up, and send it. There are some turn-based game helpers in iOS 5 that you can use to send messages back and forth. 

The way Unity does it, is that all components are contained by the GameObject itself. Components don't "contain" other components, but they can have references to them. 

It really depends on your art style. Does the game look fine scaled down halfway? Would making new, lower-res artwork push you over the current OTA download size? If so, then keep the larger graphics. There are not a lot of people with 3GSs and 3rd gen iPod touches out there (the only currently supported non-retina small devices), and with iOS 6 the 3rd gen touch isn't going to be supported any more either. 

If your character has a forward vector, you can just use that to set the rotation of the bullet vector as well as the velocity (by multiplying forward * speed). 

I don't think there really is a way to answer your questions. Personally I think it's too broad a topic to really talk about. 

You're calling animation.Play with the wrong argument types. $URL$ The second parameter is a , not a . 

You can't really not support the 3G without also removing support for the 2nd gen touch (by making the app only run on armv7-supporting devices, for example). From the analytics from a game we recently released those users are a minority but still a decent percentage of our users. The answer to your question, like so many others, is going to fall back to economics of your particular situation. Are you losing your competitive edge by paring down the design or art resources of the game to work on the 3G? Are the additional expected sales going to make up the money invested in that expenditure? If you can answer those questions then the answer is obvious. 

Worrying about somebody "stealing your idea" isn't worth it. Once your game is finished, if it's any good, somebody's going to borrow from it. Even if it's an unabashed rip off they may do a better job than you can. The only thing hiding your idea gives you is a theoretical head start. It's better to just release something good and give it to an audience that wants it than trying to hide it away. But at the end of the day you have to ask yourself why you'd want to start a blog. Can you actually pull off what you think you want to do? Are you focusing on the product itself or are you thinking a bit more ahead about what happens after the product is finished (either by shipping or getting shelved)? 

(Also you might not want to use the variable name as it's a property on s that essentially does . That might be messing you up as well.) 

The standard tip of profile, profile, profile applies just as well here, although the tools are slightly different. gDEBugger is great at helping you see exactly what's going on under the hood. It's expensive, though. 

Those other lines are your callstack. It's just how Unity does things -- as far as I know you can't change it. If you want to filter them out, what you can likely do is add a prefix to your own debug logs and filter off of that instead of just relying on the tags. 

It's probably an issue of your near clipping plane of your camera being further away than the radius on your character controller. Either make the collision radius bigger or make the near clipping plane smaller. If you look in the editor at the camera frustum you can easily tell if it's too far out compared to your collision radius. Here's an example: 

Of course it is, I can simply point to a single example of this being the case and it's "achievable". The thing is, in order for you to do it there are a lot of factors at play. Can you make games quickly/cheaply? With the race to the bottom in terms of purchasing price, if you eat up too much time and money on a single game you're not likely to get any return on that investment Do you monetize properly? The freemium model is getting more and more popular, for example. If you're not going freemium, you need to know how to price yourself in the market. You have to be fulfilling some kind of strong desire to place yourself above the $1 price point. Are the games you're making high enough quality that people will want to tell their friends about them? Word of mouth is a very strong sales driver. If people aren't saying "hey you should play this", you're not going to make any money. Is the content of the games appealing to the mass market? You can't just target the 17-34 male demographic with the games you're making if you want to go really wide with it. Can you advertise properly? This isn't a case where "if you build it they will come". You have to send out demo codes to the right people. Try to get reviewed. Try to get popular bloggers, etc. to recommend it. Be active in community groups (facebook, forums, youtube, etc.). Basically, the point that a lot of people in the comments are making is that it seems you're asking for the impossible analysis. You're giving a specific profitability number without talking about the product you're making at all. 

[Hypothetically] I'm at a smaller company and looking for a place to get the word out about our available openings. Alternately, I'm looking for a place to browse through resumes of people looking for jobs. What are some services I can use to find the people I need? Answer Format 

Given that most "2D" games are still in 3D engines, just using camera-aligned quads and an orthographic camera, not hard at all. Simply replace your standard quad with animated materials with an actual model that animates and keep your logic the same. 

Braid licensed tracks from MagnaTune. They have very easy licensing schemes, and you can choose to listen to the entire song on the website before you decide to commit to anything. It can get expensive though. Quoted rates for a full song for 1 platform at 50k units without being the theme song or used in advertising is $3000. 

There's an important distinction to make between in the psychology of the player between free games and paid games. With a paid game, people are already invested in the product by the time they get around to installing it. Clients are willing to go through more rigmarole to get your product working because they've already made the decision to use it and just tossing it isn't really an option because they've already spent the money. With a free game, there is no investment by the player. Every gate that you put in front of your user is going to result in a percentage of players not continuing to use your product. Even page load times are an issue. I don't know if this is a reliable source, but Amazon found that every additional 100ms page load time decreased sales by 1%. Even the Unity plugin, which as far as I'm concerned has a near seamless installation process (no admin rights required, no browser restart required) only has a 60% plugin install success rate. In the freemium analytics world, this is called "funnel tracking". You want your player experience to be as seamless as possible. That means, for the most amount of exposure, you want: 1) No installation process 2) No sign up process 3) Fast loads 4) Clear, brief menus Now there are a couple of exceptions to this, obviously. After a certain critical mass people will come seek your product out. But if you're trying to go wide, you're not doing yourself any favors by requiring any additional player steps. 

Simple enough question: What math should all game programmers have a firm grasp of in order to be successful? I'm not specifically talking about rendering math or anything in the niche areas of game programming, more specifically just things that even game programmers should know about, and if they don't they'll probably find it useful. Note: as there is no one correct answer, this question (and its answers) is a community wiki. Also, if you would like fancy latex math equations, feel free to use $URL$ 

I think it's more correct to say that the effect you're seeing is called Aliasing. Specifically a Moiré pattern. Basically for speed there was a naive method of picking which pixel from a texture to draw at a given pixel on screen given the camera you're rendering from, and the curvature you see is a side effect of the grid pattern. So no, it wasn't intentional. Mipmapping helps fix this issue as well as improves speed of rendering (as picking adjacent pixels from a lower res texture is faster due to cache coherency than picking far apart pixels on a larger texture). But, as you can see from mipmap examples, it doesn't make the texture look "right". For that you need anisotropic filtering. 

It seems that Unity 4.1 changed the trampoline project pretty significantly. There must be a plugin or something that your older project is using that is referencing that old file and needs to be updated to Unity 4.1. 

I know of very few games that actually charge admission. You most likely won't make any money that way, simply due to the fact that people can easily find something else to play with their time. There are a few examples I remember seeing that lock certain modes behind a paywall, but if people are getting enough enjoyment out of the free one then they won't feel obligated to try the other one (this is the same problem with demos that give away too much). It also isn't as good of a monetization strategy because it's something the user only buys once. If you want to bring a puzzle game to facebook, my suggestion it to look and see what Popcap did with Bejeweled Blitz and Zuma Blitz. They basically added a monetization layer on top of the existing games with things like purchasable powerups and the like. They also made it very social with the weekly tournament idea and very visible friends scores. 

Populate a unity scene at editor time from an XML file Replace unity's default scene format entirely with an xml file. 

In forward rendering each object that is affected by a light source is rendered for each light. So with two lights, you're rendering twice as many polygons than if you had a single light. On top of that, the optimized mesh that unity generates/imports for you may not be as few polygons/verts as what you make. I think it uses triangle strips and makes a lot of degenerate triangles so that it renders faster. See also: $URL$ 

There are basically two paths you can go down. 1) Prepare models beforehand and try to sell them. A pretty popular website with a lot of art on it is TurboSquid. $URL$ This lets you work on what you know and at your own pace. 2) Join an art collective that does outsourcing and do work for hire. I know some people who did this from home, but I can't think of the name of the company they went through. This is generally more demanding and you'd be expected to do revisions and so forth. You'd be either paid on a per-piece or by schedule. As I'm not an artist I can't really comment any further, but those are your basic options.