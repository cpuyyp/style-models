I don't think this parameter has any value and is actually very error prone because the user of this attribute has to know that he can use the and what it means. I'd stick to an automatic message about the value not beeing allowed. 

because as a parameter name is never cleaner and abbreviating message to is also not a good style. In fact in C# we rarely use abbreviations. 

Due to many confusing names (builder or factory?) and no single clear dependency structure I suggest cleaning this up first (probably by completely rewriting it). 

Parameters Use (overloaded) construtors where appropriate to create the modules and initialize them to a correct state. 

into this one. Each expression will resove either to or the actual condition if the variable was provided. 

You don't need any lists or multiple observable-collections. Just sort the inventory and pass the result to the final observable-collection which will become your . 

(don't forget about the ) Nothing is static, nothing is global. It can work with defaults or with custom values. It's testable and easity to use (with default values). Here the simple DI works with generics and the full DI by passing it a custom connection. 

If you are not able to update it later then you should start writing all kinds of unit and integration tests to make sure it's bullet-proof but even then there will still be a bug somewhere... Not being able to deploy new versions is a terrible plan. 

My PoC works, loads plugins, their dependencies and correctly executes controllers that were loaded dynamically. I was wondering whether there is anything about this simple solution that could be done better? 

I agree this is the right type of the exception but I preferred it checking each value separately to give the user a hint which one of the parameters is incorrect. 

The class is really simple. It's backed by a newer implementation of my old CronExpression. There are currently only these two methods. The factory method creates a new scheduler that ticks at the specified intervals and provides schedules as s to the observers. Jobs are scheduled with the extension. This one requires a cron-expression and the action to execute. 

Yes, I think it is a bad design and implementing a repository the way you did it is the right approach. 

Current property You should never throw the . There is almost always a more appropriate exception already available or you should create a new one. The name of the exception usually already indicates the reason for it. In this case I would pick the . LoadSession method Is the user allowed to re-load the session? If not then either throw an exception if he tries it again or return the already loaded session with the coalesce operator: 

The previous question was a really bad design where I had all the logic in the method. The only way to test it was to look at the output in the console. I now encapsulated it in an extension method and wrote two unit-tests for it - here I'm not sure about the part using the for checking how long the execution took - do you think this is the right way to do it? I guess the implementation of the extension alone should now be better. The purpose of this extension is to execute multiple jobs in parallel and cancel the ones that take too much time to complete. 

Without the this seems to be faster in tests by just ~8ms for 100.000 loops and a string lenght of 1.000 

The code itself is not so bad although it could use more and maybe more precise names then or . Of course it shouldn't print to the console but return a usable result. 

If both answers are yes then you should use curly braces. Doesn't this look cleaner? You see right away that there is an and what it does. 

I remove the and replaced it with the . It now maps dictionaries to tuples and takes care of the conversion of parsed data. 

The huge constructore is the result that the class is doing too much. It has to know everything about the ftp server as well as about the network drive. You need to separate them. I suggest the following structure: Define a storage interface: 

Batch save (EDIT) I oversaw the fact that it is a batch-save that saves each 100 items and not a percentage like I thought. In this case I suggest a more generic solution that allows you to reuse it. I don't like the manual dispose and the . It might go sideways if it crashes the context won't be disposed properly. It is an extension that you can use on a colleciton of entities. It requires the size of the batch and a factory method for the context. The last parameter is for progress reporting. Unlike the original solution this one works with so it is able to report progress for collection that are smaller then 100 items. Internally it uses two lambdas: one for checking if the batch should be saved and the other one for progress reporting. The context is wrapped with a statement. 

It'll take care of validating the model and short-cutting the request if the model is invalid. As far as the status-code 500 is concerned you should handle this one with a middleware, for example I use this pattern where in development I use the exception page and in the production code I let the middleware handle the exceptions. There's no need to put a in every action. 

The class became a collection of rules and is now immutable. Adding new rules results in a new validator. This should allow to add new rules ad-hoc if necessary without breaking the old ones. This time it also calls on the collection. 

Does this design have any obvious weaknesses? I've added the beginner tag because I have very little experience with all the stuff. 

To support this new type a new was necessary. It takes care of deserializing the value and creating an instance of the and of serializing it by extracting the from it. 

You should define a class for the results. It would help to explain all the magic indexes above and encapsulate some logic. It's extremely hard to follow in its current form. 

The real message should have a method like that you use to display the message and to hide it via the and . You should handle the in order to proceed to the next popup. It's just for demonstration purposes so I left the there. And here's one more example how to use the above service: 

I find the design with the interface is ok but the tests are not. You need to actually mock it and inject it and test something else that depends on it. 

...many refactorings later. I came to the conclustion that this soltion was totaly overengineered. I simplified it and made more LINQ-friendly by using instead of the custom type and the . The core type is now the that is easier to use with DI and easier to mock. just needs one parameter to make it faster, this is exclude directories, everything else I can filter outside later. 

Usully long verbose names are a good thing but here they don't. What is ? What is or ? They are more confusing then helpful. Generic items are mostly like if there is no better name e.g. the first letter(s) of its type name. Inside the you work with a group so the letter would be just fine. The same applies to the where you work with groups agian. Consider this: 

What else I think... Other than these couple of nitpicks this code is very well structured and pretty clean. Good job! 

but even with your original solution if you can use C# 6 it's a good idea to not use strings but the keyword so you'll get: 

If you wrote it like this from the beginning it would also make your code much longer because you use very similar code in several places. This would probaly make you think does it have to be this way? and make you look for a different solution. This new solution is called encapsulation. You don't want to have anything more the once. But more about this under the next question.