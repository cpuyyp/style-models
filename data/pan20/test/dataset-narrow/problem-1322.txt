You should check out this tutorial by Ray Wenderlich. It uses Cocos2d + Box2d to show how to write a game like Tiny Wings. The first part of the tutorial explains how to create dynamic textures: $URL$ Second part is how to use Box2d for the gameplay: $URL$ 

Actually that "while loop" that you wrote there is the source of your problem. GetMessage puts your application to sleep until a message arrives. This is good for GUI applications but obviously is not good for games. The right way of doing the game loop is using PeekMessage instead so that your application is not put to sleep and can just keep spinning. Here is the loop that you can see in DXUT and in most DirectX samples: 

This is not trivial. In general you want to make your game predictable. You also need to synchronize the clocks in both clients. If you do this there is no need to send the asteroids position every frame because both clients will be doing the same simulation. After a given number of frames you make sure that the simulations have not changed. Once you have done this you can send each player input and repeat the simulation of what happened in the other client exactly. This is one of the most known articles and a good introduction. It's a postmortem on how they built Age of Empires multiplayer. You can also check this fantastic one. The author has written a multiplayer Asteroids game. There is a second article in his website with more details. 

I kept investigating this and will post this for benefit of someone that has the same question. Seems like the right answer to this is to skip the ContentPipeline and use Texture2D.FromStream to load the textures at runtime. This method works fine in a PC and even though there will be a small performance hit this is something that I can optimize once I'm closer to the release date. For now, having the ability of dynamically modifying the content for both the editor and game are exactly what I need. Once the content is frozen I can optimize this by going back to the ContentPipeline. 

It's a very open question. Here are a few references I've found great for writing my always in progress engine :) Online references: 

My game uses the Content Pipeline to load the spriteSheet at runtime. The artist for the game sends me the modified spritesheet and I do a build in my machine and send him an updated project. So I'm looking for a way to generate the xnb files in his machine (this is the output of the content pipeline) without him having to install the full XNA Game studio. 1) I don't want my artist to install VS + Xna (I know there is a free version of VS but this won't scale once we add more people to the team). 2) I'm not interested in running this editor/tool in Xbox so a Windows only solution works. 3) I'm aware of MSBuild options but they require full XNA I researched Shawn's blog and found the option of using Msbuild Sample or a new option in XNA 4.0 that looked promising here but seems like it has the same restriction: Need to install full XNA GS because the ContentPipeline is not part of the XNA redist. So has anyone found a workaround for this? 

This question might be too general to give an answer that fixes your problem. Before using profilers I would recommend adding 1) Lots of tracing statements to your program and 2) ability to turn on/off features at runtime (including tracing but also things such as textures, culling, using very simple meshes, etc). I've found doing these 2 makes it much easier to pinpoint performance problems in my games. That being said, you do have other options depending on your target platform. Since the problem might be environmental and assuming you are targeting Windows (big assumption I know) you might find using xperf valuable. xperf is a system level profiler that will tell you everything that is happening in your computer and has a low impact on the programs that are running. Bruce Dawson's blog has a lot of very good tutorials and examples (such as finding performance problems in random programs such as Powerpoint or backup drive ). One trick he mentions is having xperf running all the time in a circular buffer so that as soon as you are able to repro the problem you will have a snapshot of everything that was happening in the machine. 

short answer:[A,B,C,D,A,B] you'll need 4 triangles to create a Tetrahedron. so you'll need 6 vertices in your buffer. not that for the first three vertices you'll only get one triangle but for every other vertex you'll have one extra triangle. now back to your problem, as I said you'll need 4 triangles represented as [A,B,C], [A,B,D], [A,C,D] and [B,C,D] with a little bit sorting you can easily arrange them into a form that each two consecutive triangle share two vertices [A,B,C], [B,C,D], [C,D,A] and finally [D,A,B]. then by combining all those together you'll have your full vertices arrangement which is exactly as I mentioned above. 

note that you also need to release the sprite at the end of the process, so that later that sprite could be deleted normally. 

I guess you have to make some changes in libRocket code to make it pass Window creation. I'm not sure if there is another way but I'm sure this piece of code will work! and I assume you are developing for a windows system, if you are targeting another platform there is a similar steps but with different variables and function changes! first of all you need to get a handler to the window SDL creates. this piece of code extracts required HWND value (according to here: 

If you don't have any idea how one can win the game, you can go with minmax. But there are too many other complicated algorithms you can implement. Here is an small list: 

it really depends on how long do you want to apply the force. but for starter you can use in which f is the force you are applying and dy is how far does the object travel before you stop applying the force (which usually is a small value for impulses) 

i started to place a comment bt it went to long so changed it to an answer : first of all you have specify your target platform, and it would also help if you tell which genre are you going to create a game. the brad answer is to download and install dx SDK if you are going to develop for microsoft group or opengl sdk if you are going to develop for others. there are many sample codes with enough documentation inside each sdk. or you can just pick a game engine again based on the genre and platform you are going to create your game and start reading that engine's specific manual. studying a engine help you create your games easier but will take you a lot more time until you reach the point that you can start your games from the scrach( and blieve me starting to develop a gameengine is almost always a bad idea). for stat I suggest essenthel engine. it comes out with a lot of samples and an active community and it's very easy to use almost the easiest engine i've ever seen in c++ and it's also free unless you want to publish a game with it. but it needs a lot of c++ knowledge to begin with and one might consider it as a moderate engine compared to UDK or similar gigantic engines. --edit-- esenthel engine has only target platform of pc and mac and if you are a license developer you can also create games for ipad/iphone. for an opensource game development i recommend taking a look on ogre3D, it's an opensource engine and even there is chapter in "deitel & deitel: c++ how to program" about it. but as far as I know (I didn't try that engine myself) it's almost somevery basic framework which force you to add many conecpts of your game yourself. And I think givving a bigger challange you can learn a lot more if you really get into it.