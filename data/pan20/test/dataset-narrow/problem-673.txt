Though this error is gone in Python 3, that doesn't leave me feeling good about it. I'd finish off with 

as our heuristic. Now when outputting results, we can ignore any branches where the heuristic brings us above (or equal to) that. (If you want all of the best options, use strict inequality. If you only need one, use non-strict inequality.) Here is some code to try. It is not particularly pretty, but it works and is pretty fast. 

One can also note that only numbers one below primes actually need to be checked, since is a factor of every number. This simplifies things: 

Lior Kogan showed manually that any timespan strictly longer than 2844 seconds reaches a global maximum. 

I suppose we could try to speed this up more, but that seems beside the point. We want to find the minimum. Well, this isn't totally pointless - we can just run a with a good key on our result. Unfortunately, though, I haven't managed to get past 

We can use to filter dependent on , and the fact both and are in to filter and to . We can do the same filtering on too. 

Note that this is again going to have problems with duplicates, so that needs to be handled once again if it can arise. 

Doesn't actually work. You need to fully exit, not just uninitialize SDL. Actually, there isn't much point running at all. I suggest just doing from a function. I personally don't like comments at the end of lines, but if you must at least space them properly (gap of two spaces and a space after the hash). This is overcomplicated: 

Why do I say that serializing to a is ill-advised? Modern Python should as much as possible try to provide lazy iterators instead of concrete storage; you can see this in Python 3's move to lazy , and others. This is mostly because lazy computations are more efficient in the scheme of things - if you ever decide at one point you only want to iterate a result, or if you want to the result before actually generating your result, or you actually decide elsewhere you want a or whatever, a lazy output is better. But it's true even when you don't care at all about performance. Providing an iterator as output gives the abstract claim of "I'm providing these elements". Something like 

I don't get your justification for running . I suggest you make sure this is really the right thing to do, because it looks wrong. You have 

You don't need backslashes for line continuation inside any pair of brackets. Remove them. Further, this formatting IMHO is quite strange anyway. The second problem is that you are both modifying the sorted array and returning it. Note how modifies but doesn't return and returns but doesn't modify. Considering how slow your sort is, a copy at the start wouldn't hurt. Your docstring is also all wrong; docstrings should mention user-facing concerns, not implementation detail. A thorough one might say 

You shouldn't call ; it's intended only for use in the REPL. Instead, try returning gracefully from a function. You should not catch a raw as this will hide real errors; try instead. There's no need to give it a name if you never use it either. You should probably check both sides of : 

I do not believe there is any reason for these dictionaries to actually be ordered, so I would abandon that. I would also prefer short names to single letter variables. 

and many others. Some are useful, though, such as (although that can be removed by just improving the code). Comments above functions like 

isn't really useful; just store . I would personally move some more of this out to an iterator that s results. This seperates some of the logic out. So here's a first-pass clean-up: 

Your tests cover the general case fine but they don't check edge-cases; what happens with 0-length inputs? What about complicated patterns? Do you ever check precedence, despite having mentioned it? 

Although this is a gameplay issue so I won't mess with it. As written, the checks are largely repetitive so I'd suggest extracting it into an operation over indices: 

Here's an idea for how to improve the algorithm. Your code is . Using a dictionary instead of a list of lists would reduce that to . My algorithm is instead approximately where is the number of circles. This comes from building something similar to an interval tree for each column: 

I'm not the first person to wonder about those semicolons, but I might be the first to explain what they do! They are used to teminate a line early, so that you can put two logical lines on the same physical one, such as in: 

loops and statements don't need their condition parenthesized, and operators should be spaced properly: 

With respect to the code, here are a few comments. First, are you sure you want to restrict it to positive integers? You can simply define negative integers to not be primes. No need to throw an error. I would, however change your 

but you run these at most twice and $$ 2 \cdot \mathcal{O}(n) = \mathcal{O}(2n) = \mathcal{O}(n) $$ Since the overall cost is at best (hopefully) \$\mathcal{O}(n + (largest - smallest)) > \mathcal{O}(n)\$, this does not affect overall running times. They are also very fast operations. However, since you're already sorting the array, indexing will be faster. All of this is not needed if you make your main loop more robust: 

The new function is too condensed (I realize this does not reflect much on the original code). I would change it to: 

means stdin? This is more reasonable if we want to allow the code to accept to mean standard input, as we can do 

is the largest , but not the largest integer, so your loop was broken (although it would have taken a while to find out). This fixes that and makes it Python 3 compatible. Now, let's add some introspection: 

is clearer. If you want to remove the , you're going to have to "return" a lock as well, since the read is only valid while the lock is held. This might be a good idea, but it's really up to you if the cost is worth it. 

This program has to support both versions syntactically but can be much smaller. Personally, though, it looks trivial to get this running on Python 3; use 

Your first line of actual code is 139 chars long. You should wrap lines like this. The simplest method is just: 

This also removes the very strange class. Then I look at the ABC. Remember that Python is duck-typed. The reason for an ABC is to standardize common interfaces that arise in the code - unless you have at least a few implementations, duck-typing is more appropriate. Which gives 

I'm starting from Josay's code with Ramast's suggestion because I don't feel like repeating their points: 

Let's fix the easy issues and move it to neighbor the only place it's used so we can revisit it at a more appropriate time. 

Do you not think this whole thing is getting a bit silly? When reading, just decrement the edge values and starting edge correctly: 

Numpy arrays are faster than lists for some things and slower for others. In particular, arrays tend to be slower when indexing single items (eg. ). They tend to be faster on operations that affect the whole array, such as , which searches the whole array. Before removing and , most of the time was spent in those two operations. This meant arrays were significantly faster. After removing them, all operations on the array were just indexes. This means that lists became faster. So lists are only faster after making certain changes to the code. 

will already be sorted, so don't call . Use over as well. More efficient than sorting \$\left(\mathcal{O}(n \log n)\right)\$ is to use a . However, to produce output one would have to loop over a range. This can be done with: 

so you don't need the comment in the first place. Then there's . So I wrack my brain thinking about what word contains . But it turns out you just meant to write . What does that have to do with the letter ? Worse than that is when you outright lie. What would you expect the variable to contain? A node, right? Nope - it contains the total number of nodes. And you write 

My first comment would be to comment your code. You need documentation so I know what your function is meant to do. "Sum any given finite Arithmetic Progression" would suffice if you passed in an , but instead you pass in some bounds. Writing an arithmetic progression type would be simple and might even help a little, but you still need to document that. I don't know what algorithm you're trying to use. You've evidently taken some maths for sums of arithmetic progressions and applied it to the problem, but there's no way for me to verify that the maths is correct or that the code implements it correctly without at least rudimentary explanation of what you did. I could reimplement it myself, but code should be verifiable much more easily than that. 

Although I would understand any reasonable compromise. Finally, I would move to for the fields in true Python convention. This all gives: 

would be better in 's docstring. "It is currently read-only" doesn't mean much since everything is public. To mark things "private" the convention is to prefix them with underscores (eg. ). I wouldn't do that, though; I'd get rid of the getters and just have attributes. If you really want getters in order to make things read-only, use properties. Since you're requiring Python 3, remove from the inheritance list; it was only required while transitioning from 2.x. I would separate the embedded classes; sticking them together seems relatively pointless. IMHO, is nicer than . Feel free to ignore this point. I personally don't think should be calling on the input file; it should trust the user to give it an appropriately seeked file, even if that may be offset. Your isn't needed; will error just fine if it's closed (with a more descriptive error, too). It doesn't seem like needs at all, actually; it should be able to receive just a string. FWIW, isn't a buffer. I would use a dictionary to calculate . 

but never touch again! This implied that a class is really the wrong abstraction in some sense; you're not using to store state but to stick itself onto the board somehow. Get rid of the class entirely. In the constructor you use for two purposes. One is to hold a random boolean you use once and another is to hold an unused string. The first can be replaced with a at point of use and the second can be removed entirely. This can be further simplified by just writing and not mutating it further. Your loops can be replaced with ranges using the and parameters. This all gives: 

not do that at all? This seems ripe for errors. Further, this behaviour isn't mentioned in the docstring! That'll cause someone problems some months down the line when they use a slightly different set of values and their text comes out uppercased! A minor, but nagging, point here is your use of over . This is poor form, and you probably shouldn't be doing it. There's also the default for of 97. That doesn't make sense! What if I pass in ? Why would a shift of 97 make sense? I suggest not giving a default here, and probably no default alphabet either. You default initialize 

then, but this is unfortunately way slower in this microbenchmark. I'll leave it as a hypothetical, then. The problem mostly revolves around having a really large number of inputs, so the overhead from is largely insignificant. Other people have explained this already, though, so there's not much point me repeating it. 

The lack of solutions for restricts , but we can keep that in mind for later. tells us not all too much extra, but keep it in mind. tells us again that we have a divisibility constraint. 

If the time span is not this long, we can break what is left into some number of whole minutes plus up to two partial minutes. The maximum over a whole minute is determined by only the hour and the minute hand; the second hand makes a complete turn so we do not depend on its value. Since the problem is rotationally invariant and symmetric, this only truly depends on the absolute difference between the hour and the minute, of which there are only 31 possibilities. These can be cached in a length-31 array. 

Surely the in the can only hold for . You might as well add that as another case in the loop instead: 

This is as direct a mapping as possible; instead of changing the comparison I just shifted the index when indexing. This isn't idiomatic, but it's direct. It's largely the same as your code, but it's correct. This matters when we go to larger N, where your code fails. It's also Python 3 compatible simply by using with brackets. Let's time them: 

is largely OK. should have its function first. Its init function doesn't initialize all of its values; you have to then call to get that running. This suggests you have a bad separation of concerns; should be split into two classes where one handles the overall statistics and another handles the game itself. I would go with and . With this, should be split into three parts; and and which are part of . The global function can be merged into the local method and the and functions should become methods. would be called from the code that handles controlling the game (currently ) as neither class has any business dealing with it. and should return whether the game has ended ignoring whether the user wants to replay. and and aren't used, so remove them. would be 

I suppose you don't indent the debug lines to make them easier to spot. That's a sensible idea (although not one I've seen before). However, I treat Code Review answers as a "just before checkin" thing, so I'd suggest removing these by this point. You pre-declare your variables. Don't do this; write them as close to point-of-use as reasonable. Your op seems to be rather useless - you could just use instead. So remove it. Your 

has a raw . I don't like that; replace it with an catching the specific wanted exception, or if you really don't know which will be raised. This would at least avoid catching , which is rarely wanted. Don't use to test if something is , use . This is a stricter, faster check and is less likely to cause false positives. You'd be better off using than the string and combination you're using now. For example, would be roughly 

This is a "blind" review in that I'm not testing my changes or running your code. Don't use unless actually version-agnostic; use or . This here 

assumes but does not require , and then does even not use that fact! For if you used that fact, you could have just done 

Some of these names (eg. ) are particularly cryptic. Your actually takes \$\mathcal{O}(e^n)\$ time - what you really want as a basis is a generator to let you do 

builds the tree-like structure and finds the areas with an overlap of at least 2. Unfortunately this is much more complex. 

quite often. Don't bother duplicating the name, it doesn't help. Only do this if the parameter name is different and adds information. Your code looks race-y. For example,