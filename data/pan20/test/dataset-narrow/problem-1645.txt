In terms of minimum voltage I wouldn't go with anything less than 5V. The maximum GPIO output is around 16mA per individual pin or all pins at ~3mA for a total of around 51mA. For more details I suggest you give this post and this post a look. 

To prevent any of these lines of code from taking effect just add a in front of the line of code. I would suggest commenting out all of them before you try anything else. 

The best practice to diagnosing a problem is trying to find the source of the issue. In this case the boot issue with the Pi 3 was actually a network problem which explains why you could not successfully ping it. Here is my suggestion on how to get the Pi 2 to boot. Use the power supply you used with the Pi 3, since you know it works. This should eliminate one problem from the equation. Secondly connect it to the screen using the same equipment as you used with the Pi 3. Just to confirm it really is a boot issue. The solid green LED indicates that no boot code was executed. This means you need to re-flash the SD card with the OS. I'm going to walk you through the steps on how to do that for installing Raspbian and if you have a Windows computer: 

It works very well - no questions about that. However I also would like to check if servo is available/connected to the port. However if I unplug it the program works just fine. I do understand that basically I'm sending the signal to a registered PWM port and that it reaches the port but there is nothing to read it. The question is - is there a possible solution for this? Maybe I should read data from the port and check if it's empty or is there a macro defined for it. Thanks! 

Depending on the hard disk drive you are using and the USB stick you want use the chances are performance wise there isn't going to be much difference. Depending on the model of Pi you have, the USB ports and the Ethernet port share the same controller. This means the USB transfer rate is bottle-necked by any traffic through the Ethernet port. Also worth considering is all models of the Pi use USB 2.0 connectors. At best through a USB 2.0 connection, (theoretically), you are going to get a connection speed of 53MB/s. (See this post for more details). Generally speaking a modern 7200RPM drive is at best going to give read speeds of around 160MB/s and write speeds of around 150MB/s. Again that's a best case scenario, so you should expect less. The read and write speeds of the USB drive depends on the type of flash memory that is used in it. A cheap flash drive is obviously going to perform worse in read and write tests. However flash memory can perform on par or better than a HDD. Although you will pay a premium for uber fast flash drives. To be honest I don't think you will notice a difference between the two. The only thing I would add is if you fill the USB flash drive to capacity it will start to slow down. You are going to be less likely to run into that issue with the 1TB drive. I can't imagine any lifespan differences would cause you issues. And I'm not sure I could argue one drive is more reliable than the other. If you would like a detailed comparison in this area I suggest you give this page a look. 

EDIT 2: Ok, I have found a problem and a "brute force" solution. I think the problem is/was related to not complete flush of io channel(s) of the scanner. So I modified the code to force and create a new instance of scanner on each loop iteration. If there're better solutions for this case I'd be more than grateful to see it. The new version of code: 

run it with for creation of and everything works fine. Also you may run to generate the config file with suitable init commands. However parameteres are not affected by it, except Baud. Hope someone will find it useful. 

And paste them into the root directory of the SD card. The final step is to change the filename of the file on the SD card to . To create the startup files, in the root directory of the SD card create a file called and add the following line to it: 

Be sure to close the file with saving it. And from there you are good to go. The source of the information suggested running XBMC off a USB drive increased responsiveness. I'm not so sure about this claim, but you are not going to see any performance degradation as a result of using this method. As for your media collection I suggest storing that on a second drive whether it is USB or a network location. 

I couldn't find the right pictures for weigh sensor with HX711 and wifi shield, but all those need pins. 

I've been trying to connect Huawei E3131 to my Raspberry pi. So far I've installed ppp, usb_modeswitch and wvdial. Here is my wvdial.conf partially generated by and partially changed by myself: 

Ok, apparently you don't need to change the basic *99# to your phone number. So the final config file looks like 

If I Ctrl+C the program (even without the signal defined) and restart - mostly it will read data. But sometimes it also won't. EDIT 1: Also I have added the in case if the return is not . It keeps giving me for output. Also interesting thing I've noticed - every time I read a card it gives this output: 

This guide here provides very clear instructions on how to generate numbers with the RNG. In terms of the tests you have proposed I have not found any source which gives the information you are after. I would imagine it is possible to write some code that would perform such tests, or there may be code out there you can use as a starting point. Although, the link earlier in my answer suggests the RNG is cytopgraphic-grade. Surely that should certify it? 

The bit you are interested in is the Revision. However the fact it says , does not actually mean its a Pi 2 Model B revision 2 board. To break it down for you: 

I'm trying to connect multiple devices to my Raspberry Pi 3 B+. The components are RFID RC522, RPi LCD display, Load Sensor (strain gauge), and WiFi shield. All those are needed for my project. However GPIO pins overlap almost in every case. I do know that we can parallel the Voltage pin, however I'm super confused how to connect all of it on 1 board. If there's a channel splitter hardware solution or an extended version of RPi or in few words - what's the best way to do it - if possible. Thanks! 

I very strongly recommend the Pi Hut's Raspberry Pi Power supply. I use it myself and it powers a Pi 3 running at 100% CPU usage with USB devices connected, absolutely no problem. It is specifically designed for powering the Pi, so it is your best bet. Nevertheless you can get away with something like a high quality tablet charger, as it will be able to supply the current. 

Using something like this it would be possible to split the 1 HDMI port on the Pi into 2. An alternative is to use this board from Gert, which adds a second HDMI port using the GPIO pins. However this is going to just duplicate them, to get the screens to extend is going to be much more difficult. As a side note, the more you split the signal the more desegregated it is going to get. So this is something to consider Also be aware of the potential stress you could be putting on your Pi through connecting lots of displays to it. 

I'm trying to make RFID RC522 work with my Raspberry Pi 3 B+. I use the library MFRC522, and the the sensor can read data most of the times. However if I just put the card on the sensor it will stop reading after around 25-1.5k reads, as well as won't read any new cards. It either ends with "AUTH ERROR" or it stops on "Card Detected". My guess would be that library read handling has some bug. Here's the code I use(same as sample Read.py from the library, but I added sleep and counter): 

It also numbers the images in numerical order so the images are outputted in the order they were taken. If you are interested this tutorial here is easy to follow: $URL$ The important bit is to set the save location of your pictures as the external hard drive connected to the Pi. 

You can buy a GPRS/GSM module for the Pi called the SIM900, from this website. It is also compatible with Arduino and Intel Galileo. The same website also includes very detailed instructions to get the module working with the Pi, it also includes all of the code to get the module working. The software required to get the code working is called minicom. If your interested in the tutorial look here.