But this will halt the calling thread while HSecondCounter ticking every second infinitely with no way to stop it. So this is not useful. 

I'm not saying the below revision is an improvement but it has eliminated the need for . The penalty is to have the index as a separate argument to which violates the idea of a state object. One could argue that the index is not a part of the (splitting)state but just an iterator variable and then everything are nicely justified again :-) 

One problem with your solutions is that they aren't tail recursive and for large data sets they build up the stack. A way to avoid that could be like the below modification of the solution in your own answer: 

I find your code clear enough, but you could improve it a little bit, so you only do the add operation once: 

(The meat of the extension methods can surely be done more sophisticated than the above.) is an with a rudimentary definition like: 

EDIT I admit that Husk has a point about especially in where the length reach as much as but tests on my computer shows only a pair of seconds in expense for n = 8. The algorithm exhausts the stack for n = 10 anyway... As an alternative you could use which seems to have the same performance as Husks version. 

When testing the algorithm against other implementations it seems to work as expected and without a thorough knowledge about calendars it is hard to comment on the details of the algorithm as is. From a computational or mathematical point of view it is possible to simplify or make the formulas a little clearer by removing unnecessary parenthesis and just rely on operator precedence: 

2) The Set() method is strange for a singleton class since the ObjectService argument will always be the same (that is the whole idea of a singleton class): 

As it shows, I have made the function generic (and guessed that cache is a Dictionary?). The last irritating comma (',') is removed by . 

A more 'advanced' approach could be the following, where I use a little Linq and an enum of Animals: 

3) For the fun of it, you could consider: Because you basically do the same same loop nested three times, it could be a candidate for a recursive function iterating over each addend and yielding all the positive sums. In that way you could generalize the algorithm to handle any number of addends... 

Instead of the use of the union type FBCase, I would use the tuples directly in a way like this (some of the functions then may need a renaming): 

Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

Some minor points: 1) You don't really need the variable, so just do the math in the call to TryGetValue(). 2) If are all positive you may the loop if . 3) It is stated that there is only one solution per input, so you can skip the check . This will never be true for the nums that add up to the target. As for the rest of nums it doesn't matter. 

because you do not filter anything out, so the isn't necessary. I wouldn't feed with a file path but with the actual input data and load the file elsewhere, making it more flexible. Because you know the total number in advance you could actually do everything in one single Seq.fold call on the input string without recursion - but maybe your focus was on recursion rather than anything else? A detail: when I run your code on the names string I get ? 

I think you show a good understanding of F# as a language and functional programming in general as far as I can see. A couple of things though: You use as variable name on multiple levels of function definitions. It makes it hard to read. IMO is a very readable construct for more than two matches. But for only two I prefer if-statements. The function/sequence is a kind of double sequence. I would do it this way: 

Overall your code does what you intend and that's a good start: to print a diamond with numbers. The first improvement could be to handle an "arbitrary" sized diamond: 

Now you just squares of digits and get index to precomputed cache of chain results. Here is the full code which on my machine is 15 times faster than the original one: 

Snap catches all exceptions thrown within handlers and converts them into responses with HTTP 500 code. So error handling in your code is pretty fine (if you are ok with converting "postgres is down" or "invalid query" into HTTP 500 code). Side note 1: You are setting at the top of the handler. It is easy to forget to add/remove this code if you are modifying some part of handler that is actually writes response data. It may be more convenient to define helper function: 

Using is justified only for big numbers, in your case using is enough and could be a bit faster. Here is another solution: 

While generating walkers for the next journey you traverse list of subsequences twice. This could be not very efficient as there are subsequences for the list of length . Here is less readable but more efficient approach: 

Working with text is easier with . E.g. it has already defined. Tagsoup understands so you don't need many type conversions. For greater amounts of data it will be notably faster and much more memory efficient. Instead of defining you can convert tag stream into tag tree, take first node and convert it back to stream: 

Haskell is great for it's declarative style programs and most of the first hundred Project Euler problems are easy to write in such a way. First of all, this problem is about ratios, so let us import module. 

Here is my attempt. It follows ideas from your code but uses function to update vectors. It is subject to fusion hence runs quite fast (test case #15 runs in 0.18s on hackerrank). The code is a bit ugly because of index juggling. Python version does not require this and is much cleaner. 

You can read more about it here. And of course it is better to use instead of simple lists if the code is full of lookups. 

In this case changing fields in or won't break . You can enable extension to get only specified fields : 

The code seems a bit too verbose because of explicit search tree construction. It is possible to make it more concise by using list monad for building search space. Here is my attempt to rewrite it: 

is the same as , so . You can use instead of to print strings without quotes. Using the fact that , you can merge and into: 

Maps as arrays In you are taversing heights 200 times. It is possible to emulate array with and do this in one pass: 

From that nice formula it is easy to see that the process of computing âˆš2 is iterative. You just need to decide what function to iterate. Let us consider this one: 

Side note 2: Some libraries export functions with quite generic names (like or ), it is easier to read code when you have some explicit pointer about were function comes from. You can import library with alias: 

It is possible to create cyclic directory structure with symbolic links, so it may be reasonable not to traverse them. E.g. you can use from package to traverse only real directories: 

Note that I'm using strict version of left fold (see here about vs ) and strict . This means that map of height counts constructed in single pass without thunks. 

( is the result of the last computation in GHCi.) There is a function in Prelude that captures such a process of applying some function to the result of applying that function to the .... and so ad infinitum. 

It is really nice that you provided domain-specific type aliases. This makes type signatures more readable and allows to easily change underlying data representation as in this case. 

Note that in Haskell there is no single element tuple, so parentheses around are redundant ( but not ). 

creates cycle from a list. skips some characters and returns list starting from . Try it in ghci ( is infinite so be careful with it). 

I switched arguments in because this allows to define function more concisely and it is also correlates with update/insert from : they have collection as a last argument. Now it is possible to skip directly to and implement it in couple of lines: 

You're throwing a . Big no-no. What you want to throw is an , much more intuitive. When we catch that exception, we want to catch all invalid arguments; not just those that happen to be . And it would cause confusion if we receive NPE's from somewhere else. 

I've been writing a small library that allows for easy querying of the Stack Exchange websockets. I'm going to add an to replace the manual at every so you can let that one slide (unless you have something else in mind). A few thoughts I have: 

Yay, you use tests! Darn it, you don't use tests. Confusing? Allow me to explain. While I totally approve of you using tests, there is a lot more to it than simply putting the annotation above them. A test is comprised of 3 aspects: Arrange, Act and Assert. Typically a test (whether it's unit, integration, functional, end-to-end, etc) will have these aspects in explicit or implicit form. Personally I like to explicitly separate them with comments (). Why do I mention this? Note the last aspect of AAA: Assert. This tells us that, as the last step in our test, we will verify the result we have and assert that it is what we expected. Doing this allows us to run the tests and automatically compare the result of each test with the expected outcome. In your situation you have to manually verify that each test works as expected; can you see yourself doing that when you have 300 tests instead of 3? This brings us to another point: all modern IDE's have integrated test runners. If you have tests, you can just run these using that instead of having to use a method as entrypoint for your tests. By adapting these changes you also won't need those println's anymore which takes away focus from your actual content. 

Use instead of to exit a loop. It leaves room to add more instructions beyond the loop without having to change the implementation. It's also a more natural way to break out of a loop. 

Seems like a questionable name for what it does. Perhaps something like is more appropriate considering that's what it is actually implemented as and not just a projection of one exception to a list of exceptions. 

In this line of code you're essentially recreating a new object that already exists inside . I would just retrieve the existing from instead. 

Why is everything static? Your methods use a shared resource (the ) which should indicate that it is in fact anything but . 

You could consider using your enum to use alongside a general class. In the end, the only difference between a Warning and an Error is exactly that: a different severity level. If you have any case-specific logic then you can add those methods to the enum itself. This would save you from having pretty much the same classes for and . 

Now it's easy to see what you can do with that block: you move it to the helper method! And the result is this: 

Note that I am using variables so you don't have needless clutter of getters/setters. This class is just a wrapper to send values, nothing else. Some notes, perhaps? Naming In that same method you have the following parameter names: 

Naming conventions! Look through the list here but keep in mind that private non-static, non-const fields are also accepted to be . 

If you don't want to use multiple variables, may I suggest an array? Nothing fancy, just and fill it from to . Then you can switch your to . Note however that this requires a different loop or usage of . 

You're not using any form of globalization. Intended? Adding a resourcebundle isn't much work and you'll finally be able to support Swahili. 

Your intuition was correct, you're not doing asynchronicity the right way. Take a look at this bit of code: 

It's okay to do so. I typically use the same diagnostic ID for both these things and simply change the message. For example the diagnostic with ID "MemberCanBeReadOnly" can have a message "Field A can be made readonly" and "Property B can be made readonly". 

This incorporates a few changes. First of all: I've made the event handler . This is the only situation where it is advised to do this, simply because there's no alternative: event handlers have the requirement to have a return type whereas asynchronous methods work with . In essence this means that you won't be able to the event handler so if the caller finishes while the event's effects are still running, your program will exit without a regard of this still running code. Another change is that I used . You can choose between this and but both are more fluent than creating a new object and then starting it. You should always avoid calling since it synchronously blocks the thread to wait for the result (which is the opposite of what you typically want in an asynchronous environment). As shown in the docs: