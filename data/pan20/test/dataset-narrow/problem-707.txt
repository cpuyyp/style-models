This could be solved by adding a in the else-case. The better solution is to enumerate the UTF-8 code units directly: 

Note that this still does not work for negative numbers and numbers above \$ 2^{52} \$ due to the rounding errors. For the latter problem, see Computing the integer square root of large numbers. 

then it suffices to import (or + ). But I would get rid of the floating point conversion and implement it as (taking the hundreds as an example): 

(and is probably a typo and should be ). Here is a simple example where this conditions are not met, and your code crashes: 

In you use list comprehension to split a row into numbers – why not use list comprehension as well to split the input into rows? 

Efficiency: The problem is about the largest prime factor. Your algorithm already determines the prime factors in increasing order. Therefore there is no need to store the prime factors in a collection to get its maximum value. It is sufficient to remember the last prime factor found. Putting it together: Your function (renamed slightly) would then look like 

but the dot notation is more concise and makes it clear that you set a property (using the suggested name): 

You either have to add an explicit check (and throw an error or fail if duplicate keys are given), or add the key/value pairs sequentially so that duplicate keys are silently overwritten with the new value: 

but I don't know if that is worth the hassle. (Note that the static property is computed only once in the lifetime of the app, not each time that it is used.) 

Or, if is expected to be non-nil when the method is called (e.g. because it is set up in ), declare it as an implicitly unwrapped optional 

Using a dedicated enumeration type is a good idea. is (ultimately) a type alias for , so you can assign arbitrary integers to it, not just . 

Now some simplifications: if the existing text has no decimal separator then there is no need to check the replacement text for a separator. And if you already detected a duplicate separator then you don't have to check for invalid characters (letters). In other words: short-circuit: 

Creating a new (ordered) dictionary by mapping both keys and values can lead to unexpected results if two keys are mapped to the same new key. E.g. (with the fixed init method from above): 

to get the last path component of a file path. Apart from special cases (such as escaping closures), properties can be accessed without using : 

Your variable describes the contents of the game board, so I would call it instead. Each field can be empty, or be occupied by one of the players. This can be modeled by 

The in the function is not needed. Since B is the "larger" set, it suffices to iterate over the counted set generated from B: 

and compute the next value of from the previous value, instead of calling again. That is one multiplication and division instead of . 

Your printing of the numerical IP addresses with does not work correctly, the second argument must be the address of a and not the address of , for example: 

However, I can see no advantage in this "magically swap two bytes without temporary storage" and would rewrite it as 

is a GCC extension which is also understood by the Clang compiler, so you can use it in your Xcode projects. The advantage is that it causes a compiler error if the condition is not satisfied, instead of failing later at runtime. 

otherwise the number of bytes written is added multiple times to the total counter if multiple calls were necessary (and then can crash). With the outer loop 

This is unnecessary complicated and has an unwanted side effect if the message contains non-ASCII characters (which are encoded as 2 or more UTF-8 code units): 

This is also a valid use-case for a forced cast: If it fails then we have a programming error, which should be detected early. You could even replace the three view controllers by a single one in the storyboard. The only difference between them is the background image, and that can be loaded (e.g. in ) depending on the chosen league. With respect to the duplicated button action code: I find it acceptable for three buttons. An alternative is to add outlet connections to each button in the and connect all buttons to the same action method: 

Further remarks and are equivalent notations for an array of integers, but I would suggest to use only one of them consistently. The comment in 

Actually I don't know of any case (in Swift 3) where this cast can fail. Things change a bit in Swift 4, as a consequence of SE 0170 - NSNumber bridging and Numeric types. Your code still works fine, and is equivalent to 

Then you can compute a tuple describing the sorting order for each phone number, and sort the numbers accordingly: 

Your code tries all \$ n (n+1)/2 \$ combinations of array elements to find the combination with the largest sum, so the complexity is \$ O(n^2) \$. A better solution would be to find the two largest elements in the array, since adding those obviously gives the largest sum. Possible approaches are: 

The variable name suggests a boolean condition, but the value is an optional range. It would be clearer to make it a boolean value: 

There is a catch (!) however: Existing objects already loaded into the managed object context are not automatically removed, and doing so it a bit tricky. See $URL$ for more information. 

Your generic pack/unpack functions can be called with arguments of any type, and that would give wrong results or crashes for 

Here are some suggestions for stylistic and idiomatic changes and simplifications. Naming the enumeration cases The enumeration cases should be lowercase, according to the Swift API Design Guidelines: 

and for the range I measured 0.7 seconds. So this might be sufficiently fast to pass the challenge. For even better performance, use sieving methods like the (segmented) sieve of Eratosthenes (see for example $URL$ 

Your code works – as far as I can see – correctly. But I would rewrite it a bit to improve the readability (and with it the maintainability) of the code. The function name is quite general. That could refer to reversing an array, string, or whatever. A better name might be . The repeated cast can be avoided by defining a variable 

Example 2: Your table view has 2 sections, so must be or , every other value would be a programming error. Again, fail early instead of hiding the problem: 

So it is good practice, and you need not worry about the performance. Note also that all Objective-C APIs from the Foundation and other frameworks which return an , are imported into Swift as ing functions. By throwing an error (not an exception!) you can inform the caller that the method failed and provide additional information about the problem. The caller has the options to 

For an upper bound of 10,000, this took about 0.001 seconds on my MacBook Pro in Release mode. But creates an array of all that numbers, which costs time and memory. If you use a range instead 

Remark: For Swift 4 one has to replace the invocations by the method of the protocol (compare SE-0173 Add ). For example, 

Let's do this from inside out. is correct, but there is also a dedicated method for strings. The loop to find the first dictionary entry with a matching prefix can be shortened to 

but not with the other two approaches. Another argument for approach #1 is that it resembles the existing method to join strings: 

Defensive programming (never force unwrap, no forced cast, ...) is good and important to handle "runtime problems" gracefully: Unexpected user input, failed network connections, I/O errors, and many more. But programming errors are a different category. Example 1: If 

Closing a path automatically adds a line segment from the last point to the first point of the current path segment, i.e. the final in is not needed, and it suffices to pass 4 points to the function. Also I would not make the return value optional. Passing a wrong number of arguments is a programming error and should be detect early in the development instead of silently ignored: 

method searches only one level deep for the first responder. You could implement it using the recursive search as 

and this reduces the time to 0.016 s. In you are using a tuple with named components internally, but return an unnamed tuple . In the calling function the return value is assigned to a named tuple again. I would recommend to stick to one variant, e.g. the named tuple: 

Declare variables at the narrowest scope where they are used, and not at the top of the function. For example 

I assume that is fast when computing an integer power of , but if you want to avoid it, you can compute the factorial by recursing to or , depending on the sign of : 

( flushes the output file in addition to writing a newline character, which is not necessary here. On the other hand, it does no harm because this part is not performance critical.) In the inner loop, an RGB triplet is appended with 

I usually assign the sort descriptors to separate variables first. This may be a matter of taste, but it avoids too long statements if there is more than one sort descriptor: 

Throwing Swift errors is a mechanism how a function/method can report a failure to its caller. Your code throws and catches the error within the same method, and I can see no advantage of using try/catch in that situation. Your code is equivalent to 

With that change, your program computes all practical numbers up to 200 in 0.2 seconds, and up to 1,000 in 25 seconds (on a MacBook, compiled in Release mode, with optimization). 

But there is still a chance that the error remains undetected during development and the deployed application crashes later. 

This and other PEP8 coding style violations (most of them related to spacing and too long comment lines) can be detected by checking your code at PEP8 online. Unnecessary comments There are some comments which add no information to the code and can safely be removed, such as 

because returns an optional. But this is not very effective. The method always traverses the entire array, but only the first (and only) matching tuple is needed. This can be achieved with : 

the array size is specified twice, which bears the risk of changing it at one place later but not at the other place. That is avoided with 

and use that instead of the hard-coded period. But that still does not cover all invalid input, such as "12-34-56". There is a better (and simpler) solution: Check if the new string after replacement can successfully be converted to a number, using a . That will recognize valid numbers according to the user's locale correctly: 

This can be improved a bit if we restrict the extension method to the protocol instead. This is not a severe restriction, because all current floating point types (, , ) conform to . The advantage is that a value can be initialized from a : 

These tests fail if is used instead. All feedback is welcome, in particular suggestions how to improve the performance. 

with your code, this takes approximately 5 seconds on my MacBook. It can be improved slightly by filtering the list only once in each step and not twice: 

Finally note that your function considers all number below the given parameter, so you should either call 

You check if is not nil, but even then can be nil and the force-unwrapping causes a crash. A safe and concise solution is to use optional chaining 

This automatically leads to factorizations with the factors in increasing order and without duplicates. As a side effect, the function is not needed. Here is a possible implementation. (Please take this as a demonstration of the algorithm only. Java is not my first language, so there may be more idiomatic ways to do implement this.) 

Benchmarking code for the Eratosthenes generator: Calculates the sum of all primes below 10,000,000: 

There is too much logic in the class. In fact all the static methods are used for the "Secret Santa" algorithm, and do not use any state of the class. I suggest to create a separate class for that purpose: 

Then and should be computed only once before the loop starts, and not for each loop iteration. There are also problems in the analysis of the computed date components: 

First note that there is no need to make the properties (implicitly unwrapped) optionals, as they are always initialized: 

Here, modifying the elements of modifies the elements of as well. I would simply omit the boxing and store the elements just as an array. Modifying the elements is then done via a subscript setter: 

because it is assigned only in the method. If you open the database in the method (making it a throwing initializer): 

and that condition is violated in your code. Second, you chain multiple calls. But the method is not stable, which means that the later sort can destroy the result of the previous sorts. For both reasons, your code may give correct results, but you cannot rely on it. So (unless you have a stable sort method, which the Swift standard library does not yet provide), a multi-level sort must be done with a single call to . Let's start with an example: Assume that you have a type with and properties, then 

Your method works correctly, as far as I can see. For a read-only computed property, you don't need to enclose the getter method in : 

Now this is confusing! A function called which returns a single integer? or would be an appropriate name. The forced unwrapping is acceptable because the input comes from a programming challenge with well-defined input. However, finding errors in your code is easier if you check the optionals explicitly and print an descriptive error message if the input does not match the expectations. And with a short description (using the "markdown format" which is recognized by the Xcode "Quick Help inspector") it becomes a reusable function for this and future programming challenges: 

Your code assumes that the host byte order is little-endian, which is the case for all current OS X and iOS platforms. On the other hand, Swift is open source now and people already start to port it to different platforms. I have no idea if Swift will be ported to a big-endian platform at some time. I would at least make that assumption explicit by defining 

In contrast to many other programming languages, this can be expressed in Python more succinctly as a chained comparison: 

Forced casts should (and can!) be avoided in most cases, in the same way as forced unwrappings. The program would be terminated immediately if the cast fails. In your code that is quite easy, by replacing the type checks by conditional casts . The latter return a value of the type and that makes the forced cast unnecessary. In addition, it simplifies and shortens the code of the failable init method: 

There is one more thing ... This can still be improved by using the mathematical structure of the problem. All primes > 2 are odd, so the sum of two consecutive beads must be odd, i.e. the sum of an even and an odd bead. The bead #1 is fixed at the first position, therefore all beads at odd positions must be odd, and the beads at even positions must be even. Or, putting it another way, a bead at position must only be swapped with beads at position . And that is now almost trivial to implement: Just replace the for-loop in by: 

the file size it computed for each loop iteration. Better compute it once and store it in a local variable. In the function 

which is now slower roughly by a factor of 3 than . Other possibly useful technique is to avoid reallocations of the array element storage by calling 

It would be interesting to know why the library function does not work for you, but here are some remarks to your code: 

is from the Foundation library and works with instances. The previous method works because the value is automatically wrapped into an object when added to the counted set. This conversion can be avoided by using a native Swift dictionary instead, which makes the code much faster: 

Note that does the “test and insert if not present” with a single call. Another (more flexible) option is to pass a closure to the function which determines the uniquing key for each element: 

there is no need to check for (and return a dummy cell in that case). If the array is empty then returns zero, i.e. the collection view displays no item at all and will not be called. 

That looks like a clean implementation to me. One minor thing: I find it more natural to assign the new index before the array is extended, so that you don't have to subtract one: