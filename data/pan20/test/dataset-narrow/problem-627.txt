Instead of having an argument, should I rename to ? The main issue I see with my current method can be seen in my example above, makes it look like you're setting the value of to when in fact you're setting the next value to "id" and disabling escaping for it. Is my character escaping code enough to prevent injection? I found the list of characters in the mysql_real_escape_string documentation. What do you think of my commenting? Is there enough and does it make sense? 

The main issue I have with my code is that I feel it's a bit long and complex for what it is accomplishing; is there a simpler way to do it? I'm not sure how relevant this is but this code is part of a Dockerfile parser. You can find the Go implementation here. I know the Go implementation is much shorter, however I tried implementing their design and it ended up rather large and "non-pythonic". I am actually using the original logic from the Go parser but with a custom state enum and parser state object. 

The input string is split by spaces, counting any text between quotes (either single or double) as a single "unit" of text (i.e. not split by spaces). Any text wrapped in double quotes can be escaped using a backslash. For example: becomes . Any trailing backslashes are stripped. 

I don't really have any "burning questions" about my code; I'd just like some feedback on what people think of it and whether anyone can see any improvements. 

I designed a "Ticker" based on how I imagine Minecraft's tick system works. My ticker calls a method times a second and provides a Delta Time value () to the method being called. The issue I have with my code is that I find the method (which handles timing) to be ugly but I'm not sure what I can do. My ticker class is designed to be instantiated and used whenever, it does not have to be used right away (which is why I don't set any time related information in the constructor). This is why there is a check for and being inside , as to ensure that the delta time does not go crazy on the first tick. The issue with this is that it looks a bit ugly, however I'm not sure what I could do. I could move the reset code into the method, however that would now mean that the method is time dependant, and must be only be called when you intend to use the ticker. 

I'm not to sure on as it's not that obvious that it is a class, however I don't know whether or is better, as they're both just as clear as one another. 

Each plugin must inherit from , and is loaded by the class. Here's an example plugin: plugins/first.py 

Maybe only pad individual columns instead of the whole table, as if one column is really wide we currently end up with them all being really wide. I don't know how I feel about the large in the constructor, it looks like a bit of a mess but I don't know what I can do to remedy it. The method looks like a bit of a mess too but I don't know what I can do to fix it. One thing I don't like is how I've extracted so I can access it from the . I could bind the method but I don't really like having to do that if there's another way around it. 

The output from my function is , which is a list of the nodes traversed before finding a cycle. Here is the code I have written to generate the array: 

I've got the following code that I use to output a list of all (public) fields in an object in an easy(ish) to read way. The issue with it is that the code is not easy to look at, and I'm not sure what I could do to improve it. I'm not too fond of all of the StringBuilders, the calls are ugly and chaining them does not help the situation however I can't see a better way of doing it. 

I am primarily looking for feedback on my testing code, however feedback on the map implementation itself is also very welcome. A few questions I have about my tests: 

There's one main issue I currently see with your code and that is that if the admin does not have a home configuration directory () then it will be created asynchronously. The issue with this it that your second call won't wait for this, leading to a race condition where you're trying to make (and write to) a path that might not exist yet. One solution for this is to have a function inside your function that handles the "second half" of your creation (i.e. the config location creation and file writing). 

I have written a basic event emitter in JavaScript and I'd like some feedback on my design. I tried to make it as simple and minimalist as possible, as I'd like it to be understandable by anyone. I have wrapped the code itself in a top-level "module" that adds it to the global namespace under the name . I have also attempted to document it to the best of my ability using JSDoc. The code 

Gripes One thing I have considered doing is putting the , , and methods into a function which accepts the object. This would mean I wouldn't "pollute" the function signatures with an argument never seen by anything outside of the events module. Is this something worth doing? Also, should I expose the method to things outside the events module? I can't really think of a case where it is needed. 

The white node is the one we are starting the traversal at. The JS representation of this graph would look like this: 

I don't like how the variable works â€” it seems a bit of a hack and there's most likely a more mathematical way of working it out. Are there more "ES6-y" ways of doing what I've done? For example using or similar functions. 

I have written some simple code to detect cyclic dependencies for a module loading system and I'd like some feedback on how I can go about improving it. The code itself finds the first cycle in the dependency graph that starts at the provided node and returns a list of all of the nodes traversed along the way. Here's an example: 

I have written a simple C header for converting the endianness of integers and integers. It uses the GCC macro to check the system's byte order and define the macros based on that. The header creates the macros , , , which convert the value from host endianness to the endianness specified. Here is the source for : 

I have written a simple wrapper for and that allows me to build and run my image without having to use the command directly. Here's the layout of my code: 

I have written a function that fills in the values between points and creates one continuous path (essentially walks between the points) and I'd like some feedback on it's implementation. If two points are provided that are not "in line" with one another then an error is thrown, as I do not want to support diagonal movement. Here is an example of the code's input and output: The route to walk 

I have written a simple JS module "loader" (loader is in quotes because it doesn't actually load the files) that is designed to resolve simple dependencies between modules. It is heavily inspired by module.js and takes some of it's design from it. Here is the code itself: 

As you can see, the program found the longest line to be near the top in the middle. The program is only looking for a 1 block wide line, which is by design. It also supports looking for the longest horizontal line too, which is not shown above. Code 

Is it a good idea to just test the methods that have the "complex" logic? Am I testing everything I should here? How is my test documentation / commenting? Is it explicit enough (or even too explicit)? Does it tell you everything you need to know about the test? Is my constant alright as it is or should I directly inline the values? e.g this: 

I'm rather new to shell scripting, however I'd like to ensure my scripts are as robust as possible, is there anything I can do to improve their robustness? 

I have written a wrapper for Java's class using Java 7, which is designed to only iterate items that match a certain filter. When the filter is null, all items should be iterated. 

A while ago I asked for a code review of my automatically keyed map and I have recently had the time to get around to writing some unit tests for it using JUnit4. The test ensures that all of the "primary" functionality works, i.e. the things that could actually go wrong. The reason I don't test every method is that half of them forward their implementation to the map being wrapped. Here is my current code (thanks to @Tunaki and @h.j.k. for their help in improving my old code): AutoKeyedMap.java 

This would allow me to create a map of objects and their classes, and if I set to true it would allow me to have a non-overwritable map of objects and their classes. The primary use of this is in an Entity Component System, where I can keep a map of classes and their corresponding components (as you can only have a single component of each type). I have one main "gripes" with my current code, albeit not that large, but I'd like to see what others think. I think that the documentation could be better - in it's current state most of the documentation is rather pointless, as it doesn't really tell you much about most of the methods. I'm not sure if this is a good thing or not, as we are pretty much re-implementing for the most part (excluding one or two methods). 

I have written this "Polyfill" for Chrome's object and I have some concerns about the implementation; 

Does it actually work as designed? It seems to work but I'm not sure if there are any "edge cases" I am not accounting for. Is there a better way to do it? The inner function way seems a bit odd, as I don't like how I the works. 

I have written a class that is designed to be an automatically keyed in Java. Here is my implementation: 

I have written a wrapper for my code that allows basic namespacing and I'd like some feedback on how it can be improved. It is designed so that a module can define it's namespace and get access to all of the parent namespaces. These are spread in reverse order across the arguments of the module (i.e. is passed as ). Here is the code itself: