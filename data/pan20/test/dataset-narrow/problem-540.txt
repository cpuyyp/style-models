I think your code is complete, but not the most efficient it could be. There are two areas where there are inefficiencies: 

Test cases From an interview perspective, I would suggest that you're missing the test case for the null-handling. Creating full unit test cases in an interview is overkill, but is it too much to just add: 

This question was mentioned in The 2nd Monitor as one which could use some more input. I looked at it, and decided that the Android aspects are not where my expertise lies, but then, when I looked further, I found there are other things to consider too. First up, I am going to assume that the android and classes can be loosely represented with the AWT and classes too. This is a stretch, I know, and it is something you need to take in to consideration when you read my answer. But, I assume the similarities are close enough for "engineering purposes". Now, I took your code, and "redid" it in AWT constructs. It looks something like: 

Solution 2 The second solution you have is similar to the merge sort in some ways, but not exactly. The merge sort is a stable not-in-place mechanism. While your solution loops through the content once to count the even numbers, I would also recommend a solution that just has one insertion point. Note that you test the evenness twice for each value. The following solution also does that... it's not worse: 

Right, here we now have a sorted list of Values. Each Value has pointers back to the list(s) they came from. The space complexity for this is O(kn) and we got there by doing a complexity O(kn) nested loop (the inside while loop does not count because it is on an iterator that is outside the for loop, and it is part of the same complexity as the inner for loop)... OK, so that is the O(kn) preprocessing. The lookup is a case of doing a binary search on the ArrayList ( O(log n) ) and then iterating over the index pointers ( O( k ) ). Thus, the search is an O(k + log n) Voila! 

But, in reality, you are not... you only print the first item from the 2D array, and the rest of the board is printed from the constant string values. See this article describing C++ array initialization 

Note that the above stream technically has side-effects in the folder, as the folder is stateful. Here's the complete code I have for the above solution. You should be able to copy/paste and run it: 

Then, at the end, your temp array is populated with the longest solution from any index onwards, and, since we are only interested in the best solution overall, we just need to look for the highest result in the temp array. So, using memoization, and processing the data from the end of the set to the beginning, you can end up with a relatively efficient \$O(n^2)\$ algorithm. Update: the full working implementation would be: 

Really? That's a . Don't you mean ? The next obvious item is that the function should take the number of digits, and the input sequence, as parameters. I would expect a function like: 

The basic premise of your sort is good. The code is neat, and, if you know the merge-sort, it is readable, and does the right sort of things at the right times. With just your code in front of me, I would say 'good job'. To make it better, I would recommend that: 

@chillworld is correct in his observation that the issue is related to the int overflow causing the problems in the performance tests. The more accurate solution to this is to use a to set the score, instead of an . 

It is 'standard' to have at the beginning of the 'alphabet' for numbers.... I would have suggested that you use the native functionality in BigInteger to convert the value to a String in any given radix, but unfortunately, it does not support more than radix 36. Still, you should follow that standard and start with instead of ending with it. I would also suggest two things: 

the methods do not use any instance state information, so they should probably both be static methods, and should the main method there be public too? The last two conditions in the cascading if/else statement are: 

There are some things you are doing wrong with your ClientThread setup. If you want the client threads to die when the main thread stops then you should set them to be Daemon threads: 

And that code is obviously broken, it returns 1 when nothing matches.... For the input it returns 1... which is not what it is supposed to do. This second bug works to make the first bug disappear... because now anything matches! Alternate Solution Putting it together I figure the code is broken.... This is how I would solve the problem... a set-up recursive method, and the actual recursion. The setup method does the work of identifying whether there is a prefix match on any of the words. If there is a match, it recursively matches the subset words with the target until there is just a 'tail' left. When I wrote it I assumed that a subset word could only be used once, but, then when I compared it to your results, I found that this is not the case. I have commented out the code that enforced the use-once rule on the subsets..... 

The error handling is also really horrible.... use exceptions! Finally, why do you have a method on the Stack? It returns a value that is a private-context , so nobody can actually call that method.... right? I am half-surprised that Java lets that compile. The "final" Stack class could look like: 

I am not at all certain that it is more readable, but, it is not horrible either. Here are the performance numbers based on neatifying 1000 random long values: 

I believe the only decent solution would be to do something like guarantee sequential processing until the data leaves the phase, and then add a map phase at that point which numbers the that exits at that point. 

Your code looks functional. I quite like the idea of splitting the data in halves each time too. There are some things I would do differently, though. First-up, the 1-liner if statement: 

Now your search arrays contain the forward, and if the word is not a palindrome, it also contains the backward versions of the search list. Now you can remove half the directions to check, and you can remove your post-search palindrome removal logic. 

Out of interest, the difference between long-based and BigInteger performance is large. Here are the time differences for a set of calculations where the (long) calculation does and the (BI) calculation does 

I am sure there is a better way to compute the value mathematically, but brute-forcing the solution is quite a lot faster than the 6 hours you suggest.... I have 49/6 down to less than 2 seconds on my laptop... how is this done? Firstly, math is your friend. There are a fixed number of combinations that are possible: \$Cn = 49 \times 48 \times 47 \times 46 \times 45 \times 44\$ This computes to . These 10 billion combinations do not take in to account that the ball order of selection is not significant. Since there are 720 ways () to order 6 balls, there are really only 10bil / 720 sequences, (about 14 million - 13,983,816) of balls that are possible. These can actually be brute-forced. To brute-force efficiently, use primitives, no objects (and garbage collection)! Here's how to brute it - count the number of times each sum-of-balls happens.