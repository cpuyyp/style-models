As for whether there's a better way/algorithm, well, for a LinkedList, like you have, then no. The scan to locate the insert-point is needed. Finally, you should only create the if you actually locate the insert point. There is no need to create the new node unless you are actually going to insert it. 

With the above function, I would probably split the input in to chunks of say 1000 and call the timeRuns for each chunk. That way you can populate a steady stream of data in to chunks, time the chunks, and move on. You can collect all the individual times outside the timing loop, and then statistically analyze them separately. This way, you won't need warmup runs as you will discard the slow ones. Slow runs can also be impacted by Garbage Collection, and other factors, so discarding the slow runs makes sense anyway. You also remove the input-value generation, and the duplicate-processing by doing this. Even as it stands, I can see that this is a useful tool. I think the value can be improved by timing the right things, and being smarter about the reporting. 

Then, your class can simply have an EnumMap and the organizationId as fields. The serialization should serialize the map, and then, if the fields change, the serialization does not need to change. All you have to do is add a new Enum member, and a new 'getter' that pulls that Enum's value from the map. Similarly, the OrganizationBuilder can simply loop through the Enum to make sure all members are populated in the map before construction: 

Index the column with Maintaining this static data in a function would be a poor use of computational power, and make indexing harder. Your function would thus become: 

Don't output to a file. Output to stdout and redirect the results. similar to what vnp has, you create a logical stack, and 'increment' it. don't use recursion, the additional stack management is not necessary. 

That's a real problem. Println's are slow, and will likely be a bottleneck for you. Remove them. You are also dedicating just one thread to service the entire socket. This should be enough for a fairly high volume of echo's, but it's not huge. Your echo process does in fact do a fair amount of work. A lot of buffer creation, etc. which generates a fair amount of garbage. I would consider monitoring your garbage collection to see if you have long GC cycles. A long cycle may cause a backlog of connections to accumulate. Speaking of that, why do you do this for every connection? 

I like the solution you use by filling a set with all possible matches. This does indeed make the lookup a \$O(1)\$ operation. The naming, style, and presentation is all fine. I have a suggestion about the algorithm for computing the permutations of the starred words. When dealing with problems like this it is often most convenient to use bitwise manipulations.This will eliminate the cumbersome storage of the . To explain it better, consider the word . This has 4 letters: 

In general, recursion is a complicated technique. It is often hard to understand the state of the system at any point in time because you have to add a dimension to your thinking. I consider it to be bad practice to have a recursive process where the recursion is unnecessarily split across multiple methods. In your case, you have a 2-method split in your recursion. 

For beginner code, this is quite good. I am impressed. Good enough for me to assume you have worked from some example code. That is not a criticism, everyone does that (me too). Still, many examples are based on other examples, and they have some issues that are 'historical' in nature, and then there are some practices in Java which make sense which are not visible in your code. Style Really, it's good, no big problems. There is an extra empty-line in the middle of your if/else/else statement which is inconsistent. If I were to be extremely nit-picky, I would say that I personally would not put the empty line after the return statement (but like you I also would put one before the statement). Order of comparison.... I am not sure why I dislike this one, and I have no reference for it, but, you have the line: 

Now you are forced to create a instance that is pre-verified, and immutable. The content of that is whatever it needs to be for your actual implementaton. The implementation will know which handles are valid, and can do other things with the handle as needed. Because times are good, and Java7 is better, you should also ensure that your is so you can use try-with-resources. Your Exceptions (which you should create custom versions of) for your interface should all extend a single Exception class, for example: 

The title of your post puts a lot of stress on removing the loop. Can it be removed? No, it cannot. You need at least one loop to solve the fizz-buzz... Additionally, the 'print' statements are by far the largest bulk of your performance problem. I don't really believe that this code suffers from a problematic performance issue, but, if you want it to go faster, your best bet would be to accumulate all your String values and only print the line once: 

In your case, if the programmer gives you garbage, throw an unchecked exception.... and there is essentially nothing environmental that can go wrong. So, no checked exceptions from your method. Reliability - what can go wrong? In this case, right now, nothing. If something goes wrong it is either because the person using the method is an idiot, or you are an idiot. in either case, you will immediately be aware of that. Your code is simple, and works. For larger functions, it may not be so clear... But, reliability is about more than what is happening now. Reliability is making sure that things work in the future too. So, to improve reliability, write tests. Make the tests run every conceivable condition through the code. Run the tests every time you change the code. That is what makes code reliable. Tests. Tests, tests, and more tests. Then Regression tests, and compatibility tests. There is a common theme here, can you spot it? Scalability - this is a buzz-word that that you threw in because right now it is popular. What influences could introduce scalability problems in your code. In essence, only one thing: very large Strings. With current and older versions of Java (less than 3 or 4 months old), the memory is shared between String values. In your case, doing does not take much more memory (about 24 to 64 bytes depending on the JVM). In newer versions of Java (recent Java7 fic-packs and Java8), the substring command will copy the relevant inner memory of the String, and thus will take much more memory. Your code could have scalability problems since it will require a large amount of additional memory each time you do an insert. Now, whether that is a thing you should worry about.... no, I don't think so. If you have Strings that large, you will have other problems first. Performance - Yes, it can be faster. Is the improvement meaningful, I doubt it, but, for the record: 

All of the error-handling, logging, and the spaces-in-files can be solved easily by using a function for running commands. Also, the construct in bash is 'special' Consider the bash function: 

It looks like you have covered the bases quite well. There are some things I would like to suggest, and the first one is the most important: 

I think your solution, and also the one proposed by Claudiordgz, are overkill. You mentioned recursion in your question, and, recursion is the 'simple' solution to this problem. problem description: 

Are you sure you need these methods at all? There's a level of abstraction which may exceed the needs of your actual use-case. The context around your question is not complete, but your pattern is relatively common. There are three situations in which people write code like yours: 

General issues Your code relies on the global values and . These should be declared in a struct, and your methods should be on that struct: 

Sometimes a 'guard condition' is needed to ensure that input parameters create a valid condition that can be processed. Other times, you need a condition to handle special cases in special ways. In your case, however, there is a simple solution which you can affect by changing the limit of your for-loop. Currently, you have: 

is a bad name, and it is because you copy/paste code from a based method. In IDE's it is really easy to rename variables, even if the code is copy/pasted. There is no excuse ... ;-) Efficiency Apart from the above, I can't see any significant inefficiencies that need to be rectified. This code is run very few times, and is a low priority for efficiency. 

Generic Types You appear to have copied this from inside another class, or something, because you are missing the Generic type for the iterator . Also, assuming you get that right, there is no need to do the explicit cast inside the code.. the following line: 

EDIT This is a 'nice' problem, it ties in all the favourite educational problems, factorial, combinations, and permutations... Here is working code that runs through the process.... I have commented it where I think necessary. I am doing this so that I have a record on here of what things are, and can refer back to it later, if needed.: 

Separate Static class, and interface In this case, there is normally a class with only static methods, and an interface that is returned from these methods. For your code, it would require three classs (the enum would be separate).... 

Now, you can use that to get the ID and solution, once you have the instance you need. To get the instance, I would go the traditional route of adding instances to an array: 

switch statements for fast lookups The compiler is able to optimize a switch statement very effectively. Consider the following switch statement that converts a character in to the corresponding hex value. This is very efficient because it is based on fancy compile-time logic. It takes some effort to code, but the results are worth it: 

You have been overly enthusiastic in your type declaration for , I think, and it should just be removed. Also, there's no real reason to make it an . A simple will do fine - and you're probably on a 64-bit platform anyway. 

Putting those together in the outer O(c) loop, I calculate the complexity to be in the order of: O( pc2 + cp log p ) The O(pc2) will be the dominant complexity. If you move the Split to be outside the outer loop, and do something like: 

Code Drop This is the final version of the code I have. The code above has gone through a number of iterations, and was inconsistent in places: 

groupingBy I presume is a static import from Collectors? You should make these things more obvious. In fact, I dislike the static imports for most things..... you don't show much about . 

to the top of your class at the same place as your declaration. All class variables should be declared in one place. Use the library tools that are available There are a number of small tricks you can use to make your code simpler. For example, your method is: 

This removes the unboxing. Java conventions and idioms. Here it gets interesting. Mostly good. You have been passing around instances instead of instances, and this is a good thing. Many 'novices' pass concrete, rather than interface types. You have JavaDoc, and I always like seeing that. Unfortunately the details are very sparse in it. It's not worth having if it is not useful. You have used private, and public appropriately. My only real concern here is that methods are not static. There is no reason to link these methods to a specific instance of . Making the methods static would mean that you call them with: 

Now, is a value which may not be easy to translate directly to an integer. For example, because of floating-point inaccuracies, the intended Q factor may be 5, but the computed one is 4.99999999997 or something. 

In terms of the algorithm, the code is clear, and so on. The logic concerns me a bit simply because I am not that familiar with C++ (I am more familiar with XML)..... but, I have the following concerns there: 

There are a number of things that I think you have completely overengineered. Holder This can be replaced with SingleSnapshotMap This class exposes 4 methods: 

Overall I would have to say that this is the neatest and most clear implementation of a Merge Sort that I have seen. There is nothing wrong with variables , and . They are standard names for looped array indexes. There is a single empty line in your code which is inconsistent with the rest of the method. That is the only nitpick I can find in terms of the style and neatness. It is a tiny, inconsequential thing. The only recommendations I can make, are things that will improve performance, or will introduce some other common practices that may impact readability, though they are still more standard than what you have. First, some common practice things