As an alternative, since you already have the letters and their counts, sort the string then make the regex . 

You don't provide any example of how would differ from , so I can't be more specific, but here's the gist of what you should do: 

I realize this isn't necessarily faster, but it will be much easier to maintain, and at least one example ought to be posted using LINQ. So here's that example, using LINQ and the Combinatorics library to do it in a single statement, and in a more object-oriented manner*: 

Everything that's the same gets put into . Everything which could vary is defined as an method or property, and then the subclasses implement just those things which make it different. 

Here's a pseudo-coded recursive function to build the query, since I'm feeling lazy and don't want to double check all the string functions. I haven't tested it for speed - it might be too slow, but I think it should work. 

This removes the need to worry about casing, lets IntelliSense prompt you for valid values, and throwing an exception on an unexpected value ensures that you catch it during testing the moment it occurs, instead of the subtle "hey, this just keeps failing to validate" of always returning . 

Because of the short circuit here the function will not be called if value is , which is not the case if you pass the object directly. 

You mentioned OOP, and thats great, and OOP is all about code reusability and extensibility,and this code is a good example of a Candy Machine Interface. And that is, users of this class might do mistakes while using it. users could call the static the method before calling instance method and this would lead to wrong routes because weights weren't computed properly. You should try your best to force right behavior. 

The first thing you expect from a queue is to be able to , and for some reason you are hiding this function by declaring it where this should be . Do I really need to care about growing and shrinking the array in this queue, I am not supposed to know that they exist, so these should be declared . 

But the most important thing is, forget about using a for that. Open a new connection and close it afterwards, and will take care of connection pooling,you might need to add to your . 

I find this much more readable than trying to do conversions to an Enum, and more straightforward than a decision grid. That being said, it doesn't scale as well as either option. 

Another possibility would be to store the words in a dictionary of nested dictionaries. The key would be a letter, and the value is another dictionary of every letter that can follow that. Repeat until you've reached the maximum depth. For the sample case, this would look like 

The first method is an all-purpose "Add"-type method which will either add it or update it depending on whether or not it exists. The second is specifically for dictionaries where the value is a . It'll let you add an element to the , creating the key if neccesary. 

Back when using .NET 2.0, I wrote a class which inherited from , and a which inherited from . For legacy reasons we still use it, but I'm pretty sure it could be rewritten in half the code as a few extension methods. Here's a small sample: 

Note that here I am using instead of string concatenation, YOU SHOULD always use command parameters to avoid . Moreover, the proper way for closing a connection is not calling explicitly nor calling it in a , the proper way is using statement. And as mentioned in previous answers your queries can be reworked to stored procedures that accepts parameters from your application, and there is a lot of benefits from doing that. 

Please note, that CircularLL is not the best name for this class, I would call it instead. One more thing, initialising instance variables to is useless because it's done by default. 

and by doing so your types will be responsible for converting to in their own ways. The code smell in your code is adding to the factory. are factories but in a way, so instead of returning converted object immediately, I will return you a function that knows how to convert to objects. 

Threads??? Once you have threads in your code, your code becomes obsolete even if it was written 2 seconds ago. are the way to go, and you can easily replace your code by a single Task that keeps running and a function that accepts Tasks 

You could use instead of the in the second case, but I seem to remember reading that it's faster to do as an array than with LINQ. 

This will kick off a new solver run each time the prior one displays, up to the limits of what your computer can handle. 

LINQ has extension methods for any which will help with this. There's , which will return the first elements, and which will skip elements, then return the rest. Of course, these don't actually change the they're operating on - they just return a new one. But that's a safer pattern to use - it means you have the option of keeping the untrimmed version around if you need to. 

You're right that all the casting is a sign that there's better way. Rather than using the value of an as the index to an array, you should use a structure that's designed to store two values in the first place. There's a couple of alternatives here. My first instinct is to use a . That most explicitly matches the concept of what you're trying to do (each has a value ), but it's not actually the best option. You're not going to be looking up the value based on the key, the order of the keys may change which could lead to hard-to-reproduce bugs, and it's less memory-efficient. Instead, I'd use a , , or (in C# 7) . They're all effectively the same thing in this case, and best convey the concept "here is a pair of related values" without implying the A->B relationship of the Dictionary. (Note that you can also use arrays instead of , like I do below). To make handle this, you would need to make it generic, so that you can pass any arbitrary type in and get that same type out. Here's what the code would look like using C# 7's ValueTuples: 

Generics would be quite useful here, because your only works with , so your classes could be reworked to take type parameters 

Note: I don't claim to be an expert in principles, I do understand a bit though. Back to , violates the principle (The most frustrating concept to me). That is, when you add a shape you have to go and modify the code by adding an , this can easily solved by using , 

Your code will be easily broken if someone adds a node to the , and your code should be as flexible as possible. Never do such an assumption (It's gonna be the first node) Your method is blocking, consider making it . 

suit and rank fields should be declared private, no need to share things and deal with infinite number of states. 

You using for everything and hence no type checking. You shouldn't be able to compare oranges with apples, and the solution is simply to use generics. One more thing your code doesn't is convenience, what if I want to check if this value is equal to a value that a I can get from a method or from a different object without doing eager execution, and the solution is using lambdas. 

Then you can use LINQ to find matches by recursively building up a query which looks like: (ab)(bc)(ca) 

Edit: Stole the idea from Jesse C. Slicer's answer, but didn't modify the function signature. You can also return if that is more useful to you, or you can go with his idea of returning , in which case you don't need that at all. 

You'll still need to code each calculation function, but you don't need to manually attach each calculation to a specific crop or trait. You can just have a database table which tells the code "Crop + Trait = Enum value" 

Each grouping of numbers is an instance of a object, and we test if two are equal based on the items in each . 

Just to build on what @svick said, this is definitely not a good way to handle things. If you want to catch all exceptions, simply . If you don't want to catch everything, then only catch the specific types you want. There's also the block which you can use to do any cleanup which is necessary, regardless of whether or not you've handled the exception. 

has a high dependency on , why not to inject it and make the code flexible (easier to test and change). 

I wouldn't start this Task in the constructor as you doing with the ,thats quite dangerous, I would rather have a method called Start that does the heavy stuff where I am sure its gonna get called after the object got constructed properly. ADVICE: Such a data structure is reasonably hard to implement properly, I would try to find something implemented and tested. 

Such default values don't really make sense if the value is not valid. Imagine if you call the function like this 

. note that your connection is never closed, and thats a memory leak, you could make your class and close the connection there. 

This code here is a bit dodgy, you shouldnt never trust values you getting from the , so you got to handle the exception and refuse the request if the value is not parsable to 

There is no much code to review here, but I spotted that is not . You can use an AtomicInteger instead. 

I can't say that it's going to be more efficient, or better designed, but one option is to take advantage of polymorphism by creating a set of classes for this. 

is just a call to get as a (instead of an ). And so on... This lets you easily add a lot of logic ("Do I add this set of tags?"), doesn't require a multitude of s, and you can go back and add more things to a tag later. 

Heslacher is correct in that you should split this into two separate methods. That said, sometimes doing that isn't an option, so I want to point out an alternative to passing the "magic values" of and into your function. When you have a function argument that only takes a very limited number of values, you're usually better off replacing it with an . That enforces the limitation when you're writing code, and helps avoid typos and other subtle gotchas. 

If is your slowdown, you're not going to be able to get a huge improvement, but you can get some by parallelizing all the calls to it. Replace your loops with this version: 

When you see yourself going and editing the same function again and again to extend its functionality then thats a code smell. The problem is that whenever you add a type you have to add an if condition to your converter. So the conversion could be the class responsibility. in Java 8 you can use for that and if you don't have Java 8 then is your friend 

You might have notice that I called it instead of , because a map is a collection that holds things and things are plural. Note: If you need to iterate over a map, don't use iterator, use instead. 

Looks fine for me, but such a class should be , because it does not make sense to be able create instances of this type. 

And now you are sure that suit always has a valid value and there is no need for the error msg in the method. Your in the Card class is not type-safe, it will throw an if the passed parameter is not a Card, You can instead implement