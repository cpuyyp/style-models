I would definitely avoid having an event for each key, and certainly not an event for each key and state change. Worse, a 'held' event is very ambiguous as to when it should fire: once a frame? Once every X seconds? To keep full control of your input, it's better to poll at a specific point in your update loop. In that polling function (which I've called CheckForKeyPresses below), you check the current state against the previous state to watch for state changes. When that function is called, iterate over the list of keys you are interested in, and check if any of them are pressed or released now. If you identify that a key that is pressed now that wasn't before, or a key that is released now when it was pressed before, then you have a state change for that key. Once you've identified that is the case, call a 'dispatcher' function to do some work. E.g. 

I think the answers proposing DB solutions are jumping to a specific implementation without understanding the problem. Databases don't make merges easy, they just give you a framework in which to store your data. A conflict is still a conflict even if it's in an DB. And checking out is a poor man's solution to the problem - it will work, but at a crippling cost to your usability. What you are talking here falls into the distributed development model of problem. The first step I believe is not to think of players and designers as being separate types of content creators. That removes an artificial dimension to your problem that doesn't affect the solution. Effectively you have your mainline - the canonical, developer approved version. You may (probably) also have other branches - live servers were people are actively developing and sharing mods. Content may be added on any branch. Crucially, your designers are nothing special here - they're just content creators that happen to live in-house (and you can go find them and hit them when they screw up). Then accepting user generated content is a standard merge problem. You have to either pull their changes back onto the mainline, merge, then push out again, or pull the mainline changes onto their branch and merge (leaving the mainline 'clean' of user generated stuff). As usual, pulling to your branch and fixing there is more friendly than asking other people to pull your changes and then trying to fix it remotely on their end. Once you're working with that sort of a model, all the normal processes about avoiding merge conflicts apply. Some of the more obvious: 

I covered this somewhat in my other comment, but I think here you're thinking about external / internal classification. By removing a voxel, you are changing the voxels around it into 'edge' voxels (if they weren't already). This should boil down into 3 actual cases (symmetry gets you the rest of them) - in the example below the numbers are the group IDs, the - is the voxel being removed 

Since you're using indirect addressing (pointers or references), and you don't need to know the contents of the other object at declaration time (only at implementation time) this will work just fine in most languages. Obviously it falls apart when you have one object containing another (because to know the size of the containing object, you have to know the full details of the contained object). All of that is just semantics though, the fact that you can do such a thing is not a reason why you should. The problem that you'll face is that you are essentially tightly binding those two classes together. You can't have a Foo without a Bar, nor a Bar without a Foo. So you can't re-use Foo elsewhere without also dragging Bar along as well, and that may just not be appropriate. So if the only reason Foo needs to know about Bar is for one little thing, that might even be optional, that's a massive pain. For example, if you have a character instance which knows about an navigation state structure to run its navigation logic, but in turn, the navigation state needs a back pointer to the character instance so it can get, say, its position. The navigation logic might also be applicable to vehicles, but you can't use it, because navigation is assuming that it's hooked to a character. A much better approach to this is to understand what the back-pointers are being used for, and define an interface which can be used instead. Instead of having a Character* pointer, the navigation state has an IPositionable pointer (and Character implements IPositionable somehow). Now the navigation logic doesn't care how it is used, and can be re-used for characters, vehicles, anything. Better yet, the navigation logic could be split out into its own library / module, because it now has no awareness of anything above its own level - it's nice and self-contained. Game development is not special in this regard. If you are producing many such tight circular dependencies like this, it is because your structures are poorly designed. This is a normal software engineering problem, and all of the same guidances apply. 

In many common AAA titles (Source engine games especially), when the player reaches an area 'un-catered' for, such as out of bounds, or noclipping under the map; a strange effect occurs on the screen (buffer tearing?). It can be described as being similar to the trail of windows that Windows XP may leave behind a window being dragged whilst theres a system hang. I can only postulate that the developers do not clear the color buffer when refreshing the screen? Is that correct? If so, why? 

If that is the result in vPosition.z (ie the clipspace Z), how does the driver clamp the depth values for representation? Although its been verified as correct against other implementations, here is my perspective matrix creation code: 

Yes. It may not be the blood flow simulation that gets you as such, but the implementation of the application to a worthwhile standard. I imagine its to that effect you are graded on the project aswell. 

The following three concepts are implemented into the method for tiles (ie when a pair is confirmed, both tiles are set as empty). 

Metaballs in 2D Estimated mass from size of Metaball Estimated surface tension (a constant) Whether F=mg is enough to overcome the surface tension. 

Albeit, you will need to make a method which returns a set of tiles that are classified as adjacent tiles (ie, if you classify a empty square that is diagonal away, as connected, then it must be in this list, but it must also be in the logic for ). NOTE: I have renamed Davids function to , for the sake of clarity. 

I'm having trouble understanding the behaviour of my OpenGL program; and in drawing my Z-Buffer out to the screen. It will probably be best to just start with code, here is my GLSL shader: 

In extending seanmiddleditch's answer, I thought I might shed some light (irony?) on the gravity field idea. Firstly, don't think of it as a texture, but a discrete field of values that can modified (a two-dimensional array, as it were); and the subsequent accuracy of the simulation could be the resolution of that field. When you introduce an object into the field, its gravitation potential can be calculated for all surrounding values; thereby creating a gravitation sink in the field. But how many of these points should you calculate before it becomes more or as ineffective as before? Probably not many, even 32x32 is a substantial field to iterate for each object. Therefore break the entire process into multiple passes; each with varying resolutions (or accuracy). Ie, the first pass may calculate the objects gravity represented in a 4x4 grid, with each cell value representing a 2D coordinate in space. Giving an O(n * 4 * 4) sub-total complexity. The second pass may more accurate, with a 64x64 resolution gravity field, with each cell value representing a 2D coordinate in space. However, as the complexity is very high, you can restrict the radius of surrounding cells affected (perhaps, only the surrounding 5x5 cells are updated). An additional third pass could be used for high accuracy calculations, with maybe a resolution of 1024x1024. Remembering at no time are you actually performing 1024x1024 separate calculations, but operating only on portions of this field (perhaps 6x6 sub-sections). In that way, your overall complexity for the update is O(n * (4*4 + 5*5 + 6*6)). To then calculate the velocity changes to each of your objects, for each gravity field (4x4, 64x64, 1024x1024) you just map the point masses position to a grid cell, apply that grid cells overall gravitational potential vector to a new vector; repeat for each "layer" or "pass"; then add them together. This should give you a good resultant gravitational force vector. Therefore, the overall complexity is: O(n * (4*4 + 5*5 + 6*6) + n). What really counts (for complexity) is how many surrounding cells you update when calculating the gravitational potential in the passes, not the overall resolution of the gravity fields. The reason for low resolution fields (first passes) is to obviously encompass the universe as a whole, and ensure outlying masses are attracted to more dense areas despite distance. Then use higher resolution fields as separate layers to increase accuracy for neighboring planets. I hope this made sense. 

I think it is also highly dependent on how your overall application is structured. You should ideally separate functionality as much as possible. Naturally we all want to see a code example, so I'll give it my best shot. Though to be honest, this all means nothing without being related to your own specific examples. Perhaps just do some basic prototypes, and when it gets clunky (and it probably will), re-factor. Iterative design accomplishes so much more than if you try to plan it all at once; in which case you meet constant mental blocks; and may even lose motivation. 

Basically, you're maintaining the full text that will eventually be displayed, the current text that is being rendered, and the current index into the full text. is the delta time since the last update and is the time that has passed since the last time you moved to the next character in the string. When that time (here in seconds) has gone past half a second, append the character to the current text, increment to the next character, and reset the time. 

Figured it out. It's due to the tile graphic extending beyond the tile. Update: I managed to work it out by playing with the tile layers. I placed foreground tiles in a layer below the background tiles. 

Here's how my classes look (condensed for clarity): First, define the deserialized instance of the SpriteSheetData: 

My goal is to display a tile map in isometric projection. This tile map has 25 tiles across and 25 tiles down. Each tile is 32x32. See below for how I'm accomplishing this. World Space 

Third, define the SpriteSheetContent with an attribute to identify its run time type (an instance of this class is generated at content build time): 

I'm using the latest version of Tiled Map Editor (0.9.1) to create isometric maps. I have objects that are larger than my tile size (64 x 32), so I am breaking them up into two tiles of the correct size. Below I show that the blue blocks are made of a top and a bottom (both of which are 64 x 32). You can also see that when I am placing these blocks side by side, there is some strange rendering overlap. Shouldn't the foreground be showing if it is rendered in the correct order? In that picture you can see 4 blocks stacked side by side with the problem, 2 blocks side by side with the problem, 1 block by itself without the problem, and 1 dissected block in its two components. Anyone know what's up? Note: this is the view from within the Tiled Map Editor itself, not from within my game. 

I want to emphasize that there are many ways to solve this and that you shouldn't fool yourself into believing that one size fits all with this problem. This is a little subjective and anecdotal from my own game, but here's how I view it. The world (level) and the beings that populate it (entities) are separate "things". That is, entities still exist even if the world doesn't and vice versa (ignoring realism for the sake of argument). That said, I tend to structure my object "ownership" in terms of a hierarchy of what populates what. For example, while the world doesn't own the player (or any other entity), the player does populate the world and is subject to its rules. A player (and other entities) in my game are managed by a third party. This third party extracts necessary data from both the level and the player when they need to interact (collisions, events, etc...). So really that was a long winded way of saying that another option is to do neither of your suggestions. 

I see that you've posted your own solution for how you handled the particular question, but I want to post what I do with my SpriteSheet assets in case it helps you at all. Note that my answer does not define a ContentTypeWriter or ContentTypeReader because I did not need to use any special writing or reading rules. ContentSerializer knows how to serialize/deserialze at content build time / run time because I've used native types. I've supplied classes for the serialized .xnb file generated at content build time and the deserialized final product used at run time. These are the four classes involved: 

You'll see that the error message tells you exactly what is wrong. You are passing arguments that are invalid for that constructor. You need to pass a object as the first argument and a as the second argument. 

I'm having trouble calculating the offset vector because I need to take the current rotation of the player in to account as well. TL;DR: How do I find a point relative to the player's current position taking rotation of the current player in to account? My theory is that it involves calculating a circle around the player with a specific radius that determines the distance away from the player and placing the points somewhere on that circle. I can draw a picture if necessary. Right now I'm on my laptop so it isn't draw-friendly.