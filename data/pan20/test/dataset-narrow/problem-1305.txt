If there is no build in functionality to find a angle in degrees from a Vector2 then you have to calculate it yourself. Luckely Java has an atan2 function since normal tangents only go from -90 to 90 degrees and you have to find out yourself to which "wind direction" you have to add that number based on the position of x and y within the vector. 

In this case the multiplier will be .66. So a total of 34% will be absorbed. Let's hava a look at a extreme example. 

Diablo 2 has a very sophisticated item system and I want to create something similar. But I am having a hard time getting the architecture right. In Diablo 2 most different kind of gear has different kind of attributes and they can all hold X amount of modifiers depending on the quality. However my server creates items randomly based on several factors. And each item is pretty much unique. To lower the amount of records a player can only have X amount of items. I tried to get some thought on "paper" and would like some insight in how this can be done properly. These are my findings: Having all my different kinds of gear separated since weapons have damage, boots alter speed and armor, shield give armor and block rate, etc. A modifier table holds all the modifiers and has a FK to weaponId, bootsId, shieldId and only one should be set where the others are null. I could add requirements in the main tables as well but in the diagram below I opted for a separate 1 to 1 relation table. 

To let your footsoldiers share a tile you should simply position them correctly after the pathfinding found the tile. If you are smoothing your path then each step should lead to the correct position for that unit within the tile. You can also have a look at flocking. It basically finds a single path for a group of units and moves them as a group. Implemented right you have great control on how the units behave within the group. But if the units are very restricted to the grid this might not be what your looking for. But for differently sized units on a tilemap you should probably implement clearance based pathfinding. If everything is setup already it should be easy to implement. What you do is give every tile a clearance value: 0 for wall, 1 next to wall, 2 for a extra tile away from a wall, etc how much you need. A tank that covers two tiles will need a clearance of 2 and the pathfinding system should find a path using the tiles with a clearance value of 2 and above. A flying unit could use 0 or higher. 

A single animated movie could take many years to render on a single beast of a machine. Since it is pre-rendered it does not matter how much costly effects like light bounces, shadows, etc we add to the scene. These movies usually get rendered by render farms where thousands of PC's are linked together working on the same job. The reason we cannot achieve the same quality for real time is simply because the machine needs to render the current frame in about 16ms to achieve a FPS of 60. A single frame for a animated movie could take hours to render on a single PC. In a game, besides the graphics, a ton of other stuff is going on. Each frame there are tons of calculations. Simply said, an animated movie does not need to calculate the damage taken by the player from a rocket launcher, you just animate the gibs and the polygons will render. Luckily there are some genius people walking around on this planet. Apart from better PC's that can render more polygons and larger textures there are some ingenious inventions made like normal maps that can animate light/shadow on a flat polygon very cheaply, making a boring 3D object look extraordinary detailed. Some of these expensive effects that make movies have that extra flare. 

Just store the position in the entity object as well. For dynamic objects I am using both arrays and I store the position of the object inside the object as well for various reasons. One reason is to use the array for drawing, if I only want to draw from coordinate (10,10) to (26, 19) because my screen does not reach the others anyway I can use the various arrays. But if I have an object and want to know it's position I have to iterate the whole array if I do not store it inside it. Sometimes I just use vectors for storing the position but a much better way is to create your own point/coordinate class with equals and hashtag overrides to compare. You can put (static) methods in this class to convert from screen and camera coordinates which are often vectors to your points for easy shifting between them. You know what? Here is a basic one I use: 

I added a normal map to a MR arch & design material in Max 2012. I have a specular in the reflection color slot and a diffuse in the diffuse slot. As i increase the intensity of the normal map i certain faces get darker and they get really "obvious". Last time i was fiddling with this the exact same thing happened which made me quit normal maps and all. Some UV's are overlapping and the normal map is made with the Nvidia photoshop plugin. My scene just has a daylight system with a MR sun and MR sky. Does anyone have an idea what is causing this? 

Is there anything I can do about this? Is there a way to tell the not to draw the stretchable area and just draw a part of it or perhaps shrink in size? 

Like Phillip said one should always optimize your models for a specific goal. That said, i want to add some extra info on the creation of 3D models. Nowadays the polygons are not the bottleneck but texture space is. Since we bake so much into the texture for details (think: Diffuse, normal, occlusion, light, etc) and a top notch graphics card can only store 1GB of textures. When an 3D object is close to the view it can takes up most of the screen which can be perhaps pixels. If that single object has a texture that texture is only partially seen since you only see a part of the object. So maybe of that texture is actually seen, this gets translated to you screen resolution and thus blurred. 4 textures for a single object (different map types) can easily take up . Where someone rather uses a texture space or larger for this object but that will take up about which would already be 4% from the memory of a graphics card with 1GB of memory. And that just for a smallish object in a scene of thousands. Besides this map and CG designers have plenty of tricks up there sleeves for reusing objects and textures. Still, less polygons means better performance. And since we can do so much with texture space 3D artists focus on contour (the outline of the model). It's not possible to make the outline of a model more detailed without adding more polygons, within a model we can use textures to make just a couple of polygons look as detailed as thousands. 

In some games you cannot reach 100% due to the amounts equipment give you. In other games this gets just capped at a certain percentage like 75% or 100%. Then there are some that lets you heal since you have such an affinity with that particular element. For solid arguments as to why any resistance above 100% makes sense would be a creature of fire itself that gets healed for 50% of the damage a offensive fire spell does. Of course when a meteor is involved the discussion starts again. You could make a meteor spell like this a 75% fire spell and 25% earth spell for instance. Another example would be a healing spell. In some games this healing spell does damage to undead. If the resistance of this spell goes over 100% it could turn to damage. In the end you decide what happens in your game, some things do not have to make complete sense as long as they add to the game experience. A guy that can shoot fireballs at ugly looking demons does not make much sense to me if i think really seriously about that. 

The face normal has been flipped on the UV layout. Selecting the face with the issue and mirroring it should solve it. 

Is there any reason you are using primitives over meshes? The engine shines if you import custom models. So you can avoid the tedious process of modeling in unity by modeling in a program that is actually designed for that. The only other way I know off creating something like a door in unity without using multiple primitives is coding a mesh for it by hand. Which is probably even worse then your method. 

The draw method I use seems to be for drawing a GUI but might be perfectly suitable for the task. Otherwise you have to dig into the sprite manager and find a way that works with this method. You could use a dictionary for texture reference like in your tile class refers to some texture and refers to another. In the line you are drawing your texture you would use your dictionary to give the right texture object. This way it should not create a GameObject and thus not create all unnecessary overhead. You can do the same for pretty much everything that does not need the level of control of a GameObject. Mind though, this way it will draw every tile of your map it most probably does not auto cull the objects like I think unity does with game objects. But just drawing what needs to be on screen is very easy. You know the screen/viewport size, camera position and the tile size. Some simple math should draw exactly what's needed. Still, unity is a 3D engine. It just supports 2D in a 3D way. But you can basically do the same thing for quads/meshes with textures and a Orthographic camera. Just drawing those meshes needed is pretty cheap. 

I'm not familiar with Unity but that Vector is pointing from the second point to the first point so running that on collision gives you a angle although in the form of a vector. You might need to run something like below to get a float with your degrees. 

Now we check the bottom and right points independently so if we just detect a collision at the bottom we keep moving to the right 

A bitmapfont consists of a image and a textfile that hold the position and size of each character on that image. Is there any way to create the text file with just a image? Or do I have to manually create the "atlas" for each character, which is kinda tedious. Here is a line for a character in such a textfile 

This is pretty much all you need to draw everything necessary and have collision working. You just build layers of these in this order from back to front from left to right from top to bottom. (It does not need to be in this order if every sprite fits within the tilesize.) 

Well, the answer of Vinayak Garg is good but since you work with perspective this won't be perfect. This is basically paralax mapping and works great for 2D games. But here you want to have the road dissapear in the horizon probably. If your road is straight then just extent on this technique and add many pieces until it is looking good. Whenever you leave a piece behind move it to the front. If you want a curvy rode you have to look in procedural algorithms to generate a path for you can use pieces to correct this path. Perlin noise for example can be used for "infinite" randomization. They use it for minecraft in 3D, you just probably just need a 1D variant that just controls the the curve of the road. ANyway, this is a lot harder to implement. 

My first assumption is that if you create a weapon with a projectile you have this script attached to it. I simply cannot help you with that. As Mougli talks about this he explains that if a wall or actor with the function/method will be triggered. Since we are not freezing walls or furniture we will leave that alone. Whenever another actor get's hit the is being called and like I already mentioned you are supplied by the actor that actually is hit . Now we can call that actor and do stuff with it by doing . So we want to increment a freeze variable? Then we need to supply this variable first too this actor. So first we need the script actor script. Let's assign a variable on top. Now we can access that variable from the method and alter it. in milliseconds. Whenever an actor is hit he gets his set to 2000. Now we need to make sure the actor is not able to move. We could wrap all the actors actions in a if statement stating and he will be frozen for it's entire life. The last step is to decrease the by the amount of miliseconds since the last frame often called something like deltaTime. The best lesson you should learn from this is to break down your problem into small steps. Try to define these steps and look around on Google for answers, like I did for the . However there might be a view catches. I'm not sure what the definition of actor is in UDK but basically anything that can be hit seems to be an actor. You might have to check in the method if an actualy player or character has been hit. Again I do not know the naming conventions but if you open a players script and it says something like then you can add the variable to the script. But then you will not be able to use . Now you need to cast it: if (other instanceof Character) //check if the actor is a character { (Player)other.freezeCounter = 2000; //cast other as a player and alter freezeCounter } This should get you on your way, otherwise I strongly suggest you tell your teacher to learn you the basics of programming first before telling you to code in a engine you barely know and afaik is pretty much obsolete (could be wrong on my last statement).