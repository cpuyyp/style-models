Unless you are running an old version of Raspbian the concept of run levels is depreciated. The equivalent to runlevel 6 would be . However, what you are doing should still work, except: 

Neither. "i386" is also known as x86; "amd64" is also known as x86-64. All Pi's are ARM variants, and not compatible with the x86 ISAs. The Pi 3 is ARMv8, which is backward compatible with ARMv6 (the single core Pis) and ARMv7 (the Pi 2). For this reason Raspbian is ARMv6, meaning any software you run on it must be compiled for that. There are a wider variety of ARMv7 OS distributions available for the Pi 2 and 3. It is possible to run a 64-bit ARMv8 (aka. "aarch64") on the Pi 3, but this should still be considered experimental as it seems the kernel does not support all of the SoC's peripherals and other components on the board. For the most part manufacturers do not distribute ARM drivers. It is the most common ISA used on mobile devices such as smartphones, but any drivers used there are unlikely to be compatible with available Pi operating systems. In short you are out of luck. 

If you are on the same WLAN and you do this properly then I'm sure it will be fast enough. You could stream video from the pi to the phone over the air this way no problem, and the amount of data you are talking about is obviously substantially less than that. If there's some kind of real time latency, it will be in the processing on the pi itself, not in the network (unless it's very congested, which a LAN should not be if it uses appropriate equipment). Point to point communication on local wifi networks is generally instantaneous. 

As far as I am aware, like many basic USB peripherals, those are reasonably standardized, and a stock linux kernel should have drivers available. 

I've got an extra sector there to avoid any kind of off by one misunderstanding of how works. There's a simple way to check if this worked: 

And presto, will appear. For those unfamiliar with this is a compression format; you need to copy that out and uncompress it, and note since you can't write new files to it must be to somewhere else. In one step: 

In this case it was not; 102 MB / 2.6s ~= 39 MB/s which is in excessive of what I have already tested as the read limit on the SD card (20 MB/s). This is because my RAM usage is low, and so would be in the file cache; it actually got copied directly from RAM. Hence 39 MB/s -- if I do the same as above directly to the hard drive I get around that. So that gives some indication of the max transfer speed to the drive. The USB bus has a theoretical max of 480 Mb/s (60 MB/s). Note that the ethernet jack shares this bus, but even when it is running at peak 100 Mb/s (12.5 MB/s), there should be enough bandwidth left for this amount to then go back through to the drive. 

and systemd are not on the boot partition. They could be. I notice there's no in that github repo; normally the parameter in that indicates the root partition, and that's where the kernel looks for (or whatever is specified as the parameter). I'm not sure, but I believe there is no default built into the kernel so without this, it will simply load, then stop since there is no root filesystem to work with. There also is no init included with the github stuff. There is no initramfs either, because the precompiled kernels do not use one. This is unusual compared to linux systems intended to run on a variety of hardware. In order for the kernel to be useful you do need at least one userland process. Conventionally, that's init. You need to supply that. 

The password isn't actually stored anywhere on the system, a one way hash of it is. This means even if you have the hash, you won't be able to deduce the password. The hash itself is stored in . Take the SD card out and stick it in another linux system; any common distro (ubuntu, fedora, arch, etc.) should do. On that system, create a new temporary user -- do all this via or as root: 

Should give you a list of running processes using the C++ library. On a default raspbian system that's not anything, so the list should be pretty short. 

POSIX systems such as GNU/Linux use root filesystems where each file has mandatory permissions set on it. The superuser (aka. ) on such a system can access anything. Raspbian exploits the sudo application to do something which would normally be considered moronic, since it short circuits a basic tenant of the permissions system, which is that a normal user used to e.g., browse the web, should not have permission to do anything. But via the user can. It's implicit in this that the default Raspbian configuration assumes: 

Really this is mostly an operating system issue, and not a brand-of-my-computer issue. Presuming you are using Raspbian or some other GNU/Linux variant, the OS kernel (which is what implements hardware drivers) is one which is used on tens of millions of normal workstations and laptops. That looks like a pretty standard wireless keyboard/mouse combo ("Fullsize, durable, simple"). USB HID (human interface device) protocols are standardized, and anything like that will be fine. There's only a potential issue when you get into zany mice with 42 buttons and lots of special features that require a proprietary driver. That Logitech product does not fall into such a category. I've used piles of Logitech HID ware with linux over the years including wireless keyboard/mouse combos. In other words yes, I promise it will work with the Pi 3. Note that by default Raspbian uses a UK keyboard layout. Because of this you will notice a few keys don't print what they are supposed to. To fix this, when you first turn the Pi on, you should be presented with a program called which lets you set various options (if not, just run at the command line). The fourth option of the main menu should be "Localisation Options". Choose that, then "Change Keyboard Layout" and select a US 104 key PC keyboard. 

This means the relevant libraries are available on the system and if you build an executable linking them, there should not be a problem. However, there may be a problem building the executable; in this case it seems when invokes the linker, is not in its path even though it is in the runtime loader path (they are not quite the same). If you use , you'll see there are some non-standard paths being used as options (e.g., ), but not that one. However, you can specify it yourself: 

This depends on the command (and note this applies to all multicore systems, not just the Pi 2). Not all tasks can be run in parallel. By analogy, consider a simple math problem 

Either something else in the environment is heating up very slowly this way or something is wrong; the third load average average number (presuming doesn't do something bizarre, which I don't think it does) is over 15 minutes, and it is higher than the first one, which is the past minute, meaning this pi has not been very busy for that period1 -- which should be plenty of time for heat to dissipate from the SoC unless, e.g., it is encased it with some kind of spray on insulation. In fact, I am sure I have read about people sealing the whole board up with thick plastic film for use underwater and not report overheating problems (the water may help with that, but I really think the manufacturer is telling the plain truth when they say it does not require any cooling or ventilation). Even if it were working 100%, I think a Pi 2 can sustain that indefinitely (presuming again it is not in a very constrained, airtight enclosure), without heatsinks or much ventilation, in 20-25 C air without ever going over 60 C; when I've run one that way it plateaus in the low - mid fifties after a few minutes then stays there. Of course, if you overclock it sufficiently, at some point that behaviour will start to change. 

ARM, the ISA family used by the Broadcom processors on all current Raspberry Pi models, is based on RISC, for which RISC OS is written. RISC OS I think predominated on ARM devices for their first decade, as the same UK based tech company (Acorn) originally designed both ARM and RISC OS. In fact, ARM initially stood for "Acorn RISC machine", and part of the reason the Raspberry Pi is called what it is is because of a tradition in the UK of naming computer systems after fruits or nuts. RISC OS is not a true real-time operating system, however, it does use cooperative multi-tasking, meaning you can run a process that can voluntarily refuse to surrender itself to another process. What consequences this may have I don't know, but I would assume that: 

You should put some kind of passive delay into the loop too, however, or else this will busy loop the processor (i.e., run it up to 100% constantly). How long that can be depends on how you are changing the value of the GPIO; if you are turning it off, 1 or 2 seconds is fine. However, if it is just a momentary change you are looking for (e.g., a button push), the gap will have to be shorter (say 200 ms) so you don't miss it. 

To find the paths of files installed by a specific package, you can use . It is installed by default as part of the base system. 

The simple answer is it won't hurt to try anything. Signal loss is a product of resistance, and all conductors have some inherent resistance, which decreases with the wire thickness (gauge) and increases with its length. So if the wire is too long or otherwise includes too much resistance to work, it simply won't work, and no harm done. Anecdotally, I'll say than several segments of commonplace 22 or 24 gauge copper strand jumper connected together for several feet work fine. However, you can easily calculate the voltage drop using Ohm's law if you know the current load and approximate size of the wire you're using. If you are not sure, assume 24 gauge since it won't be smaller than that. From the picture I would guess those wires are stranded copper with the ends tinned, although aluminum is sometimes used too. Anyway, this online voltage drop calculator, which includes a chart of resistances for wires of different types so you can do the math yourself if you want, claims that at the load stipulated on the Adafruit product page (2.5 mA), at 3.3V 5 feet of 24 gauge copper strand will drop the voltage by 0.03%, i.e., not enough to be relevant. In fact, judging by that, presuming the idealized context such calculations tend to presume, you would need close to a thousand feet of such wire before the voltage at that load would drop enough (say 5%) to become most likely infeasible. Although since the device will work with 3, with a drop to 3.1V on the way out, the drop to 2.9 on the way back would still be feasible on the pi if it is consistent since I believe that still counts as above the "high" threshold for signals. In real life I have no idea how reliable that estimate is, but presuming you mean you just want to insert a few feet of wire, it should be fine. You can use heavier gauge speaker wire to connect actual jumpers, since it is easier to find in rolls and offers less resistance. This is probably better than connecting more multiple segments as each connection could introduce an unpredictable amount of resistance. 

You could in fact do that test right now, and if it doesn't work, you need to do more research. If it does, then case closed. Although I don't know anything about the mechanism, I suspect it will because I have linux machines that do not run (i.e., they just have the time set and rely on a hardware RTC) which do change time for daylight savings automatically. 

This may drag in some other dependencies. Note if you are using a previous version of Raspbian it probably is not available. 

No. At least, not in a way that isn't constrained by the same transfer speed bottleneck as the swap problem already described, meaning you might as well just use swap. 

Something very odd is going on or you have an insufficient power supply. If a Pi 2 does not recognize a card, it will power on with both the red PWR led and green ACT led lit solid and stay that way. If it reads the card but has a problem with the firmware, bootloader, or kernel, the green led will blink in a noticeably regular pattern repeatedly. Generally, having the red power LED go off is a bad sign, as in, physical damage (or insufficient power). It is possible to run code to do so, however. If it is intentional, that is a strange choice on behalf of the creators of RaspBSD. I suppose there is some chance of it happening coincidentally, of course. If the red light does not stay on steady when you are using Raspbian, including after having halted/shutdown the system, your Pi is damaged (or you have an insufficient power supply). It should be on the entire time there is (sufficient) power attached. Did I mention insufficient power supply? ;) 

1. The fact that you can download the source and compile it implies it isn't really a licensing issue (although perhaps it is). The fact that Fedora now have a version of their ARMv7 distribution specialized for the Pi but using, AFAICT, the official Linux kernel, and that this kernel still doesn't support things like the SoC's soundsystem, implies some stuff may have been integrated into it from the Raspberry Pi Foundation kernel, and the claim there that getting this "supported in the upstream kernel...is one of the big items on the ToDo list" (who's?) further implies somebody is making an active effort to do that. I suspect the major reason is a lack of desire, and keeping it separate may be a good thing. But this is all just conjecture and not anything I've investigated. In any case, unlike various other similar ARM boards, The Foundation's kernel source is at least available and kept pretty up-to-date. 

Computers use a system called busing to connect multiple peripheral devices to the CPU via the same set of wires. I2C and SPI are examples of busing systems used with the pi GPIO pins, which enable multiple devices on the same physical pins (managed by the internal bus) but using different addresses. Addressing is an abstraction created by the bus system protocol. It is a little bit like how you can have multiple networked applications using the same physical connection to the internet, all running simultaneously. For example, looking at the RTC Pi Plus, one of the stackable boards from your example link: 

Presto, full screen. There does not seem to be a way to get it out of full screen (F11 doesn't work), but perhaps that is the point of kiosk mode. Initially, chromium has a residential memory footprint (i.e., actual RAM usage) of ~70 MB. 

My first guess would be permissions, because if you are using apache, by default it starts with privileges so it can open a low numbered (< 1024) port (HTTP is normally 80), then it calls to run as an unprivileged user (and/or it forks worker processes with an unprivileged UID that handle incoming requests). The apache user is often 48 ( or -- but see below), although all this can be configured. On raspbian it may be 33, . You'll see how to find out if you keep reading. So that's my #1 guess...