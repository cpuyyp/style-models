What are ? Global variables? Any reasons why they are not a of courses? What exactly is the relationship between , and ? Is some form of user input indicating the desired period the course should go to, to be set for one of ? The reason why I ask this is because clearly you are only checking whether is free for period . How is calling related to adding a course to one of 8 periods? 

is a public method that returns only an unmodifiable view of the underlying to prevent accidental changes, which is a good practice especially in this case. Conversely, is a private method which will be used in the block below to add values at initialization. It conveniently s itself for method chaining. Finally, the method is just used to defend against accidental repetition of values. :) The block to initialize both the and the values can be done in the following manner: 

Instead of putting the logic inside , you may want to consider abstracting them to be part of the enum. This brings the logic 'closer' to where it is used with, i.e. the base/target scales. For example: 

One small change you might notice is that I rely on instead of an implicit unboxing using arithmetic operators. Ideally, you'll want to check against values too. Using it will be: 

Some simple suggestions here... For Java 7, you can already use type inference aka diamond operator to simplify the following such assignments: 

Android's method naming convention follows that of Java, so your method name will probably be better written as (or maybe even ). Your check for comes in after you have toggled your UI elements, wouldn't that mean the state is possibly inconsistent if the method really received a argument, and then the UL elements already indicated the code is downloading something? You may want to return from your method first in this case... 

In addition, consider storing just the difference and the array index where you have the smallest difference, so that you don't need to remember . 

If I were to improve on your original solution, I will use to eliminate one nested and inline the arithmetic comparison together with incrementing as shown below: 

If you do turn this into a library in the future that can be used by other projects, you do not want to spring this surprise on them... If there are errors like this, should you simply re-throw the same error? 

My personal opinion is that methods can be less... particular about inputs, as you should be trusting enough of yourself/your team that you aren't introducing them in the first place. This is more true, I hope, when the method calling the method is right next to it, such that there is even lesser concern that s will be introduced. 

Oh wait, you did use that, then I guess this advice here is to let you know that method accepts varargs, which is just syntatic sugar for the array you are constantly creating. Working with numbers and code de-duplication With a bit of math, you can de-duplicate your -loops as such: 

An ordinary imposes no such restriction, only a . If you had gone with a -based approach, at least it's still a passable, good-hearted attempt at a 'map' implementation that only relies on comparison, which is ok in itself. As it stands now, I'll be very cautious using it as a 'map'-like replacement. 

Second, you should also consider converting and saving each of the integers you encounter in a single input line immediately, instead of storing into a array and then performing the conversion afterwards. This avoids the additional looping which you identified in your question. :) Come and think of it, putting all these together does sound like a good usage for Java 8 streams... Java 8 solution ahead So to conclude, the steps we need are: 

vs returns a , but that array is only used in a simple -loop, which I think a will work equally well too. The reason for suggesting the latter is that you can rely on to do it in a single step for you, which eliminates the need to have your own little method. 

arrays Your and can simply call the underlying method as the returned results will be the same. Java 8 stream processing In the spirit of Java 8, you can stream through your creation: 

can give you an of the string's characters, as long as we're talking about Western-based encoding. A that lets you apply some processing on a to return some form of results, e.g. a in your case. Converting an to by calling . 

Logic + unit testing You perform a check for the array to contain at least two elements, which means single-element arrays are conveniently bypassed. Do you actually want to consider them as magnitude poles, since all the LHS and RHS elements ("none", or \$\emptyset\$) are equal to it? :) I will also suggest writing unit tests as a means of documenting what are the expected outputs for various inputs - valid, invalid, and edge cases in all. The slight benefit is that you can safely optimize your logic later on, and have a safety mechanism to ensure the modifications still work per expectation. 

Type inference and naming conventions From Java 7, you can replace most of your type usage with just the angle brackets, which is known as type inference. For example: 

Rather than defaulting to , you might as well incrementally apply the decoding until you don't see , where is a hexadecimal character. This is (better) represented using the regex character class . replaces the and replaces the . The loop condition simply says: 

These two fields can be better placed as fields, instead of inside the method. On a related note, you may also want to consider turning this into an "utility class" and have the method as too: 

Conclusion It's always good to conceptualize what are the steps in your chunk(s) of code, and then wrap them into their own methods. This helps to facilitate an appreciation of your own code, which could uncover inefficiencies (e.g. doing something twice) or potential bugs (checking for a property in one place but not the other). More importantly, it lets you easily perform unit testing on smaller slices of your code, so that you can safely modify these smaller chunks in the future to be more efficient with the assurance that you wouldn't be introducing bugs. 

Guava If this is Guava we are talking about, then between the options you presented, I think it's still fine to stick with the original. Method extraction in only two places - just to 'substitute' two lines with the added complication of -ing different types altogether - is unnecessary here. And as you have observed, having to does look out of place too. Alternative I understand you are trying to unify the exception throwing when you have either no results, or no box from the given ID. In that case, perhaps you can reorder your checks accordingly: 

Is the code block really required in your method? Your fails if the default value is not any of those primitive wrapper classes. What if I want a instance? can't be casted to that. On a related note, you are relying on auto-boxing, which may lead to unexpected consequences: 

Short answer: You need the Java Collections framework. Instead of eight standalone variables , you should put them into a so that you can easily iterate through them: 

This comment is redundant as it does not say anything more than what the code is plainly doing, but more importantly, is hard-coded here. Since you already have an array, you can do something like here so that it's easier for you to add extra lines in the future (e.g. 365 days of Christmas for non-leap-years). Code duplication Your and methods are very similar, so you may want to consider doing some de-duplication here by generalizing the problem... 

For your implementation, since is not implemented yet, you may want to throw as that is the recommended usage. For your test class, is to add to the end of the queue and is to remove from the front. That is why queues are known as a first-in-first-out data structure. This is probably just semantics, but you should try swapping the operations around and see if there's any unintentional bugs. More info from Wikipedia. 

If you are fine with making an immutable class (as you seem to be doing now, since setters are ), then the right way of initializing with multiple constructors is to rely on constructor chaining. This encourages optional arguments to be placed at the end (for some definition of consistency), and then passing a reasonable default value to the stricter constructor as such: 

We use 's shell keyword to collate our conditions together. Helpfully, supports the use of and . is quite a useful (IMHO!) construct in for implementing a logic. The only thing to note is that you can only specify one command each for both branches. As such, we can 'inline' our increment of and do an always comparison to simplify our branching, namely to either () output the line to the output file, or () increment our . Otherwise, it gets slightly longer due to the required use of compound command: 

How about determining whether the number is an even number or not first so that you can do the building and optionally the summation in one loop? See the use of below... 

Since the smallest unit you have to deal with is pounds, you may want to consider representing prices as already so that you do not need this oddly-named method to 'transform' the price into a usable key. Alternatively, if you have to start handling pences, consider working in that base, such that this method returns you the value in pence, e.g. 27550 to represent Â£275.50. vs for Customer ID You can use for the customer ID, and let auto-boxing do its work when you want to use it as a key in your . Unboxing potentially values into an is bad, but boxing from an is generally OK. Comments You have very verbose comments in your , and I think your solution might have been a bit better if you actually incorporate some of those changes. :) On a related note: 

Note that is also used here, as it will likely offer better performance over the /-based implementation. Auto-boxing There are a few places where the use of the wrapper class can simply be done with the primitive equivalent. Again, some form of consistency here will be preferred, partly to aid in readability, and partly also to eliminate any possible chances of when you (accidentally?) create instances of . Better modeling class...? Given the various places where you are accessing the array elements, I wonder if using better modeling classes may be of some help here to improve the readability and to standardize the usage of the array elements. For example (reducing empty lines here solely to make it fit into the box without the scrollbars): 

A character value minus the character '0' or the number 48 gives you the number to pass to your String array (because has an integer value of 48 in ASCII). I'll also advocate over at the very least... it's easier to read. 

While you're at it, why not simply replace the classes with a 'modern' logging framework like SLF4J? The methods it offers handles the concatenation elegantly when logging is not required, so you don't even need the guard clause in the first place. Finally, your method can be simplified as such: 

For starters, I can make the method handle negative values properly as well (more on this in a bit): 

Since you are using a Swing-based UI, displaying such errors through the console breaks the user interaction. You should consider displaying error messages using the appropriate dialog boxes too. Comments I'm not sure if your comment about using Nimbus (with a reference to Java 6, when you are clearly using Java 8 already) really belongs there... Also,