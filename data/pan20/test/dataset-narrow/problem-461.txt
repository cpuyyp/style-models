because I have no idea how you instanced and set the dm object before, and you need to do the same here; I just added a generic call to the constructor to help you understand. Another big warning: you need to understand multithread programming, otherwise this code will sooner or later blow up in your face. Usually in the worst possible moment. 

So, one of the thing here is that the CPU is waiting for your hard disk to provide data, and then the hard disk is waiting for the CPU to ask for something. The first and more obvious point is that accessing disk to get a few bytes each time is terribly inefficient: disks (HDD or SDD is the same, in this case) are best for sustained reading. The OS cache will help you so that it will read a bunch of data ahead for every request you make, but you know you are going through the entire file so you shouldn't rely on the cache and try to be as efficient as possible in your code. In fact, as rolfl points out 

I don't think you are going to need a special for any of those options, simple (or any other panel), should work just fine. But it is hard to tell for sure since your code is rather hypothetical-ish. I do not know the actual use case or an actual problem you are trying to solve (if any). 

Mainly because it is impossible to tell at first glace where statement ends and loop body begins. Use offsets to separate them: 

To answer your question: those solutions are identical performance-wise. There is no "magic" in or methods: they do the same thing you do in your first solution - compare the two values using operator. There is no significant performance cost for a method call or for an extra assignment - those operations are so cheap, that you won't solve any real-life performance issue with this kind of optimization. If you will become obsessed with those small things - it will have a negative effect on your code quality. So, instead of asking, which is faster, you should ask yourself which is more clean, readable and OOP-ish. I would go with second solution. If you want to really speed things up - you should first identify the real problem. In your example - it is the number of iterations, not the number of assignments. So the faster solution would probably involve multi-threading and iterating through different parts of your array simultaneously. 

Edit Sorry, I was again thinking about point 4 above, got struck by a doubt, checked again, and here you are doing something that make no sense at all: 

190 MB/s is ridiculously low for an hard disk, unless is a 5-8 years old cheap model; right now even an SD card can be faster than that, sometime. From a decent SSD I'd expect at least twice that speed, and today even SSD in the range of 100$ can easily saturate the SATA interface. That is, you want to read big chunks of data every time; no matter what, don't read a line at time. There is no magic number, but unless the computer has serious memory issues 100 megabyte each time should be more than good. Now, problem is, while waiting for data the CPU is sitting idle doing nothing. Then, while the CPU is crunching your data, the disk is sitting idle waiting for something to do: needless to say this is time for some free multithreading. Deciding what to implement is a bit complicate without knowing the exact details and limits of the project, because you can simply have a number of threads equal to the number of cores, each one working onto an equal part of the file (easily doable in an hour total), or going to write a central dispatcher that read chunks of the file, create threads up to a certain limit (maybe doing some throttling), and collecting the results (and this can take up to a day of work). It all depends on money and time you have available to do this but, yeah, go for it. 

Without the link, I can only make certain assumptions, so I am going to give a couple of global comments: 

The reason for this is that now we only flip while it is necessary, because if the bottom of the remaining stack already contains the largest pancake, we do not need to flip. Meanwhile, we are also keeping the implementation clear: you first look for the largest pancake in the remaining to sort stack, move it to the top, and then to the bottom of the remaining stack. Using clear variable names makes it so other people can understand your implementation more easily (and even for yourself, if you would come back later). 

Note that will bring you to the same spot as . You can see that each of those share the same second parts as well. This is duplication which we can use to speed up the algorithm. If you think about it, there are generally multiple ways to get to some point . If you think of this as the starting point, the possible paths to the destination will obviously be the same, no matter how you get there. So what you can do is create a lookup table for a calculated location, so you calculate each one only once. This will give you an extreme amount of speedup I would think, on problems with a big amount of possible paths. Which you will get to quickly, even for small values of . 

IMHO, static method only makes sense for value types, when its impossible to mutate an existing instance and/or its hard to tell the difference between and successfully parsed value. For all other situations a constructor (for immutable types) or an instance method (for mutable types) will do a better job at keeping your code clean. I am OK with this (for immutable objects): 

You should also consider encapsulating your resource loading logic to separate class (or classes: one class per resource type). Handling textures and sound in single method looks messy. Single resposibility. EDIT: If you have to stick to the library of your choosing, then you should just use single output stream. 

How will those fit into your current hierarchy? One way to avoid those problems is to use aggregation instead of inheritance and treat each game object as a collection of arbitrary properties, that can be added to object or removed from it. You might want to look at how, for example, things are done in Unity, to get a better understanding of how things are actually designed in modern engines. To be clear, there is nothing wrong with having game object hierarchies in small projects. It is the easiest approach and sometimes it is enough, especially if all you want is to write some code. I just wanted to give you some perspective. EDIT Since this question is getting a lot of attention I though I might as well update my answer with a simplified example. First, you have to create some "components". For the sake of this example, you can think of components as properties that define the item and make it different and special. What is a fire sword? It is an item that: 

The content of the Parallel.For will be executed in multithread, so you need a unique instance of every variable you modify and for every class you call a method of, so keep an eye on the 

First and foremost, Phyton is not my language of choice (or in other words, I don't know it at all), so I'm just trying to add something regardless of the language. Yes, you would benefit a lot from multithreading here, it's quite a basic case. I give for granted that Phyton does nothing to complicate using of multiple thread, obviously, because doing multithreading itself is cheese task even when using the basic OS APIs. As a general rule of thumb, unless you are dealing with a really fast computation where the additional overhead added by threading will worsen the performances, there is no point in not using parallelism everywhere. It's one of the easiest things to do in computer programming, and it allows you to "choke" the hardware to the point that no matter what, you are granted to be going as fast as the PC allows. 

I agree with the answer given by Stingy. Also note that with the collector implementation you are not short-circuiting, so with a stream of a billion elements, you will still process them all even when the first element encountered is a left. That being said, I will comment on a thing or two for this implementation: 

I think overall it is a nice implementation. It is clear and readeable. The use of constants is nice, makes it easy to refactor the code to make it more generic later on (e.g. replace with given character, not just space). Clear variable names (although I'd try and be consistent, and use , or , most likely the former). I have two remarks: 

I can't think of a way with better time complexity, you have to know all values before you can sort. Though with some Java 8 stream capability added to the class, you could implement it quite cleanly as follows: 

Or just add braces (that's what I would do). is probably not the best name for a property, its too generic. Maybe or would do a better job at explaining its purpose. It would be nice to have some control over which properties are deserialized. You know, similar to how you can use attribute to skip a property during xml (de-)serialization. Unless what you do should be completely obvious to anyone working with Azure, you should add some basic documentation. I am not familiar with Azure, and to me it is unclear what problem you are trying to solve, why do you solve it using inheritance as opposed to using separate non-abstract binary serializer or wtf property is used for. You might want to explain some of those things in your code using xml-documentation. 

1) Are you sure that it is safe to write to from background thread the way you do it? Because documentation clearly states that it is not: 

Well, I do not want to be the one always hammering on using s, but your second solution was almost immediatly clear to me, whereas the first was not. It does help that with the second one you split it up into methods, a very good thing! Nontheless, I still think you can improve the second solution: 

I am not sure I agree that a loop is more elegant per se. The downside of your method compared to a traditional loop is that it requires a bit more processing most of the time, because you need to create a new character buffer and put the replacements in there, and you create a new object. I would probably create an initial implementation with a Java 8 , e.g.: 

A short comment about your first approach, using a would be a good thing, because concatenating s with each time builds a new object, whereas with a , you would only make a new when you concatenated all parts. In this very case though, pure performance wise, it might get optimized under the hood to use a anyway.