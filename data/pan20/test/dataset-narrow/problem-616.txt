I would probably place the logic related to "wrapping" index values into the next/previous convenience function and let do one thing only - show the slide index as given. 

I don't understand why you have method or have it exposed statically. Do you really need a method to build an array? Why is this not just done in . i.e. 

You could have this class implement interface so you can pass it directly to for serialization. This also allows you to do things like add validation that setters are passed valid values (i.e. boolean for ) 

I think you need to think about inverting control here or you will find limited re-use in this class. Why would you pass a specifically-formatted POST request here to this class in order to execute validation vs. having calling code just reference methods on this class that execute the validation logic? For example: 

You are doing absolutely nothing to validate the data being passed to your public methods. That means this code is extremely fragile and likely to be put into unexpected states. Take your constructors for example. They just blindly accept whatever is passed to them and sets the passed data as the DB connection to be used by the instantiated object. Since (a poor variable name by the way) is an object, you should be able to type hint the parameter like this. 

Note how I have moved the HTML into templates defined within nowdoc blocks. This approach can allow you to easily pull this content out of the function itself into separate template files that are easier to manage. For example, the function could be rewritten with template-to-variable assignments like this: 

With regard to your database model, it seems odd to base any session deletion off of value. I would consider explicitly storing expiry datetime in your session object, rather than trying to back-calculate against last time session was updated. I don't understand why you would tie session instantiation and session data garbage collection together as you have done. 

Consider moving include to footer, since all activity there is going to be executed on document ready anyway. This may help slightly with apparent rendering speed of page to browser. The browser could be using a thread to load an image or similar static asset that is more visible to the end user rather than blocking on retrieval of this script (browsers typically download all static assets based on X number of subrequest threads). 

This again decouples display classes (like ) from behavioral ones, and would allow you to use any sort of elements - these could simply be divs or tr/td combinations - in any sort of layout. It doesn't matter, since our data attributes will tell the javascript class how to set itself up. Next, let's focus on this class (we will call it ). The thought here is that this class could be dropped on any page via reference/include, such that it is reusable anywhere in this application or other applications and is not tightly coupled with the display layout. This class must be able to understand the different element types and provide a single place to implement the code logic pieces noted above. One thing we are going to look to do with this class is to minimize the need to re-query the DOM every time a filtering operation is needed. This class will store the jQuery selection references it needs to perform actions on DOM that result from filtering operations. This would greatly increase performance in cases where you are expecting the filtering controls to be heavily used. 

I am guessing that this script is in a web directory. If so, you should strongly consider moving your PHP libraries out of the web directory altogether rather than being in child directories of web root. There is no reason to ever potentially expose these files to the world, or to have to spent the overhead of putting in redirection/authentication logic to protect these resources. 

I would suggest you move away from hardcoding DB credentials into files such as this. DB credentials should ideally be defined in configuration outside of your codebase. 

Putting it all together (with optional 3rd version part to show how to handle some flexibility in input) might result in something like: 

You have some good advice in answer from @hjpotter92. I will add some thoughts in addition to those already mentioned there. 

Of course the above approach has ramifications on your javascript. For example, your function might need to look like this: 

where contains you query selector (you could pass collection instead, but since this is really only one line of code to instantiate collectoin from selector, I am just using selector here). and could contains javascript data objects, and callback could be callback function to actually perform the "hide" behavior, decoupling the filtering logic from the display logic. 

You may consider passing DateTime object to this method instead of just a string. That gives you the ability to enforce the parameter type via typehint. As it stands right now, you have nothing here to validate that a proper string format is passed. There is no reason to twice here. Just explode once and work with the resulting array. If wanting to work with concrete objects this logic should be in the constructor so that you can enforce that the object gets set up in proper state. How does this method handle AM/PM? Is it using 24 hour clock? Your test data only reflect values < 12:00, it seems as if you are missing coverage here. 

Glad to see you using doc blocks, however these property blocks should probably be changed to , , etc. 

I think numerically-indexed arrays might also be used to hold the contacts and phone number data nested underneath the contact group. 

validate against and fail out of function if non-zero length string is passed. No need to nest all the rest of your code inside a conditional. For example 

This query will not be able to leverage an index on because you are using a condition that starts with a wild card character. Can you split apart the batch date information in your DB table into it's own column? That would give you the ability to do things like: 

but I honestly find what you have in place to be easier to read, and I would not be concerned about the cost of having the additional variable in memory (that seems like a micro-optimization type of concern). 

Updated comments So it sounds like your real problem is one of dependency management. As you are developing different versions of your digitalData schema, you currently have no reliable way to ensure that interacting code adheres to your standards. It seems that you don't really care that each area of the site be on your most recent schema, but rather that each area of the site at least work with a schema that works with your backend data collection system. This is actually OK and a reasonable way to think about working with a large-scale application/site. To this end, you might consider treating your digitalData code as a version-controlled dependency. If you release version 2.0.0 of the dependency, each different team that develops a different part of the site can then control whether they want to take the new version of the dependency or stick with their 1.X.X version. It would conceivably be OK if portions of the site are on different versions of your dependency as all of those versions have been built to properly interact with the backend data collection mechanism. With your current approach, you don't know this to be true. Teams could potentially introduce schema changes on the fly and break the data ingestion process. By taking this approach, you enforce that every development team that works with this dependency must declare which version of the dependency there are going to load into their area of the site. Meanwhile, as the team developing the dependency, you can begin to enforce specific behaviors against the data structure, as I have mentioned, without concern that your changes are going to break portions of the site, as when you release a new version, nothing on the site would actually be using it until those areas update their dependencies to work with your latest release. You push the testing burden onto these individual development teams to make sure they are working with your dependency in an appropriate manner in their portion of the site. 

This may seem like a subtle difference, but it is a very powerful approach in that you establish a strong contract that this class must have it's dependency passed to it or it cannot even instantiate . An would be thrown if value passed for is not a valid object. You also remove all the logic and potential error/exception handling in classes that need such a dependency. Why should all these classes need to know how to instantiate a object? They should just get a object in an appropriate state that just works. 

Other points of feedback: You do little to validate that the parameters being passed to your public methods are acceptable to work with. You should strongly consider beginning to apply type hints into the method signatures such that exceptions are thrown when unexpected values are passed. For cases where type-hinting can't help you (like when passing string or integer values), then some basic validation should be the very first thing that you do inside the method (i.e. non-zero length string required, positive integer value required, boolean value required, etc.). Fail fast with an InvalidArgumentException or similar when these criteria are not met. Also, consider asking the caller to be more specific in passing certain parameters. For example, on your method, you allow a variety of input types. Do you really need this flexibility (and the added code complexity)? If the code can operate against anything implementing , why not just put that in type hint? Why check for both and when implements this interface? Do you REALLY need to accept arbitrary input and the edge cases it might expose in your code? Like right now, what happens if I pass a value of to this method? It falls through your conditional and gets set on the property, because it and is not DateTimeInterface object. You probably don't want to have to write 15-20 lines of guarding code for this simple setter operation. Similarly, with methods like (bad camel case here), you should enforce a boolean parameter as being passed rather than casting the parameter as boolean and potentially introducing unexpected "truthy"/"falsey" behavior. Right now, I could pass an object to this method and have that evaluate as truthy, making this cookie HTTP only, even though the caller's method usage was incorrect and should have caused an exception in your system. Be very specific when you set up the interactions between your classes and class callers. The looser you permit these interactions to be, the more problems you will have with bugs in your code and being able to quickly debug that code.