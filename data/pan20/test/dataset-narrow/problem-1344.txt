I have a few questions before I start answering this. First, in the original bug in which you got stuck in the walls, were those tiles on the left individual tiles as opposed to one large tile? And if they were, was the player getting stuck in between them? If yes to both those questions, just make sure your new position is valid. That means you'll have to check if there's a collision on where your telling the player to move. So solve the minimum displacement as described below, and then move your player based on that only if he can move there. Almost too under the nose :P This will actually introduce another bug, which I call "corner cases". Essentially in terms of corners (like the bottom left where the horizontal spikes come out in your .gif, but if there were no spikes) would not resolve a collision, because it would think that none of the resolutions you generate lead to a valid position. To solve this, simply keep a bool of whether the collision has been resolved, as well as a list of all the minimum penetration resolutions. Afterwards, if the collision has not been resolved, loop over every resolution you generated, and keep track of the maximum X and maximum Y resolutions (the maximums don't have to come from the same resolution). Then resolve the collision on those maximums. This seems to solve all your problems as well as the ones I've encountered. Here's the code I use in my update: 

After switching over to 2D raycasts, it still didn't work. After selecting [Build Settings -> Player Settings -> No Context Menu] it worked. 

It works great in the editor, but when I made a build and tested it in Chrome none of the buttons had any response. Further testing revealed that it did work in Firefox. Rather than telling people to change their browser if they want to play, I want to make the button code work. How else can I get the buttons to know when they're being pressed if the built-in stuff isn't working? 

Alright, so basically this is what @Trevor Powell was describing. Since you're using only AABBs, all you have to do is find how much one rectangle penetrates the other. This will give you a quantity in the X axis and the Y. Choose the minimum out of the two, and move your colliding object along that axis that amount. That is all you need to resolve an AABB collision. You will NEVER need to move along more than one axis in such a collision, so you should never be confused about what one to move first, as you will only be moving the minimum. Metanet software has a classic tutorial on an approach here. It also goes into other shapes as well. Here's an XNA function I made to find the overlap vector of two rectangles: 

I have some textures that are used in multiple scenes and I want to keep them in memory to speed up load times between scenes. I know about Resources.Load, but does that always keep it loaded? If a texture is loaded with Resources.Load, will instantiating a prefab with that texture recognize that it's already loaded or will it load its own instance of the texture? It would be better if it's a method that I can use in code so that I can make a loading screen and not freeze everyhing up. I'm limited to an earlier version of Unity so I don't have access to LoadLevelAsyc. 

), and destroy itself (so the clown is gone). In obj_controller's End Step event, check if is true and is false. This means there has been a click somewheres that isn't a clown (because the clown would've told it that the hit was good) and we can decrement a life 

To stop the mace from looping (and only swing once when the animation is played), in your last picture there's a checkbox called "Loop Time" (first checkbox). Unclick that. 

I've recently come across GWT (Google Web Toolkit) and have been amazed by it. I was wondering if anyone has ever put it to use making a video game? And if they did, what their experience was, whether it was worth it and whether the game was any good. 

So, in RotateParticleFinal I have a part that updates the alpha. That's only using floats. But when I check the actual particle to see if the alpha is at 1... well, it's a byte now. It was working better with a lot of debug calls because it slowed everything down, meaning I got a lot more alpha on my deltaTime based fade-in. Been wrestling with this for a while now and I didn't figure it out until right after I finally posted this >_< 

I think in game design it is incredibly important to ask the question why about everything, especially something that has become so standard as lives. So I am asking, what is the purpose of a game having the concept of lives? Why have lives? 

This is probably not what you are doing though). If you want all obj_carrier's to create a bullet at once, you can do: 

I just implemented in C a way to calculate the angle between two vectors A,B, given an origin C. Look at this Wikipedia article to understand where I am coming from. Here's the pseudo-code: 

I have a smaller version of the project right here for download. The 'main' gameobject starts a script that instantiates the main 'Load Level Screen' prefab and populates it with the 'LoadLevel - Single' prefabs. I've been banging my head against the wall for over a week now, so any help would be appreciated! 

So, nothing that should be affecting the button that I can see. I thought that the button was getting resized, but when checking in the scene the button is stretched all the way across the prefab. Any ideas why the button isn't working properly? 

This question concerns the order of events (when they are relatively called to one another). My answer takes advantage of the fact that mouse click events occur between Begin Step and End Step events. That means one solution would be the following: 

If you are creating/spawning the bullet from within the obj_carrier that is to create the bullet (ie inside its step event, or alarm event, etc), you can just use x and y: 

Another method (which I answered the question Byte56 linked to) would be to check if the collision resolution puts the character in an empty spot or not. So in your problem, you get a collision from the inside rectangle's ceiling to move it up, which would be illegal (as you're still in collision with another tile). Instead you only move it if it you're moved into a free space (such as how the collision from the upper tile would move you to the left), and once you find that collision, you are done. The answer I gave had code, but it became overly complicated. I'd keep track of all collisions within that timeframe and only take the one which lead to a free space. However if there were none, I think I resorted to resetting the character's position to its last position, however that's really ugly and maybe you would rather try implementing something like the original Mario where he just moves in one direction or something when no free space resolution is possible. Also you could sort that list of collision resolutions and only move to the freespace with the shortest distance (I think that solution would be the most preferable, although I didn't code for that). 

I have an animator with a few animations in it. These are very basic animations, just changing a transform to slide a sprite around in a cutscene. The issue that I'm running into is that when I transition from one animation to the next it will try to smooth out the animation differences. So if I have something move off the right of the screen, then with the next animation come falling from the top of the screen, it will first quickly slide to the new position. I've tried to change the last frame of the first animation to Right Tangent -> Constant, and the first frame of the second animation to Left Tangent -> Constant. It didn't make any noticeable difference. I also set up two functions (one for X, one for Y) to set the position at the beginning of the second animation, but only one of them were called, and it didn't seem to do anything. So, how do I get an animation to snap to the starting values of the new animation after a transition? 

Have an obj_controller (bad name and design practice, but fairly commonly done with GM) that has a variable and a variable. In obj_controller's Begin Step, set and to false In obj_controller's Global Mouse Left Pressed event (this would indicate there has been a hit somewheres on screen, possibly a misfire, possibly not), set the variable to true Have an object called obj_clown that is the target your user is trying to hit. In obj_clown's Left Pressed event, increment score, tell obj_controller that there has been a verified hit by setting obj_controller's variable to true (this can be done using the following GML: