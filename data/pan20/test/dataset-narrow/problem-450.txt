As to your quesion. Is this code useful? In short. Yes, but only if you ever want to do only one thing with it and never want to re-use anything inside. Otherwise no. That's just a few comments off the top of my head. I hope those are a good starting point. 

This way you might never even need to check for null at times. However if you did your statements might look something like this now 

I don't think that splitting the ViewModels up into smaller ones will break this statement . However I also don't necessarily agree with it either. Why should the ViewModel depend on anything? However what I do think splitting your ViewModels up (where possible of course) is allow you to potentially re-use any Viewmodel while also making each view model specific to a particular part of the design/functional requirement. So if I was to continue on with the IFooRepositoriesContext approach I might consider something like this: 

I would probably pass in the customer log as a parameter to the method and then have it deal with just the database insertion. If you wanted to keep a InsertOrUpdate type of approach I would branch on perhaps something like the object ID if it has one. This way you can have a variety of ways that your object is created and the method is only responsible for the persistance of that object not also it's creation and populating. A couple of problems I see in your approach: 

The problem here is that on binding back there will be no Firstname element on our encapsulating viewModel. What the input really should have looked like was 

I think I agree with Jeff. So because of this, perhaps you might want to reconsider the design? Do you really want to make RestClient dependant on WebClient or could we make it dependent on an interface instead and decouple it from that side of things? Perhaps this is overkill? Here's a crack at an alternative for comments: The testing 

Now create using composition any top level view models for the different view requirements of the system: 

I agree with what Jesse said in that a grouping of your repositories into one related is one approach and may be the one best suited in your case. However I'd like to offer another approach and that would be use composition in your ViewModel and have it contain lots of smaller ViewModels. 

One small point on the c# side. As SqlConnection implements I would rather consider wrapping that in using statement within the Save method. This way if a problem occurs in the method you can ensure the SqlConnection is closed and you don't incur any leaks. 

I would consider first splitting the method into smaller methods as other people have mentioned. The only suggestion for now is I might suggest changing your bool daily to a enumeration. This in theory means it might be easier to add a Hourly,Monthly etc reporting option. Although this is only slightly better in my opinion and I'm sure there are better approaches (maybe using interfaces?). Something like this as an exercise in splitting things out into various methods keeping most of your code but just re-arranging it slightly. 

Note: AssignDBStatusMessage actually became redundant in this approach and TryDataBaseAction is seeming a bit weak now?? 

No exception handling is required. The only reason I could see from the code for an exception occurring would be for a major failure. At which point I think you might want to capture that at another level anyway. 

Further thoughts: During typing this I thought you could even look at making an extension method on the PersonalInformationModel class (or on the class itself maybe?) to do the name conversion: 

As well as some standard indenting, a quick thought could be reversing the item being compared and using some temporary variables for readability. EDIT: Ok, so svick pointed out that the original code was fundamentally flawed. So how about creating an extension method on to do the Contains for us. Something like: 

Here's another stab at something. Mainly I think I see a bunch of duplicated code in your lists, so what about something along the lines of 

Masking potential problems Using from past experience is typically used because developers don't want an exception to be thrown if the criteria constraint is violated i.e. they don't want to see a bug come through. However this may also mean that an error occurs somewhere further down stream because of this. You will then find yourself debugging errors that in fact relate to model data violations and might have nothing to do with the code you are debugging. The problem should ideally be fixed at the point where the model data violations were made, rather than the rest of the application having to worry about it. Summary I would always advocate over if the intent of the query is to only expect 0..1 data objects returned. So use what you expect the data state to be in. Unless of course you want to handle bad data state yourself and then I would expect error handling to occur if this was violated. 

As for how that works, I'll leave you to figure that one out, or I might post it if you go down this route? However what that partial does is ends up printing exactly what you need: 

With some unit tests (I didn't do all, just enough to test base functionality). Note. I started these tests before I even started re-factoring the code so that I had them passing first. Then during re-factoring I could confidently know whether what I did was still returning the correct results. 

I'm not sure if this is any better and it might depend on how many if statements or different categories you have whether it's worth it. But an alternative could be something like: 

I'm not really any good at algorithms as such so my main suggestion would be to remove duplicate code. That is primarily in the creation of your pPairHigh and oPairHigh blocks of code. I admit they do share a common loop which in my implementation means this will be occurring twice. If this is an issue in performance it could be broken out so the pairs are created like you have done in a single loop. But I would still call a method to do the actual creation. However I'm working on the assumption performance is not really an issue, here is my suggestions. 

Ideally we would remove these however I'm not sure exactly the best way to approach this might be. I'm thinking the ManagementObjectSearcher would be the likely first candidate. Perhaps injecting via a constructor. Something like: