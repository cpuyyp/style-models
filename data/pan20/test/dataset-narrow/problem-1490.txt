For clarity, the real difference is that in Cumulative Grading, the rubric tells the student how many points are needed for each grade and they can choose to get them any way that they like, spread over the assignments, whose totals are also known. In percentage grading, especially with different things worth different "weights" it is (a bit) harder for the student to know where they are likely to wind up. They know their "average" perhaps, but every assignment affects the average. Therefore with Cumulative Grading, the student always increases their points, where with percentage grading, each assignment can get you closer or farther away from your goal. 

I have never had this situation, but can offer some general advice that is also applicable to other students whose needs require specialized techniques. As suggested in other answers here, talk to the student, of course. But ask the student for permission to do at least some of the following. You probably have a school counselor who can offer some general advice. You can talk to the parents about what they suggest and what has been useful to the student in the past. You can have a meeting with other teachers who have, or had, this student in class to see what they suggest. You may be able, with permission, to talk to the student's former teachers, even in grammar school, to see what might work. You can also seek, perhaps online, advice from specialists in the student's need-area. The student might, in fact, already be working with a professional. You might see if you can have a conference with them. As I suggested in a comment, get connected to the APCS community and ask for advice in their fora. Do the same for the ACM SIGCSE group. It is probably too late to modify your curriculum, though others in your school should do some anticipatory planning for helping this student in the future. It may require some curricular changes generally. I would suggest, however, that curricular updates consider changes that benefit all the students, not just the one. My go-to suggestion for many things is to incorporate teamwork into the curriculum as much as possible. Every student learns differently, not just the blind student. Every student can contribute to a team, though different students contribute differently. Presumably the student has skills that compensate for lack of sight. Try to bring them to bear in the class so that the student is a part of things, not an outlier. For example, he might have an exceptional memory or an exceptional organizational ability. All of these are needed by professionals and can be capitalized on in the classroom. In taking APCS the student is obviously not looking for an easy way out. But do what you can to make the classroom a supportive community that benefits all students. 

Whether this is a good plan or not depends on some things, most especially the nature of your students. However, it seems a bit too unstructured. If you have a general mix of student ability it could cause problems unless you incorporate the questions from the site(s) more formally into your teaching. There are a lot of questions available, I would guess and some of your students will panic, thinking that (a) they need to do everything or (b) it is hopeless. This is a special problem if these extra questions are above and beyond all necessary assigned work. However, one good aspect of your plan is to show them in advance the kinds of things that they will be expected to know and that other students also regularly deal with. Much better that than hiding your intent and springing things on them unexpectedly. But I think a better plan is for you to incorporate a sampling of the found questions into your labs and homework assignments. For the most challenging questions you could have five minute brainstorming sessions as part of several class periods. In short, as part of the regular process it should work out, but if it is completely "extra but not formally rewarded" work it might backfire on you. 

It is possible to teach algorithms in particular, and a lot about programming in general using a pseudocode. However, the pseudocode needs a firm definition or else it can lead to sloppy thinking. If a student is permitted to make "statements" in the pseudocode that imply, for instance that P=NP, then the statement isn't worth much, nor is the "algorithm" so expressed. I'll note that Edsger Dijkstra wrote most of his papers in pseudocode, but it was carefully defined. David Gries wrote his famous book The Science of Programming using this same pseudocode. However, each statement in the language (even the empty statement skip) was carefully defined using pre and post-conditions so that the effect of the statement and resulting programs were precisely defined. And even the pre and post-conditions are precisely defined. This language (pseudo-laguage) can be fairly easily translated into other imperative languages, but it is harder to take advantage of the features of other paradigms such as functional or object-oriented. So, yes, it can be done. It has been done. It has been done by masters. But it isn't a lot easier than using a "real" language. It has quirks, like any language. Some programs are harder than others, of course. It is even possible to write a compiler for Dijkstra's language (I've done so, actually), making execution possible. However, the reason for the language wasn't execution, but precise clarity of expression of algorithms with precise semantics. One possible problem with learning algorithms this way, however, is the the resulting pseudo-programs tend to be rather monolithic. Complex programs have long statements with lots of structure. The method, if not carefully used, seems to de-emphasize building complex things out of small interacting parts. This isn't inherent in using pseudo-code, but the instructor needs to be careful about the use so that complexity doesn't overwhelm understanding. But the same is true in real languages. Not everything needs to be done in main. 

No one has yet mentioned the long term effects on the student. If the person wants to explore computing as a career they need people skills, not just technical skills. But that is a lesson your entire class needs, not just this one person. Highly valued people in the computing industry spend most of their time and effort working with other people -- and not just in coding teams. Design, estimation, managing large code bases, etc. all require people skills. There are a few people who are absolute horrors personally who are valued, but those are extremely rare and need unique skills. For everyone else, learn to communicate, to offer and to accept advice. On a somewhat different scale, but perhaps related, I know a few people who are successful but also Extremely Introverted. But they have worked to overcome their tendency to withdraw and so their introversion isn't always obvious. Introversion is good if you draw power from your own thoughts and considerations, but it can be a handicap if you need to act outwardly in the world and haven't learned how. So, if that is the real issue here, deal with it as such. For the record, I am very introverted by nature. It cost me a lot early on until I learned how to deal with it. The scariest thing for me was to state my opinions. Perhaps you didn't notice that here :-). For the entire class, field trips to local tech industries can be helpful so that students (all of them) can see what really happens. 

Depending on your relationship with the students and their general level of background, I'd say you might consider one of the two following options. (a) The language you know best. Then you won't be struggling with the language and how to use it, and can focus on the teaching of it. (b) A language that you don't know at all. Then you can use a discovery style of working with the students to discover together how to program in that language. with option (b), instead of you showing them how to do things, you can have the students show you. With either method, however, keep in mind that the most important thing is not what you do or say, but what the students do. Your lectures (if you even do that) are far less important than the exercises that they do. If you aren't already an experienced teacher, I suggest a lab based system in which students are encouraged to work together and to ask a lot of questions. Active students will learn. Passive ones won't. It isn't really about whether one language is better or worse. 

You don't specify Secondary School, but your AP tag seems to imply that as your main interest. I'll start with that, but give a more general answer. There are some organizations that hold regular conferences and to which you should belong in any case. The conferences normally have workshops in which experienced educators teach some tools-of-the-trade. The first, focused on Secondary School, is Computer Science Teachers Association. They have both a newsletter and a national conference. The next, focused on AP itself is AP Teacher Community which has a useful set of discussion boards. They have events (and tutorials) in conjunction with the SIGCSE national conference. The SIGCSE organization within ACM is somewhat more dedicated to post secondary education. It has several conferences every year, including some outside the US, usually Europe. Many secondary teachers belong and there is support here for such teachers. The Consortium for Computing in Small Colleges, while focused on college teaching has many annual conferences spread around the US. Like the others here, the conferences often have workshops given by educators. Many topics are covered. Welcome to CS Teaching. Explore the above organizations for their offerings and subscribe, if appropriate, to their newsletters. You will get a lot of information, and a forum for asking for help. 

There is one aspect not yet mentioned, though the first two answers are excellent. Libraries usually contain only the most common data structures and those that can be used in some generic way (pun intended, I guess). But there are other data structures that you may need in your work that aren't in the library you have available. The tools you need for building the standard data structures are likely the same (or a subset) as you need for the bespoke data structures. Sometimes you want a specialized version of a data structure to be able to optimize an important algorithm. So being a tool builder is an important skill that isn't exactly the same as that of being a tool user. 

I'm not sure how relevant this is to CS, but one of the most important and memorable courses I had in my first year of college was a writing course. The prof never talked about the process of writing, but pointed us to a lot of good writing. However, the crux of the course was that we wrote a theme for every class (3 per week). We spent quite a lot of the time in class reading these aloud and getting feedback. His particular trick was to pick out the best ones in his judgement for review, not the ones that needed the most work. We also got detailed feedback in writing. No lecture at all. Lots of activity, lots of feedback. He did his job. 

We put it in every program. It distinguishes a program. But if you start your java course explaining every part of it you will (a) confuse the juices out of them and (b) never get to the point of writing a useful program. For the beginner, it is just an incantation like 

History note: Implicit typing is probably an incorrect term for this. FORTRAN had implicit typing where the type of a variable depends on the spelling of the name. Names beginning with I through N were implicitly Integer unless a specific declaration implied otherwise. Other names indicated Real variables. On the other hand, Standard ML and related languages have a subsystem in the compiler that could infer types (type inference). ML has strong static typing also, but programmers seldom need to specify a type since the compiler can ordinarily figure it out. But use of var isn't dynamic typing either. In dynamic typing (Python, Ruby), variables (names) don't have type. Only values have type. Dynamic typing can still be strong typing, but it is done at run-time, not compile-time. Errors are found later unless they are rigorously rooted out through testing during development. 

Note that the Standard Template Library (which I haven't used in quite a while) was, itself defined in terms of concepts and the term was (maybe still is) used in the literature. This was just a placeholder for interfaces that C++ didn't support. The idea here is to build a software system in terms of readily understood concepts. The resulting system has its complexity in the interactions of simply understood things, rather than in the things themselves. 

Let me suggest, pretty strongly, that you may be mixing up too many ideas in too short a space for novices to grasp in one go. Spread it out. There is no real reason to introduce arrays along with pointers, nor to give a complex reason for zero indexing at the start. In C, you don't want to avoid it altogether, of course, but you don't to dump the whole load at once. Step one I'd suggest that you first present arrays in a simple way, using all of the available sweetener that there is (syntactic sugar). Something like this tutorial is pretty clear. It enables the use of arrays for nearly all purposes. You can describe an array as a "contiguously stored block of values of the same type." One easy way to talk about zero indexing in this context is to think of the index as the distance from the start. If you aren't asked about what distance means at the start you can just ignore it, but if asked, you can talk, briefly, about each type has a "size" and the distance is measured in units of this size. Thus the "first" element is at distance 0, so has index 0. Step two Once arrays are solidly integrated into the students' thinking process you can introduce pointers in general, but not yet connected to arrays. Again, the Tutorials Point introduction is pretty much at the level that is needed. But you have introduced two concepts and the pedagogy was to keep them separate initially so that each can be learned on its own merits. Now you can merge the two ideas and will then deepen the understanding of both. Step three This third tutorial explains it quite well. Note that since you used the "distance" metaphor for indexing initially it all comes together. In an array of doubles, 

As a technique, I'd also recommend that they do a lot of paired and team work, rather than individual work. They can help you teach by helping one another to learn - working on those exercises. It will also be an advantage to their later work if they are to work together after the course ends. The more students you have, the more important this will be, since you will become a learning bottleneck otherwise. The more students, the more questions. You won't be able to answer all of them in the available time. Teams will help here. Finally, it wasn't clear to me, the reader, how motivated the students are. Things will work better if they are already highly motivated, of course. But if that is not the case, and they really should work harder, as your colleagues imply, then you have another problem that you should attack. One way to do that is to try to introduce some human, even fun, elements into your teaching. One useful Organizational Pattern, for example is "Do Food" which suggests providing food at the workshop sessions. That book, by the way, has a lot of other suggestions that will probably help you improve the situation if it is poor. In your case InfoSec is the big new idea you are trying to introduce. But you can increase the motivation by making the workspace more human (and humane). 

One of the problems of learning to program is the problem of how much information needs to be kept in mind as you proceed. If it was necessary to retain every detail of the program, it would be an impossible task. Therefore we use various abstraction facilities (mental facilities) to reduce the task. I can't remember the state of 4gb of values. I can't even really remember the implicit state of an if-statement if nested more than about 4 levels deep. Therefore I don't write such programs and instead create simple objects with simple behaviors. I also create objects that have any explicit state private - no exceptions. I design objects so that I can effectively think of them as nothing but bundles of behavior, though Java certainly has facilities that let me do otherwise. However, if I break my rules, my program becomes harder to understand, use, and modify.