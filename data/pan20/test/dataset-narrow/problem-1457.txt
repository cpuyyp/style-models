Another classic is Computers and Intractability: A Guide to the Theory of NP-Completeness by Garey and Johnson. As you may know, NP (which stands for "nondeterministic polynomial time") refers to a set of problems that are computationally very difficult but whose answers can be checked in polynomial time relative to the size of their input. Whether all such problems can be solved in polynomial time (P=NP?) is one of the greatest unsolved questions in computer science. Garey and Johnson (as the book is referred to) is about NP-Complete problems, members of NP to which all other members of NP could be reduced. The book catalogs problems known to be NP-complete, including proofs that they are members, usually reductions from other NP-complete problems. Published in 1979, the book is somewhat outdated but is still regarded as a classic [3]. (Google Scholar lists about 60,000 citations.) The introduction (available online), in which an employee explains to their boss why they can't provide a simple solution to a problem, is also classic. Disclaimer: I am not a theoretical computer scientist. I welcome comments from any. 

This provides a simple demonstration of the benefits of pointers and will help them understand why primitives (not counting pointers) are passed by value, while everything else appears to be passed by reference. 

Because the standards are explicit, it is clear that it's nothing personal if we say a student cannot continue in the major. If the student really is interested in computer science, I tell her this might not be the right time in her life for her to do it (not that she's incapable of ever doing it) and advise her on retaking courses, with any appropriate accommodations. I might also advise her on related majors in which she might be more successful. We have no way of stopping a student from continuing to take CS courses (as long as she has passed the prerequisites), but the policy sends a strong message that they should choose a different major. 

As I indicated in my other question, I have found that there are always a few students who don't seem to get it. This leads me to suspect that there may well be some small number of persons who are so disadvantaged that it may be effectively impossible for them to become strong programmers. However here are a few words of cautions: 

Give it to your students, but don't tell them what it does. Give them a chance to attempt to trace it. Tell them that they only have 4 minutes (240 seconds!)1 to figure out what it does! Presumably, they will struggle mightily to figure it out, but mention that, if anyone thinks that they've solved it (and can back that up), not to call anything out, but to instead raise their hand. If anyone does call you over, ask the to whisper the answer into your ear, and if they get it right, ask them to silently try to re-write the code segment in a way that would be easier to follow. Now, give the class a new version, with another 240 seconds. Do not mention that it is exactly the same code as before, but with nicely-defined loops (and modified variable names). Once again, tell them not to call out the answers. The process here should be the same. 

First of all, kudos to you for being willing to support learning in your community! This is awesome work, and I'm always glad to hear someone is pitching in to help kids learn. I wouldn't be so sure that you're not adding value. There is a principle of teaching that you can use to guide a lot of your action in the classroom: we learn by doing. If the student does, then the student learns. If the teacher does, then the teacher learns. What you've created is a structure where the students are doing basically 100% of the learning. You are there to check in, make sure they are safe, give guidance and support if they get stuck, help keep the kids focused, and provide additional food for thought to kids who get really into it. This isn't a bad thing, this is a nearly ideal learning situation. Celebrate your success, and always keep an eye out for ways you can continue to help the kids develop and grow. 

The difference is that, in the first piece of code, each array element is retrieved from memory once and placed in either a register or the cache, from which it is operated on a million times. Ignoring spatial locality (which would apply equally to both versions), the total number of reads from memory would be 1,000,000, and the total number of writes would be 1,000,000. With the second version of code, each array element is fetched from memory once for each value of . The total number of reads from memory would be 1,000,000 x 1,000,000 (10^12); the total number of writes would be the same. Per Latency Numbers Every Programmer Should Know, a main memory access takes about 100 ns; an L1-cache reference takes .5 ns. Accessing a register adds no time to instruction execution. Ignoring the times for the writes (which may not be in the critical path) and spatial locality (which applies the same to both versions) and assuming that is stored in a register, the data memory access time for the first is 10^6 * 100 ns = .1 s. The data memory access time for the second is 10^12 * 100 ns = 10^5 s. 

CS students are taught to use version control software. I teach at a small liberal arts college, and we've taught its use in our capstone course (and sometimes others) for as far back as I can remember, at least since 2005. A graduate's not knowing something does not necessarily imply it was not taught. Students tell me they've never seen material that I know was in the prerequisite class. I'm sure this is not unique to CS. (Students are taught proper writing in the required English 1, but they don't all use it.) Teaching something does not guarantee that students understand it. They could have copied-and-pasted commands or relied on their teammates (or Stack Overflow.) I don't include questions about VCS on tests, just like I don't include questions on how to use IDEs and debuggers, but that doesn't mean it isn't taught. 

I'm currently reading a book, Polymorphism: As It Is Played, which has introduced me to several new instructional ideas. I am particularly intrigued by Pair Programming, which seems like it could benefit everyone. However, if I simply describe the idea and tell my high school students to go, I feel like there is a very good chance that it won't really take. The Navigators might not remain fully engaged, or the kids who are more advanced might just take over the Driver position and not bother to explain what is going on. How, then, can I handle the introduction? What are the pivotal ideas that can enable my students to use this tool effectively? Edit: I understand that a similar question has been asked here, but my question comes from the perspective of a teacher who is far less familiar with the source material, has never used it in a classroom, and is specifically about the introductory lesson. 

The teacher believes in the material being taught. They think that it is both useful and interesting. (And hopefully a little amazing, too.) The teacher believes that the students are absolutely capable of learning the material. The teacher loves their students, and genuinely wants to see those students thrive. The teacher praises good student practices above and beyond student accomplishments. There is a lot of research to back this up; students who receive praise predominantly for being right, for being smart, or for being the best at things often become wary of difficult material and of the unknown. Why throw yourself into something if you can't succeed like you have in the past? By contrast, if you are typically praised for good process or for working hard, then when the material gets hard, that praise still feels quite accessible. You can still organize your own learning and work hard. 

One reason infinite loops are used could be so the problem can't be solved by letting one thread complete the code before the other thread starts it. With infinite loops, no thread ever completes the code. Of course, using a bounded buffer has the same effect. 

Georgia Tech announced an Online Master of Science in Computer Science degree in 2013, which has received very positive press. You said you don't want MOOCs because they don't "provide a solid, recognized degree." Georgia Tech's degree is solid and reputable. According to a 1996 New York Times article: 

As you know, the local variables and do not get changed, because C uses call by value. At that point, I show and discuss this cartoon: 

I teach at Mills, a women's college near Silicon Valley with a high number of students of color. We do a great job of preparing students technically -- they do very well on the job market and then in their jobs. What I am unsure of is how to prepare students for the transition from a nurturing, feminist liberal arts environment to industry, which is not only more rough-and-tumble for everyone but can include bias based on sex, race, age, etc., which may cause them to leave the tech industry. How can I prepare my students to not have their careers derailed by mistreatment in industry? I don't want to just scare them out of the major or make them fearful by mentioning discrimination without providing a solution. 

I teach the "standard" conventions for the language, where they exist. For Java, I use the original Sun naming conventions and Google Java Style Guide. More important that standard capitalization (which I require) are: 

Over the course of these visitations and re-visitations to the various layers of abstraction, the ideas between the layers become highly interconnected. These interconnections are what ultimately allow for fast, flexible thinking. Therefore, where you start can be dictated by secondary goals. Whichever layer you ultimately choose to begin with, the most important principle would be to ensure that you are creating a rich, foundational set of intellectual hooks that later layers can connect into. That is what will serve your students best in the long run. 

I next create a class into which I put my . I create a point, and show them how to use direct access of public variables: and . At this point, we have basically created a struct. When it comes time to print out a few of these points, I create a Then I create a rectangle class: 

In my experience, students will try to avoid reading even a single full page if they can get away with it. It has also been my experience that most students don't really know how to learn from text, so that they often need a guided activity that utilizes it. This isn't merely to get them to engage with text in the first place, but also to focus their efforts while reading it. Many students won't learn without this kind of guidance. Asking for written summaries or short presentations before chapter questions can also help get students to learn this way. And, as silly as it sounds, reading instruction can be subtly provided at the high school (or even university) level by asking students to identify two or three of the most confusing parts of the text, with a promise that you'll go over any section that confused a sufficient number of kids. 

This seems to provide the desired interaction with professors, albeit online. While it is not a research master's, it should put someone in a good position to apply to PhD programs. Update Commenters have correctly pointed out that this is not a research Master's, and a Master's degree is not needed to apply to PhD programs. Thus, it is not a perfect fit. It is, however, the only highly reputable distance CS grad program of which I am aware. 

When teaching Intro CS in Java, I sometimes tell students things that are not entirely true, such as that, unlike abstract classes, interfaces cannot contain any code. (For those of you unfamiliar with Java, that was true until functional interfaces were added with Java 1.8 in 2014.) I realize I could put an asterisk on the slide, or visibly cross my fingers, and let students know I'm not telling the full story, but, when I witness other instructors allude to irrelevant advanced material, I view them as pedantic and fear that students find the additional information distracting or confusing. I don't mean to open a debate on the importance of functional interfaces in Java -- they're just an example. What I'd like to know is if it's considered better to gloss over details in an introductory class or to always speak the whole truth. 

Yours is a fine first lesson, although it does not show the value of pointers. I would suggest also demonstrating how pointers can be used to implement a swap function. Ask the students (or step them through) what this code does: 

Kill 'em with clarity. I have a working memory that borders on handicapped, which has forced me into a solution that I have not seen others do. This is going to sound like total anti-orthodoxy, but I actually focus very heavily on my Powerpoints to keep things moving and breezy, and it really can work! Fair warning, though: doing this well takes a tremendous number of hours to pull off. It is not unusual for me to throw 2-4 hours into making a single slide. I started with TED's powerpoint recommendations. Many of the top talks there utilize PowerPoints, but take a look at those slides and you'll see something funny: there is virtually no text at all. The 7x7 rule (no more than 7 lines of text, no more than 7 words per line) doesn't make for interesting slides. I aim for no more than 5 words altogether, and 0 words is even better. (I don't always attain this, but that's the goal.) My slides consist almost exclusively of graphics and figures for discussion. The graphics are often heavily animated. Very little of the animation is aimed at being cute or funny. The huge majority is designed to make sure that the concepts are extremely clear. So, I might construct a graph in small segments based on the order in which I wish to discuss the parts. For instance, when I talk about how two dimensional arrays are stored in memory, I begin with a graphical representation of how I suspect my students typically imagine it, and then have pieces fly out or fade in, slowly replacing the fictitious model with the correct systems one at a time, giving me a chance to talk about each new element. The other thing I build into the slides is the activities I want the kids to do. "Try this exercise!" "Look at this prompt and work with a partner." "First one to write the correct answer on the board wins!" This was at first a nod to my terrible memory, but it has actually helped the pacing in my classroom as well. The whole enterprise is very highly choreographed, and after every lecture I give, I make notes on any place where kids seemed to fall off. If it slowed down or became unclear at any point, I rework that section, often very thoroughly. There are still limits, and it is still lecture. After about 30 minutes, kids will still start to very seriously drift if they don't have other things to do. However, the feedback I have received about clarity has been very consistent. One addition I intend to make this year is pre-made notes for every lecture with blanks for them to fill in as we go, and integrated exercises that they can work on at various times throughout the lesson. (Again, this is all highly choreographed.) What I like about the system is that, as I hone it over the years, it really does get more and more effective. It also provides me with a nice set of resources that I can share if students need to review material.