When picking up the second time, the previous pink physics frame did not come off and ended hitting something invisible. 

I find it hard to determine the wheel RPM since I'm only making a simple 2D game of rotating object via Z-axis. I wanna try this solution but I got no change since I'm trying to find the RPM from a game object that has a rigid body 2D and a circle collider. I decided to think of something more simple but alternate solution. I'm a bit good at math but not much. Took around to calculate but no luck yet. I want to know possibilities of checking its rotation from transform properties, figuring out yet about 6 degrees per second equivalent to 1 RPM as said from the link. I used the method for rotation speed. Also, when the rotation value reaches beyond 360, clockwise or counter-clockwise, sometimes it goes back either 0 or a negative value and I have to maintain total degree so that I can compute for the overall RPM. Please help me. Re-direct from my original question: $URL$ 

From $URL$ My guess is that it is dying because the space is not 'Unlocked'. You will have to queue it somehow to be changed from dynamic to static when it isn't locked. I do not know if chipmunk has this facility. If not, just put the object in a list and right after the physics is stepped for the frame, run your list and change objects to static. Update In response to your feedback, I could not find a place where Chipmunk's is exposed to the library. I assume you have seen this page, and want to reproduce it's behavior: $URL$ However, I did look at their wrapper class, and I wonder if you could do the following. On contact, remove the object from the world. Set it to Static, and add it back. There are a series of functions that wait until the update is finished: Internally, PhysicsWorld::AddBody() calls PhysicsWorld::addBodyOrDelay(). I wonder what would happen if you called PhysicsWorld::RemoveBody(), set it static, and then PhysicsWorld::AddBody(). Likely it will still blow up, but you can try. Alternatively, since Cocos2dx is open source you could add methods to get access to the addPostStepBlock call inside chipmunk, but I can't help with that as I have never done it before. 

} Now, I'm thinking which part o line should I implement for the sound effects. My objectives to make SFX played once for every collision (Or should I say "SFX played once per collision"?) on the following: 

When aimed successfully again in a streak, the second target will fall along the skewer and stacked. Same process over and over when another target is spawned. 

Was it okay to use in order to disable conditional width and height pixel size that requires power of 2? I'm planning to sell the game app at Google Play. I want to know and make sure that most of the latest models and Android OS's that won't display faulty white images by estimation, depending how many smartphone owners have latest Android OS's. (Gingerbread, ICS, or Jellybean) I had updated my LibGDX library. 

Before the official public release or publishing the first prototype game, I learned about alpha and beta testing in order to gain feedback and fixes needed to improve or correct the game's system. I have some several questions regarding this feature on development feature on Google Play where game developers can publish games: 

As with your other question, I think you need to profile your code and assess the bottlenecks. Languages like Javascript, which perform significant allocations by design of the language, have efficient allocators and garbage collectors. I would argue that the design of your library is wrong. There are a number of effective libraries out there that use the same syntax. Here's one: $URL$ And sample syntax: 

Fundamentally, if you want objects that are in a hierarchy relative to a parent, you need to do a concatenation of the local-to-parent transform with the parent. This is how it works. I see now way around it, and I wouldn't describe it as 'visual tricks' - that's how a transform hierarchy works. Objects have orientations and positions in world space, but if they are relative to their parent, they need to perform transforms every time they, or their ancestors, move. However, I think you can have your cake and eat it too: use two transforms: one a local-to-parent transform and one a cached worldspace transform. You also want a dirty flag. When an object moves in world space the local-to-parent matrix, or in your case orientation and translation, is updated and the dirty flag is set. All of the children then have their dirty flags set. Any request for an entities world matrix must first check the dirty flag. If set travel up to the first ancestor that is not dirty and recalculate each descendants world space matrix, clearing their dirty flag, back to the original entity. Then return the new world matrix. This avoids recalculating matrices of top level objects that have not moved or children who are part of a hierarchy that is static this frame. Normally this lazy evaluation is hidden behind the object's GetWorldMatrix() method so the caller never sees it. All the rest of the work is hidden behind SetWorldMatrix( ), SetLocalToParentMatrix(), etc. They do all the right operations under the hood. I would also note that while storing orientation and translation is cheaper from a storage perspective, it is quite expensive to perform a quaternion to matrix every frame. This solution might help you for objects that do not move often, but I suspect it might actually be more performant to store the local-to-parent transform as a matrix, but I am not sure what kind of transforms you are performing. 

I figure it out on how to stay center or inside the screen visibly (regardless of the device's screen aspect ration) by changing the value crop.x and crop.y as possible(basically set at 0). Regardless of the calculations to fit what's best for the screen and the whole game view, it will do. 

I have a question regarding about any smartphones that run only in Android 2.3.3. Is the size of screen or the screen resolution is always HVGA or does it have capable of running this OS (Android 2.3.3) on big screen size (4" to 5") at about 720x1280? I'm thinking of the game's compatibility depending on the version of the Android OS and the screen resolution, which affects the change of coordinates especially for assigning touch buttons and drag-n-drop at exact location, before I'm gonna decide to make one. My program works on the Android 4 ICS and Jellybean, however, will that work on Android 2.3.3 in spite of precise touch coordinate or just dependent on the screen resolution (regardless how large it is) as the X and Y coordinate? And take note, I'm using Eclipse IDE for Java developers. 

I took a look at a number of implementations that are all based off of this paper: $URL$ Here is one that I extracted and ran with your numbers - it returns no collision. You can look at main() to see the invocation with your test numbers. I have not done any more analysis than that. Good luck. From $URL$ 

Store a flag for each triangle in an array, associated with the mesh. This array is allocated once and owned by the mesh. When testing the triangle, use the triangle ID to first check the flag. If the flag is unset, add triangle ID to resulting list of candidates and set flag. Ignore triangles with flag already set. I encode this as a bitflag array so 8 triangles is 1 byte. I share this with all queries as long as it isn't multithreaded. Right before each search for triangles, I clear the array to zero. Performance is not bad. Store a last_search byte per triangle in an array, allocated once, associated with the triangle mesh. Have a static search_number byte for all queries, again associated with the triangle mesh. Initialize each triangle byte to zero via memset(). Initialize the static to zero. On first search increment search_number. Any triangle last_search not equal test and set to new number. If search number, when incremented, is zero memset last_search array to zero. Result is a clear every 254 searches.