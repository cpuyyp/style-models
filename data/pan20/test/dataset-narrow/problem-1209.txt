I don't think any such algorithm is known. The results I know about maximizing the minimum angle in straight line drawings of planar graphs are: 

A family of bitvectors is the class of solutions to a 2-SAT problem if and only if it has the median property: if you apply the bitwise majority function to any three solutions you get another solution. See e.g. $URL$ and its references. So if you can find three solutions for which this is not true, then you know it cannot be expressed in 2-CNF. 

If you like you can think of this as a stack or a queue with a split operation that splits it into two stacks: the extract operation can be used to implement a pop or dequeue operation, and the extracted sequence of items could as well be put back again into a different stack or queue. What I already know: one can maintain the sequence as a doubly-linked list, where each identifier is just a pointer to a linked-list node, and each node also stores a position number that allows fast comparisons between the positions of two unrelated elements in the sequence. It's not difficult to update the position numbers as the data structure progresses so that they are all positive integers of maximum value $O(n)$, where $n$ is the current number of items in the list. With this data structure, the only difficult part of an extract operation is sorting the extracted items by their position numbers. An extraction of $k$ items takes $O(k\sqrt{\log\log k})$ expected randomized time using the integer sorting algorithm of Han and Thorup from FOCS 2002, for instance, and a push operation takes constant time. What I don't know: is it possible to handle extract in $O(k)$ time and push in constant time? Is there literature on this problem? Is it as hard as integer sorting? Motivation: this is the basic step needed to order the items in the Coffman-Graham scheduling algorithm, which also has applications in graph drawing. The hard part of Coffman-Graham is a lexicographic topological ordering. This can be done by maintaining, for each different indegree, a sequence of the vertices with that indegree in the subgraph induced by the remaining vertices. Then, repeatedly remove the first vertex $v$ from the sequence of zero-indegree vertices and add it to the topological order; extract the neighbors of $v$ from the degrees they previously belonged to and push them onto the sequence for the next smaller degree. So an $O(k)$ time for the extract operations in this data structure would lead to a linear time implementation of the Coffman-Graham algorithm. Since originally asking this I found a paper by Sethi from 1976 that allows the Coffman–Graham algorithm to be implemented in linear time, and included it in my Wikipedia article on the Coffman–Graham algorithm, so the original motivation is less meaningful. I'm still curious what the answer is, though. 

For several references for the problem of testing for the existence of a triangle (exactly, not in the property testing framework), see Triangle-free graph on Wikipedia. In particular Alon, Yuster, and Zwick (ESA'94) give an O(m^{1.41}) algorithm, and it can also be done in fast matrix multiplication time which is better for dense graphs. If you're ok with something in the dynamic graph algorithms setting, I also have one for counting the triangles: The h-index of a graph and its application to dynamic subgraph statistics, D. Eppstein and E. S. Spiro, arXiv:0904.3741 and WADS 2009. In our paper we cite Chiba and Nishizeki (SICOMP 1985) and Itai and Rodeh (SICOMP 1978) for the basic static-algorithm facts that a graph with m edges can have at most O(m^{3/2}) triangles in the worst case and that they can be listed in that amount of time. 

It really makes a difference what the input to the algorithm is: how do you specify a group? If you want groups given by generators and relators, I would suggest Combinatorial Group Theory, by Magnus, Karrass, and Solitar (but algorithms there are sparse because too many of the important problems are undecidable). If you want automatic groups (groups whose elements are strings of symbols and whose group operations are performed by finite automata, with applications in low-dimensional topology), I would suggest Word Processing in Groups by Epstein (not me!), Cannon, Holt, Levy, Paterson, and Thurston. If you want permutation groups (the kind of group-theoretic algorithm that is most relevant e.g. for graph isomorphism) then Seress has a book Permutation Group Algorithms but I don't have a copy so I can't tell you whether it's any good. There should be a fourth paragraph here about matrix group algorithms but I don't know of a book on that topic. There's a little coverage in Seress's book. 

I believe the answer to your question, and to most questions like this, is to be found on $URL$ There's also a book that has much of this (including an appendix at the back with some of the main subset relations between graph classes): Brandstädt, Andreas; Le, Van Bang; Spinrad, Jeremy (1999), Graph Classes: A Survey, SIAM Monographs on Discrete Mathematics and Applications, ISBN 0-89871-432-X. The answer to your specific question is no. The graph shown in $URL$ (a central triangle with three more triangle attached to its edges) is chordal, but its complement $URL$ is not a comparability graph. 

An upper bound on $|E'|$ is the sum of the cycle ranks of the non-bipartite 2-vertex-connected components, since the cycles for the edges in $E'$ are necessarily linearly independent. But I think this is not tight: the 3-sun (a six-vertex maximal outerplanar graph formed from a 6-cycle by connecting three of its vertices in a triangle) has cycle rank four but the maximum size of $E'$ appears to be three. 

The UCI Network Data Repository has a collection of social networks, with additional attributes (not just vertices and edges). They also have a set of links to similar collections elsewhere. 

If a graph has bounded crossing number it can be drawn with that number of crossings in the polyline model (i.e. each edge is a polygonal chain, much more common in the graph drawing literature than bounded-degree algebraic curves) with a bounded number of bends per edge. It's also true more generally if there is a bounded number of crossings per edge. To see this, just planarize the graph (replace each crossing by a vertex) and then apply Fáry. Now, to use this to answer your actual question, what you need to do is to find an algebraic curve that is arbitrarily close to a given polyline, with degree bounded by a function of the number of polyline bends. This can also be done, fairly easily. For instance: for each segment $s_i$ of the polyline, let $e_i$ be an ellipse with high eccentricity that is very close to $s_i$, and let $p_i$ be a quadratic polynomial that is positive outside $e_i$ and negative inside $e_i$. Let your overall polynomial take the form $p=\epsilon-\prod_i p_i$ where $\epsilon$ is a small positive real number. Then one component of the curve $p=0$ will lie a little outside the union of the ellipses and can be used to substitute for the polyline; its degree will be twice the number of ellipses, which is linear in the number of crossings per edge.