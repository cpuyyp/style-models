You seem to have connected the LED to GPIO 12 which is connected to expansion header pin 32. You are using pin numbering (GPIO.BOARD). Either use GPIO numbering (GPIO.BCM) or move the LED to pin 12 or use led=32 in your code. $URL$ 

The specified function will be called asynchronously to the main thread, i.e. it will still be called even if the main thread is waiting in a raw_input. Generally you would use global variables to pass state information between the callback and main thread. 

It would be helpful if you edited your question to add a photo of your connections. Typically a red stripe indicates pin 1. The red stripe should be over the pins at the top edge of the board, i.e. the pins furthest away from the edge with the USB sockets. See $URL$ pinout $URL$ 

You don't need any cooling for normal Pi usage. If the Pi is in danger of overheating it will throttle back the CPU to cool down. If you plan and need to run the Pi at maximum speed continuously then cooling will be useful. Cooling will lessen the need to throttle the CPU because of overheating. 

Once data is true the character will be printed forever. Simplest solution is to set data = false before the initial if. 

Personally I would just use a UBEC and drive the Pi and the motors from the same 5V supply. A UBEC converts a voltage in the range 6V to 26V to typically 5V and is what a lot of model airplane and quadcopter enthusiasts use. Your motors should work from 5V. 

You only need additional hardware if the servo draws more power than the Pi can safely supply. In that case the required additional hardware is a suitable power supply. The Pi should be able to power your 9g servo as long as the servo is powerful enough to depress the button without stalling. So connect servo 5V to a 5V pin, servo ground to a Pi ground pin, and servo control to a Pi GPIO. My pigpio library can generate the needed servo pulses on any GPIO on the expansion header. 

A couple of points. The digitalRead(x) function returns the current level of the GPIO numbered x. For instance digitalRead(21) will return the current level of whatever GPIO is assigned the number 21 by wiringPi. Your code contains a logical error. will evaluate to false as 21 is taken to be true and LOW (0) is taken to be false. False is represented by zero in C so the call reads GPIO 0. will evaluate to true as both 21 and HIGH (1) are taken to be true. True is represented by one in C so the call reads GPIO 1. The code should be changed to and . I'd probably use an else clause instead of the double test. The other point is that the signal is brief. You can not guarantee that you will be reading the pulse especially as the reads are only made once per second. You need to explore the use of interrupts within wiringPi. Get wiringPi to tell you when there is a rising edge. If there has not been a rising edge for more than 6ms that means a car is present. The following Python script shows the sort of logic you need to implement. 

As the author of pigpio I would only use the pigpio Python SPI, I2C, and serial functions if you are using pigpio over a network. The pigpio Python module uses the socket interface to the pigpio daemon. You should use the Python smbus module if you are running Python on the local Pi. The pigpio C bit bang functions will be required if you need >10K samples per second. 

The first thing to look at is the packages available within Raspbian. To search for a package use the following command. 

At power-up all GPIO are set as inputs. GPIO 0-8 have pull-ups to 3V3 enabled. The other GPIO have pull-downs to ground enabled. During boot some GPIO may be configured differently according to what you have asked for in . If this causes problems you need to find an electronic solution as there is nothing you can do about it in software. 

Yes, you will need an ADC, the Pi has no analogue inputs or outputs. A popular choice would be an MCP300X (10 bit resolution where X is the number of channels) or MCP320X (12 bit resolution). They connect via the Pi's SPI bus (GPIO 7-11) You will find plenty of software and tutorials for those chips and the Raspberry Pi. 

The pigpio daemon does not issue that warning (warning, not error). The message is issued by the RPi.GPIO Python module. If I remember correctly RPi.GPIO tells you what do do if you don't want it to print that message. For details on what the message means refer to the RPi.GPIO documentation. 

I suggest you use TCP as that is what most applications will use. I'd use Python as probably the better supported choice. Lots of socket examples on-line to get you started. 

You haven't said how you are powering the fan. "I have a bought a fan and plugged it into my Pi" is vague. Given that it stays on I reckon it's safe to assume you have connected it to a 5V pin and a ground pin. These pins are not GPIO, they are not switchable, they are powered as long as the Pi is powered. So the answer to your question is no, there is no command to switch the fan off. 

Initially set each of the pins high so that each device is at I2C address 0x63. When you want to access a device set its pin low. That device will now be at address 0x62 and may be accessed through I2C. When you have finished with the device set its pin high. Only one of the device pins must be low at any one time. 

You need to specify the GPIO you are connecting to the motor driver board which in turn controls the motor. The motor driver board normally has two pins per motor. If you set one pin high, the other low, the motor turns clockwise, if you reverse the polarity the motor goes counter clockwise. For the gpiozero documentation see $URL$ 

May I suggest you use 2 (or 6) cells in series and use a UBEC to generate the 5V. This is pretty much what UBECs are designed to do. A L7805 will just be wasting energy as heat. Example UBEC. 

I suggest you raise an issue (not sure where). My pigpio Python module has an alternative SPI implementation (spi_open, spi_xfer, spi_close). From the command line 

There are two PWM channels used by the audio jack (left and right I guess). These audio channels can be directed to zero, one, or more gpios as follows. 

Yes, it is straightforward. You need a motor driver board. Each motor driver board will typically drive two DC motors so for four motors you would probably need a couple of motor driver boards. If we assume these are small hobby motors they will only draw an amp or so at 6V. If that is the case look on eBay for L298N or L9110S based driver boards. L9110S based ones can't supply as much power as a L298N based one but they are much simpler to use. You should be able to buy the boards for a few GBP each. To control each DC motor (in direction and speed) will require either 2 or 3 gpios. So for 4 motors you will need between 8 and 12 spare gpios. Recent Pis have 26 available gpios so this shouldn't be a problem. There must be thousands of tutorials showing how to use these boards. Google will find them for you. 

The serial driver (see stty, man stty) only supports 5-8 data bits. The nearest standard serial speed is 230400. You can get 1.25 Mbps by using the init_uart_clock setting in /boot/config.txt (set it to 16 times the maximum value you want to use, i.e. init_uart_clock=20000000). stty will then let you select 1250000 bps. I'm not aware of a practical solution for the 9 data bits. I've read of people trying to use the parity bit as an extra data bit. 

pigpio will be able to send any infrared code you know how to construct. pigpio also provides a wrapper to capture and send well behaved codes. By well behaved I mean codes which don't change from press to press and are not a ludicrous number of bits long (some IR codes are a pretty unnecessary hundreds of bits long). In the first instance try this IR record and playback example. If that doesn't work an alternative to try is to record the IR code with piscope and play it back with this playback piscope recordings example. All the above example require that the pigpio daemon is running. It may be started with the following command. 

To answer the question "Long story short: Can anyone tell me how I can achieve a duty cycle with a pulse width of 0,8ms to 2,1ms for controlling a servo using the hardware PWM on the Raspberry Pi.". Recent Pis (the ones with the 40 pin expansion header) have two hardware PWM channels available. Channel 0 is available on GPIO 12 and 18. Channel 1 is available on GPIO 13 and 19. So you can have hardware PWM on GPIO 12/13/18/19. However 12 and 18 will have the same settings as will 13 and 19. pigpio has C, Python, and command line methods to choose the settings. From the command line 

EDITED TO ADD It's not clear from your question but to clarify you can NOT back power a B+ through a USB hub. 

The main piscope display will be blank until there is GPIO activity. You can trigger activity with the following command (on the Pi or the networked Linux machine). 

As long as the power bank outputs 5V it will power the Pi. It claims 50000mAh so it claims 2.5 amps per hour for 24 hours. Assume it will deliver half that so 1.25 amps for 24 hours. If that is enough or not will depend on what you have connected and what the Pi is doing. 

EDITED TO ADD The MCP3008 works on bits, unlike the Pi it just sees a bit stream. It is important to note that the MCP3008 will ignore bits in the bit stream until a high start bit is detected. As far as the MCP3008 is concerned a transaction is 17 bits long as follows. 

The DS18B20 is a (Dallas) 1-wire bus temperature sensor. It uses one wire for control and data. Early versions of Pi software only allowed for the 1-wire bus to be started on GPIO4. You are looking at old or incomplete tutorials. Recent versions of Pi software allow the 1-wire bus to started on any spare GPIO. There is still the limit of just one bus though. To configure the 1-wire bus use device tree. See for details. 

The last Debian distribution tailored for the Pi was available from ftp://ftp.mirrorservice.org/sites/downloads.raspberrypi.org/images/debian/7/2013-05-29-wheezy-armel/ I used that distribution as a base but keep it in line with Debian jessie by apt-get'ing from the appropriate Debian (not Raspbian) archives. As far as I know you shouldn't try to mix soft-float and hard-float packages. Have you tried your printer under ordinary Linux? It may work but just with limited capabilities. 

Is there any reason not to use the one in the repository? The repository version will be compatible with the other Raspbian modules. 

In normal use it would be your 5V power supply maximum rated amperage less the amount of power used by the Pi and other peripherals. These are all unknowns so your question as posed is unanswerable. However the Pi's PCB traces may well act like a fuse (and pop) if you try to send 3 or 4 amps through them from the microUSB to the 5V pins. 

Pins and GPIO are not the same thing. You can not power the Pi via the GPIO. You can power via certain pins on the expansion header. Pin 2 and pin 4 are 5V pins. You should only supply power via a 5V pin. DO NOT try to provide power via the 3V3 pins or any GPIO. 

If you are using recent software (last 6 months or so) you should be using device tree. Add the line to the file . Remove the line from . Reboot. 

EDITED TO ADD To manually run the command you can do something like the following. Create a file in /usr/local/bin called mysync with the following content 

That relay may not be suitable for the Raspberry Pi. The blurb indicates that a low signal is 0-2.5V and a high signal is 3.3-5V. Perhaps the Pi isn't managing to generate a high signal. You could test by connecting one of the relay inputs to a 5V pin rather than GPIO 17/22.