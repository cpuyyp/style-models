After much deliberation and a stroke of insight I figured out what the problem was. It was a problem with my shadow map vertex shader; I wasn't putting the objects into model space. That means that all objects were being rendered at 0, 0, 0 with a scale of 1 and no rotation. OOPS. Properly applying a model matrix in the shader managed to fix the issue. EDIT: If you're interested in seeing the exact code that fixed the problem here's a link to the commit on Github: $URL$ There was some extra architecture that went into getting the model matrix sent to the shadow shader that might be interesting. 

When in reality Balls A and B are very close but have the exact same velocity! What should happen (and what you would get with Approach B) is: 

Yep, you're out of memory. Loading all of those textures (which I assume are going to be very large since they're backgrounds) is going to eat through your RAM pretty quickly. There are a couple different ways you could solve this. 

An efficient SAT test is "Exit Early" meaning if you're just testing for collision, you see the collision and end the algorithm. Of course for the situation you've presented exiting early is no good; you need more information. I ran into this problem too. The solution is fairly simple. You need to test ALL axes during your SAT test and not exit when you find one collision. I end up returning a "Collision" object from my SAT test which stores a vector of points where the objects collided. Of course this can turn out to be a big time waster since there may be some collisions where you care about resolution and some where you don't. There may be some cases where you DO want to exit early and others where you don't so keep that in mind. 

Collision resolution is no easy beast. You need to take a step back and realize that you're going to need to simulate some simple physics. Game physics don't have to be super accurate and you can tweak gravity and resultant forces however you want but you need a solid framework to build off of. I recommend that when handling collision resolution you have a Physics management system that's separate from your collision detection system. How I usually do this is with something along the lines of 

I figured some images to illustrate the problem would be pretty useful. When I render with the castle it looks like this: 

Interestingly the shadow map is really just of the castle, the other objects aren't in the shadow map. Now the scene with just the floor: 

What you're looking for is "spatial partitioning". You want to break up your world space into smaller chunks to cut down on how many objects you detect collision against. Since you're just doing 2D you'll probably want to use a "quad tree". There are other options including BSP trees but in my experiences quad trees are the best all around solution. As for determining which class you're colliding with C++ doesn't handle that as nicely as C# or Java do. You can either use a "dynamic cast" to cast a generic collider class to a more specific collider class or you can store a hash of the specific type id in the generic collider to know which class to statically cast to. 

It's quite simple, you're already sort of doing it with your terrain, right? You draw your terrain first and then you draw your entities. Whatever is drawn first will be drawn further back in the depth. What you can do for your drawable entities is give them a depth sorting index. Then when you tell them to draw you sort them into collections based on their depth and actually draw them from lowest depth to highest depth. If entities draw immediately when you tell them to you may need to reorganize that. What I do in my engine is I have a Rendering Manager class. When I want to draw something I pass what I want to draw to my Rendering Manager which sorts them into different collections based on their properties and then draws them in the right order with the right properties. The Rendering Manager is the class that actually executes the draw logic; when Entities "Draw" they just alert the Rendering Manager that they want to be drawn. I don't know how in-depth you've gotten with Slick and frankly I'm not really familiar with the API but it appears to mostly expose OpenGL. If you represent your entities with a world matrix you can simplify this process quite a bit. You're working in 2D but OpenGL always has a concept of all 3 dimensions. The Z axis can act as a depth ordering axis of sorts. The further back something is positioned on the Z axis from your camera, the further back in the scene it will be drawn. If you do this you don't have to worry about the order of your draw calls at all but rather objects should naturally be drawn behind other objects if they're positioned further away on the Z axis. If you're not directly doing any OpenGL calls this won't really be possible unless Slick2D gives you a way to represent position on the Z axis. 

You're already halfway there since you send matrix data every frame. A little bit of history. s used to be called because their value varies depending on the vertex in the buffer. s are called such because their data is uniform across every vertex of the buffer. Since your matrix is the GPU can handle it being changed at runtime since it's just one blob of data for the whole buffer. See what I'm getting at? You're already changing your matrix every frame. Your matrix is "dynamic". So just do what you did with the matrix. When you setup your shader, you can get the location of the in your shader with: 

No you do not. Everything Steam provides is optional to use by the developer. If I remember correctly The Binding of Isaac, the original one, was written in Flash and had no chance of ever integrating the C++ Steam SDK. As a result there was no Steamworks support or Steamworks DRM on the game. 

Box2D has a Java library. It might be a bit more than you need but it's pretty robust and used in all sorts of projects. Maybe someone else can recommend a better library solely for collision detection. If you want to roll your own solution, which would probably be better if you want to keep it simple, you'll need to look into Oriented Bounding Box (OBB) collision detection. The Axis Aligned Bounding Box (AABB) algorithm is super simple but OBB is not nearly as nice. It requires a fair amount of math involving matrices so if you're not solid on that this is a great opportunity to learn. Separating Axis Theorem (SAT) might be a bit much for 2d OBBs but it's a solid multi-purpose collision detection algorithm. Gilbert–Johnson–Keerthi (GJK) is another algorithm that's used more for objects that are in motion but may also be good for your needs. Real-time Collision Detection by Christopher Ericson has some really great samples and the book is great for all things related to collision detection. The book actually has a really great example method that I don't think I can paste here because of copyright. However there are always more examples online. $URL$ $URL$ 

Of course this isn't even as generic as it can get but it's relative to your problem. During the stage you should determine your velocity. If the player has clicked why not set a velocity that doesn't change unless the player clicks again or right clicks to stop. Otherwise just move the player if a key or keys are down in a certain direction. Then you can apply that velocity to position, detect collision and react. If this is more involved than you want it to be I'd suggest using something like Box2D to handle the collision logic for you so you can just worry about getting your player walking around the way you want. 

I've been playing around with rendering shadow maps using FBOs in OpenGL. I set up a simple directional light in my engine and managed to get a shadow map rendered. My Scene is a big castle and the shadow was cast over most of the other objects in the scene. Out of curiosity I removed the castle and just added a simple floor and my shadow map no longer renders properly. It seems that only one object at a time is making it through my render pass and onto the shadow map. Here's an overview of the way the render is structured: 

Which game specifically? What engine does it run on? Is the source available? If the source isn't available then you're SOL unless you REALLY like decompiling. Chances are good the code base is C or C++ (lets hope so). That means you have to compile with the Android NDK which isn't trivial. My experiences with it have been painful. You're right you have to refactor the game to use touch events which means a complete overhaul of the input system and designing a control scheme that works on a phone. You'll also need to re-write the window management system. Android uses an Activity system and you'll need to create an activity and a GL context from inside the NDK (which sucks) or you'll need to create the Activity in Java and call all the game logic through the JNI. Lets also not forget that older games sometimes use assembler. x86 isn't compatible with ARM so you'll need to rewrite those sections in either ARM assembler or just C/C++ and let the compiler handle it. It's not easy but at the end of the day you'll end up with (hopefully) an APK that you can install on your phone! Speaking of assembler, compilers suck. Different platforms implement C/C++ slightly differently so there may be some parts of the code where the developers relied on assumed type sizes which can change from platform to platform. These problems might manifest when you try to run the game as random crashes which will require some serious debugging so watch out! Lets not forget about drawing to the screen! Older games sometimes used "software rendering" where the program itself (rather than a GPU) would draw to the screen. This is big no-no nowadays so you'll need to refactor all that code to use OpenGLES. If the game uses hardware it will probably use an older fixed function version of DirectX which will need to be rewritten as modern GLES. Heck even if the game is using a modern OpenGL drawing system you'll still need to make sure all the shaders will work well on mobile. A lot of problems can be alleviated by using SDL2's Android port. It should make it a bit easier to handle input and setup all the OpenGL goodies you want. Heck you could probably use the SDL surfacing system to draw instead of doing all the OpenGL yourself. Here's a good article on writing native activities in Android: $URL$ Here's the SDL documentation for Android: $URL$ For SDL you'll probably need to be using a *nix environment. Check out Cygwin or CMDER if you're on Windows (I like CMDER) Good Luck! Don't forget to come back and ask more specific questions if you get stuck.