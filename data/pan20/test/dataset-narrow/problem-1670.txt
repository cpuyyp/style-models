Notice the GPIO ribbon out the side and the red/yellow/orange/brown wires on the second header, which attaches the 8x8 LED inside the clear top case. To actually make this work, you have to reconfigure some pins. Also, as mentioned, enabling this disables the camera connector, but can just as easily be switched back on the fly. There are some stand alone utilities that you can use to enable the second bus. Originally I used hipi-i2c -- installation instructions here, but unless you are installing to Raspbian wheezy, they won't fly. Currently I'm using a blip of code compiled with libbcm2835,2 run from . is the regular bus; now there's 

If you did not modify the old one, I don't know what would have (pretty sure and do not), but this could in fact just be a minor mistake. I usually just say use the package version in that case, but you may want to have a look at the option ("show the differences between the versions") to see if anything jumps out that you think might have been added to your current version by some piece of software. If you do just say yes, check after the update is done to see that it looks like the one above. 

If you are using apache, it runs as its own user and does not have permission to run with . To do that, you have to edit (as root) and add a line: 

and should now be identical. There should not be a -- that means you left the off. When you are sure this is all good, you can delete everything in , but keep it as a directory: . This will free that space up in your root partition. Add a line to : 

You may also need to disable the serial console. The easiest way to do this is via under Advanced Options -> Enable/Disable shell and kernel messages on the serial connection. If you don't have , it doesn't work, and/or you want to double check, first look in . If you see: 

This will then be applied if you are using a graphical login, so that you do not have to boot to console. To test it from the console, try with no arguments. 

This is because newer Raspbian kernels use device tree "to manage some resource allocation and module loading": 

Have a look here but scroll down to the part about . Running on the pi via wifi ssh gives me (after about 30 seconds): 

If you have reason to believe this should work, fair enough. If it is just something you decided upon, I would use something other than in , e.g., or (check to make sure those are in use with first). By the way, you do not mention doing this: 

You do not mention the OS, so I'll presume it's Raspbian or some other linux variant. This depends on whether that display can really use a USB for video input. I don't have one, so I'm not promising anything, but there is a USB driver for Apple Cinema displays included in the default kernel.1 However, I think it is just for using the USB as a control line for the backlight. If you plug it in via USB presumably this will load; afterward check with: 

The default pi kernel may or may not have the right drivers built in to mount the external drive without the root filesystem,1 so the first thing you'll have to do is investigate that and if it doesn't, build a kernel that does. It's probably okay (various blog posts online imply a custom kernel is not generally needed), but this is important to note just in case. Once you have that, make a copy of your primary partition (the 2nd one) from the SD card onto the HDD to test with. Do not do this naively while the pi is running. It should reflect the state of the filesystem while the system is off, so take the card out of the pi to copy it. If you make the copy by duplicating the entire filesystem, you'll need to change the UUID, since otherwise it will be the same as the second partition on the SD card. To get the UUID under linux, if the partition is : 

Reference the specific version of python you want to use in the shebang. is a symlink. On my raspbian pi it's to python 2.7: 

Yes, you are not the first person to report this here. I just went looking for those other reports but could not find them, however, there is the chance they were pruned from the system if they were closed without an answer, as they might have been. I can definitely remember one and possibly two others over the past three years. Here's the thing, though: Without getting into book length explanations of the nature of IP and level 1/2 wireless and wired networking (yes, I've read them), you'll have to take my word for the following fact: It is NOT possible, either via error or deception, for a single device on a subnet to cause other devices on the subnet to spontaneously disconnect, or for them to induce the central gateway (router) of that subnet to spontaneously disconnect them or otherwise wreck widespread havoc except: 

You can use the command-line app ("framebuffer image viewing"). The framebuffer is also what uses. Fbi is available from the raspbian repos and should be in any other GNU/Linux distro as well; it is not specific to the pi. It takes a filename or series of filenames, and you can use shell globbing for this, so e.g.: 

More in (you don't need 2 this time since there's nothing in section 1 by that name). You can find stuff like this with, e.g.: 

I hate to be a stickler, lol, but you need to clarify some things, because on a literal level this is not possible. ALL network communication requires a two way relationship. If you initiate a connection with another computer, the ONLY way for that connection to be established is for that computer to send back a response. 

Running something inside a GUI won't make any real difference performance wise unless the additional memory consumed becomes significant. Ideally, on the pi you probably want at least 50-100 MB free for the page cache, which does generally speed performance. If you are not getting that, you want to try and free some up, whether it is from a GUI or something else. Beware that many tools include (or distinguish) the page cache in their reporting of memory use, so if at first it appears full, check and see if that is the case. If it includes the cache and the system has been in use for a while, it should be full. Likewise, if there are other things active and contending for CPU time that are part of the GUI, this will have an impact. However, this is equally possible without a GUI. In my experience the only significant culprits here are (ironically) eye candy system monitors, which on a pi may use as much as 5-10% of a core depending how frequently they update. You can use tools such as or to check for this kind of thing, GUI or not. Since they're monitors, they may end up appearing frequently near the top of their own list, but you only need them for evaluation. 

As per my comment, the Pi does not use an Intel based ISA and so this will probably impact whatever you are trying to do in not insignificant ways (I don't know enough ASM to say how much or how definitely). Which is not to say it won't be possible, it may just require a little more hacking of the concepts ;) Anyway, the reason you are getting that error is that is a non-option on the GDB in Raspbian. Here's output from on an x86-64 (Intel) machine: 

That said, if "my newly built OS using Yocto" is just a root filesystem, then you would want to recreate or delete the content from and copy in the content from the Yocto root fs. However, there is a significant issue with that, namely that the kernel is loaded from the first partition and it will not match the available modules in the new root fs. You could solve that by not deleting the old but I suspect this is not your scenario, since if you were trying to install a new root fs I do not think you would be asking this question. 

The controller is a Microchip LAN9512 and the reason it is used instead of, e.g., a bunch of independent controllers is presumably: 

You've misunderstood the purpose and circuitry of a pull-up/pull-down resistor. They aren't in line with the pin to protect it, they are in line with ground or a voltage source in order to prevent an input pin's value from floating in a high impedance state. Here's a pull-up circuit: 

That number is 2^16 - 1, that is, the maximum range of a 16-bit unsigned integer. That kind of number will wrap around to become 0 if you add 1 to 65535 (or 65535 if you subtract 1 from 0, since unsigned numbers cannot be negative), meaning it is only an error of 1 in relation to 0. 

I'm not a python user, but the (probable) reason for the old version is that it's debian policy to take a sometimes excessive amount of time to update versions, plus the package may be obscure (hence updated even less), plus raspbian itself is pretty obscure in relation to debian (hence the packages there are updated even less). Ie, it's a consequence of available resources (the people who maintain the packages, who are usually not the upstream developers). 

The norm for GNU/Linux systems is to set the hardware clock to UTC (I'd guess this is most likely true for POSIX systems generally) aka. "universal common time" or "coordinated universal time", neither of which abbreviates to UTC (and neither does the original French; apparently this is a bizarre compromise). Although it is not a necessity presuming the hardware clock is timezone aware, it will keep your life slightly less complicated to stick with that. By my reading of , technically, the "system" time is always considered to be UTC, then adjusted at the application level according to the timezone configuration (native library functions may do this by nature and hence it is really a sort of system-application interface level). So, if your RTC is set up as the hardware clock and is set to UTC time (as per my comment on the question, it appears that it is), you should get the correct time from most applications. You can set the hardware clock to the system time using , and the RTC in all the desktops/laptops I've ever used seem to be timezone aware,1 so you can then use the system time "unadjusted". However, particularly if you live in an area which springs forward/falls back twice a year, there is not much advantage to this and it may bite you at some unexpected point. 

The gauge is obviously fine for anything running off the pi at a distance of 8". The durability is also fine, considering the pi itself is kinda delicate and you haven't said anything special about the circumstances. The casing is reasonably thick and doesn't split or crack unless cut. You can tear them apart without accidentally exposing any metal. Those are stranded aluminum and pretty easy to strip with an exacto knife if you want to solder them on at one end. The only thing about them vs. a cable is it gets tedious pushing them individually onto the pi pins if you are going to plug and unplug whatever regularly. However, the square connectors are the right dimensions to tape/glue together if you are connecting to a bunch of adjacent pins.