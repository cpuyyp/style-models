Well, yes and no. If you absolutely must instantiate classes by name as a string, and you absolutely must have exactly one namespace for classes, and you absolutely must not use the object or a module scope as that one namespace (i.e. just declare a function in your source), the way you're doing it is probably the simplest method. I would add a to make it more user-proof. However, for all the same reasons as above, I would again have a good hard think about how badly you need to instantiate objects by the name of their class. If you want to actually do reflection, you'll need to re-implement by name, etc. etc.; if you want to segregate your classes into namespaces or give them any other kind of scope, you have to re-implement scope. 

Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

Perhaps I'm missing something, but is there a reason you aren't converting to first with any of a set of functions, then formatting the output in a separate set of functions? e.g.: 

Since it has been said already, I will leave the issue at "figure out what's responsible for memory management" without further explanation. I have a few things to add: DRY, DRY, DRY! (ha.. ha... tumbleweed) It is possible that some day, you will want to change your container type. Maybe you import a library, maybe you need different performance or thread safety, maybe you write something entirely new that better serves your purposes. You did half the work of protecting yourself from this change by making a for , but you also have throughout your code, as well as its corresponding iterator. You can DRY that up by using the instead of in all cases. Possibly add another for the iterator type. That's just to save some keystrokes, though, rather than typing out every time. You probably won't ever change the fact that you need an iterator specific to your container, so is also fine if you don't care for brevity. The other thing I see repeated over and over is the code to select a subset of your s based on their subclass. I doubt that your 's role includes enforcing the class hierarchy, so you don't want the manager coupling to it. That makes your manager brittle to any extensions of you may make later - at best, every new type requires not only its own code and header, but also a change to the manager class, lest it remain un-queryable. There are two ways to go about reducing that coupling. Probably real OO gurus can think of more, but I'll stick with the simplest: 

Firstly if you are going to be passing objects of type around I guess you best be prepared to do a few casts here and there. You can achieve this using a simple interface and templates quite easily. Interface: 

Then onwards. Arguably this is borderline procedural but with these few steps I think that is acceptable. Edit: Less readable, more old school 

On the whole it's not at all bad, I find it readable and I'm sure that it does the job (one caveat to this is how does it handle cases where you have multiple instances of the same point e.g. {{1,1},{1,1},{1,2},{2,1}}), a few things that you could do to improve it.. 

Then, you can make your list of number formats more declarative; construct an array, output the descriptions, and have the user pick what will effectively become an index into the array for the source format. Then read the destination format and numeric string, in either order. As it stands, the input method is needlessly coupled to a finite set of formats and their names, as is the source/destination pairings. I once wrote a hex-by-default calculator/expression evaluator in assembly, so I'm the last guy that's going to call a wheel-reinvention foul on you; in fact, I like the general theme of your code because I've never seen a number formatter that covers absolutely everything, like your binary output's adding leading zeroes to pad 4 bit groups. Bravo on making a wheel that spins exactly like you want it to. With regard to the conversions themselves, I see more twos complement math than is necessary. In particular, I see several s while converting to binary. If I'm interested in a number's binary representation, I will probably find the equivalent ones complement operations in your code just as readable, if not more so. The sequence: 

For reference you can also check this excellent article from Smashing Magazine (check the author) and related GitHub repository. 

-. When you are coding your method start thinking in templates. Sure it's not necessary now, but it costs nothing to write and you've got a utility function you can use forever. One thing that would concern me about this method is the Cyclomatic Complexity due to the number of loops and conditionals. Consider how you could break things down, e.g The content of your loop can be broken out into code which finds/verifies the rectangle is complete. As a rule each method should have a role as discrete as possible, again this makes things more testable and more readable (when coupled with sensible naming). 

/UPDATE In a more inclusive sense, the pattern you're describing breaks a lot of the functionality that JavaScript provides natively when you use established idioms for creating objects. You lose , you lose , you lose , you lose , you lose , and you lose either lint or . You're also forfeiting your IDE's documentation and code completion for your classes and constructors (unless you're writing code in notepad anyway, or something). It comes down to priorities: how desperately do you need single block "classes" and reflection, and how certain are you that this is the only way to do it? 

Next, don't try to return every type of Object from the one Switch statement, it will always be ugly. In order to work out the next step maybe you could elaborate on what is happening outside the blackbox, e.g. if the calling code wants a Double you could add that into your enum: 

Are you changing the fields that you expose from your objects depending on certain conditions? On the whole it would be best to use reflection only as a last gasp. Gson works fine with collections in general see the documentation over at Google. If you want to exclude some fields from serialization then you can use the annotation, as documented here. This requires you to annotate all fields that you want to serialize with the annotation, and to use a builder to instantiate your Gson Object like so: 

This looks perfectly good to me. Everything has a unique purpose, everything is either clearly explained or self-explanatory. Unless you have tested this and found a performance issue, and you are sure that it is happening here, do not do any optimization to this. There is no loop and no recursion, the code itself can't properly be an optimization target. If you are observing that this is running slowly, the hidden costs of setting the scrollbars must be the cause. To address this you will need to change your entire strategy to keeping the contents in the right place using CSS only. I have to say that while I find using the position of some element (?) to be a pretty elegant way to duck issues of messing around with coordinates that will be inconsistent otherwise, it is technically the best practice to do all positioning with CSS. 

In general try to limit how much you are working with the type and reduce as far as possible your use of reflection. 

If there is other code and you need all the features of a TreeSet great, otherwise delegate to a TreeSet member variable. Your code is somewhat superfluous because of the next test 

Your iterations would need to evolve to use the SortedSet#tailSet or SortedSet#subSet methods. Both of these are just new views on the same data so they are cheap operations. A pseudo approach: 

By using an enum you clearly enumerate all the supported cases and encapsulate your data without resorting to data structures that do not fit your purpose. If your data is not clearly defined, or is dynamic or extensible in anyway then the enum approach will not work. At this point I would need to understand the relationship between the key and value in your map. If the key describes the parameter and the two values encapsulate the behavior then the key should be a part of the object (if this is the case you are using as a tuple). In this case you should begin by modifying to include a parameterName member variable and then override and so that you can use in a set. How you chose to override the methods will depend on whether you can have multiple instances of a parameter with different values or whether each parameter name should be unique. If your data is hardcoded today, but might not be tomorrow, don't worry about it. If your data is hardcoded today and won't be tomorrow you could define an interface, say . This interface can expose whatever maethods might be useful to you - size, iterator, next... Create a single implementation for today say or - whatever accurately describes the data you will be feeding back. This means that in the future you could add a or or whatever. Now, inside your you could create an enum as described above. If you need to iterate over the values to convert them into another structure you can use the method: 

Again, that will change a few things logically throughout your code and header, but it will end up far cleaner and clearer than it started. You've got pointers to pointers in C, an often underestimated advantage over other languages, and so far you're doing great with them. If you can handle using them for pointers to arrays of pointers, you can handle using pointers to members as objects. Other than that, the nature of the task demands a bunch of hairy pointer-chasing and a little bit of pointer math, which is tough to read. Stuff like takes a second for me to digest fully. If your comments were at all lacking, I would want some of the longer statements to be broken up and have some intermediates made into local variables with names. However, your comments spell out what's going on very clearly, so I don't think that counts against you.