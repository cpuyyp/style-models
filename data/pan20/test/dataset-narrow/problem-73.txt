IP is unable to deliver a packet to the correct service/application. And TCP/UDP is unable to deliver a packet from one end of the internet to the other. Both TCP and IP work together to enable them both to achieve the "end-goal" of Internet communication. Data that needs to get from one host to another is generated by the upper layers of the OSI model. This data is passed down to L4 which will add the information necessary to deliver the data from service to service, like a TCP header with a Source and Destination Port. The Data and the L4 header is now referred to as a segment. Then the Segment will be passed to L3 which will add the information necessary to deliver the segment from end to end, like an IP header with a Source an Destination IP address. The L3 header and the segment can now be referred to as a Packet. This process is known as Encapsulation and De-encapsulation (or sometimes decapsulation). Here is an animation of how it works: 

While not strictly something you asked about, given the comments in this Q&A I thought it wise to mention something about duplicate address detection: There is an often confused point regarding duplicate address detection and Gratuitous ARP. When a computer is trying to see if another host on the network is using a particular IP address it does not send a Gratuitous ARP. The reason for this is by definition, a Gratuitous ARP is meant to update the ARP mappings of other devices on the network. If an IP is not unique, we wouldn't want the "test for uniqueness" to cause an incorrect ARP entry to be updated. In reality, a specific set of ARP Messages are used in duplicate address detection: an ARP Probe and ARP Announcement. The crucial difference between these two packets and an actual Gratuitous ARP, is the ARP Probe does not have a complete IP/MAC mapping, therefore it is impossible for an ARP Probe to accidentally erroneously update an ARP Cache. The general process is the ARP Probe is sent a few times, which would prompt the owner of the IP in question to send a Gratuitous ARP if the IP is already in use. If no response is received, then the sender sends an ARP Announcement to officially claim the IP address on the network. The ARP Announcement is even more similar to a Gratuitous ARP, but it (also) is not technically the same because the ARP Announcement has an opcode of , indicating a request (where as a Gratuitous ARP will have an opcode of ). 

But now in the #debug ppp negotiation I see that for some reason my MRU being sent is STILL 1500, it's so annoying 

So on the I for the inbound PPP message we are seeing that the peer would like to use an MTU of 1492, but we NAK it and tell him we want to use 1500 on the O outound message. This just goes around in an endless loop until it does a ConfREJ I don't get why? So I checked the interfaces specifically to see the MTU settings, and they just ain't changed. See below. How can I fix this? 

I've tried a #shut, no shut, and a reload. Still I can't get this to change. In the interim I did manage to figure out a command to make it work, but I'm not particularly happy that my #ip mtu command didn't work. The command I'm using to fix this currently is below. I just stumbled across it when trying to fix this issue. int di1 ppp mtu adaptive 

I've been doing some reading about MTU and I just can't get my head around something. When we talk about MTU for ethernet, it's documentated that the MTU is 1500, however the frame size is larger after the Ethernet headers are added. So effectively, when people talk about the MTU for ethernet being 1500, they are referring to the payload. Now then, I could accept the above statement if this was a standard case for every other protocol. But with TCP for example, the MTU is considered the payload + the IP header + the TCP header. If you compare this to Ethernet, the MTU was just the payload, but with TCP it's the payload + the headers. Am I understanding this right, because this is really confusing to work out which protocols include the headers with the MTU, and which don't? I have a sneaking suspicion that it's just Ethernet that does not include the headers when talking about MTU, since it would be setting the standard for the maximum packet size for upper layer protocols (i.e. you could only ever have an IP packet with a total packet size that uses a 1500MTU including all the headers and everything). But I want to get some clarity on this topic. I do realise that fragmentation can be used, but I want to know how to work this out without talking about fragmentation. 

And this process continues until the Sequence Number maxes out and resets back to to zero. It is worth noting, that the Sequence Number is not an infinite field and does have an innate maximum. In the case of IPsec, the field is 32 bits, and therefore the Sequence Number maxes out at approximately 4.2 billion. When the maximum is reached, the keys which were securing the packets must be rotated to avoid a looped sequence number vulnerability. The solution to your Problem What is happening in your case specifically is the window is moving forward to fast, and legitimate packets that should be accepted are being dropped because they arrive at the other end just as the Anti-Replay window moved out of range. The solution: Increase the Anti-Replay window. But the tricky part is what do you increase it to? A good rule of thumb is for your Anti-Replay window to be 0.5x to 1x your average Packets Per Second. I suggest starting conservative (0.5x) and increasing slowly until your performance errors falls within an acceptable level. Do not be over-aggressive with increasing the Anti-Replay window, because that leaves you open to inadvertently accepting a replayed packet. Increase it slowly until you are happy with the results. On an ASA, the command is: 

In an attempt to refresh an expired, or expiring, ARP entry, many Client OS's will issue a "targeted" ARP query to the MAC address they already expect. Most of the time, this prompts a response from the intended target and allows the entry to be refreshed without sending a broadcast to the entire network. This will be the first time I've seen it with a Router, but it isn't too big of a stretch to think a Router vendor somewhere will have implemented ARP in the same way. Nearly a Year Later Edit: I found a quote in RFC 1122 that describes this behavior: 

After upgrading our ASAs from 9.1(1) to newer versions, users were no longer able to connect using native IPsec VPN client software when inside of an office network. From outside networks it still worked just fine. The office networks have established VPN tunnels covering the IP range that the user's system falls under, but the workflow is to VPN in to gain access to restricted resources. We verified that disconnecting the LAN to LAN IPsec tunnel to the office allowed the client to connect in successfully. When debugging the connection attempt's IKE and IPsec, a log entry shows why this is failing: 

Flapping events don't require ingress traffic alternating between ports -- a simple change from ingress of a MAC address on port A to port B on a switch quickly enough will cause a flapping event to be logged; for instance, a live migration of a virtual machine from one host to another will often cause a MAC flapping notification. As the other answers have covered, it's nothing to be worried about whatsoever until the events are much more frequent than what you're seeing. Your concerns about spanning tree re-convergence and flushing of MAC tables are unfounded; it's not a topology change for spanning tree and the table is just getting updated for the MAC address that flapped - other entries on the same switch, same vlan, or same port are unaffected. 

Configuration management software might be worth looking into -- Puppet's network device management can add vlans easily to numerous Cisco devices (if you're using Cisco). 

Does having configured on an interface prevent unicast flooding for a MAC address the switch hasn't learned? The information that I'm seeing conflicts -- the wikipedia page on unicast flooding cites protected mode as a mechanism to block flooding, while Cisco's documentation says that doesn't matter, and that would still be needed to prevent flooding. However, I recently ran into an issue where on a 2950G running some relatively ancient 12.1(22) code, unicast flooding seemed to be completely broken for a protected port -- the aging time on the switch was 5 minutes, while the router's ARP timeout was 30 minutes, and the one TCP connection utilizing this interface had a tendency to sit dormant for 10 minutes at a time - and be non-functional when waking up after 10 minutes in this case. Captures run on the host showed no unicast flooding when it was expected, and increasing the MAC aging timer on the switch to match ARP completely resolved the problem. Is this behavior undefined or inconsistent in older IOS versions, or is this just a bug in this old code? 

Correct, the EIGRP and OSPF metric calculations are Apples and Oranges -- not to be compared. The EIGRP calculation is described thoroughly above, or in more detail in this article. If you want a run down on the OSPF metric calculation, I'd suggest asking a new question. 

You can not change the default Cisco configurations. You can use the "interface range" to put all ports in a different VLAN in one go. You don't really need to change the Native VLAN on the uplink trunk, so long as the other switch is using the same Native VLAN. If you really want to spare the switch from adding the VLAN Tag, you could get creative and do the following (although, its probably not recommended). Leave all access ports in the VLAN1. Leave the Native VLAN at its default (VLAN1). On the uplink switch, set the port as a trunk port. And set its Native VLAN to the VLAN you want the lower switch to be a part of. Since the lower switch will send traffic to the upper switch untagged, the upper switch will receive it and associate it with what it considers the Native VLAN. 

Which finally lets us speak to your specific questions. At least the ones that haven't already been answered above: 

Depending on where you are in your University classes, there are three options. If you have already covered "Layer 3 Switching", you could set up an SVI for the Students, and an SVI for the Teachers. Then the first floor and ground floor would only need a Layer2 path (aka through switches) to your Layer 3 switch. Then you could have these two VLANs existing at two different locations. If you haven't already covered "Layer 3 Switching", and you are purely in a "Router L3" and "Switch L2" world, then unless you do something special (see below) you will probably need to use four different VLANs and four different IP Subnets: A Students 1st Floor, B Students Ground Floor, C Teachers 1st Floor, D Teachers Ground Floor. You could get around that and (in a way) do a manual "L3 switch" by connecting your central router to a switch, and then that switch has a trunk to each of your "Floor" switches. You could then have one VLAN/IP Subnet for Teachers, and another for Students, and they could exist in two different locations.