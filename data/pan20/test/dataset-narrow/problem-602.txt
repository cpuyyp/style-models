That's not how the keyword works. creates an object using a constructor function, but your function does not behave like a constructor. This works only because will perform the function call, but you're really just doing . Also, rather than using for attributes, use . This holds for the rest of your code as well. 

This started out as a comment since I'm only going to discuss , but it grew a bit big, so here we go. First of all, I strongly recommend @nukeforum's suggestion that you use the function. Also, as has been mentioned aplenty already, should return a bool: 

Formatting I found this exceedingly difficult to read. The indentation in particular is inconsistent. I highly suspect that this is because your code contains mixed tabs and spaces. (StackExchange silently converts tabs into four spaces. If this is not the case, please ignore this section.) I don't want to start a holy war or anything, but there are three main camps here. 

I'm sorry this is so short, but I only have time to give it a quick once-over right now. The first thing I noticed was the flickering of the cycling icon as I scroll through the bottom. Compared to the rest of the application, which looks great, this was awful. This is happening because you are assigning the to the on , which doesn't make much sense. If you move this initialisation to a handler instead, the flicker will be gone: 

Aside: Semicolons are typically not necessary after braces. You're using a code block for a for loop, not a function expression. Naming 

Code Legibility Many of the values and functions in your program have non-descriptive names. If you plan on only sharing this code with your colleagues who have familiarity with the domain, similar algorithms, and the mathematics behind it all then there may be no need to be descriptive. However, it is also easy to cite whatever source you got this from at the top of the code so that future users can have a frame of reference. 

From the POV of operations performed they're unequivalent. is defined from the result of a pattern match that discards the tail of the list. as you know is the result of the invocation of the method. (I suppose it could be the case that the compiler is smart enough to translate a pattern match on a list that only takes the head of the list into an invocation of the head method, but lets just ignore that for now :^) And a final example: 

When pattern matching and inspecting multiple values of a sequence type (, , , etc) you can reduce the length of your expression by using sequence patterns instead of explicitly breaking the sequence up with the operator. So instead of you can more concisely use . When you want to check for explicit values while pattern matching on an object you can use those values instead of replacing them with variables that are then checked with an statement. For example can be more concisely expressed as When using pattern matching on sequences (especially when the expression goes beyond the standard ) it can enhance legibility to use single letter variable names and comments instead of long variable names. I think that we would both agree that good code should describe itself through both value and function names. However, in this case there is no way of adding intuition with function names and so all of the description ended up in your value names. Like I said before, do what works for you. If legibility was our only metric then maybe pattern matching isn't the ideal way to implement your function. It could still be recursive, but instead of s you could use functions. Do whatever suits you the best but when possible I would recommend short variable names accompanied by comments over long variable names. 

I agree with @ckuhn203 in that the first looks cleaner. I'm not too familiar with C# and its style, but in C I would definitely prefer using a loop: 

Try to match the country code. If none matches, falls back to default. Lookup the appropriate RegExp for that country code and attempt a match. If the match succeeds, attempt to verify the number with the appropriate function. 

† I say "probably" because although it's a CSS3 Candidate Recommendation, it's considered at-risk due to poor browser support. ‡ Strictly, your code will be assigning the handler to , but they'll do the same thing. 

The trick is a cool way to truncate floats to integers, but it's much less readable and relies on a side-effect for the heavy lifting. Although is appreciably faster, using is preferable since the intent is immediately obvious. Feel free to disregard this if you've identified this as being a performance bottleneck. If your application is not performing slowly, however, then this may be a case of premature optimisation. 

It looks like you're looking for the index of the first child of with the class. (Incidentally, your code will also trigger on stuff like , which might be a false positive. Be careful about your classes!) Native selectors work fine here. Furthermore, your initial assignment doesn't do things the jQuery way -- there's no reason to initialise two separate jQuery objects. Try replacing your block with something like: 

I was writing an answer but @jsanc623 beat me to the punch with the , so I'll just add the missing bit. Your solution won't work if your file is served from e.g. . Instead of doing it this way, you can find the current filename more reliably like so: 

Pattern Matching Within the helper function each layer of the recursion checks the value of against some constant value using an if statement. The more idiomatic way to do this in Scala is to use pattern matching. For example: 

Below I've written up an implementation of a recursive bubble sort that addresses the main concerns you mentioned. The areas your code can be improved matches what you instinctively pointed out in your bullet points. Whenever you use a or in Scala remember that it is in fact a linked list and so accessing an element takes linear time. This could add a significant number of operations to an implementation of bubble sort that utilizes a . As a substitute I used an which offers constant time access to elements. It is also worth mentioning that the container is mutable in Scala even if it is declared as a . We can kill two birds with one stone by rewriting the while loop as a recursive procedure. The two birds are and and our trusty stone is . 

Style When you declare a type of a function, value, or variable, add a space between the and the type. 

Below are some of the changes I would make to your code. In my opinion one of the nice aspects of Scala is that it gives you all sorts of ways to reduce the amount of work your mind has to do in order to decipher code. As an example, one of the first things I did was declare a type that is equivalent to . I then just substitued where necessary and the code (to my mind) became more readable. The choice of was arbitrary on my part, you could if you wanted use instead. Along these lines I shortened all of you variable and value names. As the program is set up right now you don't need to pass in a array, but I left it in anyway. As you mentioned this is a homework assignment so I'll leave a bit of mystery as to why this is. And really you don't need the and the . Next note that is equivalent to . And finally (for now) checkout how I initialized and . If you still would like to use your function you should look into the method called . Cheers. 

Functions should be named according to what they do. This means they should often start with a verb, so rather than , it should be . (There are exceptions. For example, when checking a condition, you can use .) Furthermore, they should be named in ; the first letter should be lowercase, while the first letter in each word should be uppercase. Consider aggregating your dog mood functions into a single method. You'll probably soon learn about s; an enum would be a natural way to store and represent the dog's current mood (à la ). If you're looking for a 40% chance of something, then or will do what you want. will get you a random number from to inclusive, so will actually be a 36% chance. Your chain is needlessly complex. Remember that an will only be considered if all preceding s and s failed. Thus, you can instead use an - ladder similar to the following. (Note that the percentages are accurate only if you change your line to use rather than . 

Hint: The problem statement asks you to remove friends from the end of the list as necessary. Think carefully about this. 

Revision. Better yet, we can use . This has the advantage of being entirely unreliant on magic numbers; we can instead just change our object as needed. Furthermore, this deals with @megawac's concern about the undefined enumeration of . 

In addition, in your code, you're running a lot of s here. Rather than calling it each time, you can store the result into a variable and only have to call it once. I didn't do it here because by making the other change, you'll only have to call it once anyway. 

Note that in the first case clause you can replace with any arbitrary constant that you want to match against. In the second case clause simply means match against the wildcard, that is, can have any value or type and the block will get evaluated. As a general Scala tip I'd recommend learning about the many other ways in which pattern matching can be used to create concise code. There are a couple of other places in your code where you could apply pattern matching, but I'll leave those to you as an exercise :) 

You can apply to most containers to test if every element in the container satisfies some property. will only evaluate if is true. This type of evaluation is known as short-circuit evaluation. So basically we can use this property to perform the same behavior as the statement in the original code. Notice also that I've used pattern matching to get rid of the . 

To remedy this bug just call . A possible concise (and correct) solution to your problem using the built-in methods for sets in Python: 

Style Comments Methods which take functions as parameters ( and in this case) should be invoked using infix notation. That is, if there were a god of Idiomatic Scala Style he would prefer to Defined functions should use camel case, e.g. over . In general, and you will get a feel for this the more you use Scala, pattern matching is preferred over if-statements. You will notice that in your function I've swapped your if-else statement for a pattern match on the value . The last style tip I have for you is to break a chain of higher order functions over several lines. This last one can be fudged in some cases, but in general I find that it improves readability. Efficiency Comment The one change that I made in the name of efficiency was to change the container type of from to . The reason I made this change is that accessing an item in a takes linear time on the length of the list, whereas accessing an item in a is almost constant. And as you know, you are accessing elements of by index is in the last line of . 

This is a little bit messy; this is the issue I was referring to earlier. It's good that you added a comment, but even with the comment it seems a little bit bleh. This is mostly an issue because your and methods both call , even though in this instance you'd prefer to just use the logic. If you can, it'd be better to separate the model logic (the stuff dealing with the adding and deleting on ) from the presentation logic (rendering, clearing input boxes, etc.). That way this method becomes a lot cleaner. There's also a bug here: if you edit to an already existing todo item, the add will fail, but the delete will still run, so you lose your existing item. This will even happen when you edit to the same thing. 

This is the classical implementation of the sieve. The resulting array will hold a value of for prime values. Now, observe that the first time you ever see a prime, you remove all of its multiples from contention. We can therefore store a separate list containing just these primes. (We also have to loop over the back half of the array to get any primes .) 

You're looping through every possible permutation of three boolean values. This could be achieved by looping on booleans: 

This post will focus on your implementation of Union-Find. First and foremost, you're not using the member at all, so you should probably remove that. It turns out you actually are using this, just not in your Union-Find class. This is a bad idea. We typically wish to minimise coupling, and using a public member in this manner does precisely the opposite. Next, all your members are . This usually isn't advisable; you should endeavour to make them and provide getters and setters as appropriate. Next, you are in my opinion overloading (not in the programming sense! :P) the member. It's doing double-duty, holding the nonnegative parent node index for child nodes, and the negated size of the set for root nodes. The name therefore cannot be meaningful, since its two purposes are so distinct. If you are pressed for memory then I understand your use of that solution. Keep in mind, however, that since disjoint-set structures are really forests, the classic implementation uses objects containing a reference and optionally an for / . This has the advantage of being more semantically meaningful (and arguably more readable): 

My current assumption is that the string returned by is going to look something like If this is the case then you can try the following function: 

I've introduced a smidgen of strange syntax just to show you a possibility. As a way of explaining what is going on, consider that the following are functionally equivalent: 

Another benefit is that automatically becomes a field for any object (this is also possible with standard class declaration by prepending to the front of the parameter.) These two examples don't really demonstrate the full utility of so if you'd like to learn more check out this link. STYLE Current Scala dogma utilizes camelCase. So I've swapped and for and . I also added a return type to your method . A QUICK NOTE ON TYPES One of the cool things about types is that they allow you to constrain your program. For example, as your method currently stands there are over twenty different collection types (of the mutable and immutable variety) that may be passed in for (see these inheritance graphs). Long story short, I swapped for . STRING OPERATIONS Finally, to get around calling I utilized a method from StringOps called which returns if the caller and the input are equal (regardless of capitalization), false otherwise. To be honest I only changed this bit to show you another possibility. 

Hmm I'm not sure what the requirements for 'python koans' are, but if you are getting counted off for the conditional, here are two alternatives: