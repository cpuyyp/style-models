Disclaimer : your code is not indented properly and I cannot run it. Also, it seems a bit convoluted to me so I haven't really tried to understand it. However, here are a few comments that might help you if you want to improve your code. 

but what makes your task a bit difficult is that you are not handling dictonnaries but lists. Among other things, if you keep that idea that way, you'll have to iterate over pairs (where and are respective size of and ). A probably better idea would be to reorganise data in and to have them as an actual dict mapping to some additional information. Then, merging will go through maximum elements. 

This is very concise and would prevent you from using for instance the code of when the one from is expected. Also, rotors are expected to have 2 properties : 

The organisation of the code is not the best as some methods are probably doing more than they should. You should write a method to check whether two words are anagrams or not. There is not point in storing the number of anagrams in k as it corresponds to the length of the list anyway. You could use join from StringUtils in . If you plan to look for anagrams in the same file multiple time, you could go for a different algorithm in order not to have to reprocess the whole file every time. The trick is to compute for each word its "sorted" version and to keep a mapping from "sorted" word to the corresponding list of real words. Then checking for the anagrams for a word is nothing but sorting it and looking for it in the mapping. I have to go, I'll try to finish this. 

About It seems like the property is never used. Let's get rid of it for the time being. Now, what do we have ? A class with 2 methods one of which is an . I suggest you have a look at this talk called "Stop Writing Classes ". You can easily write this as a simple function : 

In your case, we can remove a level of function call because could take the function as a parameter. Ultimately, I am not convinced that it makes sense to have a at all. You'd get: 

Your code looks very good and the type annotation is a really nice touch Also, your code is well organised and easy to understand. Some documentation could be a good idea (but it's better to have no doc rather than bad doc). Also, you could consider writing unit tests. Let's try to see what could be improved/made more Pythonic. Loop like a native I highly recommand . One of the idea is that whenever you are using , you are probably doing it wrong. In your case, you could use . End of word The end-of-word detection could be done in a single statement: . Also, you can get rid of the definition before the loop and even in the loops, sometimes, you could define it only behind the because you use it only there. Reorganise the logic Sometimes, you check if something is empty and then if it contains a particular element. This can be factorised out: Also, simplifying the code , you could rewrite : 

Also, you could find mathematical expressions to compute the number of leap days in a more efficient way (constant time instead of linear time) but I'll keep this out of the review. 

Also it is a good habit to put the part of your code actually doing things behind an guard. Style Python has a style guide called PEP 8. It is an interesting read and it is probably worth trying to follow it if you don't have a good reason not to. For instance, your code does not follow the naming convention. You'll find various tools to check your code compliancy to PEP 8. Final (untested) code The following code has not been tested, feel free to edit it to fix errors and typos I may have introduced. 

Going further It may not be relevant for this problem (but it may be if you continue on Project Euler problems): a different algorithm can be found using formulas for generating Pythagoran triples. 

Then, some trick to compute the inside of the loop faster. Indeed, many indices cancel each other. At the end, you are down to some value that can be precomputed with another cumulative array : 

This is a bit better but you can go further in the separation of concerns. It is probably a better option to have to return a boolean and have a loop ensuring we call as long as required. This would look like: 

It's simple and clear. About There is still quite a lot going on here. The logic is duplicated looks like maybe it shoud be part of the function (telling how many dice are left to play). Also, it could be a good idea to have a constant containg 5 to make things less confusing. At this point, the code looks like : 

Handle empty input You access the first element of the input without checking the length first. Maybe it'd be clearer to document this as an invalid input or you could handle it properly by returning . Removing duplicated logic When the empty case is handled, the case with 1 element doesn't need to be handled in a special way. With a few minor changes, you can write: 

Your code looks nice, well documented and is split into small functions. Also, you've used the which is a nice touch hardly ever found in beginniner's code. Congratulations! Let's try to see if the code can be improved anyway :) Style There is an official standard Python style guide called PEP 8. This is highly recommended reading. It gives guidelines to help writing code that is both readable and consistent. The Python community tries to follow these guidelines, more or less strictly (a key aspect of PEP 8 is that it provides guidelines and not strict rules to follow blindly). It deals with various aspects of the code style: naming conventions, indentation convention, etc. You'll find various tools to try to check whether your code is PEP 8 compliant and if is it not, to try and fix this: 

Your code seems to work fine and it somehow well tested (even though one needs to compare function outputs visually). A few details can be improved anyway: Indentation and spacing The indentation seems to be a bit off in a few places. Also, a few blank lines seems to be in places where it is not very relevant/helpful. Naming Function names such as are not very easy to understand. It would be easy to find names more meaningful such as . Useless temp variable Using variables for printing does not add much. You could just use . At this stage, the code looks like: 

Don't use the same variable for two different things if you can avoid it as it can make it hard to understand the kind of data the variable is supposed to refer to. For instance, it's easier to get what is like if you rewrite 

Now, I have realised something that I find quite confusing : you keep adding elements to and then you loop over it : it will loop once the first time, twice the second time, n times the n_th times. Is this something we really need/want to do ? Finally, you are doing things in an un-usual way : you have , then . This could easily be written . Then, you do , you might as well get rid of , and the loop and work directly with (and maybe you should exit when the argument is not provided). 

Once all of this has been done, one can notice that the and contain somewhat duplicated information : a node has color if and only if . I have no time to get rid of node_colors but that would be my next suggestion. Also, there might be a problem with the way you add/remove colors because when calling we might re-add a color that has been removed at an earlier stage. I am not able to find an example right now but it might be something to consider. Please let me know if you think I am wrong. 

it seems like you are using the wrong data structure. You want to iterate over domains only and only once and then process the corresponding urls. It would be better to define a dictionnary mapping domains to list of urls once so that you don't have to call many times in many places. You have different ways to do this, the best involves : 

def add_txt_extension_if_needed(filename): if not filename.endswith(TXT_EXTENSION): return filename + TXT_EXTENSION return filename 

It is the time I realize that I shouldn't have inverted all conditions at the very beginning as the whole thing can be rewritten : 

Unfortunately, this is not detected. I guess instead of , you meant: which is equivalent to which is equivalent to the more straight-forward: . In any case, as pointed out by Oscar Smith, this optimisation may not be worth doing. Reusing existing functions Looking for index can be done with the already existing function: . Loop like a native Your final loop is not really Pythonic. Most of the time in Python, you can avoid messing with indices. I hightly recommand Ned Batchelder's talk: "Loop like a native". In your case, we can improve your code in multiple steps. (Some of the steps are pretty artificial in your case but I use them to show you the different functions you have in your Python toolbox). Introducing to get rid of the code to track : 

Avoid string manipulation (again) At the moment, you have a list of string representing operations types and in a few places, you look if the string you are handling corresponds to any of the string you know and perform the relevant computations. This has multiple problems: you have a lot of repeated code and it is easy to forgot a place if you want to add an operation. It would make sense to use a data structure with all the relevant pieces of information. A tuple and more particularly, a seems relevant for this task. 

Types You do not need to convert your original into a list : and will work just as well on a string. Similarly, you do not need to convert the guesses into a list. This makes a lot of code removable : 

Alternatively, you could define a list of (name, function to apply) and iterate through both lists in the same with zip to fill a dictionary. 

Code organisation Instead of building , then use it to build and then use them to fix the problem, you could do things in a more straightforward way with less temporary containers. 

Overall, it seems really really good to me and I like the way you use IndexError to count surrounding cells in a concise way without bothering about edge cases. Here are a few comments anyway : Removing a useless check This is not much but you can remove a check of in 

Style : PEP Compliance Your code looks nice and is well documented. You can use tools to check your code compliance to PEP 8 and PEP 257 : pep8 and pydocstyle (formerly pep257). PEP 8 warnings are about spacing and line length. PEP 257 warnings are about verbal form used (should be imperative and not declarative). Style : a step further A few details in your code are not very pythonic. The main one if the way you write loops. At a rule of thumb, any time you write in Python code, there might be a better way. Ned Batchelder's talk about loops might interest you. In your case, you could use zip or itertools.izip is what you need. Your code becomes : 

In any case, your function deserves some documentation. Tuple unpacking One of my favorite feature of Python is iterable unpacking. You can do something like: 

You can already handle much bigger values. More tricks to handle bigger inputs A trick to perform things quicker is to precompute values to be able to reuse them quickly. Such an algorithm for prime number is called the Sieve of Erathosthenes. You won't be able to compute it for the maximum values () but it could be worth storing a list of primes up to where max is the maximum max value in the input. If you do so, you'll perform the sieve for values up to maximum 31622 which is realistic. Then instead of checking all divisors, you can check only prime values (as primes gets rarer and rarer, I expect this to make the code faster). Another trick might be to try to handle overlapping test cases by not performing the same actions many times.