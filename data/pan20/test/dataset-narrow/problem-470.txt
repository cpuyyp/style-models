Avoid magic numbers where possible, whenever you need specific values like this, make them a well named constant instead. 

One area you could improve performance is by making it a doubly linked list. At the moment your deleteLast() method is an O(n) operation, meaning it needs to traverse the entire list to delete the last element. And since this is the case, there's no real reason for keeping a reference to it at all. If each Node had a next and a prev Node, your delete last could look something like, 

I think a method that prints an element from a collection is a bit unusual. What I would expect is a method called that returns the top element but doesn't remove it. By just printing it you're limiting its use to console only applications, and the only way to retrieve the element is to remove it! You should consider adding an error message to go with your , and maybe reconsider the exception type, an sounds like you're accessing an index, but you're not maybe a custom exception would be more suitable. I think should be (plural) as it will be representing zero or more items. Bonus Stuff you could implement the method. This would allow the caller to do something like 

I think single letter variable names (excluding and loop counters) should be avoided at all costs. You currently have all the fruits values hard coded in, it might be worth while to extract that data into a file to make it easier to add/remove new ones. That's probably not a huge deal though and may have no real benefit. I'm not sure if there's any cleaner way to achieve the s without scattering the calls throughout the code. You could maybe use named constants for the duration, but there may not be much value in that either. You have no docstrings in your code. The statements act as a form of documentation however, and your variable names are (mostly) very good. But there may be some room for some useful comments. Hopefully this review was useful for you! 

so we don't need to do any if-else checks here. Now I haven't added in any checks to make sure the user enters a valid value. This is a problem that was pointed out in the other answers. I would like to also add that I don't think recursion is necessary and only adds complexity that we don't need. A simple loop to keep prompting the user to enter a valid turn would be better I think. I don't like and 0 and 1 are magic numbers here and should be avoided. this would be a lot more readable if we have a meaningful names instead. 

it isn't immediately clear what the significance is of adding 100 to the total. (you're saying why, not what) As a side note, instead of writing total = total + 100, you can simply write total += 100 As for docstrings (comments which describe a method/function) they are generally triple quoted strings 

Hi thanks for sharing your code! Players class Creating a class to represent a Player is a great idea, however your current class represents both players. If you want to have 2 players in your game, it might make more sense to have a Player class rather than a Players class. Also try and expose the bare minimum that is possible by making as much private as possible. Don't reveal implementation details, only expose what is absolutely required. Instantiating your players could look like this. 

Method Names A lot of the method names you've chosen provide information about the class as well. If I want to print a Card object, to me it would make sense to say, and not I already know I'm dealing with a Card. This kind of sounds like it can print any card, not just the instance I'm dealing with. Some more examples from your code vs vs Player IS a Deck In your current code, you have a player class derived from a Deck. This means that every Player IS a Deck. To me it makes more sense to use composition over inheritance. I.e. a Player HAS a Deck. But even then, a player doesn't really have a deck either, they have a hand like you have in your example. Your game can deal with players (with hands) and one or more decks. Players could be able to draw cards FROM decks. It could be 2 different decks, or all from one deck. Consider the following. 

Now here, we're still using the same number of lines (1), but this gives more meaning to the code. Code can now look like this 

here's the output of this program. [a, b, c, g, k] [1, 3, 4, 5, 5, 7] And as I mentioned before, you could write some code that looks something like this. 

now we just put all our there. At the moment we have 3 different methods for adding employees, again we only need 1. 

BubbleSort is an inefficient sorting algorithm when dealing with large inputs. The sheer number of comparisons done with larger inputs will cause some serious problems if you recursively call the function. With the example input you gave, your function gets called 568 times. I tried sorting a list of double the size and got this 

To me this is someone screaming that they want you to use inheritance in some form or another. In your current code, you have a single class, and you maintain the different levels of in 3 different lists, and then you keep track of them by index, 0, 1 and 2. I think here we can make Employee an abstract base class, and create 3 concrete implementations. These will be , and . These could look like 

thanks for sharing your code! I wanted to talk about one pattern that repeats itself quite a bit in your code and how you could improve it. The long if/elif cases where you check for a name, and then based on the name, you call a method on the relevant object. 

Now, the interface itself doesn't know anything about whether or not it's a Cave, or Stream or Town etc. Because it doesn't need to know! What about a ? 

now it's all well and good that we have 3 subclasses, but we're going to need to be able to compare them, we need to add a way for an Employee to give it's priority, so let's just use a getter. (we don't need a setter) 

At the moment this method simply prints that the is searching a chest, why not provide the option to search any object. 

is an example of a particularly bad offender. If I have a class, and it has an member variable. We know that a will have an , you don't need to write a comment saying what the code is already telling us. Let's take a look at your class. If we look in the constructor, we can see that the constructor is causing some side effects. In this case, it's printing to the console. In general, when I construct an object, I assume there will be no side effects or other unexpected behaviour. It's perfectly reasonable to provide a method to do this (in your case ) but I would not include this in the constructor. Consider making your classes immutable where possible Unless you need to provide getter and setter methods for an instance variable, you should just leave them out entirely and make the variable final. I think here is a good candidate, a getter seems reasonable, but I don't think you'd ever really need a setter. In a standard RPG or game, the player or enemy names don't change. They can be marked final. 

Okay so now it looks like if the list is empty, the other player wins. And one more example, this code 

The class here could be in charge of finding out what the game state is from the BlackJack object, and then calling the corresponding view method from the BlackJackView object. Consider the case where you want to check the display. 

I would stick with one (especially in the same project) just for consistency. My personal preference would be to go with the first one. Where possible, I would avoid checking for null. Hopefully this was useful! 

This class has the sole responsibility of starting your game. I would avoid using Strings to represent something more complex than a String. The "A", is not a , it's a . A can and should use internally where needed to achieve the desired functionality. Your BattleShip is kind of a God object it currently stands. It knows about and is in charge of too many things. It keeps track of Ships/Players/Missles/Grids etc. I would say that the object should tie all of these things together, but each of these responsibilities should belong in its own class. @RobAu showed some good examples in his answer. One of the main benefits of using custom Objects instead of just Strings/Lists/Arrays for everything, is that it makes the code highly readable if done well. At the top, we have 

You have a CreateDraftFile class, I don't think I liked the name of this class. In general you want to name a class what the object will do, not what you want to do with the object. Here you want to create a file, so was chosen as the name, but your object will be doing the creating, I would maybe consider or something along those lines. And could be a method (what you want the object to do for you) You seem to be doing a lot of work in your main method that doesn't need to be there, I think the body of your main method could be as short as this. 

this print statement is unreachable code. If this is the actual indentation of your code and not a mistake in formatting when writing your question. A return statement exits the function, code after a return statement will never be executed. If you want to print it, simply change the order of the statements 

It's a good sign that this jumped out as not being the best idea! There are a few problems with your design here, let's have a look. Your class contains these instance variables 

these could maybe just print the elements in the given order, or maybe return a list of the elements (not the nodes) in that order. Overall I think it's looking very nice! Keep it up 

This better documents intent in your code, again making it more readable and easier to follow. in your roll_statement function, in 2 of the conditions you check 

An important distinction between these two methods, is that the .sort method is a list method that sorts the list in place while sorted returns a new list and leaves the original unaltered. Hopefully this review was useful! 

Where possible avoid using classes as a way of storing global / static variables. The benefit of creating classes is to provide a method of abstraction. On top of this Player class your Game class is essentially just some static methods that you call from the main method. What if your code could look like this 

The code in your constructor can stay the same. You can change all of the return types and arguments to List as well, instead of ArrayList, this will allow the calling code to provide any implementation of the List interface instead of just an ArrayList. Now in this example, an ArrayList is perfectly fine and probably the best choice, but in general it's best practice to program to an Interface if able. In your addNbaTeams method, at the moment the team names are all hard coded. This means if you wanted to add any new teams, you'd have to go in and change the source code of your NbaDraft class. I would prefer to see a construction like this 

where is a function that starts the execution of your program. A pattern you use in your code is relying on a string value ("yes" or "no") to determine which function executes. This is standard enough and nothing really wrong with it, but I would recommend instead of checking for this string literals, to use boolean values instead which are taken from shorter helper functions. A quick example. You offer the ability to save and load game state, this is a good thing. However, you save the state in a Human readable fashion - i.e. "Bob's Balance: 24". Unless you're relying on this format somewhere else or even just displaying it, you could just save a single number in a file. No need to record a name. The main code does a lot, you could break this up into helper functions. Some possible function names that jump out are. , , , A pattern you use in your code is relying on a string value ("yes" or "no") to determine which function executes. This is standard enough and nothing really wrong with it, but I would recommend instead of checking for this string literals, to use boolean values instead which are taken from shorter helper functions. A quick example. Your current code for prompting for saving the game 

Now, this class has the single responsibility of representing and maintaining this list of items. and your class can just have an Inventory 

In your current main method, you do lots of List manipulation, all of this can be done elsewhere, you shouldn't need to know how it works. As a side note, there are a lot of redundant comments in your code. Comments should say WHY you're doing something, not WHAT you're doing. I know that when I see object.method() that you're calling a method, but I might not know why you're saying instead of just , for example. I hope this was helpful for you, keep it up! 

see this question $URL$ have a look at the arguments for and against using getters and setters. I won't also recommend reading up on the benefits (and drawbacks) of writing immutable classes. Avoid using Strings to represent more complex Objects You're currently representing your inventory as an array of Strings. I would argue that an is far more than just a String. I would rather see an class. This could be a super class or interface that all items in your game could derive from / implement. Some class that come to mind could be, , , etc. If all of these things are represented as a single String, you're restricting what you can do. Additionally, I would not use an array for this situation. How about an class. 

Now, these variables have names that indicate what they are, rather than just a single letter. Also notice I got rid of completely, you were calling for the effect of prompting for them to press enter, we're not actually using it so we don't need to save it into a variable! Something that's sorely lacking from your program is the use of functions. Functions have many benefits, in this particular case, they are a way of re-using code, but also a way of making the code more readable. A prime candidate here is the constant use of . Why not put this in a function instead. 

You code is also missing docstrings, you could optionally add those to document your code. You could implement the method to provide a nice string representation so you can simply say 

Hi thanks for sharing your code, You should stick to Python naming conventions, check out the PEP8 style guide. $URL$ Based off of this, your rod class should be and should be For your global variables, you could fix this by having a or class. 

Hi there thanks for sharing your code, I have a few comments/suggestions. Implement the __str__ method In your code, you have a method specifically designed to print out what your card looks like. Using the method is a special method designed to return a string representation of our object. In your case it would look something like this.