One solution: Build your rectangle of 4 pieces, and which one registers the collision tells you which side it happened on. If two register, you know it was on a corner. Another solution: Use the relative positions of the two objects and their velocities to figure out where it happened. For example, if the ball is above the rectangle, and the xcoords are almost the same, you know the collision happened on top. The velocity is a sanity check. If the ball's y coord is below the rect's y coord, but the velocity indicates the ball was moving down, you know it moved too far in one frame and should have bounced back up first. 

There is no hard rule about when you should or should not make GameObjects static. At the very least, only do it for objects that will never move in their lifetime. But you have to know what it does to evaluate whether or not you should. It freezes the mesh into the scene data, so you don't have the overhead of the GameObject for the item. This means a performance boost at the cost of altering the scene data at build time and extra memory cost for the final built application. This is fine in many cases, though it can cause problems, for example with forests. Also, it means that instead of storing the verts for the tree once and the GPU drawing copies, it has to duplicate those verts all over the place. That takes time during the build, and space in the app. Our app went from 3-4 GB to 300-400 MB when we made the trees not static. Build time went from 3-4 hours to 1 hour. Having said all that! Your game is 2d, and would probably benefit from setting GameObjects in scenes to static, provided you don't have tons of them. 

is desktop only. You can't use these on mobile platforms. That includes Windows Phone, iOS and Android (at least). There are some plugins on the Asset Store that do this on the various platforms, but not all of them have been updated to work with Unity 5. Tread carefully when trying to solve this problem. 

Currently, the blue box spawns a descendant of Actor which checks collision to see which KActors are touching it: 

In Unity, we have some special things for coroutines that are additional to normal C#. for example, we can use 

One way to do this is not to change the actual values in the database in realtime. When the player logs on, you see how long it's been, and how much stuff he should have if he were earning during the time he was logged off, then update the value accordingly. One benefit of this is that if a player never logs on again, you're not spending server time and resources updating his information. If these values are needed at times when the user is logged off (say when he gets attacked) you just check the time since it was last updated, and add the accumulated value for that time frame. 

Just negotiate with them. If they're willing to take a royalty, they will. If not, you'll have to get other assets. 

It depends on the keyboard in question. There are certain combinations of keys that don't result in all the keys registering as pressed. For example, pressing A and Q at the same time might only register Q. Since this depends on hardware details, there's no one solution for you. One good solution I saw was the KeyJam for Star Control 2's Super Melee mode. It allowed the user to hold down a bunch of keys, and the program would tell you which keys it thought were held. That way, each user could find a set of keys that worked for his setup. 

I recommend a contract regardless of what you're doing. If it's not for profit, a simpler one will work, as "spirit of the agreement" can be important in civil trials. I am not a lawyer, and this does not constitute proper legal advice. It is only my opinion, and you should check local laws. 

I have a Toggle UI element (the stock one from Unity 5.2), and when I resize it to make the text legible, the checkbox doesn't resize or move: 

One way is the Quake 3 way. Based on a bunch of what were originally bugs in the code, you get all sorts of weird interactions. 

I'm trying to get GL.IssuePluginEvent to work, according to this: $URL$ I have a plugin made with this code: 

Use Quaternion.LookRotation to look in the calculated z direction, with the adjusted ground normal as up: 

For my game LowDown: A Social Experiment, I did this: The first time a user submits a number to a contest, there's a CAPTCHA to filter out bots. The server assigns the user a UserID, which is just the next index in the database table. It also assigns an invisible password (I call this a key; it's a randomly generated string). The client saves both the ID and the key. Future logins are sent using the ID and the key, and is sent encrypted via string concatenation and hash. It concats the userID, the key, the contest id, and the user's entries into a string and hashes it. The hash of the string plus the submission are sent, and the server verifies that the submitted data results in the sent hash. This is to (hopefully) verify that the submission is coming from an actual client, not a bot. This means the user can only log in from that device, since the keys are hidden from her. If she wants to log in from another device, she can register the account. This involves giving the server an email address and desired password. From then on, the user can log in from any device provided they log in with the email address and password. This system reduces new-user friction to a minimum, yet allows them to log on through other devices if they really want to. 

One way Unreal Engine 3 handles it: The bullet gets a collision message saying it hit something, with an argument telling it what it hit. It can then call objectHit.takeDamage(self). The target then gets the TakeDamage message, with a pointer to the thing that hit it, and takes the appropriate action. I personally like this approach because it means the bullet can take special actions (like making some sort of explosion effect depending on the type of thing hit) and the target can take special actions depending on the type of bullet. It's also possible that the bullet knows what it does to targets, and can call function on it, like objectHit.freeze(self). Then the target knows it got hit by something that freezes it, and what kind of object that was. EDIT: This answer is meant as a general picture of how it can work, since you're probably not working with UE3. :)