You recalculate and a lot. You should define them once and re-use them whenever you need. uses . So you can define in terms of . You can use something like instead of something like to make your code clearer (in my opinion). If you use , you don't have to do so immediately. So you can define your words, and define your separators, then combine them later. You can short-circuit your last clause by putting it near the beginning and having it the result. This allows you to unindent a large block of code. You never use the initial you create. Get rid of it You re-use variable names for different things. That is confusing. You should use more descriptive names (I have taken a shot at that in my example below). If is expensive, you should probably only do it once and store it as a global variable. You can then pass it as a default argument to speed up access. This also makes the code more flexible since you can specify an alternative word list if you want. You should use boolean operations rather than to check if multiple booleans are the same. In this case, you can reverse your test and use , which will will return if and only if exactly one is . Python doesn't explicitly have . Since you are sure in this case that both are , you can use instead. and are just used as test values later. You can remove these by moving the test into the code block where you originally create them. 

My observations, in terms of implementing this in Python (without regards to improve the algorithm, that will be later): 

It is safer and cleaner to open files with the syntax, since it will safely close the file no matter what happens. It is better to do imports at the top of a module, rather than in a function. It is a convention to use ALL CAPS for module-level constants, which you appear to have several of here. This makes it easier to keep track of what is module-level and what isn't. You re-define certain constants every time through the loop. It is clearer and faster to define them once outside the loop. It is a convention to import numpy as , rather than . This would be much easier using if you can. I will assume for now that you can't, though. Although has a link to the module, it is, as far as I can tell, undocumented. Even if it was documented, it would be clearer to use the module directly. You potentially re-use the same value many times. It would probably be easier and quicker to define it once and re-use it. Along similar lines, you write the same value multiple times. Since it is just a object, it would probably be easier and cleaner to just duplicate the value. They are small enough that this shouldn't be a problem. You use for two different things in the same loop. Don't do that. You should use a more informative name for the first . You only use a small bit of the variable. You should probably strip that off at the beginning. Rather than finding a particular value in and then slicing to that, you can just use to split it at the first , then take the first value returned using . You don't even want the , you want the frame, or rather the frequency. You create variables only to immediately re-name them, then never use the original name. This doesn't have much effect on performance, but it is confusing. I don't know what produces, but I will assume for my improvement it is an iterable. If it isn't, then just put the wrapper you have now back in. Is a numpy array? If it is, then change to . If Syntax.struc.num is already numeric, then you can drop the . If you define your frequencies in a numpy array at the beginning, you can also pre-calculate and much faster in a single step rather than at every point in the loop. Try to avoid "magic numbers", which are seemingly-arbitrary numbers in your code. They should be named variables for clarity. You never use or . Numpy has a method that converts an array directly into binary. You create , but then write instead. If you can just write numbers, you don't need at all, right? I think it would be easier to read in the future if you use the functions rather than setting everything in one big function. Are you sure you want the max value to be ? 16 bit wave files can handle . 

Follow the pep8 style guide. When doing numerical code always have . Don't put multiple commands on one line. So, for example, for your kwargs, each should be on a separate line. Rather than using and getting the values out of the dict, you should define specific keyword arguments and give them default values. In cases where the default value needs to be computed at runtime (such as ) you can set the default as then test if it is at the beginning of the function. This is both simpler for you and much, much easier for people wanting to use your library. I would have and in every function which are passed unchanged to the matplotlib plotting funcion. This is a good way to keep your code simple while still allowing access to the more advanced capabilities of the library you are using. Your plot setup code and plot formatting code are pretty consistent across function. You can split those out into their own functions to reduce code duplication. I would split the fitting code (currently in the section) into their own functions, then access them using a . If I were writing a library, I would split the fitting bits (which don't require matplotlib) into their own python file, and only keep the plotting-specific bits in this file. Also, if I was writing a library, I would have an optional argument for each plotting function that lets you pass an axes object. If that happens, then the figure creation, , and parts aren't called. This allows you to use these functions with subplots or make additional formatting changes before showing it, or just save the figure to a file without showing it at all. If I was writing a library, I would also make the face color a keyword argument with being the default value. I would probably abstract the scatterplot bits of and into a function. With the ability mentioned above to pass an axes object to the plotting functions, your and would be able to create an axes, pass it to the function for plotting the scatterplot, then do their additional stuff with the axes afterwards. This code won't do anything when run as a script so it doesn't need a shebang. I would document the first three functions.