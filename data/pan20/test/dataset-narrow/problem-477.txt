This is pretty much a draft, but I'm sure you get the idea. In StandHit`. The goal of these "transformations" would be to shift the whole responsibility to interact with the from the class to the class. Strings Instead of : 

Now, I don't check if the dictionary contains the property name before trying to get it via the indexer. I don't think it's necessary in your case, since you have full control over what property is used and to which control it is bound, that shouldn't change during runtime. What if we wanted this code to be even nicer. We could extract a method to get the first error in the validation results! 

Considering the indentation and spacing your code has, it is very, should I emphasize very difficult to give an opinion on such a post. You should consider using more white spaces, or using this bracket style : 

String interpolation, it's called. Looks kinda cool eh? You shouldn't return a . Ever. Unless you're in a private method, which isn't your case here. is an implementation detail. You want to return if you want the client to be able to add/remove from your list. Otherwise return to offer a view of your result that cannot be modified. 

As pointed in the comments, is a terrible variable name. Don't do that. :p Overall, your variable names need to be reworked. Why is your named ? Why not ? Then again, what does this dictionary hold? It should be named accordingly. It's a set of dynamic properties, or something like that? Name it ! It might be off, but you get the point, good naming is important. You never check your parameters for . You should. This way you'll catch the problem as soon as possible instead of potentially receiving a at some point in your execution. I'm not sure there's a use to your . All it does is hold a dictionary of properties. Why wouldn't you simply use a variable and extract the and methods to helper static methods? Your bracket style doesn't respect C#'s standard. I guess that's not too bad, but you need to be consistent. Use the same bracket style everywhere (Right now your class's brackets are on a different style). Also, you have useless brackets at some place, don't do that. It's confusing and serves no purpose. EX : 

The advantages of using such a solution is that you don't need to write down every property in a , which could lead to errors (if you forgot one or wrote one incorrectly). Also, you don't need to use since the target of your attribute is the instance itself. I'll review your current code too, because there is three points that I see could be "better" :) By convention, attributes should end with the suffix (which I changed already in my example). You won't need to write when you use it (as shown in my example, which compiles!). Also, your brackets are following the Java standard, not the C# one. You should put opening brackets on a new line. Finally, instead of doing this : 

This would return if your session was invalidated by the method. Otherwise it returns the currently logged in user. 

doesn't need parenthesis. They bulk the code and it serves no purpose. Finally, this doesn't need the , the code flow will never take advantage of the , a simple would do the same work.: 

At the moment, the complexity is of \$O(mnp)\$, \$m\$ being the number of matrices and \$n\$ being the row length of matrices and \$p\$ the column length. I'm wondering if there are edge cases that might crash my method, is it a good decision to make my a and is there a way to make this more performant? Obviously any other comments are welcomed. 

And you use the "magic number" 26, I'm a good example of why you shouldn't use it. I always have a hard time remembering if there's 26 or 27 letters in the alphabet and reading your code I wasn't sure why 26 was there (so I had to count from a to z). You should create a constant in order to make it clear : 

Why? Because the I pass as a parameter isn't a , it's a . You parse a string, if it doesn't work, you return a value. That's your method. The question is : In your application, is there a scenario where you don't know if you'll either receive a or a ? Because that seems like a design flaw in my opinion. 

This method works as well if you want to have parameters to your method, but I didn't this explanation because I don't know if you need it.. 

This way, the method cannot add a single node like it's done in the previous implementation, this keeps this method's responsibility count to one. 

You should have a method to initialize a user (or log it in, whatever floats your boat :p) and one to retrieve the currently logged in user. This way the user of the class has a clear understanding of what's happening "under the hood". As I said, I don't know JPA and it makes my confidence over what I'm saying a little less high, but I know that using reflection in a unit test it bad. Usually it's because it's an implementation detail. That's exactly what it is at the moment. Your variable is useful to you and no one else. Your unit tests should test what is useful to your client. And if the unit test have a hard time doing it, your client will have a hard time using your code. Overall, JPA or not : Reflection in unit test = bad unit test = bad design choice. Think about refactoring your class to change this and I'm sure one day you'll think "Darn, that guy from Code Review was right, I would've been stuck if I had keep the implementation as it was." Otherwise, @chillworld's answer is good, that's something you can do. But I wouldn't encourage it for such a trivial case! :) 

This answer isn't about immutability since @rolfl has it covered. You should put spaces between your in your assignations, it is easier to spot the so it makes it easier to see the assignation. There is lots of white spaces between your getters from , one should be enough otherwise the code takes alot of space for nothing. You have a parameter that is PascalCased instead of camelCased, is it something java specific that makes it impossible to name it ? Otherwise, you should name it.. ! 

First of all, your code doesn't compile, you have a poor lonely extra closing bracket in your method. Next, your method shouldn't if doesn't work. If the entity doesn't exist, you should return false. Otherwise rename your method so that it is clear what you are doing! Also, you shouldn't blindly catch every possible exception. Imagine an is thrown because the connection cannot be established to the database, you will catch this exception, then try to insert into the "broken" database. I don't think you need to catch any exceptions there because you already check if your entity exists. If you need to catch, you might have another problem in your code. The second method is weird, why does it exists? In your view model, your should be marked . Also, if your application ever needs to offer multiple languages, you should consider putting this message in a resource file. This code doesn't compile, an cannot be null, so your if should only check if the is greater than 0.