As far as optimization of two loops to one, it does not matter as these two loops would execute in less than a millisecond, I would guess about about 400 microseconds. 

RegEx is not my strong suit. While it works well this does not make sense to me. I'm not saying it is wrong, it's not broke, I just do not fully understand. some minor stuff that bugs me: You do not need to concatenate simple variables in double quotes 

The "i" is not necessary when you already have the array key. The key applies to both link and title. PHP 

JS I have two functions one for each the two EC methods. function ec() is for EC method 1 functions ecp() is for EC method 2, pairs the current selected section with the previous. Normally obe one of these functions is used on a web page. The div id="s999" is for the initial value for so there is no null value to prev. The reason I have var is for when the same section is selected as previously. I do not care if is expanded or contracted just contracting it is much quicker than an else if to check its display state. But I need to remember what I am doing with the passed . If the same section is clicked and I toggle the display state, if it is being expanded the toggle would contract it again. The line of code: 

The page width should not be 100%. Even in a mobile design. Where the "experts" (e.g. Google PageSpeed Insights) say a mobile design should always have this meta tag: 

I will address your question on the . Which is now moot because it never should have existed at that point. The short answer on removing the unset is the unset destroys the variable $iii if the unset are both in global scope. If this were an include called from a function and $iii was not declared locally to the function, then it will be locally destroyed but not globally destroyed. No matter what, you should not have unset it. Especially as you are using it in the next routine. How a variable is destroyed is a compiler decision. Sometimes the value is set to NULL, most times the allocated memory for that variable is freed to be reallocated for other use. Even if you were not going to use it again you still should not have used . Because it is an integer uses minimum memory space, the CPU cycles use to destroy it would be a waste of resources. A well designed, compiler would ignore your unset. Because PHP is an interpreter and not compiler it does not have the luxury of doing iterative optimization parsing as a compiler. The question that comes to mind; Is your first and the used after using the same physical memory location? Probably not. But when you remove the unset it will undoubtedly remain the same. Your $retval (most PHP programmers use $result) should be "unset" if it is considerable in size. When a variable is large enough to consume RAM that may be needed before the end of script execution, it should be unset, except in the case of mysqli_query Result instead use . When and When Not to use unset When and When Not to use is not always an easy decision. Static variables are where the data type and amount of memory required remains constant throughout its use. This also means the amount of physical memory allocated and it location (physical RAM address) remain constant. Where in physical memory it is stored depends largely on scope. There are languages that require the number of elements and data type of the array's elements, and maximum string size be fixed throughout their use. Many, if not most, languages do not allow type conversion of variables. There are very valid reasons for doing it this way. PHP is very flexible with arrays and variables allowing the executing code to change the the size and data type of variables. There are performance penalties for doing it this way. The other factor is scope. Why scope is important goes beyond knowing where the variable's value is valid. It also has an major impact on performance and memory usage, particularly the read and write. Allocation of memory, static vs. dynamic, and scope go hand in hand. In general terms, global scope the variable is declared and its value can be used and its value changed anywhere in the application. Module variables are defined to be used in a subset of procedures and functions. And local scope that are only valid with in user defined functions / procedures and their subroutines. The way current Intel processors work is they have separate memory pages for instructions and data in the cache memory. Cache is where you want your variables to reside. The only better storage location would be in one of the processor's registers, but that is a decision for the compiler. Compilers may store a copy of the loop variable ($jjj) in a register and then write its value back to it memory location at the end of the loop. (reason loop is faster than in PHP) Use local variables rather than global where possible. If you keep your local variable storage requirements small and well organized you stand a good chance of all your data residing in L1 cache. Same applies to the number of machine instructions required for your executing code. Declare all variables, by data type and size, before the code. Using unset() and declaring new variables within the code will fragment memory. As an example of good memory organization and allocation, I declared as a 32 byte string. and as 16 byte string. If I thought a field name would be longer than 16 characters I would have declared it as 32 byte. On the extreme side but efficient. Going even further, I could have used the results from and initialized to the type and size or the columns using $col instead, . It is a good idea for programmers to understand the basics of microprocessor design. Especially the instruction pipeline, cache, and microcode execution. It's all in Intel's 64 and IA-32 Architectures Optimization Reference Manual: Intel's 64 and IA-32 Architectures Optimization Reference Manual I recommend Chapter 3 and all "User/Source Coding" Rules. 

And their pages score a ZERO with the W3C. jQuery Lot's and lot's of sites use it. does that mean its great stuff? Not necessarily. This site uses jQuery. I just right clicked this page and went to the console tab where javaScript is monitored. This is what I see. 

Takes the expanded section and puts it at the top of the Browser window. When all are contracted, it scrolls to the very top or the page. The reason I use an array for the toggle is to eliminate the else if that would otherwise be required. 

JS I have two functions one for each the two EC methods. function ec() is for EC method 1 functions ecp() is for EC method 2, pairs the current selected section with the previous. Normally obe one of these functions is used on a web page. The div id="s999" is for the initial value for so there is no null value to prev. The reason I have var is for when the same section is selected as previously. I do not care if is expanded or contracted just contracting it is much quicker than an else if to check its display state. But I need to remember what I am doing with the passed . If the same section is clicked and I toggle the display state, if it is being expanded the toggle would contract it again. The line of code: 

I would make the code function correctly within the definition of the rules. Although I would expand on it. I would NOT use the Request Method to determine any functionality. The API should be architected where GET and POST Types can be used interchangeably. I would NEVER use them to select view, save, delete. 

There are a few issues with the original approach. It is far better to use the id rather than class to find the div pairs. jQuery has a fair amount of unnecessary work to do to find the classes for the code . It is what you do NOT see, that matters here. jQuery makes it appear simple. It could be simple if the id is used rather than class. But still jQuery does not know what is actually wanted, it has to use generalized computations which compounds the cpu time. The far better approach would be to use the Math.max to get the greater of the two heights rather than comparisons and inefficient if else structures. This would eliminate a lot of inefficient code. jQuery has to scan all DOM elements, retrieve the class, then compare the class to . Too much like work. Here is a simple JavaScript routine to resize the height of 5 pairs by their id. By class would not be as simple but the second snippet uses a routine to find the pairs then adjusts the height using the method of this first snippet. This code in both snippets should be compatible with all Browsers going back to IE 5. Tested with IE 8.0 (2009), opera 12 (2013), Safari 3.2 (2007), FireFox 36, and Chrome 40 

I still prefer using id over class to pair the divs. If the class were absolutely necessary the code would still be similar by retrieving all divs To get by class Replace this section: 

My preference is over , although they are the same. In a test environment like this, instead of I use with a plain text header: 

This is confusing when the first passed argument is $parameters $controller->view($parameters, $req_body); And the accepted 2nd argument is 

While the arrays may appear to be a lot of overhead, the processing is so much more efficient. When the arrays are local and somewhat small the data is in L1 cache of the microprocessor. The L1 cache of an Intel i7 is 32KB Data and 32KB instruction. If the data is less than 32KB then it will reside in L1 cache. Data access should be grouped together. Data writes should be segregated from data fetch. Data access should be segregated from computational code. Processor branch prediction is an important consideration for efficiency. In my code I use the structure 

This is just an additional comment as the two previous have done well. Encoding small images with base64 There is a misconception that using base 64 encoded images in HTML and CSS is inefficient. Not True. The general conscientious is the because base 64 adds about 15% more bytes to the image. It does before the HTML is gzip encoded. I created two html pages. I used just one div with the One with the Google link to the image (starG.html), and one with the image in the CSS using base 64 encoding (star64.html). I tested both pages on webpagetest.org star64: 0.4KB Less bytes, and 243% faster than startG. starG: Both HTML and PNG: 

These JS files are cached for 10 minutes, requiring the Browser to download them on every time you linger maore than 10 minutes. Also they should be combined into a single file to reduce HTTP Requests. One other JS file: is cached for only 30 minutes. The above are just a few things I found wrong spending about two minutes. There is no excuse for HTML or CSS errors or 0% MobileOK. MobileOK is tough, 20% is OK, 80% is very good. Zero is too typical. These guys are supposed to be experts. Why can;t they get the simple stuff correct? Too many dysfunctional sites. The Web is a mess. Too many dysfunctional sites. jQuery is a factor. The problem being that a Web Designer will want some functionality and search for a solution. Many of these published "solutions" use jQuery. The Designer copies and pastes with no knowledge about what they are doing. The result is a hack job. I assume Bootstrap is supposed to do responsive mobile. Responsive Design is one thing and mobile is another. I guess that why when they say 

Or follow the HTTP 4xx header with an error code in an additional header key value with the error code. 

This is easier on the memory allocation, memory bus I/O, and retyping a variable from string to array. 

When dealing with Serial devices you have to keep in mind diagnostics. When things are not working, where is the problem? Avoid devices that do not drive the DTR and RTS signal. The troubleshooting procedure is to read DTR and RTS then disconnect connect the cable and read them again and see if their was a change in port status. If the serial port is a USB to RS-232 adapter, the device driver may always report DSR and CTS as active regardless if the connected device's actual DSR and CTS signals. Many times the Available and the Port number the device is connect to is unknown. You should include a routine that reads the status of all ports supported by the OS and report the status of each port. If a port exists at that port number read DSR and CTS and include in the report. Most serial device support the Hayes AT Command. If so, issue a command and read the response as part of the device initialization routine. 

Yahoo's YSlow Grade Perfect Score: 100% (gtmetrix.com) Page Speed Grade: 99% (gtmetrix.com) 1% loss due to bug in PageSpeed scoring Page Load time 0.250 seconds (gtmetrix.com) HTML CSS 

preg_match_all() could provide error detection and correction (user typo) as will as doing the explode(). 

Because the day of the month is no an issue I used 13. Not that it would but in dates the month and day can cause problems. By using a day of 13 it cannot be confused with a month. If a date were entered as 13/4/2015, it would not be difficult to understand 13 is a day and 4 is a month. Oct, Nov, Dec would still be ambiguous if entered as 10, 11, or 12. 

The point: Branching, as in if else, is very inefficient. It helps to understand how the micro-processor's microcode and instruction execution blocks function. All programmers should be familiar with Intel's 64 and IA-32 Architectures Optimization Reference Manual at this link: Intel 64 and IA-32 Architectures Optimization Reference Manual This is mostly for compiler programmers but there are many optimizations for other programmers in their "User/Source Coding Rules" The most important Source coding rules pertain to Branching (if else), Loops (while), and variable declaration and organization. You don't have to read all 642 pages. At a minimum read Chapter 3 

Only one query was necessary: It would be better to remove the DESCRIBE Query and use after the SELECT Query: 

I do not know python well enough to show examples. Fill in the blank questions will always require a human to check those marked wrong. As you find incorrectly answers marked wrong, you can tweak the code I developed this technique for submitted answers from a web page and adapted to your interactive input. When answers are submitted from a web page the score for many questions can be scored in a few milliseconds. So fast there is no perceptible delay in the user getting the results. is much quicker than should be avoided when possible which in many instances can be done with arrays create question answer, correction and score arrays this is for two questions one with true (1) or false (0) and one with 4 multiple choice answers. The arrays are made to evaluate to zero on wrong and one on correct. The arrays for output, incorrect on zero and correct on one. Or pad the array so the answers are 1,2.. rather than 0,1... Where is the question number and is number of the answer chosen. From multiple choice you just use an array with more elements [1,0,0,0], the marks array remains the same. questions[ `Is the answer 1. True or 0. False','Is the answer 1. points = [0,1][1,0] or if you don't want zero as a choice: initializations: 

I think the transition is smooth enough. Where I have a problem with this design is when the window width is 501-767px. This covers the common qHD, WVGA, FWVGA resolutions. The problem being when the column width changes from 50% to 33.33%at 768px width. At this point the red page header is taking up a large percentage of the vertical window real estate. I do not have a way to test this on a mobile device that is in this width range in landscape. 640px is a very common landscape width. If this 33.33% width holds in landscape, the the whole window may be red. 500px seems to be an arbitrary width to do the switch. I would think a common screen width like 480px would make more sense.