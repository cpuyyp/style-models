There is probably even more ways to refactor my code, but without better context that is the best I can do. This is where having unit tests is super useful because you can continue to run your test every time you make a change to it to clean it up. 

Yes. You are correct. making just the list class which does only list things would have been the correct approach, anything else breaks SRP. so a bit more of an OO approach would have been to have a factory that takes in a path (be it in string form or other) and returns your person list. Its only responsibility would be reading the file end to end and creating a list with all the people in it. 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in . 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using 

is a term associated with many test frameworks. is another similar term. They usually have many methods that are all synonomous with the following Pseudo code 

if the result is authenticated you redirect your action. But if authentication was not successful then you don't return anything??? that is how your code is phrased. Obviously next line is where you return a blank View, and you comment that if you get that far that something failed and you want to redisplay the form. You do the exact same bit of code for register. If you find exact duplicate code like that it would be better to pull it out into a method and give it a useful name. I chose this 

This has the added benefit that the return value increases in (i.e., it returns the of your function). Alternatively, you can actually avoid constants: 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

Implementations The first (HOF) version can be much more efficiently rewritten in using (provided returns fresh lists): 

Stack overflow is tail-recursive, so if you compile it, it should become a simple loop and there should be no stack issues. However, do not rush with it yet. Algorithm Number of iterations Let us use to see the problems: 

Check $trackCols against a list of valid column names you are expecting, to stop me doing things like I have below. 

Unless you know for sure there is no html or user editable content, you should really html escape it 

Then for showing the gallery we could use a data tag instead of class names to identify the links and galleries, then you could easily extend the code to include more galleries, with no extra js 

The StudentRepository is all about database, and shouldn't know about $request and $response objects, that is the job of the controller. What if you were fetching data to put in an excel file, then you can't use the StudentRepository as it was to fetch that data. 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

If that is the case, then why re-declare then, why not use FILE_DOWNLOAD_PATH and FILE_ENTRY_SEPARATOR directly in your code If you do want to allow them to be overridden, then you could extend your constructor 

I have been using php for over 10 years and never found a need for a session wrapper, but maybe you find it easier/better. There are a few improvements that could be made with your code If we are checking to see if the session has a key, a simpler test is 

There also appears to be no way to overide these private variables which are set to constant values. 

On a final note $lang->xlate may sound like a nice function name, but after a while you will get sick of typing it, $l->x is cryptic but shorter 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

is C/Java style. Lispers use or . is clearer than . Lispers use indentation, not paren counting, to read code. Your code is thus virtually unreadable. Please use Emacs if you are unsure how to format lisp properly. 

is unreadable. is better. is far too high precision. With such an epsilon, you might as well use instead of - the "oscillation between two adjacent floats" problem will be the same. Read up on machine epsilon. This number should actually be an argument to . Adding a line break would make the function more readable. 

You have a lot going on in one middleware. Keep in mind a middleware runs for each request so it needs to be reasonably well optimised. I have split the logging bit out into PlatformLogger class, that seemed like a logical separation. I have also removed a lot of the } else {, to me they just add noise and in most cases you return anyway, so the else will never get triggered. PLEASE NOTE: The conditions below where I removed the else's may not all be the equivalent to the sample provided, it is just to show you what it would look like, you would need to check and make those changes yourself if you choose to do it that way. Also check your if conditions, and do the cheapest test first as they might short circuit the if statement and you won't have to perform the other slower test that involve database access for example. 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

You are not using tail recursion in , so the compiler cannot easily turn it into iteration. It depends on the specific problem; in this case I would probably do it iteratively. Sure, is useful and convenient. 

Note that takes so you can write instead of (you also want instead). Furthermore, is quadratic in length of the input string - it can be made linear instead. is a usually used as a prefix for iteration macros. Also, you call in twice; you can use to remove one call. Your line breaks in are very confusing. You can use instead of in because returns a fresh list. Summary I think your code is overkill.