Depending on implementation, the scheduler could be skipping task when gets near 0 or 999. I've attempted to solve that by adding to a snapshot of time, however this solution suffered a problem: The delay is cumulative, so the schedule's time will slowly deviate(fall behind) from the real time: 

I think to brute force this kind of question is the wrong path to take to begin with. Quoting the wikipedia on Brute Force Search : 

You forgot to plug parameter. And, I would consider renaming it . I wouldn't trust the values from selecting or : 

There is no benefit in declaring your variables on the top of the method, when you don't use it immediately. Even if they are used in the loop, it still wouldn't make a difference to declare them outside of the loop. They will both be compiled into the same IL. However, having to backtrack while trying to read the lines is frustrating. So, just drop a as needed, or the actually type name if the right-hand side doesn't suggest the type. In the following code : 

Without the definition of this class, I can only make some guess about it. We can observe that the value is assigned by a parameter from the constructor. The class itself seems to serve no other purpose than holding the value via and . I would suggest you to replace them by or , depending on whether or not if you want to enforce valid value is required. 

The problem actually stems the design. There isn't much that can be done from the code you posted. I would suggest you to update your question with the rest of repository methods, models or database schema. 

Design is a helper/utility class here, so it is best to make it a class. That way you don't have to instantiate it before using it. It is not like you have various converters that will be used depending on the context like localized converters: English, French, Chinese... 

is a pretty wide range, not only does it holds positive numbers up to 2,147,483,647, but also negative numbers down to -2,147,483,648. If we pass any negative number, the method simply returns . There is 3 ways of fixing it : 

Due to the nature of this algorithm, the digits are in reserve order (right to left). Although it is really simple to re-reverse it (by chaining ), it doesn't matter in which direction we are check the adjacent digits. To compare adjacent items in a sequence, we can pair up a sequence with itself offset-ed by 1: 

This really shouldn't happen unless you plan to do this : . You should use reflection to pull every member or property(pick one), and use to filter amd format them. The only switch you might need to have is opposibly for the premitive types : , , , etc. 

EDIT: After this answer was posted, OP updated on his definition of "best", which leans toward readability. I'll add my comments on his code here : 

Defensively Coding While you validated the user input on the UI layer, , it is also important to validate the argument passed on your business/service layer, . 

Basically, we need to (1)extract the digits, and (2)check if the adjacent digits have a difference of 1. 

There is no benefit in declaring the variable, , for the regular express, without giving a meaningful name to it, other than stating the obvious. It should be renamed to . is a quite misleading name. One would think it the value stored in the binary format, which is pretty much how every number is stored... However, it stores the binary string of . Therefore, it should be renamed to , or . The class already have a property that could be used instead of the long way . This property is cached, so we are not re-measuring the length of the string, as you can see here. 

At first glance, it looked like some kind of awkward fluent syntax. Then, I realised you need immutability. You should simply expose the properties as get-only from an interface which implements, and upgrade into a . 

LINQ As for LINQ, I would recommend to limit yourself to one operation per line(everything until your first linq method can be in one line, but again you may want to switch line when it gets too long). Taking for example your implemetation : 

Bracket alignment. For some reason, all obstacle classes and -loops are written with vertically aligned bracket, while the s are egyptians. 

Segmentate the expression into a list of tokens Parse the tokens into recognizable lexemes(numbers, operator, parenthesis, etc) Transform the list into a tree structure based on the order of operations Calculate the result of top root, which requires the results from its branch(es) 

The follow piece of code is particularly frustrating to read. The argument list and method block are not so obvious at first glance, and the argument is actually align on the same level as the method body. While this is okay, the lack of visual clue(blank line) that separates them is frustrating. 

You can look specifically for them, instead of comparing the argument list of each method, which is really costly. 

We can also solve the problem from a mathematical approach, with logical operators and bit-shiftings : 

Try to keep you method simple. It should the core logic of your application. The whole "get option and try again if failed" doesn't really belong in the method, and should be extracted into a separated method, not just the print options part. 

You don't have to, as you can obtain information on any member of a class, be or . Serializable by exposing a serialize method This design is more straight-forward where each element serializes its own stuffs and delegates the rest to the respective element. 

EDIT: Just reread your question, if your concern is only about the . You can simply use null-coalescing operator : 

should not care about the of current . As its name indicates, it should only get the s of the . The higher up should be the only to taking care of . is a really clunky type, use a . The conversion can be made with a . 

Counting Continuous Occurrence Now, this part you don't need nested loop to get the job done. Although, it is natural to think this way: taking an element and all the same that follows. You can just compare previous and the current element and check if they are the same. 

As @TamoghnaChowdhury has already pointed out, you have too much code in, what I assume, your main method. You should divide it into multiple methods, so that the indention of your code can be reflect by glancing at it, and not studying line by line. If we examine the code, we can see that it performs 2 different tasks that can be split, counting continuous occurrence and RLE formatting. With this in mind, we can rewrite the main method like this: 

Or, if you are proficient enough, just inline it. Normally, you should use PascalCase for menbers, and not camelCase. However, Unity3D seems favor the latter. Therefore, it is up to you to decide. ( ) When your method name is already , you don't also have to name the local variable , just should suffice. Class name should never be plurial, and never a verb or verb+complement. 

The proper way of updating value from UI, would be using . And, not patching it via . Here is how I would do it : 

Now I feel like I shoot myself in the foot, as I just criticized Michael Colon for "not providing any meaningful improvement like an example or a full/partial refactored code, other than stating the obvious", and I just did it. So here is some nitpicks : 

May I add that you could try to alleviate the situation a bit. However, you will have to add the on top of every source file : 

The major bottleneck is most likely in the method as we are dealing with a file. In your method, a PdfReader is created to read through every page of the document to find the and the page numbers on which the is found is stored inside a named . Once the reader ran through every page, the method returns null or the filename based on whether numbers of is 0. What you could do is to return as soon as you have found the text, so that you don't have to look through the entire document for nothing. 

First, the linq methods are not aligned, while the lambda parts are. This makes the reading difficult, as the reader would have find the and then backtract to previous line to find out whether this is a filter, projection or something else. Secondly, since you mentioned that you use LINQPad(wonderful tool), writing each linq method on a new line will also have the benefit of easily inserting a to test the result of each filter, projection, etc... I would write it like this : 

You don't need to pull every single method and compare Most of parsable type will have these signatures : 

Normally, I would use generic here, but Unity3D seems to have some problems with generic , so I left it out. However, do give them a try : 

Access Modifier Normally you want to avoid using unless you want the field, property or method to be available without instancing. Generally, a field or property is used for application-wide settings. While static method is usually a stateless helper method, such as : , . So I would remove the on these lines, as these are tied the instance of the calculator. It wouldn't make sense to have 2 instances of the calculator that share the same memory, so that any input on one will be synchronized on the other. 

Serializer with reflection (customizable through attributes/converter/mapper). This design is more complicated, in a sense that you have to plan ahead every the possible details of serialization. It is also harder to wire everything up, while leaving room for customization. 

Return a collection type like instead of an . If the entire list is not required, a will be preferred, as only the required portion of the list will be created. Also consider moving the properties selection part into your presentation layer, and have it to wire up the properties they need. So that, you don't need to change both place when you decide to add/remove a property. 

Credit to @AffluentOwl's answer However, LCM is not the final answer, but it is the number of chocolate that we care, we have to divide by . And, we can simplify all this : 

You can put the s into a dictionary to reduce the boilerplate and . The and the string concatenation part can also be reduced with or : 

So, do use the full name, like , and so on... It does irk a bit, but I will refactor this with other s later. In this bit of code 

An better solution would be to provide a range of time, and check if expression fall between the range: 

As @WinstonEwert has pointed out, the number of chocolates that you can eat, is related to the least common multiplier. And, here is one fast way of computing it making use of the Euclidean Algorithm : 

Do not abbreviate the variable name... Go for the full name, with exception of some short lambda functions', event handlers' parameters and -loops' variables. At first, I thought they were some kind of hungarian notation, and had trouble figuring out what kind of handles are they? It was until I saw the next obstacle class that I realize it was for !