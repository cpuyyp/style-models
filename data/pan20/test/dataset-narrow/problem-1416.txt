Fail Early, Fail Often Well, it is pretty hard to 'fail early' when your project is out of the door. Hopefully the feedback you gain from the above will shed light on processes that may have been pretty dark to you. There are problems that you will run against that will sting pretty bad. It'll be pretty difficult to just forget those. To make sure that you don't forget the problem areas it could be handy to write a 'Core Value' type list that you keep at arms reach. Keep them available for others to see and for you to see. When the your next project starts I might be inclined to bring some of these to the table to get other people's perspectives. If you have new eyes on the project you might get feedback that could shed new light on solving a particular issue. As long as you're aware, and you keep your problems in the light, you're bound to solve those issues. Write It Grab all of the writings and bring it all together. 

Unity3D doesn't have any direct support for voice recognition. You would need to write an extension (System.Speech.Recognition) or find some kind of plug-in to get you rolling. If you do end up going this direction you will lose out on the unity web player compatibility with your project. I do not see any plug-ins that are already developed for this purpose. 

The Map Editor is where 'Galaxy' is coming from (Galaxy Editor). It's a data driven editor which allows you to put together actions from English statements which really opens up an insane amount of possibilities. For example, attaching Thor cannons to a hydralisk is easy cheesy. 

Introduction to 3D Game Programming With DirectX 9.0 (awesome) NVIDIA FX Composer (good for examples) There was a Shader X2 intro paper on ATI's website, but it's been removed... Ah! Found it here! 

Big companies tend to create group atmospheres. Artists will hang out with artists. Programmers will hang out with programmers. Testers will probably hang out with support. You will have to make an effort to network (lunch, activities). There is no reason why you wouldn't be able to create good relationships with developers. 

First off, you should really store the tiles in a 2d array. As far as I can tell from documentation, has a method. This method gives the coordinates of the top-left point of your view. Next you will need the coordinate of the mouse, in relation to the top-left of your window. Finally, you add the two coordinates together, and you'll have the world-space coordinates of the mouse. From here, it's a matter of basic integer divisions to get the tile you are currently hovering. 

I would never recommend having one large image. One large image will make changing and creating levels very tedious. In my tile engine, I draw all the tiles to a separate screensized render target, and reuse that render target as the player moves around in the world, only drawing tiles as they enter the screen. This all happens in the background. I then use the render target as the background, and then draw the entities on top. This is what I believe one of the most efficient ways of drawing a tilebased world. 

I think the issue is possibly a bug in the older versions of Windows Phone 8. The blend state seems to be borked so you need to create a custom one that you know works. 

I got this working, but you need to use some MSBuild magic to do it. I strongly recommend you backup your project, as you might easily break something if you do this wrong. First things first, you need to open up the configuration manager(). Then you need to create four build configurations for your game project. I chose to name mine , , and . After doing this, you save your project, right-click the project in the solution explorer and then hit . Now, you right-click the project again, and hit . This is the raw MSBuild configuration of your project. In the first node, you need to find the child node ann then delete the line. Next you need to find the nodes that look like this: 

I would really like to hear how other independents generally approach marketing their game with limited resources. I know how critical marketing is since I've seen it first hand on several fronts. I've been part of teams that didn't put an ounce of marketing into their project and didn't come close to meeting expectations. I've also poured a lot of time into visiting forums to discuss our previous title which resulted in minor bumps over time. I really think Wolfire is doing some amazing grass roots marketing with the way they are managing their community around their Blog. They've massed a following that is willing to pay (far in advance) them for their game before they finish it to help support them. That's awesome. But how many people are really willing to divulge such information that early? Should that be a concern? Should I start talking about my next project before I really have anything implemented? What has worked for you? I would be particularly interested to hear how people approach Apple's iTunes store. I believe we're looking at around 33,000 games on the store these days. 

You're in luck! I just discovered some Linear Algebra tutorials on Wolfire's blog that I felt were really good. The guy writing the tutorials, David, has such a killer way to explain the stuff. It's extremely handy for those that are weak at math since it is showing more practical application than theory (which is what someone weak could use) 

There's nothing quite like the routine of tweaking a variable, compiling code that takes a few minutes, executing the code, realizing that your tweak was in the wrong direction and repeating the process all over again. I would like to start interacting with my game logic while a session is in progress. What are some of the ways you've handled doing this? I would be open to hear solutions for iOS, C/C++ and C#/XNA. 

It's been said above, testing is very, very tedious. Manual testing is a monkeys job. Companies understand that coming in through support is a well known path for people looking to get into the game industry. There are companies that don't like it. I recently watched an interview with Gabe Newell where he mentioned companies firing an employee who attempts and move out of QA. Companies need testers who are genuinely interested in what they're doing. So if this is your path make the best of it. 

You need the center of the knob and the point of the cursor along with the atan2 function. You then use it like this: 

Problem 1: I solved this by using a render target that was larger than the area. It should be able to encompass the halfwidth/halfheight of your biggest sprite. In my example, I just decided to use a size three times as high and wide as the game render area. I cut the render target into nine pieces, and render them all on top of each other. Here's the code: 

The type is only there as a placeholder, and it doesn't have any actual use right now. The type from JASS is a pointer to a function in a maps compiled JASS script. I have tried creating new JASS script code at run-time, but I haven't had any good success so far. Since you're using 1.2.4 there is really no way to achieve what you want. If you were to switch to 2.2.5.124b you'd be able to use the system for attaching C# delegates to a with the following code. 

If you have any questions, fire away in the comments section below this answer. And remember to mark whatever answer your satisfied with correct, so future visitors know which answer to look at. 

Problem 2: This I have no idea how to solve. Problem 3: This method automatically does that. You can replace the Vector2.Zero in the nine SpriteBatch.Draw inside the second SpriteBatch.Begin/End block to draw it wherever you'd like. 

However, normally, you'd keep it somewhere and only load it once, as it is faster to look at a global object than calling the ContentManager.Load method. 

This gives you a very dynamic approach, and lets you modify things at run-time. Maybe you want to make a spell deal double damage when a buff is applied. Maybe you want to have it bounce. All these things could be hardcoded into a single class, but it would get messy fast. This approach lets you give each "effect" their own separate implementation. 

You're gaining valuable insight as you work through the process. For any good business man that works on a project it's fairly easy to tear your project to pieces when analyzing what you did wrong. Figuring out want went right is a little harder. How I would approach a thorough postmortem Get All Perspectives in Writing Ask each team member to write a few pages on project observations. Instead of randomly laying a trail for them to fulfill I would ask exact questions that you want to know about. You can supplement this with a meeting, but I rather get someones sole attention without distraction. The most obvious questions would be 

I have no experience in this domain, but I've seen something that may be useful. If you know, or anyone else knows about this feel free to elaborate on it. A buddy of mine pointed me to this when I was talking about creating a multiplayer web-based game. $URL$ 

Have you thought about using a good API to help you with your flash development? Take a look at Flixel and Box2D. 

This is a team effort. If people are playing the blame game you might want to look for some other company to work with. With code bases being hundreds of thousands lines of code no tester is going to find all of the bugs. That's just not realistic. 

Introduction to the project, goals, and anything you feel like sharing about the project process Top 5 - What went right? Top 5 - What went wrong? Conclusion... Bringing it to the end. 

I have taken advantage of what apple has provided with UIKit. My last few projects have abused Core Animation/UIKit instead of OpenGL ES. For my case it worked perfectly well. My next project will use OpenGL ES and I'm not quite sure how I will manage the UI yet. I will likely still abuse UIKit. I've seen a few developers use OpenGL ES to push their graphics and actually integrate UIKit into the scene to handle the User Interface. If you're interested in hearing a developer talk about the integration check out this article he wrote. Great guy. 

What you need to do is separate terrain from live blocks. For example you could store the live blocks in a dictionary that uses a point as key. And then unload the terrain. This way your live blocks stay in memory in a way you see fit, and you can still look them up based on position, but the terrain is stored on disk for later retrieval. This will increase memory a bit, but you can't avoid it entirely. 

From what you said in the comment section, it appears it was an issue with the server ticking too fast and the imprecision of floats that caused the issue. It was solved by first checking and comparing the ticks of the client and server, and then subsequently slowing down the amount of server updates. 

You can see how your total force increases each update, by update 120, only two seconds into the simulation, you have a downward force of . To fix this, you only add the Force once, like when the object enters the world and is subjected to gravity, and remove it once it leaves the world. 

Here's my way of adding transparent holes in your background. It uses a simple pixel shader that subtracts the values. I'm not sure this is the best way, there may be some tricks possible simply by using a custom BlendState and the Subtract function. What I did was create two rendertargets. One holding your dirt. This could just be a large texture, however, to get it tiling dynamically, rendertargets was a good choice. First I prepare them in the LoadContent override. 

If you know the points of all the corners, it's simply a matter of taking the average of each point component. 

This is a good OOP approach and allows you to have multiple Scenes with different dimensions should that ever be needed. It also allows you to do generic sanitizing in the Scene itself rather than having to implement it on each GameObject. 

Here's a custom BlendState that should do the same as Game Maker's does, based on the post found here. Here's a complete example with combining two RenderTarget2Ds, so you also see how they work in practice. 

Don't ignore details... Short fingers? Scars? Tattoos? Missing eyeball? One leg? Tearful body odor? You can now use those descriptors to assist in bringing your character a personality. If you're designing a combat game, you can take the fact that you know your character has scars to describe a hard-fought battle the character was in back during Vietnam. Now that we know that, maybe your character has PTSD which will influence certain game mechanics. If you're developing a puzzle game, maybe your character got those scars from a science experiment gone wrong. The goal is getting all of the possible creative juice out of you that describes every single detail that you possible can about this character. Give your other designers all of the information that they could possibly need to fit your character into the game world. If an Artist is modeling your character they can simply look at your descriptors and recognize the look. They can read a short bio and realize that this guy is a thug or an innocent/clumsy scientist. If a musician needs to compose a piece that focuses on your character, they can discern the mood they need from reading a short bio. 

I have seen a couple of things in the past where I have seen a crowd majority buck their heads. One really sticks out in my mind: Little Challenge In a prior project, I leaned against the word 'casual' a little too much. I imagined people picking up this game and simply solving a simple feat and moving on. I didn't integrate any kind of losing mechanism per say, but left that for the player to determine. A 'did the player meet his/her expectation' type of situation. Judging from the feedback I received I see not giving a clear losing mechanism a mistake and a missed opportunity. It seemed that those players who wanted a way to lose actually enjoy knowing they've lost. I guess that may sound obvious, but I wasn't quite thinking about it that way. Reward a Player By nature humans are always trying to achieve that next best thing. I think there are some instincts at play there. At a young age our mind was a buzz when we got a new toy, for example. So in a game I imagine that a player who is given something along the way will improve the fun-factor. I assume this is exactly what Achievements are targeting - a direct reward.