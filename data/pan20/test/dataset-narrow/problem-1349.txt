So my path variables use something like: How could I move my exes so they would find all dlls and data, so I wouldn't need to replicate the data folder for each version and have them nicely separated? I am mainly looking for answers for Windows, but I am also interested in Unix solutions. 

I am now creating a 64 bit and 32 bit executable of my game. How could I achieve so that the executable and dlls lie in a separate folder without changing all the path variables in the game? To clarify I want to have a folder structure like this: 

The problem is a typical starters error: you chose both loops iteration variable to be the same, so they modify each other. You should always choose nested loops to use a different iteration variable(usually called i, j, k), otherwise things will get messed up. In other languages completely, but here you got the two objects already and using the keys only to remove, so only the removal part got messed up. The correct code should be: 

I would recommend either leaving this system as-is and worry about performance later or use Assimp, which not only does this all for you, it supports more formats with consistency, and will save you some headaches later with its tangent generation and other useful preprocessing. Some pseudocode for aligning as asked for: 

Using a 2D tile array for your world/level generation and representation will definitely simplify things. For example you could internally represent your world in a grid of tiles and take it from there : 

in each Update() call. targetPos can just be a gameObject in your scene indicating a position to the left, just outside of the visible screen space (at which point you can kill/recycle your pillar). If you need objects which have their own speed then alter or add to the 'speed' variable for each required gameObject. For example a projectile being shot by a trap towards the player from right to left might be moving at playerSpeed + bulletSpeed etc. On the topic of recycling objects : instead of instantiating a new gameObject for each obstacle such as pillars, especially in a tight loop or Update() function, instead investigate object pooling in Unity where you can just keep recycling from a pre-allocated list of gameObjects. --- EDIT forgot you're using rigidBody ---- After you instantiate each pillar with an initial velocity (moving towards the player from right to left) then it sounds like you could then use an InvokeRepeating or something similar to fire off an increase in speed of each subsequent pillar by just adding force to the current velocity : 

I base all this on personal experience from implementing an animated mesh with assimp and glm myself.(which now works) But it might not be the correct way of doing things. 

Basically its what @DanielHolst said, you can use negative coords and expand in all directions. As for storing your loaded chunks for fast access and checking you could use , Just , then your code looks something like this: 

I can see that your fragment shader is the culprit. The problem is in the way you are storing the output of the fragment shader in the Gbuffer. This is how I do it, and how it works for me flawlessly: 

Where the last parameter is how much to wait for an incoming event( can be a pakcet, but can be connection or disconnection request too ) You can use the documentation as a reference. Edit: As per request in comment here is how should your main programloop look like: 

Lets get to the part: Do they use this? Probably not, at least not like this or for this. Do they use something similar? Definitely! The answer is in spatial data-structures which let you get a list of only the nearby walls from the player location. This is done in 2D using Quad-trees or BSP usually. In 3D with octrees and BSPs. What is the best way to handle it? The best way is to get it to work, and when it starts to eat your CPU cycles(You know, because you Profiled it), come back and optimize it. 

A quick test, just grab the logo image from the SFML site and paste it into the working directory of your project (or just somewhere simple and explicitly state that in code i.e. "C:\test\img.png") 

Additionally, I've noticed that you're loading a new texture for each block. This kind of defeats the object of using a texture. With a texture you want to load it once into video memory and then point all of your sprites to that once instance to reduce draw calls and memory requirements etc (aka batching your draws). In 2D games using the concept of one large texture atlas is very common because it's so efficient. You could have a variety of block textures all tightly packed into one 'blockTypes' texture and then just use 'sprite.setTextureRect' to refer to different sections of that texture as mentioned above. I'd just throw a few texture atlases into a map so that you have a single texture dictionary to refer to in all of your block objects. 

You've already got most of the setup. What you could do is just control the Campfire from the other collider inside the Collision method [untested code] : 

When importing the animation there is a 'mirror animation' checkbox under the Animations Tab in the Inspector for that asset. If you check that box and rename the animation to "myanimation_mirror" or whatever then you should have 2 mirrored animations. 

I believe your error arises from rounding errors. I believe the problem could be solved by using for pixel-coordinate storage. This way you will always get the exact increment needed for the given delta time, which is usually very small and thus the resulting per update increment is less than 1, and truncated to 0. Don't forget to use proper rounding when converting back for rendering or comparison. For rendering I would use: Which will yield 'proper' rounding: up from 0.5 and down with anything less. 

Picking in OpenGL can be done, by rendering the primitives you want to check for, assigning each one a unique color, based upon which you can look it up. Then you can check what color is rendered for example on the center of the screen, this way getting the object pointed at. This was done in older games, but is frowned upon, because it can be a huge performance hog. 

The way I(And I believe many others) do it is to have not only one noise generator, but multiple ones, configured differently, and then interpolate between them based on some value(perhaps chunk type, perhaps just another noise function). Also generating a specific terrain type is more feasible by combining multiple noises too. The website of libnoise has some nice information about all this, and also about the various noise generation and mixing techniques. Some basic generators are: 

I know some people frown on link dumping, however I found this to be a very enlightening paper, and it obviously conveys way more than I could elaborate on : $URL$ 

$URL$ If you're using Aron Granberg's pathfinder, then are you perhaps using one of the smoothing modifiers? This would result in the unit trying to optimize the path which would probably prevent the unit from hitting each node as it steps through the path. Or is the problem that you have a consistent offset when the unit paths from node to node? 

From my experience recently in doing a few 3D animations, I found it very simple to just split up the animation into 3 separate clips. That way I felt that it was quite intuitive and easy when creating transitions between each animation clip in each stage of the overall animation. You also have a great deal more control over the animation transitions using this method. If you split the animation up then just ensure that when you import the animations that you check the Loop animation check box in the Animations tab for the middle climbing animation clip and you should be good to go. You can then also use State Machine Behaviours to drive any additional actions like playing sounds or effects etc during each clip. I'm sure you could also perform some complex looping logic as you allude to, however that seems unnecessarily complicated and error prone in my opinion. 

The site you referenced also has these and other techniques in its tutorial section, so you should probably reduce your world size so you get a testable FPS and start implementing these optimizations. Also you should measure performance not in FPS but in frame time: The time needed to rendered a single frame. FPS is not good, because it is not linear. 

I think you are over-using the component model. While what you are saying could be accomplished and would work, the general way of doing this is making the camera a global thing. Sometimes it is just much easier to make an exception than to try force everything into a rigid view of "everything must be a component". So I recommend making the camera not a component but rather a property of the RenderSystem. There you could even have a list of cameras, and the RenderSystem would have much more control to optimize the way things get rendered. 

Probably your problem is due to normals not being per-face but smoothed. You can apply Smooth with AutoSmooth after import with 30 degrees threshold to your model or maybe use a better exchange format. You can use 30 degrees in most cases for half-smoothed objects. If you need blockiness just decrease it. (Or if you need smoothness increase it) 

When I implemented something similar I used a messaging system exclusively to handle the necessary communication between different entities in various systems. That way the messenger can perform the relevant required component checks while marshalling the your messages between the entities. You can think of the Events as mini SubSystems if you like. It also cleans up your systems quite a bit as well as providing a great deal of de-coupled logic, and hence less dependency chains overall etc. (contrived and untested psuedo-code disclaimer) example : 

A great explanation of a well known voxel chunk system can be found in the minecraft wiki Regardless of how you want to store the data programmatically, the ability to generate smooth flowing infinite voxel terrain comes down to a smartly optimized neighbouring chunk loading system. "The exact number of generated chunks varies in single player mode, depending on view distance and movement. In multiplayer mode, a grid with a default inradius of 10 (for a total of 21x21 or 441) chunks is loaded around each player and sent to the player by default, although this can be configured to be between 3 and 15, usually only lowered with a poor connection home server. These chunks may have activity (mobs spawning, trees growing, water flowing, dropped items disappearing etc.), while the other world chunks are inactive, stored on your hard drive. Chunks will not save again if they were saved in the last 30 seconds." So effectively in a player driven game like minecraft you're only ever creating/loading a small number of chunks around your player at any time. It's quite tough to troubleshoot your slow chunk loading issue without more information or code examples etc. 

EDIT: To answer your comments, there is no reason to precalculate the matrices. But I see no problem in doing so. But if you also want to interpolate... It doesn't look straightforward. Maybe you could store a matrix for every frame but that would be quite a lot of data. Well To expand on this here is some calculation: Assuming 4x4 matrices of float(4byte) data. Lets assume you have 16 bones in your model. And you want 200 animation frames. And you want interpolation so you do 2000 animation frames instead(10 subframes)(Assuming a bad case scenario). This would require 2000kB of memory/disk space. Thats not a lot.(Except if you are doing skinning on GPU, then if you consider 100 different models, this is 200MB animation data, which is quite significant.) But you could just easily calculate it on the fly with even more accuracy, and don't need to have larger files. And mainly: write, test and maintain the extra code to do it the other way around. So the more I think about it the less feasible reasonable it seems. 

Edit: From the video it seems you are overshooting the position you are aiming for. There are three ways to solve this: 

where is the device resolution and is the size of play area in meters( in this case the latter is ) Note: This is just a very simple implementation, and needs some refinement, but I hope that you get the idea. Note 2: I assume you are using floating point numbers to represent coordinates.(should be the case already with lua.) Edit: In the example above (the position of the object) ranges, which means . So for example an object in the middle of the screen would have the coordinates 

Once thats set up you can then interrogate a tile in your move path to see if its walkable based on the terrain type, or if it's blocked by an child obstacle etc. 

I found it a little bit difficult to follow the entire thread of your question. However at the most basic level, in a simple FSM you could either just query the current state of your StateMachine (i.e. assuming its a singleton manager class etc : StateMachine.Instance.GetState ) and then do the necessary long-winded if or switch statement logic depending on which state is returned. Alternatively, for something a bit more loosely coupled and dynamic you could just have each relevant Class subscribe to a OnStateChanged event equivalent and react to specific states with callbacks. There isn't a right way to implement a FSM, however you can take a steer from one of the many online resources eg: $URL$ $URL$ ------ EDIT UPDATE ------ The idea is that if you're going to roll your own GameStateManager in the Unity engine, then each state would essentially have it's own methods such as Update etc. These methods would execute sequentially as per the norm. You could manage your state transitions with a State stack container. This way multiple states could be queued up and pushed into the stack, and then executed in order i.e. GameState-->MenuState-->ControlsMenuSubState etc. At the end of each frame you could then do some bookkeeping and check if it's OK to roll onto the next state i.e. pop the current state and then execute the next state object on the GameState stack. It does sound like you're overcomplicating things by coupling each class to each State of the game. The classes generally shouldn't know or care which state they're in as it's the State's job to call into other classes, not the other way around. Unity's normal Scene methodology is also suitable. You could just use Scenes to transition between major games states, and then use the Unity GUI for Overlay states such as Inventory or Menu states which need to run in the current state. All you would need is at least 1 object to maintain your meta game state between scene transitions. 

The most solid option seems to be checking for overshoot and correcting. Note: The simple code I provided doesn't account for the movement speed lost when arriving at each tile. 

This seems like an optimization question. As such the answer, as always is to profile it. If generating the matrices doesn't take too much time on the fly, then it is simply easier to do on the fly, as you don't have to write and export/import of matrices, and add it to your file format. And perhaps you could simply use other file formats natively and not have to bake your resources. On the other hand if your application is very very animation intensive, it may be worth it to move the matrix calculation to the baking stage.(Tough I would seriously doubt that.) In the end this looks like a premature optimization to me. If you are interested, then you should profile it first, and if the results say you spend too much time calculating matrices, then do it. PS: If you do profile it, don't forget to post the results. 

Lets start with general rule of optimizing things, especially when it comes to games: Profile it. It's not worth working on something that works already, because especially with games, you will get stuck optimizing and refactoring what you have, instead of doing actual work. When a player is playing a game, they usually are doing just that, because a game requires most attention, especially as this will only get called when the player is moving, so the CPU cycles you save are not needed for anything else. But lets put that aside, this is a learning project, so you want to try what can you do. The idea you describe has two big negatives: