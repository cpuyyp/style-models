If we can remove your calls to we should see a nice reduction in the run time of your loops. But, why can we remove this you ask? Consider: 

Here are some changes that you could make to your code. I'll explain various parts of the script below. 

Below are some changes I would make to your code. Starting off with I moved euclidean distance inside of this function to reduce function call overhead. Also it was unnecessary to cast and to . The other major change is that I created a function () to load your files into a coordinate vector. Instead of repeating a block of code twice, just make a function out of it. Edit: As another has mentioned it is best to replicate the pattern. The benefit being that you can either execute the entire script or through the use of modules call your functions separately. Hope this helps. 

NAMES Whoops, one more thing. I think I would also rename your class from to or something similar and rename the method from to . That is: 

It looks like you need a variation of the prefix sum algorithm applied to your list. In Scala this can be accomplished with scan: 

As you can see from the snippet above, will parse and evaluate whatever string you pass it, and return a literal representation of that string (assuming of course that the string represents a valid literal). Clearly, it is more efficient to compare and than it is to compare and . Also, it doesn't appear that you are concerned with whether or not or is a valid python literal because under the scenario that throws an exception, you default to just comparing the strings returned by and . Long story short you can remove the and just use the statements you have under the clause. 

More efficient ways to do the same thing: (1) The following reduces the runtime of your program to ~50% of what it was: 

You could use tuples to pair your flags with an . Throw those into a and then perform a and then a on that . Here is how that would look: 

There are at least two ways you can increase the efficiency of your calculation of . So right now you are doing: 

One of the main changes you'll probably want to make is to change and from functions to values. As your code is right now, every time you use it is having to recompute your top code block. The same goes for . At first glance I don't see a reasonable way to eliminate the conditional statements that you step though to calculate . Because of that, there isn't a great way to utilize pattern matching. So IMO you may as well take advantage of the fact that conditional statements are expressions in Scala. Another small tweak I made in calculating was to change to . Its not so hard to count out ten zeros, but if you needed a larger amount of them you now know about this other method. I added class fields for the other subsections of a typical phone number, e.g. and . Finally I utilized string interpolation for your method as to my mind it makes the expression easier to mentally parse. 

Well, that about sums up the changes I would make. If you have any questions, don't hesitate to comment! :) 

The is what is known as a companion object. In this case we might use it to store values that are the same across all instantiations of the . Within the itself we start off by checking that the 's in belong to the set of allowable nucleotides. Finally we calculate . The crux of the calculation rests in the use of followed with a . If you are unfamiliar with these methods I'd suggest playing around with them in the REPL as they come in handy. 

That is, this solution produces the same output as yours does for the tests that I performed. The intuition: you are essentially building a grid-graph sans the middle-parts. So we iterate over the range of possible points, but only keep those which are on the exterior. 

Solution Explanation So first off we drop everything to lowercase and then filter each of the string based on whether it is alphanumeric or a space. We've kept the spaces so that in the next line we may the into an of sub-strings which we then filter based on your length requirement. In the final line we utilize two more collection methods and . If was equal to then would return . then performs the final transformation to get your desired output. 

Here , , , and are assigned the expected character values and is a list consisting of the characters through . If I've misunderstood what your asking for please let me know and I'll update this accordingly. 

Whenever you need to perform calculations that involve the alphabet I'd recommend initializing your alphabet variable in the following way: 

I haven't tested it, but option one or two (or some slight variation of them) will mirror the functionality you have in your code while also being easier to write and read. 

When calculating the length of an iterator we can do so without creating a list and then immediately throwing it away. So where you do 

Also, we can import to get a potential speedup over your lambda function. Here is an example of how works (see docs for more examples): 

It seems to me that your general approach is solid. One small change I noticed you could make would be to move the declarations outside of the functions and . The reason for doing this is that it is expensive to compile the with every call to these functions. By moving them out we only construct them once. This is supported by the Scala Regex documentation which can be read here. 

You'll notice that in each of the four functions considered so far we calculate and then branch based on the result of this calculation. While I can think of other ways to derive a value for they aren't as intuitive as the operator and in the end I think we would still have a conditional statement which decided the final element of the list. Other than adopting the small change suggested by function I think your code is as concise / understandable as it can be. 

The above loop occurs as the inner-most loop of both loops and . With each iteration you check that isn't equivalent to 7 other possible key values. 6 of these key values occur in the data you've presented and the 7th () doesn't. It should be more efficient to replace: 

Note that in Scala you don't need to use a statement as long as the last bit of code in your function returns a new value. 

I added four new containers to the class (, , , ) to avoid recomputing them with each call to . now generates a single for each check instead of a of them. This is done with the method which returns if all values in the container are when evaluated by being . Lastly, the expression in can be replaced with a comparison operator. 

Swap a linear operation for a constant one Currently the function is appending () objects to . is a so this append operation has a complexity that is linear in the length of . You can remove this overhead by refactoring into a which can perform the append operation in constant time. If you wish you can check out this link for more details on performance characteristics of various Scala collection. A minor redundancy It looks like you could remove the that occurs within because it is called immediately before on the same object in . 

Code Below is another interpretation of how you might write your code. I've separated all your original parts into a set of case classes and one trait. For example, is now called and it extends the trait. I imagine you were aware of it, but was essentially a Caesar cipher. Likewise, all the logic you had embedded in the rest of your program, particularly how you were dealing with the the string and the function resulted in something close to a Vigenere cipher. In order to align the with the input text I choose to utilize a method on the list class, , which works as follows: 

With the above code if I set to my run time dropped to ~70 ms (naturally this number will vary on different machines). This code is a bit more bare-bones than what you have and may not fit your style but it is quite a bit quicker than what you have posted. The significant changes are