Another useful function you might add is get_once. I do something similar for when I store an error message in the session, then redirect to a new page and display the error message. After that the error message is no longer relevant so I remove it from the session. 

Then for showing the gallery we could use a data tag instead of class names to identify the links and galleries, then you could easily extend the code to include more galleries, with no extra js 

The dump function, why do you throw an exception if the session doesn't exist, but not anywhere else if the session doesn't exist? I would re-write it like a guard clause rather then having a return halfway through the function. 

If you can get all the shift ids in advance and do something like this. This is just some pseudo code to give you an idea 

You have a lot going on in one middleware. Keep in mind a middleware runs for each request so it needs to be reasonably well optimised. I have split the logging bit out into PlatformLogger class, that seemed like a logical separation. I have also removed a lot of the } else {, to me they just add noise and in most cases you return anyway, so the else will never get triggered. PLEASE NOTE: The conditions below where I removed the else's may not all be the equivalent to the sample provided, it is just to show you what it would look like, you would need to check and make those changes yourself if you choose to do it that way. Also check your if conditions, and do the cheapest test first as they might short circuit the if statement and you won't have to perform the other slower test that involve database access for example. 

self:: is for referencing static variables, etc $this-> is for dynamic variables Eg your constants are static so 

One aspect I'd like to mention is sorting: The contain does a , which is on the filenames. In particular, out of "somefile(9).txt" and "somefile(10).txt", the max will be "somefile(9).txt". It will then choose "somefile(10).txt" as the new filename, overwriting its original content. This is because 9 is larger than 1. 

Another thing I'd like to note. actually returns a value. What value? The last value in the list, that is . Let's inline it. 

The code is now shaping up nicely. Let's consider the final loop. Here you're ing until it's empty. Why not just loop over it in reverse? (The stack is going to be destructed anyway). Iteration is probably cheaper than mutation. 

(I cheated a bit, I moved from weights to lengths, because it somewhat makes more sense when talking about start and end.) Then, instead of 

The algorithm itself. Your algorithm is also far from optimal, calculating collatz(16) several times. First, when trying to add 3, it goes 

And be done with it. There's probably a lot that can be cleaned up further in the rest of the code, but I just wanted to give a short overview of how to fix the . 

And similar for match2 and match3. However, the real complixity in your implementation lies in the determining of the error message to show. I would suggest building a dictionary mapping the display error to internal errors: 

Better: use a testing framework like unittest, py.test or doctest. Here's how it looks like doctest: 

Not sure if the following will be faster, but I'd like to hope so. That is: profile! I see that in the nested if/else, they share code. 

Not going into the question as to whether or not this is a good idea, I can see very little wrong with the solution. One thing I would very much like to suggest is the following. Instead of 

Personally, I would just stick with what you have already got. You could try something like this, although too me it doesn't look any tidier. You would need to profile it against your database, to see if it performs any better. 

Check $trackCols against a list of valid column names you are expecting, to stop me doing things like I have below. 

The security aspect of things looks fine, but there are some areas for improvement, I have provided inline comments where possible. The whole quiz could be coded as a class, and would be a lot nicer, however I didn't want to go too far from what you started with so you can see what changes I have done. Overall, I have split the code into functions, and tried to make each function do 1 thing only, and renamed variables for readability. This will become more important when you go to maintain the code. The first bit of code is what I used to test all the functions and catches exceptions that occur. You could improve by adding more error checks after each prepare and execute, but I will leave that to you, as they are only really necessary if the database structure doesn't match the sql. 

On a final note $lang->xlate may sound like a nice function name, but after a while you will get sick of typing it, $l->x is cryptic but shorter 

Well if you want to split hairs, you could do a couple of minor changes (commented below) Honestly, I can't see any advantage in making it recursive, it works fine as it is 

The bulk of your code looks fine, I have made what are (In my opinion) a few usability enhancements, but take it or leave it as you see fit. I don't think you can really make the xml processing any less ugly. Comments are inline 

It seems a bit silly to use both and . I'd suggest replacing both by or . Using is a bit superfluous for ranges of length 3. 

First of all, let us do some short-circuiting. You're doing a lot of logic to see if it is a nice geometric progression, and after all the hard work, you check some very easy conditions. Turn that around! 

But now, the whole generator-function is a bit annoying, and I'd like to switch to ... (drumroll) Generator comprehensions Defining lots of separate generator functions can be really annoying, especially when the body of the generator is quite small. There's a solution for that: generator comprehensions. 

Already a lot clearer, no? Still, I've typed the sign 3 times here. By using the module, I could write: 

(There are also a lot of conventions on how to phrase a docstring. I won't get into that for now.) Parenthesis in conditional The code says 

You notice I left 1 comment in. That's because of the number. If you follow the advice below, you can replace that line with 

Global variables are not that nice. But this is a simple file, so maybe we can leave it like this for now? Let's. 

Let's think out loud what the lambda does: first, we find out the position of in . Then, we use that position to look up the value at the given position in , (which should, in all reality, just be again), and then get the second component. Better would be to write 

(without the comment). The code is just as clear. Excessive commenting in general Another comment I'd just like to point out. Somewhere in the code I see 

The first branch of the conditional is cleaned up nicely. Let's consider the second branch, most specifically the handling of . You're checking if , and throwing a ValueError otherwise because of an empty stack. What you actually mean is . That's already checked by the other branch, so this condition is superfluous. However, we can't just remove it just yet, because might then throw an IndexError. So, let's continue and see if we get another opportunity to fix it later. In the while loop, we see a . The has a , so we might as well move it outside the loop. (I took the liberty to also remove the temporary variable ). 

I haven't read the book you mention, although it looks good so I might buy it and have a read. A few things for me There are echo statements in the code, I am assuming that is for debugging and you are going to remove them. In a couple of places you use die(), and then elsewhere you throw an exception. Personally I would throw exceptions and let it bubble up to somewhere that can handle them properly. Your class is called fileImporter, but it also has a download aspect to it as well. I am wondering if fileDownloader should be separated out. You have a private getter function 

Have you tried using this function before? It does a fair bit of what you are trying to accomplish. $URL$ Failing that, I would try learning regular expressions, as they can make a lot of your strpos more concise. Its a handy skill to have in the toolbox. $URL$ I also find the a,b,c thing incredibly cryptic You could use constants 

If that is the case, then why re-declare then, why not use FILE_DOWNLOAD_PATH and FILE_ENTRY_SEPARATOR directly in your code If you do want to allow them to be overridden, then you could extend your constructor 

There also appears to be no way to overide these private variables which are set to constant values. 

Unless you know for sure there is no html or user editable content, you should really html escape it 

The get function here would probably be more useful with a default value option then just returning false. 

It looks reasonably well thought out to me, although I am not sure how much it would be used beyond practice. There are a few small things that can be improved. Comments are inline 

Database service, take the config out of the service, and store it in a config file. otherwise you need to edit the code when you deploy to a different server. Would a join work better here 

If you need to import your module or part of it, your code will execute each time. To prevent this, use condition 

Uhh.. Is it still complicated? If you can retrieve content type (ringtone or wallpaper) and save it in Dynpath field, solution will be easier. P.S. Please write your code in English not Spanish ) 

Use spaces instead of tabs. Avoid to name variables as built-in functions/objects. I mean . If you need this function later, it will take time to figure out why it doesn't work. keyword closes file automatically if exception happens. it's preferable for opening files. 

You also may use csv module to iterate over your file. Your code would be faster because of C implementation and cleaner without 

keyword closes file automatically if exception happens. {}.setdefault() is more pythonic than the condition which @dcrosta suggested. What about function, there is an excellent python library optparse, which helps parsing command line options. Check it if you need more complex user interface. 

Your code is messy and difficult to understand. I believe that in a few month you will waste time to understand what you have written earlier. So it is can be ok if you are not going to support/extend/re-use your project. Scrapy offer quite good architecture to organize your code properly: Item Loaders and Input and Output processors, Item Pipeline. It will move processing logic and make your main parse method cleaner. 

4. You don't check exceptions that are very likely when you send HTTP requests. In this case your script stop and you have to attack server from the beginning. I also advise you to close connections. With-statement does it automatically. 

You have 2 models (Ringtone extends Contenido). As I understand you store same , , in both models and every update/delete/insert operation on the first model must be synchronized with another one. You can avoid this, make foreign key to base model: 

One of the first things that I notice is that you define the as an instance variable. Better would be to define it at the top level: 

I'm going to look at the code without the intermediate print statements. They expose an implementation detail, and not the end-result. 

(That is, remove the doc string.) and can be given similar treatments. Importantly, add an extra empty line between the documentation, and the parameter description. Comments Look at the following code 

The reason is that you copy over a bunch of items in , but not in the . Whitelisting vs blacklisting In you copy several items over using a . Why not explicitly define the items you want to copy over instead? Actually, why copy at all? Performance would be a proper reason, but then I'd suggest copying just the items that have proven to be necessary to copy (after profiling). 

Also, in Dijkstra's algorithm, the key point is not the nodes, but the edges. An edge is a tuple (source, destination, weight). But let's first see what we can clean up before tackling that. Your takes a list of things. It claims to be a list of nodes, but it's actually a list of lists: edges. So maybe it would make sense to define a namedtuple : 

That's a bit nicer, right? Using The builtin has a second argument: . You can use it to signal counting should start at instead: 

I don't know enough about pandas and numpy, but I decided to take a look at some of the code anyway. 

Ideally, you'd split out the parsing of the -chunked blocks from the iteration, but this is good enough for now, I think. 

All these conditions look the same. Let's see if we can simplify it a bit. Let's start by flipping the and branch in . ( becomes ). 

You're basically asking a question, and then "What is the answer to the question?". Better to just ask the question alone. Instead of writing , you could write or . Another thing of note: the score (I assume that's what you mean with ) gets reset to each time you get a new problem statement, but the score () is only printed at the end of the rounds. That is, you have (pseudo-code)