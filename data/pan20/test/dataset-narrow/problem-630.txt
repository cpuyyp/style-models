Will not come out as the numbers they represent but can be reconstructed later on. But sequences such as will come out as making it easier to account for multiplication of variables. Questions For the most part I'm quite happy with this code, a couple things that I'm interested in (alongside general review) are: 

I'm dereferencing a lot of iterators in order to swap and assign values, is there a better way to be doing this? Is this implementation better than my last implementation? I'm looking for answers that think about stability, efficiency in terms of speed/memory, etc. (Possibly an obvious question) Also, I know nothing about templates, is there anything more to it than adding the line then line before the function and then using within it? I can't figure out how to get rid of . Obviously this goes against the templating, how should I store the results while I'm doing the merge? (Edit: since looking back at the previous accepted answer, I figure I should create a new vector outside the original call to (inside ) and pass the of that array as the destination, rather than defining a new array inside each call and using . Is this correct?) 

The following is a .wav file generator that I wrote briefly while (re)learning about audio sampling: 

The reasons for these questions specifically is that I like concise code, writing it on few lines without having any too long. Code 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

Very clean code. I only see some little issues: You throw "InvalidFileFormatException" in HuffmanDeserializer. Should the class care about where the byte-array comes from? I suggest to rename it to "InvalidFormatException". The MAGIC handle (checkSignature) can be omitted as you already identify format issues while you process the byte array. That is semantical redundancy. I currently do NOT say "delete the constant" as it is significant information to a developer what he/she has to expect if maintaining the code. But the relevant data is only the length of MAGIC. On the other side I do not know if MAGIC bytes are used only in your code. If so then I really think it is completely obselete. You several times mentioned: 

Make them a "public static final" constant. Resources should be loaded only once and not every time an object is instantiated. There are other variables that may be declared as constants like "listS1" or "listS2". If they are not meant to be changed then they are also constant candidates. An common convention is to write constants UPPER_CASE. Listener registration The listener registration should be within the configuration part of the component (see lazy getter) and not in the listener itself. 

Semantic mismatch in Constants You are mixing semantics in the class Constants. On one hand you enumerate allowed input parameters on the other hand you enumerate allowed characters. They will be changed on different reasons. Separate them into two classes (Single responsibility principle) Semantic encapsulation Tie together what belongs together. Connect the allowed characters to their label. Object vs Class Favor objects over classes as they are more flexible. They can be extended and mocked. That useful if you want to put them under test or reuse them. Argument preparation Try to prepare all the input parameters as early as possible so further algorithms are able to work on proper typed values. Invalid parameter The output of "Invalid parameter" is redundant by three. Remove redundancy by extracting it to a method and/or provide a better exception handling. First argument cannot be number This information has no more value than "Invalid parameter". Remove it. Case specific adaption of check concept and parsing On one hand you are checking towards (!args[i + 1].matches("^\d+$")) on the other hand you are checking backwards (!args[i - 1].equals("-length")). Try to establish a concept where you are only going only one direction. Insufficient check Once you determined that a parameter only contains digit you do not check this value to the end as this digit chain may not be a valid Integer. You pass around a half checked value. Parameter reusage Do not reuse the parameters passed in. You are removing "-" instead of using well defined labels. Duplicate checks You are checking "-length" twice. Try to consolidate this check with proper parsing. Exception handling Do not return null as the indicator. Throw an exception as soon as you identified a problem. General Parsing is a tricky thing. To be flexible in Parsing you need to build up structure and/or generic algorithm. Things will become very complicated as the parameters have different natures. To handle every state with a monolithic if-clause is hard. The example I will provide adresses some things I mentioned. But the real flexibility you will only gain with library support and/or a state machine. The solution I provide will go only with no library support, little generic and lots of structure. Code Structures for allowed chars 

Is there anything that I can do to improve my function? I'm especially interested in the use of storage types other than and what the advantages of doing so would be. It should also be noted that I do have an intention of doing something like this in a however, as this was quickly thrown together for the solution that's parked for the time being. I'm less interested in my method of solving Problem 16, however any comments on that would also be appreciated. 

Following the review of my old merge sort implementation here, it appears that the biggest improvement to make was to use iterators instead of copying the s. Having never used iterators before, I'd like a review of the new code following that review: 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

On top of the comments provided by Billal BEGEURADJ, you also have the possibility of a stack recursion error in your code: calls calls calls calls calls calls And calls To fix this it may be worth making the game get started from outside of the class in a loop: 

Recently I've been doing some experimenting with RPN and the shunting-yard algorithm, in order to test these systems more appropriately I planned on writing a tokenizer and then using these tokens to check validity and eventually get some output. I also think that I could use this to work with some primitive programming language, such as making a CHIP-8 assembler. Function The intention is for my tokenizer to separate the input string into a list of the following: 

Overriding hashcode and equals on mutable objects will lead to unaccessable elements within hash-based datastructures like HashMap or HashSet. Always make sure your objects are immutable when overriding these methods. Furthermore your implementation of equals is semantically wrong. This is because you make "equals" dependent on hashcode only. Maybe you can precheck the hashcode to avoid a complex equals-evaluation if the hashcodes aren't equal. hashcode has a totally other purpose. It provides a value that is used in hash-based datastructures to balance lookup tables to increase lookup performance and minimze the binary search path. You may say that Integer.hashcode(int i) always returns i. Yes, but you depend on implementation details for a totally different semantic. A correct implementation for your SomeInt: 

Avoid multiple return statements Try to reformulate your algorithm so you have only one return statement at the end. The problem is that the constructs like break, continue and multiple return are not refactoring-friendly. Extracting methods out of the current method that contains such constructs will lead to reformulating your whole control flow. Naming Try to rename i, j, count and index to match there semantic best. (e.g. startIndex, offset, word2Index, ...) 

First of all I see really nice approaches in naming your artefacts (classes, methods, parameters, vars). Furthermore you master the first step of programming: algorithmic thinking. As you have thought of naming you figured out most responsibilities so you followed the single responsibility principle. Yes, there are some things to improve. But I see only one real big issue: the intention to implement hashcode and equals. Hashcode and equals I'd like to address hashcode and equals as there are intentions to implement them. If you do so you may have strange effects in the future. You can easily see what happens if your equals and hashcode methods base on length and width (and I guess it will) of your Chocolate: 

As part of a first year university course in computer architecture some time ago we were tasked with learning 8086 ASM. The final course work required creating a small animation of shapes moving around the screen changing colours and the like. As I would not expect anyone to review 720 lines of assembler I'm just going to provide my implementation of Bresenham's Line Algorithm. Note that this is not the entire program but a single macro from the working program. Also note that at the time of writing I had little to no experience with 8086 ASM (I still don't in fact), but I'm very interested in knowing how I did and how it could have been improved upon. If anyone is interested in reviewing the rest of the project as well (it can be done in small parts) then let me know. 

I've recently started learning OpenGL and thought that a great way to start using it in its simplest form would be to create a Chip8 emulator using the keyboard callbacks and graphics that GLFW and OpenGL provide. As this question would be too large to request a review on my classes used with OpenGL and my Chip8 emulator, I'll keep it to just the Chip8. 

Note that this would require a few changes to make it work but would result in there not being any recursion hidden away. 

I'm working through some Project Euler problems using C++ and some of the numbers in question are starting to get quite large (21000 for Problem 16) and I need to add some of these large numbers together, so I quickly threw together a string represented (positive) integer adder: 

You can see a high symmetry as we input a set of elements and pass these elements immediately to the consumer. The only thing we define here is what to do asynchronously (maybe starting the thread, but I ignore that for now). Stream preparation We have "ElementJoiner"-class that does pretty well. Now we want it to work together with a stream. A standard stream cannot exit as long as there is no indicator for exiting. If you have a Ranged-Stream you limit the stream through the boundaries defined. The stream we want to have has a special indicator so we have to define a so called Spliterator. 

... separate the technologies (Spring service, Spring DI, Spring task scheduling) ... ... introduce a model ... ... make the services depend on the model (observer mechanism) and not on each other ... 

Although the solution inflates to three methods nobody can avoid the responsibilites involved to produce the result: 

Test The only thing to determine thread-safety is to acknowledge that your monitor works. All other things can be tested without considering concurrency. To determine if a monitor is working is to "attack" the critical code fragments. Write access As mentioned above following statements are critical: 

Object scope You should introduce object scope. Your source code gains flexibility through the possibility to to apply abstraction, polymorphy, inheritance (Open Closed Principle). Your code will be testable much more easy. Furthermore in JAVA 8 you can make use of functional interfaces. That would not be possible in a static context. Constants As "bracketMap" is a constant you should declare it "static final". Then you will get rid of instantiating the HashMap every time you call "validateBracketPairs". break, multiple return (and continue) Avoid those statements. Using them you hinder yourself to make use of applying refactorings like "extract method". Within a loop you spread your breaking conditions all over the place. That makes the code less readable an maintainable. All breaking conditions for a loop should be at one place, the loop header/footer. For methods that have to have a return value try to have only ONE return statement at the end. for-loop The for-each-loop is not the appropriate loop for this case. Consider a loop type that allows breaking conditions to have a proper place to put your go-on (breaking) conditions: As long as there are characters to process OR you not found a validation error. switch-case The switch case statement can be simplified through the standard if-then-else. Use the keys() and values()-method of the bracketMap to check if they contain a character. Now you are able to extends bracket pairs through putting them into the bracketMap without touching the if statement anymore. (Single Responsibility Principle). Naming Because bracketStack only contains open brackets it should be mentioned in the name: openBracketStack. Code So I would end up with something like this: 

I'm aware that not all op-codes have been implemented as I have only implemented the ones needed to get the 15 Chip8 games that I have copies of running. The code that I am most interested in having reviewed are the chip8.h and chip8.cpp files however I have included (the majority of) main.cpp for completeness. An update that I would like to work on would be to switch from using a statement to using function pointers but would like a hard review of the current working code before I begin with that. Thanks to this tutorial which I used to get started and for opcode . chip8.h 

As a small suggestion, I noticed that your s have an odd line at the right hand side due to drawing them with the outline of an oval (as you noticed and commented in the function). You can fix that by instead using two filled ovals, a big one which is filled using and a smaller one filled using (Although this does require adjusting the to compensate for the missing width): 

Something I'm less sure about as I haven't implemented a CHIP-8 emulator in some time is that it doesn't appear to be functioning 100% correctly, although some games are certainly playable. As far as it running is concerned, I picked of a few games to see how they ran, I had no problems with: 

Edit: Thanks to @ratchetfreak for pointing out a bug whereby I was overwriting elements of without storing the overwritten element elsewhere beforehand (essentially losing it). 

You have to consider that using Spring is like playing with lego bricks. Spring will force you into a corset of for most usecases "well-defined" interfaces and dependencies if you want to reuse already existing functionality. Your task is to chose the right elements out of the toolbox and use predefined implementations or provide custom implementations under Spring interface contracts where you need them. Finally you configure the implementations to use in the predefined dependency graph as Spring provides it. All I mentioned you have done. Everything is adapted to the interfaces Spring forces you to use in a minimal way. Following suggestions I have, but that are small concerns: 

... where to receive or how to produce elements (supplier) ... where to register the received or produced elements (consumer) 

A correct test would be to ... ... run a thread executing statement 1 and stop ... run a second thread and check if it runs into the monitor lock ... if the second thread ran into the monitor lock -> continue with thread 1 ... If the thread 1 leaves the monitor -> thread 2 should enter the monitor, execute the statements and leave the monitor. Read access Another issue is that the HashMap is not thread-safe anymore so the "get"-method of "CountAtIndex" must prevent modificiation access during read access. Reading concurrently only is never a problem. So this is not an issue of concurrency. To test this scenario you have to ... ... start a thread that is modifying (countAt) and stop before it will leave the monitor. ... start thread 2 that will query the index count (get). You have to check if it ran into the monitor lock. ... thread 1 then has to continue and should leave the thread ... thread 2 now should continue and get the proper value.