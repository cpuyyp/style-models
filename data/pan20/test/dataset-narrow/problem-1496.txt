Thanks to working with Racket recently, I've been spending a lot of time learning about and implementing non-trivial macros. In the process, I have been thinking about ways to apply this skill to my teaching. In particular, I teach students C (in the context of CS50 AP) and would like to show them simple but useful examples of macros in C. I see the potential benefit as two-fold: 1) it would be helpful for discussing the C pre-processor when I teach the stages of compilation, and 2) it might help students write/understand code with information abstracted away in macros. What lesson ideas (with code examples hopefully) do you have for introducing students to macros in C? 

I've been volunteering at a local Girls Who Code club at a U.S. high school. Other volunteers are female grad students in computing. I've been struck by the fact that even though the volunteers are women in computing, that doesn't mean that we won't scare the high school girls away from computing with bad teaching practices. The other volunteers tend to: 

Tell students explicitly that the mind works like a muscle when learning computer science. Carol Dweck showed that students can be explicitly trained in growth mindset, leading to better outcomes for those students. 

Peer Instruction materials exist for Discrete Math, for instance Cynthia Lee's Peer Instruction questions from Stanford. You may be able to adapt some of the questions to fit your needs for a HS course. To your first point, I find Peer Instruction to be an excellent balance of lecture and active learning. There is direct content delivery, but it is short, and punctuated by active Peer Instruction questions that get students talking and allow the instructor to know that the students are actually thinking :) 

This now becomes a teachable moment on a number of levels: imperative v. functional languages, recursion v. iteration, "expense" of function calls on the stack. Students appreciate being shown the messy truth behind topics that are sometimes treated reductively and simplistically. Let them wade in the mire and see what they think about these debates. Have them analyze the arguments they mind on here; now they are thinking on much higher, more sophisticated level about program design. The key line that I take away from all of these is this one: "You almost never use recursion for performance reasons. you use recursion to make the problem more simple" (top answer to the first post I linked to). It's often times an exercise in thinking more so than programming. From a pragmatic perspective, discuss use cases for something like merge sort and quicksort (recursive) v. bubble sort (iterative). Throw in traversing tree structures as well. There is a time and a place for thinking recursively. Iteration is not always the best choice to make. Last, from an aesthetic perspective, based on my time studying SML, there is a beauty, an elegance, an aesthetic to a well-written recursive function. It's clean, clear, easy-to-understand. If part of code quality is its readability, then recursion has an aesthetic quality to it that a for-loop arguably does not. 

Design This is where the algorithm is figured out, and psuedocode is written. It's also a great place to introduce common patterns in solutions, like the Input, Process, Output pattern so common in beginner programs. For example: 

(Note that this problem provides indentation information, but others on Runestone do not, allowing students to choose their own indentation -- this is known as a 2D Parsons problem) Recent development is in the process of adding cool new features to these Parsons problems within Runesone [reference], like 

I don't think there are shortcuts hereâ€”the students just need more foundational knowledge before they can be independent. It takes significant expertise to be able to transfer knowledge to new contexts [ref]. Novices have shallow knowledge that is closely tied to shallow features. As an expert, you have insight into meaningful patterns in your area of expertise. You have also seen many, many different problems and cases that you can relate to current problem-solving. Your knowledge is organized in terms of its applicability to new problems [ref]. It seems so straightforward from your perspective! But think about the challenges facing novices. To them, the problem looks different than anything they've seen because they don't recognize the generalities. Do they even know what words to Google? I agree with other posters that confidence is necessary. Knowing good resources to use (e.g. user-friendly documentation) also helps. But most important is foundational knowledge. Teach your students well, with many examples, and as they learn more they will begin to seek out knowledge on their own. 

Ultimately, students need to know Java, and understanding classes and objects, inheritance and polymorphism, will be as needed with FRC as anywhere else. However, to help them see how Java applies specifically to FRC, start with something that drives and work backward from there. Maybe start with #2, move back to #1, and lead them to #3, maybe even with examples you have found of how teams use the WPI library in different ways. 

The materials in this course are heavy on recursion, so some of the earlier exercises in Homework 4 may help your students with this concept while getting them comfortable with basic Racket exercises. I also can't speak highly enough of the free, self-paced course materials for UC Berkeley's CS61AS found on the "Textbook" tab. These two additional resources may spark some ideas as well: 

Have you considered the social aspect of your class? For most people, I don't think there's anything more motivating than working towards something you want with people you like. And even if you're doing hard, boring, or confusing work, if your friends are doing it, you'll want to give it a shot too. If your buddies are excited about their future in the field, then you'll very likely become excited too. It's peer pressure. It's infectious. This is the reason that cohort models are so powerful. With more time around a group of people, taking all the same classes at the same time, you build deep bonds that make you more excited to come to school every day. Proximity is the strongest predictor of friendship. I have used this approach to build strong cohorts among students I worked with (18-25yo college students). This is done by frequent teambuilding, constantly mixing up their seating, active learning, pair programming, talking about how they are a cohort, calling them a cohort, reiterating how we're all working together towards our goal, etc, etc. In my setting, students were excited about graduating with their CS degree and getting a great job. Sounds like it could be similar in your case. I'm sure this looks a little bit different for older adults, but everyone loves being part of a group that's going somewhere. My recommendations: 

Personal disclaimer: the best preparation for the exam is first to ensure that students master course content. If you have an AP CSP-aligned curriculum, then every day is a day of exam preparation. This touches on the biggest struggle I felt as a first-year AP teacher: am I teaching them computer science, or am I preparing them for a computer science exam? The ideal situation for me -- and the personal resolution I reached -- is that quality instruction, assessment and feedback, and student engagement with a rigorous curriculum (CS50 AP in my case) are the key elements to focus on for ensuring student success on the AP Exam. That said, I did utilize a number of resources throughout the year: 

Help students make improvements to a toy website with git & Github I have taught git and Github basics with this activity from OpenHatch. It was successful for helping students learn git basics: clone, add, commit, push, and pull, as well as Github basics: making an account and repo, submitting an issue, and making a pull request. In the activity, small groups work to improve a small website housed in a Github repo. The site is also hosted on Github, so they can see changes immediately. Issues are available in the repo for students to claim and then work on. Students really see the difference between running the site locally and seeing the version hosted on Github. It requires some setup before hand, since students interface with a real Github repo. But it's worth it, since students get to use git in a realistic way (and so they have contextualized knowledge!). Another bonus is that no specific programming language is required, since students can modify text in HTML to complete tasks, or hack some javascript for the most advanced tasks. 

I, too, have felt exactly the same during lab periods. Walk around, ask questions, sit, repeat. I've come upon two things that help improve productivity: goal-setting and reflection. Releasing students to work as soon as class starts for more time can be counter-productive. Instead, I found it helpful to frame the focus for a particular lab session with a clear objective. That goal may stretch over multiple days, but every class should start with a review of the goal, a discussion of progress made if relevant, and a re-focusing for the day. It does not need to be complex; a simple, manageable goal is effective. Even having multiple small goals rather than one big goal may help students spot their own struggles as they do or do not make progress. Comments can go from "I'm stuck" to "I'm having trouble implementing x." Their involvement with the creation of their own plan for a lab session will also increase their ownership of their work. Plus, it's essentially another way of teaching decomposition. :) To follow that, a goal that doesn't get assessed for progress may as well not be set. I find exit tickets to be an absolutely invaluable tool (thank you, Google Forms!). Even 1 or 2 simple questions at the end of class like "How did today go?", "What went well today? What didn't?", "Do you have a questions for me?", etc., will help you see their progress meaningfully, spot trends among student perception of the lab session, and provide a way to start the next class. 

I used a card game activity to review Boolean expressions in a CS1 context. You may be able to adapt to involve more abstract propositions and more complex operators. tl;dr Students play a card game in small groups. They choose proposition and operator cards from their hands to create true or false statements. Proposition cards have text like: 

When you allocate memory (make a pointee), draw it in the heap. Setting that pointee equal to x makes an arrow go from the pointer to the pointee. 

This step could further elaborate on the details of the Process step, of course. Implementation This is where you finally code! But note that the previous steps require no knowledge of syntax at all. Those steps could be learned in the first few days of class before a single is ever seen. Here's the full outline of Rick Mercer's CS1 text (aimed at college freshmen): 

When teaching it, he used the book D is for Digital, which I assign to my AP CS Principles students. That AP class is similar in spirit to a CS0. He just recently released a new edition of the book called Understanding the Digital World. Here is its ToC: 

I'd use the following analogy connecting MVC to a teacher's gradebook. In the context of MVC, the actual gradebook with a complete record of every student's grade on each assignment is your . Students may have their individual grade rendered in the , but they would never have access to the entire database (for obvious reasons). A , say in a school's learning management system, would select the appropriate grades to display to the specific student. A student could then choose only to render her quizzes or her homework assignments to focus on specifically those grades. In that instance a user action in the , through say a dropdown, would modify what appears thanks to logic in the . As with all analogies, it is an imperfect comparison. However, this general concept will be something (nearly) all students are familiar with. The iTunes U course on Developing iOS 10 Apps with Swift has a great lecture on MVC. The lecture video and slides are available here. The image below from Apple also gives a succinct summary of the relationships among the three components.