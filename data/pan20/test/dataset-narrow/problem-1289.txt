This will keep your writes consistent and predictable, depending on the nature of your game, you could have infrequent database writes. The key is to realize that if your application server crashed, you'd have to come back online from the state in your database, so serializing player inventory every 90 minutes might make players upset. For reading data, you'll want to load as much as possible into memory in the application tier as possible, then insure that all of your code uses this memory pool, in the background you can synchronize the memory pool with the database. As Joe points out, there will be times when you need "real-time" transactions. By serializing most of your writes, you should still have sufficient IO on your database to do real-time transactions when necessary, presuming sufficient hardware on the database server/cluster. 

I'd try to render images at the same size as the source image, so if that is truely the max size (and also the size of your .png or whatever) I'd render it as-is and be done with it (unless I saw noticable framerate drop by doing that). If you do see performance problems, or you anticipate much larger imagery, you'd need to come up with a tiling scheme, which will determine which tiles of your map need to be on the screen and render them. One way to do it (maybe not the best) is to use a Tile class, then have an of tiles. Each Tile knows its realitive position on the screen and can react to user-input in order to move on the correct axis. 

I'd recommend the User Datagram Protocol -- have each client send user inputs to your server, have your server calculate the results of all inputs and respond that result to each client. 

Note the unordered list, most of these can happen asynchronously, though if its just you working on it, it would probably make sense the serialize the process. This is a relatively large task, that will probably require significant effort, and is probably (at least in my opinion) not a good place to start building games, I'd recommend biting off a smaller project if this is your first. 

Greatly reduce your design. If you have a short timeframe and have to learn everything as you go, you will run into problems and it will be hard to get anything done. Think single player first. Making a multi-player game is tricky and will most likely require some programming to get working. In general multi-player must be thought of and designed for early on, but I recommend your first game be a single player one. Stay motivated and ask specific questions you have here when you get stuck. If you have a specific question and you show how you have tried to solve it on your own, its very likely someone on this site will be able to assist you. 

I know that you defined events to be interrupts and what I've put here is not "truely event based", but I don't see what the above doesn't give you that interrupts do give you -- most users will not notice the single frame lost, unless your game runs at very low frame rate. 

I would not ban a failed CAPTACHA for an hour, that seems harsh, I would just prevent them moving forward until they successfully complete the CAPTACHA and allowing for a new CAPTACHA image to be shown. I would also only display the captcha if they making requests too quickly, I'd store the a DateTime on every request, and then compare it to the next request, if its less than 2-4 seconds, you display the CAPTACHA, otherwise let them go. You'll need to determine what a reasonable interval is for your game, server, and bandwidth. You could also do a "forced" CAPTACHA every X times that an action is taken, this will prevent even an automated script with a built in so it doesn't trigger the time limit CAPTACHA. 

With the proliferation of touch based devices, many lacking a true D-Pad, I'm wondering if anyone has any resources on how to emulate a D-Pad on a touch screen? I'm specifically interested in XNA and/or Android code examples. 

What I'm worried about is that this feels rather predicable, what other factors should one take into account when building recoil? While I'd like it to be somewhat predictable, I'd also like to keep players on their toes. I'm thinking about increasing the min/max recoil values by a large amount (relatively) and adding a weighting, so large recoils will be more rare -- it seems like a lot of effort to go into something I felt would be simple. Maybe this is just something that needs to be fine-tuned with additional playtesting, and more playtesters? I think that it's important to note, that the recoil will be a large part of the game, and is a key factor in the game being fun/challenging or not. 

To make a real-world example, lets assume I want to build an animated sprite for an explosion. The duration of the animation should last ~1 second, and we'll say exactly one second to make the math a bit more simple. And lets assume I'm using XNA and my goal is to target both XBox (60fps), PC (60fps), and Windows Phone 7 (30fps). My question is this, how should I build the sprite animations so that my programming is as simple as possible without simply using a timer to calculate which frame I should be on (which I feel would make the animation "choppy")? 

You don't want to be hosting any games from an iOS device, so you are probably looking for something to run on OSX. I'm not sure how lidgren works or if it is Mono compatible, but the Mono project has done an excellent job of bringing .NET to OSX and Linux. I highly recommend you look into it, especially if your library of choice is .NET. The server architecture and platform don't dictate what the client must use, so having a Mono/.NET lidgren server and an iOS (Objective-C) client should be just fine; however, there is MonoTouch which brings .NET and C# to iOS, so you could use that if you felt like it. 

If your values for X and N are very large, it would probably make the most sence to keep the player list sorted by such that you could always take the bottom elements to create a group. This will front-load your computation time (keeping the list sorted every time you add a new item), in contrast with the above algorithm which would require execution every time a new group is to be created. 

I'd recommend you check into $URL$ and $URL$ for information on what you can do with node.js. cocos2d-javascript has a tutorials section on their website: $URL$ which I recommend you start with. Without significantly more detail, there isn't much more I can recommend you look at. 

Its hard to tell exactly what you're asking, but there's my thoughts. When testing networking code, its perfectly acceptable to use for both client and server to get it working, because its quick to debug and you can easily debug both client and server. It is important to note, that this is NOT sufficient for testing and final development. In order for your testing to have maximum impact, you must test as many situations as you can. The minimum you can get away with are (IMO) these: 

You can change state anywhere, as long as you have a pointer to your main class. You can load/unload as necessary to save memory (if your game is big it might be nice) You've kept your very simple and easy to follow. This is the single most important thing a programmer can do IMO. 

You might want to look into getting an EC2 instance (Micro) -- you can run basically whatever you want on them, so writing python shouldn't be a problem. The smallest Linux instance is $0.02/hr as I recall, so it shouldn't run you all that much. However, I would build and test your server code on a LAN, and only once that is working well would I start looking for external hosting options. No need to pay for an Internet server, until you have something to actually test. 

You could use proximity detection to run the algorithm every few frames if the distance is very great (because in most cases if the distance is large, the target path wont change drastically from frame-to-frame). For example: 

If your game has little or no replay value (which is not a bad thing, but it does change the way that I think you should price your wares) then you should charge your fee upfront. Get your money and be done. It will reduce the number downloads of your game gets, but at least you will make some money. Since you anticipate 30-60 minutes of total playtime for your game showing ads wont make you very much money. Ads supported games/apps work best when there is a strong reason to come back and play or use the app again (and thus see more ads). Based on your comments, question, I think that $.99 is the most you should charge for a game that plays through in 30-60 minutes. Most short games are in that price point. I think that Angry Birds (mentioned in another answer) is the exception likely due to its low/free cost on other platforms. Most Xbox Live games on WP marketplace are in the $2.99 range, but most of these provide at least a few hours of gameplay before being boring, and IMHO many provide tens of hours of play. 

Only load what you absolutly know you need immediatly, or you know you'll need soon Only remove things from memory when you absolutly know you wont need them again AND you need to load something that fits the constraints of #1 AND you've reached your memory limit A general understanding of Paging and Virtual Memory of Operating Systems can be applied to games in terms of when to remove data from memory -- that is to say, those ideas can be applied to game systems because many games have "OS like" requirements (fast, direct access to memory, input, and network devices) 

This way, the experience required to get to Level X is and accessing other data is easy as well, if you need a collection of Items, you can add it here too, if your Items data is too large to store in memory, you can also implement caching logic within the static class. Making it static keeps a single copy in memory, and ensures that every client of this class is getting the same data. While this does "tightly couple" your classes together, tight coupling is not a bad thing if the design really needs it, which in the case of Item stats and XP charts, it is, IMHO, reasonable to tightly couple these. I always try to keep it simple, until something forces it to be complicated. 

Without any specific knowledge of your generation algorithm, I would suggest the following. Assuming that your world is defined in a multi-dimensional array 

Just to toss this out there, you can build your own and simply stuff a standard PC inside it, Scott Hanselman did this with his Hanselcade -- $URL$ very labor intensive, but if its for a pet-project this may be what you (or some googler down the road) is looking for. 

I think @Gajet is on the right track; the other thing I think you may be missing, is that the server should define the state. Events should be sent to the server, who does world calculations and then updates each client. In other words, when a client clicks, it should send the data about that click to the server; the server then calculates where the box ends up, and sends that data to all clients. The client who actually performed the event can start "predicting" where the server is going to tell it to put the box. Put a different way, each client should tell the server "the user just did X" at the moment it knows that X happened. Then, the server goes about figuring out what that means, and updates all of the clients. As soon as the client finishes telling the server about X, it starts moving the box and when it gets the update from the server, it adjusts the box from its own calculation to the calculation received from the server.