I took me a while of hunting, but I managed to get low-latency real-time video streaming working on my RPi2. I'm running this on my RPi2: 

Manually power cycling it sometimes fixes this, but sometimes the error immediately re-occurs. What's causing this? It seems to occur more often if I try to SSH into my Pi while it's booting. I'm running Ubuntu 16.04. Edit: I'm also occasionally seeing the error: 

during boot, which also hangs. Would this be caused by a corrupt or defective SD card? I'm using an 8GB Kingston, which is reported to work. 

Is there any workaround for this? Even if I add the pi user to the root group, it still silently crashes. 

This eventually resolved itself. I installed Ubuntu 16.04, upgraded the firmware using the standard rpi_update tool, and then did a hard power-down reboot, and wireless worked. 

After reading through the several Launchpad bugs associated with the ARM image, it's clear the Raspberry Pi 3 cannot reliably run the Ubuntu kernel at this time. I've decided to abandon Ubuntu and use the default Raspbian image instead. Edit: I eventually found this image (ubuntu-minimal-16.04-server-armhf-raspberry-pi.img.xz) which runs reliably on both the Pi2 and Pi3. 

Just be very careful you have the drives the right way around... the OS won't warn you if you try to overwrite your main SD card. 

You need a TDS (Total Dissolved Solids) meter (aka EC/PPM meter) for measuring the nutrient content in your water, and you should also have a pH meter for maintaining a proper alkaline/acid level. I did a quick search, and here's a link for each of the above meters, and how to integrate them to the RPi. They are brand-specific, so you'll have to do your own searching if you seek out alternate units: TDS meter pH meter Note that I am not making a recommendation for the above products whatsoever. I've never used them; they are just examples of what you're going to need. 

To avoid having to install a custom kernel, you can use this driver, and then follow these instructions. Specifically, because you have the 5" model, you'll use the following command after following the first few steps of extracting the driver tarball and changing into its directory: 

I am pretty sure that uses the HTTP proxy environment variables, and the issue you're having is that you can't fetch anything during install from the Internet: 

I have absolutely no idea what the issue could be. First, I thought it could be an issue with the GPS. These devices are relatively fragile, so I figured a component of it could be damaged. I plugged the device into my computer while sitting outside and it got a position, differential, and heading lock. Once I knew it had a lock, I plugged it back into the Pi, reran everything, yet I still recieved the error message. I know the device can be detected. Running , shows the following entry: 

I've been researching how to use a servo on my Raspberry Pi but the tutorials concerning this seem very complicated. This surprised me, since the Raspberry Pi has GPIO built right in. Despite the Pi appearing to be servo-ready, most of the sources I have looked at have a setup that looks something like this: 

As explained here, the "Data Partition" option creates a buffer that is untouched when the OS is installed. Like any partition, it segregates memory so that if a OS is reinstalled to the SD card, it doesn't wipe out all the preexisting memory. 

I'm interested in a very basic servo implementation on the Pi that does not take up a lot of extra space nor demand extra hardware / power. Thank you so much for any guidance you could provide on this matter. 

Here's an example that does the same thing, but uses my Mock::Sub Perl distribution (it's equivalent to Python's 'Mock'). If the env var isn't set, it'll mock out certain functions/methods. If it is set, we're on a Pi board, so we can run natively with the original functions: 

I am reasonably certain that wiringPi's command can't be used to interface with the expander in this way from the command line. You'll likely want to interface it by writing your own binary. Please see this document on Gordon's site for further details. Said GPIO expander is an i2c device, and must be treated as such. 

As @joan said, wiringPi has different pin numbering schemes. uses the GPIO pin scheme, whereas uses the wPi pin scheme. You either need to change your init call to or change the pin number to ( is the GPIO representation for physical pin (PWM pin), and is the wPi representation). Your wiring is definitely correct, as the command uses the GPIO pin scheme, and will automatically use as the pin number and that's why it works on the command line. 

The IP will be the IP address of the hotspot. To resolve names to IP addresses, you'll need to add at least one DNS server: 

Should this be changed? Are there any known clock skew issues with serial communication between a Raspberry Pi and an Arduino? 

I was using my Pi 3 on an 10-year old Linksys wifi router, and it worked fine. However, I just bought a new Linksys router, which supports 802.11 A, C and N, and all my devices are able to detect and connect to the new router...except the Pi3. Running doesn't show my SSID, even after rescanning. According to the specs, the Pi3 supports only 802.11N, so it should "just work". Is there any kind of configurations that the Pi3 doesn't support? For example, my router's admin lists my wireless network settings such as: 

As far as I can see, this library is only available in the repos for the Raspiberry Pi, and have no x86 candidates in the standard Ubuntu repos. How do I fix this? Edit: I managed to fix all the include errors by manually installing the Raspberry Pi firmware headers to my /opt/vc. It now seems to compile my code fine, but it's failing to link it to some shared objects: 

How do you detect when the Pi is slowing down its clockspeed due to overheating? I know I can find the "current" CPU speed by running: 

I have no idea what to do. Any help would be greatly appreciated! Update: I suppose it's also important to mention that I had a lock using this GPS the other day. Now it doesn't get a lock at all, which to me makes no sense. 

A source here goes into further detail on what it does. It sounds to me like selecting that option will allow you to create a 'recovery disk' of sorts. It might have come as a result of discussion on this issue, where people requested a partition that persists despite wiping another partition on the Pi. I hope this helps! 

They involve a breakout board and an extra power supply, which is not space efficient, nor does it seem like it should be the case, given hardware the Raspberry Pi has. To my understanding this is caused by a voltage difference problem. The board itself takes in 5 volts and outputs around 3.5 volts to the GPIO pins. Most servo motors require 5 volts. This raises some questions: 

Then, I thought it could be a problem with how the Raspberry Pi is configured. I doubled checked the aforementioned guide. Conveniently, I have another GPS, although this one is a much smaller and cheaper that plugs directly into USB and doesn't require it's own power source. Rerunning all the commands replacing with worked. A lock was achieved relatively quickly and displayed the correct data. Even when the lock wasn't achieved right away on the USB GPS, didn't time out. Does that mean the problem is a connection issue? Just to double check that it wasn't an issue with GPSD, I called variations of the command, changing the location specified, and even omitting the location. (Always making sure to a GPSD process before starting a new one.) Sometimes, the model of the GPS would flash up as raw data, but always timed out. 

Why is it rebooting even though I'm using the option? What am I doing wrong? Edit: I found that I could save the console output by instead running: 

How do you allow non-root users to access I2C on the Raspberry Pi 2? I've compiled this code for accessing an MPU6050 sensor via I2C, and it works perfectly, but only when I call it via sudo. I tried adding the pi user to the spi and i2c groups, and adding udev rules as explained here and here, but even after rebooting, those had little effect. I can run as a non-root user, but the C code still crashes if run without sudo. This is documented in the underlying bcm2835 library: 

However, this clearly doesn't use the HTML5 tag. I then tried the WebRTC example page, and this does appear to run in the browser, but it's heavily Javascript based, so I can't tell exactly how it's implemented or if I can reuse it in my own application. 

How do you install the Arduino IDE on the Raspberry Pi running an ARM version of Ubuntu or Raspbian? There doesn't seem to be any official ARM release. Both distros have an "arduino" package in their standard repos, but it only includes an ancient 1.0 version that's missing a lot of features. 

Given the information in the comments (the red LED staying on solid) means that the SD card does not have a valid boot partition (ie. Operating System) on it. A solid red LED indicates that the Pi is ok, but it can't start up. You need to re-flash the SD card, put it back into the Pi, and power it up. Installation instructions can be found here for both NOOBS and Raspian OS builds. You'll need to read through all of the information, including the link that directs you to the Operating System you're running on your computer. 

The IP here will be that of your DNS server (quite possibly the same IP as the gateway above, but that's not certain as I don't know your network). 

I rarely, if ever, use the GUI on my Pi devices. I develop for it from my laptop workstation. In the UI, there's an annoyingly terrifying icon** that pops up for this condition, but how can one tell if a Pi is under-powered if only used in headless (console-only with no immediately direct visibility of the console itself) mode? ** - ok a bit extreme