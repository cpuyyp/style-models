A picture says more than a thousand words, so here's a mock-up. The actual choices are different, this is just a sample. 

I don't think there are any possible edge cases here, at least some initial tests don't reveal any problem. I think it's short and readable, but readability is often hard to judge when you're the author. Any remarks? 

The goal is to construct a with a connection that uses an access token. The access token is acquired with ADAL (Active Directory Authentication Library). The problem is that acquiring an access token is an async operation. Luckily, ADAL uses for its async calls, so it should be safe to do sync-over-async without risking deadlocks. Full code is provided below. The focus for this question is on the sync-over-async code and method of registering the , but remarks for the other code are welcome too. Container configuration 

A user first has to choose between Red, Blue and Green. Upon selecting an option, additional form elements are displayed, depending on the choice. For Blue, a Date and Font are required. Currently, there's no need for a third level, but who knows what the future brings. In order to represent this data, I've come up with the following model (after many attempts). 

I understand his argument, but the code is harder to read and there's a higher chance on bugs when doing date/time calculations without using date/time objects. I also can't cast it to a in the query because I'm using LINQ to Entities. Which method is the better one? 

I'm using s for hard-coded choices, so I can make decisions based on the value. s come from the database and do not matter in the programmed decision flows. This works, but I can't help but feel like this is an ugly solution and I'm worried about future modifications. I've never had to make something like this before so I can't make decisions based on past experiences. The UI design is more or less set in stone, unless strong arguments can be made against it. (I'd need to bring them up to the designer and project manager.) 

This is a fold, not a scan. A scan produces something with the same number of elements, and change the elements. A fold produces something new. 

Looks ok. A is a more interesting way to do this, since you can then auto-close the resource. There's one thing I took an issue to: 

As to the objection: in idiomatic Scala, you don't use . If there's some API which might return you a string, then, at that point, you turn it into an , and handle the elsewhere as needed. Handling (or even ) at the method is misplaced. 

That is, if used as you did. I'd make it an instead, and initialize it at creation. I'm not sure would help you here, but might. I just don't think it is a particular good fit for BFS, but it might just be ignorance on my part. 

The first two being means this cannot be reused. However, if you turn them into , then will already return a valid iterator. 

The solutions given are simple but have quadratic complexity. I tried to improve upon it, while keeping it strictly functional. The solution I came up with is huge, though some of that resulted from breaking it up into smaller pieces for readability. While it is much faster, I'm not sure if that's due to an improved complexity, or just better heuristics detecting when no more palindromes are possible. I feel like it could be improved, perhaps with some Scalaz tricks. I see a couple places where I could remove some code by using an Scalaz abstraction, but not enough to be worth. On the other hand, I'm not particularly familiar with Scalaz. So, here it is: 

If I remove the call to , the running time is ~75ns. If I remove all the the argument parsing and just return the value 0.0, the running time is ~72ns. I did a few more tests to confirm running times and Python's overhead is consistently ~75ns and the function has running time of ~150ns. 

You can decrease Python's overhead by parsing the tuple and creating the return value manually. Try changing these portions of your code: 

Disclaimer: I maintain the gmpy2 library which also provides arbitrary-precision arithmetic. includes fast integer arithmetic based on the GMP library. If is not installed, uses Python's native integer type(s) for computation. If is installed, uses the faster integer type. You didn't mention if you have (or , an older version) installed, so I ran one test with your original code, , and without . The running time was ~91 seconds. With installed, the running time was ~63 seconds. The rest of the examples assume is installed. Your code include superfluous calls to . Since is already an , the result of will also be an so the call is not needed. If I remove those calls, the running time drops to ~56 seconds. You import from both and . and replace the functions imported from . But you are still using . Numpy can be very fast but only when uses types it natively supports. If I remove and change to , the running time drops to ~48 seconds. Here is the code with all the changes listed from above: 

Updates Without any changes, your code takes ~340ns on my computer. Changing the argument processing and how the return value is created decreases the running time to ~295ns. Replacing with multiplication didn't change the performance with my compiler (GCC 4.8.2). Changing the exponent to a non-integral value significantly increased the running time so I assume constant integer exponents are optimized by the compiler. Next, I simplified the conversion of the numpy arrays by checking that the objects passed are numpy arrays. This avoids creating new objects. I also assumed that the data type is a "float64". Extra checks could be added if needed. With these changes, the running time is ~220ns. Code is below: 

Scala has an unfortunate overhead compared to Haskell to do these things. Also, Scalaz will be able to do a bit more in the next version, but this works with 6.0. The gain with Scalaz is not, however, legibility or conciseness (in this code, anyway), but of composition. For instance, in the current Scalaz we can abstract most of the body of like this: 

I wanted to know how efficient all that set manipulation really was, so I benchmarked it all. My solution is two order of magnitude faster than the one in the question, and three than the accepted solution for the greplin input. Since the big-Oh is different, this would change depending on characteristics of the input and input size. 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

One good technique at eliminating vars is recursion -- it can certainly be used in this example. Alternatively, you can identify a common pattern, such as fold, traversal, etc. For example: 

Ok, I'm changing the answer now that I understand what you are doing. The main problem here is -- while Scala people, in general, don't mind special operators, they don't add operators just because they can either. You can replace with the existing just by adding to any one of the terms. Views aren't often used either, and it's important to have a very good understanding of how they work if you are going to use them, and it's not that easy to gain performance with them, since the machinery they use to support non-strictness is quite heavy, and not everything takes advantage of it. For example, will create a new collection before and are applied. Views can gain when you have many mapping/slicing steps, and few elements of it are ever used. Most of the time, iterators will gain you much more performance, at the cost of the mutability problems iterators have. If you want to reduce the number of times you iterate through the list of proportions, there's at least one place where you can simplify: