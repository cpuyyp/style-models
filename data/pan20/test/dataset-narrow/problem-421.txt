I have to agree with sehe, this is well written. Just a couple of recommendations for maintainability. Prefer standard algorithms The immediate things that come to mind is the opportunity to use standard algorithms in your functions. could be written using . e: Unfortunately, this solution only works if you had a container (not ) that specialized the various functions like a that processed 64 bits at a time rather than 1 bit at a time. Always initialize variables 

Who needs to know about s existence? In this context, is purely an implementation detail of the structure. Users do not need to know that exists, so like any good spy engineer, only expose information to collaborators users on a need-to-know basis. Make a nested class of . 

If I am going to provide "safe" versions of the traversal operations , , and , I should at least meet those minimum requirements. Implementation 

Defining the interface is the most important step when designing a function. Doing things that are different or surprising will confuse and annoy users of your functions. The name of the function doesn't match what going on in the body of the function. Copy is a non-destructive action on the source. When you copy one item, you have two of that item. What you are actually doing is copying a subrange then destroying the subrange source (effectively moving the subrange). Whenever you are writing functions, prefer to write parameters in the order that replicates similar functions from that language's standard library. Most users of your code are more than often going to use standard library code than handwritten code. Having to deal with alternating order of parameters is annoying if your function wants destination before source in the arguments while the majority of code is using source before destination. What does really represent? Semantically it refers to any type . As a user, I would have to look into your implementation and dig through the documentation to figure out what exactly represents. Be explicit. Expecting a container type? Call it (or if your coding standard allows localized shortened variables). Specify immutable variables with (or for literal types). Must the types for and really be the same type? Perhaps it would be better to loosen that restriction to the underlying types being convertible. Your return type narrowly converts from to . 

You are reinventing a lot of old and new library features. Internally, with could have removed the need for the private functions. If you like living on the edge, look at the proposal for a generalized . As Loki mentioned, you likely wanted . If you are interested in moving beyond explicit piecewise argument chaining, currying might peak your interest. See Kari. 

Member functions that inspect but do not mutate the object should be marked with a suffix. Mutations can happen internally through direct access and externally through references, so marking functions as (read-only) prevents mutation. Strive for -correctness. Return by value is inefficient and doesn't allow for external mutation of the value. As stated in the review of , you don't want to return a dangling pointer. The simplest solution is to delegate construction of a static variable to be referenced. 

Do not use directives or declarations at the global scope of header files. Doing so pollutes the global namespace of anyone using that header which may lead to symbol collisions and ADL misbehavior. 

If your return type is an , will Ackermann values overflow if \$m < 4\$ and \$n = 13\$? Are there Ackermann values that don't overflow when \$m = 4\$ or \$m = 5\$? Consider what actually is computable and throw an overflow exception for values that are not computable. 

If is not found in , shouldn't you just return ? If you do remove the first occurrence, you could have up to 3 possible allocations here. Consider reserving a buffer first then copy the two substrings. 

A source file should be self-sufficient in providing the definition of every symbol used. Some implementations may include the library for you ( including , but that behavior is neither standard nor portable. requires . 

Specify for immutable variables. self-documents that a variable should not change values in the current scope and any accidental modification to the value is detected at compile time rather than run time. Prefer enumerations to represent sets of related named constants. Avoid magic constants as they are difficult to understand and may be overlooked. Prefer symbolic constants to give values contextual meaning. 

If you pass zero arguments, nothing is evaluated. If you pass in arguments, they are each forwarded to the single argument helper. You should be aware of the following with this method: 

If you have to use a comment to explain what a member is, you should rename that member. Also, consider the actual type these variables will represent. They are sizes and sizes are always positive. Either go with or allow architecture flexibility (if needed) with . 

Does case-sensitivity have anything to do with your stated goals of calculating and serializing the frequency of characters? It depends on the context in which this function is used. Case-sensitivity isn't always required. If you really want to provide a mechanism for case-insensitive frequency generation, consider a toggle parameter or another function that transforms the input then calls this function. 

Do not abuse directives and declarations. Importing everything from a namespace into the global namespace causes pollution which could result in name collisions and ambiguity for the compiler (an imported function is found to be more viable even if not correct). 

Initialize variables as you need them. C++ does not impose the same restrictions as C89 did. You can avoid two-step initialization by passing the file you want to open to the constructor. 

Don't expose implementation details. is an implementation detail of . There isn't any reason library users should know how you implemented your Binary Search Tree (BST). 

You can write a non-owning read-only adaptor. The underlying container is a protected data member of the Standard Library container adaptors. 

You won't be able to parallelize it using task parallelism while doing more comparisons and utilizing more space. Just have your two calls work over the ranges and . 

Define and initialize member variables in the order of member declaration. Member variables are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order in the constructor initialization list just makes the code confusing because it won't run in the order you see, which makes it difficult to find order-dependent bugs. 

Don't try to return both error codes and actual representable data through the same return variable. A library user may be using in their data set and a call to may result in some user-code believing some data was actually removed. Decide whether you want to inform the callee of success or failure and don't bother returning data from the list. If the callee really wants the data, they can copy it themselves before deleting. 

Depending on the length of and the value of , this could result in more than 1 allocation. Consider reserving first. Careful with your spacing ( vs ). Since you are just looping until is , your conditional could simply be . 

This works fine if you have a number you want to grow/shrink. However, you could generate the value 1234 based off the current level of recursion you are at. 

The problem asks you to print words beginning with consonants or vowels. You've assumed that words can only begin with only those two, but what about words that begin with a digit? A symbol? 

I was looking at a few profiles this afternoon and noticed a few users had plenty of open questions. This led me to wonder which users actually had the highest amount of questions with unaccepted answers (both in size and percent). So with all the hoopla I kept seeing in the 2nd monitor about SEDE queries, I decided to try my hand at writing one. 

If you've measured and multiple allocations are slowing you down, calculate the string length of your result first, then fill it with the characters. I highly recommend you watch Andrei Alexandrescu's Fastware talk he's been giving for the past few years. He covers this exact topic of converting integers to strings using specific optimization techniques. 

Say we want to the maximum value of . For the built-in integral types, we can construct them with the value . Constructing a with a value of only sets the low bits. You should check to see if is negative and set the high bits appropriately. 

Smart pointers are fine for ownership, but do you really need a to represent its structure? coupled with a non-owning pointer (raw pointer, C++17s ) can represent the ownership abstraction for a doubly linked list. Be aware of how smart pointers behave with the compiler generated operations. With , the destructor recurses \$O(n)\$, which could consume the entire stack. 

In this context, all of your data is set to constant initializers, so you can just use the compiler generated default constructor. You can explicitly default it (uncomment above) or implicitly default it (delete the commented line). Note - The default constructor is only implicitly auto-generated if there is no other user-declared constructor. 

Did the user provide ? Validate your preconditions. Was the regex pattern a valid expression? throws if the provided expression is invalid. You should catch it and notify the user failure occurred. 

General design notes - Utilize the adapter pattern. I brought up the rule of zero earlier (If you can avoid defining the default operations, do). How could we accomplish that with a ? Well, a is an abstract data type (an interface) over a collection of data that provides operations on a single end. The standard library provides us a bunch of collection types. We have sequence types that have front operations (, , ). We have sequence types that have back operations (, , ). For the interface, it's very simple. We adapt the stack interface to the interface of a container that supports modifying operations on its back. 

In the event of a item with a duplicate code, the new entry is simply discarded. Perhaps it would be better to merge the two records? 

Just be aware that some coding guidelines utilize this and actually want you to allow for the implicit return of the success case. 

Don't say in comments what can be stated in code. Keep code-related comments minimal and crisp. When something is important and not obvious (unusual/obscure code), clarify through a comment. Don't pay for what you don't use. Unless you require that keys be sorted at all times, prefer using . 

Do you always want to print to ? Consider defining a parameter to take from the caller. Even better, provide an iterator interface and let the user access all or part of the list values. Be aware of what does. If you just want a new line, prefer streaming the new-line character (). If you want to express to the reader you intended to flush a buffered stream, explicitly stream . 

The biggest issue is that it only returns 1 letter/count pair. What happens if you call . Your function returns the pair that is first encountered that sets rather than . If you want to return all of the max pairs, build your count hash, find the max value, then return all elements from your hash that has that max value using . 

What should be the value of ? Prefer non-member, non-friend functions Functions should only be class members if they are required to be members (constructors, inherited functions, etc) or they need access to the internals to your class. Your function is a candidate for being a free function and the implementation is roughly the same. 

The prototype/interface header for this implementation (ie, the .h/.hh file that corresponds to this .cpp/.cc file). Other headers from the same project, as needed. Headers from other non-standard, non-system libraries (eg, Folly, Qt, etc). Headers from other "almost-standard" libraries (eg, Boost) Standard C++ headers (eg, algorithm, iostream, etc) Standard C headers (eg, windows.h, dirent.h, etc) 

Can they point to ? What happens if they do? Your options are either to check for null on assignment/use, contractually mandate not be null (, ), or use a plain reference. 

The use of feels like unnecessary obfuscation. I'd recommend using two variables with descriptive names (like and ). 

Consider specializing on constrained types through tag dispatching (tutorial here). Tag dispatching leverages the C++ language and compiler to select the appropriate candidate function through tags. provides the tools you'll need to test for most of the types. For missing types (like ), you'll have to roll your own or pull from Boost or another metaprogramming library. There are other metaprogramming techniques that can be used as well until C++ implements the Concepts proposal in a future standard (hopefully in C++20). 

Each file should be self-sufficient by including the specific header a symbol relies on. You forgot to remove the and artifacts. You are missing: 

Your guard name is vulnerable to collisions. Append more information and a good differentiator to reduce the chance a collision occurs. 

Requires a single-pass algorithm. Single pass algorithms have special rules associated with them, like only accessing the current element once and only moving forward. Your implementation exhibits multi-pass behavior. 

As Incomputable mentioned, TemplateRex's "How to Implement Classic Sorting Algorithms in Modern C++?" post on SO is a must-read. 

C- aliasing rules only exist in C++ because of compatibility. Prefer to use C++ style aliasing unless you are writing specifically for C. 

Since you are working with as your underlying type, there is no reason to allow the user to reuse an existing . If you were using a type that allowed for infinite precision (modulo available memory), perhaps it would then be appropriate. You take an immutable approach with every other function, so I would remain consistent and remove this setter. 

Virtual Functions should specify exactly one of , , or . Use when declaring a new virtual function. Use when declaring an overrider. 

The Ackermann–Péter function should be tail-call optimized by any decent compiler, so you won't find much improvement with the recursive approach. If you really care for performance, calculate Ackerman values in constant time using the formula's for \$A(m,n)\$. $$ A(0,n) = n + 1\\ A(1,n) = n + 2\\ A(2,n) = 2n + 3\\ A(3,n) = 2^{(n+3)} - 3\\ A(4,0) = 13\\ A(4,1) = A(5,0) = 65533 $$ 

Spacing helps distinguish different language constructs. Consider adding spaces where appropriate (e.g. before the and surrounding the ). You should prefer member initialization lists instead of assignment in a constructor body. You'll get a performance increase from non-POD types, increased readability from the uniform initialization across all members (const/references require member initialization), and prevent common errors (e.g. use before set errors). 

(requires ) provides simple lexicographical comparisons that works at compile-time (unlike s comparators). We can create s on the fly with . 

Follow the Rule of Zero. If you define one of the special member functions (destructor, copy/move constructor, copy/move assignment operator), then explicitly define them all. With in-class initializers, prefer letting the compiler implicitly generate a default constructor. If you require an explicit argument constructor or a conversion constructor, explicitly default the default constructor. Your destructor could save on one pointer copy by using directly instead of . 

Avoid data. If you've ever been told don't use global variables, this is essentially a smaller-scale version of the same problem. You find yourself violating the first three design principles of SOLID. 

Don't just name the guard after the filename. Append differentiators (file path, GUID, date, etc) to minimize the chance of collision. An example 

Using beyond the size of our string returns a value initialized . The rules of value initialization from the standard: 

Other things you may want to consider are recognizing that there are bounds. and must be positive and is bounded to . Indexing tricks on the column value could be employed to reduce the amount of calculations on the diagonal. When a control structure interrupts the flow of a program like does in your program, do not use or . This helps with readability (less of the control path to keep track of and reduces indentation on ) and improves maintainability. Semantically both are equivalent, but in larger codebases, multiple control paths become a pain.