The main things is that your system is much more verbose and harder to understand than simply hard-coding all the calls to superclass methods: 

So your component test really is more of an integration test, not a pure unit test. There are basically two ways to improve on that: 

Presentation matters. It really does. If you would apply for a newspaper reporter position, would you submit an essay where paragraphs would start without indentation and sentences would end without full stop? Any fool can write a program that a machine can understand. A greater challenge is writing code that other people can easily understand. You need to learn how to properly format your code. Google "JavaScript style guide" and follow whichever you like - doesn't really matter, as long as you format your code consistently. Code structure One of the benefits of a framework like React is that it allows you to split you code up into multiple simpler components which you can then compose into other components that perform more complex tasks. Your code does not take advantage of that. Instead it has been written as a single large App component. The same applies for functions. Instead of large function like you should strive to break your logic down to smaller functions. Giving these functions good names, will also allow you to make your code more self-documenting without needing to write a comment. 

Like ojdo has pointed out, using plain regexes to parse something like BBCode is too complicated of a route to take. It would be too long of a task to educate you on building proper parsers, but here's a short simplified example, of how one would go on parsing something like BBCode. First tokenize First off, we transform the input text into some higher level data structure which we can then work on more easily. For the BBCode, let's tokenize the input into begin tags, end tags, and text in between: 

I really think your code is having at least two issues. The first one is something that may confuse your service consumers a lot. The second one is probably a bug. 

"Linearizing" the solution (i.e. getting rig of the recursive calls by using a single loop); Applying memoization, which is recording the cells which are known to be unreachable from the target cell and avoiding further visits of such cells. 

If this assumption is wrong, and you'll have various s that run steps in different order, than your tests should indeed make sure that the prescribed order is followed. Your current code is using the mock that intercepts the method invocation. I think, this is still checking the implementation detail. Instead, I would expose the collection of steps as a read-only/immutable property. Then I could do something like this: 

"Caching" an Observable is by default a singleton in Angular just like any other service (This is thanks to the way dependency injection container works in Angular). This means you don't need to have the class fields as . Make them instance fields instead: 

This may be a bit more compressed at the cost of readability, which I provide as an option rather than recommendation: 

Update 1, for those who are unfamiliar with functional programming. If ternary chaining was that bad, it wouldn't be mentioned Mozilla Developer Network 

Getters/setters in HuffmanNodeObject In my humble opinion, they are not providing any value at all. It's okay to expose the fields (, , etc.) and treat this class as a value type (or a "structure" if you will). This will allow removing the , thus shortening the code by about 50 lines. The class works as data holder and has absolutely no logic, therefore no need to complicate things. I don't think this code change will lead to any noticeable performance gains. 

So you load data for each view, but then you also go through all other views to pass this data to them when they happen to need it. However you don't only pass the data from currently loaded view, but you try to cover all the views (some of which have not been loaded yet). So the first optimization to make is to eliminate this third loop through all the views. Just passing the data from currently loaded view to the views that need it: 

Java doesn't allow you to implement it like that, but you could implement a swap function like that: 

The main problems with the code resides in tight coupling between UI logic and business logic. For example the function: 

Another step to simplify code is to filter out the invalid numbers before doing any calculations on them. helps us here: 

This helper doesn't really help you much in performing a swap. I can see from your pseudo-code, that you'd really like a helper like this: 

And don't take my word for it. Run your JavaScript through an analyzer like JSHint - it will warn you about these and other issues. PS. I think overall your code is very nicely and cleanly written. It just falls short on looking and feeling like JavaScript. 

Definitely. The is already a pretty large component. I'd suggest splitting it into even more smaller components, like: 

loadValues() is rather problematic. It checks for each possible data-attribute and if present overrides the value in . These repeated checks are just duplicated code which could be eliminated by just calling without parameters to grab all the data-attributes. But the fact that it's modifying is a real problem because the function is used like so: 

Your code has a structural repetition. The same cycle is written for every coin nomination. What you could do instead is create a coin registry, and use it in a generalized loop. 

Each invocation results in creating and returning a new unless special measures are taken (like , ...) 

My approach, design, implementation, and performance description Both time and space complexity of the solution is , where is the total count of bits in a bit representation of the integer number. However, I feel there might be some smart approach (or a "trick") that improves the solution. My code basically consists of three parts. 

The other good effect is the reduced code repetition. Move Magic Code into Functions When I see lines like that they look Magic to me. 

Little note. I think, that from the "big O" point of view we haven't improve the algorithm. Since is \$O(n)\$, the performance of the entire solution is limited by the (which is probably \$O(n * {\log n})\$). The way we're potentially improving solution is by making sure that the constants in our "big O" cost are as small as we can achieve. Nevertheless, if we'd put the performance as top criteria of the solution, I'd learn as much as I can about the real data being processed; as well as conducted a thorough performance test. In real life scenario, however, I personally never put performance above readability, because I believe that lack of readability is eventually the same thing as lack of correctness ...and correctness is almost always more important than performance (few exceptions are known though). 

If you are not planning to add the function that disables "moving" of an element, you may even not need a local variable holding the reference to a : 

Follow the You ain't gonna need it principle: Don't add methods/properties to a class just-in-case. Have a clear purpose and clear plan how you'd expect your class to be used. Unless you're really sure, it's better to leave it out. Less is more. Design first for your own specific use case. Leave out everything you don't actually need. Then try to use it in another project - see if it works as is, or do you need to improve it somehow. Only after having found it useful in several places of your own, consider sharing it with a wider audience. 

Regarding a plan to implement them recursively, I would suggest you instead look into implementing an algorithm like merge sort or quick sort, which are recursive in nature. 

This code looks needlessly tricky to me. It's not immediately clear what kind of values are stored to the state. I would just write it out explicitly: 

But all the places where method is used, could actually use the method instead. This should make one realize that this whole Tile class could be completely eliminated and replaced with a plain boolean value instead. Other smells 

Business logic or not I guess the general dichotomy is View logic v/s Business logic. So, to decide whether something is part of your application business logic, try to imagine your app having a completely different UI, like a command-line UI. Would the logic still need to part of your application with this new UI? If yes, then it's likely your business logic. Email validation and checking if user is logged in, seem to me as part of business logic. Controllers The role of a Controller is the most vague one in MVC world. That's why there exist several Model-View-* patterns: Model-View-Presenter, Model-View-ViewModel, Model-View-Adapter. To answer your question: 

About Constructor It is considered a bad practice for a constructor to have side effects for multiple reasons. You can browse numerous resources online on this subject. Here are a few whys: 

Here's what functional style might look like. Unfortunately, it requires index recalculation, and overall more verbose and complicated, even though it tries to go the ".some()" way. :) I believe it's one of those cases where imperative code keeps things simple. 

UPDATE: You can run performance tests I prepared based on various code samples from the answers to this question: $URL$ When I ran them, I see that my code is second best performing. The best is the one by @Kevin Cline (up voted!). 

@demrks please take a look at the code below. It's a result of multiple refactoring iterations. While the original code does the job, I find it very hard to read. Hopefully, you agree that the improved version reads better, even though there's very little new in it. Many developers including myself believe that readability is a super important aspect of coding because it directly affects complexity, and thus correctness of the code. Here's the list of techniques I applied (in order of importance as I understand things): 

Naming Name things properly and do not abbreviate words. is definitely not a short name, but it's describing what it does with 100% precision. Similarly, original transformed into . It may be funny, but first seeing I thought I'm reading code in Spanish. :) Please never never never use the , , , and similar. They are absolutely meaningless. Yes, the other dev "may understand" it, but you don't want anyone to guess what the code does. Spell things out, in most of the modern editors it's a matter of hitting . Temporary variables constants Do not hesitate to introduce reusable temporary constants with descriptive names. They make cryptic conditions or relay the intent of the writer. Avoid branching when possible, or minimize its "scope" An unnecessary if-then-else for processing array/non-array orders may be generalized, if we normalize the array first. Was: