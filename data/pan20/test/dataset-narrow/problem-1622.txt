Will be a toolchain targeting the more common ARMv7 architecture. It probably does not properly support the ARMv6 Broadcom SoC used on the pi, but you could try by adding: 

I have an I2C FM transmitter for the pi; it has a 3.5mm stereo jack for input. Everything works great -- I attached a short dipole antennae and get clear reception for at least 25'. However, if I use the same model B pi to provide the input, there's a slight steady noise; sometimes this rises and falls in pitch/intensity. I've heard it do this at precise one second intervals, presumably synced with another device on the same I2C bus that receives updates at that rate. However, usually there's no such correspondence. The noise is there whether or not the pi is actually playing sound, although it is not very noticeable if it is (i.e. the relative volume is very low). If I use two pis, one powering the transmitter and one providing the input (or just use some other device for input), it's crystal clear. I've tried various power supplies, which did not make any difference. Is there anything I can do to filter or correct this? What's it caused by? 

In addition to , suggested by joan, you can switch over to root completely, if necessary, with . No messing around with the finer points and gotchas of . You'll need root's password, but after that, until you , you're root (in case that's not clear: you need to call to get out of the root session). Note if you are in a GUI terminal, you won't be able to start other GUI apps. stands for "switch user" and it is by default to root unless you specify something else (e.g. ). It does not apply to anything else on your desktop, etc., just the command line where you switched. Part of the caveat about not using root is to minimize the number of applications run that way. Thus, unless you need to, don't start an entire GUI desktop as root, then run a web browser, etc. Any security hole in the browser or DE now has root access. However, as long as you pay attention, using , or logging in as root via , is fine. Again: just don't use it for anything when it is not necessary. The biggest danger is really just that you do something stupid, but if you intended to do what you did and you needed to be root to do it, then the latter fact is besides the point. To be honest, I've been cavalierly logging in as root since I started with linux in the late nineties, and it has never caused me any grief that didn't have to do with me doing something incorrectly. As long as you are careful, pay attention to documentation, make an effort to keep the system secure, and generally use your head, it is reasonably safe. 

This is in C, and I'm not promising it will get you what you want (see joan's comments below), but it does meet this criteria: 

If you want the output printed to console, you are going to have to set that up. There are lots of things started at boot, and they can't all print to console or it would be an interleaved mess. So, just as none of them can hog the foreground without special arrangment, none of them get to hog the console used by the kernel and init (on current versions of Raspbian, init is systemd). The default for anything written to such a process's or is systemd's "journal" (i.e., the system log); see "StandardOutput" in . That option can be set to "console" (note it must be combined with something else); this may be what you want if it is only a short message every 4 seconds, but it means you will have to start the process via systemd (which is actually the best way to start a boot service anyway, but involves a little more work than or ). However, the console used by kernel and init is not the only text terminal. I'm presuming you are running sans GUI (i.e., "text mode") but not headless (i.e., you have a screen and keyboard). In that case, you could create a shell wrapper and redirect the output to one of the other virtual terminals (VTs). These are where the logins you can find via Ctrl-Alt-F[n] are, where "[n]" is 1-6. Note 2-5 will look the same (except for the number shown), since no kernel or journal output is going there (except for supposedly important warnings). There's actually more than 6 VTs, but only the first six have a login running. That won't stop you from writing to them but it may be tidier to use instead. So you could create a shell wrapper like this and put that in (or it's own script and start it however you want): 

Beware your hostname is not necessarily . There may be some difference in the content of the second message, but this is the point at which the system logger (1) copies in the stuff you can see with , which is the kernel speaking. Kernel timestamps (e.g. ) are in seconds (so have microsecond granularity); the date/clock timestamp is added by the rsyslog itself so will always be present whereas the kernel ones will only be for messages from the kernel itself (hence rsyslog's "start" message doesn't have one). Since that indicates the last boot, you are looking for the messages immediately before these two lines. For a normal shutdown, the last one should be something like: 

UART serial communication at a fundamental level is not master/slave based like say, USB or I2C is. It is about as simple a protocol as can be imagined and simply describes how groups of bits (usually, 8 of them in a byte) can be communicated across a wire. There must be a previous arrangement between the two parties about some of the details (including the speed) in order for this to work, or else they will just interpret random rubbish from each other. 

1. Presumably it's accomplished by tweaking "argument zero" in the call at the end of ; I mention this because you can see login shells with ; they're the ones. 

1. X86(-64) is by far the most widespread instruction set architecture (ISA) for contemporary PCs (desktops, laptops, inc. Apple machines). ISA's are used in hardware implementation, meaning they are carved in metal for specific physical systems. Software is compiled to machine code which corresponds with this. Software compiled for one ISA is unlikely to be compatible with another. 

Notice there is a bit of a discrepancy here: the "Start" and "End" sectors match the original partition table, but the total size in the stats up top is only 102 MB! This is because I actually used as the param to because I did not really want to bother with a 12 GB copy (notice also "total 200000 sectors"). The reason the table at the bottom does not reflect this is because fdisk is getting its information from the partition data copied verbatim at the beginning of the image from the beginning of the SD card, which, as I mentioned in the second paragraph, is vital to maintain. If I had (properly) copied the rest, the numbers would be copacetic and the image would be viable. Give that a try. :) 

That's irrelevant to execution order. It is used to determine in what context the service should be run at boot; probably covers any of them. I think is more appropriate but that is just a casual opinion and in any case, again, this is about whether or not to run it, not when to run it. 

SELinux requires kernel support, and the default Raspberry Pi kernel does not include it. You can check the configuration this way: 

Here's something which takes a different twist on , which has a standardized format based around setting shell variables, meaning you can it and use them. First have a look at the actual file to get the idea, then consider: 

The #1 problem that plagues people here is believing that Raspbian (the "operating system" that is predominantly used on the pi and recommended and distributed, with tweaks, by the manufacturer), was written from the ground up for the device the way that Android was created, for the most part, for the devices it is used on. This is false, not because anyone involved is lazy or dishonest, but primarily because of the economics of scale (it might also be considered totally unnecessary, just as Dell or Toshiba do not produce operating systems for their hardware but instead produce hardware intended to run existing operating systems). I used quotes on "operating system" because it implies, e.g., that there is some great difference either in technical structure or end user functionality between Raspbian and the much more long standing "operating system" on which it is based, Debian. "Based" as in very very closely based. The differences are primarily superficial, the way that you might live in the exact same model of home as your neighbor but have painted the walls differently and put different furniture in the rooms -- something it might take a few people a few days to swap back and forth convincingly, as opposed having to knock one house down and build it anew in order to replicate the one next door. Of course a normal, modern computer running Debian is to the pi a bit like a mansion is to a bachelor apartment, which makes a big difference in terms of end-user experience but little or none in terms of operating system structure. I used quotes in referring to Debian as an "operating system" of its own as well because it is a distribution of GNU/Linux, colloquially "linux", another problematic term since Linux is actually just an operating system kernel also used, e.g., by Android as well as various obscure embedded platforms. Most people have at least one linux based device in their home and do not not know it (clue: they are probably attached to your television and/or the cable that connects your home to the internet, and often run atrociously designed end-user interfaces on top of the kernel). Those are probably more truly individualized operating systems than say, Debian is from Fedora, or Ubuntu and so on. Although common parlance has come to refer to these as different "operating systems", this is a little bit like saying that Bob's Samsung Galaxy phone runs a different operating system than Sue's HTC One phone and that Ralph's Google Nexus phone runs yet another different operating system. In a sense this is true, but for the most part, they are all variations on the theme of Android. Fortunately, in the consumer smartphone world, most people are aware of this. They know that while Samsung and HTC may maintain and run slightly different versions/customizations under the conceptual umbrella "Android", that conceptual umbrella is in fact what primarily determines most things about the software on the phone and further, that generally speaking application software is easily inter-operable between them. Hence, there is not a Samsung Playstore and an HTC Playstore and so on. There is a Google Playstore for Android. Unfortunately, this is not the impression implicitly received by many new (and even long running) pi users, who incorrectly believe there is something more significant than paint and furnishing to distinguish Raspbian from Debian, or, worse yet, that the primary use case for GNU/Linux is the Raspberry Pi, so really they are somehow synonymous with one another. So to be clear, the conceptual umbrella for the open source operating systems used on the Raspberry Pi is "GNU/Linux" or more informally (and confusingly), just "linux", with the exception of a few things like FreeBSD, which I believe also has a pi port. Why this is a Serious Problem This is a serious problem because it then leads people to search online for information such as the "raspberry pi SD card software stack", which will return to you (I'm only going to guess) an incredible pile of assorted garbage. This is not because there is no such thing, but because for the most part, the context in which this software stack exists is on a much, much larger scale than that of the Raspberry Pi. As in at least several orders of magnitude larger: Although there might be 4 or 8 million+ pis in the world, mostly running linux, there could easily be more than a billion other linux powered devices in the same world. Keep this in mind when you search for things on the internet. You may end up concluding your searches by including the term "raspberry pi", but it is generally foolish to start out that way believing you are going to get to skip some steps instead of going down some random rabbit hole. With regard to the SD card stack on the pi, it's the SD card stack from the linux kernel, the same kernel used on 30%+ of the world's internet servers, 95% of the supercomputers, etc. Of course, those things probably make little or no use of SD cards, but vastly outnumbering them are the laptops and desktops running some form of GNU/Linux much like Raspbian, albeit in a somewhat fancier package as they tend to run on much higher performing hardware than a $35 dev board, and may account for a few percent of that market (so still outnumbering the pi by an order of magnitude) and then of course all those Android devices, almost all of which do use SD cards (and now we are talking another order of magnitude, well into the hundreds of millions of units). If we peek into the vanilla linux source, the top of the stack implementing the SD "protocol" (see Millway's answer for a dissection of that) is probably in (where "MMC" stands for "multi-media card", which was a term used before "SD", i.e., "secure digital", became the industry standard). Finally, the Answer You Were Looking For... The Raspberry Pi, like Android devices, does not run an unadulterated vanilla linux kernel. It includes various low level bits and pieces used for hardware only on the pi (or rather, predominantly, it is not an exclusive limitation), namely the Broadcom SoC at its heart. This shows up in the subdirectory of the directory, which in the pi branch of the kernel contains a few additional entries such as: