As a player it gets really annoying at times when the AI can see things it shouldn't be able to see. I still one game that was otherwise quite good but the AI was all-seeing and thus could do some very nasty things with artillery at times because of that. 

I don't believe you can do this with simply loading certain layers because of the problem of transitions. My inclination would be to store some metadata with each chunk: 1) Is the block entirely air. If so there's no need to render it. 2) For each face of the block is it opaque. An opaque face means you do not need to consider the next chunk. (Note, though, that depending on where the chunk is there could be as many as three faces involved--a chunk must be rendered if any of the three are not opaque. I suspect this is best pre-calculated--render so long either b1 is visible and has a non-opaque face f1 or b2 is visible has a non-opaque face f2 or b3 is visible has a non-opaque face f3.) There are unfortunately over 7000 chunks within your 12 chunk sight range. However, I would expect few locations to have more than three vertical chunks that actually need to be rendered using this approach which cuts the chunk count to probably no more than 1500. I would apply the same sort of logic within a chunk--when you load a chunk calculate what junctions are transparent and what junctions are opaque touching opaque--you only need to actually render faces where someone can see them. (Note that in Minecraft you have three types of block--transparent, opaque and vision-altering--glass, doors, fences etc. You can only skip transparent-transparent and opaque-opaque.) 

In the worst case it looks to me like you're going to use more memory this way. Picture a snake that goes something like this: ‾|_|‾|_|‾ as much as possible. There are a few spots at the edge of the screen where it must go straight for a few squares but those aren't enough to overcome the higher memory storage per location unless the world is small. While the average memory is lower what difference does that make? I would say the "naive" approach is the best one. 

The problem here is that you have an accelerating missile--the simple math doesn't work. A simplistic answer is that the position of the missile is 1/2 * acceleration * time * time. (This is evident if you understand calculus, it's hard to follow otherwise.) However, this won't produce the right answer because in reality your missile is accelerating in a jerky fashion (an update each frame), not smoothly. It may be good enough, if it's not I would simply precalculate the missile's performance and refer to the stored results when you need them. 

It sounds to me like your problem is that you are blindly applying gravity without considering the effects of whatever the character is standing on. If there is something below you there is no meaningful effect of gravity! Furthermore, you don't want to simply not move if a collision results. Consider what happens if you jump off something--at the point the next movement frame intersects the ground you're frozen in space for all eternity. Instead you want to stop the character (or perhaps only zero out the velocity in the direction that caused the collision) at the point of impact but allow them to move that far. Simply stopping the movement only works if you don't care about exactly where you are. (And, yes, that can happen. I did a simple 3D first person journey through an environment once--more an experiment in 3D than a real game. I implemented collision handling by zeroing any velocity component that would take you within .1 of a wall. The result is how closely you can approach the wall depends on how fast you impact it, the guy heading straight for it will be stopped sooner than the guy approaching it at a very narrow angle. Without a debug display showing the actual numbers you would never know, though, as being first person you can't tell exactly how close you are anyway as the point of contact isn't in your field of view.) 

Do you even need to solve this? Hohmann transfer orbits are SLOW--1/2 the orbital period of the outer body and they also require a proper alignment of the planets to work. Do you really want to limit players to such motions? And if you're doing that you are obviously using some sort of jump drive to get to the other star systems--why can't you use that within a system? If you have any sort of continuous thrust system of non-trivial power you don't need to do such fancy orbital calculations. Instead: 1) Figure the velocity change needed between the bodies. This is both orbital velocity and the energy needed to move to the new orbit. 2) Figure the distance between A and B at their current positions. 3) Adjust this for the burn needed in part #1. If you're going outward figure an extra burn at the start for the velocity change, if you're going in the extra burn is at the end. Subtract this distance from the distance between the planets, add the time needed to the total time. 4) Take the remaining distance, divide in half and figure how long it will take your rocket to do this. Double the result. 5) Add the times involved, figure where the target planet will be after that burn is over. If it's moved too much use the new location of the planet as your target, redo the calculations. This will rapidly converge. Yes, this isn't up to NASA-spec but it's plenty close enough for game use. 

An idea I have considered but not yet tried: Draw an offscreen image the same as the real image but no textures etc. Simply draw your objects, each object in a different "color" where the "color" is really just an object number. To figure out what's under the mouse you simply look at the color of the pixel on the alternate image. Of course this is doing a lot of wasted work but it's the GPU doing it rather than the CPU and it's sure to resolve things by exactly the same rules. 

1) Scripts are often much easier to modify than code. 2) Scripts are often field-modifiable. This permits modding the game. 

Unfortunately, the math here gets hairy. FxIII's answer is fine for the general case of a falling object but you are talking about a rocket--and rockets burn off fuel. I have seen code that does it but it was completely undocumented and I never managed to figure out the math behind it. Unless you're CPU-limited somehow I wouldn't bother and simply brute force it--FxIIIs approach applied on a quite short timescale and adjust the thrust (or fuel use if you figure the rocket throttles back as the fuel burns off to maintain the specified acceleration rather than the specified thrust) between each iteration as the rocket burns off fuel. 

As has been said, treat the moves as a tree. However, since you say C++ you're running off local storage and thus I'm going to propose a different answer than trying to write a rating function. Instead, as has been said, the game has been solved. There are only 4.5 trillion possible boards and the fact that the AI doesn't want to make stupid moves takes out a bunch of them. Given some precalculation combined with modern processors this makes me think it should be possible to make the theoretically perfect move in all situations. To do this you'll need to start out processing EVERY board on your machine. This will of course be quite slow. Save the first 11 moves of this tree in a form of your response to each of his possible moves. (Note: This can be packed into 20 bits per move, the resulting file is in the tens of megabytes.) I think this puts you far enough into the game that you can now brute force it faster than a human would play. Code optimization will matter! 

How about multiple chunks per file? You say your chunks are 2048 x 2048, how about putting 16384 x 16384 in a file. Flag which ones exist somehow so you know whether you need to create it.