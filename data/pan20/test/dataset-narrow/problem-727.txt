How to approach this in a game? Well, you have some of it already. The and are fine. I would say that the top few items (resort, mountain, starting point) are a series of text prompts. What you really have is a graph. When the player starts, it is at a central node on the graph. This is the "big decision" that will decide the rest of the decisions: "What resort do you want to visit?" From there, you can change resorts (which is slow and time consuming and expensive, but might be necessary for game play, or might be a "level up" feature- you can only change resorts as you get better). Or you can head for different starting points by taking different ski lifts. Or you could head for a different mountain by taking a van over, then a ski lift. Etc. Finally, you get to a starting point, pick from a small set of runs. You reach a point at the end if your run, pick from a different small set of runs, reach a different point at the end of that run, etc. Eventually, you reach an ending point - the bottom of the hill. You can call it a day, or go back up for more runs! I would reverse this for climbing. There are some places to start, maybe some "trails" that take you to the bottoms of a few routes. When you climb up, you reach a point that you can change routes. Then eventually you reach the top, or some other ending point, etc. Update: So you have a climber traversing this graph of starting/middle/ending points by various routes. So the nodes (points) have various weighted edges (weights = difficulty, cost, etc.) and they all have names. Your climber will need some kind of "current node" or "current location" indicator. Your graph of routes should have a common "node" class, with various "routes" connecting the nodes. 

First, you need to realize that Python is not Java. Python is a "consenting adult language." (Watch Raymond Hettinger's talk for more.) What that means is the bizarre fetish for mutators/accessors/getters and setters that permeates Java and C# doesn't exist in Python. You don't need to write: 

But you have to be wary of alignment requirements: some CPUs cannot read misaligned data, or if they can perform the read they do it at a high performance cost. For this reason, most code is written to do bytewise assembly using shift and binary or, with the (frequently incorrect) expectation that the compiler will figure out and replace the operations if type punning is a viable alternative. 

Next, you check if the company is already in the database. If it's in the database, great. If it's not in the database, you create it. If it's in the database more than once, you raise an exception. I don't think that last case is really the job of this script. That condition - that the company name should be unique in the table - is properly the job of a database constraint rather than a "create users" script. (It's not even a "create companies" script, which would at least be on-topic.) So I'm going to suggest you ignore that case. Let's just have the script either create the company if it doesn't exist, or use the existing company if there is already a record. One thing you don't do, is check if the company name is empty. I don't know if this is a valid case or not, so I'm going to leave that alone (after bringing it to your attention). Our first step will be to separate out the company names (because there could be M:N of them versus the people), and the email addresses (because that is your key, apparently). Let's put the company names into a set, in order to make them unique. And we'll put the entire record into a dictionary keyed by the email addresses: 

This is a pain in the ass to maintain, so you only do it when you are done changing the algorithms and stuff, and you want to squeeze out that last 10% of performance. Note also, this is strictly a c-python thing. : The big cheese. The head honcho. The place where ... all the time ... is spent! I'll start out by pointing out that every time you write a kitten dies! 

Given that the player data is a function of the turn number, there's no reason to pass the player data into the function. Instead, defer the computation of player data as long as possible. Just pass the turn number and board into the function: 

Remember, you are writing code for the next maintainer, not for the compiler. You have this while loop that is unclear: 

and get the correct result. Alternatively, you could store your words as strings rather than lists. This would make it somewhat awkward to manipulate them, since Python strings are immutable. But it would again let you simply say, 

You may wish to add a link pointing up the tree, to simplify the split code. Add an Invariant Write yourself a method (or methods) called . Assert whatever things you find to assert - I think the wikipedia article has some pretty solid candidates. Call it when you're about to exit a public method, and whereever else you feel the need. 

With due apologies to Madonna, there are some places where your code could be more Pythonic. Let's start with this: 

Problems in Your and have some serious issues. I think your instructors have gotten somewhat lazy. I'd suggest that you invite them to submit their code ( and and whatever else they have written) to this site for review. First, there is the problem that this file won't compile under : 

You have too many variables. The is not needed. Also, for testing I would like to see some actual testing, rather than just printing to the console and letting the user do it: 

Because each occurrence of is an expression that is evaluated separately. Which means a new tuple is being constructed, when if you put that into a variable, you could just reference the same variable over and over again quite efficiently. But wait! Because the whole thing is wrong anyway. Why are you iterating over two ranges? Why don't you tell, don't ask your grid class to give you all the valid locations in the grid, in some sequence? Define an iterator for the grid! 

(In fairness, this last example came from the PEP proposing the syntax: $URL$ and see overview page here: $URL$ 

This returns the native array syntax to C, and lets you skip having to code any functions. Finally, I'd suggest changing your function to a function. To me, suggests , which is memory footprint. As we all know, the "length" of an array is . You have two numbers to track: used elements and capacity. In fact, you might want to convert to simply tracking capacity, and let the user deal with managing the used elements. Regardless, neither of those should be called simply because of the likely confusion with . 

Why does one have a space after it, while the next one does not? Anyway, dropping those spaces doesn't make your code "look cool." Neither does setting your terminal to black with a green foreground, or whatever. It makes your code look crowded, and hard to read, and did I mention that I could be watching the weather forecast in Mexico? Maxima! Minima! Noche! There are hundreds of "coding style" guidelines on the interwebs. Your class might have one. Your school might have one. If not, google for one. Pick the first one you find, and follow it - it doesn't matter how stupid it is, it's bound to be better than your existing code because it will be consistent. Even consistent + stupid is better than random. If you're lucky, your text editor might even have a code-beautifier. If not, look for one. Try "code beautifier" or "indent" for keywords. Stop Repeating Yourself I'm a little surprised to have to write this, but you've got essentially the same code appearing over and over and over again in your if statements: 

And this is wrong. Tail should point to , not to NULL. How can you fix this? By adding another condition: when updating the pointer, check to see if the pointer is still pointing to . If so, then go ahead and null it out because you know you have a 1-element list being shortened to an empty list. But if points to some other location, and you're deleting the tail element, then you can set to point to the address of the struct containing the pointer that is pointed to by (Say that five times fast!) Fortunately, the pointer is the first element in the struct, so in C you can assume that the two addresses are the same, and just cast one type to the other. (In C++, with a vtable, the addresses wouldn't be the same. In C with any other field at the top of the struct, the addresses wouldn't be the same. That's what the macro is for! You could subtract the offset, but ... c'mon! This is C! Just hard-code the 0 and move on...) Something like this: