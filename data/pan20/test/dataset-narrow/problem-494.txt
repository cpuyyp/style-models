3. When dividing code into seperate functions it makes for a more readable code, and that way it can be imported by other programs. 

Python program to test ideas Below is a little python program I used to test if everything went well: 

Your double while loop looks silly to me, I think it be more concise to use 1 loop and use a structure within 

First of all, your entire is way over-engineered.. and with the correct standard modules this practically becomes a one-liner Review 

loops per se are not a bad idea, it is just using a loop for this example is overcomplicating stuff. That makes it a bad idea. is awkward because you keep appending that item to the list and refering last element, you could also have stored the range as a variable and keep overwritting it. 

Code suggestions I would use a instead of a dictionary, since it is much cleaner looking and easier to use. When to use a namedtuple! Using the above suggestions and adhering PEP8 I get the following. 

Just a simple utility that logs the pressed keys in Python and takes a screenshot everytime a new PID is opened. ÃŒ got bored at work, so decided I was going to have some fun with this. Made in Windows 

looks clunky as hell! How can this be made beautifull again? Is my general logic ok, or should I have divided the problem in easier to comprehend functions? Any stylistic review is welcome too. 

This post is form a long time ago, but I scrolled pas it, and I think it could use some improvements. I will try to stay in since that is what you used. Review 

Sorry for the long read, but this was actually quite a difficult challenge. That is why I wanted it to share it with this community. Any review is welcome. 

Make it work for both and . use a body. Added a dictionary to map the (no more need for an block) According to the python style guide, functions and variables should be 

Review Yes the first option would be better as memory might become an issue with really long numbers (say you have a 10 million length number). But that implementation could be improved as well 

For timing, see the Time complexity for python You use some expensive operations while this can be done is a single loop 

These are the definitions of the generator functions. This shows the vital functions involved in the analysis process (the process to determine the priority of selecting blank squares): 

initializes the evaluation for the current iteration. The statement called before these is the program's attempt to try and solve the problem purely based on the rule-based procedure, trying to eliminate the set of numbers that can be entered into each square. The function iterates through each bit-field trying to discover the possible elements (values) that can be entered into the blank box. The set of values are then stored as bit fields. This function runs in a loop because, an empty box getting filled by a value might help provide enough information to figure out the value in a different box. Therefore, until such a possibility is ruled-out the function iterates. The above process configures the bit-fields, which would help the function to compute the number of possible elements that can be entered into each square. The next function, which relies on the result of the function, computes the which assigns a floating-point value to each square in the sudoku board following the expression and later the function is called followed by the function, which returns the list of all the empty cells, along with its associated priority value. The function sums the number of possibilities across each row, each column and each cell (the smaller boxes, which must also contain values from 1 to 9) and stores them in an array. The function returns a priority queue, sorted based on the priority value derived from the result provided by the other three functions. The final depth-first search is computed by recursively calling the function, belonging to a locally declared instance of the class. The sets the puzzle board for the next recursive call. Recurrence is brought about by calling the same belonging to a local instance of the same class, declared within the function. In what areas does my code need improvement? And how can I improve the design of my code and algorithm? I wrote this code intending it to be Object oriented. How object oriented is it? (I.e.., is there a better way to structure the same solution) And is there a better algorithm to solve this problem more easily? For complete code, please refer this URL: $URL$ 

Be aware of the fact, that you have to take care for the cases, where your vector size isn't a multiplication of thread count. There will be some elements left untouched, but I let this job as a task for you ;) 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

As you can see, I renamed my class to SynchronizedValue, because I find it more descriptive than LockedValue. The behaviour of the class stays unchanged, I only did some minor changes and I want to describe why. In every state of this class, only one mutex gets locked. Even in the move parts, I only had to lock one at the same time. This prevents me from getting into a deadlock. The real important part is in the function. In the last state of this class I returned a rvalue reference, which was bad, because when I really started to move the value from other, outside of the function, the mutex already was getting unlocked. This means a race-condition could occur, which is absolutely bad. To fix this, my only change here is to return a real object instead of a rvalue reference. The second important change is no code change at all. It is also closely related to the function. I am talking about the move assignment operator. While I had to check the self assign in the previous version, I can now just take the value and store it safely. The cleanup, which is the bad thing of a self-move, already happened inside of the function. Thus, it should be absolutely safe to deal with the self-moving problem. Why no noexcept The lock functions of a might throw, this means I am not able to make a guarantee for exception safety, unless I would write the whole function inside of a block, which is never a good idea to deal with exceptions. It is not a mistake to declare a move-assign not ; it just makes some optimizations for some classes impossible. why a and copy ctor That's a good question. While I know, that usually a copy ctor is enough, unless you have to modify the original object, it is here required to make the templated ctor possible. If I delete the non-const version of the copy ctor, everything works fine, unless I try to copy from a non-const SynchronizedValue object. A conversion from to is required; and a templated overloading always has a closer match than an overloading which requires a conversation; even when it's just the to a reference. I played a little bit around with SFINAE, but I got no nice solution for that (there might be a solution; but I wasn't able to make it work), thus I used this easy way to deal with this issue. The problem is, I can't SFINAE the copy ctor, this is the wrong way. I have to remove the templated ctor from the match list when I want to copy; and that's the real issue here. The idea, which someone came up with, was to try this one: 

The program first determines the set of all possible values that can be entered into every blank square in the puzzle board. The possibility set is determined by iterating through the row, column and the block, and eliminating the set of numbers already present. The possibility-set is stored as a bit-filed value for each square. Every blank square with a single possibility gets the number entered into it. The algorithm is repeated from the first step again, until there isn't a square with just one possibility. If there aren't any blank squares left, the current board's state is returned as the result. It chooses a blank square and enters a value into it. The process of choosing the blank square, out of all the available blank squares is guided by an analysis algorithm. The value entered into this blank square is chosen from all the possible values that can be entered into the square. A recursive call to this function is initiated with a clone of the current board's state. Note that the current board state now contains the modification done to it at the 4th step (entering one of the possible values). Steps 4 and 5 are carried over until all the possible values in each of the available blank squares are tested with, or until the puzzle gets solved. 

This Sudoku puzzle solving algorithm follows a brute-force approach mixed with rule-based approach. To further improve performance, an extra analysis step is added, to determine which squares to be prioritized while choosing it to be filled. The priority value is inversely dependent on the number of possible values that can be filled into a particular square. This value is used in computing the priority weight value of each of the blank square that is to be filled. This priority weight value helps in ordering which squares must be filled first. 

The signed integer values from represent the numbers in the Sudoku puzzle board. The value zero signifies a blank-box in the Sudoku puzzle board. 

I had written a Sudoku puzzle solver that accepts puzzle boards, and completes them with the least possible time. Rather than purely depending on brute-force, my algorithm first attempts to fill in the squares that have an obvious solution. And for each square being filled this way, the amount of information increases (I.e.., more number of squares get filled which aids in filling in the remaining squares) which makes the further iteration process easier. Once this method fails (this happens if there isn't an obvious answer to fill-into any of the squares), the algorithm immediately switches over to brute-force search. (Note, the source contains a few spelling mistakes, like the word recursive misspelled as Recrussive. Please ignore spelling errors. Anyway, it has been a while since I touched this code, and this was my first object oriented code written in C++). The basic working (High level view) 

Try it out for yourself to see the difference, and if unclear what is going on you can always ask me 

Using a structure like this will improve the code alot, and adding an AI (or other improvements will be easier after this) Avoid working in the global namespace This point is interwoven with dividing the code into functions/classes, see this link as to WHY working in the global namespace is considered bad. Wrap up your code into a guard. This will make your code be runnable from the command line, while also be able to be imported into other scripts 

I created a new for each file. To have better accuracy I should have merged the frequencies for each file to a new , for instance . And once all files a processed try to break the text. My is redundant, I don't do anything with the frequencies. I could have just return the to yield the same results. 

This could be done in one loop, by tracking if any of the current visited vertex in the dfs, are in either the last or first (row or collumn) Alternative code 

First of all, welcome to CodeReview! I'd like to know what the common best practices are when working on a project 

When I do a the IP of the Attacker is in the route. When I trace the route, and there is not a router device in my route it means an attacker(laptop) is listening on my connection When I the attacker does an , the ARP-table has duplicate values. 

Tests The description is a rather simple one, when pipes are leaking then things become interesting. So here are a few Testcases if you want to have a go with this. 

Ok first make a function to check if a list is in a sequence and if not return the first element where it is not strictly increasing 

Intro I have started a new course (Analyzing Big Data with Microsoft R) and have an exam soon. So I wanted to test my skills, and a nice way to do this was by doing a Kaggle competition Titanic: Predicting Disaster. I managed to get a decent score (80%). You can run this script by first downloading the , and set your working directory. I am using the latest Microsoft R Client. Any review is welcome, but I am most interested in: 

You make your code more self-descriptive. your Socket class Your class suggests an other meaning, than it provides. It should handle the sending and receiving without the need, to specify the explicit. The user shouldn't be forced to pass the themselves. That's up to the class, to provide the correct socket (at least you are holding a socket as private member). Think about that, perhaps your class has simply the wrong name for its purpose. use instead of heap array You are using a heap array as a read buffer. This yields exception errors, and it isn't totally clear (at least for the user of the Socket class) who is responsible for the cleanup () of this buffer. It is never a good idea, to hand back a pointer, and let the user cleanup the stuff by themselves. Instead, you should simply return a . That's clean, smart and has no hidden traps. If the user decides, he doesn't need the buffer anymore, he can simply let it go out of scope and it will be deleted automatically. The problems are even bigger, when an is thrown by any part of your framework, the users code or any other part of the program. If you want to pass ownership, use the provided classes. For strings it's , for every other point it is or . When you think, "returning a char* has better performance than returning a ", that's not totally true. Most of modern compilers can optimize that. You should google for "" (). In it is guaranteed, but in or it might fail. But even in that cases, a simple move of the happens, which is not as bad as it sounds. 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour