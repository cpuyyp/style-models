Program design The main issues with your program is the overall design. I would recommend to study object-oriented programming on beginner level before even picking up C++, or any other programming language. 

And now you'll say "this is not exception handling!". Who cares. If you look at the generated machine code, this will generate exactly the same code as a C++ exception handling program. It will contain the same direct branches. The only difference is that the above program might contain less overhead and therefore execute quicker, with less memory usage. 

My concern is performance. I have not yet attempted any manual optimizations. Rather the contrary... Particularly, I'm not pleased with this part, which is a manually-implemented : 

The truly fastest way is some manner of look-up table, as demonstrated in another answer. Such a table could even be generated at compile time: 

Overall, the code is acceptable and a common way to implement such algorithms. Below I have posted some things to consider: Dangerous programming practice 

You should avoid all of these like the plague! Now, I know your specification says "use recursion". So what a professional would do first of all, is to question if the specification makes sense. In this case it doesn't - there is absolutely no need to use recursion here. Others have given you diverse ways of solving this with recursion. Here is an alternative approach which is efficient, instead of needlessly inefficient. 

As for the rest of the code and overall hardware concerns: this code will be widely ported between various smaller, single-core microcontroller embedded systems. I believe the number of instructions is the main performance concern, then program size. Things like improving branch prediction are likely not a very important concern. 

( please note that naming a variable "str_cat" is very bad practice, I just couldn't resist sneaking in a C programming joke :) ) 

There exists no reason why you need to use pointer-to-pointer here. It is slow and needlessly complex - a complexity that caused a memory leak bug. Simply do . Alternatively use a variable length array (VLA). If you for reasons unknown must use dynamic memory allocation, then do so on a proper 2D array and not some fragmented look-up table. See Correctly allocating multi-dimensional arrays for examples of how to do this - it is likely that your book or teacher is teaching you bad habits here. 

I am using following method to solve N-queens problem for all possible solutions for a board. It seems to be smaller as well as faster than many commonly mentioned method. Also, since it is tail-recursive, it should not create any memory problem on longer runs or with larger board sizes. I tried to implement the method that I was manually trying: 

I get message most of the time (on DrRacket IDE). Sometimes it runs and then it give correct answer (same as on rosettacode page): 

Please see my comments in the code above. Edit: The advantages of above function are: This method uses relatively simple built-in functions: for/list (along with #:break clause) and drop function. It follows the task to be done in an iterative manner within the loop: 

It uses for/list to get items one by one into a list till delimiter is reached. This list is added to final outlist. Drop from initial list those number of initial items (+ 1 for delimiter) and start loop again. 

Following is my solution to Knapsack problem using all combinations of the sent list of items (in Racket programming language). Although it is very short, I am sure it can be improved in many ways. 

One can also use 'named let' loops to add items from one list to a new list, using cons which will reverse the order : 

Following is shortened working code. It is based on simple systematic search & recursion algorithm: read the rows one by one from left to right and top to bottom, starting with first row and first column. If the cell is blank (0 here), try to put numbers 1-9. Each number is checked that it should not be present in that row, column or subgrid. If no such number is found, the loop will return to previous level (previous empty cell) and try next number there. Once a suitable number is found, it is placed at the site and the loop is started again with next column (if columns are over, it moves over to first column of next row). If all rows and columns are done, it means a solution has been reached and the same is printed. One can exit at this time to stop immediately on finding a solution. A separate subfunction is made to return numbers in the corresponding subgrid as a list. A common subfunction to step forward to next site/cell is provided to replace 2 very similar code segments in original program. There is no need for separate subfunctions to get cell value, row or column values since these are short code snippets are are needed only once in the program. 

Overall, the program is fairly well-written and clear. One particular good thing is that you have grasped the concept of private encapsulation in C, by placing the static keyword in all the right places. You also use const correctness for your function parameters. All of that is excellent program design, so keep using it! Below are my comments regarding various issues in the code: Bugs found: 

To set the bit flags in , you'll have to use bitwise operators like shown above, instead of /. Then make a function corresponding to every case and define a common function type. (Since you understand the algorithm, you can probably come up with better function names than me) Write the functions so that they only contain the actual action to take, and not the boolean checks, which we are optimizing away: 

I'm sorry for my bluntness, but this code is absolutely horrible and unsafe. To worry about global variables while using a mess of function-like macros, together with /, is kind of like worrying about the paint of your car while smoke is raising from the engine and the breaks are dead. Apart from that, trying to re-invent the C language is always a bad idea. Mainly because it confuses other C programmers. You can implement exception handling in much safer and more readable ways: 

(To avoid subjective debating and to demonstrate that these aren't just the personal, subjective opinions of a random internet person, I have cited a widely-acknowledged C programming authority as source for each statement made.) 

General advise Never write the whole big program at once. Write a litte bit at a time, compile it, test it, if there is anything wrong with it, fix it. Develop the program a tiny bit at a time. 

I'll only address C programming issues in this answer, not the algorithm itself. Program design and programming practice 

Here is feedback on C programming and style only. I haven't looked at algorithms or performance: Style 

The multiple if statements based on booleans can be optimized in the same way that you optimize digital logic in electronics. Make a logic table like this: 

Expand and Contract (ec) the one Section where multiple Sections can be Expanded or Contracted. Only one Section is Expanded at any given time. (ecp ec paired) 

Check validity of all passed parameters. Then determine the best, most specific and user friendly response. The best user response is to fix the error when possible. If a parameter is missing, add a default. If you had an HTML error on your web page, do you expect it to render? Would you like it if a single HTML error returned a 404 response? If a Browser was that rigid it may not get much use, same goes for your API. 404 is not an appropriate response when the document URL (index.php) is correct. Additionally this will confuse some users as to why. They may just think your server is down and they go somewhere else. Consider using an alternate response such as 409. You want to make it as easily as possible for the user to understand what their mistake was. 404 should be reserved for an error in the URL Also for diagnostic and support issues, use various response codes for different issues and document them for the user. You could use a text header and a message identifying the specifics problem with an error message. 

I would rather see ENVIRONMENT equal to 0 instead of 'development' and 1 instead of 'production' This is so if it is undefined it will equate to zero with . 

And it's not because of all the unnecessary bandwidth wasting white space either. 100% of what? Just by the nature of HTML it is going to always expand to 100% of the content. 100% of the Browser window? Why? If there is not enough content to fill the window, why fill it with 100% of nothing? Your page no Bootstrap or jQuery: Basically I changed the #loginBox CSS from to 

At this point in your code Assert RTS and DTR Then Check Port Status by reading DSR and CTS If the device you are connected to does not support hardware handshaking they may have these signal set to an active state or they may be left unconnected. If these signal are not driven by the connected device, be sure your cable loops back your DSR and CTS to your DTR and RTS. Or use an RS-232 loop back adapter. Keeping in mind the PC is a DTE (Data Terminal Equipment) device not DCE (Data data Communication Equipment) When designing the original PC IBM perceived the PC to be a Terminal to their Big Iron so the logic of DTE and DCE are reversed. 

It seems that the variable can be replaced with a boolean(?), which in that case would make the function clearer. You could then have each function returning a bool and make the caller even smaller: Given , the caller can be reduced to this: 

I am writing a portable library function, which is a generic "remove characters" function. Language standards used are C11 and MISRA-C:2012. TL;DR: it should either remove all occurrences of a specific character in the beginning of a string, or it should remove all occurrences of the specific character no matter where they are in the string. The detailed specification: 

Instead of this, I initially had a call to , which will supposedly be nicely optimized for the specific hardware. The problem with that though, is that both parameters of strcpy() are pointers and my requirement is that I should be able to call "in place". In the special case where the user passes a string with no initial characters matching , I would end up with something equal to which invokes undefined behavior, as it violates the contract with . In order to dodge that bug, I rolled out my own . The above issue is my main concern which I would like some feedback on. 

As others have pointed, out never try to re-invent the C language. It makes the code less readable and more error-prone, for no obvious benefits. Function-like macros in general are incredibly error-prone and dangerous (and a pain to debug), they should be avoided. If you for some reason need to use function-like macros, you need to make them safe, properly encapsulate them with braces and parenthesis. In addition, doing strcmp after strcmp in sequence like this, is very slow and inefficient, growing more inefficient with each "case" you add. This is unacceptable if program speed and random access are important. So as for code review, I'd strongly recommend to forget this whole program as quickly as possible, nothing good will come out of it. The proper way to write an algorithm that stores unknown, initially unsorted and completely random input strings, is to use a hash table.