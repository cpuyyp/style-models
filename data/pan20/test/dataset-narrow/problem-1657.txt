Everyone of the 3 git repos you linked is for a specific component. The tests one constains a full program. You can infer that the Kernel needs patching, as well as some other components, from the first paragraph of the link you pasted: 

Short answers: 1-No. 2-There is a 1.1A polyfuse after the microUSB power connector, so anything trying to pull more power than this (includung the 700mA for the Pi itself) will cause the board to stop functioning. 3-The return pin should be GND. The long version: First things first: there are at least 2 electrical motors in a floppy drive. And if I am not mistaken, they are 12V motors. So, I don't think you will go far using only the 5V power pins as for powering up a floppy drive. The Raspberry Pi, unlike other electronic hobby-targeting platform, has no protection whatsoever in the GPIO or power lines. That alone should drive every project thought to make use of these signals to think about some sort of protection, at least a transistor. You are talking power, motors. You should always use some sort of protection and never connect it directly to the Raspberry Pi. You can use the Pi as a controller, but shouldn't use it as Power Source. Use it to control some power circuit that will source the power you need. That said, according to the the Raspberry Pi Hardware guide: 

I would suggest you check the DS18B20 1-wire sensors, which are digital, and have working kernel drivers. Adafruit has a tutorial on how to get them working. You can use up to 10 sensors on the same pin at this time (this is a hardcoded kernel driver limit, as is using the pin it uses. This tutorial has it right, just follow it). As for reading the results, it is as easy as finding a file with a predefined name pattern and then opening the file for read and parsing 2 lines of content. Using 2 sensors is as easy as duplicating the procedure for reading one. Each sensor will be made available in a different file in the file system. There is no need for any Java-specific libraries, procedures or tricks altogether. Just open a file with a particular name pattern for reading. If you use the same sensor, the filename will be the same between readings, so you only need to find the filename that the kernel driver creates once for each of the sensors throughout the sensor's lifespan. As for an expansion board any that makes pin GPIO 4 (which is P1-7) available is okay. That is the fixed pin number used by the 1-wire kernel driver. The Pi Cobbler from Adafruit is one of the many that will do that. 

Both are explained at its homepage on github. The biggest limitation is that the installer (and scripts you choose to run with it, such as ) are done so on which is a minimal shell with few tools. There is a discussion here on how to take the installer further here. The user "netdesk" explains why the installer by itself is slightly limited, and solutions are explored. Please note the discussion is for raspbian-ua-netinst, not raspberrypi-ua-netinst. The latter is the one I prefer, as it has some useful extra features - the former is the original. But they are almost identical in how they work. My blog article gives one possible solution: it explains how to bundle a file with the installer, and some systemd service files that do the following: 

Beginning Raspbian Jessie (and I presume future versions as well), has been replaced by . So instead, follow instructions here. It will automatically log in as user To quote the answer, create this file: 

The result is that via FTP I can view files in /var/www, but uploading folders or files doesn't seem to work. What am I doing wrong? I've missed out the chown command that was used in the tutorial, but if I did that then lighttpd would not have access to /var/www? 

I want a quick and dirty way to upload files to /var/www and /home/pi via FTP. I followed this tutorial to set up FTP access to /home/pi/FTP using pure-ftp. But how should I then set up a new "virtual ftp user" (as described in the tutorial) so I can upload to /var/www and /home/pi? I have set up lighttpd to serve pages from /var/www, which works fine. Doing "ls -la" in /var shows that /var/www is owned by user and group "www-data". So I thought the following should work: First, make a virtual user "www" for pure-ftp, which will give access to /var/www: 

It will create a /etc/openvpn and a /usr/share/doc/openvpn/examples/sample-config-files directories that are relevant to this answer. Browse the configuration examples in /usr/share/doc/openvpn/examples/sample-config-files and pick one that you can alter to do whatever you want to do with OpenVPN. I assume you will use the client.conf file so that your RPi will connect to some OpenVPN server somewhere. Copy that file into /etc/openvpn, like this: 

I love the Pi, but I have to tell you it doesn't hold the fastest IO in the market. According to this article on the USB performance there is a empiric limit of 30MB/s transfer rate on the USB port. And all the USB ports use the same IO interface. As that, the limit of all combined USB should be capped on that 30MB/s limit. If you take a look at some HD throughput charts you will see that the average HDD can pull much more than those 30MB/s, so, seems obvious that the limit on the port will keep transfer speeds much below the empiric maximum of most HD Drives. Given that the limitation is the port itself, connecting 2 HD will only make them share the available throughput, and not add to any speed. 

There are a number of protocols that stack on top of Bluetooth for specific applications, such as Human Interface Devices (mouse/keyboard etc.), Audio Headsets and others. They are called "profiles" in bluetooth-terminology. Wikipedia has a comprehensive list of bluetooth profiles that is interesting to know. Many of these profiles have driver implementations for Linux, and, as an extension, for the Raspberry Pi. Choosing one of those existing profiles would be, thus, the best option for such a project. Linux machines use the BlueZ Bluetooth stack, and you can check which Bluetooth profiles it supports in the supported profiles link. For your particular application I would suggest using the Serial Port Profile - SPP that should be simple to implement and will transmit and receive short messages like the ones you probably need to get your project done. Sometimes it is called RFCOMM, like in the Android Bluetooth Documentation. Given that there is a BlueZ version for Android (I don't know if it is the default stack on the Android, but I suspect so), you have the two sides of the channel supporting SPP. Other profiles you might take a look that could get your project done, even if in a hackish way, are: 

country=US ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid="your_ssid" psk="your_pw" key_mgmt=WPA-PSK } Eject the card, boot with card in the RPi3 use arp -a on mac to see what IP the pi got or check your router config ssh to the pi. 

I had similar issue - did you copy the wpa_supplicant.conf from the website? If so, check your quotes - mine were matching quotes, not the straight up/down type. Changed those and the WiFi config worked. 

Check how is your power supply and cable situation - run: vcgencmd get_throttled 0x50005 <- first 5 means throttling occurred, last 5 means you are suffering from "brown outs" on your power supply. 

(Have been chasing this on raspberrypi.org forum but no answers there. Latest post with config info: $URL$ Edit: $ curl -4 $URL$ Returns 

I use that exact display with my Raspberry Pi 3B Jessie. No problems. It also works in dual input mode with Pi on one side and my MacMini display port on the other, since the display is so wide. 

Check out "Headless Installation" ==== Get Raspbian (or lite) â€” Download Raspbian (Raspbian Lite) $URL$ === get SD card formatter: $URL$ - install it === put Raspbian-lite on the (micro) SD card Use Etcher to Flash the image onto card === Mount the card to mac (to configure headless configuration) - Pull card out, reinsert so it is mounted for next steps === Enable SSH - create file called "ssh" (or ssh.txt) in the Boot partition === Setup WiFi Headless 

I have found that the tiny Kinobo - USB 2.0 Mini Microphone Makio Mic works surprisingly well in a quiet room, with the bot not moving, for speech recognition. There is a larger Kinobo USB mic that works very well but the cord is very long... Speakers are a bit tougher - I am currently using "Mini Rechargeable BOMB Speaker with 3.5mm Jack Line in. You might also consider a bluetooth earpiece which gives the best speech reco, but bluetooth connectivity was too flakey for me to rely on so went with direct connects.