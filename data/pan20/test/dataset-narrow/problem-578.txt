Plus, I can now call from one of my classes. (Although, on the other hand, I guess one could ask why I would ever need to use your function.) I wouldn't do more than though. In this case, it's 2 lines of code more for some re-use and re-enforcement of a good practice... Remember FizzBuzz is usually an interview question... A lot of abstraction is just not going to be needed. There aren't very many use cases for this problem. Javadocs You can document your code with Javadocs. The code you have right now doesn't utilize this, and it is pretty trivial to fix your existing comments to do this. Use braces This is the most important issue. This: 

Generalization I would argue that you should add an additional parameter to . is one of the many functions you could pass into the set so allow someone else to change it and add as a parameter to and pass the function in. Optimization What would I change to optimize the code?* 

is strictly increasing. Calling will stop a particular iteration quickly, but really you can stop a whole cycle, switch it out with . 

This tries getting the particular key which is a function. It then calls it. If the operator is not found, it defaults to the . 

Every once in a while you can add an additional newline for clarity, but don't over do it. You don't need to define as many variables as you have. Consider: 

Performance According to here, generating a list with multiplication is the fastest way, so change both occurrences of: 

This is equivalent to what you are doing and removes the variable entirely. Bugs There are bugs in your program. @Mathias provides an example as to why your code is wrong. You should consider @vnp's comment. The typical game tree traversal involves a reduction phase of some sort. As another hint, you should really review slide 27/39 of these slides. (Ask yourself, what does your code do differently than what is on that slide!) Abstraction (and more hints) You can actually abstract a lot of this. See my question here for a general framework on solving these games. A general framework declutters a lot of code. However, as mentioned in the prelude, a mathematical analysis may (or may not) provide a better solution than the general framework. 

This way we also don't need which you use only once, and is longer than . There may be some performance penalties, but it seems to run fairly well on the example you gave when I run it. 

I highly recommend that you adopt some sort of testing framework for your tests instead of having a stand alone script. There are quite a few options out there. For instance, . I would read up on how to write tests for and in particular have a look at how to capture IO since a lot of your tests depend on it. I would also recommend you give more descriptive names to your tests instead of, for example, and I would try to explain what the particular test does. So in the case of and what particular case is each one trying to break? Finally, you should look at PEP 8 Style Guide, functions should have instead of . So, for example, becomes . Also, classes typically use convention, however, because you are trying to emulate the keyword, using is probably a reasonable choice. 

It appears that you are using across multiple threads. I guess you plan to replace it in the future, but still, according to the documentation: 

Should be at the top of the inside of the function. (Also should be .) Global Variables Global variables are typically a bad design practice. Move these: 

There are other small related issues. Docstrings Python has docstrings which are ways to document your functions. It isn't exactly clear what or do at the moment. You have a comment describing . Two things about this comment: 

You call this twice in a row. I am not sure why you do this. Is this a mistake? If not there should be a comment why this is not a mistake. In you have the following two lines: 

Is something you should probably do. You don't really need flags. You have a list of numbers (which btw, is a generalization of your problem statement, why?). Each one of these numbers represents a move you cannot play again. So in the recursive call: 

But, again you should probably reword the comment, at the moment the meaning is not so clear, possibly: 

Law of Excluded Middle Something is either an isosceles triangle or it isn't. (This is a consequence of Law of Excluded Middle). Given this knowledge, as an exercise, what should you be able to eliminate from this code: 

Consider keeping with the standard library Instead of using , consider just using to generate a random permutation. Removes the dependency altogether. Just use instead of Comments such as: 

Your code doesn't use pattern matching well (it is kind of unecesary the way you use it). I would advise you take the solution you have and rewrite it to use pattern matching more like the Rosetta Code solution. 

Small syntactical changes should at least be . Some would probably argue that you should spell out and entirely. I personally like small names, but regardless, the capital should not be there. You wrote this one time: 

Are usually used for docstrings, you are using them to elaborate on certain steps in an algorithm, I would use for this. Place the cycle decomposition into a function The while loop introduces a lot of global variables and makes it hard to use, I would put the contents into a function. Also explain that this function displays a permutation as disjoint cycles. Please use better names. I'm still not sure what every variable does. Like why is ? I would think is short for , but seems to be what the actual permutation is. This program is really hard to understand simply because of your name choice. 

I wrote a game solver similar (but with reduced features) to an application called GamesmanClassic but in C++. The general idea is that (roughly speaking) board games can be represented with the four following functions: 

There might be even better ways than JSON, but it is definitely a push in the right direction as it isolates the data models from your code. 

I don't really believe you use to serve stuff faster. I believe is a better idea. (I don't like long names, maybe challenge yourself to a shorter name? Maybe ? Think about it.) (More) Comments Even then, isn't the most descriptive name, so you should include some comments as to what your code does. Don't over do it though. Remember saying something like: 

First some stylistic stuff Variable names According to the PEP 8 style guide, Python variables use instead of so, for instance, should be . Add a The equivalent of a function in Python is: 

returns the result of rolling two dice. Be sure to not say that it is the sum of two random numbers. Provide the context for doing that. Explain the rules of craps inside of the function (in the docstring). 

I recently attempted to prove that given two lines, they intersect at one and only one point in Idris. Here is what I came up with: 

Prelude Firstly, you might want to ask on Math Stack Exchange if there is any analysis. This game looks a lot like Nim and a variant of the subtraction game (mentioned later in the article). The subtraction game in particular has a really nice and cheesy solution. The major difference is that you prevent taking any number away twice. On to the code! Default values When you start a game, the first player to go is, well, the first player. I don't think a user really wants to waste their time typing it. A similar argument goes for . You shouldn't really need to specify it. Hide it make the default value . so: 

Easy stuff There are a lot of stylistic issues (indentation, spacing between operators, etc.) that violate PEP 8, you can use tools like pylint to find what they are. Moving on 

The past, present, and future. So for example, your function may have a good reason for being there. Maybe you had designed a stack before and had issues with pushing 3, popping 1, and then peeking. I've never personally had such an issue. It seems like a weird test case I wouldn't consider it, but maybe you have. If you have a compelling reason to have that test you should explain your reasoning in a comment so I can understand the purpose of the test. Ultimately: 

The prompt will wait for the user to input the data, don't make the user wait. Naming conventions for example should be converted to . We don't use the for functions and variables in Python. Instead we use . 

There actually may be is a better way to represent this with JSON. I'm not a JSON expert. The point I'm trying to make is this will help clean up a lot monster creation code, and room creation that looks like this: 

Keep track of the factors in some sort of variable. (Initialize it at ) Create a variable . Keep incrementing until is equal to . If divides , divide by . Don't increment and keep track of how many times you divided by call this . Otherwise, update by multiplying with . Increment . 

What does mean? You proceed to use it to determine the level (i.e. ) but it is not clear from the name (or even the method you use) that that is what does. Java 8 now supports - statements for strings. You may eventually want to refactor this into some sort of "difficulty" , but for now, I would change the level select to a switch case instead of - chain. See this answer for the syntax. 

The resulting code prints out as P1 can always win. I am not too particularly concerned about speed, as I plan to make optimizations later (including threading and memoization). I am mostly concerned about writing idiomatic C++. 

This way you can't accidentally change it later (Well, you could mess up something in iteration...). If you attempt to, the interpreter will get upset at you and tell you exactly where the issue is instead of it silently failing and you having to spend a ridiculously long time to figure out the problem. Naming Functions are verbs that transform data ("nouns"). Instead of call it . When you are inside the function you are opening the link, but what does the function do, it opens the link. (The same argument applies for . Call it ). 

The reasons for this are described in this answer. You should move your loop into the main function. Refactoring the while loop Don't use a flag. Just when you are done: 

is a weird name just omit the prefix to become . Similarly: -> . The term is often used. Furthermore the statement: 

The comment seems redundant. Your line of code reads clear enough for me to understand that you want to keep doing something until the list is sorted. 

I don't know if this is the best way to measure internet speed or not. I won't comment whether this is the right approach. There are, however, some stylistic improvements that can be made. You should run your code through pylint. Some issues could easily be addressed such as too many newlines between and . pylint enforces two newlines. This isn't English class, you don't have to double space your functions. 

The comment isn't really necessary. I wouldn't worry too often about explain imports upfront. I would explain the functions when you use them. In this case, however: 

Although Rosetta Code doesn't always provide the most idiomatic code for each language, look at the "idiomatic solution": 

Find current issues with your code. Nip likely future issues. Prevent errors you've had in the past from coming back. 

So what if ? Then It doesn't cause a division error. Same goes for . (Also, if you think that could become or some other sort of indeterminate form, the program will fail well before you get to that statement.) Reducing over addition You write a few times. There is common name for this operation, it's called , and it is included by default, so you should be able to get rid of all together.