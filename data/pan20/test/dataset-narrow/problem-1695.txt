By "properly linked", I just mean check there's no after any of the arrows. The output will differ a bit from system to system except for the pi-specific stuff. You probably then want to add that directory (which includes and some other things) to your , so that the executables (such as and ) can be found. If you are going to compile against the libraries note there's a directory and you may want to add that to your . The Pi version of OpenGL-ES is in there (notice some of it is linked to , above). 

However, beware that if that module was not built for your specific kernel, it will not load no matter what you do. 

What GUI's are fundamentally greedy about is memory; if you have enough free, using one won't hurt the performance of other applications. There is a hopefully obvious caveat to that: If you run very active graphical apps, they may require a lot of processor time. One way to judge this is whether they are actually doing something besides sitting around. For example, a web browser may hog processor time if you have pages loaded with javascript animations which run incessantly. A more definitive way is to run a process monitor such as top or htop. I believe by default these rank by CPU time. Generally they use a little bit themselves, which you will notice if you run one on a fairly idle system; the monitor process itself will be near the top, consuming 1-2%. You can diminish that by configuring them to sample less often; once or twice a second should be fine on a pi and still fulfill the purpose. 

No, i2c == i2c in very much the same sense that USB == USB. However, unlike USB, I2C devices are seldom if ever "plug and play" which is what you seem to be expecting. 

Looking at a version of , the auto-login part is enabled by linking one of several systemd service files from to . For auto-login that's ; for a normal login it's . To check which is the case on your system, 

See also a similar sentiment here. If you search online for "inotify sysfs", you'll find lots of actual reports of this. Inotify is a userspace entity; it monitors filesystem inodes. Sysfs, a kernelspace subsystem and the basis of the entire directory, is not a normal filesystem. It exists in memory, and functions as an interface to the kernel. The way the individual files work is this: when opened and read, the kernel provides whatever information they represent. For example, when you read , this is asking the kernel, "What is the current state of GPIO pin 25?". It will then tell you. However, that information is not actually stored there. It's a fake file. Inotify was not really intended for this purpose; in one of the discussions from that internet search you'll find a remark from someone who is presumably one of the inotify devs: 

1. The "tree" in "in-tree" and "out-of-tree" refers to the official linux kernel source, which includes most drivers for most things, or at least, most of the drivers that are available for the linux kernel. However, there are things that aren't included due to licensing issues, or because the driver was not submitted to or was rejected by the people in charge of the kernel. These tend to be a much bigger hassle. 

The first one of those that returns a line is the name you should use. Alternately, you could just look at while the server is running and find the user name. There is one instance of apache/httpd that runs root, but there are others that are unprivileged and those execute PHP. 

It's a breakout on a development oriented board, and ground is probably required more than anything -- everytime you connect one of the power rails, you need a ground connection, but in addition, attached devices with their own power still need a common ground. The breakout could be shrunk so that there are only two power pins instead of four, and only 1 ground, on the premise that if you need more attachments to power or ground you can fan those out with a breadboard. However, that could get a tad tedious and awkward. 

As flakeshake pointed out and then deleted for some reason, this is only an issue if you intentionally want to do things the wrong way. All of the documents you refer to make it very clear the point here is don't use . It exists because it's part of ANSI/ISO C, i.e., it has to for compatibility with ancient code. To be blunt: If it is too hard for you to just use , then how is it possible for you to care about the semantics of what you are doing (the wrong way, on purpose)? Anyhow, this is easy enough to demonstrate. 

If you don't do any shell scripting, is the exit status of the last foreground process. Non-zero indicates failed. When this happens, I reset the frequency to 30 or 60 seconds and if it fails twice in a row, the script restarts. The initial part of the script checks for other running instances, kills them, and shuts down anything else found running related to the connection, then starts it all a fresh. If you are using normal networking, you could just stop and start (or restart) that using whatever commands. All this is logged to a dedicated file, including redirecting the output of whatever commands. The one issue I do notice with this involves DHCP leases on my home LAN. I haven't looked into it, so it may be some annoying quirk of the Big Corp provided black box router. I only notice it with computers I actually work at, which implies when it happens to one of the afforementioned devices it eventually works itself out. I don't know how long that takes but I've sat waiting for fifteen minutes before, and nothing I do manually works -- DHCP fails because the router will not offer a lease. However: I use , and if I shut it down, then go into and erase everything (this is where the leases are kept) then restart, presto, no problem. Some systems have required some tinkering to solve particular problems -- e.g., I had a laptop where I had to use to get the wifi to restart effectively. If you think your problem has to do with the interface powering down, then you should use whatever command to force it to power up.