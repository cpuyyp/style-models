Your ability to do this is limited by the amount of time you would like to invest and the cooperative spirit of server administrators. Frankly, you cannot trust any email header that appears in the message headers regarding the delivery route that is beyond a server that you control. For most people, this means that you can only trust that your server received it from the server that it identifies by address and name. To determine whether or not this is the actual source, you would have to contact the owner of that system that most immediately delivered the mail to your server with the relevant time and information about that message from your mail delivery logs. Using that information, if he is so willing, he can extract data from his server log to tell you which server gave it to him. You probably begin to see the issue here. If he is unwilling, that is no indication that his server was the origin of the spam. However, if he is unwilling, your trail also immediately turns cold. Hope this helps! 

An entirely different approach, depending on what software you need to run, would be to fire windows back to yourself using X over ssh. This, of course, will only be workable if you are actually running XWindow applications rather than native Cocoa apps under Aqua. :) 

It's not actually a contradiction. Think about your own day. You have tremendous capacity to achieve work and, at times, do not have enough time to get everything done because you have too many simultaneous tasks or deadlines... Then on other days you sit around without accomplishing much at all. In a very similar way our computers actually tend to spend a great deal of time waiting around for us. Even so, as programmers, we try to keep our code optimized not only so that it can execute quickly and produce results as fast as possible but also to optimize system resources. This way, if it's a "busy day," we're trying to avoid contributing to "contention" (simultaneous demands for the same hardware resources) within the system. For an example of technologies made possible by this interesting situation take a look at modern virtualization products. The reason that we can run 10 or 20 virtual machines simultaneously on a dual or quad core processor with only 4 or 8 gigs of RAM is that all of those systems are not attempting to use lots of memory and processor time simultaneously. (Of course, you have to either get beefy hardware or judiciously select which systems will be virtualized in the same host or you will create contention issues!) 

This is somehow a developer question, but as it is more related to operating systems and network connections, I will post it here and not on Stack Overflow. I'm trying to simulate a situation when a network connection get closed because of a network problem or error, to test a behavior I implemented in one of my application. I could simply disconnect my network cable or shut down the network interface, but I made my application to reconnect immediately after this so doing that will take too long until the network will be up again (because of DHCP negotiating and etc.). Is there any way, in Unix or OS X, to just disconnect a specific application from internet and then let it reconnect immediately? Maybe to simulate a "connection reset by peer" error or something (I'm not a pro when it comes about networking, so sorry for my newbie language). Thank you. 

I'm working on a simple Bumblebee GUI tool. One of its features is to show a list of processes which are currently using the dedicated video card. For now I list all of the running processes and check for their parent: if the parent process is it means that this process is using the dedicated video card. The issue is that this is not working with , as there isn't any process called like that while a program is launched with . Is there anyway to detect the processes launched by primusrun or the processes which are using the dedicated video card? Thanks. (This is more a programming-related question and maybe it belongs to StackOverflow, but I'm not interested in code example but a generic way to find these processes). 

First, you're using in a Python environment, which is not available here. You should use from module to change the current working path in Python. Also, you use backslashes for defining the path, which need to be escaped. Either use or . Example: 

Another option is manjaro-iso, or its UI frontend b2im. I used b2im some time ago and it was pretty simple to use, but it gave me an error at the end of the process. Hopefully today that issue was fixed. 

How it started In March 2017, Win10 had recurring BSODs and, at some point, could not start at all. I did a reinstallation from the Win10 "repair tool". BSODs remained. Then I did a fresh install from Win10 DVD (which was a pre-Anniversary version). In the meantime I updated as many BIOS, firmwares, divers as I could. And I never had a BSOD since, but … Symptoms of current problem Apparently only after the Anniversary update: After some very random time but most often 15 to 45 minutes (and not necessarily increasing or decreasing with occurrences), both sound cards start to make a regular noise over any sound they're playing, one RANDOM application crashes (not responding), other open applications keep running but progressively, clicks here and there start having no effect at all. TaskBar also progressively crashes. New windows or menus don’t appear. CTRL+ALT+DEL not working, Start Menu not working. So thins looks to me like the crash comes from somewhere in Windows 10 UI. At the end of this progressive crash, that only option is a hard "Power off". (Making post-crash diagnostics harder.) Hardwares 

Softwares Softwares I typically install: Eset NOD32 (anti virus), Magix Vegas Pro 13 (with Hitfilm plug-ins), Magix SoundForge 11, Adobe Photoshop Lightroom 6, Visual Studio Community 2017, Notepad++, Microsoft Office 2010 (because I paid for that one and I don’t see the point updating yet), Google Chrome, Mozilla Firefox, Mozilla Thunderbird, Foobar2000, FileZilla, MozBackup, WinMerge, WinDirStart, CritalDiskInfo, hwMonitor, … Softwares I typically install but were not installed yet when crashes already happened: VLC, Adobe Photoshop, … Softwares I typically uninstall: OneDrive, games coming with Windows, NVidia Geforce Experience Things already tried I’ve tried so many that I’m not sure if the list will be exhaustive: 

Current experiment On 26/5/2017 I started a very "slow" step-by-step re-installation. Timestamps relate to the line before them. Current stat no real crash yet: 20170526 1848~ 

In a MediaWiki, where can I find the list of all uploaded images ? (I had it a few weeks ago, now that I'm back on the project, can't find it in the interface.) 

If the apps support multiple DB, it's imaginable that they would write store procedures for each DB they support. Now, I don't know for SQL Server but regarding MySQL, many shared hostings don't allow creation of stored procedure at all, and some other features.