And you would like to know why there are no interfaces listed even though you still have the WiFi dongle attached to the system... There are a few questions: 

Plug your modified miniSD card into your Pi. Plug in your power cable. Wait 60 seconds. Plug in your USB cable into your Raspberry Pi and your PC. Run on your GNU/Linux machine and wait until you see the serial device register as something like Open a serial terminal program such as . Change your serial device in the program to match your OTG registered Pi. Press Enter 2 or 3 times and wait a few seconds. 

When prompted for what do to with new certificates, choose . And then select the with space. Test that it works: 

AFAIK only one audio output can be selected. You can, however, select one of them manually using amixer command: 

There is at least one option you can use that does not require adding additional Ethernet port to your RaspberryPi - using VLAN switch. This can be quite expensive since the cheapest VLAN switches I know costs something like 35$. But it has some additional benefits (even more ethernet ports, way more to learn, etc). You can configure them to tag each port with different VLAN id, and then create multiple VLAN interfaces on your Pi. Each packet that is tagged, will be visible on proper tagged interface on your Pi, effectively providing something many virtual interfaces. 

and pins have external 1k8 pull-up resistors connected. This is indeed because they are intended for I²C usage (which requires them). Unfortunately, since they are external, they can't be disabled in software. Having pull-up resistors means that default state of the pin in , unless they are pulled to ground. And this is exactly the problem you described. This may be seen as a disadvantage but for buttons, this can be actually useful. This means that you don't have to use any additional pull-up/pull-down resistors with those pins (but you will have to use inverse logic - 1 when button is not pushed and 0 whet it is). 

If you are looking at the guide linked to by @RichardChambers then the relay board has the transistor and the diode (the orange component with the clear packaging) listed in the relay control circuit. However, it's important to note that the transistor could be setup to follow reverse logic. The type of transistor will determine how the input functions. An NPN BJT configured as in the above guide, will follow normal logic. However, some other transistor might be used to change the input voltage sensitivity or perhaps the logic applied. 

In order to get recording to work from my USB headset, which may be approximately the same... as long as the default sound card drivers work... I needed to select device 1 as follows: 

If so, then you'll need to find the datasheet for the board. The transistor can be setup to activate the coil on a low input... i.e. Ground the input terminal. Or it can be setup to activate the coil on a high input... i.e. 5V applied to the input. If you can't find more information online about that particular board, try asking your local shop for more information. Most electronics shop people will talk your ears off if you ask a question or two... I know, because I was one once. 

Where is your RPi IP address. You should see all the network packages sent to/from RPi. This way you can see if packages are sent at all. NOTE: You may need to use (before word ) option to specify interface other than default if you have more than one on your server. NOTE2: You can add at the end of your command to only limit network traffic to TFTP packages. 

While I don't have Arch Linux to check if this, it's probably mounted by kernel itself and never remounted. You can check your and you should see something like and options. You can set them in file. First one specifies which device (partition) should be mounted as root device, second one specifies filesystem type. If you want to change some mount options, you can use kernel option - just specify proper mount option string (for example ). Note that you can only specify filesystem specific options like this, filesystem independent options seems not to be working. Also note that if you make an error setting this option, your system wont boot. In order to fix this you have to use emergency boot or change your file on other computer. You can also remount your root file system somewhere in the boot process with following command: 

If you are connecting to a remote host via and would like the graphical interface to show on your local display, you need to: 

There are some shortcuts for path names. However, using the full path should be more error free for a beginner on UNIX like operating systems. I recommend reading through the Free Pascal Documentation, since there be some changes from what you are used to in other compilers. 

So, on a system where has not been installed, installing will also install . However, is not the same program as , and seemingly does not rely entirely on the cache. So, in order to properly setup the command is required. There is a clue in output when install and pulling in as a dependency. 

As @Frepa said, there is kernel thermal driver for RaspberryPi now so the easiest way is to use it. As far as I know, that's not the way works however. It was able to read the temperature even before thermal kernel driver existed. It is using special communication mechanism available on RaspberryPi called in order to communicate with VideoCore OS running on GPU. It is partly documented here. 

Unfortunately it seems that (RaspberryPi's SoC) does not support sequence. This means that your module is not compatible with the on RaspberryPi. There are two workarounds, none of them is easy to do, however. Bitbanged I²C You can use software (bitbanged) bus on your RaspberryPi. I can't test this but reading the driver code it seems that repeated start sequence is supported by driver. My tests with logic analyzer confirm (although I only tested this with which is very stupid device) that sends bit after data address while only sends bit. It so happens that I recently wrote a Linux kernel module that let you create such bus without manually changing Kernel code. It's not (yet?) a part of the RaspberryPi kernel so you would have to compile this yourself. Here's the code and some instructions (but you need to know how to compile your own kernel to use it). Since uses function, it should "just work". HiPi commandline utility You could use HiPi utility (here are installation instructions) and check that it works from the provided commandline utilities. If it does, you could use them instead of to do the communication. I know that it is not pretty solution but it may work. 

Simple Debugging of X11 SSH Connection There is no need to start X11 manually on the Mac side. If you use the option when trying to connect via ssh, you'll get useful debugging messages. Towards the end of messages, you'll notice that X11 is started automatically: 

If the 74139 decoder is a 3.3V version, the left LED will be lit when power is applied to the Pi. Once the systemd service file is executed, the GPIO pin will select the right LED, and the left LED will turn off. 

So, it seems that is has two locations for with the user Remove the second one, and see what happens. 

If using the new hostname will be accessible at myhostname.local If is disabled, the new hostname will be accessible at myhostname.domain.tld as long as there is an entered in the DNS zone file. 

which should spin your drive after 10 seconds of inactivity (you can change to other values (1-240 can be used to specify multiples of 5 seconds, 0 turns spin down time off, 241-255 can be used to specify longer periods). Another option you could try is to use: 

protocol is very simple. It does not really define data structures that are sent over the wire. The frame consist of a slave address (with direction bit indicating if master wants to read or write) and (in case of writing) some bytes of data. Since it doesn't make sense to initiate write with 0 bytes of data, first byte is mandatory. This first byte is often used as a slave register address or command number but it doesn't have to. There may or may not be additional bytes after the first one. The higher level protocol defining what each byte means is device specific. This may explain why there are two separate arguments - first one () is mandatory and second one () is optional. While your example is in language, the API used here is actualy very close mapping of original API where you can't easly create optional arguments. 

Since it seems that your is missing, you may want to fill it in with the necessary information. You'll need to manually mount the root and boot partitions first: 

The result of the working procedure is a logical link in to the certificate in and the new certificate being added to the trust store. Hopefully, this tested procedure works for you. 

Here's a partial answer... It's Christmas Day, update later if it seems helpful. Building on my comment: Here's the external electronic circuit to go with the proposed systemd service file [TBD] 

It's important to remember that the alias needs to be created in the proper user's environment. So, if you run as , you will need to create the alias in a shell. 

Will allow the USB memory stick to be mounted by a user ... but will not be automatically mounted at boot. 

You could try epeg. It's designed exactly for the job you need - to create fast thumbnails from jpeg files. The only problem is, you need to compile it yourself as there is no package for it for RaspberryPi. It's a library but it comes with a simple test tool that you can use. 

There is not much difference since RaspberryPi is quite normal Linux system. The only difference is that it uses ARM architecture instead of x86 and compared to the recent computers it's slower, has less RAM and has some other peripherals (like GPIO and lack of HDD). When programming in high level languages like Python, you wont see any difference between different CPU architectures. So the only difference is amount of resources - programming on typical desktop computer you usually don't have to worry about speed and memory footprint as much as on RaspberryPi.