Having a numeric component can help with translation. For example, if you have both fields meaning entries in an HTML form and fields meaning land under cultivation on a farm, then you don't want them to have the same translation key. That said, people often want the translation keys to give some hint as to what the text might be, so they mix the numeric ID with a string, e.g. . You probably want to separate your main code from the translations. Also, you probably want to separate your English and Spanish translations from each other. The reason is that you don't want to have to change the file with the English translations or the code because there is a problem with the Spanish translation. This also allows you to use separate encodings for each translation. And of course, separate files scales well. I'd be wary of trying to use generic English messages to cover multiple situations. For example, there may be a language that uses different words to describe a form entry that can hold a string like a name versus a number. It's often better to be as specific as possible in your message so as to save yourself the trouble of refactoring when a new language causes translation problems. Repeating yourself makes for bad coding practice, but it may be good for translating. Be especially leery of embedding translated strings in other translated strings. It's very easy to get into situations where (for example) two strings use different articles or verbs. An English example would be "I am", "you are", or "she is". "I is" or "you am" would sound ridiculous but is the kind of thing that string embedding gets you. Also be careful of concatenating strings. The translated version may put the words in a different order. For example, Spanish often puts the adjective after the noun. 

so that it has a variable to reference. This also brings up another problem. The function will return a reference to the underlying data structure which can then be used in assignments. If the caller does this, they can bypass the bit mask that you use in assignments. For that matter, the caller could store a non-integer in the array. So maybe what you want to do is 

Note that and would probably be enough, as "saved" and "current" are implied. I also added whitespace between tokens. The compiler won't care, but this often makes it easier for humans to read. 

Again, I did an early in the error case. I switched from the to a as more readable. The version was incorrect too. You need to before using , , and . I also changed from to as previously discussed. 

This creates a new table that maintains a unique index on and , so you'll never have a duplicate. Then 

That will also save you a level of indent. This works because the else ended with a return, so you don't actually need to invert. You can just move the check before everything else. A return statement in a then clause makes for an implicit else. You don't have to add an explicit one of top of it. 

Note that this won't update the or superglobals. Further note that as written, your code will escape each time this function is called with as the input. I would think that this would be an undesirable behavior. would turn into then , etc. 

This whole section of code is unnecessary, except for one line (the ). Instead of generating invalid strings and masking them out, just don't generate them in the first place. That will save all subsequent recursive calls down that path. 

This adds a new variable that points to the end of the list. Note that you'll have to make additional changes to maintain the variable if you go this way. If you don't maintain a , then consider making the default to add to the front of the list. That's simple in a linked list whereas adding to the end is difficult when the list is singly linked. It's not necessary to use with field names unless you have a naming conflict (e.g. a function parameter). So you can just say 

I might call this . It doesn't balance anything. It's a stack of all the currently open braces, so call it that. 

You do two things here. First, the Java standard prefers that you always use braces (although the language allows the other form. More seriously (at least to me), you are mixing styles in the same control statement. Even in languages where the single statement form is allowable if not preferred, it's better not to use both forms in the same / construct. As Laura noted, really should be a method on the class, not the search class. Another thing is that you shouldn't need to do on each call to the function. Check if a board is solvable before passing the board to search at all. 

Be careful about using . It's one thing if the three columns that you use are the only columns. It's another thing entirely if you have a large text column that you don't need in the table. There are some people who believe that you should never use and always specify the columns. Note that using may also cause you to go to disk when you otherwise would have a covering index. This means that even a small column can be a problem. I don't like the name for the database connection. It's too short to be obvious what it is. Admittedly, is slightly more accurate than , but is accurate enough, reasonably standard, and more easily recognizable in my opinion. You may want to replace with as your check. I.e. instead of checking the time, check for newer values. Assuming this is an autoincrement primary key, you should already have a unique index on it. You could put an index on , but it will be a slightly less performant non-unique index. This also avoids the problem with near simultaneous chat messages where you only have the first one and never look for the second because it has the same time. 

Now I have a declaration block, an initialization block, and the start of the coding block. I changed the declaration of . Instead of being of type , I made it of type , which is the interface name. This is why we have things that implement interfaces, so we don't have to care what the implementation is. You happen to be using a , but if you change that to an or any other implementation, it shouldn't matter. I added an at the beginning of the . When I first ran this, I didn't know what the various outputs were. Now I do. Avoid code in You put a lot of your code in the method itself. As a general rule, there should be very little code in main. Process the arguments, perhaps initialize variables, and then call methods to do the heavy lifting. This allows you to reuse those pieces that do actual work. If all the code is in , then you have to edit to use it. Further, you can't just add your class to another project; you'd have to copy the code itself. 

There is a type explicitly for handling size data. You may think that you are being more inclusive by using , but you are actually moving errors from where the problem occurs to where clipping occurs. In programming, it is generally better to be consistent than right. Because even if you are more right, you will be wrong in your interactions. 

You don't need to save the value of the string literal. You only use it once, so you can just use it. Starting with instead of means that you don't have to add to the value before using it. I switched from to , as is a more common loop iteration variable.