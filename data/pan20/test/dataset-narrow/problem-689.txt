→ , same for . is more readable. You can also convert everything that represents a time into a or a , rather than deal with Unix timestamps. There are functions in the package that do what you want to do (, , etc.). About that, why does need to do complicated things with times, checking when was the last time it was called, etc.? Shouldn't the caller take care of this with a simple instead? It feels like this complexity shouldn't be there. is a weird name for an implementation. maybe? Your package isn't very idiomatic, which makes the callers do weird things to use it. For example, why do you have a struct that doesn't contain anything? Why not simply have as a package-level function? Same for the other empty structs of this package (…). It's more idiomatic to test for rather than . I'm not exactly sure what you're doing with (this is pretty complex). Maybe add a comment for the line or refactor this part? Talking about refactor, is way too long. Split it in sub-functions. No need for an after . Rather than: 

Minor: don't panic. This is encapsulated in a function (that, indeed, does too many things) so the function should return an error if something bad is likely to happen; and you should let the caller deal with the error. Furthermore, is almost always what you want rather than . Major: don't use a regexp to parse HTML. Seriously, don't. Consider using the html Go library instead. 

you could also write but it's not that important. Now, the rune/string/byte question is the interesting one. deals with only; and converting strings to bytes and back is expensive (new memory allocations each time). So I'd change your code to use instead of , and instead of . The function becomes faster: 

It doesn't seem that the library has a query builder or a specific type. So building a query in an idiomatic and readable way should be done as you would do for a normal string, and that is using the package. This will allow you to get rid of many code smells: 

(That said, I'm not convinced it matters — the compiler should probably optimize this anyway.) I tried it and was very surprised to see that the benchmarks were still very poor. Turns out, you called the wrong function in your benchmark :-) calls insead of . Retrying it with this fixed leads to the expected result: 

This allows you to replace with the more readable . Default properties: There is a pretty common technique used to handle default values of object properties. Replace 

Now, it is much easier to see that the inner loop is actually just checking the existence of an element within an array. You can use the faster built-in method instead: 

Style Instead of I suggest the more self-documenting as the length can never be negative. Also, don't needlessly mix vs. for strings. Specification Right now you are returning a distance of when there is no path and a distance of if equals . I suggest following the common definition of path length and return and instead. You might also want to pass the alphabet as a parameter instead of having a hard-coded 'magic' constant in your function. It can easily be computed from your dictionary as . Also, you currently allow any word for while must be part of the dictionary. I recommend allowing non-dictionary words in both cases for consistency. Performance Your main performance bottleneck is the function. If you keep track of a set of open words which you haven't visited yet, you can replace that function call with a simple . Set lookup time is constant and thus much faster than iterating the whole array. You then have to pass the set to . The map is no longer needed. Another performance drain is performing string splitting via in the inner loop of . You can push that to the outer loop. Also, you currently treat as a special 'shortcut' case. You could generalize this to . Sample code Applying all those modifications to your code yields: 

Notes Declaring some of your variables as can protect you against erroneous reassignment or rebinding, as any assignment to variables will throw a at runtime instead of silently continuing execution. Instead of I recommend using the unary plus operator which is "the fastest and preferred way of converting something into a number" according to MDN. Parsing I like your separation of input parsing and the actual program logic. However, you create a lot of temporary copies by first splitting and then mapping the array. If you like, you can use iterators or generator functions to parse input with only constant additional required space: 

In , you're needlessly allocating strings by modifying the variable. It would be a fairer benchmark to write it in the following way: 

It's very simple; what you're saying here is "give me a , I can give you n random values from it". Option 2: 

And, no, there's no easy way to have something more dynamic that , unless you have a specific use case in mind (and then, you would use an interface, but this is out of scope for this question). See this for a detailed discussion on why Go doesn't have generics for now. 

the line containing your query is long and not easily readable, maybe skip more lines you can write the skeleton to your query once, instead of using successive appends — this is also more efficient if you have many services the call to can be avoided using a simple condition in your template you can replace directly by its value, that you previously computed in your Go code and you can get rid of the variable that you pass to & , just do all the substitution logic in the go code. 

Yes, this is the way to do error handling in Go. By design, you can't let exceptions propagate to the callers "silently", you have to consider what makes sense at each step. I found that on large-scale projects, it makes it significantly easier to predict and test the error handling behavior of your code. It also forces you to put the error handling first, which (imho) results in more readable, less nested code. Truly global variables don't exist in Go — if a package exports a variable , other packages will have to call to access it. That being said, it pretty much never makes sense to do that. In the example you gave, cmd.go and project.go are in the same package, and all package-level variables are shared, so identifiers conflict. If you want this variable to be shared, it's more readable to put all functions that use it in the same file. When you want to mock some of your functions, it's the sign that there should probably be an associated interface. You can then "mock" an interface easily, by re-implementing your interface in your tests and making it do whatever you want. I find this more readable and idiomatic than using complex frameworks. 

As already pointed out, you need a more sophisticated approach to testing runtime performance of runtime-optimized code produced by modern JavaScript engines. I compared the performance of your datastructure against the built-in as well as plain objects on the well-known performance testing playground jsperf.com based on the benchmark.js library and got the following results on Firefox 53 / Ubuntu: 

You asked what happens when you don't initialize in the loop body? Initially you create a single array instance . Then, during each loop iteration, you modify the content of this array and push it onto . So in the end, each index of contains a reference to the same array, similar to this: 

to mitigate timing attacks. Reason: The public function should only return one information - whether the password and the hash match or not. But right now, it leaks more information to an attacker who observes the time this function takes to complete. Whether or not that information can and will be used to the advantage of the attacker is dependent on many factors (e.g. preimage attacks) and unless you have taken all those possible factors and scenarios into account, you better use the safe and simple . 

Create a circulant 10 x 9 matrix where each row is a circular shift of . For each round or column, replace the self-match with a match against team and let team play against the self-matched team. 

Optimizations Blindman67 has already pointed out that regular expressions speed up parsing by a huge margin. But we would still copy the input which results in a linear additional space requirement. By stepping through the raw input via and and using the fact that two of the three queries are of fixed length, we can reduce the additionally needed memory to a minimum and thereby speed up parsing even more. We also reduce the overall number of and operations on the stack by a simple run length encoding - i.e. by keeping track of the last maximum in one stack and its repetitions in another stack: 

Enhancements: You might want to listen to the "blur" event and deactivate the dropdown when its focus is transferred to an outside element. 

However, unless your will have additional properties later on, a simple instead of a class will do the job just fine. Instance properties and side effects: Within your calculate method, you create new instance properties such as , and holding the result of the calculation. This is called a side effect. Pure functions without such side effects are easier to understand and debug. Also, those property names are not very descriptive. Consistency: For different inputs, the values of and the return values of are inconsistent: 

You client code is incompatible with the argument type of (I guess you meant to write instead of ?). But this is strange to have for an expiration time, most probably should just be renamed to and be an . The code could be more idiomatic. Your variables/functions have long names that aren't really useful. You could replace by , by , by , by , etc. Your function does many things (type conversions everywhere!) so that's confusing. You should probably refactor away a function like: 

You're saying something similar here: "give me a and I give you a ". It's better if you want to have a concept of a variable that you'll later pass around or reuse. 

If you can't guess, try it; it's a good way to learn =) Anyway, you don't want that to happen. So you can do this several ways. Before I'm going into two idiomatic options, let's talk about your interface definitions: 

→ . When a function returns and you want to return an error, you usually return the default value of along with the error. So in , you would return rather than . This helps you make sure that you're not going to use the return value when you return an error. Instead of printing the error with , you probably want to use and add an error message. Or not print anything at all and let the callers deal with the error (after all, it's why you return it), possibly returning instead of just . Close the file after usage. Add . Use a with option instead of trimming whitespace by hand. Your CSV file shouldn't have space after values (arguably, it shouldn't have spaces anywhere). On "does this look like Go", I'd say you have too much whitespace (empty lines in functions are seldom used), line returns (you never see them right after declarations () or assigments ()), and your variable names are Java-level verbose. In Go, you would use instead of , instead of , instead of , etc. 

I put zeroes outside the func, to avoid converting it over and over. You still have a few conversions & allocations, but there's no way around them. The other functions can be modified easily to accommodate the type change. 

The resulting optimized function below runs about 30x faster in Firefox 52 compared to the original code. It turns out to be pretty similar to Flambino's exemplary code apart from replacing with a ternary operator and pushing a subtractions out of the inner loop: 

Of course, you might want to encapsulate above code in a function or even more versatile, a generator function and replace with . However, since you only have four different step-sizes of 1, 10, 100, and 1000 you can encode them manually and come up with an even simpler generator function as follows: 

Edit: You could move the declaration of both event listeners out of the loop body. However, the dropdown toggle's 'click' event listener needs access to the dropdown element it belongs to. So you would still need a closure or alternatively bind the event listener's to the dropdown: 

Now, we re-introduce the matches against team wherever a team would have to play against itself (the red squares). We also have to fix the opponents of team to reflect these changes. This practically means that for each round we swap with where denotes the self-matched team (the red square): 

Replacing above regular expression with e.g. a much more refined allows you to capture floating point numbers, negative numbers and whitespace. To support more operations, simply append them to the object literal, e.g. and add to the operator capture group within the regular expression. 

I recommend to follow this 'natural' structure and solve these two tasks independently. Generator functions are a great tool for untangling your seemingly interwoven code and pushing individual functionality into their own reusable, testable functions. They are especially useful when you are not interested in storing intermediate results but rather want to directly process (e.g. print) them: 

I like your idea of counting character frequencies first. This allows you to count the required deletions in linear time. Your code is readable, but readability can be improved by more semantic naming and leveraging modern JavaScript language features. Naming: Regarding the variable names , , , , : Those identifiers mainly include type information (, ). But as a reader, I am more interested in the role of your variables instead of their type. So instead of I would prefer to read or even . And instead of I suggest the simpler . For-loops: First of all, you probably forgot to declare the local loop iterator in . Unfortunately, those omissions can introduce very hard to trace bugs as you now access and potentially share a global variable . Also, JavaScript arrays and strings implement the iterable protocoll. This means you can iterate over them using a simpler for-of loop: