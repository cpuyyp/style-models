The difference is simple. Unity is a carriage with four round wheels that can get you places. OpenGL is sawdust that you could set up a shop and potentially use to mould an improved and more modern carriage and wheels. That is if you invest many hours of your time into learning what the people before you have done first. Your goal as a beginner should be to first study existing carriages and their designs. There is not point in throwing everything out the window and starting from scratch. First learn what already exists and get a thorough knowledge of it. If you don't, how do you know of it's limitations and if you don't know the limitations, how could you break through them? What is the point in making something mediocre that is useless and being ignorant to all the vibrant existing tools that are already available? imho the steps of a fledgling game dev are: 

Meshes are typically implemented as graphs. If you wish to implement path-finding in a map based on a grid do the following: Create a graph where each traversable square is represented as a vertex. Each pair of adjacent traversable squares represented as vertices, will have an edge between them. And you're done. 

Finding the bounding box of that shape. Increasing it's size by 1 in each direction. Iterating over the frame of the new slightly enlarged bounding box and applying flood-fill. If there are any tiles that you did not mark with flood-fill that are not on that chain then they are enclosed. I suppose that by your definition if there are enclosed tiles than the shape is a closed figure. 

The first part of the formula in the red frame defines the sets of all possible velocities for agent A that will result in collision with obstacle B in the future (a cone). 

Pointing from the floor to a 3d character's head. Pointing from the character towards where it's facing. 

Create a 2d-array with approximately one square cell per the one collide-able object (considering the approximate max amount). Each cell in the 2d-array is a iterate-able container (data structure) of your choosing (list preferably) of collide-able objects with a bounding box that currently overlaps / intersects with that cell. It needs to be updated every frame (if the object moves). You only check for collisions between objects that are in the same cell(s) and you only check once every frame. 

Rule 1: Do not use random behavior in traps and enemies. This is why Roguelikes could be problematic if they are not fine tuned as randomness could create massive difficulty spikes if not handled correctly. The point is only making the game hard to beat; this may sound obvious but you also need to convey to the player what challenge they are facing and why they failed, otherwise it would be just one of those trial and error "trapformer" games. Platformers 

You have it all wrong, you seem to say you want to return and also have the function state that it returns an entity. That cannot be done. Te object you return has to be of the same type or a subclass type of the object your function definition/declaration says you"ll return. For instance you can't do: 

You could simply provide buyers with a username/password upon purchase of your game and allow them to sign in, actually they could sign in with their googleID which they will provide to you during their purchase and your will add to your server as a payed customer. I did something similar with an education service, it could not be very tricky, could it? How would you monitor how many turns they played? Sounds like a big database... that could be bypassed somehow by faking user ID, I suggest limiting them to a certain area of the game map in the free version and letting them explore everything in the full version. Good luck with your project. 

What you could consider is accepting more vague and inaccurate input from the user as correct input during this lag and when it occurs. For instance, if the play had to touch the screen on the left between 7.3 and 7.7 seconds into the stage the give the player a wider time frame. This is hard to do but I feel it is more suitable than the other two options namely doing nothing & pausing. Alternatively, you could simply slow down the gameplay pace when framerate drops beyond a certain point like under 30fp, you could slow down the gameplay according to the fps rate. 

The position (x1, y1) of your character. The angle alpha in which it is facing. The positions (and possibly sizes) of all enemy creatures. 

Therefore, there must be two integral numbers and such that = sqrt(3) We assume these numbers are coprime, if they have a common factor, we divide by it producing a coprime pair, and We know that and therefore . is devisible by 3 as is integral and therefore is also devisible by 3. There are not integral numbers square is devisible by 3, but they are not. so it follows that itself is devisible by 3. Lets define . => = > which means that is also devisible by 3. This contradicts the base assumption that they are coprime integers. 

There are a lot of examples of games where famous characters are used. You can see many adult oriented games with characters like Princess Peach from SMB for instance. While in theory there should be no risk involved, things will probably get out hand if you try to sell this game or advertise it well enough that some companies would feel obliged to protect their copy rights. The general rule is that if you are "small" and "unprofitable" then companies leave you alone. I can only prove this by example and this is not legal advice. If you don't wish to sell this game for profit I doubt that I would worry. You can always rename the characters and say "the game is inspired by" xyz. 

Would this be useful to your project? I believe what you are asking for is NLP and IF is just a specific use case. $URL$ Well, if you wish to check that the correct combination of a noun and a verb was found in the sentence and not so much about structure, grammar and other aspects: I suggest downloading this $URL$ You could use it to basically check if a synonym exists for both the verb and the noun you are looking for in a sentence without having to manually type in all the viable synonyms for each word. If you wish to see text adventure game source code that was recently released, you could find some games here (just hit Ctrl + F) and type text $URL$ There is also a list of Text Adventure game engines here: $URL$ If you require something more, please elaborate. 

Master a modern framework / Engine and get a deep understanding of it (This will also help you learn of the different aspects of game design, graphics and OpenGL are not all there is). Make a small game with it and learn more in the process. Organically encounter obstacles and limitations in the engine. Learn more about the subject. Work to improve the areas that you deem needs improving. 

Create a new Vertex from each one, with the stored as the 's . Randomly pick a neighbor from one of the vertices created until this point (don't do it for the first Vertex as there will be no other vertices at that point). Connect the two by adding each to the others list. 

Playing a variety of games I noticed that some concepts are "trapped" in the realm of roguelikes. One of the most intriguing game-play elements in roguelikes is the unidentified item. The unidentified item can be used at any time adding another layer of randomness and chance to the game-play. I think the reason this element cannot co-exist with a saving mechanic is that you could save, use the item and then load if you are unhappy with the results. I am still puzzled if this mechanic is overlooked and it could possibly be successfully incorporated into some modern games? If you do know of examples where it is being used, please share. 

It is actually supposed to be simple. There is an invisible anchor bullet moving like a normal game bullet would in a straight line (implementation not included). You have the angle in which the anchor bullet is moving and its position & . You also have the (how far does the sine wave expands) and it's (how fast does it go up and down). You also need the to determine where the actual bullet is now. To compute the position of the sine wave bullet, use this: 

The cause of this "effect" is that I believe you are drawing the outline of a rounded rectangle, one rectangle inside the other. Is that correct? If so, what you are seeing is simply how Allegro I presume is handling round corners, specifically, it does not draw a thick pixelated line and leaves some pixels "missing" in the corners. When you draw multiple repetitions like you just have, the missinh pixels become more prominent than they would be if you only drew one outline (which is what I presume the function was intended for) and create the missing lines effect. To put it in visual form: This is what it's doing: 

Are you extending one of the Citrus classes (CitrusSprite, PhysicsObject)? If so can we see that class's code? Do you have the [Property] tag in the right place, above a public var or a public set function? If so can we see that code. Make sure the code for the project is in the folder path Level Architect expects it to be as mentioned in the instructions for setting up your IDE. 

To accept input from the user, parse it and send it to the server. To render and display what the player is seeing. 

So an engine needs to understand how read files; you don't want to write a file parser. The files are on the disk in some format and you simply want to say and the Engine needs to convert that data into something useful that could be rendered by the rendering service. The rendering service wants the data parsed (digested) and explained in the way it understands it. If the files change, you don't want to have to replace the entire rendering service, that's right? 

Display the sprite-sheet(I assume you have that covered) Allow moving(arrow keys or wasd) the image on (x,y) while retaining the offset -> offset.x, offset.y (the offset is the (x,y) of top left corner pixel currently displayed) Allow zooming in and out (+, -) 2x / 4x / 8x/ with two keys -> zoom 

New answer: After getting more intell on the situation, I suggest installing CS5 in addition to CS6 until you no longer require use of the Device Central. It will work according to online resources. If you wish to make sure you could try superuser.com for additional advice. Good luck making that game. :) As you probably know CS6 allows to save projects as CS5 (with some limitations). Old answer: Read about: Adobe AIR mobile simulation 

This is psuedo code and it needs some refining.. It should give you an idea. If you never made a platformer, I suggest you learn about states too. 

You can use if you want the absolute value like I think you do. Sometimes you will get a value that is nearly , in this case subtract and use again. 

If it's 3D it includes, lighting, refraction and interpolating between frames of animation too among other things. 

If there was no collision between their containing rectangles, we could stop here and save processing time. 

Is there any reasonable way to compute this on moving objects? i.e, so collisions will not be missed because of the discrete nature of frames? 

I would limit this to a SMB(1) style game where the Y-axis is bound throughout the game. Instead of randomizing everything, I would stick to building mini-stages in advance and then determining which of them will be next using a hash-like function that takes the seed and the current 'x' value to pick the next area. I suspect that because of the computational abilities of the Mega Drive (~7 MHZ), it would be unwise to further burden it with sophisticated level generation when it should be sufficiently occupied with collision detection, enemy behavior and other game mechanics. If this experiment works out, you could layer mini-stages on top one another, breaking the y-axis bound and getting something similar to what your described. 

The issue: You have a limited amount of resources to complete a certain task. You also wish to complete this task in a specific time frame (i.e 1/30 seconds). Using HTML5 does not allow you the same freedom and efficiency that you'd get with a native client. If you need more efficiency in utilizing resources you should seriously consider a native client or a plugin based Engine like Unity3D. 

The behavior I've seen in the video you attached could be mimicked like so: When the characters are spawned, the current leader's position (2d point) is saved and is currently the only element in an array (or Vector) representing the movement path coordinates or . All have a member that points to that element as the position they need to reach (but they are currently unable to move). They also have another member that signifies how close they will be (in the line) to the leader which obviously differs between all followers (possibly something like units for the closed one, , and so forth for the ones behind her). When the player clicks a new target, the new position is pushed into the end of the vector. The distance between the current position of the leader and the new point is calculated. This distance is the amount the leader will move to reach the new target area. Assuming all soldiers were spawned with the correct distances between them, it is also the distance that each soldier is allowed to move (this is the easy way to implement it using integaral [not floats] units of distance). So we begin to move the leader to the new point and at the same time, move the others to the leader's spawning point (the first element on the path array). Once each character reaches the leaders spawning point (first element in the ), that character's goals member is adjusted to point to the next element in the . Each character is allowed to move exactly as much as the leader or alternatively, until the computed sum of distances from it's current position to it's current goal and from there through all other coordinates until the leader's current goal is equal to their . You could and probably should add a tiny delay from the moment the leader receives an order from the player or computer AI and until the followers begin moving. That delay should be small but you may want to increase it like the so , , and so forth as it will give a natural motion (like cars in traffic). If the leader is redirected whilst she is moving, then her current goal coordinate in the path should be replaced with her current position and the new goal should be pushed as her target. The distance from the previous goal should be deducted from the allotted units of movement allowed to the followers and the distance to the new goal should be added. As a data-structure, you could / should use a queue. Coordinates that all characters reached could be removed from the queue. 

So lets see, what is in the core of all this, what is absolutely needed to get started? Your low level list might be more this: 

Sum up the speed of both particles : (u is the some of their velocites) Draw a line through one of the particles with the same angle as the velocity. ; ; The line is : ; Now use geometry to find the closest point on the line to p2. If the distance in that point is greater than the some of their radiuses, predict no collision. Else move to step 5. Check for the points where the distance between them is exactly the sum of their radiuses and use the nearest one as their point of collision. Calculate how many frames it will take for them to collide by measuring the distance between p1 and the point you found on the line. Lets say it takes 8.6 frames, you can now give them each a fake speed of and they will collide in 9 frames. You can also slow them down(decelerate) them gradually so that it looks more natural. You would need to slow them down to a speed that averages with the current speed at . 

Not all rooms, halls and pathways are born alike. Some games have very plain level design. For instance in some Beat'em Ups VS fighting games, classic RPGs and some other games, the rooms are sometimes very square and planar. If the rooms lack any complex detail that the player is supposed to interact with physically (as in jump on or bump into), you may be able to easy define walls as boxes. In most (99.9%) FPS, Adventure and modern third person RPG games you will likely not get away with that. In these games the level is very detailed and there are lots strangely shaped corridors, platforms, terrain and also maze-like structures that you simply load into the physics engine knowing the player will likely physically interact with it. You may however often want to have a detailed (high-poly) mesh for rendering purposes and a very rough (low-poly) one for physics.