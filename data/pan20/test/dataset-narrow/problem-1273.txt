I personally use Mercurial. There is an asset management oriented VCS from AVID called Alienbrain $URL$ which used to be heavily marketed towards game developers. 

Devices like these are super cheap, and I bet you can get a hold of a second computer to run it on (it doesn't need anything special) so you can capture your game from your game running machine (be sure to have a computer with S-Video out for this cheap version). There is also something like this for higher quality capture - $URL$ but requires USB 3 and is more expensive, but you can capture HDMI and higher resolution. I really see no better option than either of these two. 

Each list contains layout sheets (or character layouts for characters - front, side, 3/4), notes, mechanics notes for animation, etc. Whatever you need or might need. Story/Game production sheet. 

If you're really interested in technical aspects of screenwriting you can also take a look at Screenwriter's Bible - but that one is more oriented towards technical aspects of screenplay formats and structures. 

PixelJunk shooter from Q-Games has nice set of fluids. There is a GDC paper they have published here: $URL$ (PDF!) Jos Stam from Alias Maya fame (now Autodesk) wrote paper on real time fluids in games here: $URL$ (PDF!) And he wrote a simple FFT fluid solver here: $URL$ (PDF!) where he included source in that PDF at the end. 

I am not sure flash allows P2P without Stratus (and v10+ only). But if you want to go socket route I suggest you give Red5 a shot $URL$ . I wrote a small how-to on installing it on ubuntu here: $URL$ It's a bit old, but should still be valid. If I were to make a networked flash game today I'd weigh my options between RED5 and SmartfoxServer $URL$ 

We have a mixed art/tech environment, but hiring process is always the same. Cull interesting resumes and offer candidates a task from start to finish on his own where you give him only a high concept. For programmers a small game that can be made in several days (can use programmer art or stock) where you give him a concept of what it should do and tech to do it with. A really basic game. For artists it's either a spec work or a pitch for concept. They can work on their own on that, can use whatever help they need (google, ask around, whatever) as long as they finish on scheduled deadline. Test consists of first cull if project is actually what it was supposed to be (does it work at all etc.) and where you go through process he used to make it and code review where you discuss his decisions while making it. 

then your delta is: vx,vy You don't need the angle. If you wanted to draw an arrow, use something nominally like: plot( x, y, x+vx, y+vy); I don't know what you're drawing, so if you do need the angle to rotate it (like you're using JOGL) then sure, use the angle. Don't forget if you are using opengl to turn the angle back into degrees, because ATAN2 returns radians: 

but this is scaled according to the velocity. If you want to apply a negative acceleration, first compute the magnitude (already computed as v above) Now you can generate a vector 1 unit long in the direction of the projectile: 

And in this case, that would work because dx is a constant. But in general, dx can be zero, so you usually want to use: 

I actually answered this in your other question, but since this one is here, this is the place to do it cleanly on its own. What you are asking is the trajectory problem. First, consider it neglecting air friction. For an initial velocity v0 and angle a 

You need a reality check if you think you are going to handle instability, tumbling, or anything like that. You don't have the math for it, and it will take years to get it right, as well as massive amounts of CPU you don't want to devote in a game. You can try to fake that if you like. But if you want somewhat realistic slowing down of the projectile, that's relatively easy. 

which is a function specifically designed for this job. But as I said, library functions in Java are hideously slow, and in this case there's a better way of doing it without as alluded to by @FxIII above. If the horizontal velocity is always v0x, and the vertical velocity is: 

If you are desperate for performance, you can even precompute 0.5*g, but the above code will take you 90% of the way there without doing anything too crazy. Benchmark doing this 10 million times if you like, it's admittedly not a huge amount of time but percentage-wise it's pretty big -- libraries are very slow in Java So, if you wanted the angle at which the arrow should go, what you want is 

You are making a 3d engine. You want best of multiplatform worlds. Suddenly you realize that if you want to use Direct3D on Windows machines and OpenGL on OSX/Linux, you'll have to sacrifice supported features of both to least common denominator. Some may use OpenGL across three OS', since it appears to be least common denominator by itself. All is good. Then, you have to port your graphics API backend to Nintendo's GX, you also have to make a PS3 and Xbox360 path. What do you do? Do you design your own API which is least common denominator in itself and write backend implementations for it for each platform or do you write for each platform it's own branch? If you opt to design your own API, do you use bridge pattern or your own voodoo? Where does madness stop where you realize everything and kitchen sink approach must stop and you basically have separate engine for each platform as a branch. Or you stick to everything and kitchen sink and keep platform specifics in backend module specializations for each platform. 

As Justing said, OpenCV. But if you want to get your feet wet quickly, I suggest you try dabbling with openFrameworks It has an addon that wraps OpenCV and you will learn a lot from it. 

I come from a different stream of life (TV Production), but it's basically the same. You need a production bible. But, to put it more simply - you need what you need and nothing more. 

I was very fond of Andrew Rollings and Ernest Adams on Game Design. It goes into depths of interactive game mechanics as related to player, which is the only unique element to game development as editing is to movies. Having said that I'd consider suggesting screenplay writing material as it shows you what connects with people and what doesn't. I'm not talking about linear progress material here like stories, but what kind of characters connect with people, themes, motifs etc. In that area I suggest these: 

What you want is delta y / delta x, because the slope is the rate of change (mentioned in one of the other answers). Note that x is just the position where you are at any moment in time, not dx. 

Ok, so if you neglect air friction, then the x-velocity of the arrow is a constant. First, decompose velocity into x and y components. You could be shooting at an angle of 45 degrees or 60 degrees. So you need launchVelocity and an angle, it's not a scalar. Second, compute everything as double, not float. You're not numerically sophisticated enough to know when roundoff error won't kill you, so don't try. It's not a great time saver in any case. Third, don't use Math.pow, it's slow and not as accurate as multiplying for integer powers. Also you can save a lot of time by using Horner's form (see below) 

You want the angle of the arrow at any point in time. You remembered that in order to compute an angle, there's a tangent. But here's where your thinking started to go wrong: 

The coefficient c is a small number, and friction will tend to slow down the projectile so it always operates in the opposite sign of the moving projectile. You need the direction of the projectile, which is the vector: 

This will have the effect of slowing down the projectile and making it fall short of what it would do with no air friction. the higher your constant c, the shorter the trajectory. If you have wind, then just add to vx in your 2d game, in either + or - direction. If you really want to show the projectile tumbling once it moves slowly enough, ask another question, but that will be a discussion of how to fake it, not how to do the real physics. If you want to see just what you are getting yourself in for with simulating the drag on a projectile, this should be a survey paper that will show you the different approaches out there. $URL$