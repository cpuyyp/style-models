Now, we can move onto . Kinda... You're immediately recreating the target range at the beginning of this sub, so just pass in as a range instead of a string. That changes the event to this: 

The Awful I'm chucking this under awful, but it's really not. It's simply the worst offense. You're using magic numbers for the Divisors. Minimally, use constants. For maximum flexibility, pass them as arguments and calculate the GCD for the first test case. You could even set them to default values using parameters as not to break existing client code. 

Doc Comments Well done! I rarely see a single method so thoroughly documented with XML doc comments. There's a catch though. Be careful about just how much you do this. It can really obstruct the readability of the actual code. I count roughly 20 lines of documentations here. Is all of that really necessary? I don't think it is. For example: 

This looks really good to my eyes. You're decoupling, setting good boundaries, using great style and meaningful names, and it seems that you did the simplest thing that works (to me at least). This is the only thing that strikes me as being odd. 

I'm not sure this counts as a Code Review answer, but I wanted to at least share what I found out after nearly a day of fighting with this... 

Allowing these values to be specified makes the class much more reusable and specifying default values makes it easy to leave any current client code unmodified. Which brings me to the fact that I really don't like that client code can arbitrarily mutate these values through the property setters. I really believe these should be immutable. Once the class is instantiated, nothing should be able to change the number of characters that are required. It's the kind of thing that you want one and only one chance to set. If you have a good reason to expose these through a Getter, ok, but I'm doubtful that even that is necessary or useful. I would go so far as to argue that allowing client code to have access to these values breaks encapsulation and fails to hide information that should be hidden. Once you've removed the setters, go ahead and declare the private fields so the values can't be changed internally as well. 

This is terribly nit picky, but the whitespace is inconsistent. Give this line some breathing space. 

I wanted to talk about your using Ninject as a service locator, but I can't even begin to describe how bad is. I don't even know what it is that you're trying to do here. In order to fix this up, you'll need to take a few steps. 

3 gets called with a null arg for . 3 calls 2. 2 calls 3 again, only this time, 2 gave 3 a new List to work with. 

If you inject the instead of "newing it up" in the constructor you should be able to solve this. An interface may not be entirely appropriate, but a generic base class would be. 

A small note on naming: Being new to your code base, I have no idea what represents and worse, looks a lot like and it confuses my eyes. As a rule of thumb, don't abbreviate names. Spell them out so that the maintainer coming behind you understands what everything is. 

DiffListener.cs This is the class performs a diff that is roughly equivalent to a and caches them for later use. 

Replace every instance of with an instance that gets injected through the constructor. If you need it to be short lived, pass a factory class instead. The number of arguments each ctor takes will grow as you go up the chain towards your composition root. That's okay, and in fact, is a Good Thingâ„¢. Don't pass anything from Ninject to anything else. Once you get all of your dependencies up and into your composition root, then bind them all with Ninject. Let the IoC do it's magic and recurse down the dependency tree. 

The case here makes me think that isn't really a . It only implements one of the command types and you added that command type specifically for this implementation. At the very least, don't let it silently fail. Again, raise an error here. 

All in all it's the most readable bf I've laid my eyes on though. However, don't take my omission of commenting on the actual code as an indication that it was done right. Truthfully, I've no idea. I'd have to brush up on Turing machines and spend some time writing something simple just to get into the right mindset to decipher this. I mostly wanted to post an answer so that maybe it would prod someone else into taking a serious look at it. 

This works great for now, but what happens when I want to expand it to include other document types? I'm thinking a enum could go a long way toward making it easier to extend, as well as improve readability. 

Finally...... Performance: You can set the recalculation of the sheet to manual prior to running the code. It will only make a large difference if your code has a lot of formulas, but it's worth a shot. Just be sure to set it back to in the "CleanExit" part of your routine. 

I was inspired by Me How's question to see how far I could push an imitation of .Net's Enumerable Class. The new functions can obviously handle Collections, but can also handle any collection-type object whose items have a default value. If a 's items don't have a default value, Runtime Error 438 "Object does not support property or method" is raised. So, things like and work, but doesn't. and only differ by one operator, so there's some duplication there, but I don't know how to refactor it out. also seems inefficient to me, but I couldn't imagine a better algorithm. So, those are particular areas of interest to me. Suggestions for which features to add next would also be appreciated. Enumerable.cls 

This is very clean, very nice code. Unless you've profiled the code and identified a slowdown somewhere, you're done here. Move along. 

I was going to suggest that you use a header element, but then I realized that this isn't a header, it's a nav element. You should use the semantically appropriate elements whenever possible. s are supposed to be for formatting purposes, when there is not a more semantically correct element available. I like the choice of an unordered list for the links themselves though. Now, this is a , but you didn't add the tag. 

This should format just the lists within this particular list. The selector is read as . More information can be found in the manual. 

Also, although the factory was a nice idea, you're using an IoC and can do the same job with Ninject by telling it what constructor arguments to use. This means you can completely remove the factory class and interface. 

This involves unnecessary over head. You see these kinds of things in code that is being manually tested instead of properly unit tested. 

But minimally, you should replace with a constant value so you never accidentally change the delimiter in one place, but not the other. 

On another note, in your original implementation, you never used the parameter you passed to 's constructor, or it's related private readonly field. 

Which makes me want to mention that I really hate Hungarian notation. I like this mixed and reversed notation even less. The IDE will tell you that it's a , but if you really just need your code to spell it out, just spell it out. At least be consistent. 

I don't think it's a good choice. Doing this bakes magic numbers into your code. This is a prime candidate for an Enum. 

Also, you say you're repeating this logic elsewhere in your code. You've not shown it, but I highly recommend extracting a new class that is responsible for this logic. You can then inject it into these other classes via their constructor and any changes to this logic truly only has to occur in one place. 

Which brings us to the loop. Friend, that is just awful. You've intentionally created an infinite loop. Once the is called, it never exits. Never. The only way I can figure to kill this is to open the task manager and kill Excel. What you should do is have a loop that exits when the game is over. For example, consider this code where is a function that returns a boolean. 

You're swallowing every possible exception with nothing more than a message in a log file. You should figure out which exceptions you can gracefully handle and catch only those. 

This is a useless comment. If the maintainer doesn't know the difference between and they can look it up. 

This differs only in the order of the characters, but I'm too close to it at this point to see a better way to clean up the control logic. Advice on it would be appreciated. Version 1: 

You don't show it here, but I guarantee you're splitting on whitespace. Which is wrong. Condsider the name . You're going to cut off the second half of this person's last name. This is notoriously hard to do in reality. Names don't just fall into our sense of what "good data" looks like. Please see Falsehoods Programmers Believe About Names. What you really need to do is make sure your input makes sense. If it doesn't, you're eventually going to have problems. Your input needs to be in the form of fixed width columns so that you can do this manipulation based on the position of the character. 

I see that there are a few other people who have tackled Project Euler Problem #3. I hope you're not all sick of that question yet. I've not taken a look at those yet (purposely), but am about to now. I feel like I did a pretty good job on this one, but you tell me. How can I further improve this code? I'm particularly interested in how it could be made even faster, but it seems to already be a pretty quick implementation. My first version took over an hour, this one runs almost instantly. I'm also interested in how I could have used a instead of an array, if you feel that would have been a better data structure. 

The modifier only means that we can't assign the identifier a different reference. Nothing stops us from modifying the internals of the array. I'd reach for a ReadOnlyCollection of some kind. is designed to be a base class, so this gives us one more reason to extract these useful snippets into some bit of reusable code. 

Note that I gave the join conditions some breathing space. It was really difficult to understand as a one liner. In SQL, new lines are your friend. Use them liberally. Personally, I like to make sure that all keywords are the first word on a newline. I'm going to pick on just one more alias... 

Otherwise, some maintainer like me is going to come behind you and remove what looks like dead code. Now, there seems to be some debate about whether or not to declare empty finalizers, but I found a great analysis of the topic that you may be interested in. The TL;DR version of that piece is below. 

It's not an entirely thorough review, but that should give you a good start until someone else comes along. 

First thing's first. Indent the code. Everything inside of should be indented one tab or four spaces. Same thing with code inside the . 

Minor note on consistency. You use a newline for your and , but not your . Otherwise, it's pretty straight forward. I don't see anything smelly about it. 

Which begs the question, why set a default value at all if you're just going to overwrite the value a split second later?? It doesn't make sense to me and I would remove that code. At the least, I would make the overloaded constructor call the default constructor to dry things up. 

As for a simpler method for getting a byte at a particular place in a string, I think it's a wash for VB6, but there is an alternative. Create a byte array then return the byte at the index you want to retrieve. How this is done is different in VB6 vs. VB.NET. VB6 The function to return a byte array in VB6 is StrConv(). 

But arrays might not be the best solution here, as you have to hard code the number of elements in the array. Note that in your code, you ask the users for five numbers, but only use three of them to determine which number is highest and lowest. Bad juju. What you want is a list. 

You're already aware that this is a linear and slow search method, but as you pointed out, it shouldn't affect overall performance much. What I wanted to mention is that there's a lot of here. You're already referencing the library, so you should go ahead and strongly type these if you can. 

This is just begging to be a method called . It should return some object that represents those three values in some sensible and well named way. I apologize that I've left s critique without any code examples. Normally I would provide some, but it's been a while since I've written any Ruby. It's better in this case that I leave you to attempt a clean up yourself. Try to: 

Whenever possible, avoid both static methods and "newing" objects inside your methods. Both make tests difficult to write. 

Which works, but isn't great. I would prefer "not Any" here. I find it's good practice to get into the habit of using . It's just more readable IMO. 

Will you remember what that means 6 weeks from now? 6 months? 6 years? No. You won't. It's often been said that the hardest thing in computer science and programming is naming things. It's true. It is the hardest thing, but it's also the most important. It's been my experience that the easy way is never the right way. You took the easy way out here, when you should be coding like the programmer who touches the code next is a violent psychopath who knows where you live. 

So, you have a couple of issues here. First, your question... What I've done in VB6 (which your question was originally tagged as) is create a module that is responsible for reporting errors and logging them. I would imagine seeing your error handler look something like this.