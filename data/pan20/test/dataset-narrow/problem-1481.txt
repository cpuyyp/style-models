Ask them to switch their screens off. They don't like it if you do it too often or for too long but it's surprisingly effective, saves you having to repeat yourself unnecessarily and forces you to try to make your instructions clear and concise. If you can't see their screens you can always tell by the glare from their screens on their faces who hasn't followed instructions. 

Websites such as $URL$ and $URL$ are great for students to practise this type of competitive programming activity. In order to prepare them for that type of competitive challenge it can be good fun to create opportunities for competition and collaboration early on when you're introducing new programming concepts. For example: 

Write some code that is unfinished with some deliberate mistakes and share it with your students on GitHub Get your students to clone / download your code, find and fix the bugs then talk about the problems with having so many different versions of the same code in the classroom. Get your students to fork your code into their own repositories and commit their own changes. Discuss code and commenting conventions and why they're necessary (e.g. PEP8) Get your students to go back and recommit their code in line with the conventions discussed Ask your students to issue a pull request on your code so that their changes can be contributed to the original resource. 

I am going to take a shot in the dark here and make an assumption about your question: your question is about programming and the "test" is writing a program. Under that assumption I would answer with a loud "yes" - you'd want students to be able to reason about programs and convince themselves of the soundness of their reasoning, not just go by trial and error until they converge to a working program by sheer chance. That's, after all, no way to program in real life. On the other hand, I would also have a lab test to measure the student's ability to actually compile and run a program and/or launch a debugger - after all, once you've produced a correct program you still need to compile it to be useful... 

As for CS, in your original question you say that you "have no problem understanding what Computer Science is and what it includes", but let's talk about CS as well. The definition from the report you pasted in your own answer is good enough for me: 

Problem solving and computational thinking is a hugely transferable skill in itself. Almost any science / engineering route through academia into the workplace is greatly benefited by the ability to write / modify some code that will process data efficiently and generate exactly the sort of analysis / evidence that you require. For example, a substantive part of a Psychology degree involves collecting and processing statistical data. Even without the logical and analytical benefits of CS, the ability to write code to automate the analysis of that data immediately gives you huge advantage over peers without any CS skills. 

Once they've been through that process in a safe and controlled environment they'll be much more confident joining in with an open source project. It can be intimidating jumping in for the first time, no matter how friendly and supportive the contributors are. You might also want to look at GitHub Classroom which automates the process of creating, sharing and collecting programming assignments from students. 

Disclaimer 1: I'm not sure if this is more of a comment or an answer and Disclaimer 2: this is not really my field, but I'd be inclined to answer: no. Firstly, I don't think it's necessary. I think the intuition behind the concept of transform (at least as in Fourier or DCT) is within the grasp of most high school kids that know some trigonometry: you can probably get away with drawing a simple function, decomposing it into sine waves and writing down their phase and amplitude while waving your hands a lot. You'd then proceed to reconstruct the original function by means of summation and persuade the students that the representation in terms of 4/5 phase/amplitude coefficients is "more compact" (finite, even) than its representation in terms of infinite pairs in $R \times R$. I'd argue it's also not possible because the DCT is also very much one of - if not the - working principles behind JPEG, differentiating it from classical lossy compression techniques. Operation in the frequency domain is ultimately the reason why *PEG performs subjectively better than, say, resampling and requantizing at 240x180@16 colors, which is essentially a much naiver lossy compression method that operates purely in the space/time domain. Note, finally, how the excellent Smith handbook - along with probably several other resources - explicitly calls JPEG “transform compression”. 

For a general introductory course, the answer is mostly practical. High level concepts are abstract and difficult to grasp. Low level concepts may appeal to the strong math student, but can be a road block to the average student. I see value in focusing on code that students can write and run and see results. This is more likely to hook them and encourage the students to want to learn more. However, we cannot avoid the low level concepts and CS is all about layers of abstraction, so we cannot honestly give students an introduction to this field without hitting bits, bytes, and abstraction. Students in an intro class should see the practical value of understanding bits and bytes. These are terms used in consumer products and data plans; my students appreciate learning what a megabyte is and how much information it can store. I don't get many "when will I ever need this?" questions. 

I don't think that student learn that much from just running someone else's code without going through it. Copy & pasting can be really useful for sharing code that has been deliberately 'broken': you can demonstrate / explain code that is working and then introduce deliberate mistakes for students to find and fix when they copy / paste. That way they get the speed advantages of copy / paste but they also have to engage their brains whilst getting experience debugging. Alternatively, you can give students code to copy that they then have to comment / adapt / extend. 

I tend to avoid multiple students working on the same code simultaneously (Google Docs style) because it's really difficult to assess what has been done by each student or to stop one student dominating whilst the other doesn't understand what's happening. Either that or students tend to get distracted by what the other is writing. Having said that, you could try: 

I don't see how this follows in general. It depends, of course, on what the test is testing: if the test is about finding the one incorrect value in a 2000-entry trig table I would expect a computer would be of help, but that's not what a CS test usually looks like, is it? I expect a good test would in general measure the student's understanding of a topic, not their ability to mechanically carry out repetitive tasks. 

Further rule of thumb: if there is a big $O$ somewhere, or a proof by induction, or a graph, or an inductively generated structure, it's probably CS. If kids who are good at the IT and DL parts fail miserably at it, there you have the conclusive proof. 

The way I understand the report and especially the bit you pasted in your own answer, the key to IT is in the T. It's IT if it has a clearly technological approach (and by necessity the treatment is at theoretical level rather than practical). 

The easiest way to set the conditions so that they can all be reached continuously in every class period is to make the conditions so easy that all can achieve them with very little effort. However, this is not at all motivational and sells the students short of being stretched, inspired and challenged. Dumbing-down the curriculum so that all succeed can get great results on paper but is counter-productive in the long term. A good lesson almost should contain some objectives that can be reasonably achieved by all students whilst also featuring others that create scope for curiosity and intrigue for the fastest/brightest learners. Any teacher knows this isn't easy: 

Ultimately, I don't think it's a question of choosing a particular type of student to pitch the level of difficulty to. As teachers we have to be deliberate in our planning and delivery so that there's something even the least confident student can leave having achieved but also some bait dangled tantalisingly just out of reach for those who want to discover for themselves. All that, whilst not neglecting the majority of students who find themselves in the middle of the two extremes. Realistically, my answer to your question is that we can't guarantee every condition will be reached continuously in every class period for every student. I can't anyway. But it's worth giving it a try - it makes teaching more fun as well as more productive.