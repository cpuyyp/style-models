Ideally you actually create a class which gets instantiated with the input string and where you can call on which will return the next token. The tokenizer should be passed to the parse method. I just used simple because it was quicker to show the basic concept. 

I'd prefer the first method because it's making more efficient use of resources (provided the async methods you call are really async and not just wrappers around synchronous methods) and it also looks cleaner. To quote from this MSDN blog: 

then this is an indicator that your abstraction is flawed. I'm not saying you should never ever do it but more often than not it indicates a design problem. Another point is the empty interface. An interface is like a contract - so what does an empty contract mean? Not much really. Don't throw generic . In your case an or maybe your own defined would probably make more sense. This would give the user at least some way of catching specific exceptions. 

In general your code is quite hard to comprehend due to the bracing style and the single letter variable names. A bit more spaces and more meaningful names would do quite a bit for readability (I've kept your 2-indent spacing) and also remove the need for most of the comments: 

Standard naming convention in C is usually . You should be using rather than I would consider making the return value deterministic when the new size is 0 by always returning rather than the implementation defined behaviour (which could technically be a pointer which is not but still not allowed to be dereferenced). guarantees by spec that is legal. 

Note: I have taken the liberty to remove the static from all fields and just return the of the list rather than keeping track of the length separately. When serialization requirements get more complex it can get problematic but for simple stuff it's hard to beat. Sample XML file: 

You have some methods to copy individual elements out of the array containing the encrypted data (, ) but you manually fill it in in the encryption method. Also you have delete the IV and tag to get just the data. I would encapsulate this in a class where you can set these properties individually and it deals with the layout of it. Something along these lines: 

Since it hasn't been mentioned yet: The third version with the function and the local variable to store the length is best since it will only iterate over the string once. Of course this could be achieved via a macro as well but others have already explained why the function is the better choice 

It makes it a lot easier to figure out what each variable is meant to be used for (especially for others). 

Property names like are completely useless as they in no way indicate the purpose of it's intended usage or what it represents. Given that it's probably bound to a radio button it means it's very likely some sort of option to chose from. My guess you could replace all those properties with a single enum property which states the option which has been chosen. At the very least all those properties should be renamed to something meaningful. You should move the comparison into a method on the like . Then your main loop becomes: 

Your implementation suffers from the fact that the user of the stack is required to carry around several pieces of information around ( and ) which can make it easy to get wrong. Also your struct does not actually represent a stack in itself, just a node in the stack and one of them just happens to be the head. For almost any data structure your need to keep meta data about it because it will usually make operations on the structure more efficient. Also you should have a single object which holds the information so you can pass it around easily. Last but not least you should think about the API of the data structure and what the user really cares about. In your case the user does not care about nodes or that it's a linked list. The user cares about that he/she can push values onto it and pop them of later. Therefore I suggest the following design: 

Both and are and should therefore be wrapped in a block to make sure any unmanaged resources are properly released. Prefixing all your local variables with smells like hungarian notation and is generally discouraged. It adds not value and just clutter. Your variable names should indicate what they represent and not what type they are. In C# land the common naming convention for methods is and not . It pays to stick to general naming conventions for the ecosystem you are working in as it will make your code look more familiar to other developers. 

You don't have any unit tests (at least none that I could find on github). You should start writing them. I suspect it will be a PITA to do so which is good since it will highlight refactoring targets plus it will provide regression tests for when you break things while refactoring. Yes it means you'll have to invest time in it without making actual progress on features but if you'd like the project to grow and more people contributing to it you can easily put yourself into a world of pain if you don't. Check all your / modifiers and make sure that only things which need to be actually are. In large blobs like these I often find public methods or properties which aren't used anywhere outside of the class (or not even there). Anything public is a lot harder to change since it will potentially affect a lot of calling code. Things which are private can be changed around at will (as long as you don't break anything, see unit testing above). There is no documentation on the public interface of the class so you are pretty much resigned to read the code if you want to use it. Related to this: The public interface of this class is very broad and it's absolutely not obvious how it is meant to be used. I assume methods are meant to be called in a certain order and in certain states or otherwise things will go wrong. Also having a public dictionary called which is apparently everything but constant seems like an oxymoron to me. I tend to start refactoring these kind of things in baby steps. A good candidate seems to the be . Code like this: 

This encapsulates the classification logic and makes the code easier to read. If you have control over the you could also use attributes to decorate the values instead (plus adding some generic code to obtain classification based on the enum value attributes). The advantage is then it's obvious that you need to add something when a new enum member gets added. I would consider extracting this condition into its own method: 

I'd use (LINQ) to obtain the maximum. Less code to write and does the same. While it is ok to use single letter variables for loop counter is not really a loop counter. It's the index of the current element so I would rename into . Consider changing your last while loop into a for loop. This avoids mutating the state of the array (saves you a read and write on every iteration): 

You can use reflection to query the members of both types and match them by name. Something along these lines: 

The return type of should be because that's what it returns. You can also get rid of in there and use in its place. In you asked some questions on the return value. I guess you want it to indicate whether the initialization was successful or not - which is if is or not so you can just write this: 

What you are doing in your second method is basically calling the async methods in a synchronous way just to then in turn wrap it into a task. This will have scalability issues because it's using up a dedicated thread (at least in the current implementation of the task library) while the async methods you call might have more efficient means of achieving their asynchronicity (like IO completion ports or timer callbacks)