Following is my solution for your reference. It's much less code, and I think it's functionally equivalent to yours. 

I don't intend to faithfully follow the interface specified by the standard/draft, because it's too cumbersome. Specifically, I didn't implement some methods and modified the signature of some others. Refining memory order requirements is left to future work. 

does not support dynamically updating element priorities. This class template extends it by allowing updating priorities of elements in the heap. Any comments are welcome. In particular, I hope that the implementation is at least bug-free. Original code and unit test can be found here and here. 

This is working for me, but I wanted to know if there is a better way to do this? Info: This is used in this way: 

The expected behaviour changes depending on what it is I am doing, sometimes I want to see Login success when I user values that exist in the database and other times a single error on either the username/password or both. The behaviours that I expect occur. I wanted to know if there is a better way of doing what I currently am? 

This doesn't help too much here, but might make things more obvious in the long run. Now, considering performance, the choice of a list of integer will make your program hard to optimize. Functions such as this will be really slow : 

But those are all minor nitpicks. The main issue, for me, is that the whole design is unnecessarily coupling orthogonal concepts. Decoupling stuff There are several concerns that are mixed : 

It is a lot more complex now :) Here are the main takeaways : An interpreter This is a major technique in Haskell : transform an effectful computation into a pure computation that is then interpreted. You can use the or packages for that. You now have the game logic running in the monad, that can run effectful instructions encoded as the type. Those instructions are then interpreter by the function. You gain several things from that move : 

I have created a test login page that, as most do, takes in two values from the user (username and password) and the processes it. For this I have opted to use jQuery and AJAX to pass the results to a separate page to be processed, checked and validated before allowing access. My main front end uses Twitter Bootstrap v3.3.5 and jQuery v1.11.3 (I know there are newer but it's what I am used to until I learn the newer one). The front end looks like this: 

I made a tool set to facilitate bit manipulation as follows. Any comments are welcome, be it about the interface design, the implementation, or even the naming. Also, I want to make sure that the tool set is not lacking something for use-cases I failed to catch :-) Original code and unit tests can be found here and here. 

I'm trying to write a lock-free implementation for atomic shared pointer. Basically, there are two class templates and , each implemented in a header file of its own, for a total of two header files. The algorithm is inspired by the split reference counts idea used to implement a lock-free stack in C++ Concurrency in Action Sect. 7.2.4. This is my first time designing and writing lock-free algorithms, and I'm not confident. I want to have my code reviewed for possible flaws in the algorithm (quite likely ~>_<~) and room for improvement. Note that 

Warning : I never played this game, so I might be wrong. Syntactic nitpicking There is quite a bit of syntactic noise, that you can catch by using . For example : 

I believe the intent here is not properly encoded, as you might modify one of the two lines, and have both branches (or none) executed. I think that the following makes it more obvious : 

I am unfortunately no performance guru, but will take a stab at this as I repeatedly had to make programs faster, and there are no answer yet. A nitpick : I would have used a type synonym for and : 

Sometimes, we create a one-dimensional object, but want to access it in a multi-dimensional way. For example, you can access an array object in a 2x2x2 way. So, I made a class template to make this easy. Any comments are welcome~ Original code can be found here and documentation here. 

The syntax for specifying multi-dimensional types in C++ is messy. For example, to specify a two-dimensional , one has to write . The syntax doesn't scale. So, I wrote a handy tool that provides easy syntax for this. Any kinds of comments are welcome ^_^ (original version of the code can be found here with unit test code here) 

As lists are linked lists, and indexing will traverse all previous elements. Profiling shows that this is the most time consuming function. I would suggest one or a combination of the following solutions. Using the monad The ST monad is a strict state monad. It is pretty useful for encapsulating value-mutating algorithms in referentially transparent functions. Basically, you would write algorithms the way you would in C, and the resulting code should be quite efficient. The type might be a good candidate. Using a library known for its performance A library such as or , both are known to be able to generate crazy fast code when the right rewrite rules fire. is probably overkill, and hard to understand. You can alter vectors in the monad too. Change your representation The function takes most of the time. It has an implementation for a single case (), and all other cases rotate the board, run a , and rotate it back. It might be possible to either have specialized implementations for each case, or, perhaps better, to use function composition / modification to skip the rotate / rotate back operations. 

I am creating a system for a client that loads information from an XML file and then parses the information where needed. For this, I have got this class: 

I am using PHP in order to create a custom wrapper for including files, for this I have written this class: 

I have written a class that connects to a database using MySQLi and has methods for the connection itself and returns the instance of the MySQLi class. This works, but feels a little "clunky" and can be a bit slow, can someone help me to improve this? The class is as follows: 

However, it makes things a bit more complicated to lay out at first ... All players are handled in the same way There is now less code duplication (the and functions were almost identical), and it would probably be easier to increase the player count. Pluggable strategies Now all strategies are pluggable, not just that of the dealer. Well ... I basically said "rewrite your whole program in the way I like", and there is definitively a question of taste here with the whole "free monad" or "operational" decoupling. You gain nice effect separation with "magical behavior" that might turn into cargo cult programming ... There is also the problem that I turned fixed fields ( and ) into a , which might return Nothing.