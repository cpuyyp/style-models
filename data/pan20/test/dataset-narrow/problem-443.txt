Without being able to actually test (I can only guess what , , and are), something along the following should produce your desired of dependencies: 

On my machine, (10k) takes about the same time as (1M) (less than a second), whereas (100k) doesn't even terminate within a minute. Note that we can now also any list, not just s (due to the removed type annotations). If you want to pass an empty list in F# interactive, just use . I reversed the accumulator and 'real' parameters to make use of the concise ality. 

Personally I like leaving out the parameter (a.k.a. eta-conversion) to facilitate moving functions around (as we'll be doing shortly). This is a disputed topic, however. Similarly, can be rewritten: 

Personally I don't like prefix '_' on identifiers. The rules for using '_' as a prefix are complicated. Even if you know the rules not everybody that reads your code will. 

If you want to release all the resources and re-create the default versions you can manually destroy all the objects. Potential Leak. 

Only seems to have any purpose. is used locally in one of the constructors and flag is set to true on error for some reason but plays no other purpose. You have a copy constructor using a vector. 

Technically pthreads is a C library. Thus the callback function you pass to pthread_create() must be a C function with C linkage. To do this in C++ code the function must be declared as extern "C". So it may work, but it is non portable and you just happen to be getting lucky that the compiler is using the same calling convention for C functions as for C++ functions. But because the C++ ABI is deliberately not defined this may not hold for all compilers. Once you are in your function it is perfectly legal to use all the C++ tricks. I like you personally like to use the to convert the pointer back to its original type. But I believe I am in the minority on this one and most people use static_cast<>(). There have been several long discussions on SO about the usage (check there for details). Some minor modifications to make it legal: 

which reads nicely as "there exists a tuple such that the second element equals zero". Then, using the fact that sorting lists does not change the elements, i.e. the outcome of , get rid of all sorting 

For splitting in linear time, there is a 'trick': moving two 'pointers' while keeping track of the visited elements (). The second pointer () always skips two elements while the first one () skips just one. The function needs to be called with , i.e. both pointers at the first element: 

we arrive at "a matrix is feasible when there exists a feasible column, i.e. a column containing no significant zeros" (significant = q < 100). Finally, use to print s and for unused : 

Internally it uses std::vector<> (by default) but the elements in the vector are organized into a binary tree structure for faster sorting and organization. (ie element 0 is the root, element 1,2 are children of 0 etc). If you want to do this manually you can your own container and the following methods: 

This allow you to write a constructor in terms of another constructor. This then allows you to correctly use the initializer list in the constructor and prevent members being initialized then immediately being overwritten. 

Why are you nulling the whole array. You are just about to write over it. Seems like a complete waste of time. 

As mentioned above (but without the container code it is hard to tell). Well this test work for the iterator. 

Yes, this is tail-recursive. Just annotate countWordsInFile with and the compiler will check that for you. Btw: why not name the method ? The Scanner is not limited to read from files. 

As this algorithm is tail recursive lets tackle another problem: having recursion instead of loops often makes it easier to reason about a single step but more difficult to see whether one step is (partially) undoing effects of the previous one. Here, the remaining are ersed in every step. This is an O(n) operation (n = length of the list), doing this in every step means the overall complexity is O(n2). It seems the result could also be computed by 

I'd consider the code there to be "correctly written" (I'm in no way linked to the code nor its authors.) If you want to rewrite your method to work directly with s I'd recommend using their full power: 

Because the language did not have the features required to implement modern smart pointers. The was the first attempt at a smart pointer and it worked to a certain extent it just had limitations. It took them 8 years to improve the language enough so that smart pointers could be implemented properly. 

You TreeNode methods are not : Mark methods that are non mutating as . Return objects by reference to avoid a copy operation. If you don not want to give access to the underlying object then return a const reference to the object. 

I think you have a classic case of not knowing the standard. What you are writing is generally already available via either a normal constructor or a standard algorithm. In a few cases I would have just implemented a minor wrapper class that could be used by these facilities. Lets have a look at a few and see how you could have utilized the standard: 

A concise and idiomatic (I think) implementation (which happens to be tail recursive) but without your optimisation would be: 

An observer is now able to process as soon as they are found (as opposed to wait for the completion of the computation yielding all results at once) and can unsubscribe anytime which in turn will cause a cancellation of the result computation. If some function still needs all at once there's always and friends. In addition, possible parallelization is now obvious (e.g. using Parallel.ForEach) but still not trivial (hinted at by the inclusion of TaskCreationOptions and TaskScheduler, sensible options for Parallel.ForEach not included). Also clients must then be prepared to consume 'out-of-order' search results. Potential further improvements: 

Whether that's equivalent to the paper, I don't know. For sure it is easier to understand than the original version. 

It basic looks like you use as a container then other classes just pull all the data from it and then manipulate it directly via the API. This leaks your implementation extraction. I would reverse the design. The class knows how life is run. Then it updates the GUI via an interface that you provide. 

So this page is 200K bytes long. I don't think its a good idea to load the whole page into memory then parse the page. 

In C++ an empty parameter list and a parameter list is the same thing there is no difference. It is more idiomatic to specify this as: 

Design Issue Creating a new thread for every connection is not a good idea. Creating a thread is expensive. Also a single thread can easily handle thousands of connections, so utilizing a single thread for a single connection is very wasteful. Also the way you are using the threads is all wrong. This should never happen.