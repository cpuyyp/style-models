When the routers on either end of a BGP session first boot, the session between them is in the Idle state. The BGP session remains idle until a start event is detected. Typically, the start event is the configuration of a new BGP session or the resetting of an existing BGP session. At boot time, the start event is generated by the router as the BGP session is initiated. After it detects a start event, the BGP host sends TCP request packets to its configured BGP neighbors. These packets are directed only to neighboring interfaces that have been explicitly configured as BGP neighbors. Upon receipt of the TCP request packet, the neighboring host generates a TCP response to complete the three-way handshake and establish a TCP connection between the peers. While this handshake is taking place, the BGP state for the connection is Connect. If a TCP timeout occurs while the originating host is waiting for a TCP response packet, the BGP state for the connection is Active. The Active state indicates that the router is actively listening for a TCP response and the TCP retry timer has been initiated. Once a TCP connection has been established between both ends of a BGP session, the BGP session state is OpenSent, indicating that the originating router has generated an open message. The open message is an initial BGP handshake that must occur before any route advertisement can take place. Upon receipt of the open message, the neighboring router generates a keepalive message. Receipt of the keepalive message establishes a point-to-point connection, and the BGP session state transitions to Established. While the originating host waits for the keepalive response packet, the BGP session state is OpenConfirm. Source of the information 

fails on these three requirements and is therefore not a suitable tool. A quick search did not revealed any relevant alternative, so I went the Scapy route (Scapy is a Python library and interactive tool allowing to freely build and manipulate network packets). Here is the code I used to successfully test CAM table overflow in a GNS3 environment: 

I will now take each of these point individually. Knowing where difference with real gears lies For performance reasons, a lot of switch things are actually not part of the IOS code but are implemented in hardware. This includes the ARL, or Address Resolution Logic, which provides all the methods to add, remove and lookup entries in the MAC address table. Therefore, for the NM-16ESW module to work in GNS3, Dynamips had to reimplement all these normally hardware provided services, or at least push this far enough to allow an unmodified IOS to run on it correctly. The sad thing is indeed that this is unfinished work, as stated in this module's source code header: 

This launches the function every 15 seconds. What this function does is to scan the whole CAM table and check a hit flag associated to each MAC address: 

Understanding what you can really expect As explained in the introduction, a lot of literature explains this attack as "making the switch behave like a hub". While a good overview for the layman, this oversimplified description is wrong from a technical point of view. To understand I will recall how a switches works under normal circumstances, what's the algorithm behind them, to ensure we are all on the same page: 

Now, let's see how a switch works when the CAM overflow condition has been triggered and he did fallback into the so-called "hub" mode... Actually all of this is just nonsense: there is no hub mode and the CAM overflow triggered strictly nothing. The switch just continues to work as it always did: 

Quagga losing routes was my primary reason to switch to bird. Over some time I am running a corporate VPN with hundreds of branch-offices, linked through the ipsec/gre/whatever point-to-point tunnels. On some branch offices I was using the FreeBSD/quagga setups. The issue was - in a OSPF router chain like A - B - C the prefix originated from A was seen on B, but not on C. After months of struggling, finding no solution, and seeing this situation spontaneously arises and clears it self with quagga (and with no proprietary vendors like Cisco or Juniper) and various prefixes, I switched to bird. Now the problem is gone. You may call this lame. You may say I should report this and help communnity to fix it. But for me quagga and it's bugtracker seems to be for a long time some kind of post-nuclear desert, where sporadic groups of friendly developers may be encountered, but more likely you will die of dehydration or some bug. Bird is developed more intensively, and it's mailing list is more populated with developrs and practical help. 

I've already posted this question on the Juniper community forums, but, unfortunately, both replies authors thought that I need the IGMP snooping feature, not the VRRP, so I should mention that I don't care at all about the IGMP snooping and I'm showing it here merely to show that this isn't the reason of VRRP packets getting blocked (at least as I understand it). I've also tried to enable the IGMP snooping (in case I understand it wrong), it gave nothing. I also tried to experiment with various spanning-tree protocols (as far as I know this has nothing to do with the multicast, but just in case - as I was out of options, to see whether I do understand anything) - I tried rstp and vstp, and this also gave me nothing as I expected. So, - prior to buying the support for EX4600 and asking in JTAC, I decided to try once more and ask in the community - how do I make the VRRP work in the EX4600 default vlan ? I'm aware about the solution "move everything into non-default one", but this requires outage, and furthermore, I want to solve this, - after all the default vlan is just a vlan. 

On incoming packets, if and only if the source MAC address is not present in the table will the CAM overflow have any effect since the switch will have no free slot to add this new one and will therefore skip this step. If the address is already present in the table, the switch will reset its aging timer as usual. On outgoing packets, if and only if the destination MAC address is not present in the table will the switch indeed send the packet through "all" of its interfaces. If the MAC address is present in the table, the switch has strictly no reason to act weirdly: it will simply proceed as usual and send the packet only through the port associated to the MAC address. 

This flag is re-enabled whenever the switch receives a new packet from the corresponding MAC address, keeping active addresses in the table. You will have to take this behavior into account in order to design a successful CAM overflow attack: 

Using the right tool The tool classically recommended for CAM table overflow attacks is (from the dsniff project, unmaintained for years). However, this tool makes me the effect of a primitive barbarian from some fantasy story: brutal, inefficient and unreliable. This tool generates packets using fully random MAC addresses generated on the fly. This is wrong for two reasons: 

The switch receives an incoming packet on a some port, The switch then checks if the source MAC address is already stored in the MAC address table. If it isn't and there is a free slot, it records this new MAC address associated to its incoming port (and by the way if the address is already present but associated to another port, it will update the record with the new port). This is also the occasion to reset the aging timer associated to this entry, no matter if it is new or not. The switch then checks if the destination MAC address is already stored in the MAC address table. If it is, then this is all good and the switch outputs the packet on the interface associated to the matching CAM table entry. If it isn't, the switch will output the packet on all interfaces except the incoming one (all interfaces belonging to the same VLAN + trunk ports as long as this VLAN is not pruned). 

in the enable mode. Since clients connected to this switch can reach Google public DNS, they have information on where to look for the gateway. Switch from the context of the network connectivity of it's management interface is an ordinary network host. 

I have a Juniper EX4600 switch which I'm using for host connectivity (obviously). Now I need to set up a VRRP/CARP between two hosts that are in the same vlan, and it's the default one. Surprisingly, it's not working. And the reason is that these two hosts simple don't see the multicast packets from each other, they do see only self-originating packets in tcpdump (so my VRRP cluster is in split-brain state permanently). Previously I have successfully set up such scheme on a variety of switches, including EX4600, and I see no big difference between them, except that in the case of the working VRRP on EX4600 I have all of the interfaces in non-default vlans. I was suspecting it's the igmp snooping feature that blocks the multicast, but it turns out there's no such thing configured on my switch: 

I have a bunch of Cisco AIR AP 1602e, which I have configured. These are dual-band a/b/g/n access points. Sometimes my users do expirience lags and spikes, even the associations start to break (for some of the users). This WLAN is deployed in a large office buildings, occupied by a number of organizations, and a scan from a FreeBSD machine reveals more than 18 (!) SSIDs on 2.4 GHz, without taking into account my own SSIDs. In the same time carrier busy test for 2.4 Ghz show busy rates for a set of channels where 17% is the minimum, and the maximum sometimes can go up to 71% (!). The 5 GHz range isn't that overcrowded (5-15% at the CBT), but still, spikes happen: sometimes once a week, sometimes less frequently. What is the best strategy to mitigate this ? You should take into the considaretions the following measures I attempted: 

After you do that, you will be able to test and repeat MAC overflow attacks in GNS3 with router-based switches in a stable and predictable manner. Here are two final notes: 

For the short answer: yes, CAM overflow attacks can be simulated in GNS3, however this goes with a few requirements: 

However, in real gear the whole process behind this parameter is implemented in hardware, and this setting is currently simply ignored by Dynamips' implementation of the NM-16ESW module. Dynamips implements its own garbage collection system which deletes old MAC entries after only 30 seconds, making CAM overflow attacks noticeably more tricky to stabilize (but may be a good training against the "backpressure" functionality described by Łukasz). The code in charge of this can be found around line 2516 of the dev_nm_16esw.c file: 

Currently, when the ARL failed to store a new MAC address, the handling of the incoming is aborted, effectively resulting in the packet being drop. The fix is just to ignore the ARL status and continue processing the packet anyway, since this what real gear actually do: 

also relies on some brute-force strategy by sending its malicious packets as fast as the attacker's device and the network allow. This cause several issues: 

I've raised this issue to GNS3 teams so it can be fixed in GNS3 future updates. I also advocated to raise the MAC table garbage collection timeout from the current 15 seconds to 5 minutes in order to be closer to real gear behavior. Until this gets fixed upstream, it requires a manual modification and recompilation of Dynamips source code but this is a very quick and simple process (there is no need to recompile the whole GNS3, only the binary, and I provided the patches in the tickets linked above).