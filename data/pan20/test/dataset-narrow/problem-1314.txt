I've never found this to be a useful strategy for teaching anything useful. It's like the teacher giving you a test on the first day, then every day after this they putting up a question from the test and explaining what the answer is. It might work to teach you something, but it still makes you feel stupid. Asking someone to do something that you have not really prepared them to do can be read as rude by players. It's always better to introduce information up-front. 

Just as an example, take Geometry Wars. Most 2D engines would suck at these kinds of visuals, since most of them are built around drawing sprites, not lines. That's a game that needs a very specialized kind of renderer. At the end of the day, you need to take responsibility for the elements of your game that are important to the needs of your game. If your game's visual look is primarily developed by the art style of the images and models you use, rather than specific effects, then using a pre-packaged solution is fine. But if your game's visual style is defined significantly by custom rendering code, odds are good that a standard engine could become a serious limitation if you decide to do things that are outside of the box. Furthermore, there's a very practical issue: not all game engines are equally portable. With the recent rise of mobile platforms, the marketplace for games is spread across numerous OS's and user-interface devices. Not all engines work on all devices. And if your engine doesn't work on a platform, you're certainly not going to take the time to make it work on one. After all, that's why you used an engine in the first place, right? If it's important to you that your game function on a particular platform, then you again need to take responsibility for it. And the "easiest" way to ensure success with this is to do it yourself. To build an engine that can work across multiple platforms, perhaps employing simpler platform-specific frameworks where needed to handle some low-level details. That way, if it breaks, it's your code; you're the best person to be able to fix it. 

In the order of slow things, changing programs is more or less around the level of changing textures. It's something you have to do in order to render what you need, but for performance sake, it might be a good idea to minimize the number of changes where reasonable. This could be changing the order in which things are drawn (objects using the same shader are rendered sequentially), texture atlasing, etc. 

Story Story is a bit easier, in terms of basic structure. Especially since the elements of narrative is a fairly well-understood concept; there are many books and such on crafting a story. Really, start with Mark Twain's absolute vivisection of Fenimore Cooper's work and go from there. Of course, this is a videogame, so you need to figure out how your story is going to work in terms of being a game. How will the player interact with the unfolding story. One of the most difficult things to do in videogame storytelling (without stripping away all control from the player) is to maintain a strong element of pacing in the game's story. For videogame storytelling, mysteries often work quite well. It's very difficult to tell story during gameplay, so games often have a lot of dead time between explicit narrative elements. As such, one way to maintain interest in the narrative is to build elements of mysteries and the unknown into the story. A few subtle hints can keep the player's interest by making them wonder what it all means during gameplay segments. A hint here, a suggestion there, and so forth. Characters are also a good way to maintain player interest between plot points. Making the characters interesting, real, and deep, people that the player wants to get to know or wants to hate. Sidequests are far too often just excuses to force the player to play through an area and lengthen the gameplay. That's fine if the gameplay is interesting on its own. But unless a sidequest's storyline has something to do with the story (whether it's a piece of a main plotline, some element of a more complex non-linear plot, or erudition about an important character, etc), the sidequest is going to feel pointless to the player. Sidequests often detract from the pacing of the overall story. There's a reason why most novels and movies don't have characters going off on sidequests. It's hard to build tension if characters are distracted every 2 hours with something that's irrelevant. TV shows and comics, long-form episodic stories, will often have the effective equivalent of sidequests: standalone episodes/issues that don't contribute to the main story. However, even if they don't contribute to a main plot, they often will contribute to character establishment/development or thematic progression. Basically, make sidequests matter. Never add a sidequest for purely gameplay reasons. If story is going to matter for your game, then a sidequest needs to be justified by that story. 

Handling #1 on the GPU is a bad idea performance-wise. The problem is that you need to do a CPU->GPU->CPU round-trip. The CPU needs to manage where objects are, so that AI and other systems can manipulate it. Therefore, the CPU may need to update the position of objects. The CPU also needs to read the positions of objects, as well as be notified of any collisions. So you can't just fire off some GPU "rendering" commands and then do something else; you need that information right now for AI and the like. This forces a GPU/CPU synchronization. A GPU/CPU sync is one of the worst things you can do for performance. You want the GPU to operate as asynchronously as possible. Doing physics of type #1 on the GPU works against that. Now, for #2 physics, things are different. In this case, the physics is completely subservient to the rendering of the object. It basically does physics solely to do rendering. Therefore, everything can effectively live on the GPU. For this, doing the physics on the GPU makes sense, because the AI and game engine don't care about any collisions or whathaveyou. I don't know of anything complex enough for people to call it a "physics engine" that doesn't handle at least convex hulls. You can generally build concave meshes by taking many convex hulls and using constraints to effectively fuse them together, though how well this works depends on the physics system. Many physics engines do have some way to run on GPUs. PhysX and Bullet have some mechanisms for it, though it may be limited to certain hardware that provides appropriate support.