This question is somewhat related to a prior question that I asked about an Information Theory lab. I received a lot of great feedback there, but I have not gotten past the idea yet that the lab that I assigned last year was simply too hard. I have been wracking my brain to think of a new lab idea, but so far, I have come up empty-handed. So you don't have to visit the prior question, here is the relevant portion: 

I'm not a native of C++, but it seems to me that a Conway's Game of Life simulator, with cells as immutable objects, would be a great way to show the need for a destructor. Without one, your program would quickly run out of memory. And, of course, it's not a bad approach to the problem. All you'd have to do to demonstrate why such an approach is reasonable is to first try the naive approach of modifying the active gameboard to figure out the next turn. This, of course, always leads to incorrect behaviors, since the modification of one cell will be used in the calculation of the next cell. One final advantage is that you will also be introducing your students to an important and interesting other algorithm in its own right. 

Fair warning, I do not demand any particular naming convention (such as NetBeans) from my students. This leaves me with variable naming only for the purpose of clarity. I speak constantly to my students about the two different audiences for code: the computer itself (which is the one kids naturally think about), and other is human beings, which students find more difficult. And I also strongly believe that this is the single biggest impedance to good naming: students don't think that it matters, because they think they are writing for a computer. I also grade all of my labs using code interviews, and my students are aware that I will be looking for clarity above almost all other considerations. (There is good reason for this; deeply clean and clear code also has very few bugs. When you engage in the difficult process of cleaning and refactoring, you can polish your code until there is basically no room left for them!) My intuition is that good code correlates much more with good writing than it does with good mathematical skills. Good code demonstrates a clean rhetorical structure. This part of the code cleanly and clearly accomplishes this task, while that part carefully lays out the thinking and organization for that task. This could simply be a function of the kinds of people who are naturally attracted to coding, but I have found that asking kids to write clean code is often very difficult for them. What works I have found that the following question is a useful overriding guide for most of my students: 

In my experience, immediate feedback is helpful in speeding along development, but rarely enhances understanding. In fact, I am often frustrated with the immense level of help that is provided to my strugglers, because they wind up moving words around until whatever they've written stops being underlined. The only exception to this has been for norms that don't cause errors, such as using CAPS for variables in Java. In those instances, it is very helpful to have some sort of indicator that what they've done isn't perfect. Edit: Now that I've seen your edit with examples, it seems like what you are contemplating is basically all of the stuff that I feel is helpful. In which case, I believe that it could be very helpful! 

If this happens semi-regularly, and you continually emphasize fix-up strategies, you may make some meaningful headway. A third approach, which is more forceful, is to use a page (like this or this) with multiple timers. Students who have a question for you don't necessarily get you. Instead, you simply set a timer. (Having a second monitor display to a projector would help with this approach.) Only if the timer reaches 5 minutes and the problem still isn't solved can they ask you for help. 

Even if this is true, what of it? The fact that I have not figured out how to teach Johnny how to code does not necessarily mean Johnny is incapable, and I am still obligated to keep trying to find new ways to reach him. If, in fact, he really is incapable, I will ultimately fail, but I have no way to distinguish between him and Samantha, who is entirely capable, but has yet to have some key piece of information click into place. The number of people should be quite small. For me it has run around 5-10% of students. I work with a "gifted" population, so that number might be a little smaller than would be found in other populations, but it shouldn't be wildly different. As you have pointed out, general brightness is a poor indicator. If you're finding that >25% of your students are seriously struggling, then there are additional factors beyond "student ability" that you need to be examining. 

Even with all of these tools, there are no easy guarantees. I sometimes have to simply wait for my "Eureka!" moment, and teach the best I can in the meantime. 

One of my goals is to minimize homework. My high school students are high performing, grade conscious, and constantly stressed out as it is. Many of them fall into the "Ivy League or bust" camp, which is a tremendous amount of pressure. So, when I give labs, I try to give sufficient class time that a majority of kids will be able to finish it with no more than a couple of hours of outside work. That means that I provide lab periods. Certain students have a lot of natural acuity for CS, and seem to finish labs far faster than the rest of the group. If I provide seven lab periods for a lab in AP Computer Science, I may reach my homework time target goals, but there will often be one kid who gets the lab done by the middle of the second period. What strategies do you use to deal with these kids? 

In my experience, kids need a second exposure to binary before it starts to really sink in. During sophomore and junior years, we use binary heavily for certain key moments at my school, so that freshman exposure is absolutely vital. I still have to present it a second time when they are sophomores, but I can only imagine how much harder all of that material would be without the benefit of covering it the first time. 

The final message is the hexadecimal number , which is nice because fleas are so cuddly it is easy to check. (As an added bonus, kids who answer incorrectly are forced to decode the hex back to binary to figure out which questions they need to reconsider.) Reviewing the worksheet in class takes almost no time at all. The kids get a kick out of the secret message, it reviews a prior concept, and (as I mentioned above), the entire activity is quite short. 

The best book I know that follows fairly closely to this format is Polymorphism: As It Is Played, which observes two students slowly build out a calculator. True to form, the book takes the reader deeply into the mindset and core philosophy of OO. It's a quick read with very short pages; it took me a few hours. The book also explores some important areas of the software development process. Paired programming, which runs through the entire book, works well in the classroom (there are many questions about it here on this site), and aspects of Agile development are also explored. 

My students are all highly inclined to take notes on their computers. There are some obvious advantages: 

I might push back against the core idea here, and this gets to the idea of the central mission of the course of study. Within my course, teamwork is not a primary goal upon which I will assess my students. This is not to say that I don't value it. I think that there is great value in paired programming, but I approach this only as a salesman, not as a taskmaster. I get real buy-in. On my most recent lab, >85% of my students have opted for two people, one-screen, driver/navigator paired programming. That said, I never require paired (or group) programming. I allow students to opt into paired programming if they wish to, and I sell it like crazy, but for some of those Lone Rangers, the idea of working with another person can be intensely frustrating. Where this becomes a big problem is where they begin to hurt the education of their peers by simply doing the work themselves. Some of these students may never really warm to the idea. While I want to teach good team-working skills, I am unwilling to jeopardize the education of my middle- and low-flying students in order to force the high-fliers into an activity that they really don't want to engage in in the first place. Even in this environment, there can still be group projects, but they would involve differentiated responsibilities: 

We had a question recently that also touched on some of these same issues. I am a fan of expressing that the material can be difficult, as it sets the tone and prepares students to work hard in a course. However, if failure rates are as high as you suggest, then that suggests something is going seriously wrong. For context, I teach at a high school where kids apply during 8th grade into 4-year majors. They are tested in math and literacy, and we interview them to see if they are generally engaged kids. We do not evaluate them on programming or CS background, because most of the 8th graders have none. If accepted, they cannot change their major at any point. That means that our CS kids will have a 4 year CS curriculum that builds upon itself, and it gives us teachers a very powerful motivation not to lose kids at the beginning. It simply isn't a viable option. A freshman who gets lost will probably remain lost for their next 3 years in the school. Not every kid remains enthusiastic about CS. That's okay! They applied to the school when they were quite young, and many move on to other interests. However, over the last 3 years, we have had exactly one student not pass the AP test as a sophomore, and that student was dealing with significant mental health challenges that also brought about high absenteeism. Now, a university program is not under the same constraints, and not every student at every institution can be classified as "gifted" (whatever that actually means), so I can absolutely accept that our results might be an outlier. However, virtually everybody can learn to code. It comes down to what work the student puts in, and how well the instructor breaks down the concepts and designs the course materials. My general advice to achieve high passing rates is to create good supporting materials to use with kids who struggle, and to break things down (and make connections explicit) far beyond what you would think you would need to. I know that that advice is quite vague! And if you are ever unsure about how to break down an idea really clearly, ask around. (Heck, I could tell you about this one website devoted completely to getting answers to the problems of CS educators ... ;-) But please don't accept a 30% failure rate as the norm, or even as acceptable. So much more is possible! 

Background This is mid-year in a course for HS juniors in theoretical computer science. The unit is about Information Theory. We were using the coin-weighing problem as something of a motivator for the entire enterprise, as a deep understanding of that problem would also engender a pretty reasonable understanding of the purpose and use of the four axioms of Information Theory: 

Of course, another way is to describe the change in scale. I love the approach used by BlueRaja here, though again this is from 2013. If adding two numbers consistently took a person one second (which is already pretty fast for most people, especially since you could be adding rather large numbers), we could create some interesting comparisons to the 2013 computers. Of course, these all presume that you never sleep, eat, talk, etc. You just sit and calculate, all day, every day. Some of my favorites: 

In actuality, we have now created a literal, and two lambda expressions: $10$, $(\lambda x.(power\, x\, 2))$ and $(\lambda x.(/\, (+\, x\, x)\, x))$. Now, let's add a formula into . That formula will be: . This is a third $\lambda$ expression: $(\lambda x.(+\, x\, 1))$. Our sheet now looks like this: 

There are more slides, and quite a bit of discussion. But in essence, this model allows me to ask discussion questions like: 

As a male high school teacher in a gender-mixed school, there are certain limits to what I can add here, but it is an issue that I care deeply about. My first source of information would be the girls themselves. I would create a poll for graduates of the program, because they will have the most insight into whether they were really prepared for whatever obstacles they encountered. I would ask them: 

Another approach, entirely different from my other answer, is to ask students how they might approach the following real-life scenario: they have just been given 1400 paper forms, all filled out by potential enrollees for a program. The forms arrived in the mail and are in no particular order, but they must be sorted into one of 4 geographical regions, and then alphabetically by last name/first name. The student has been situated in a meeting room with a giant, empty table, and boxes full of forms. The student is told that the sorting needs to be done before the end of the work day. Of course, the activity itself is boring, and the student would love to get out of there as soon as possible. What approach might the student take to the task itself in order to get it done accurately and on time? Typically, someone will almost immediately suggest sorting the sheets into subpiles. One logical number of subpiles for this first case is 4: divide into 4 piles by geographic region. Now repeat the procedure, dividing into further subpiles. While a true computer algorithm might use 4 piles again, a person would more likely use 26 piles (for the letters of the alphabet). At that point, look at the size of the piles. Repeat the procedure as many times as you need on any piles that are large enough to still be unwieldy. At some point, you will have a series of tiny piles. A person would probably sort these small piles using some form of insertion or selection sort. We would now reverse the process, taking our tiny sorted piles, and recombining them into larger and larger fully sorted files. These would be our recursive unwinding steps. This entire procedure is not dissimilar from a standard mergesort (or, really, a recursive bucket sort). Divide the problem, conquer the smaller pieces, and then recombine. Breaking the problem into smaller subproblems is what makes the entire enterprise more manageable. What's nice about this procedure as a motivator for examining recursion is that it, with only minor variations, is the natural solution that most people arrive at when faced with such a daunting sorting task because the benefits are clear and natural.