Edsger Dijkstra allegedly said "computer science is no more about computers than astronomy is about telescopes." Often people replace "computers" with "programming," for much the same idea. An education in computer science will expose you to a wide variety of topics that have nothing to do with programming itself (although programming is often used as a vehicle for communicating and solving those problems) -- topics that have to do with modeling and manipulating information in interesting ways that tend to be very relevant in modern game development (even if it won't seem apparent while you're slogging through the classwork). For example I have leveraged the knowledge I acquired about graph theory in several instances to build automatic layout and diagramming tools, "visual programming" type editors, and unique-coloring algorithms to allow designers to have a holistic view of the the content they produced for a game, et cetera. You don't need a computer science degree to be a game programmer. You could have another degree (or, if you're quite good, no degree at all, but that could be risky in today's job market at least) -- math or physics, for example. You could even get one of those "game school" degrees (but I would not recommend it). It is important that you study what you are interested in, because college will only give you benefits proportional to the effort that you put into it, and you're not likely to do that if you're not invested in your coursework in some fashion. Certainly studying on your own, outside of school, is important, too -- because most colleges won't be teaching you how their coursework can be applied directly to game development. Plus, building games and little tech demos on your own will help you have a portfolio of interesting work to talk about in your future job interviews. Some interviewers, myself included, are greatly encouraged by a candidate who takes the time to pursue knowledge on his or her own. As for where you should go... that depends on you as well. You should go to a school that interests you, where you think you'd fit in, where you like the environment, et cetera. You should visit schools if possible. You don't need to go to Brown, MIT or Carnegie Mellon or whatever in order to get a good, solid CS education. In fact, I'm personally a bit skeptical that there is any significant benefit at all to doing so (many such schools are actually more well known for their graduate programs, and their undergraduate material may be no better off than anywhere else). 

First, consider a design that avoids the need for a virtual update entirely. The overhead of dynamic dispatch is trivial, but non-zero. More importantly, however, the fact that one is necessary generally suggests that you may have poor cache coherency in the storage of your units. That is, you may have something like a which contains units of various concrete subtypes in effectively random order. An approach where you store lists of concrete unit types and update each unit type in large blocks has better coherency, and avoids both the indirection needed for the dispatch and the dispatch itself. The outboard component entity architecture is particularly amenable to this. Related, consider whether the type hierarchy for units makes sense: do you really need inheritance here, or can you instead compose the differences between units as data? Second, use an appropriate spatial partitioning technique to determine which units are more important (for example, visible units are probably very important) and must have constant, immediate updates versus which units are far away and don't need as frequent updates. Units with less priority can be updated less frequently, such as by subdividing them into N groups which are updated every N frames, effectively amortizing the cost of their update over multiple frames of update time. There's no magic bullet: you basically need to make sure your updates are cheap (make sure you profile, so you know the updates are actually expensive, where they are expensive, and how to cheapen them) and that you do fewer of them (prioritizing the units that matter over ones that are less important). 

As mentioned by others, the function families and are deprecated, so if you have the ability to use a more modern version of OpenGL, you should. That said, the concepts you are struggling with are not specific to those two functions, although you may be getting hampered by the fact that those functions are operating on a matrix stack, which is somewhat GL-specific. In 3D graphics, when you send some geometry (vertices) to the CPU to be rendered, that geometry is transformed (on the GPU) by the current 4x4 transformation matrix. In OpenGL (and disregarding for the moment shaders, which are part of the modern programmable pipeline you should eventually become aware of), the convention is to represent that matrix as two matrices: the modelview and the projection matrix. The OpenGL API allows you to manipulate both of those matrices independently on the CPU-side of the API, and they are concatenated on the GPU prior to a rendering operation. In legacy OpenGL, where you'd use the and functions, that CPU-side manipulation is presented to you as a stack of individual matrices, which you push onto via the two functions you are having trouble with. When you call (or ), you specify a single transformation matrix. That matrix is then multiplied with whatever matrix is currently on top of the stack for the current matrix mode and the result becomes the new top of the stack. That's why it's usually important to use to reset the stacks when you start preparing a new frame, and that's why you can sometimes get unexpected results when you make several matrix function calls in a row, especially since (for matrix multiplication), the order of the multiplication changes the result significantly. So then, to address your specific questions: 

Note that this computation assumes the color components are specified in the 0..1 range, so if you're using 0..255 you'll want to scale them first. 

One possibile explaination is to encourage players to return to the game later, presumably because it can produce more ad revenue (for ad-supported games, possibly depending on the terms of the ad contract), increased mindshare, or a more diverse social population. The latter is especially important for games with a strong social component. Another explaination is to keep people away from the game. Some countries have laws that involve limiting (or penalizing) a player in certain scenarios if they play for too long. Some games don't want to allow players with vastly more time available to have such an unfair advantage over those with a more casual block of time (this is what the FF 14 developers claimed as the reason the game limits XP gain after eight hours of play, for example). I'm not too familiar with Angry Birds but it doesn't sound like either of these reasons would really apply to it, so I'm afraid I can't help you there. 

What you are defining here is the vertex input layout; this has nothing to do with the format of the textures you will eventually use, and instead everything to do with the format of the texture coordinates used in the vertex data. Generally these are 2D, so you'd only need . would be used if you needed 4D texture coordinates, which you probably don't. Perhaps the use of the and in the format enumeration is just confusing you; in this case the 'name' of those channels is irrelevant, it's the width of those channels (32-bit) and amount (R and G == 2D, R, G, B and A == 4D) that matter. You can load ARGB textures when you actually load the texture data from the disk.