1... You've got some invalid code in there. "Quotes" in JavaScript can't span multiple lines. Invalid: 

That way, you type that selector a little quicker via the variable. I've touched on some simplification. Someone might review this to contribute improvement to the structure, but this is not bad code. +1 for you! 

You have this commented out, but the variable hasn't been declared, so I assume there's no use for keeping it. 

Your indentation here is not conventional. You should keep indentation to a limit of 4 spaces, except for when wrapping a line that is too long, in which case an 8 space indentation is recommended. Instead of: 

For you'll need to make your own replacement. I suggest you to also place it in an class such that you can simply remove that class and fix imports once you upgrade to Java 7+. Another important note is that if the catalog and repository classes are bounded by another class (or interface), then you should use that bound in your literals. So assuming that every catalog class extends and every repository extends , you will need: 

Please note that this is a rough prototype, but by all means do write critique on it as creating rough prototypes as good as possible is also a valuable skill. My main concern with this program is the performance, if I query it to calculate the fastest strategy for for example Metal Mine 1, or 2, or 3 or 4 then it is fast, but for Metal Mine 5 it takes forever. The problem lies in RAM usage as for Metal Mine 5 it takes at least 6 GB of RAM and this is obviously a big issue. On the other hand, I am restricted to doing a Brute-Force search as I cannot think of any good heuristic which would let me allow a more efficient algorithm. 

Update Here is a sample of "working application" using the helper function, assuming you have saved the code snippet above as (which should be stored in a module, but that's another story). NB : I have dropped the exit part, since I don't like to type when I can hit CTRL+C. 

I would not hard-code the fee logic, but instead store it as pure data. It's easier to maintain, even allowing to load it from a file. Then, it boils down to a range-based lookup, which is quite classical (cf in spreadsheet software, with so called "approximate search"). In Python, we can perform such a search via , relying on lexicographic order (and infinity as an unreachable upper bound). Separated core logic would look like : 

The others have already posted out most points, so I'll briefly recap my opinion on them and provide an easier example: 

To illustrate, I have decided to reformat the class to how I would've done it and I think it looks way better now. 

When forcing this word to abide regex , it has to return , here I am denoting the objects as strings. I have a solution, however it is not fast enough, more details after the method: 

Overall your code looks okay, nothing much to comment on it as a whole. I'd like to add the following comments though: 

Now, the "factor & multiplicity" approach like in suggested link is really more efficient. Here is my take on it : 

That's an interesting question, since it requires both folding (to propagate the carry) and mapping from updated values (to apply , ie get the less significant bits). Since it's not that common, I suggest to stick with a standard Python approach. Don't force an idiom if it obfuscates. 

Like @tokland's answer, it's quite artificial (building n items only as a way to iterate n times). A side note : Haskell and Scala should provide you even more fun'. 

Uh oh... Global variable declarations. As a rule, you should keep variables in the proper scope. Instead of 

Ok first of all.. Silverlight Rant. Silverlight was a flop far less successful than Microsoft expected it to be. HTML5 + WebGL, on the other hand, is the future of handling anything that anyone ever thought Silverlight might do. If you want to maintain highly supported, future-proof practices, start doing some WebGL research. It's INCREDIBLE. Silverlight is another one of Microsoft's attempts to avoid standardization and control the web with their own tech. They've failed every single time so far. Lesson: Avoid Microsoft's proprietary stuff when possible. Now, for a Review on Practices.. As far as your code formatting and practices go, I'm happy with what I see. There are a few improvements you can make to make your code a bit simpler: You use all over the place. Try this instead: 

I must confess that I do not understand what you're trying to achieve and how Zipf's law come into play ! But I've some suggestions about the code itself : 

I agree with @Christopher. The brute force might be embarrassingly parallel, but its complexity is dreadful. Calling the answer, there is a simple approach : the case boils down to , where also allows . The case is left as an exercise, and some other early stop shortcuts might be used. With this algorithm, you don't even need C++. Instead, a language with lightweight threads (scala) will prove profitable, since up to 9^n threads may be instantiated. 

In the game Factorio there are string-encoded representations of blueprints that I wish to decode. The implementation according to their wiki is the following: 

I could probably take a guess at what some of them mean, but you really should be one naming them properly. I would expect for example, not something named . You should not put multiple declarations on the same line, as observed in . Your method names and are very confusing, they sound like some mathematical operations to me and looking at the context I cannot figure out what they are supposed to mean. Your indenting is off at various places, there should be no white-space on the same line when calling methods, like in , you should be happy the compiler even accepts this. 

4... The parentheses of anonymous function literals should have one space of padding on either side. Messy: 

That's the way to do it. There are no other ways to do what you want to do without using bufferjs, which likely handles things the same way, or less efficiently. Now, there is one optimization you can make here. By adding the parameter of Buffer.concat you can improve efficiency by avoiding an additional loop in the function, which would need to check the new length of the new buffer. 

First of all, your code looks great. It brought me to study the internal workings of Node's stream API. The piece that you're concerned with, and rightfully so, is: 

Beside avoiding mutations, functional mindset demands to split into elementary functions, along two axes: 

Regarding 1, nested dict traversal has nothing to do with the requirement to create dot separated keys. We've better return a list a keys, and concatenate them afterward. Thus, if you change your mind (using another separator, making abbreviations...), you don't have to dive in the iterator code -and worse, modify it. 

Your solution is clean but doesn't scale well. A well known optimization for is to perform all computations modulus . If is sufficiently small, we furthermore can switch to native types (this is not the case here !). 

HTML Your html is flawless (to me) pretty good. Good job. CSS Also completely flawless pretty good!. Well written, efficient, I wouldn't (personally) change a thing. JQuery You made a few formatting errors here. I'll refer you to this awesome JavaScript formatting guide by Douglas Crockford, and walk you through a few mistakes that I noticed ways that you might make your formatting a little more conventional. The blank line here isn't suggested. Blank lines are, for the most part, best used at the bottom of function declarations (if at all). 

Formatting Improvements I don't have time for a full review, but I will help with some of these formatting issues. Quoted sources: Douglas Crockford