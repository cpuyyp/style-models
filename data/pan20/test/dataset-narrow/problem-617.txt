First, I get the MethodDeclarationSyntax node, then get the doc nodes for that method. If a doc node exists, I get the list of method parameter names and the list of parameter names in the XML doc. If not all method parameter names are in the XML doc parameter list, I report a diagnostic. What I am more bothered about is the code fix: 

Those names don't tell me what the variable does or is used for. Using a longer, more descriptive name won't affect performance, and will make debugging and maintaining the code easier. 

I was unable to completely remove the properties in the CSS, but I was able to remove one. I also adjusted position of the progress bar as it was not lining up with the input bar nicely. Here I changed the margin padding: 

First, your algorithm looks a little better, but it still can be improved. It appears that it weights the higher values so they always drift to the left side of the board instead of wrapping around in a snake pattern: 

That iterates and produces a new list of booleans as to whether the conditions match. That new list is then iterated to find if the condition ever returned . I can make that into one iteration with early return like: 

First, your HTML passes the W3C validator with no errors. This will help all browsers render it the same, and make it easier to maintain. However, because you are using HTML5, you should use the element instead of a : 

It is easier to see which code is in which scope if you have it indented one level per scope. In fact, some languages take this so seriously that the level of indentation determines the scope, including Python. Also: 

You use the value in your tests, as well as the value . What if you decide you don't like the number 76 and you change it to 75? That will break your tests. You should consider setting this value in one place as a variable so you just need to change the value in one place if it changes. Perhaps you could have a of students that you take data from and use for all your tests? 

It is good the way you do not use . This practice will save you a lot of headaches later on. In fact, the only problem I found with this code is that you do not use braces around one-line statements. 

I have a Back function, and it is growing. I also think this is terrible, but I don't seem to get how it can be improved: 

This is essentially a built-in method that does exactly what my loop with the early-exit does. Next, while your indentation is pretty good, your statement is indented one space farther than it should be. Finally, your naming could be improved. What kind of data does contain? It should be named something like , or something descriptive. 

This way, the method always returns a string. Because this is just FizzBuzz, if you are going to create a second method for handling it at all, I would just print from within the function, then you do not need to worry about return type: 

You have good indentation, but please use braces. Braces are never optional in my book; I've seen enough bugs/confusion (i.e. a new programmer doesn't understand that you can only have one statement without braces) around them. 

Just because I've never written a real Sieve of Eratosthenes, I decided I should probably write one just to make sure I know what it is. I'd like (constructive) criticism on best practices, potential problems, and anything else you see fit: 

Eleventh, you are not allowed to use elements inside elements. This solution appears to work for me: 

Continuing with my VB.NET experience, I wrote a quick guess-the-number game. Any improvement suggestions? 

This is a lot simpler to parse. Alternatively, if you still want to have the separate cases, I would use instead of nesting them: 

If you enter an invalid number for your values, your program breaks. To prevent this, you could check your input like this: 

But, is a magic number in there, and magic numbers are never good. Why don't you create a value to store the number that you are checking the passed values against? 

It appears you are assigning these values so the binary values of the options are , , , , etc... This is so you an assign multiple errors to a single variable, correct? It would be clearer what exactly you are trying to do if you used bitshifting, like this: 

Comparison to Boolean Literals: You do not need to compare a value to or : . Just use . Again, you do this in other places in your code. Addition: can be . 

In one method, you use parenthesis around the expression, and in another, you don't. In one method, you use spaces around the operator; in the other, you don't. These methods could also be improved by using C# naming conventions: should be named with PascalCase as at a minimum--writing out the full word "function" wouldn't hurt (although technically, this is called a "method" in C#). 

This seems very WET, but after thinking it over, this seems to be the best way because only what these methods do is the same, the details are just a coincidence. This is the code fix. Again, I provided overloaded methods: 

This single snippet of code has many things that can be improved in both readability, performance, and maintainability. First, use braces around your single-statement blocks. This will make it much easier for you to maintain later, and will ensure bugs are not introduced when more statements are added. Second, you are overcomplicating things with that loop. First, you loop way more than necessary: 

In question five, you have multiple inputs. Why don't you handle it like this instead of having multiple // statements? 

And finally, I really hate this last one, but I don't see any other way in SignalR Core to publish a message to a group with exceptions by connection ID. They have this functionality in SignalR non-Core, so hopefully soon... 

For the most part, you are consistent, and I like how you use spaces around your operators and braces on your one-line s. 

Just because I'm bored, I wrote yet another prime number generator. I think it's pretty clean, but I won't be surprised if someone finds something to comment on. 

I don't like the required length in the ctor for . Allowing the user to provide an array signals that you don't care about the number of cards provided. If there must be a specific number of cards, you should make the user provide them explicitly, and if you need to, concatenate them into an array in the constructor. If this was a public library, this would probably be quite the pain point for your users, and when it comes down to it, you are basically just a user 6 weeks/months after you write this. 

The constructor takes the character set to be used and a beginning and ending range of passwords. For now, it assumes both passwords are the same length, which is useful for when you know the number of characters in the password. iterates over the range of passwords, and returns the password when found. If the password is not found, it returns . will calculate the next password in a manner similar to addition in base-N math. will return the current password, stored as an array of s, as a string. I generate my tasks like this, leaving Windows to manage the threads. Based on watching it in debug mode, it does create several threads, but not 95: 

Using a delegate for that one step that changes makes this code much cleaner to read and maintain; if, for example, you had a bug in the code to read the values from the textboxes, you had to fix it in 8 separate places--once for each textbox for each operation. Finally, a value divided by is most definitely not infinity. It is undefined. Consider, for example, if and . Now, we can say that , and that . Clearly not true. 

This review is primarily to make sure I am using Unity right. Please tell me everything that can be improved. 

Two string arrays with members that are supposed to match by index? Extremely difficult to maintain, as I learned from my own experience. Use a map instead, so you can do something like: 

There. Clean, easy to understand and maintain, and lots of options to use. Notice that the second needs to have the one integer larger or smaller than the value you want to stop at to accommodate the multi-directional search. 

I'm not too familiar with graphic algorithms, so I'll leave that review to others. This is mostly a style review because you make many mistakes that IME will make it more difficult to maintain this code. 

The full test suite can be found on GitHub here: Tests for SwitchDoesNotHandleAllEnumOptions. All comments are welcome, but I am especially interested in utilizing the Roslyn framework better if I am misusing it or not using any helpful features. 

You have principle in this section right, but it can be simplified a bit if you set and to use the absolute difference: 

This comment is not really needed, unless you are reminding yourself about it. Robert C. Martin states in Clean Code that every time you use a comment to explain your code, what the comment is really saying is that you failed to write your code so it explains what it does itself. After reading and writing many comments myself, I have to agree with him. 

First off, I don't know Swift. These are generic issues that should be addressed in all written code, and I'll leave the Swift-specific stuff to the experts. Comments 

This will input the entire string of input, make sure it contains only integer values, then parse the string as an integer and assign the value to the number. Unfortunately, this also breaks if you enter a value larger than an integer. You could manually check this before you attempt to convert the string input, or you could simplify your method a little and just use a / block: 

If you have multiple designs for different types of media, such as phones, printers, and regular computers, you can set the tag like this: 

First, your indentation is a little crazy, which makes it very difficult to see which code is in which scope. Consider: 

ExtensionMethods.fs This is really the public API of my library. I designed the methods like this so they could be called as in both C# and F#. 

You can validate your HTML at the W3C validator (it validates once you provide the framework). It does look clumsy the way you write out each figure. If I were you, I would probably load the images and s in a separate file (maybe a JSON file?) and use JS to add them to the page. This way, you just have to enter the new data in this file, and the webpage will load them right in the next it is loaded. 

You need to put font names that include spaces in quotations: (this error occurred twice). You have an extra brace here: 

Avoid instantiating an instance of in a method (at least you didn't scope it in the loop!). instances should almost always be placed in class scope to reduce the chance of getting the same value for every clock tick. seeds itself with the current time when it is instantiated, and the value produced is completely dependent on the seed. 

This is pretty good-looking code, except for the fact that every argument is passed as an . Let's look at what happens when I pass a custom type declared in the namespace to . First, succeeds, unless the value is null. Next, we reach . What is the value of ? Do we really know? If I have not overridden , it will return . If I have overridden , it could be anything. Finally, we reach . What happens here? We get an that crashes our code. Because you are working with a value intended to be an , you should take input as a string. Problems that could arise here are if the string "234r" is passed, which will cause to throw. You should probably use to ensure that the parse succeeds without crashing your code. 

My latest refactoring for Rubberduck is called Introduce Field - it promotes a local variable to a private field. The three overridden methods are the members of , and are used to start the refactoring sequence. The other methods are the worker methods. Overall, I am pretty happy with it, but there are a few things that bother me. The first of these is that has a strict requirement for the declaration type, but accepts any declaration, regardless of the type. Is there a way to enforce this other than throwing? Should I even be throwing here? Should I just return instead? and both seem somewhat clunky. Is there a cleaner way to do this? 

As brought up in the comments, this will crash if there are 0 elements in the list. To prevent this, you should probably check this before you try to get the range, like this: 

The newsletter suggested I try to answer this, so here is my attempt: This looks like a lot of repeated code here. I don't think this can be shortened really, but I would create a function to do the conversion in: 

This loop is almost right, but you check the value an index , which you did not set to because was the value to exit the loop: 

In the / block in , you do at the top of each block. You should move this to just above the conditional if it is going to happen either way. However, I'm not quite sure if it is supposed to use the operator in each given that the comment for the first says you are trimming the top of the range and the comment for the other says you are trimming the bottom. 

Board.fs This type represents a board, and the only stateful member of this class is immutable, like . The second optional constructor is for ease of creating a board from a hard-coded list in C#; it may not remain in future versions. 

The reason there are style guidelines is because it allows you to skim your code and find what exactly happens at each point without reading it character by character and line by line. If, for example, I had never worked on this, but had to fix a bug on a certain special case involving one of the dimensions, I would have to read the code carefully to figure out where variables are declared and used. By the time I was done, I'd know the process, but I'd be so involved in the process, I would have a hard time seeing the algorithm. If, on the other hand, you followed more standard guidelines, I'd be able to skim it and figure out the general algorithm and then look through the process to see where it deviated from the algorithm. I'd also be able to easily skip over sections of the process that were functioning correctly based on the expectations of the algorithm. This could speed up a bug fix from taking 5 hours to 5 minutes. 

To start with, C# conventions often state that you should always use braces around statements, loops, and similar statements. That means this statement: 

This lets browsers know which version of HTML you are using. This is the current version, which you should be using. Second, you should enclose your entire HTML in a element. Third, you need to have a element with a element. The element is the page title that appears on tabs. You can also link external files, like CSS and JS files, here, as well as specify which character set you are using, typically UTF-8: