Just to clarify, your artist will need to install the XNA framework as well. Additionally, if your game requires other stuff to be installed (like OpenAL if you use MonoGame), your artist will need that too. Also, if you're using the XNA content pipeline, this won't work, because the file formats are all in and similar processed formats; you need to use straight-up assets instead. Edit: Beyond that, you will need at least the following: 

I've used both approaches and they work equally well as far as I can tell. Both rely on Java being installed. You still need a JVM; there's no way around it. Launch4j also includes an option to bundle a JRE with your app, which would make it a "true" standalone application (doesn't need Java installed on the user's PC). Your app will be quite big, though. 

One very effective technique used by some roguelikes (DoomRL, Brogue) is to mask the actual variables. What this means is that instead of showing health as "2/10," show it as "20%." Remember, most memory editors work well with specific value searching/filtering. If you don't know the specific value, you can still track it down (eg. search for changed/decreased values after the player health drops), albeit it takes much longer to do it that way. I also suggest an anti-cheat backlash. For example, if you have a game where the player takes non-positive damage and their health didn't drop, you can easily and accurately check this and know that the player cheats. Do something interesting, like spawning some uber enemies around him :) 

While looking up OpenTK, I found a couple of references to threads that talk about Windows 8 support: 

The solution to this might be test partitioning. Consider partitioning into a low-end, medium/normal, and high-end device, for example. You can reasonably expect (in terms of performance) that if the performance is X on a certain low-end device, it will be reasonably similar on a similar low-end device. With this in mind, you can judiciously choose devices that represent a "class" of devices and test of those. And ultimately, as anyone who shipped an Android game will tell you, every phone has its own unique quirks and bugs. Make sure you use some sort of analytics tool (I used Flurry Analytics) that allows you to capture errors; you can eventually diagnose and fix a number of these, increasing the range of devices on which your game works on. In my opinion, the emulator is only good for functional tests; it neither has decent performance, nor does it represent device-specific bugs. I would avoid it. If you want a decent alternative with decent performance, go with BlueStacks, which is an implementation of Android on Windows. 

I think you have a good start. You certainly have your GA infrastructure in place. Now you need to expand and tweak. You also seem to be missing the part about random new genes, which is important. I think, at a high level, you need to figure out what kind of actions you want your AI to take. Attacking and fleeing, are they enough? Since you have a roguelike, I would suggest also incorporating the concept of "damage done to the player" into your fitness function. The problem with these two chromosomes is that you get an either-or. Instead, you need something with a more range/spectrum. I would try something like "flee after N turns" or "flee when you reach N% health." You can add other ones that incorporate special attacks at certain points. 

The main issue to consider here is the cost vs. return. Cost can be tangible (money) or intangible (time, effort, pain and suffering from a horrible debugger/platform/environment). So it boils down to this: do you get more out of the extra effort than what you put in? If you have an awesome game, and with some tweaking it'll become much better and attract a higher grade (or quantity) audience -- then by all means, go for it. If you won't get much out of it, then why are you spending time on it? Go work on another game instead. 

If you need to model springs (eg. something swinging like a pendulum), constraints on forces, and arbitrary polygon shapes (eg. tetrahedron), this sounds like what you want. If you want a frame of reference, think of something like Angry Birds. Based on your game, you can pick which is the best-fit to your needs. It sounds like a spectrum of speed versus accuracy/complexity (Arcade Physics being the fastest but simplest). 

If option #2 seems too "hard," try option #1 first. If your game is a small size, it may be "good enough" for you. 

Until one of my games "makes it" big, or I get flooded with gold ingots, I will have to handle most or all of my game art myself. The crux of my question is: how can I learn enough art to get beyond "programmer art" and into something I would actually be proud of? The focus of my question is 2D, not 3D. I already have a good grip on: 

I'm assuming you're an indie developer, doing your own (or getting free/partner-based) artwork. I'm also assuming you have no external pressure driving you forward into new games; you can work on your games as much (or as little) as you want, then move on. Having said all that, how do you decide how much polish to put in a game? I'm also assuming you won't fall into the notorious trap of dumping your game half (or less) finished; that you have the discpline to work on it until it's "good (enough)." I currently have a rough cycle where I develop the core functionality, then content/levels/whatever, then add layers of polish (art, bug-fixes, and usability tweaks) until I get bored. There's always scope to improve, but I don't have a measuring stick telling me that "at this point, your return on polishing is not worth the time/effort you're putting into it." I'm going to assume this is always worth it if you learn something new (like how to render a glow effect, say). Also, before you ask, I don't have much of a player base (and not one I can observe, either) to ask them when it's good enough. 

Use classes. This is tricky, because your class will have data (player health, etc.) but also the current view to draw (sprites, etc.) A better way would be option #2 Use a component-entity system. This article describes it quite well, as an improvement over option #1; you basically create small components (eg. Sprite, KeyboardInput) and entities (eg. Player) that are a composite of multiple components and "wiring" to make them work together. 

I'm starting out with MonoGame. For now, I'm only targeting Windows (desktop -- not Windows 8 specifically). I've used a couple of XNA products in the past (raw XNA, FlatRedBall, SilverSprite), so I may have a misunderstanding about how I should add images to my content. How do I add images to my project? Currently, I created a new Monogame project, added a folder called "Content," and added images under there; the only caveat is that I need to set the action to one of the ones. It seems strange, because my "raw" XNA project just last week had a project in it (, according to VS2010), which compiled my images to XNB (I think). It seems like Monogame doesn't use the same content pipeline, but I'm not sure. Edit: My question is not about "how do I get the XNA content pipeline to work with Monogame." My question is "why would I want to use the XNA content pipeline in Monogame?" Because there are (at least) two solutions (that I see today): 

To give a parallel in writing, when you're writing a fantasy/sci-fi novel, there are a lot of elements you need to describe. While you can arbitrarily invent objects/creatures/places/etc., you get a much more consistent world when you sit down for a few minutes and design the area, region, planet, or universe. Everything then fits together nicely, and you can ask yourself "how would this work in this universe? Edit: It seems like I didn't explain this well. Let me simplify the question in the extreme: when I need to lay out a title screen (with background, fonts, skinned buttons) how do I decide how they should look? Green or blue? Grunge or not? Rounded or flat? Serif or sans-serif? Take that question and explode it into your game as a whole. How do you figure out how things should look? What process do you use to make them consistent and non-arbitrary? Look at the screenshots again. I could have stuck to grass/sky/rocks, but metal seemed more fitting to the idea of chemical reactions and atoms. 

My class, enemies, etc. all subclass from this. My components also live behind an interface with a simple method. Most of them expose specific functionality (eg. for input, events for when keys/mouse are pressed). Creating the player was simple: 

If you don't care about rotation, you can simply set the origin of the sprite to its center and rotate it 180 degrees (). This is the same as flipping horizontally and vertically. If you do care about rotation, and the sprite is flipped both ways, you can just add to the angle and you should be done (eg. 45 degrees + 180 degrees rotation looks the same as 45-degrees flipped on both axes). 

What seems to be the right fit is something like "for each self-enclosed space, find the nearest empty space and tunnel to it." That seems complexity-hard though (for each circular enclosed space, compute the distance to every other space) and will probably be slow (running on Ruby too) Is there a simple solution to this problem? 

I assume you know what flood fill is (looking at all adjacent tiles recursively until you run out of tiles). 

Johnathan Hobbs is close in his answer. I would suggest ditching corners, and going with a percentage base. Hitting the paddle on the left-most edge gives an angle of, say, -60 degrees (2pi/3, I think). Hitting the right-most edge is +60 degrees. So your range is 120 degrees. Calculate the relative Y of where the ball hit, map it from [0 .. 1] (a percentage) to [-60 ... 60] and that's the angle of reflection. I used something quite similar in my Flash block-paddle game. The benefit of this approach is: