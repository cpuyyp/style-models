First of all, you're confusing zram with swap. zram is basically a compressed version of RAM, and it is still in RAM. Swap, on the other hand, resides in the disk and is utterly slow. In other words, zram is a compressed swap file that's still placed on RAM. There's no such thing as "zram on the OS partition/disk/dphys-whatever". It's still on the system memory, although in a compressed form. I'm sure you already know what a swap file is, so I won't bother explaining. No, zram will not help with performance whatsoever except when the Pi is getting low on memory. Then, it will start compressing RAM. If system memory still runs out despite compression, swapping kicks in (based on your value). What I would do is: 

2 flashes mean that the SD card cannot be read. 3 flashes mean that the file cannot be found. Either both of your SD cards are damaged or your Raspbian image is bad. Get a known working SD card, download a fresh copy of Raspbian, then flash the image on the SD card (or copy the files if you are using NOOBS). But before you do that, plug in your SD card on a Linux machine (VM or real). It will recognize the card if it's not corrupted and it will show up as a normal flash drive. Just copy your files. 

No, this would not work unless your computer accepts HDMI input and can use that as a stream which you can direct to the monitor (via VLC maybe). Have you considered directly connecting the Pi to the monitor? or VNC? 

Assuming you pulled your source code from Raspberry Pi's kernel repository on GitHub, you'll want to copy the folder inside into your system's directory. Replace files if or starts to moan. Source: Experience 

Anyone know what this is? Is this normal? I've Googled around and it seems that people mostly encounter a instead of this . That's why I couldn't find any info. I didn't touch any of the networking stuff except when I set a static IP address. All is well when network activity isn't as flooded as this. Stable overclock: 1000MHz ARM, 500MHz core, 450MHz SDRAM, 4 overvolt, Heatsink and fan on SOC and LAN chips 

If the app is not the one to blame or it still happens after using the more famous ports, your Pi might be misconfigured. In that case, Here's a known working configuration from my own pi. The file is . Make a backup of yours and replace it comletely with this one. 

I don't think a Y-cable would work since the two power banks would compete and eventually (if not instantly) one of them would break and possibly take the Pi with it. This solution might work (it will work, I've done this): 

When you connect to that address, you will need to HTTP authenticate like you would when you visit the actual device portal. You will need to use your credentials (, ). In C# code, you would likely use . I will leave that to you. After you connect, simply parse the JSON output. Look for . 

From there, use bi-directional sockets. Should be simple enough to implement in C#. String should contain Player ID (because of DHCP) and guess/answer. JSON recommended. Source: I know my way around C#. 

Don't expect awesome quality if your network isn't that awesome since it needs to get the (HD preferred) video stream to your PC. You could lower the resolution to get better frame rates and lower delay. 

Alive. It was probably the polyfuse. Your shady power supply might have tripped it, unless it was from a reputable source. Other than that, an accessory might have pulled too much power from the Pi, blowing the polyfuse. 

After a quick Google search, it seems that, in theory, it might be possible to control the RasPi touch screen brightness. Apparently, the I2C interface on the touch screen module is exposed. It seems that there's some need to poke around to determine the correct address, and the correct values to send. The details are too scattered, so I'll just post the link: $URL$ 

If you overclocked, double check that and maybe set a lower frequency. One does not simply set "Turbo" or "Pi2" as an overclock in . I've experienced this with extreme stress testing and a serious overclock. Clocking down solved my issue. 

If you're on Linux, it should be a breeze. If you're on Windows, you somehow need to find an equivalent of these Linux commands: 

Check your power supply. Make sure your adapter can handle at least 2A since you're running a hard disk. A phone charger won't do. Source: Experience 

Attach a 1k resistor to the gate pin. Then, attach the other side of the resistor to the GPIO pin of your choice. Connect the source to ground. 

Generally, you can't. If you do want it, you will need the right hardware for the job. Specifically, you'll want an adapter that supports virtual interfaces. Unfortunately, your adapter does not support that feature. I know some Atheros adapters do. My TP-Link WN-722N supports that. After you acquire the hardware, simply sprinkle some command sorcery to create a client and an AP interface, add some routing/NAT rules (i.e. /) and you'll be good to go. 

If you don't mind adding some size to your Zero (comparable to Pi A+) and soldering some pin headers on the GPIO pads, then you could grab the Pi UPS and a Li-Poly. It takes care of charging the battery for you when the Pi is powered on and kicks in when the power is removed/goes out. The size of the battery is your decision but the bigger it is, the longer it will last. Take a look here. 

I'm not aware of any USB solutions, but a simple relay circuit connected to a GPIO pin should fulfill your needs. Here's a mechanical relay circuit from this site. The main point here is not to draw too much current from the Pi, so what you should do instead is connect the GPIO pin to a MOSFET/Transistor. Switching a MOSFET on draws very little current. Once it's on, it will let more current through that will, in turn, turn on a relay. It should be simple enough to follow: 

Depends on your hardware and SD card. If you're using your Pi, the maximum real-world limit would be around 20MBps to 22MBps assuming your SD card can handle it. If you copy your data using your computer with appropriate hardware (UHS2 microSD and readers, USB 3.0), it would be happy to perform at 80 MBps. But, once you're back on your Pi, it's back at 20MBps. So basically, you can speed up SD card preparation by using your PC, but you can't go around the Pi's limits once you're using the SD on the Pi. 

I highly suggest adding a pullup/pulldown resistor or some other pullup/pulldown mechanism. I suspect having different power supplies for each Pi has something to do with this. Also, I don't see any pullup/down resistors in your diagram. A quick search would result in a simple pullup/down circuit (i.e. just add a resistor between GPIO and ground for each Pi). An alternative would be to do it programatically since the Pi's GPIO pins can be pulled high or low in-software. This would be the most practical option. Take note that you may or may not have to change your trigger logic. For example, for a pullup setup, detecting a would mean the button was pressed. For a pulldown setup, detecting a would mean a button press. I'm sure you get what I mean. I also suggest getting an actual switch/button since manually connecting wires can almost always cause issues with bouncing, unless proper debouncing logic is implemented (in software and/or hardware). 

Re-burn the disk image. You can grab a disk image of your choice from Raspberry Pi's downloads page and the latest copy of Win32DiskImager from here (direct download link). 

In , try changing to . Just a hunch. Also, just in case, add your router's BSSID into your supplicant file: 

SSH and serial are just different methods of getting your hands on a command line. Basically, SSH isn't a substitute in the first place. It's a different method of accessing the same thing. If your project won't kill anyone when you disconnect from the command line, SSH is, in my opinion, a more convenient way to access the command line. Just think about all the wires (3) you have to take care of when using the serial port. Take note that any foreground script or program you launched in that SSH session will die if you disconnect. If you don't want that to happen, use the command before you do anything. And no, you don't need to mess with any complicated networking stuff. Just connect the pi to your network and access it using its IP address. Oh, you don't know the Pi's IP address? Use SoftPerfect network scanner. (personal choice, not sponsored). Your Pi's MAC address will start with . 

Your best bet would be to do everything involving data over WiFi (FTP, Samba, etc.) An alternative would be via Ethernet. This will effectively turn your Pi Zero into a Wired/Wireless NAS. 

You should now check . The last line should print highlighted in red. If you do, congratulations. You just made and installed a kernel module. Now remove it using . should now print highlighted in red. Sources: 1 2 3 

The minimum version that supports that attribute is Python 2.7.9. Make sure you're using Python 2.7.9 or above. Most Linux distributions (including Raspbian) use Python 2.6.something. 

Based on the message, they're not blocking your connection since you can actually connect to your Pi. The problem here is that your SSH server isn't configured properly. Now, the misconfiguration may be too broad for me to enumerate all of them. It might be a typo, something might have been uncommented accidentally, syntax error, etc. The most common cause would be you tried to mess around with file-based authentication and failed and/or your app doesn't support it. Another cause would be your app is simply... how should I say it... fecal matter. In that case, download another one. I recommend Prompt. If they are, in fact, blocking your connection, then you could use some of the "famous" ports provided you're not using them. Try to forward port 80 or 443 to 22 on your home router and connect to SSH using port 80 or 443 from school. 

Your Amazon link has a significant number of reviews that basically says "my drive died". What I'd try to do first would be to run on the drive again. Make sure to unmount the drive beforehand. , where is the device and is the affected partition number. Do NOT run it for the whole device (i.e. do not run ). If it's still the same, I suggest having the drive RMA'd. As for the slow performance, I presume the OS is trying to write to the drive, but it can't, therefore blocking some operations. 

refreshes the package index files from sources listed on will fetch new versions of packages that are installed on your system. This command will fail if there are conflicting packages, hence the need for . The versions it will install depend on the index downloaded, so running beforehand is important. does the same thing as , but handles changing dependencies. It will attempt to upgrade more important packages at the expense of less important ones. Some packages may be automatically removed. The switch tells to answer yes on any questions it might ask. The part tells whatever is running the command to execute the second command if the first is successful. So an won't happen if ever fails. (Source) 

I've used those modules. They work with 3.3 volts, but the transmit power would be better when using 5 volts. Simply connect VCC to 3.3 volts then wire everything else exactly the same and you should be good to go. For the transmitter, you can safely connect VCC to 5 volts since the data pin only receives data from the Pi.