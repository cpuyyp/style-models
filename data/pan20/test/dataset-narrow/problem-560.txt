Remove the interface State. It's not necessary. You already have an abstraction with "AbstractState" ResetState should not derive from PausedState they have nothing to do with each other. Inheritance is not for reducing code redundancy. It's modelling semantic. Maybe you mean that AFTER you made a Reset (go into ResetState) you are going to the PauseState. The same with the methods in AbstractState that were involved in the state machine. pull them down to the concrete states. Code is not necessarily redundant if it looks the same. In the AbstractState the methods involved in state-change should at most implemented empty. Remove all the super-calls Pass the Mp3Player through the constructor to the states and not through the methods As you are using the flyweight pattern right now for your states keep them immutable in the future. As you are using the flyweight pattern no prototype pattern is neccessary. Why would you create something out of a prototype if the result will always remain like the prototype? remove static initializer static {...} and introduce lazy initialization in your StateCache. As you have no access to the Mp3Player in the StateCache do the caching in the Mp3Player. The holder object and the state objects are high cohesional so do not pull them apart. You should not let other objects than the holder object or other states create them 

Each of the responsibilities should be represented in a separated code fragment, a method or a class. 1 To calculate missing elements of a right triangle you have to have at least two more information beside GAMMA that is considered to be 90 degrees. Given angles must be in a range of 0 > angle < 90 and edges must be x > 0. You have to decide what to do with redundant and compromising information.I suggest to throw an exception if something is strange. 2 I do not really understand the isPossible()-method. It is called AFTER every calculation and it is calculating something I don't really want to understand. The isPossible() check has to be called as early as possible. In my reality I first check if something can be done and maybe then it is done. In this case I would first check what I described in (1). Often if you do things not in the "natural order" you mess up your code. 3 Here you have to identify a strategy to calculate missing information. You have a lot of if statements to identify the next calculation. That's because you have redundant code that isn't obvious. Look at this: 

Constructor Do not make calculations in a constructor. Responsibilities As you only have one class of objects that are not communicating to other objects this program can be considered as a procedural program. OOP is about structuring a program by responsibilities. So let's start to identify them. The purpose of the program is to calculate missing elements of a right triangle. So you have 

This parser searches for numbers and returns them. Whitespaces separate numbers as whitespaces are allowed to occur multiple times. If you input alphanumeric characters the machine goes into the Error-State. As I kept it simple you will have to distinguish several other states when parsing expressions. For example if you have an + operator you may have a stack on which at least two numbers exists. Some other things you have to consider is an appropriate abstraction. For expressions you may have "Expression" with an evaluate-method. Numbers is this case will evaluate to themselves. There are a lot of other things to consider. As I said: You picked one of the most difficult task in computer science for a hobby project. 

After you use lazy init every access to txtCondition must be done through the getter. Tie up construction and initial configuration. Refactor 

I do not use a ConcurrentHashMap as it is not necessary anymore. And it is wrong considering the usecase. Those datastructures are not that beneficial as they seem in the first place as you have to know the usecase to chose the proper datastructure to be synchronized. Synchronizing is done via the synchronized method modifier. Both, the read access method and the modification access method allow only ONE thread to be in the monitor. Some may argue to avoid the synchronized modifier because it will introduce a lock on a visible object. Other developers may use the object as a lock as well and a deadlock may happen. My point of view is: If you put a lock on an object that you do not "own" you should know what you are doing. And I think it is a wrong message to allow other developers to not know what they are doing. Thread The next to adapt is your thread. First you should define a Runnable instead of deriving from Thread directly. Furthermore the thread should know the usecase specific thread-safe datastructure: 

you have an initial length of a name you have a char sequence from where you take chars from the beginning with the given length the amount of chars you want to take is incremented by 1 each turn you want to take chars until there are no chars anymore 

Monitor I suggest to think about your monitor. As every method is working with the "head" variable every method should be synchronized. Either you make all methods "synchronized" or you introduce an internal lock object and use the "synchronized-block" construct in each method. If you do so you do not even need an "AtomicReference". Synchronisation micro management For the sake of clarity: Of course there may be several solutions with "micro-managed concurrency mechanisms" (volatile, several implementations of sets, maps, lists, stacks and queues) and they may be faster. But my way is to have the monitor clearly and transparently defined. And this transparency omits any concurrency elements that are different to the synchronized keyword. You should only left this path if you really need whatever you want to achieve (mostly performance). If you do so then you will open Pandora's box and you have to handle it. And what is even worse your collegues have to handle and maintain it too. size-method Your size-method is good. Either you are iterating or you formulate a recursive algorithm. As Java has no "tail recursion optimisation" and the stack count can exceed the JVM stack I would go for the iteration. Generics Try to get your Generics right and do not suppress "raw type warnings" as they are important indicators of design flaws. Code 

I would go further on responsibilities. I would introduce a listener pattern. So the Main-class looks like this: 

Shutdown strategy Because you are using Swing you currently define following to close your application: 

table column name (unitid) the type of the table column (NpgsqlDbType.Integer) value to query (id) the placeholder within the query (":id") 

Write your own OR-Mapper Use an existing OR-Mapper Develop your code towards an OR-Mapper Ignore the problem through adding specific code that makes your solution more inflexible 

state pattern, to represent the different states of the game template method, to avoid duplication of System.out.println 

Cache semantic A cache is something optional. You should be able to disable the cache by always returning "null" in the lookup method without worrying that your algorithm fails. It only should be slower. I don't think your implementation will pass this check. The cache should NOT retreive new data on its own. Cache scope A cache has a well defined lookup and object scope. Your implementation has a cached object lookup scope of "method" and a cached object usage scope that is somehow greater. Both should fall into the same scope to satisfy symmetry. Without knowing your UseCase-Layer you most of the time want to have all objects needed available in the UseCase. Refreshing your UseCase will often cause refreshing your cache because you want to process a UseCase on the latest data. One other thing: Your Child-Objects may not the only Objects that have references on the Parent-Object. Those objects you would have to handle with seperate caches so you cannot take advantage of the already loaded instances. Consider caching on In thhe Business-Layer if you have no Persistence Mapping Tool (JPA). Otherwise you should make use of Entity-Caches. Lambda expressions My opinion on lambda expressions is ambivalent. Of course you can have very compact and technically expressive statements. But technically expressive statements may not be semantically expressive. Often they hide bad design. You can compress code that it looks good in one method that would normally be splitted into two methods. But the only reason you may have need for two methods was bad design. I consider usage of lambda expression rarely: Listener-notifications, mapping JPA objects to Busines-Objects or massive parallel number calculations. I never use lambda expressions to make code "shorter". Approach Simplify the data retreiving process: