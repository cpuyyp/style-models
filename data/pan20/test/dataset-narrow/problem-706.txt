Since the length is 1-based and the indexes are 0-based and returns numbers between 0 and 1 (excluding the 1), you don't need more than this. And now, the You have the following code: 

Performance: Performance is quite satisfactory. It takes around 2.5s to search 9-bytes long repetitions, on a 8.58MB string, on my machine, using Google Chrome v47.0.2526.106. Using IE11, it takes over twice the time (around 5.6s)! Screenshots: Google Chrome, IE11. The time it takes is always around the same (with very small variations), which is a good thing. Running this code on a string that is 10% the size will take 10% of the time. That is, for a string that is 0.86MB it will take around 250ms. This is the code used to test: 

It isn't the prettiest thing on Earth, but may work for you. To call it, you don't have to change anything! Just remove that on . With some bitwise operations, you can cut down this code by a lot! 

You don't use the variable anywhere, besides in 1 method a few lines below. Instead of all that, you can chain the methods and spare a dangling reference later on. Something like this: 

With the replacement as an empty string, you would remove the double-space in . Normalizing it to a single space will return instead of minifying into . 

Now, how will you distinguish between an error-ed query and a successful one? You can't! And that makes angels angry and cry. Return in case of error. 

Why do you need a linear search [O(n)]? You can determine in which interval the value belongs by a binary search [O(log n)] (do not implement is with a recursion! use a loop or hard-code it))). Average number of comparisons for linear search is n/2. Binary search needs a constant number of comparisons of ceiling( ln(n) / ln(2) ). 

So binary search should be faster, if comparison is the main factor, for n > 4. If n is constant (its seams 64 in your case) you can even hard-code the binary search to avoid the overhead of a loop. (that is also possible for linear search.) As an example how to hard-code a binary search: [for a array with 8 entries] Code will get quite long for 64 entries, but it will be fast. If your intervallBoundary array is intervals[0..7]: 

You need to check if each letter occurs the name number of times in both strings. One method would be to sort the letters and compare the lists of letters for equality. Here is my approach: 

by an Enum which would add typesafety and also helps your IDE to detect e.g. if a state is not handled in your statement. 

To see where the bottleneck is, you need to profile your code! Here something which may be a little improvement: replace: 

I think speed will only increase a bit, if at all, if you use arrays (The List implementation you use may already use an array). But you will reduce memory consumption if you switch to an array based implementation if you reduce the number of objects used this way. You should profile both implementations to compare speed and memory consumption. 

That's better, but we still need to loop through all the views to find out which ones need our data. Perhaps there are hundreds of views and only three need the data. A better approach would be to use a publish-subscribe model. Instead of having to loop through all the views, each view that needs data would subscribe itself on the view who's data it needs. When the data for that view is loaded, it would publish this data to all its subscribers For example: 

Most importantly, try to care about your code. If you put your code out for others to see (by posting it here), try to first make it as good as you possibly can. Remove dead code. Fix the problems that you know about. Post a complete example, not half-finished one. Structure it so that it's as easy to read and understand as possible. Run it through JSHint and fix all the warnings, so you that people will not need to point out the mistakes that a stupid machine could have told you about. 

In general, I would say: no, just serve the same page for all kinds of devices, regardless of mobile or not. Perhaps though you have some sort of reason why you want to serve one kind of page to to mobile users. Without knowing that, however, I can't really assess whether your solution is good or bad. 

Checking for runs A basic check for runs is quite simple. You just loop through all the buckets in order and check for the longest sequence without holes: 

If shape and number of polygons do not change (or at least not often), I would add an extra step (the new first step) to your algorithm. Calculate the center and radius of the smallest surrounding circle for each polygon. This way you can calculate in a minimal and maximal distance of all vertices from the given position in one run without iterating through them. If the minimum distance for a polygon is greater than the maximum of an other polygon, no vertex of that polygon can be the nearest => we can ignore this polygon. Than proceed like you did before. 

calculate distance to each polygon surrounding circle and eliminate all polygons which are too far away to be a match Entity: performs a loop through all not eleminated polygons. Polygon Loop: loops through ALL vertices of the polygon in the current iteration. Vertex Loop: if the distance between the entity and the current vertex is lower than the distance between the entity and the previous vertex, save the current vertex and the ID of the polygon the vertex belongs to. Once all loops are finished, take the nearest polygon/vertex and get the vertex of the polygon to the left and right of the nearest vertex. Check the left and right vertices to see which is closest to the nearest vertex. Doing so, finds the nearest line of collision to the entity. 

It is a matter of taste, so there is no 'better'. But more common seams to be because often the conventions of JavaBean are used. If you work in a team, I would discuss the naming conventions to use with them. 

The on the same line is target of discussion. In my opinion, it should be in a line on it's own but most people prefer this way. Other things like this: 

This will have the exact structure you wish. Simply use to access all values. And done! An alternative with 0 lines of code! 

Based on what I've seen on Firefox 53.0.3(32-bit), on Windows 10, my implementation is around 5-20% faster most of the time. You can try it bellow: 

These are easily fixable. Fixing this may solve some quirks when you spice up your page, in the future 

As @Dan said, you are re-re-re-re-re-forcing jQuery to painfully look for the header, every time you scroll. Can you imagine how slow that is!? I will take @Dan's suggestion and change it a bit: 

Shows that it still takes 4-5 milliseconds, on Google Chrome (on my pc), while @Kruga's ES6 answer is a lot faster (0.9-2 milliseconds). Here are some improvements I've made, without any regards to keep the programming style integrity: 

Still, there is no validation of the data. And there's no way to pick 0.5â‚¬ (50 cents). You should look into that. 

This part can also be used for the block. But a major concerning area is that regular expression. It is made to match newlines, the first and a space and . Here's my proposal: 

You trust too much in the user. You have no validation what-so-ever! I could say I have 5 coins and then only give 2 denomination in the wrong order. What would happen? 

But only profiling will tell you if / how much speed improvement that brings. Also you should always profile before trying to optimize. See were the bottleneck is. 

In my point of view you cannot implement and any clearer or simpler. In the method I would somehow separate the values and also not print two times and not at all. Here is my suggestion: 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

You can also unroll the - loop, by copying the inner body 2 more times. If you can manage to change the mask_function: 

You could extract the content of inner loops to methods with speaking names. E.g. You could introduce a method like 

REMARK If there is any rule for the distribution of the intervals, you might be able to calculate the correct interval (or at least calculate a good guess and search from there). 

If possible I would try to avoid a method like . If someone manages to manipulate the this becomes a classical injection problem. If you do not need the flexibility to make any kind of db requests, use prepared statements for specific requests which only get some parameters. 

I think this method is not that long that you really need to refactor it, but you could do something like 

If a number can not be divided by 2 it can also not be divided by any even number. So you can check2 and than only the odd numbers. you can make a list of all little prime numbers and check these and from the point where you have not the primes, try all odd numbers you can stop checking at sqrt(n) but that is quite expensive to calculate. Not so good, but still halves the work, stop at . 

The main problems with the code resides in tight coupling between UI logic and business logic. For example the function: 

You should avoid mixing calculations with input/output. It would be better if your would not call the output function directly, but instead would just return the result of its calculations: 

As @kruga and @qntm have pointed out, it's easy to write a function that checks for the right ordering as long as the input only consists of numbers. Like so: 

For me the main semantic question is whether you should have a section containing articles or an article containing sections. Or perhaps even an article containing other sub-articles. From the HTML spec: 

Well... this function doesn't really do what its name says. It in itself does not process the arguments, it only create arguments parser. I would personally suggest implementing so that it actually processes the arguments and returns them, so you can pass the result directly to : 

But all the places where method is used, could actually use the method instead. This should make one realize that this whole Tile class could be completely eliminated and replaced with a plain boolean value instead. Other smells 

So your component test really is more of an integration test, not a pure unit test. There are basically two ways to improve on that: 

I would not worry about efficiency here. Rather I think the search is not very useful: you can only search by exact value of "to" field. Try to make it work so that you can filter by only writing part of the destination name, like "Ams" instead of "Amsterdam". Filtering on every keypress would also be nice. Note that the filtering isn't applied to the newly created entries. 

How to compare the the Algorithms: Either determine the complexity of your algorithm and the complexity of the solution in the tutorial. If you want to avoid to determine the complexity based on the source code you can simply implement the tutorial solution and compare the runtime of your algorithm and the runtime of the of the tutorial-algorithm. To get a good idea of the complexity behavior of both algorithms you need inputs of different lengths to approximate the runtime related to the size of the input. How to improve yours If your approach is very different you might not be able to improve your algorithm by looking on the tutorial-algorithm because they are too different. If the Tutorial-algorithm is better at all, you can try to understand the steps it does and try to memorize the general idea of this steps for your next algorithms that address similar problems. 

I think you can improve the 'Inverse rotor pass' a lot by hard-code the inverted rotors instead of searching the inverse function every time. Your is never below so you could try to replace 

I have never written any Lua code before, but a short view in a tutorial at $URL$ let me come up with this: Extract a method which returns 3 values: 

And so on until you have only short methods with speaking names. This makes the code easier to read and understand. 

I recommend to do the in a separate method (or simply use I recommend to use instead of I recommend to return an array with the size matching the new number of entries. even if might be cheap to compute, you should avoid computing the same over and over again in the loop-condition.