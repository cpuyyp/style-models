@goldilocks provided a very sound answer on sources modification and why you don't really need that. I wanted to add that your real goal is probably getting some specific things configured - for that you can follow this simple route: mount the card image and modify its content to meet your specific needs, including semi-installing additional software or change default configuration (network interfaces, autoruns, additional scripts you may want to add). This is what I do for my RPI boxes - I'm using them as smart home agents plugged into network in different areas of the house - they are able to discover network and start acting as soon as powered up. 

Run terminal on your mac and do You should see two lines, one with local loopback (127.0.0.1) and another one with the IP obtained from the router (192.168.XXX.XXX) Check that the IP you are trying to reach is within the same subnet with yours (only the last number on the IP should be different) Another way to check if you are on the same network is doing a traceroute to this IP - should be one hop, not many. SSH to it and answer "yes" when it's asking you if you want to establish the connection. 

You are probably going to get your best answer from official RPI web site. There are hints in their FAQ section that kind of give clues to what your chances are: Will you sell a self-assembly kit? 

If you are editing individual crontabs, you don't need to specify the user and should not edit the file directly and instead use crontab -l to view your crons and crontab -e to edit them. 

Are you editing /etc/crontab or /var/spool/cron/crontabs/*? can you copy the output for the whole file? 

A better way to organize this would be setting up a media client as mentioned above. Here is a good article on this. 

There are quite a few posts raising pretty much the same issues as yours I believe. Here are a couple. Most advice that you make 100% sure your power supply suffices RPI and the HDD needs. Not only your HDD needs to be supplied enough power but the RPI, too. Disconnect everything from the RPI, leaving just the network and the HDD and see how this helps. I don't know what your hub make/model is, but mine has two ports that provide 1.2A each whilst rest of the ports on it only do 500mA and will require a Y-cable to connect to HDD. Check into that to see if that helps. 

I'm currently building an application core for my smart home project - there will be 6 to 10 devices on the network each controlling its own area and performing different tasks and operations - security, notifications, sensors reporting, controlling lights and devices, et cetera. RPI can be treated as a regular computer able to run regular and odd operating systems. It does meet your requirements although you seem to mix hardware and software requirements into a single stack which is bit odd. It is not clear from your question what the primary focus of Internet of Things you are attempting to build. I see two key fields Internet of Things is valid for - knowing/sensing and controlling/operating. Both are possible to a good extent with RPI in its current hardware and software state. Sensing and computing for anything complicated may not be always possible with RPI - things like face/voice identity and recognition without assistance of other hardware will be either slow or impossible, reading data off sensors and controlling servos and lights is easily done - most of stand-along solutions for this types of tasks being sold are done using hardware that's way behind RPI specs. I'd suggest that you identify your key priorities and look for example implementation with RPI. 

I downloaded and installed LibreELEC 7.0.3 onto RPI2 and it won't connect to WIFI. I can't even view logs via KODI standard UI. The power button on the left bottom does not have 'exit' option - only reboot and shutdown and custom shutdown timer. Is there a way to exit to command line or boot to it? 

What happens when you enter 'yes' to the SSH prompt though? You are playing with two different IP addresses, this could be the problem. Best way to get the IP is logging into your router and checking for the right one. If you can't do this for some reason, try this: I would assume you are wirelessly connected to the same router/hub with your RPI 

You can edit /etc/rc.local and include your command before its exit statement. Then to enable it And to reboot and see if that has worked out for you. 

I checked on my RPI and it looks like executable permissions is set automatically by g++, so you might be missing the './' bit before the program name you are attempting to run if you are in the same directory with the binary: 

You need a minimalistic Linux Pi distro like PiCore. It boots to command prompt after just 7 seconds, and it needs 25 seconds for X. You can play with it in QEMU if you want. 

If you can live with Google Maps alternatives instead of Google Earth, then you can even download all map data and use it offline for free (OpenStreetMap). Useful Raspberry Pi project link is here. 

You can use TinyCoreLinux. At the moment of writing this one was the latest one with just command line and SSH, having a little more then 18MB zipped. Versions having X in it's name are with GUI. And yes, there are QEMU (virtual machine) images to try too. There are many packages ready to be installed, and you can also make your own or install from source. 

That is not possible with Pi, since it has HDMI output instead of HDMI input which you would need for your idea. However, according to this specification page, it seams that Canon 5D mkII already supports composite video output, so you should better check you Canon 5D mkII cables and manuals. 

Any external USB battery pack with built in overcharging protection will help your Pi survive power outage. It will simply work as a poor man UPS for your Pi. $URL$ 

Your best chance is to try if sigrok and it's frontend libsigrok can be compiled on Pi, and then buy some compatible oscilloscope hardware. That way you can grab signals up to 24 mega samples per second. With enough knowledge you can customize the software any way you want, including wireless transmittion to mobile devices. 

By a quick look it seams that Razberry uses SPI and serial port, and that Raspbee uses serial port. Serial port is not shareable, so you would need to use two of them, with a lot of hand made rewiring and changing software to enable using both at the same time. Instead of all this mess, you might want to consider EVE, a RPi wireless shield with connectors for Zigbee, ZWave, EnOcean and 433/868/915Mhz RFM12B module. 

You need to use RS485 for connecting instead of RS232. Then you can have single master (RPi) polling multiple slaves (AVRs) one after another in a loop. For this you can use MODBUS or some other similar communication protocol. 

You can detect if you are booting after power failure using a script similar to the one in the last message here. No need for GPIO or UPS. The only condition is that file system is intact. You can make sure it is intact if you make it read only, and only make writable before writing just a partition where you put your power failure flag file. Using battery backup makes it all just a little harder. Use WiringPi lib to detect change on GPIO pin. On pin change just execute script and shutdown RPi and cut of battery backup. Then on power up you have to activate battery backup. 

If you are really concerned about protecting your intelectual property then you can combine your Rapberry Pi based application with some external custom made micro controller (MCU like AVR, PIC, 8051...) based hardware key (connected to Pi via USB, RXTX, I2C, SPI, 1wire...). For example, Pi side application generates a random number which is sent to MCU, decoded and sent back as an unlock key to decrypt something important. Then additionally you have some important function executed directly in MCU (you just pass parameters and get the result from MCU). You can imagine how that would raise cracking difficulty for a hacker in order of a magnitude, since his knowledge would have to be much wider then usual. There isn't a perfect protection, but if you really want to make it a challenge then this could be a way to go. 

If you can put a pi with camera above parking, you can use OpenCV library to find out free parking slots. Beware, this is not a project for beginner and requests intensive development work. 

If you take a look at mikroBus specification, you can see that there is 1 digital input, 1 digital output, 1 analog input, 1 analog output, RX/TX, I2C, and full SPI (with CS). This means that all boards contain electronics which exploits one or more of these pins/buses. You will have to take a look at each click board schematics to determine how to use that hardware. Sometimes it will be simple pin usage, but sometimes it will need analisys of SPI or I2C protocol details from datasheet of a chip found on click board. Bad news is that on Pi you can not use mikroE examples since they use drivers from their own compilers which do not have any source publicly available, but good news is that you can find on the net many examples for communicating with click board microchips for some microcontroller, or even beter for Linux itself. Linux might even incorporate some drivers in it's kernel, and some might exist but not included by default so kernel recompilation will be needed. All these things are not specific to using mikroElektronika click boards on Pi. They are general for interfacing any hardware to Linux. If you are looking for an out of box solution, this might not be the path for you. Otherwise, there are many things you need to master. Welcome to embedded world ;-)