It is rather poorly documented, unfortunately, but I gave it a try and it does indeed work well. It can be installed with: 

This appears to be the same issue as bug #837788 in the Debian bug tracker. It appears that this is actually by design, and Munin installed without any problems from the repo on your Pi: 

To add additional accessories, you need to add more blocks inside the key, like this (I've clipped all but the relevant bits to make it more obvious): 

It looks like you're not getting the PID until the process has finished (and it's not particularly clear that your attempt to get the PID is working at all; it looks like it isn't!). I'm guessing your pipe simply blocks until the image viewer exits, at which point it's too late to kill it, even if the command did get the right PID. You can just get the PID of the process of that you launched with , e.g. 

This should ensure that your installation is working correctly. I'd then try installing a fresh copy of CouchDB (perhaps try 2.1.1 too?). 

Note that the was necessary in this example so that didn't block and launched in the background, so our script could carry on running. You can adapt this to suit your needs if there are any special constraints you have. 

This should technically resolve the issue, as long as you sort out the glob. Bear in mind this isn't terribly secure or good practice, though, but it does address your immediate problem. 

The door operates similarly, but with block ID instead, and you'll need to modify the (up/down axis, with positive being up) instead of the (north/south axis, with positive being south). 

You should, hopefully, have the second audio file running after the first one is done. This relies on exiting when it finishes broadcasting, and not earlier – if it does exit after broadcasting is finished, you can simply tell Node to wait for it to exit, and then you'll know that the file has definitely finished broadcasting. Give the above code a test, and if it does work as expected, it should give you the building blocks to make the code work as you expect. 

Unfortunately, you will not be able to modify the Pi to support Vulkan, as the issue is the GPU capability. The GPU is contained in the BCM2837 system-on-a-chip, as you can see here: 

esekeyd is an alternative to using keyboard shortcuts in Openbox, which will work even if X.Org isn't running. As noted in the Debian repositories: 

(replace the example with your desired script; represents Alt+Shift+K, and remember that if you change this, letters should be lower-case – see this section for all modifiers) Save the file, and restart. Your new key binding should then be ready to use! 

Note that since this configuration file is stored in the user's home directory, the autostart only works for the user you choose. 

This is by no means a complete list. You might like to also read How to backup settings and list of installed packages on Ask Ubuntu for some ideas on how to get started, but I suspect you'll have an easier time doing at least some of the configuration again, without copying it over, simply because it's so hard to actually find every configuration file. 

It also appears to be available in the Debian repositories for Python 3 (install with ). It is a little outdated though at version 1.9.3 for Stretch, so if possible, pip is the preferable solution, which will install version 2.2.7. 

As Octave has quite a few dependencies, I suspect that it's probably easier to use Stretch if possible. While compiling and installing it yourself is an option, it's going to be very slow and difficult compared to using Stretch or Jessie Backports. 

For further information, check the link above or use to read the manual page. The Pi Zero uses a BCM2835 SoC, which supports Broadcom's proprietary media acceleration features. can take advantage of this to gain better performance than software-accelerated playback. To track whether playback has ended, you can use the function in Python. Presumably, when playback is complete, the function will return 0 (exit code 0 implies success, generally, on Unix systems). The call is synchronous so your script will wait until playback is complete until moving to the next line. 

That line is setting an environment variable called . That's not an unusual thing to do for sensitive data (e.g. passwords and tokens) as opposed to hard-coding it into the program. While you could edit the activate script to create the environment variable there, I personally wouldn't. They aren't really designed to be tampered with, and as you can see, it's not a trivially short script and so I'd err on the side of doing things more conventionally. Consider some of the more standards ways of setting an environment variable: 1. For one command 

As you can see here, MariaDB's 10.2 builds are only for i386 (32-bit), amd64 (64-bit) and ppc64el (PowerPC). Your Pi has an ARM processor which needs a particular build for that architecture. Unfortunately, even the Debian sid (unstable) repositories don't have an ARM build for 10.2, so you can't use that (though using the unstable repositories is a little risky at the best of times for your system stability). Since there's no package, you will have to compile MariaDB from source. Note that compiling large projects from source typically takes a few hours, and there is a chance that it won't work. If you absolutely need MariaDB 10.2, this is what you'll have to do, but you might find it a good idea to look for an alternative option if possible. 

Generally speaking, JavaScript scripts are not given direct access to hardware by the browser. This would be an enormous security vulnerability; imagine going on to a website and it can then access everything connected to your computer. Not good. That said, you can still achieve what you want a slightly different way. Your Pi needs to be a web server; you could use a library such as Python's Flask to serve up a simple web API. Then your client-side scripts can simply send a request to your Pi server, which then fetches the data through Python. A trivial example would be as follows: 

So, with 8 LED matrices, you're looking at 330 mA * 8 = 2.64 A, which is probably beyond what your PSU can supply. Also interesting: the documentation for the LedControl Arduino library, which goes into detail about the hardware decisions you will face. Note that the current draw will depend on the LEDs that you've chosen — as pointed out in the section 'Selecting RSet', if you have LEDs demanding only 20 mA, you'll only have a 170 mA typical draw. 

Below to tell systemd to send a SIGINT, which is translated as a exception by Python. This should then run your graceful exit logic. 

The easiest way would be to use a pre-made module to communicate with Wit. Usually, searching for whatever you're trying to do along with "Python" brings up many libraries, and I found pywit quickly by searching for "Python Wit.ai". Instructions and usage guidance is given there; you can install it using Pip with . ( for Python 3) You can send a request to Wit to convert speech to text as follows: 

(emphasis mine) You will need the full version of NOOBS, not NOOBS Lite, if you wish to install Raspbian offine, unless you add a custom OS version to NOOBS Lite. 

Looking at the graph, it seems clear that disabling won't actually speed anything up anyway. As you can see is waiting until completes, so a 1.6 second load time for run in parallel won't affect the overall boot time at all. There's an idea in scheduling of a critical path which, when any activity in this path is delayed, causes delays to the entire project. The other activities have 'float', i.e. they are not critical, and can be delayed without affecting the final finish time. It is this critical path which you must save time on, not the non-critical activities. will help you identify the critical activities, although you can pretty much spot them on the plot. Any marginal gain in would help your boot time significantly. It might also help to understand why your services take so long. For this, Bootchart2 might be useful. It can be installed with: 

Poorer quality cards probably won't even manage that, so a heavy load on a hot SD card will likely lead to it suffering a premature failure. Below 50 to 60 degrees Celsius, there should be few concerns, and most components should last a reasonable lifetime. Above this, heat sinks and cooling mechanisms would be a wise idea — there are some ideas here. Short periods at extreme temperature around 85 ºC may be manageable, as long as the exposure is not for a very long time. 

In Debian, Python 3 compatible packages are explicitly named . Packages such as and are the Python 2 versions of those packages; you will need to install the Python 3 versions. Packages generally don't provide Python 2 and 3 modules — they either offer Python 2 or 3 modules individually. You will need to run: 

The directory it'll create will be called , not (so replace all instances of with in the steps). On Linux, you'll need to use as the path separator instead of . You'll also need to use , not (that's noted in the documentation for ). 

Note that for the Pi 3, the 1 A current input is inaccurate; the Pi Foundation recommend 2.5 A instead. pinout.xyz suggest that "with a decent power supply, such as the official Pi adaptor, you can expect to pull about 1.5A." The MAX7219 datasheet states that: 

Solarized is apparently built-in to LXTerminal 0.3.0. One solution to your problem would be to upgrade to 0.3.0, which is available in the Stretch repository. It doesn't look like LXTerminal is in Backports, so upgrading to Stretch would probably be necessary here. 

This leads you to this GitHub repository, which contains , which would seem to be the library you want. Simply download that repository, extract the files to the directory of your script, and then running should work as expected in your script. If you're not familiar with why that will work, you might find the "Import System" documentation valuable to read. 

This assumes you save the file as in your home directory. Also, remember to set in your terminal (you only need to do this once—don't put it in the ): 

You may be told of some conflicts. You will need to resolve the dependencies (possibly by installing those packages also with the older versions) and also it may be wise to 'pin' the old version so it doesn't get auto-upgraded again/ 

Assuming you're using an HDMI connection, the power on signal is probably sent using CEC, which is a feature of HDMI. To disable CEC in OSMC, you'll need to SSH into your Pi, then open . Here's how to do it with the editor: 

Then, you need to add the Jessie repositories to your Pi's sources. Create a new file in called . Add the following into it: 

Note that you'll lose all power on ability from the Pi by doing this. Once you've set that, press Ctrl + O to save and Ctrl + X to exit. Reboot your Pi, and test if the issue is resolved. If not, it's likely to be a setting on your TV which switches it on when an input changes. Consult your TV documentation if that's the case. 

The earliest you could realistically run your service is after , when the low-level services are initialized, I suspect. The systemd configuration above will execute the script path declared by after is complete, which should be relatively early in the boot sequence. 

Yes, you can install specific packages (in theory) from older versions of Raspbian. There is the chance that packages may conflict, but apt will let you know if there are any serious conflicts that need your attention. First, remove the current version of Chromium: 

in your terminal, on a new line. Then, the variable is set until you close your terminal. 3. Using .bashrc If you wanted to set the variable permanently, add 

One of the questions you linked actually does point to the answer: in Django 1.8, the function became obsolete, and was replaced with a normal Python list. The correct would be as follows: 

(you can do that in the terminal by running , typing the line above, then pressing Ctrl+O then Enter to save, then Ctrl+X to exit). Then, rerun the Gradle build (you will need to change directory back to where you were before with ) and test to see if that works. If it doesn't, try tweaking the to other values, and if none work, you are likely out of luck. 

You cannot 'fuse' two Raspberry Pis in the way you're thinking—it's simply not possible. Computer clusters do exist, and indeed, some people do make clusters of Raspberry Pis. But two slow computers don't make one fast computer, generally speaking—clusters of computers have quite a narrow use case. It would probably be a waste of your time (and money) to try and build a cluster to make video playback faster, so I wouldn't advise it1. Clusters work well for large computations that can be done in parallel. Imagine you need to cut 1,000 pages in half with some scissors. It'll take you a long time to do, but you could give 100 pages to 10 friends and they'd do it in a tenth of the time... but, each individual page doesn't get cut any faster, and you have to co-ordinate splitting the jobs and re-assembling the pile at the end which takes a little longer. Cluster computing is largely the same, so if your task isn't something that can be parallelised, then you'll see little benefit. If the video is stuttering, you really need someone who can cut their pages in half faster, not more people—ten people trying to cut one piece of paper takes just as long. In the same vein, you need a faster computer, not more slow Pis in a cluster. If you're keen to stick with the Pi, you should really address why the video playback is slow—try to figure out what is causing the slowdown, and perhaps look around this site and ask for more help if you need it. See also: Why Use a Cluster? on eTutorials.org, which explains what use a cluster is and when you might use them.