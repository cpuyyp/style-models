To make this work, if we assume that you want to record through device 0 and playback through device 1, then you need to alter the .asoundrc file to be like so : 

I suggest that you look into a sound card which has all of the features which you require. The reason why I suggest this is that generally you can only have one sound card on the GPIO headers. There are several sound cards on the market which support both input and output, some of which also have on board microphones+ input RCA connectors. Elinux has a short list of some such sound cards. It should be possible to record from both a microphone and line input with some of them. Finally To solve the problem of requiring an external microphone over the RCA input lines, you will need to find yourself a suitable microphone preamp. If for example you are using a dynamic microphone, there are plenty of balanced or unbalanced options out there which let you plug the microphone into the preamp and give you RCA outputs. Alternatively, if you are using a condenser microphone, you will need to plug a phantom power unit prior to the microphone preamp. Some preamps come out of the box with phantom power. Finally, if you are using an electret microphone, you will need to find a suitable external preamp which supports electret microphones. 

I would like to measure the mains power (120vac/60hz) to know precisely when the voltage drops to 0, but in a safe manner for the pi - one solution would be to use a high-value resistor bridge that measures the peaks, and then add (1/240) seconds to when it detects those, but I am wondering if there is a safer/better alternative. 

I have seen many small displays that work with the Pi, however I am wondering if any of them can be turned completely on/off via the Pi. If so, what should I look for? many are GPIO based (especially the smaller ones or touch-sensitive ones), so CEC code support isn't quite enough. The application I want to use this for is a "weather display" that shows the weather forecast, but only during certain hours (not during the night - it needs to be completely dark then). 

Alternatively you could get one of the sound cards which have inbuilt input/microphone and output ability, such as the ones listed here. This solves a lot of problems, as the same clock is operating the input (ADC) and output (DAC). I see that was your original situation, and am wondering why you changed to purchase the USB input. Matt 

A sound card for the GPIO bus will be coming out soon which supports more then 2 channels input and 2 channels output, see here. Until this happens, you will need to resort to multiple usb sound cards. The problem with multiple USB sound cards is that they will suffer clock drift. With that in mind, you can do the following (taken from the ALSA asoundrc page); Create the file ~/.asoundrc with the following in it (changing the hardware devices for the ones on your system and duplicating this example from 2 to 4 devices) : 

"Over wifi" is somewhat vague - which device will be acting as the access point, the Pi, the notebook , or a router? Once you have both the Pi and the notebook connected to the same wifi (and provided wireless isolation is disabled), you should be able to ssh into the pi and have access to it - ssh as root or equivalent, and you will have full access. In order to SSH into the Pi, you will need either it's IP address or it's network name - the network name can be configured in the Pi, but the IP address depends on how you intend to configure the wifi network. You will also need a SSH server enabled and running on the Pi While there are many programs that can be used to SSH into the Pi, Putty is probably the most common one used by windows 

This command sets the Master volume to 0 dB. You can list the available simple controls using the amixer scontrols command, here is an example : 

There is an incomplete short list of sound cards available here on eLinux You will most likely want to use a GPIO board rather then a USB sound card because of the USB latency issues. I think you can get latencies as low as 1ms or less in some cases. 

Alternatively, you could program your own algorithms to generate waveforms either to file or in real time using libsox, jackd and even ALSA, here is an example set of programming tutorials using gtkIOStream. 

This will accept voltages from 7-35 in the input, so despite it showing 12 as the input, it will work fine for 24 as well, provided your Cin can handle 24v (assuming you need it - depending on your power supply, you may not even need the input capacitor). If you are uncomfortable building it yourself, there are various versions pre-built available for sale on ebay and similar, although they may not be using components that can handle the full 3A that the chip supports. 

While the suggested 7805 will work, it is also incredibly wasteful - assuming your Pi takes 1A input at 5V, the remaining 19V will be dissipated as heat - 19W of it, which would require quite the heatsink (and likely a fan as well). Instead, I would suggest using a switching regulator, such as the TI lm2596 instead - it will require a couple more components, but will be much more efficient. Here is a sample circuit from TI: 

There are some sound cards which have audio input and output on them. If you need to hear what is coming from the audio input and record at the same time, there are a few options, such as ; 

If it sounds good when using omxplayer, then you don't need to replace the sound card or anything like that. If you hear distortion, it would be interesting to know whether there are underruns, where you application isn't presenting data fast enough to the ALSA driver. Which sound library are you using in java ? Perhaps you need to understand how to turn the volume up and increase the playback block size ? Matt 

a lightbulb, motor, etc. use a transistor to drive it - for a higher power one, use a transistor to drive a relay to power it. an analogue input - use an analogue to digital converter (or build one) 

SD cards (the full-size ones) can use up to 330mW of power (100mA at 3.3V) - The Pi is known for having difficulty with certain high-speed (and thus high-power) cards, so I believe it is less than 330mW - but how much less? 

There is now a Pi zero variant, which can do what I wanted, and Adafruit made a tutorial for it: $URL$ The official name for this seems to be "usb gadget system", and simply requires an OTG cable. I haven't been able to test this, as Pi zero's are out of stock pretty much everywhere, but I do think that this is currently the best route 

Apart from solving these problems you mention. The audio out of the Pi is pretty poor in general. I think it is best to use either a USB sound card, or a GPIO header sound card like one of these. The reason is that the audio codecs which they use are far more linear then a pulse width modulation (PWM) strategy which the Pi uses. This linearity implies much better sound quality. 

There is a coding tutorial here which demonstrates a full duplex client for jackd. Full duplex means recording in and playing out at the same time. By using a full duplex client, you can process the input and output as required. There are also links there for suitable cards with inbuilt microphones. The lowest latency you can probably get is around 1ms in and out (say 50 samples at 48 kHz). You will probably want to target around 3ms latency before the performer starts to feel uncomfortable with latency ... but you can probably push that a little. That set of audio programming tutorials also demonstrate how to open, read and write almost any type of audio file. The base library used is SoX which has the capability to load and save many different audio formats. For that reason you can pretty much pick and choose any audio format you like. If you want lossless audio, then something like wav, flac or other will do. To bring your processing needs down, as you are using voice, work out the upper frequency which are in your files and drop the sample rate to double that frequency. For example, if there isn't much audio data above 12 kHz, you can drop your sample rate to 24 kHz and save a huge amount on processing requirements. Consider that the first formant of singing is probably between 2kHz and 200 Hz, which means that the third formant may not be much above 8 kHz. Because you are talking about vocalised sounds, you aren't too concerned with consonants and consequently the high frequencies are not going to be present. It may be different for your recorded instruments. If you can push your sample rate down, then you can probably get better latencies. Do you have enough memory to load an entire set of chords into memory ? If so then extra delays/computation in file loading and waiting can be removed.