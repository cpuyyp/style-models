Remarks on the Code [] The use of demonstrates the understanding data validation is important. It is a clear strength of the code. [] The line is a bit weaker. In part because is equivalent. In part because if the reason for using is to express intent, then more clearly expresses that intent. [] The code phrase: 

Alternative Implementation It is worth noting that this implementation was written at leisure. There was not the pressure of a technical interview. It was not written while the primary concern was getting a job. There was time to drink coffee and think. There was time to take a walk and think. There was time to refactor in my favorite editor. 

Modularity All the definitions are in the same lexical scope. For example is in the same lexical scope as even though the only place is referenced is within . In addition is defined between them. Organizing the code: 

The three functions {, , } are used within the function which takes a value and returns either a string {'fizz', 'buzz', 'fizzbuzz'} or . The big-hairy nested is written to be more easily translated into a lower level language where {, , } could be inlined should additional optimization be sought. 

It contains three functions {, , } which take a number and either return that value or an appropriate string: 

Caveat: I'm taking the code seriously Background The abstractions are leaky. What is a Node? A node has two parts: the value it contains and pointers to other nodes. Either, both, or neither may be null. When the pointer part is null we have a terminal node. Depending on context a terminal node might be called a leaf or an atom. Graphs One or more nodes form a graph. A graph may be directed or non-directed. Some, all, or none of the nodes in a graph may point to other nodes within it. The way in which nodes point to each other is what distinguishes one type of graph from another. Whether a node contains null or some other value is a detail of a graph implementation not nodes. A node's pointers to other nodes are the edges of a graph. The value stored at the node is a record. The structure of a record is not a function of the graph or the node. It is an implementation detail of a particular program. That is to say that the record structure reflects business logic. The edges of a directed graph are directional. The directed edge is different from the directed edge . The edges of a non-directed graph are not directional. The non-directed edge is indistinguishable from the non-directed edge . Traversal is an operation on graphs. The order is not a property of the graph. It is a property of the business logic. The efficiency with which we traverse a graph often depends on the alignment between business logic and graph type. Trees Trees are a class of directed acyclic graphs. A graph consisting of a single node is a tree provided that it does not have an edge pointing to itself. A graph that consists of several trees is called a forest. A tree in which each node has two outgoing edges is a binary tree. Typically, one edge is labeled left, the other right. A binary tree may or may not store values at internal nodes depending on the business logic being implemented. Binary trees are of particular interest in computing due to their isomorphism with binary logic. Another important class of trees for computing is the b-tree. Code Improvements To a first approximation, the leaky abstractions can be removed by redefining and then using it in a definition of a . A Node Implementation Since the number of edges a node has is a function of both the graph type and a particular instantiation of that type, an iterable data structure makes sense. A list is probably the place to start. 

The test is true when the inductive base case is false. The action on the base case comes at the end. 

Sorting algorithms for an array are baked into most programming languages or can be found in a library [the kind with books if not the language's standard ones]. Sure they don't handle arbitrary objects directly, but they all handle integers appropriately for the purposes to which the language is usually put. These are off the shelf parts. There's a whole chapter in Knuth for anyone needing to take seriousness up a notch. Keeping the array sorted while changing it's values means concurrency semantics. That's the sort of hard problem that matters to a sensible interviewer. Presenting an unreliable answer in O(n log n) is often worse than a reliable one in O(n^2) even if a reliable answer in O(n log n) is preferable. 

The code is readable, and appears to be correct. That's a pretty good starting point. It's shorter than what's presented here. I'm always skeptical of the word "Pythonic". The original code may be more Pythonic than that presented here because it is more explicitly procedural. Then again, someone could come along and claim that because Python has objects, true Pythonic code is object oriented. Down at the level of a single statement or expression, there are some dominant idioms. But up at the level of programs "Pythonic" is mostly part of a pejorative "Not Pythonic". The problem is such that there's no good way of avoiding the fact that there are four cases. Where the code in the question is weak is the level of abstraction at which the four cases are articulated. There's lots of fiddly-bits around columns and rows and limits up near the top-level of the function. Even though our top level abstraction is a diagonal. The mathematics works, but it's not obvious exactly why. One way of thinking about Remark 2 is that the code 'one level down' is reductionist rather than compositional. It expresses itself in terms a bit more like 'machine code' than 'business logic'...or perhaps the mathematical logic suggested when linear algebra was mentioned. 

Details to handle input output should be at a higher layer of abstraction. It shouldn't matter to the game engine if the game is between a human and a computer, two humans, or two computers. It shouldn't matter if it is being played using a laptop or over the internet. Data Structures A good rule of thumb is to replace complex logic with a data structure, and 

Style Format Racket tends to use two space indentation rather than Python's four spaces. This keeps code from indenting too far to the right and because Lisps allow multiple expressions on a single line, reduces the issues with lines becoming uncomfortably long. Keep in mind that "left banana"s [ ] are also there to help the reader. Names The big ambiguous name is . What does it split? How do I know that it it can't be used on vectors? The naming is inconsistent: should be per Lisp's conventions. However, would be more descriptive. Personally, I'm not a fan because it looks like in many typefaces. More importantly I have no idea what a is other than a key on my keyboard. Please give the reader something like and . Generally, I find that and are more readable than and . The advantage of the latter pair is their composibility into etc. And if I find myself using that, I consider giving it a name that describes what it represents in the program's business logic, e.g. . In the same vein, I agree with your intuition about using is more clear. Code Smell Treating a list as a vector Your intuition about is also sound. Lists are ideal for providing sequential access. They are poor for random access with indices because reaching the th element requires following a sequence of pointers from the element until elements have been visited. Likewise, determining the of an element list requires traversing pointers. This can quickly put operations into O(n^2) time complexity or worse. Inline Logic is a hint that isn't a particularly clear way to express simple logic. An Illustrative alternative The basic structure of the procedure is similar to Racket's built in in that there is a recursive call to an inner procedure that does the heavy lifting and is initialized with the values from the command line. Note that still takes as an argument. This allowed building it up and testing it before wrapping it between and the trampoline . 

To expand on Rofl's point about efficient data structures, the most efficient data structure in terms of space is code, and currently this is a space constrained problem. Values The set of all permutations of a collection of lists is a constant value, not a procedure or function. This means that there are really only two ways it can be used: 

Caveat: I am not a Matlab expert, nor am I competent at an advanced undergraduate level in mathematics. Efficiency Removing data structure impedance and redundant or unnecessary calculations is likely to improve the running time of the code under review. 

Generative approach The idea of functionally generating the next value from the current value rather than mutating a location is consistent with good Racket practice. Naming 

Warning: The following is opinionated at times. At other times it is more opinionated. Channeling PG I've heard on the internet so it must be true, that Paul Graham will get right to the point when interviewing applicants to Y-Combinator with "What problem does this solve?" It's hard to understand code without understanding what it is supposed to do. And only Google and watching a video twice make me think I might. Since I still don't understand the code though, I can't tell whether it solves the problem or not. The "water pouring problem" is a canonical toy problem in programming curricula. Wolfram Mathworld describes it as a special case of the three jugs problem. The special case is where the third jug: 

The Good Thing The code works and does what was intended. Making it shorter and improving readability are improvements not bug fixes. Readability It is hard to follow the logic of the code. Adding a documentation string and comments would assist a future programmer (which might be the program's author in a few months) in figuring out what is going on and guide the programmer in making changes. Names The name does not follow traditional naming conventions for Lisp programs. Hyphen case is more typical would be more conventional. I'd probably favor adding a few extra keystrokes for legibility with because it is more readable and often spend longer reading code than writing it. Philosophy As noted in the accepted answer Emacs Lisp provides the function as a simple way of determining if a value is in a list. However, it is possible to mean different things by 'value' depending on context. Emacs Lisp addresses this with additional functions such as , etc. to provide more stringent set semantics for lists. Emacs Lisp also provides a more general for contexts where strings matter. For example working with string values: 

Like I said, it ain't exactly pretty. Like I didn't say, this might be more efficient on paper but not in real life. Modern compilers do a lot of sophisticated optimizations including JIT'ing at runtime, and CPU's that do predictive branching optimization. Therefore optimization should begin with measuring something that works and determining where the actual bottlenecks are. The other answers that optimize around are examples of why ideas about optimization are not always actual optimizations. On the other hand, the general approach of precomputing a cycle is applicable to other languages and other problems and the larger strategy of avoiding work is a good place to start changing code when measurements indicate changes are warranted. Final Comments I appreciate that the code in the question seeks to generalize the problem by tackling the 'Arbitrary FizzBuzz'. I also like that all of the modulo's are done in one place...one of the optimizations that are built into Python is optimizing development time.