Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

Main thing is the first issue, the listener has to be in the global scope. I recommend either or the jQuery to listen for the event on the elements. 

I don't know if this is better, but might be more flexible to have a parameter for a factory function that creates the objects you're filling the with. I also added and parameters so subsections can be replaced instead of just the last elements. 

I recommend using bluebird for promises; it has a ton of nice features that really improve quality of life and seems to be faster than the alternatives by quite a large margin. (Note: I only briefly looked over the JSPerf, but it seems to be done well enough.) Using bluebird (and a few other adjustments), the promise version of the code can be simplifed to: 

Nice work. You can make a lot of headway by using attributes. These are attributes you can add to any element to store whatever you want in them. They will be available on the property of the HTMLElement, and will always have string values. For instance, given the following HTMLELment: 

You'll notice I'm using classes of the form like , that's because it's nice to separate CSS class names that are used purely for JS from those used for styling (more info). The full JavaScript: 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

In , the leading unary operator () is used to convert the string values to numbers. Just a side note. 

The JS files should go at the end of the . Usually, you want all JS in external files. In practice, I find the only exception to be when the server is injecting data, for instance, if data about the current user needs to be available to JS it would go directly in the page and not in an external file. 

With that, you can generalize what you're doing with your handlers. On each case, you can store the case number (1, 2, 3, 4) in a attribute, and store the following case in another attribute . 

Generally, attaching event listeners in markup should be avoided. A couple reasons off the top of my head: 

The casts to a boolean. It's not required since an empty string is falsy, but it clarifies the intent. 

I'm not a compiler guy, but I'll offer some feedback, anyway. Hope it helps. Nice work. Regular expressions are a powerful tool, but they can become difficult to maintain and sometimes to get right. You used them, they work, seems fine. I'd suggest making it a point to always use simple regular expressions (which you did). If you need more complex matching, using multiple simple regular expressions in a sequence or loop or in combination with character / string comparisons seems to work pretty well. To answer your questions: 1: Using integers does make error messages harder to read, so switching to strings for token types is a good idea, IMO. But, instead of adding properties onto the class I'd suggest doing something like the following: 

Now the first line says this: is of type , as long as the constraints in what we call the context are met. Here the context is what comes before the , and what it says is that , the type, is a member of the typeclass. This means that we're saying that any type which maps a to any type of is itself an instance of . Why are we doing this? Well, let's start with the simplest case. is an instance of typeclass , because we defined this 'base case' explicitly. Okay, so then is also of typeclass prop, because we said that any type is in class . This gives us the functions which take in one boolean argument and return a boolean. Examples: , , , . (In fact, these are all such functions). How have we defined whether to determine whether one of these functions is ? Our definition says that 

Notice how as soon as the grade matches the range corresponding to something in the Enum, the method immediately returns. Now an example of how you might use that : 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

2: Slicing the string is fine. If there is more to the question, then please elaborate. 3: Use of the variable to store the match is not too clever. I recommend against assignment inside the condition, though, it's just something that can be error prone, in general. Down the road you may make an edit and forget to have only one , or something like that. It's usually considered against best-practices, but is not invalid or anything. 4: As I'm not a compiler guy, take this for what it's worth (there is probably obvious conventional wisdom that I don't know about). Using a single token type for these four operations seems fine to me. They all have similar characteristics. But, it will likely be an issue if you broaden this usage to operators that have different characteristics, like the unary (e.g. ). Having said that, you may end up keeping these four operators under one type. You may end up wanting to group on precedence, though. 5: Not a question. One thing I want to note, the and methods are organized in a way that is a little strange, to me. You consume a token (move forward), then when you are getting the next token after that, check the type of the previous token. I like to have separate methods for the various tokens I have. For instance, you might have and . Each of these can attempt to consume the correct type of token, and if it fails return . The method that called them can decide if that is an error or if another type of token should be attempted, like . As a side note, a scanner I wrote for a DSL: JavaScript and Python. It uses a mix of regular expressions and character comparisons for consuming content. The scanner has a property and a property, and any time a token is created the content spans from to . Then, is moved forward to .