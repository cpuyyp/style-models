It's useful to encapsulate this because there's nothing about martingale betting systems that involves a random element, the system itself is entirely deterministic. 

This isn't a code review question, but I don't think it's particularly verbose. It's certainly no worse than JUnit looks to my eyes. 

(I would also replace in 200_success's answer with because that is maybe the greatest programming pun I have ever realized.) 

You should definitely separate the calculation from formatting the output. One of Haskell's key strengths is being able to compose functions. By confounding the definition of your function with the presentation of it's return value, you lose the ability to reuse it elsewhere. For instance, if you wanted to use to sum all of the numbers you were given, and then find the factorial of the sum, you couldn't with your code as-is without reimplementing both functions! Here's a composable definition of . 

I'm not sure that there are appreciable improvements left to make to . You could use and , maybe record update notation, but I don't find it that bad to begin with. Use even more -notation in to unify the handling, and extract the commonalities. 

By identifying the smallest bits of functionality that still make sense to talk about, we can write or reuse functions that do only one thing, and then compose them using higher order functions into something that does everything we need in one go. Since this problem is dependent on characters and lists, your first stop as a new Haskell user should be to the Haddock documentation for and to learn about what pre-existing functions you might be able to use for your solutions. Tackling the first bullet point, dropping some elements of a list conditionally on their values should jump out at you as a operation. If we look through the documentation for you may realize that represents all Unicode characters—not just ASCII values—but we're only interested in the ASCII letters. Knowing that is an instance of (from the documentation), we can use list range notation to get just the values we care about in a list. I.e., . Instead of expanding our range to include the uppercase versions of letters, we'll next write a function to lowercase our string using from . 

From there we can deploy our usual bag of tricks higher-order functions to write this more idiomatically. 

This is good! You have restricted imports, type aliases, type signatures on all top-level definitions (except , which you should add but is at least obvious), total functions... All I've got are details. should use the type alias in its return. I.e., . I would probably also name that function “,” refers to an implementation detail; you are providing the function with what you know (or hope) is a single serialized rule to be parsed, not (say) dividing a rule off by splitting it into two. I might also reconsider your error handling with , right now your program silently discards rules it can't parse. That's certainly a valid choice but you might find that it actually makes sense to halt program execution on badly defined input, like so— 

I find that to be a very succinct, readable definition. I probably would have written it too. Unfortunately it's wrong! One of the more tedious requirements of beautiful code is that it be correct, so let's set up some really quick testing using QuickCheck. Since you've been reimplementing functions from QuickCheck can generate a bunch of random test data and throw it at both the original function and your reimplementation and verify that the outputs match. We'll start by defining a property that says the output from and should always be the same. 

This seems overwrought. Let's start with . It's often a good idea to consider not just the problem at hand, but a more general statement of what it is you're trying to solve. In this case, you're trying to get a frequency count of each distinct element in a list. At this point don't worry about the particulars of your problem (like the fact that you're only supposed to be counting s with values ), frequency counts are a well-defined problem for arbitrary data sets and as such lend themselves to a generalized solution. So think about what a general solution would look like. Well, to start, your function will be handed a , just some list of arbitrary elements. But we need to group up which ones are equal to each other so that implies that we must have an equality constraint, . After we find and count the equal elements you'll need to return that count, so . But that doesn't make sense now given our generalized problem, the position of each in the list says nothing about which s it represents, so instead we'll return , a list of pairs of an element and the count of that element in the original list. Putting it all together we get— 

I won't prove the laws, but you should be able to see that they are trivial given the properties of addition and our definition of . Let's try one more pass at now. 

Or you can write a handy little utility function and reorder your arguments to write a point-free function. 

You can see most of the program is devoted to input and output, and only two lines (three if you count the function type signature) are required to implement the algorithm itself. Here's the trick. The loops can be reordered so that instead of mutating an input array, you're actually producing an output list of multiplicands. 

Now consider intermediate representations that can get you closer to your goal. Remember that it's easy to construct a map from an association list with , so let's make that our end goal. Write out the types for a roadmap from where we are to where we want to be. 

is a function from the Haskell module which turns a finite list into an infinite list by infinitely repeating it. Now we can take a finite sequence from the front of the list to determine all of the cycles the tree will experience over a given span of time. 

And assuming we have a lowercase string, it's easy to filter to just the characters we're interested in. 

The biggest issues I see look like unfamiliarity with . already exists in as . is poorly named (take from what?) and not very Haskell-y. A well realized Haskell version would be defined as where is a function that returns all of the divisors of a number. However this still isn't quite the right definition because every number is divisible by at the very least 1 and itself (and you skip returning 1) so you're really looking for the first prime factor. 

My goal here was to make everything as correct-by-construction as possible (q.v. the type) and to reduce the opportunities for ambiguity (e.g., a "Fill Field" may mean any number of things if all you're looking at is a literal , so the representation should be as precise as necessary and no more). On the benefits of this approach 

The above version is contrived to (hopefully) show just what went where without piling on too many changes at once. This version introduces , which creates an infinite list out of a finite one by repeatedly appending the list to itself (in effect). We restrict the range of our indices to because we know they're completely predictable and periodic after that range. To take it a step further we can directly pattern match on the value of in our tuple. This usually is non-obvious to beginners and so is worth showing on its own. 

There's only one more improvement I'd make to this, and that's to call rather than and in . Using both and leads to walking half the list twice in each recursive step where we can walk it only once by doing some more bookkeeping. takes an index to split a list at, and returns the prefix and remainder just like using and separately would. So putting all of that together, here's the final version. 

Next, we know that the cycles begin with a monsoon and thereafter proceed regularly indefinitely into the future. 

Notice that we're building functions that can be easily composed to produce the functionality our final program requires. Going from an arbitrary string to just one containing valid letters all in lower case is easy, . Going by the original statement of functionality, we next need to determine a letter's position in the alphabet so that we can then keep a tally of letter frequencies. In writing a functional version though we can be smarter. Instead of picking a letter and then finding the correct tally to increase, we rearrange the order of operations. First we group letters and then we count the number of elements in each group to produce a tally. Perusing the documentation for we'll pull out and . will rearrange our list of , then will organize them into lists by equality. The last step is to run length encode the groups to produce a tally for each letter. 

It's applying a mathematical function to a value. It's producing a sequence by applying that function recursively. It's choosing the first value from that sequence which matches a predicate. 

is a little abusive of case statements and guards, plus you end up performing a lot of comparisons when you should really just go by the ordering gives you back. 

I haven't used PureScript, but in Haskell the most straightforward way to do this would be to leverage the instance for and write your function using -notation. From toying around with $URL$ I think this should work. 

I don't think there's anything wrong per se, but it's very narrowly focused without much opportunity for reusability. You'll not often go wrong if you attempt to mirror the reality of what you're modeling in your functions and type signatures. For instance, consider that a roulette wheel is an unlimited source of randomly chosen values. One way to express this in your Haskell program would be... 

There are a few small tweaks to your definitions that we should make to come in line with good Haskell style, these won't impact functionality but help your function definitions to read more like English definitions instead of instructions for a computer. When checking to see if a number is even, use the function instead of checking the value in modulo 2. The definition of may be doing the same operation under the hood but using expresses your intent instead of the method. Changes like these will improve the readability of your code in larger projects remarkably. (Additionally, abstracting out allows the implementer of that function to change the definition to be more efficient without requiring any changes to your code, e.g., may check the least significant bit instead of performing any mathematical operation at all.) 

This is now obviously a specialization of , which isn't all that interesting. Look now to the implementation of where you can see that the result of is passed to . Because the type of is given as , the compiler can again determine that must return an Integer if you change the definition of to— 

Besides the aesthetic appeal of this solution, to me this illustrates the power of thinking about what you want to do in Haskell, instead of thinking about how it's going to be done. 

A no-frills solution to this with primitive recursion and pattern matching should be self-obvious (or will be with experience). 

I would use instead of the field accessor for two reasons. First, doesn't show up in the Haddock documentation for which is a bit confusing. Second, on the off-chance that the author of begins hiding the constructors of from export (which is very common practice in Haskell so that library authors can change implementations without breaking users' code) you'll be safe from breaking changes. Knowing the instance and available functions, you can now write a clearer version of . Unfortunately we have to be a bit cautious of bounds, throws an exception if you try to get the successor of , but it's not too bad. 

Pattern matching repeats what is important about the value we're inspecting. The constructors and values we care about are directly on display, and the irrelevant portions are shown to be unimportant by naming them . Consider the difference between these two fragments. 

Jumping back to your version before showing the implementation, let's compare what's going on between both already. 

This is a very dense function though, I think it might be easier to write if you wrap the version using a snake around a primitive list version. Your snakes will presumably never grow so long as to actually cause a user noticeable slowdown between steps due to list processing, so you might think about tossing out altogether.