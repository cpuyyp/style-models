I would have to do something like that, but then it gets even more complicated if I have monsters and I need to add them to the level e.t.c., so how do I get the monsters to interact with the player. So I'm struggling with this basic concept. If I use C it gets rid of this problem as I use extern and I can get the data I want so all I think about is the flow. So in C I can do something like this 

There must be a better way. For example, maybe it possible to not render to the screen to input the data into the mob. Or maybe, I don't need to save it to say .png to then put into the neural network. 

I'm really confused on what you do. I can do them, however I got this problem. Say you have several squares, say 1,000 squares. Now I can make a VAO for each 1,000 squares and then do some for loop to render all of the squares. I can also use shaders to move the squares. However, is it possible to put all 1,000 squares in one VAO. The problem is I'm going to create a voxel game. So I need to render about 10,000 cubes. However, the game will lag a lot even if I render 200 squares how I'm currently doing it. 

It's a question you must answer yourself, depending of what do you send. In TCP/IP, you can send any kind of information, your client will get it (until it is wired), but the protocol check takes some time, resulting in a lag when you have a low band-width. In UDP, you just get rid of all the checks, so you have the max speed of transfert (less lag). But some data could be lost and never be fetched. You must first know what kind of information you need to send, their priority, and if they are critic or not. You may be able to sent at ~16ms and have a kind of smooth moves, without interpolating or applying a velocity, but you'll certainly not reach 60 packets by second and you will have your entities acting like jumping between positions. 

You can easily get the direction of the axis by measuring the angle of it, which you can get by removing its Euler angles from the Euler angles of the camera. This only works when you have the Y axis of the camera pointing up. Another approach would be to use rays and planes (They are both your best friends !) and apply the delta rotation each time the mouse moves. This way, there's no ambiguity. 

You will be controlling only one person directly in the game. But, you can issue vague command like to build something here or attack at this square. So I'm trying to make a multi-player roguelike game. However, I have a bit of a problem understanding how to do sending and receiving data to the server. Was wondering how would I use threads to do this? I have two c++ project. One is for the server and one is for the client. I can create multiple client and connect it to server. So do I just create threads on the server for each player to listen for client input. So I would wait for say 100ms for the input and then send it to update game, then repeat again? I just want to know how to design it. I could probably work out how to do the detail myself. Just need the big picture. So I was thinking that if I have say two threads for networking. One for listening to client input, one for sending updated stuff to the client. Although, maybe you need to do networking on one thread and you can't separate them like you can't have openGL on two threads. 

It creates a line from the projection of the point clicked on the handle (your mouse), and the projection of the center of the object (the pink dot) 

When pointing right, the positive direction is up/right depending of the line angle, else positive is at down/left of the line. 

Singleton is a famous pattern, but it's good to know the purposes it serves, and its pros and cons. It really makes sense if there is no relationship at all. If you can handle your component with a totally different object (no strong dependency) and expect having the same behavior, the singleton may be a good choice. On the other hand, if you need a small functionality, only used at certain times, you should prefer passing references. As you mentioned, singletons have no lifetime control. But the advantage is they have a lazy initialization. If you don't call that singleton in your application lifetime, it will not be instantiated. But I doubt you build singletons and not use them. You must see a singleton like a service instead of a component. Singletons works, they never broke any application. But their lacks (the four you've given) are reasons you won't make one. 

I'm using LWJGL, however I'm a bit confused on what to do. I'm trying to write an AI simulation, however I'm stuck at this problem. I have one camera, and I plan to move the camera to the mob position and then save it to the screen, then I will then use that to input into the neural network, then it does its action, then I move onto the next mob and repeat. Then, finally I move the camera to the player position so I can see what is happening. The problem is that I just want to see out of the player eyes and not the mob eyes. However, I'm confused on how to do it. $URL$ the only way I can think of getting the information for what the mobs see is to take a screen shot if I render it to the screen. But, then if I do this all I will see is everything jump around a lot. The code will look something like this 

So in here we have Player u and your moving that player around only if it doesn't hit a wall. But, I can do this because I use extern on terrain[][]. I'm really struggling. I don't really want to use C as C++ is easier with SFML and I like classes. I suppose the answer is how do I manage interaction between level, mobs and players? If I was going to do it now I would do this 

As danijar says, it might be due to a compression, but let me remind you what is Colour in computer. You may already know that a color is made by RGB components, which can represent 16 777 216 different colors (256 red * 256 green * 256 blue). But it's quite small compared to the real world :) You can see the limitations in soft gradients with few color changes like in your picture, because there's big chunks of colors varying of certainly the smallest unity. Over that, compression makes calculations faster and reduces memory usage, but with a loss of color information. You can color objects in several ways, but the next two are the most commonly used: 

I study how Unity editor handles rotation with mouse movements. You can rotate by directly clicking on the object, but I didn't look too deeply to that rotation since it doesn't answer your question. You can hold the circular handles to rotate on only one local axis. It proceeds like this: 

When moving perpendicularly to that line, it rotates the object. Here, cyan is positive and red negative because... The positive direction of the axis (here, we are rotating around Z axis) is pointing left depending of the projection of the center of the object (the pink dot).