Scan codes identify physical keys on the keyboard, not characters. Since your host is in AZERTY mode (where A and Q are swapped), sending a scancode corresponding to results in being typed. This is by design. The comment in your tutorial is misleading. This line 

An RPi doesn't act like a real USB device when connected to micro USB plug: it won't "enumerate" (a fancy USB slang meaning "to configure a connection") and thus will not negotiate the power it will draw. By default, USB spec limits unconfigured devices to 100 mA, and USB OTG is no exception. However, regular USB hosts (like laptops) usually have loads of energy to share and in practice will provide at least 500 mA to any device. A smartphone often doesn't have that much, so it may actually stick to the spec and provide only the bare minimum (which is plenty for typical OTG applications like keyboards or flash drives). Technically, if your smartphone respects the USB spec (which I'm willing to bet is the case of well-known brands), you lose nothing by trying it out. Worst case, your RPi won't start, or will keep rebooting. However, that last line from jaromrax's answer is important even if the odds are small: if your smartphone happen to lack any kind of overcurrent protection, you may damage it by connecting the RPi to it. 

This is definitively not normal to have browser-induced system crashes. If you suspect bad memory chips, you can try and make a few test runs. Also, if you're not using the official power adapter, try to get one, or at least a good one: bad power supplies are by far the most common source of hardware problems. Linux equivalent of Ctrl+Alt+Del is typing while holding Alt+SysRq. Wikipedia has a description of each individual command if you're interested. 

Just take the micro SD card out of the Pi and fix the permissions in your sudoers folder on any Linux machine you have at hand which has working or root access. 

This type of plugs is only used on slave devices, and it's almost certainly protected from back-feeding any electrical power back to the USB master. It's very unlikely you will get any current out of it. Depending on the design, it may even require the RPi to provide some electrical power for the touch screen to function. 

simulate this circuit â€“ Schematic created using CircuitLab A basic AND game can be made with a resistor and two diodes. Sending a LIN frame would look like this: 

You may want to start by running and locating your program in the list. It will look similar to this: 

This laser draws 110 mA at 5V, while RPi GPIOs only provide 16mA at 3.3V. You'll need to amplify your GPIO signal to power the laser. Most probably, the black wire is (-) and red one is (+), so the correct way to wire it to your RPi could be: 

The easiest way to a binary compatible cross-compilation is to install the toolchain used by Raspbian developers. It can be found here. It's essential to use this toolchain if you want to build the kernel and drivers, as kernel objects require perfect ABI compatibility, but having perfect compatibility won't hurt if you're building userspace binaries as well. According to documentation, this toolchain is compatible with current Ubuntu, both 32-bit and 64-bit. 

should do the trick. It will forcibly close the current session and display a new GUI login dialog. If you want to prevent anyone from logging back on, you could (for example) unload the keyboard driver and disable HDMI after you have killed . 

Your command jumps to step 2 right away and tries to install a software called which presumably doesn't exist. 

Add a line to your and reboot Insert the driver driver with Run . You may need to build the program first, using the sample code provided here. 

You should remove non-free packages if your product doesn't use them. Leaving them on the SD card may violate their license, at least in Wolfram / Mathematica case: 

Wireless routers may not accept clients with self-assigned static IPs. When a new client logs in to the router, he gets assigned a dynamic IP address which he is supposed to request via DHCP. If he doesn't, an simply picks a random IP address (as in your case), the router will simply drop its packets. This can be changed by configuring static IPs on the router: you have to tell it that a client with a particular MAC address will be using a particular IP address. With some routers, the client still have to use DHCP (even if the IP address he will get is always the same) to be able to communicate with the router. The procedure to configure static IP is router specific. It can easily be found by googling "static IP address" plus the router name. 

I think the proper solution would be to create a SystemD service, as described here. Create a file named : 

You need internet connection in order to have valid clock settings. If your clock is not set some time after a reboot, you might have disabled. In that case, you can simply fix the clock manually by running 

I bet my hat on the root cause being not enough power provided. The Pi 3 itself may need up to 700mA occasionally, and the HDMI screen may consume another 500mA or so. This can easily exceed the current capability of a standard USB port, which results in low-voltage conditions and the screen controller hangs up as a result. Get a real power supply for your setup. You may get away with better cables for now, but the moment you add another load (USB device, intensive computation or networking activity, Bluetooth, 3D graphics, whatever) the problem will likely appear again. 

Trying out OwnCloud is not a bad suggestion (note it's written in PHP, not Python, if that makes any difference), but I'd advise against manually installing it from a tarball. You'll absolutely want security updates for server software facing the Internet. You can install it from OpenSUSE repositories as described here: 

In my case, the LCD model is . You'll need to know the exact interface it has (most common is LVDS, but you need to know the number of channes and bits per channel) and what kind of backlight supply it needs. Google is your friend here (search for ), but checking specialized sites like panelook or beyondinfinite can save you a good deal of time. Putting my model name in the search box there you can see that this panel has a 1-channel 6 bit LVDS interface and a single CCFL backlight. Then you'll have to find an LCD controller that supports your panel. Check Amazon, Ebay and Aliexpress for which support the exact interface of your panel. If you only need a screen for the RPi, any board with HDMI input would do. Personally, I've puchased a so-called LAMV56 board based on the TSUMV56RUUL chip, which can additionally decode TV signals and play media files from USB storage. Different controllers come with a different set of optional devices, like power supplies, audio speakers, CFL modules, remote controls or buttons, etc. You'll have to buy all the parts you didn't salvage. At the very least, you will need the power supply, the LCD data cable and the CFL module (or whatever your LCD needs for backlight). The assembly For parts you buy, the assembly is pretty straightforward. For salvaged parts, it is up to you to find/make appropriate connectors with the right pinout: 

Take out the microSD card from your RPi, plug it into the card reader and try to backup your files on the laptop. Then you can either attempt to fix the filesystem of the card with (again, on the laptop). If you're unable to fix it to a bootable state, you'll have to reflash the microSD card with the image and start from scratch. 

Since you call your script a server, I assume it needs network connection to run properly. Therefore you should consider running it via with as a dependency: Create a file : 

While you might be able to reprogram GPIO pins to high impedance state, that would only work until you reboot. For the time from power on to the moment your scripts disable the pins, you have potential for overcurrent conditions between USB and GPIO. This might be solved by putting resistors between the two, which may in turn have significant effects on USB communication. USB 2.0 uses high-frequency signals (about 0.5 GHz) and requires careful signal routing. GPIO pins aren't designed to run at such frequencies, so PCB traces attached to them don't respect routing constraints. As a result, USB signals will get all sorts of artefacts (spikes, reflections etc.) which will probably prevent USB 2.0 devices from working. The same may be true for wires you solder, if you're not careful. 

As your command line is written, you're trying to open twice, to redirect two streams in it. Since redirections are processed right to left, gets executed first. As a result, the second redirection, is stuck with a file which is already open, and silently fails. Either redirect one stream into the other first (with as goldilocks suggested) or log normal output and errors into two separate log files. I'm not sure why your lines didn't produce any output. My best guess is that they don't have newlines so they got lost in stream buffers somehow. Try adding newline characters at the end, or use 

This element is labelled L3, suggesting that it's an inductor. It's OK for it to be black and have a slightly non-uniform color. If you can reach the pads with a multimeter, you could check that it conducts in both directions, with a typical resistance in Ohms or tens of Ohms. Of course, testing an element in-circuit can give false results, but getting such a small part off the board for inspection is difficult and risky. If you want to diagnose your RPi, I would start by measuring the voltage on 3.3V pins. If you don't see the right voltage, your board may have an issue with the overcurrent protection or the voltage regulator, which could theoretically be fixed. 

A light sensor usually works pretty well when you can illuminate it with a LED and make sure that the passing marble will block that light. 

replace with and recompile. Hopefully, you will have your local time in both RPi and DS1302. configure your RPi to use UTC time with . Then the conversion done by will be identical to . Whether using UTC time is convenient to you is another story. 

Power-related crashes are better handled with some sort of UPS solution like juice4halt. For cases where unexpected shutdown cannot be prevented, I suggest you try option for your root partition. It will make writes slower (but as you said in comments your root is virtually rea-only so there will be little impact), and will be able to fix most issues automatically upon restart. 

The first thing you should check is . Right after you plug your GPS in a booted system, type on the console and take note of the last 10 lines or so. They should mention the steps your system took when the device was plugged, like loading the driver. Then, reboot with the GPS plugged in, and check again. Try to find the lines you have seen the first time. There will most likely be messages in the output describing what went wrong. Of course, the usual advice for situations where something used to work but doesn't work anymore is to roll back the latest changes you have done to your system. If you make backups, all it takes is to restore one. 

You need to have samba installed on your RPi for hostname resolution to work in Windows. Try running on your RPi and retry the same direct connection steps. Also double check the hostname your RPi has (by running the command or checking ), it may be different in Ubuntu. 

If a dedicated USB-over-Ethernet adapter seems flaky to you, I bet you will be disappointed by the speed of USB-over-Ethernet implemented using the RPi which is not optimized for this use-case. One thing that might work is using the RPi to produce a video stream and transmit that (compressed) data over the network. You will need to figure out a way to remote-control your camera, which will be done outside of the video stream. Possible solutions include SSH, Remote desktop, or something like Synergy. 

Web browsing on a Raspberry Pi is slow, but it's certainly not normal to wait for minutes for a new window to open. I suggest you make a fresh install with no extra software except for Firefox (no addons!), and retry. If opening a new window (except the first one) still takes more than a few seconds, I would try getting a different SD card. 

This usually happens on cheap WIFI/BT adapters which use the same antenna for both functions. Some devices can play nice and share the common antenna, others don't. The simplest solution would be to buy a separate USB WIFI dongle and use it instead of the built-in WIFI. Another option is to buy a different BT mouse which is known to work with the RPi. Several examples of such devices can be found here. 

This converts your system time to UTC, before writing it to the DS1302 chip. When the chip is read back, your system time is set to whatever is received from the chip, without any conversion (which frankly looks like a bug). There are two things you can do: 

may still be using instead of and instead of , which shouldn't be used in scripts anyway. In any case, the error message suggests may not even exist. Perhaps the thumb drive is not yet mounted at the moment when executes your script, or it is being mounted and the mount script didn't apply the permissions yet. Add some logging to your script (I would go for ) and see what happens. The log file must be created by the user, and you will see if the thumb drive is really mounted at this point.