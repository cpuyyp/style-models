Now they can do whatever they want with the list they passed in, and it won't effect your object at all! Efficiency at the moment your selectSong method has O(n) time complexity, because you need to (worst case) iterate through the entire list to find your song. A better data structure to use here would be a Map. This allows you for O(1) or constant time access. Instead of your JukeBox being backed by a list, you could have it backed by a HashMap. So you could have O(1) access to any song given its name. Or maybe a Map, or even both. your selectSong method could look something like this 

So no the class is your "Runner" and is used in your main method, it contains an instance of a and a . Hopefully you found this review helpful, keep up the good work! 

If someone passes in that list, they can add/remove stuff from it and it will effect the list in your playlist object! Try this instead 

This way you don't need to worry about either, not that that would really be a problem here anyway. This while loop could be a lot simpler. Try breaking it down into multiple well named boolean values instead. 

Other test may be needed @Wingblade Non-standard function is not standard C library nor did I find it in Linux. Questionable signature I'd expect a function that checks a string's validity to cope with a . So using on the supplied is not possible. Code needs to make a copy or otherwise assess the string. 

Why sign-ness difference in Recommend consistency as above. Explain interface: as the return is 1 of 3 values, yet that is not apparent form the comment nor the signature. Again, consider the function declaration and comment may exist in a .h file. 

Good that code allows a leading . Pedantic point. overflow is undefined behavior and that is the result of the following with , a string that should "work". 

Minor style implication: --> . Variable declaration A style issue, yet I find declaring variables when there are needed better as well as bracketed 

Add date and your ID (name) to the file as a comment. Format: The below format is hard to maintain with automatic formatting tools (at least mine). Maybe it does well with yours. Formatting is a pain and should not be maintained manually. Assuming you did not use such a tool, try one. 

Notice here how I created another Deck instance to act as the discard pile. Really a Deck is just a bunch of cards right? I Deck doesn't have a "playing" pile and a "discard" pile. What if my game doesn't ever discard cards? By having multiple decks to represent multiple piles of cards, then I have full control. So e.g. If I want to make a solitaire game, that could be represented by a number of smaller "decks" that get added to. The managing of when cards getting added/removed can be handled in some Game class. Unneeded class variables Consider these 2 methods 

This would make your NbaDraft object more robust, could provide it with any number of team names to deal with. You could also easily then keep a file full of all of these names so as not to clutter the code itself. You have a printDraft method, it would be more flexible if this method simply returned a String instead, and then you can just print it, or use it for any other purpose. Eg. in a JPane/JPanel or a JavaFX window. at the moment you're constricting yourself to ONLY printing to the console. 

needs a similar re-write to employ this new approach. It will remain . Further, it should return a value indicating (found) or (not found). could be coded calling 2 helper functions: and . is very similar to and also . re-write. 

Complexity Instead of the structures involved, this task could be solved with less data usage: a length, eldest index and a single array as below and still maintain O(n) complexity. Adding is a simple as scanning for the eldest index in a sorted array, replacing it with the new value. Then bubble sort the new value into place. 

Alternative allocation idiom. In C, I find sizing to the de-referenced variable easier to code, review and maintain than sizing to the type. No need to code the matching type - and maybe get it wrong and no need to update. 

Snippet 1: Any separated by many lines of code deserves re-consideration. Snippet 2: There should be no need for the - just return. (which is much like this #5 approach) Snippet 3: The is a beacon for some as an evil. It will attract a disproportionate number of dis-likes. Although I find it not so objectionable, I see no advantage for it here. Only use when it has a clear advantage. Snippet 4: A macro to simplify many lines of code is useful when it has wide application and is not hiding branching (code flow). As the macros provide neither, suggest avoiding them. [Edit] Like to offer a generalization in pseudo code. Consider 

I've used a larger number of smaller classes here. We now have the benefit of easily being able to add a new to our game, we just make a new class, implement Location, and say what should happen when the method is called! Of course if you needed to do more things than just you , you could add new methods. But I'm a big fan of having as few public methods as possible in any given class. Your logic for checking number of tiles to towns etc. could all be done in the class. In your example, you have some logic around maintaining knowledge about whether or not you can drink from a location, I'll just add one more quick example about how you can do this, let's rework the class just a little bit. 

Thanks for sharing your code, it's looking good but I think we can make some improvements. Currently, the method doesn't actually make use of ! We can just remove that, so we end up with . And then when we call it later, we don't need to pass in a object. you say that returning null is a bad idea. I agree with you, and would suggestion you use an instead. This was introduced in Java 8. It's intended purpose is to act as a value to return when the actual return value might not be there. To me, your example looks like a good use case! Let's see what your method looks like if we use an Optional. 

Formatting is inconsistent. Use an automatic formatter. Avoid manual formatting. When the pointed-to data is not changed, use . This allows for more compiler optimizaitons and lets users know the data is not changed. 

Some modern compilers can make additional optimizations if the pointers are known to not overlap - use and where applicable. 

Assume exists in some other file like You are reviewing/maintaining code in the some file and code compiles OK, 

Minor: Keep local variables as local as able. could be declared and initialized in 1 step local to the block as it is not used outside the block. This borders on style issues, but as a rule, limiting variable scope is easier to see its use and impact. 

Unclear of the value of right after . If anything, coding that before the may add value. Consider coding a variable to help detail what the is about. 

Conversion from to may lose precision. Although typically can represent every value of an , could be wider such as 64 bits. A good will return the exact value for a perfect square, but not all behave so nicely. Code should be prepared for something like --> . Since the loop has no trouble iterating a little pass ideal, recommend a simple solution for both above issues: Increase the upper limit by 1. 

I would like to point out some things that I would watch out for, these may not be directly related to your question, but hopefully they are useful to you. Alot of your comments are completely redundant and actually add clutter to your code. some particularly bad examples are the comment for the variable . Your comments should say why you're doing something not what you're doing. The code itself should say what you're doing. Avoid returning references to the underlying mutable objects directly, in this case, your . Instead you should return a defensive copy. 

especially if you reuse them throughout your code base. Hopefully some of this was useful to you! Edit: Here's an example of what your method could look like Here it's a method of some or object. 

If you're using to call methods like this, just call the methods instead. if you look at the documentation for the function, it already returns a list, you can just use There seem to be some unnecessary offsets throughout your code, why use and not just you can just take the user input value and subtract 1 from it in one place, in Python counting starts from 0 :) n is a very poor name for a variable, use something like or instead, anything to improve readability goes a long way. in your function, you call again inside, I don't think there's any real benefit to using recursion here, I think it would be simpler to understand a simple loop instead, and it would also be simpler to reason about and leave less room for error. 

I'll offer a more robust "parsing a string into a double" code that allows leading/trailing whitespace taking into account the above ยง7.22.1.3 10 spec. 

If user enters the coefficients in order, code gets nice and tight. No need to save all the coefficients and no need to limit them to 10. Calculate the sum as you go. BTW: Always good to check the results of . 

Use for array index types and the result of . may not be the right size to use as an index. (Also in ) 

Since OP's code makes heavy uses of macros, insuring the needed headers files do not have sequence inclusion dependencies is a good thing. 

Comment "implemented a generic linked list', this codes seems to be focused on adding to the list variant sizes of data - which in good for strings. I would find this a bit error prone or tedious and prefer to provide the size at link-list head creation time, rather than provided it each time with . Major Invalid standard C code is not defined yet used in