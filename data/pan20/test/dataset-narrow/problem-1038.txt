You can cook up a formula that will do this. For example, you can use to check an array of conditions for and tally how many find a match. Then, compare that tally to the count of conditions you were searching for. 

This will keep the top row for each value in column A and remove the rest. You should be left with what you want. 

I'm about 1.5 years late to the party, but I thought I'd post just for anyone else who stumbles upon this. I think your best bet is to interpolate a cumulative distribution function from the data you have. This may take some serious finessing and hand-waving, especially if the sample data you provided is close to the distribution you're working with. However, it sure beats the hell out of creating (and storing!) a million+ fake data points from a distribution you're just guessing at in the first place. To get the CDF, you'll need to calculate the cumulative probability for each bucket. I assume there's always some latency, so take 0 as your minimum value with a frequency of 0. To find the CDF value at each bucket upper bound, use the formula 

Replace with nothing. How it works: matches entire words. limits these matches to words that are not preceded by a space. further limits the matches to words that are followed by a comma or the end of the line. This should match all single-word entries and the trailing comma. 

You just need to make a couple of tweaks to the code -- it's very close to working as is. See my comments in the amended code below. 

Make list of all unique entries from Column . In this sample, it would be a matter of typing two names. With a larger data set you could copy that column to your target location and just use the Remove Duplicates tool to pare down the list. To the right of the first name in your new list (Mine starts at , so I have the following in ), enter the following formula as an array formula by pressing Ctrl+Shift+Enter: 

Now, for the finessing. If you have some common-sense insights into what the distribution looks like, e.g. you think somewhere around 25% of the latencies are less than 0.1 ms, you can add these intuitions to your data. If you don't have any idea what the distribution should look like, then you can just roll with what you have. From here, you have two choices: either (a) linearly interpolate between the points you have, or (b) fit a functional form, such as a beta distribution, to your data. (a) is simpler because it requires no regression; however, it will not give you a picture that is more fine-grained than what you already have, and the calculation of frequencies requires a bit of Excel formula kung fu. (b) will provide you a fine-grained picture that more than likely resembles the underlying data more closely than the linear interpolation, and it only requires straightforward, simple Excel formulas to get frequencies for any bucket or percentile; however, it requires a regression, which requires the Solver add-in. I prefer option (b) because it gives you the most bang for your buck (i.e., effort). 

This will work for larger systems of equations with more variables as well. This formula works based on the observation that the left-hand side of a system of linear equations can be represented as the product of an n by n matrix, A, and an n by 1 matrix of variables, x, and the right-hand side can be represented as an n by 1 matrix, B. To solve this matrix equation, both sides must be multiplied by the inverse of A. 

To achieve this by formula (in a different cell), you can use the following, where your unformatted complex number is in : 

will refer to all data in assuming there are no blanks in your data in column A. Now you can use the name to refer to all your data, even if you add or delete rows. All that's left to do is to redefine your conditional formatting rule with in the field. 

Of course, beware that some of the other cells you reference may contain text-formatted numbers as well, so adjust accordingly. 

Here's an array formula solution. Select on the Query sheet and paste the following into the formula bar. 

When in edit mode (select cell and double click of press F2), you can press Ctrl+Shift+<-- to select the previous word and then press Backspace. That's my best suggestion. 

This formula works by checking if the employee ID below matches the employee ID in the current row. If so, a is entered. If not, then the row is the last entry for that ID and date. The cap value in column D is handled by using the sum of two functions: one to sum the appropriate values in column C where the value in C is less than the cap value in column D, and another to sum the appropriate values in D where the value in column C is greater than or equal to the value in D. This guarantees the right value is counted for each record. 

Beware using in your code, especially if it's code that hasn't been tested thoroughly. In this case, it's masking a syntax error in the line 

calls for the visible cells in columns A through H of named range . Presumably there are named ranges , , ..., in your workbook. In the Acceptance Test Procedure code, by mimicking the syntax here, you've assumed that named ranges , , ..., are defined in the workbook. If they are not, your code will throw an error because Excel does not know what is referring to. To check that this is in fact the problem, open the Name Manager in Excel by pressing Ctrl + F3. Here you will see all the named ranges in the workbook. I suspect you will see the FTP ranges but not the ATP ranges. To solve this problem, you must do one of the following: 

Enter this as an array formula by pressing Ctrl+Shift+Enter. This will give you the count in one cell -- no extra columns needed. You can also return the row numbers of each duplicate entry, but you'll need a little help from a VBA user-defined function (UDF). To create the UDF in VBA, press Alt+F11 and insert a module. Paste the following code into the module. 

Your text includes some carriage returns or line breaks. You can remove them in one go with a simple VBA procedure. Be sure to save your sheet before following the steps below. (You'll want a backup in case this does something you don't expect and mangles your data.) First, select the entire column of URLs. Then, open the VBA editor by pressing Alt+F11, and go to >> . Paste the following code into the text field that is opened.