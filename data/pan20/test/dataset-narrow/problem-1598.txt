If you want to make a full keyboard to actually type on, you'd probably be best off with the IC out of a USB keyboard. Either retain the PCB itself buried deep in your system where it can't be seen and run wires up to your switches, or fabricate something custom with the same matrix. If you really need to change the electrical matrix then you might need to make your own design from scratch, but otherwise it's not really necessary. Even with a custom board, you can still end up with something that enumerates and functions as a USB keyboard, removing the need for custom drivers. 

First, your diode is misplaced. It should be placed in reverse orientation, in parallel with the FET. Where you have it in series, it is simply reverse biased and will prevent the circuit from operating. Next, an IRF510 is a dubious choice. It is both delicate (subject to damage from static discharge) and has a threshold voltage which may vary from 2-4v, while the pi only outputs at most 3.3v. To utilize this FET well you would really need a gate drive circuit - it's specifications are characterized at a gate drive of 10v. What current does your solenoid draw if you connect it directly to the 12 supply? If it is not too much you may be able to use a simpler NPN power transistor circuit. Or you could use a small relay (driven by a small transistor or the optocoupler version importers sell everywhere) to control it. 

This sets up the callback with myarg set to 4. also handles argument lists in a similar fashion the example above uses just one argument for simplicity. 

As for the hardware buffer: a minor problem - no official datasheet is available for the Pi 3's BCM2837 (see here: Where can I find the documentation for the BCM2837?). At the Foundations website (here and here) we learn that: 

Yes, ad-hoc is the right way to think of it. Use Ralink RT3570 Driver based WiFi Adapters to achieve ad hoc mode. I do not use Windows 10 IoT so I could not help further but the initial idea is right. 

read_serial is a string as is s[0] which then holds the same content which you print both - so you'll see the same thing twice. So the question really is, what do you expect this to do? 

To me that includes the case of a real hardware defect. So if you tried to use current OS images (thus including current firmware) and the error prevails it might just be a damaged Pi. 

Individual crimp pins in heat shrink work well. A wire wrap tool can also be very handy for interconnecting boards in prototype systems - although not designed for it, it will typicall work on 2mm headers as well. 

GNU screen may give you an interactive terminal to a usb serial device such as an Arduino, but for use in a program you want to use the serial APIs for C, python, or whatever you are writing in. There is very little distinction between the pi and other Linux (or even unix) systems in this regard, except that some runtime framework too heavy to have a practical pi port wouldn't really be an option. What the Arduino does in response to commands on the serial channel would depend entirely on the sketch which you create and load into it; out of the box it will do absolutely nothing. An Arduino by itself probably does not exceed the pi's USB peripheral current limits, however an Arduino with accessory shields might. Powering the Arduino from a hub is one option, but some Arduinos/Arduino-like boards will allow you to use an external power supply for the board, even when USB is connected. 

From Petroblock: "The RetroPie SD-card image is a ready-to-use image that provides a full installation of all systems and functions that are supported by the RetroPie Setup Script." So I take it, that one just installs this image to the SD card and that is it. 

Wireless keyboards could operate by using radio frequency (RF) or infrared (IR). RF techniques range from 27 MHz to up to 2.4 GHz (according to wikipedia). With Bluetooth being a widely used technology. While both WiFi and Bluetooth share the 2.4 GHz band they differ both in technical aspects as well as in their objective. So in short: Your (presumed) Bluetooth dongle of the wireless keyboard is not going to double as an WiFi dongle. 

Yes, the RaspberryPi is your thing (I'd say) and the primary software tool you're looking for is formerly known as . So you should look into openelec and alternatively into any of the basic Linux distributions for the Pi (e.g. Raspbian) with kodi on top. Typically it directly boots into kodi so that the non-tech user should be able to handle it. 

The properties of a USB serial converter have nothing to do with the hardware of the hosting system, but only with the USB serial chip itself, and the software stack of the hosting system. The pi should be using stock Linux USB serial drivers. Therefore, you can enable/disable the linkage of DTR to port open/close via the usual Linux method of clearing the setting as documented on the Arduino site and elsewhere: 

Or replacing /dev/ttyUSB0 with whatever device file actually corresponds to your USB serial port (for example, the first Uno connected would likely be /dev/ttyACM0) Even with regard to the PI's own native serial port, this behavior of DTR is ultimately under software control - anyone who argues otherwise is ignoring the fact that it is only the Linux driver, and not the hardware, which has any knowledge of the port being opened or closed. The actual port hardware can only tell that it is being read from or written to or reconfigured, none of which are actually synonymous with opening the serial device. 

After making sure that the system is not compromised: Disable access via ssh by putting the following line in : 

So all we need to do is to check for the least significant bit - if it is set then the cable is unplugged. So it would seem that running and parsing the status properly should enable to detect whether HDMI is connected or not. 

Obviously the Pi cannot distribute more power than available from the supply. The design load of the 3.3V regulator is limited to about 1000mA* and the two other voltage regulators (2.5V and 1.8V) are daisy chained to it. So essentially all load is coming through here. This includes GPU, CPU, RAM, NIC, HDMI, ... and the Pi specific peripherals such as the camera. The documentation is a little vague as to how much exactly they consume. From schematics alone it is not possible to quantify the resistance of the power line on the circuit board from the regulator to the SD card. However a prudent design would use power planes or a sufficient width of the pcb tracks. 

Floppy and IDE interfaces are extremely different. I'll address the IDE as it is much more practical: GPIO-based communication with an IDE drive is most likely possible provided you operate at a low data rate and use passive level translation. IDE is actually a very simple interface; it (and it's close cousin compact flash) have been interfaced to lots of legacy microprocessors, you just don't hear as much about that since the price on SD cards dropped causing most of those projects to be done with spi (or bit-bang spi) to SD cards instead. Additionally, if not enough I/O lines are available to talk to the 16-bit IDE interface, it's actually possible to use only 8 data lines, since the commands are all 8-bit. Not having the other 8 bits means you waste half the storage capacity, but disk is cheap, so that's not necessarily a problem unless you need to read a disk created by something else. (You can however copy a normal filesystem image to or from such an 8-of-16 disk connected to a normal linux box, by manipulating the devices as a file) 

Well, seems that even a three LED solution (on board + jack + external) would be in spec with the LAN9512's buffer circuitry. 

Mopidy with extensions allows you to stream from cloud services such as Spotify (and others as well as local files obviously). It can be run pretty well on the Raspberry Pi and can be controlled by a multitude of clients (local or remote; command line, graphical, web based). Packages for installation are available for Debian and Arch Linux, but other than that it can be installed from source and is running on python2.7. (As for the second part: that would be best left for another question.) Addendum: Performance On my Pi2B with current Arch Linux mopidy runs at about 25..30 % CPU load while playing local .mp3 files (192k) from an USB flash drive. On a single core Pi B+ at standard clocking it runs more or less at 100% CPU load and remote control actions are delayed and might interrupt playback. This might differ a little for spotify streaming given that it uses .ogg comression over .mp3 and depending on the selected bitrate (spotify's quality levels). 

You should not be running the power for a stepper motor (or any other moderately hi or pulsed load) through the pi, period. At the least give the load its own wiring directly back to the supply. While it is true that higher voltage supplies can yield much better stepper motor performance, a boost converter is going to be a poor way to do this. If you want to run your motor at 12v (say with a ) you should use a 12v supply, not one upconverted from a lower voltage where higher current would be required. If you have a good supply in the 12v range you could consider using a buck regulator to also power your pi from it, but you may find it simpler to use independent supplies for the pi and motors driver. 

No, it is not possible (at least on the model B I'm familiar with, you can check the schematics for others) to toggle the USB VBus power, as there are no power switching devices on the board to implement this, and USB lights typically use only (abuse) the USB power without being command-able over the data lines. It's true that a few USB hub implementations provide per-port power switching (many hub chips have the output pins to drive power switching FET's, but few hub PCB's have the FET's installed), and there may be ways to command them under Linux, but that's not relevant to an implementation where they are not present. You should be able to accomplish your goal with a USB- or GPIO- commanded switching device - FET or transistor driver, mechanical or solid state relay, etc. These are available both as bare components or already packaged on a board/module, direct wired or opto-isolated, etc. If buying a USB-connected device, be sure to get one where driver source code is available either from the vendor or someone who has reverse engineered it, as neither a windows driver nor a binary-only x86 linux one would be much use on the pi. 

So it is hardly conceivable that the power consumption of those three devices is too high for the respective supply. Checking and explanation of the wiring and the setting of the GPIO ports is required to solve the issue. 

In my book this means that the two will not be able to be operated on one Pi. Furthermore it is noteworthy that there are no stacked HATs - and the newer HiFiBerry boards share the Foundations EEPROM based configuration approach. Per Raspberry Pi Blog: 

So, the Pi's power supply is 5V but its GPIO pins are not 5V tolerant. Thus, while the BME280 could handle 5V the Pi just would not like it. Power the BME280 at a voltage suitable for the Pi's 3.3V GPIO pins. For the BMA180 the 5V are also not an option, as it requires a voltage below 3.6V. So again, simply use 3.3V and you're on the safe side. Given the low power consumption (very low current) of both sensor modules simply connect them to the 3.3V pins the Pi provides (Pins 1 and 17 at connector P1).