Thus, for ultimate portability, and to satisfy pedantic compilers / analyzers, use types/casts with bitwise operators. Providing more information (return value) If you have the leeway to change the specification, you could make a couple changes to the function to increase the information it provides to the caller: 

Not only does this tell us if any "bit columns" are all , it also tells us which bit column is all (any bits that are in all of the input variables are set in ). Note that there are no logical operators here (i.e., , , ). This is important for algorithmic optimization because logical operations can "stall" pipelining or cause branch mispredictions, which can kill performance. For checking for "bit columns" of all , we could use the same concept (but with inverted inputs) as such: . But that's not taking advantage of our knowledge of Boolean logic. Recall from De Morgan's laws that (that is, "(not A) and (not B)" is equivalent to "not (A or B)". Thus, we can calculate as: 

I had basically written everything Zenohm wrote (but way too wordier). I would like to suggest the slight change to Zenohm's code. Remove the end of , from on, and move that logic to : 

That means there are (16 choose 4) combination = 1820 possible input combinations, much less than 65,536 (or 16 * 15 * 14 * 13 = 43,680 permutations if order matters). However, that knowledge does not change the algorithm or opportunity to improve the performance. But what about the differences between the algorithms? I ran the same test inputs (including identical random data) against 3 other functions: your (but sans checking for ); my (sans checking for ); and finally, my (also sans checking for ) but following my suggestion and returning more than just or . Here are the CPU times (in seconds): 

Is there anything that isn't a number? it's probably a or something so we'll make sure not to capture that. Then we look for a country code. You had only a check for a single digit country code, and if that's what you want, fine. However, know that some nations have codes more than one character in length. 

Homemade database access objects almost always lack some sort of functionality. They are very likely to be insecure They're not community reviewed (most of the time) 

Your code looks fairly good. It's nice and easy to comprehend, and it's to the point. It is also something that's been done before, so luckily you can look at others' code and compare/contrast. I'd like to suggest looking at the FIG standard autoloader. It comes from this PHP FIG Autoloader standards page, which is an excellent resource when determining what looks "good." Also, you may want to take a look at other, maintained autoloaders, such as the Aura Autoloader. If you choose not to use it, it could still give you hints on how to expand/improve your current code. 

Question 1: You've partially got the idea. It's acceptable syntax, but it won't work, you need to use which references the current class. However, you're not allowing for dependency injection, and keeping you class very tight together. Here's a way that's commonly seen: 

Perhaps you're looking for something such as this. You had lots of repetition in your code, and so I basically applied the DRY rules to your code. It could still use a lot of work and I'm sure there's other approaches, but this might help you kickstart the process! Another way to possibly help improve your code would be to separate the logic, database access, and your s. You've probably heard of frameworks and such, and you might want to start looking into your options. It will keep your code separated, and while maybe not shorter, it will be much neater! 

Return if any of the inputs are . Let the output value tell you which "bit columns" were found identical. Even if you don't need that knowledge currently, calls to the function like such, 

All of the masking with individual bits and logically comparing values really eats up your performance on the randomized data. For the ordered permutation runs, it's likely that some compiler optimizations in conjunction with branch prediction helped out your times (because every group of 16 calls to had a, b, and c identical, varying d. This is evident because for the randomized data runs, your original algorithm suffers a 3x performance penalty compared to my implementation. The Takeaway This is probably one of those cases where, if performance is really important because you're operating on a lot of data, or you need hard real-time performance, that it pays to take a step back, and reconsider the data flow. If at all possible, removing the cases where you're checking the inputs {, , , } for will yield 2x-3x improvement in the algorithm computations. Alternately, if there's another way to handle those cases (mathematically, instead of conditional-logically), then you can just operate around the issue. 

is undoing the work did for you (which is the entire reason for using ). Instead, you should do this: 

This cleanly separates the business logic of the game from the mechanics of running the game multiple times. Also, it frees up to return the number the number of guesses the user took, so that (or other calling code, in the future) can collect statistics about gameplay. 

provide the same logical information as calling as you originally posted it like: . But with this suggestion, the following information is available: 

I've written your code to take into account all of these modifications. I think it looks neater, however it's not meant to be completely superficial. Since my Sass isn't very strong I hope someone else will be able to help break down your code with you more thoroughly. 

Other than that, all looks well. Just in case you wanted to look at some other validation classes (if you haven't already), here's one to get you started. 

I haven't worked with CodeIgniter before, so if I say something that argues their standards, please excuse me. It's such a basic piece of code that there isn't too much to be said. One things I notice right off the bat, your function has a first parameter with a default value. I'm surprised you haven't done anything about this because it should be throwing you a warning. 

And the average function time was about 2.1894 E-6 seconds. However, PHP 5.5 introduced us to the function! And it happens to do exactly what you want! Yipee! We can do a big swap-out, and come up with this: 

Here on Code Review, it's common to not receive some sort of feedback for a few hours. We all try our best to be on and answering! 

I'll see what I can do to explain things. In all honesty, looking at your algorithm, I knew things could be changed. Sorry for making it so drastic! 

Good work formatting and approaching styles in a fashionable method, it makes reading your code very easy! a couple things to note: 

Very interesting concept, I could see this turning into a "Pimp my Ride" game. A few things before this is sent off to gamers: OOP It seems like you've kind of misunderstood what OOP is about. As it is, you have a lot of variables (not objects) which then are smushed together into a final concept (the car). If you want this to be more OOP oriented, here's some things I suggest: Get rid of all the variables, except . Keep this, as it will represent your "object". Instead of the manufacturer having his own variable (who knows, maybe some car will be custom built or have various manufacturers), use getters and setters to define a property of car. Picture it this way: 

Background: I'm in the process of writing a relatively simple behavior tree driven AI system for a game that I'm working on. Basically, the behavior tree is made up of individual gameplay tasks (move, attack, etc.) as well as composite tasks that iterate over sub-tasks in a variety of ways. Each gameplay task is a leaf and will return a status (success, failure, or running). For example, a sequence composite task iterates over its sub-tasks in sequential order. If all of the sub-tasks in the sequence return , the sequence will also succeed. If any of the sub-tasks in the sequence return , the sequence will end early and fail. Finally, if any of the sub-tasks return , the sequence needs to store its position, return this frame, and re-tick the same sub-task again next frame. I had no issue getting my behavior tree to work correctly within a single frame of execution at first by recursively calling down the tree. This works basically like a depth-first traversal. But I've been having some issues finding a clean way of dealing with storing and resuming from nodes that return . I probably can't post all the code needed to compile and run this without making a mess of this question but here's the basic flow of the program: 

This worked fine, but it felt a bit messy and brute-force. So I thought about other possible ways to do it. Thinking back to some of the C++ code that I've written, using something like an iterator came to mind. After a little research I found that IEnumerator seems to be more-or-less the same idea in C#... Second Attempt: So, going back to the drawing board, I tried rewriting my code to make use of enumerators. Now, instead of storing a reference to a task, my composite now stores an reference. I've used foreach loops and IEnumerable objects many times before in C#, but this is the first time I've ever needed to deal with IEnumerators alone. Honestly, I went for a kind of 'lazy' approach to calling instead of doing so in the constructor because I figured that tasks might be added and removed dynamically at various points in time. I added some small convenience functions for controlling my IEnumerator to prevent cluttering my code in other places. Here are the changes to my CompositeTask abstract base class: 

Let's compare your implementation of to my functionally equivalent implementation. For testing, I created 2 datasets for input. One dataset ("Permutations") is just all the permutations of a, b, c, d (non- inputs, values ) (that's 164 = 65,536). The other dataset ("Randomization") is 65,536 randomly-generated sets of {a, b, c, d}, about 50% of numbers are , the rest are more-or-less evenly distributed between 0 and 16. I ran these datasets through our implementations 10,000 times. Here are the process's CPU times (in seconds): 

Use the returned by Edit: my original response directed the OP to use library to parse JSON-formatted text. That was incorrect, as the returned data was already parsed by library. The returned from your function is a of the key-value data shown in your "Results for from " section. Thus, you just need to access the appropriate key of the (specifically, the keys in the of the returned data). To access the and fields you were looking for, they are under the key: 

This is one of those happy instances where optimization will increase performance, maintainability, and readability. But first, Analyzing your specification With what you have described, the example outputs you have provided, and the code submitted, if I had to back-derive specifications for , this is the best I could do: 

Edit: Original code masked with , which was erroneous. Mask (corrected above) should be . Note: I have use casts because per the C11 standard, §6.5, para. 4 (emphasis mine): 

Now maybe your use case does not care about which bit(s) is/are common. But one of the nice things about C's design, and most idioms in C, is that truth is reduced not to and ; but to and anything but . I will come back to this point in my suggestion. Recognize the opportunity to work in parallel C's bitwise operators are just parallel 1-bit logic functions, so there's no need to check for individual bit positions one at a time; bitwise operations do not "interact with" neighboring bits (unlike mathematical operators, which have carry / overflow). So, to check if any of the "bit columns" in {, , , } are all : 

You're right, global variables/functions in general aren't the best. They can cause issues with naming and referencing in the global scope. There are a few solutions to this, w3 has a section devote to avoiding globals. If your snippet can be placed inside a class (ES6 only) or an app object, I suggest that. 

Warning: I am far from an expert with Sass! I'll list a few things I think could use some re-factoring. 

I know absolutely nothing about c# or unity3d, so if there's a language specific assist, I have no idea about it! I notice each condition checks , so that's one bit of information that repeats. I also notice we have three speeds, yet we have seven conditionals! First of all, the negatives are confusing. Find the absolute value first. I'm going to assume a number followed by an "f" means float. So maybe we need something like: 

A possible alternative to what you have: Use a while loop and count up for each unit. This method is often seen is change dispenser scripts (Out of $1.74, how many quarters, nickels, pennies, etc.). Simply declare a a variable , and then in a while loop, count up until you cannot make a whole pound any longer. E.g.: 

I had some data being paired with flavors, but I got rid of that feature. Is there any chance I can turn this project into something scalable, fast, and modern? 

I suggest you use someone else's maintained and secure code. They'll often have proper error handling too. Almost every PHP framework has one, and there's a dozen on GitHub. It's too hard to specify one, so I suggets you do your research. Question 4: Yes. Avoid s. Give yourself room to expand with a config file or a config class. Preferably the file, and then a class to interpret the data the file holds. Again, dependency injection.