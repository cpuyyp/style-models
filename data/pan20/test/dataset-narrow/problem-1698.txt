There's also resin.io which offers a "playout" system that handles updates, etc. when dealing with a fleet of Raspberry Pis. 

I have my Pi Zero W set up as a wireless bridge, bridging from wired to wireless ; of course, wlan0 operates in AP mode. So far so good. Now I'm noticing that when I forgot to plug in the USB Ethernet adapter for into my Pi Zero W before boot, it won't be added as a bridge port to my bridge automatically. How can I ensure that always gets added to the bridge, even if I plug into the Pi only later? My has to say this: 

I even run the VNC server on my Pi Zero Ws on a regular basis, albeit currently at 800x480 pixels only. I then connect from my laptop to the Pi Zero W's VNC server to do maintenance and development work on the "headless" Pi Zero W. 

Take a different spin: the Pi Zero W supports Ethernet Gadget mode (which is not to be confused with OTG mode). Ethernet Gadget mode means that you can connect your PC to the Pi Zero W using a standard USB A-to-microB cable -- but not an OTG cable. Note: with the Pi 2/3 you're out of luck, as they don't support the USB gadget mode. Only the Pi Zero and Zero W do. In Ethernet Gadget mode, the Pi Zero W appears as a USB Ethernet link to the PC, so both sides get IPv4 addresses (and probably also IPv6). On top of this IP link you could now use VNC with the server running on the Pi Zero W and the client on your PC to see the Pi's desktop and to control it using the PC's keyboard and mouse. You need to enable Ethernet gadget mode: 

In general, as the IPv4 address space is much smaller than the IPv6 address space (by 2^96), there is no universal translation possible to reach all IPv6 addresses from the IPv4 address space. You can't in general access the full IPv6 as you can't get the missing address bits in that IPv4 lack. There are applications of NAT64 with clients in IPv4 and servers in IPv6, but these work only under closely administered constraints in system configuration. For these reasons, your ISP needs to provide Dual Stack (DS) connectivity, either as full DS or alternatively as DS Light, so that you are able to use IPv4 as before until the final sunset of IPv4 (not really foreseeable yet). With DS Light you will be located behind a CGN Carrier Grade NAT, so that you are sharing your public IPv4 address with typically at least 16 other users, but depending on ISP more users might be mapped onto the same public IPv4 address. So, with DS Light, you are lost, as this is a "crippled" IPv4 working only on the client side, but not on the server side. While there are specifications to automatically forward CGN ports to your home router, good luck in getting an ISP that allows it, and the end system software to initiate it. So if you want to access the Pi from an IPv4 network, you need an ISP that gives you full DS. In that case you can simply forget about IPv6 for the moment, and then need to forward the SSH port from your home router with the public IPv4 address to the private IPv4 address of your Pi. 

Without a DHCPv4 server running on your Pi Windows usually will be very sad. So sad. The ISC DHCPv4 server can be easily installed, from package . Make sure to adapt its config file to reference the IPv4 subnet you have assigned to where your AP is. 

My limited understanding is that you can't do this with a single Pi and without a wired connection to your upstream router/access point. The reason why requires some deeper explanation of the Wifi 802.11 technology... At the moment, you route (NAT) at the IP layer between wlan0 and wlan1. As you said, there's no bridging present. It is highly important to understand that this configuration works, as the wifi client side has just a single MAC address. As another small side note, this isn't a (Wifi) repeater, as a repeater works on the MAC layer. The problem with your intended system configuration is that you want to have multiple stations behind a Wifi station ("client"). Even if you put a bridge br0 into play and connect the upstream wlan0 to it, as well as eth0, with br0 going into the IP stack for routing, it won't work (to the best of my knowledge). The reason lies hidden in how Wifi IEEE 802.11 works: it currently has a 3 MAC address model only. And having only three addresses means that you can connect multiple stations to an access point, but you cannot put a bridge behind a (non-access point) station. That is, because on the wireless medium you need two MAC addresses, one for the radio (!) sender, one for the radio (!) receiver. Please don't mix up radio sender/receiver MAC addresses with the end-to-end source/destination MAC addresses. This leaves us only a third address, which can be either a source or destination address in a larger, bridged IEEE 802.1 network. For bridging to work on a non-access point station, we would need a four MAC address configuration, with source/dest MACs as usual so we can address individual destinations beyond a single radio receiver/station. Unfortunately, that's reserved and unspecified IEEE 802.11 territory. I'm afraid you cannot achieve what you want with a single Pi. Could you use a second, separate Pi that just bridges your Wifi and which you have wired up via eth0 to your upstream router/access point in order to monitor traffic? 

Unfortunately, the USB mode the Pi Zero W's USB electronics and connector cannot be changed on the fly, and thus no hotpluging possible which would also cause a change of the USB mode. The OTG mode is requested by shorting an additional fifth pin in the USB connector to GND (if I'm not mistaken). If this pin is left unshorted and thus floating, the USB electronics will be configured into USB slave mode. Beware, changing the state of this OTG detection pin always does a hard reset without any warning (which is a pain in the back). Still, USB hotplugging is still possible, but only if it does not change the state of the OTG detection pin. Unfortunately, power fluctuations when hotplugging a device may also cause an unexpected reboot, albeit the OTG pin was left as it was. This depends on the type of OTG shim/cable used, as well as how well your USB device behaves. From my own experience with several Pi Zero Ws, different OTG cables and shims, and different USB devices I've some some combinations to work (almost) reliable, while others reliably cause reboots. The Pi Zero W hasn't been designed for such usages (I think); even while the technical specs would be sufficient, better use the 3B(+) when you need reliable USB host functionality -- even if it needs more power, produces more heat, and takes up more space. 

As you see the old square symbol, you're trying to boot an outdated Raspbian with boot code that doesn't support the 3B. Flash a recent image. Use the official 2.5A power supply for reference. As you see the top right under voltage symbol, the VideoCore GPU has successfully loaded the boot partition, may have enabled the ARM cores, and may have started them. The bolt overlay is managed by the VideoCore and triggered by under voltage. As your Pi doesn't successfully boot the kernel, there is serious undervoltage. All Pis are tested at their factories, so there is a really low chance of your Pi being bad, but a high chance that your power supplier isn't suitable. 

Yes, it's possible. Look for the recipes wlan to eth with NAT, then replace with your . One excellent is, albeit in German, this one which walks you through all the gory details: $URL$ While I'm writing this on my desk is sitting a Zero W with it's internal acting as AP. Connected to it is a tablet. I've an USB WLAN dongle attached via an USB OTG shim, it connects to my home network with Internet access. I only need it to update the Pi. But it is possible to NAT between the upstream additional and the AP . Bridging is not possible, but routing is. I've done this all also on a Pi 3B beginning of this year. The NAT rules even work when the upstream IP is dynamic. I was working from the description I linked to above. 

The most basic variant is to use : this is a shell script that runs during startup. Note that you need to start your script in the background when using , otherwise it will block execution of other programs started from there until your script terminates. So don't forget the . Another way is to write a systemd service unit file, which is a short text file describing your process and how it is to be started and stopped. There are tons of examples available, if you need help, then simply start a new question here and we'll help. 

I strongly suggest to test this on Raspbian Jessie, but not on Stretch, as Stretch is difficult to configure from my experience, with many things breaking in totally unexpected ways. One really annoying breakage is that MAC48-based so-called "stable" but unfortunately unpredictable network interface names are now enforced. This makes any configuration unique and as soon as you replace a network adapter, you need to update all configuration files. So safe ground here is Jessie, and I can tell from my own experience that running a bridge automatically works great. Getting the same done on Stretch is a nightmare and not worth the effort at this time. Alas, you first need some basic understanding what using a Linux kernel bridge (or any other software bridge) means: 

See this list for which USB Ethernet adaptors work with the Pis: $URL$ From my own experience I can only emphasize the advice given in the official Raspberry Foundation forum to strictly avoid any Davicom-based USB Ethernet adaptors at all. I've spent several hours trying to hunt down all kind of network problems until I finally replaced several Davicom adaptors with Sitecom model LN-030 v3.001 adaptors (Realtek-based). The Davicoms only appear to work, but most of the time they don't. And I had four of them, all with the same issues. In contrast, the Sitecoms work without issues, even if they only feature Realtek chips. Avoid any USB Ethernet adaptors that don't work out of the box with a stock Linux kernel. Some adaptors boast Linux drivers, some don't even have them as they're for Windows only. Most of the time, such drivers that were never integrated into the mainline kernel have severe issues, don't compile, or only in specific environments depending on sunshine hours, moon phase, and other parameters. Save the troubles, and vote with your wallet for those USB Ethernet adaptors that work right out of the (Pi) box. 

I fail to see how the new unpredictable network interface names fit into the self-esteem of Debian as being the stablest of stable distribution. The MAC48-based network names are the opposite of usable for most users, except real network experts. 

Your multi-card reader should show up as either one or multiple block devices, starting with , et cetera. You may check which devices are present using . Also, you still should see your mSD card with its partitions show up when doing . I've seen different card readers working slightly differently, so it may be that while multiple , are visible when you do an , the exact name depends on which kind of card you stuck into which socket of your card reader. Please note that is the whole storage device, such as an SD or mSD card. is its first partition, and so on. 

I would suggest to start over from a /etc/network/interfaces copied from a fresh image. As for logs, might be a good place to check anyway. 

pi clone which gets installed alongside with the Pixel desktop. the script from $URL$ which does roughly the same job, but without any UI. Clone the GitHub repository, and . Then ...