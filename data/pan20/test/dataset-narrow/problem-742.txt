In the long run these definitions could be maintenance problems if you need to change the parameters to the functions. The way your code is written to add a parameter to a function you need to do it in 2 different locations. A good habit might be to make main() the last function in the file. As your programs get more complex, you may have multiple files. You may want to reuse a function name in another file. To make you functions local only to the file: 

A collision is when 2 different functions have the same name, the same argument types and a similar functionality (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionality of a class such as std::vector or std::stack. Namespaces allow these constructs to be overridden. The use of the programming statement: 

This will become quite helpful as the problems and code become more complex and you need to include other name spaces. Some languages such as don't support namespaces, however, C++ does and it is quite a useful feature. More complex programs may use multiple name spaces and each one of these name spaces can contain a definition for functions such as or , or overrides on operators such as . You may even need to write your own or . Using allows you not to create your own name space when you write your own with the same arguments. Initialization of Empty Containers There is no need for the empty braces on this line: 

Reducing the amount of code is a benefit because it makes it easier to write the code in the first place, modify the code later and debug the code. You did well following another software engineering called the Single Responsibility Principle. The single responsibility principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. When raw numbers are included in code they can often be confusing. Also if the same number is used multiple times in the code for the same reason, such as for array bounds it is easier to understand the code and modify the code using symbolic constants. Some examples that might apply to this program 

It might be better of the number of arguments was checked prior to calling so that could return NULL if there was an error. That way the call back would not be necessary. The function also contains the lines: 

You worry about violating DRY, but you've violated a C standard, macros should always be all capitals. While I don't recommend it, the fastest code would be to avoid the use of functions totally and just have the macros. Inline code should always be faster than functions, although on modern computers this is less of an issue. The function can be a macro or just inline 

This could be a cut and paste error while creating the question. The program will not link of DEBUG is not defined. The code either needs 

Memory Leaks This program has a memory leaks. There should be a for every memory allocation, the variable gets gets freed once at the end of the program, this is the wrong place to call free on . Word should be freed whenever a Node is freed as root->lines is freed. Use the Library Functions The function isn't really necessary, the function can be replaced by , especially since already calls . Program Return Values The program already includes probably for , and . Since stdlib.h is already included it might be better to use and rather than in and in other functions. The Use of exit() There are two functions that use after memory allocation errors. This causes the program to exit without closing the input and output files. It would be better to have some way to return an error code from and and then closing the input file and output file before the program quits, even better if was called before the program exited. Not as Fast as You Think While the binary tree does allow a fast implementation, all the reallocation of memory can slow the program down. Every time , and are used the program is swapped out for a system call. 

The function copy_max() is mis-named, No one maintaining this code would know from the name of the function that the string is being shortened by the . Copy does not imply destruction of the source, move might be more appropriate. You may also want to consider the Single Responsibility Principle and break copy_max() into multiple functions. I see at least 2 functions there. This loop is complex enough to be it's own function and can be called from copy_max() 

First Welcome to Code Review, and nice first question for a beginner. You did a good job with variable names, function names, comments and indentation, although is incorrectly indented in both functions. The function is very inconsistent in the indentation. Consider the User You might want to add an error message such as "Invalid input please enter a number between X and Y" with X being the lower limit and Y being the upper limit. DRY Principle There is a software engineering principle call the Don't Repeat Yourself principle that may apply to the two input functions. Well written functions can be used in multiple places in code and decrease the amount of code necessary to implement a program or library. This code count contain a function called that implements most of and a lot of 

I needed to add these two headers to make the code compile on my computer, which is running Windows 10 Pro and Visual Studio 2015. I would have needed the same 2 header files in either XCode on MacOS or Eclipse on Centos 7. Avoid the Use of Macros in C++ Macros are a part of C++ to remain backwards compatible with ANSI/ISO C, in new C++ code they should be avoided because they are not type safe. Instead of using to define symbolic constants use either or . 

A collision is when 2 different functions have the same name, the same arguement types and a similar functionallity (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionallity of a class such as std::vector or std::stack. Namespaces allow these constructs to be overriden. The use of the programming statement: 

Variable Names I would use a struct to represent each rectangle, variables within the struct would be height and width. The struct could be named rect with instances of rect1, rect2 and rect3. If you don't use a struct, use better variable names such as rect1x, rect1y. Prompt For Input You need to ask the user a question before you scan the input. 

Use Meaningful Variable Names It's a bad practice to use single character variable names. using , , etc. is a throwback to Fortran that allowed undeclared integer variables starting with those letters. Using meaningful variable names makes the code easier to read, understand and debug. It also reduces the number of comments necessary. Some examples might be: 

It clearly defines what the number means, which makes the code more readable. It provides a type for the type checking that makes C++ a strongly typed language. It makes it easier to change the algorithm by allowing the values to change in one place rather than going through all the code to make the changes necessary. 

Variable Names: The base variable name is almost understandable, but what kind of base, does it provide a starting point for the function, or is it a numeric base like Octal, Hex or Decimal? It's really not clear from the code what x is. In main() what are the variables str (almost obvious), bas, n, p, base? Future Flexibility: You main could be a little more flexible, currently you can only redirect input and a output, you could use command switches in your to select input and output files as well. In main it is possible to add a couple of FILE * variable to make it a little more general 

Recursion in an Embedded Environment This function is a recursive implementation. Recursion is a memory hog and in an embedded system you may be very limited to the memory you have. Instead of using C type strings, why not use std::string? The C++ string type std::string has a find_last member that will perform at least half of this function. Macros in C++ It appears that you are more comfortable writing C rather than C++. While macros are supported for backwards compatibility with the C programming language the use of macros is strongly discouraged because they aren't type safe. There are many alternatives to the use macros. For defining constants there is and , for functions that handle many different types the are . In C++ there is no good reason to use macros. Missing Header File The standard library function requires the header file 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and stackoverflow question. Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

Why 5? Symbolic constants are used because you might not be the one who alters the code, or you may come back in 5 years to change the code. Unnecessary Code In options.c the functions askIfPowerballsShouldMatch() and getTicketOption() have the following code: