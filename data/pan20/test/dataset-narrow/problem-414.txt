Looks decent! Some smaller things: The is declared as . Always declare it as , since is an "implementation detail". If you'd switch from an ArrayList, you might have to change an awful lot of code. Also, it's name is , I would have used . Also, you want to think about if is the best type. Suggestions: Use a , where the String is the phone number. So it's a bit easier to figure out, if a phone number already exists and easier to remove a contact. With that said, another suggestions: Use a custom type for a phone number. So you can save stuff such as the country code, if it's mobile or office. (But then, the suggestion doesn't work very well anymore). Hope this helps, slowy 

Well, I would have made a view which does the selection and the dao would then do the mapping, or rather the disassembly and re-assembly of the resultSet (get all Cards, extract Clients, set the Client to the corresponding Card). So at least it's only one select. Or you could introduce a new type in a layer 'above' both dao's, which does the mapping. To your thoughts: 

Flip path, flip route, revert pathDirection, revert linkDirection. It's like a thesaurus in here. AStar & Polygon Okay, I think I have to stop here now... Guidance Alright. It took me so long, I had to take TWO cigarette brakes. Look, it's a quite complicated topic you got yourself into. Now, you have a complicated topic, and complicated code. It's the duty of a software developer, to write clean code, so a reader can focus on the topic. Ok? Clean Code Use the correct indentations. Format your code. Don't leave commented code. Get rid of "all" comments and make your code speak for itself. Use the common code conventions. Read the book "Clean Code" by Robert C. Martin. There should be a free pdf version. I really, really recommend that book. Many of my points in this review are also found in the book and discussed in great detail. Another thing: Good code, or clean code, is hard to measure. But if someone else opens it and thinks stuff like "Oh, that's nice", it's good. My favorite: "That code is sexy". You need to entitle yourself to that. OOP You have a butt ton of code spread out in a few classes. You really should read about oop principles. There's so many priniples and patterns which could be applied to your code. (Of course, OOP is not about splitting code into classes just to have smaller classes.) You might want to read about SOLID principles and about high cohesion and lose coupling. But from my experience, just reading about it is not too helpful. Getting better About producing "good code", I learned the must by doing pair programming and code reviews with good, passionate and experienced programmers. Yes, this site is called code review, but, you know, face to face communication is the best communication. Now, the fundamental difference between code review and pair programm - well, at least from an educational perspective - is, that a code review is more about finding bugs, smaller details like "this can be a static method", "there's a type", "I find that too complex". Pair programming on the other hand is more about "the process of thinking" and "decisions". If you do a code review, and you see, that the other dude for instance puts "x and y" in a type . You don't judge that. But if you do pair programming, he will tell you, that they "belong together". Working code If you finished your work, push it up to your scm, and you're thinking "The code works, I'm done.", I have bad news: That's only half of your work. In reality, often you will read more code than you write. If it takes you two days to read and analyze clean code, it can easily take you four days to read bad code. And in reality, that's a poop ton of money wasted. Tests You didn't post any unit tests, and I'm fairly certain, that there are none. You know why? Because it's not testable. I highly recommend to read books about unit testing, especially test driven development. There's people who like it, there's people who don't. But what it will do, it will produce testable design. Which is quite better than a non testable design. Now, why are tests so important? Well, if you have horrible code, which needs refactoring, and you can not write unit tests, because it's not testable, how do you figure out, if it still works? I have seen classes with thousands of lines and dozens of inner classes. I wanted to refactor it. But I didn't. Because it was so bloody complicated, everything had dependencies to everyone, everyone to everything. And if you have code which is about money, in the sense of: If you break it, your customer will lose money, and you are not 100% sure it works, you're so freaking scared, you just leave it. Brutally honest If you'd present that piece of code in an interview, even fresh from university, you won't get the job. If you'd have a job and are developing in our project and would push code like that into our repository, it will be back-outed immediately. Then we'd do a lot of pair programming ;-) Hope this helps, slowy 

Dude, that's the default exit code... MK_7WithUI.java Holy smokes, it doesn't stop. Well, MK_7WithUI indicates, that the type will do to much, the word "with" usually indicates that... 

WAIT WHAT? Well, the Console code is not posted, but if that thing actually is a JFrame or something, you're gonne make me really angry. getSimulationInspectedObject() 

... if possible. In your case: Try not to send one json string per line, try to send as much as you can. 

Please don't do that. Declare variables line by line. Btw, what ? In maths and physics, it's usually called velocity. 

Not writing a test case is a huge part. Because, as a software developer, I say, that test code is as valuable and as important as production code. The other stuff can mean, that you're very inexperienced, never worked with other people on a project, or never did a code review. And you do not know the basics of the SDK. Other tips: 

Read the constructor JavaDoc of Random. If created within the same System.currentTimeMillis(), it will use the same seed. Beside that, I've seen a random variable somewhere, why not use this one? 

underscore prefix First of all, I do not like to use an underscore as prefix. That was made back in the day, when IDE didn't visually represent member variables as member variables. Same goes for static variables or constants. As long as you don't write your code in vi, there's no reason to do so. guards Your 'guards' are spread out in the constructor (the day=1, month=1,year=2000 parts). Make sure the variables are correct first, so you can be sure the rest of the code works. Beside that, the user has no feedback, if they pass rubbish, they just end up at 01.01.2000. This is very error prone. Validate first, and throw an exception if the parameters are wrong. And actually, those are not really guards, but default values. code duplication (don't repeat yourself) I count three times, the assignment of the 'default values' four times, the assignment of the actual parameters four times. The part can easily be refactored to a separate method or something similiar. The default values can be assigned directly when declaring the variables. But to be honest, the type shouldn't have default values in the first place (imo). naming / comments The method has the comment . First of all, that's a JavaDoc of a private method. Try to name your stuff, so nobody needs a JavaDoc or a comment anyway. If I'm coding within the type, and my code completion shows me , I imagine someone jumping meters high (and high, because y is the vertical axis). Usually, methods which return a boolean, have the prefix. But is not enough, because a date can't jump. So go with . A small and maybe unnecessary detail: In most date API's, the day is usually named "dayOfMonth", to avoid confusion with "dayOfYear" or "dayOfWeek". Check how others implemented it You're far form the first who implemented a date. And actually, there's a lot that can go wrong. You might want to check LocalDate on grepcode.com. The LocalDate of the OpenJDK is over 2000 lines long. Most of it is, of course, additional functionality. But everything else might be interesting. Don't reinvent the wheel To be honest: I don't see any reason not to use already written code. The is fine, does everything you want and even more. And it is more 'complicated' (better: comprehensive) than one would think. I'd be somewhat disappointed if I had to write and especially maintain code, which is shipped by the jdk. Okay, to be honest v2: Working with before JDK 1.8 (I think?) was a huge pain. People used that fancy jsr-addon for 1.7 or JodaTime. And to migrate that stuff - especially when your software is supporting several timezones within one VM and one backend - wasn't very economic (and quite scary). But they did a really good job in 1.8, imo.