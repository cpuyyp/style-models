It looks good! I only have some minor suggestions. You might want to not have the LINQ expression all on one line. Right now I have to scroll to see it all. An alternative is to use to create a range of indexes: 

You can have a boolean as a parameter and select X or Y and Width or Height based on that parameter. You can declare the method like this: 

Because rectangles with the same X position weren't matched before, won't contain , so if it has a length of 1, that 1 element will be a different rectangle, but only the original rectangle will get added as a group. In the inner loop, the body of the last only adds the initial rectangle, but doesn't do anything about the previously added s, so it's possible for the loop to add a bunch of but only add the initial rectangle. If you get a list of the rectangles ordered by their X position right away and loop through that instead of the original list, you can take some shortcuts in the body of the loop. Edit 2: You should add more descriptive names. I don't know what , , the nl in , etc. stand for. Short names are okay for lambda expressions and loop variables, but even then you should stick to , , , , or a letter that relates to the object. I think it would make more sense to use for a rectangle than . 

The first thing you can do is assign all the properties for a thing in one line using an object initializer. The following: 

If you can only change a bool once, and the entire purpose of a loop is to set the bool, then you should just exit the loop after the bool gets changed. There's no point in looping more than you need to, and you also don't have to worry about the bool getting switched back. So you can write your example like this: 

LINQ's method syntax (which uses lambda expressions) is not that good for this problem because the problem has nested loops, and it would be nice to store intermediate values. LINQ's query syntax is great for both these things. First we create a helper method for calculating the product of a collection of integers: 

I don't know much about making numbers random enough, but I have some other suggestions. Instead of checking if a range of integers contains a number you can just check if the number is >= the beginning of the range and <= the end of the range. So you can replace this: 

As D. Jurcau mentioned, you can move that first block of code outside of the if and else and only write it once, and you can handle the min or max checks with and . To combine the second block together you can write a Clamp method that makes sure a value is between two other values, like this: 

Is this useful or is there an obvious other way? The context is solving the problem of bubbling events in an asp.net site built with user controls and nested user controls. I found myself writing a ton of events. So instead of events, i'm using a technique to allow any client to watch an arbitrary session value. A shared context class for Page and UserControl. Updates to session values go through here as well as registrations for session value changes. 

Now in my web page code behind, instead of subscribing to an event, an action is registered for a session value change. 

I'm not very experienced in test-driven development (TDD), but I'm trying to get into the groove. Here I am making a console app that creates records in a database. I bootstrapped by creating a console app and then let MSTest make a unit test for . I know I'm doing at least something right, because the tests didn't pass until I did the development -- they "drove" me to "develop". But I feel like maybe I'm still missing the point, as I didn't really test my code - I tested the database the code acted on. How would an experienced TDDer approach this? 

Second way: No additional local variable but the call to is duplcated in both branches of the if statement. I think this is clearer even though logic was duplicated. 

This is a fairly trivial example of a question I come up to often. In the example below I tend to think that allowing duplication sometimes results in clearer code. Does anyone agree/disagree on this point? First way: an additional local variable is used so is called just once on the last line. I think this has slightly more logic to decode than the second way. 

I just wrote some code that is very representative of a recurring theme (in my coding world lately): repeated logic leads to an instinct to eliminate duplication which results in something that is more complex the tradeoff seems wrong to me (the examples of the negative side aren't worth posting - but this is probably the 20th console utility I've written in the past 12 months). I'm curious if I'm missing some techniques or if this is really just on of those "experience tells you when to do what" type of issues. Here's the code... I'm tempted to leave it as is, even though there will be about 20 of those if-blocks when I'm done. 

I had this same issue today. I already had a table of the databases, so I wrote a program. It could be done with dynamic sql in the same way. That said, I have huge regrets that my original design used multiple databases in the first place and maybe the reality is that the reason its not something readily doable is related to the fact that its not something that ideally needs to be done (just a thought). 

There are magic numbers everywhere. If you decide to change the size of your board, you are going to have to change a lot of numbers. Normally you can just declare them as constants privately in a class, but because they are used by multiple classes I recommend extracting the magic numbers into a class. You shouldn't have public fields. The following: 

Why does have three parameters but only use one of them? should be declared inside the loop because it's not used outside of it. You can assign it on the same line that it's declared. 

The thing that sticks out to me the most is there is a lot of similar or duplicate code. Let's look at the code for assigning the reactionTime: 

it won't get rectangles that are at the exact same X position. But that won't matter if it's guaranteed that none of the rectangles overlap. Then there's this code right after: 

A method would be useful and more efficient here. You can implement your own or find it in a library. I believe all the Project Euler problems have a solution that is a lot faster and more memory efficient than brute force. So you can try to figure that out for this problem next. For the later Project Euler problems, brute force is not an option. 

The only thing that changes for each statement is the index is incremented, so we can replace all of the statements with a loop: 

Since the loops are similar, you could extract one into a method and then replace them with two method calls. I'm going to replace the loops using LINQ. This requires 

If you wish to keep the speed of your original solution and increase readability, there are many improvements you can make: 

You can get rid of a lot of repetition in by storing things in arrays and accessing them by the . You can set up your arrays like so: 

I think your version three is still better than my alternatives, but you might prefer one of them. is nice for replacing loops, and query syntax is nice for declaring intermediate values (like ) and replacing nested loops. But the method that takes a lambda that includes the index as a parameter is very nice for this situation. With enough practice you can get to the point where your code looks like version three right away. I rarely write loops anymore. I actually find them tougher to write because they make you focus more on "how" than "what". 

Alternatively, you could have functions as parameters for selecting the properties, like using a lambda expression in . Edit: as for the first method itself: In the following line of code: 

In terms of speed, your solution is about as optimized as it can get. In terms of readability, your solution has much room for improvement. I prefer readability over speed. You should try to make your code as readable as possible, then, if you have performance issues, search for bottlenecks using a profiler and optimize them. The method body of can be made into a one-liner, which happens to be slower but is much more readable. 

Now, in spirit of the course, I'm not going to give you the answer. However, the lines you changed are relevant: Old Lines: 

20 minutes of trying to understand this code later (That's a lot of dev time!), I sort-of get what you're trying to do here. That's not , it's . I'm still left confused: 

Apparently, non-rented cars cannot drive. But yours don't notify the caller. They'll happily report the trip as having taken 0 liters of fuel. I want to buy one of those cars. Not having to pay for fuel would be great. 

It'll be your task to implement the ones I haven't shown yet. You'll also have to move some of the variables so they're class members, not just declared in a function (hint: and are two of these, I don't know if there are more). Given the name of the functions, it should be easy to guess what they do. shuffles the cards. tests if two cards are a match. And so on... 

We're far better off by changing "If not conditionA or not conditionB, then controlA is true. If controlA is true, then functionB." to "If not conditionA or not conditionB, then functionB." 

You've just cleared both your lists. I'm not sure that was the intended goal, but it could happen. Maybe it can't happen right now due to certain circumstances. But you'll make a future change and all of a sudden it will happen and you will have bugs and these bugs will be near impossible to reproduce... you'll get a gradually building list of tickets of customers who report that sometimes, it doesn't work. Make a special that you create once and never mess with again. Then on that. Do the same for . 

You can remove the first if statement, it's not necessary. Clearing a list that has no elements is almost free anyway. 

If you make enough use of descriptive function names and variable names, eventually the code will read like a weird form of English. 

Maybe you should label the function . It's weird that you're returning a negative, though. Let's see where you're using this... 

I think a MenuOption should be a separate class. A MenuOption has a name, a pick function, and a way to call functions on your Main class where you have all your business logic. Right now you have duplication in the numbers for menu options and in the handling of menus. 

The real reason it's hard to read is because is a pretty bad description... in this case, you're looking for something like ... but that doesn't really fit the description either. 

You could use a here. , or better, . Then you just have to get the Tile from the map, and ask that for the image. And if it's null you can return a blank. 

Although maybe it'd be better to just calculate the offset; in that case you could invert to get the cartesian view.