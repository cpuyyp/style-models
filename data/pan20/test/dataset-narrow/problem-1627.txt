I will make this answer more general. There are couple of things that one should check if having problems with audio. In no particular order: Check if it's not PCM sample rate/format problem Currently RPi ALSA driver has no nmap support. This makes plug ALSA plugin behave badly. This plugin should let you play any PCM format you like converting it if needed. But it is not on RPi. Instead it does report to applications that the format is supported but it fails when it starts playback. One way to fix this is to turn on mmap emulation using .asoundrc file in your home directory or /etc/asound.conf: 

Use file as Upload all the modules to from in your computer to directory on your RaspberryPi rootfs. 

The answer Yes it's safe. Judging from the source code of the library, it doesn't cache the values but reads them each time you call function so it should work as expected. Documentation It isn't really documented in the wiringPi documentation but at least the documentation also doesn't say it's forbidden (for example for there is a not saying that you have to set the pin to first). So we have to dig deeper to get the answer. Some background WiringPi can control GPIO in two modes - using interface and using RaspberryPi specific registers in memory. First option is a standard in Linux and it's documented here. Note that the documentation says: 

First thing that you should do is to ensure your TFTP server is actually working and ensure it is configured for logging. This way you can check if RPi requests where received by deamon. uses and so is not really reliable. You can debug it by capturing the network traffic on your TFTP host using or : For , you can use something like (you can termianate it by CTRL+C) 

As pointed out by @nos, your script has syntax errors. This line is wrong (having more than one error): 

You can use VNC server on rarspberryPi and VNC clients on developers laptops. You can use tightvncserver package for this. In most typical setup, each client connecting to VNC will see exatcly the same screen, will control the same mouse pointer etc. I believe you would like to setup it so that every one that logs in gets his own individual screen. To start VNC session, you can type: 

The quick answer to this question is that you can limit the current using resistors. You can use, for example 1kOhm resistor to limit the current to `3.3V/1000 Ohm = 0.0033 A = 3 mA. This amount of current wont damage your RaspberryPi or button for sure. If, on the other hand, you wont use the resistor, you will create a shortcut which can damage RaspberryPi. Button should be safe, however. 

There's a lot of problems with USB stack on Rapsberry Pi and developers are working hard to fix as many of them as possible. They introduce some kernel modules options (like ) that enables those fixes from time to time. Most of them are being enabled by default in recent kernels so you don't want to know them in order to use them. It's always good to know what you can disable when troubleshooting problems, though. And it's good to know that you don't need them in your cmdline.txt anymore when cleaning it up or reinstalling your SD card. So what is the list of all such options that and what is their meaning? 

Pin numbers Your chip has 16 I/O pins that are divided in two groups of 8 pins each, called and . Physical pins of the chip are used for and physical pins are used for . Rest of the physical pins () are used for other purposes like setting the device address, connecting power and ground, etc. The device has quite a few registers that can be individually written/read in order to perform different operations. Two of those registers are (0x12) and (0x13) 8-bit registers that can be used to read/write whole or at a time. This means that if you read register, you will get 8 bits of data and each of them will give you the value of different pin in . The same goes for writing - if you want to write some value to any pin in , you have to write whole register setting values of all pins in bank A at once. How to calculate bank value As already mentioned, each bank consists of 8 bit which corresponds to 8 pins values. Here's how the value is computed for : 

There is a very important line in top called "Cpu(s)" (3rd line in my top) where you can find where CPU time is being spent: 

Testing card write speed: There is no easy way of testing write speed as to do this you would have to actually write some data to the card. If you would like to do this on low level (omiting filesystem) you would have to override some data on the card and you probably don't want to do this. This can be done if you have swap partition as it can be easily deactivated (with ), tested with dd (with ) and then recreated (with ). If you don't have swap partition, you can test filesystem write speed also using dd command: dd if=/dev/zero of=/home/pi/testfile bs=8M count=25 This will create 200MB file in . You can use any other filename you want. Notes: 

Yes, there are at least two of them: GPIO kernel module The full documentation of this subsystem can be found here (look for subsection). Basically, kernel exports some files in directory. Here's an example usage (using pin 0 as an input and then switching it as output and setting to 1): 

Unfortunately things are not as easy as you described. All the applications you gave as an example (a compiler, an editor, an interpreter, etc) are quite complicated and they are not only doing computation but also interact quite heavily with the OS. They need a way to use files, interact with user (like keyboard input, screen output), expect a concept of "process", etc. All this is very OS dependent. Think of it this way - if it was so simple, would it be so hard to run for example Windows applications on Linux (providing they both run on x86 architecture)? What you would like to do is even more complicated than that since when porting some application from one OS to the other, you already has OS. In your case, what you have is really far from being even simple OS. What you can do is to provide C language (or in fact any other language) runtime that will allow running programs written in this language. But keep in mind that while it may be easy to write runtime environment, porting libraries, even standard ones, may be extremely difficult. That being said, you can find a lot of useful information on dwelch67 github, you may want to take a look at DexOS and see what you can find on bare metal section of raspberrypi forum. 

It tells to allow user to run all cammands as user without even providing password. You can change last and specify comma delimited list of commands (with their full path) allowed to run. In your case you should change this line to: 

Good power supply is not enough. USB ports on RaspberryPi are behind polyfuses which limits current that can drawn from it to about 140mA (in practice, it should be even smaller). So no matter how good your power supply is, if your USB device wants more than say 120mA of power, it will fail. Note that USB specification says that enumerated device can take up to 500mA so some devices are designed to take much more power than RaspberryPi could give them. What is even worse, the more power you are trying to take from USB, the bigger resistance is on polyfuse which means there is bigger voltage drop. This may be another problems for USB devices. You normally gets less than 5V on RPi with cheap power supplies anyway so dropping it even more may make it out of spec. Also bear in mind that your device may be working at first but stop working after couple of seconds/minutes or at bigger load or when there is a hot day. Power consumption of many USB devices is not static and can change depending on many circumstances. Also, I would say that 750mA power supply is not much. It could be OK for normal workload but not when you connect some power hungry devices. And WIFI card can take a lot of power. Note that maximal current that power supply can provide is not the only critical parameter. In most cheap power supplies, the more power you get, the lower voltage is. And if it drops below 4.75, you can have problems with your RapsberryPi. So while some people got some Wifi USB cards to work on RapsberryPi without powered HUB (but probably having better power supply than you), it's not recommended setup. The recommendation is to use RPi USB ports only for mouse/keyboard and attaching everything more power hungry using powered HUB. 

It depends on what type of connectors your sensors have. If you have standard 0.1" headers, you can use . Depending on the other end of connection (for RaspberryPi side you have to use Female connectors), you can use female to female () or female to male () . They should be easy to buy on any hobbyst electronics shop. You need female side for connecting to RaspberryPi. They are very often used with which are very handy for prototyping If, on the other hand, you don't have any connectors on your sensors and you are going to solder them, you can cut F-F jumper wires in half and just one one end for RaspberryPi. It is also possible to make your own headers but you need and with housing. This is much more expensive to get.