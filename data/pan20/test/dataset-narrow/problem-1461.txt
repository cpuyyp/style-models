I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: 

Automatic testing would find these equivalent, but clearly one is incomprehensible and the other is relatively logical and sound. This is also recognised in Using Test-Driven Development in the Classroom: 

I would be keen to avoid punishing someone who might not have done anything wrong, but some others might not give the benefit of the doubt. It's certainly not easy to tell what exactly has gone on when two very similar works are handed in, but if you can rule out any copying without the author's awareness with certainty, then you must assume that the author facilitated cheating. If you haven't made clear what the difference is between helping and cheating, then you can't really punish anyone fairly—if you don't clearly lay out your expectations, then you can't enforce strict rules. 

In an ideal world, you might give students a problem, and let them explore solutions to it rather than actually covering the content directly. For example: 

I don't think the concepts behind generators, sequences and iterators are too difficult to grasp if you're clear on what exactly they are. The 'old' function of Python 2 just produces a list of numbers: 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

I think whether and when the test cases should be released depends on a few factors. Not releasing the test cases You say that the assignments were only partially assessed by the unit tests, so in my understanding this means that there is somebody having a look at the source code. If (and only if) the assessment was fully automated and there were no human beings looking at the source code, you should not release the test cases before the assignment as otherwise it would be possible that somebody just created a program that has the required outputs for the test cases hard-coded and chooses the right one (using some kind of map or dictionary) depending on the input. If you plan to put the same (auto-graded) assignment again on students in e.g. multiple courses, you might also want to avoid releasing the test cases after the assignment - otherwise students that have completed the assignment could be able to hand the required test cases through to the students that haven't yet completed the assignment. If you however change the unit tests for an auto-graded system after releasing them (i.e. each course has it's own set of unit tests for the same task), then you could release them after the assignment. Releasing the test cases before the assignment I can imagine a situation where it's neccessary to release the test cases and to do this before the assignment: If you're doing test-driven development. In this case having all the unit tests available to everybody would be essential as otherwise the whole strategy wouldn't work. Furthermore, the test cases could help students as they are examples of the program's in- and output if they have trouble understanding the specification (as specifications can benefit from examples). I would even go further and would recommend you to release the test cases before the assignment in almost any case unless you have specific reasons against it. Releasing it after the assignment This could be an option if you want the students to figure out the algorithm without having examples (not sure when this is required, but maybe there are some sort of tasks that require that) but you want them to give a chance to review their mistakes after the assignment is done. I would always try to release them at the latest when the assignment is done. 

Now we've discussed what the problem is, and what most people would do to solve it, you should be able to see why lessons don't actually reach every student, despite no-one actively aiming not to reach everyone. The Solution I can't really promise a straightforward solution that works now, and reaches more students without a lot more effort. pddring's ideas are excellent, and you should strongly consider providing different 'routes' of challenge so that all students can take something away from your instruction. At the very least, you probably need to ensure that students understand enough to build on the concept you've taught (e.g. understanding syntax to a reasonable level before moving on to constructing more complex algorithms). The holy grail is the 'Digital Aristotle' that CGP Grey talks about, but I don't think it's entirely here yet. Some Internet resources like Khan Academy provide excellent self-paced resources and self-test questions which might be helpful to use if students need to work on things at home, so that they do have the prerequisite knowledge. In essence, there are two options to reach more students: provide different teaching for different abilities of students, or try to make sure everyone is on the same page before they get to your lesson. I feel that I've written a lot without actually proposing a real solution, but it's extremely difficult to solve this problem. If you're willing to put in the time, you can provide different levels of difficulty in each lesson, which would at least ensure that the vast majority of abilities are taught well, but I think that the future lies in computers adapting a curriculum just to your students. If you find a platform where you can put tasks that adapt to a student's ability, it may be worth considering so that you can challenge every student to reach their potential. 

Why should you try to teach every interested student and assist them in reaching their different personal goals? I think you've already given the answer in your question: Because each of them is genuinely interested in learning something. In my opinion, one of the wonderful things about schools is that they are designed to be places where knowledge is spread. People who already know something about a topic (often these people are the teachers, but even this doesn't have to be the case every time) share their knowledge with people who want to gain knowledge about this topic (usually the students). In reality, this principle is sometimes hard to encounter: As there are usually a lot of required courses in most school systems, you'll always have students who aren't interested in learning something, but are just forced to attend. Still, as I want to focus on the idealism here, I think the reason why teachers should try to teach everyone who is interested is because teaching every interested person is the primary objective of a school. When discussing this question with some others, it might be good to reach a consensus on the level of the discussion: I could imagine that somebody argues with you about this question assuming you are talking about a given, realistic situation and wants to convince you that in certain situations it's (as you also already stated) just not possible or incredibly difficult to teach everybody. 

Given a large amount of time, actually rediscovering some solutions to common problems would help your students to think critically and understand why certain design choices have been made in CS. But you could spend years rediscovering things that are already known, and sometimes just telling allows you to move on more quickly. Removing 'the content' completely from the course would essentially render it pointless—if there's no goal ("in this course, we will learn X"), the course wouldn't really seem to help anyone. As a summary of my views: delivering the content is practically a requirement given the time constraints of most courses, rather than letting students investigate things for themselves. Perhaps changing this would provide some benefits, but the current system has emerged because it's pretty efficient as passing on knowledge, even though some students don't benefit as much as they could. 

How did you begin to teach Java to your students? I bet you didn't start by showing them the Backus-Naur form that the Java parser follows. Instead, you probably introduced a simple "Hello, world" program, and slowly built on that with assignments and projects for the students to work on. I'm sure you can see the parallel here—teaching XML as a prerequisite for HTML is not, in my opinion, a productive or helpful exercise. XML is a rather boring language; it doesn't do anything, so you don't get that instant feedback when you write some code, unlike in HTML, where you can see the webpage unfold as you add elements. HTML is also simple enough that you can generally pick it up as you go along; explaining that you start an element with and end with should be simple enough, and any mistakes in the markup will be visible when you load the page. As a general rule, if you want to teach [insert language here], you probably don't need to teach a different language first; teaching XML to make HTML easier probably won't give you the benefits you're expecting. I'm rather partial to the typical "Hello, world" for HTML. Almost certainly, your students will spot that the title is "My First Webpage", and I imagine that they'll be able to guess with some guidance. 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

If you already use an IDE, this could be the right way for you: Git support in your IDE Many IDEs come bundled with Git support. Eclipse, for example, uses EGit for Git integration. The JetBrains IDEs also provide Git support. The text editor Atom can be extended with plugins (e.g. Git+) to provide Git support. All of those IDEs run on most common platforms (e.g. Linux, Mac, Windows) and look more or less the same there. This would mean you can use the Git client you know at home and at work if you use the same IDE at both places. Normally, the Git support integrates quite well with the programming workflow. The Git clients are often quite mighty, but always accessible using a comfortable GUI, which could help as there are no terminal commands to memorize. However, you should keep the Git concepts in mind - depending on the IDE, the built-in Git client will follow those concepts more or less closely.