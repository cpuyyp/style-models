What are the permissions? Ownership? Perhaps a mounted filesystem has gone missing, and you don't have write permissions on the underlying mountpoint? 

An ALTER TABLE operation that adds a column to a table should be a simple data dictionary only update. There is no reason for Oracle to visit all the blocks/rows in the table. So, the operation should be very fast. (sub-second response time.) The only exception to this would be, if you're on a version of Oracle prior to 11g, and you're setting a default value for the column being added, Oracle has to visit all the rows. In 11g, even setting a default value will not precipitate a visit to all the rows in the table. 

Do you still have access to both the 9i and 11g databases? If so, connect to each one and do: (NLS stands for National Language Support, and showing all nls related parameters should tell you the characterset, as well as a few other details that may be relevant.) When running the export and import, did you correctly set the NLS_LANG environment variable? You mentioned numerical values, are these NUMBER datatypes? I assume you're using exp/imp to create the objects, and not just move the data? If that's not the case, are you sure all datatypes of all columns match across all tables? 

The composite primary index will always ensure that the combination of col1, col2, col3 values are unique. If the purpose of the index is to ensure that the values are unique then you will have achieved that A composite index also provides for index matches on any combination of the columns col1, col2, and col3 You would create separate indexes on col2, and col3, if you join or filter using any of the columns without the others. I always prefer a numeric primary key (with no business association), and unique indexes over a composite primary key where necessary. 

If this table has no other foreign keys attached to it you can try INSERT ... ON DUPLICATE KEY UPDATE or REPLACE INTO (this one deletes an existing row and inserts a new one) This would save you having to select first then insert or update, however it requires that you have a unique key to base the checks on 

You can try Adminer ($URL$ which supports MySQL, PostgreSQL, SQLite, MS SQL, Oracle An additional beauty with this is that its a single PHP file that is deployed to your server 

From the MySQL Workbench 5.2 window, select Database -> Synchronize model which will allow you to synchronize the model (EER diagram) with the database (you need to create a saved connection) for it. I recommend this method over just reverse engineering the model from the database since it maintains the layout of the EER diagram. One caveat is that you need to add new tables to the EER diagram manually. 

My goal is to go through all entries for a given date and assign the field "rank" for results. For example the player with the highest score should receive rank = 1, 2nd highest score rank = 2 and so on. If 2 players share the same score, they should receive the same rank (olympic scoring). Example: 

The problem is, however, with some hundreds of thousands of entries, this query runs for a couple of days, even though I have created indexes for the WHERE conditions. How can I optimize this query to run faster? 

Is a SELECT statement a complete transaction, meaning the isolation level will be reverted to session default after the SELECT was executed, or does a SELECT somehow not represent its own transaction, meaning that the isolation level will not be restored after a SELECT statement? 

I have a Master / Slave Setup in production and from time to time I add or remove a slave and recently I also removed the master and promoted a former slave to new master. This procedure usually involves dumping my master DB like so: and then reading the MySQL master log position from the dump like so: 

Turns out I have called accidentally on the live server. The slaves stopped replication now because they can not find the expected bin log files on the master. Is there a way to continue replication without data corruption and without reimporting the whole dump on the slave? Is it save to call with 'mysql-bin.000001' and position 1 on the slave now, because that is where they should continue, or do I risk data corruption in that case and it is generally preferred to reimport the whole dump and start over? 

I do not think that the location matters rather it is a matter of personal preference, and the MySQL installer will automatically update the my.cnf file for you. However I would rather go with D:\mysql as the installation directory because its lowercase, has no special characters (spaces, capital letters) and is not in the Program Files directory which you may need to clean out for a new install or upgrade. You may also need to add the D:\mysql\bin directory to the PATH environment variable so that you can run the MySQL commands from any command prompt 

In the backup script the views are first created as tables which are then dropped at the end of the script as each view is being created, so it seems that an error occurs while creating the views at the end of the script. However when a view is created there is a user who is used in the DEFINER clause of the view who may not exist in your database, e.g., DEFINER=@ I usually remove that clause in the backup script and it tends to work. To verify add the -v option when importing the database 

I think the question of duplicated data depends on the meaning of the relationship between the two users. For example if the relationship is who is following who, then User 1 can follow user 2, but that does not mean that User 2 is following user 1. However if the relationship is where there are no duplicates, for example if the two belong to a team or work together, then the above model would not necessarily work since you need to relate them through another entity, team in my example