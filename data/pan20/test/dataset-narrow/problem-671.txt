since the rename is redundant. As already mentioned, it's more common to be a bit more explicit with error handling in Go and let utility functions (such as your ) return any errors for handling "higher up". In addition to Effective Go, I suggest looking at the Go project's Code Review Comments page. Although the later is only what the Go Authors use and isn't necessarily more widely applicable, I find it a good starting point. Among other things, with respect to naming it suggests (again as previously mentioned) using , , , etc instead of what you use. Also, while on the subject of naming, I personally subscribe to Russ Cox's naming philosophy which suggests vs , versus , and vs for identifiers used within a short span (as opposed to file or project wide identifiers). When it comes to marshalling to/from JSON, use of struct tags allows you to not only map Go style names to JSON style names but also apply other attributes (notable things like "omitempty": ). In particular, without this if you tried to marshal your stucture back into JSON I believe you'd end up with your JSON fields capitalized (as Go's package can only deal with exported fields). The code review comments page also recommends applying caution/restraint to the use of named result parameters. They can be useful for documentation via but I try and avoid them just to save a variable initialization line in the body. Your tastes may vary, but if you use them be careful of shadowing the named returns (e.g. with a named and inside an if/for having something like ). Instead of using something like to pre-read all the data I find it useful to look for "streaming" based alternatives. For programs that process large data inputs (e.g. reading from a large file) piece by piece this can make a big difference. Here, provides a type for this purpose. In this specific case I don't know if it makes any memory/performance difference but I find the result of using it (and combining your send and parse functions) seems to simplify the code. Back to marshalling, it can sometimes be helpful/useful to create your own thin wrapper types with custom (un)marshalling rather than limiting yourself to basic types. For example, in the code below I've added a type that unmarshals from the way StackExchange API is documented to do all time/dates. You could easily add a method if marshalling was also required. The difference isn't that important here, but for example, it allows easier use of all the methods/functions (e.g. , changing the output timezone, etc. In several places you do things like: 

this way you can re-use the mapping definition. Just my opinion, but I'm not a fan of Automapper's kind of magic. When using these tools you won't get any help from the compiler when renaming or change types of properties. e.g. If you rename a property in your Entity but you forget to rename the same property in your CustomBehaviour class. you won't notice until run time that the mapping has failed. If you would you a manually made mapping, which tends to also be faster, you still won't have your property name changed, but you will still get your data. The same thing happens when change a property type, with Automapper you won't notice until run time, manual mapping will give you a compile time error. Of course the benefit for using Automapper are there also. 

this helper is now responsible for only handling connections and transactions and if, in the future, you find a new ORM which uses the IDbConnection like Dapper does, you can re-use it. Next thing you could do is make use of the "repository pattern" in my opinion this should not be a generic interface with CRUD operations, but It could be that. 

In addition to Maxim's answer, to avoid giving the employee class too much responsibilities, by adding the AddToDataBase method there, you could take a look at the repository pattern. Repository pattern explained. This pattern is created to handle database management. 

Use static variables that are already part of the Javax MIDI library. For example, your and magic numbers can be replaced with and respectively. This applies for the message as well. I'm not sure what that's for or why it's necessary, but I'll take your word for it :) Similarly, that magic can be made a private static final variable on the class. And the . I'm not sure what that does either. Velocity? Let's go with Velocity. 

Midi class. If Midi is no longer to be sharing the MusicInfo object (since it doesn't exist anymore!), it needs to know when to update the track, and what to update it to. One option (there are probably better ways) is to expose a method such as: 

Back to the class, and the GUI class. Do away with . I view your UI as having rows. Each row is for an instrument, and each row has some checkboxes which represent beats. To model this, we can make : 

Now, you might be wondering how that helps at all. For one, it abstracts out (to a reasonable extent) all of the work needed to create a row, add the label, handle changes to a checkbox, etc. This also helps with extensibility. Say you wanted to add a button to your app that adds a new instrument (or even one to delete). Previously you would've had to do a bunch of work to update and maintain that 2D array of objects. Now, all you would need to do is add a method to your UI to addInstrument(), which would create a new InstrumentRow instance and you're all set! I won't go into much detail on this, but one thing that is also a good practice is to separate your view into an interface and an implementation. The implementation would be specific to the UI framework that you have chosen. For example: 

This repository is now the abstraction you are looking for. If you now want to move a way from dapper and use e.g. NHibernate you could create a new implementation of the IAccountTable interface and let this be injected instead of the DapperAccountTable. Last but certainly not least is that this is only possible when using Inversion of Control I think that this is the maximum amount of abstractions that is possible in a DAL. Other ORM's like EF and NHibernate differ so much from Dapper that you always have to re-write your repositories. 

My two cents; Lengthy class names are not necessarily a code smell, as long as they are descriptive. I found the Ubiquitous Language in Domain Driven Design an eyeopener in how to structure and name my classes. The link I provided describes in overview what the Ubiquitous Language is. Google some more to get a good idea of how it works. 

To be clear I think Adriano makes a very good point but still I wanted to provide some feedback: I think you should separate piece of functionality in different classes. You could abstract the handling of transactions and connections away in e.g 

As you are querying for a userID, which I assume, is unique in the users table, SingleOrDefault states that there can be only one user what the queried userID. When using FirstOrDefault you basically saying that there could be more users with the same userID, and if so then just randomly (because you are not ordering) return one. About Automapper, I agree with TopinFrassi that mapping a list feels it be odd because it's not re-usable. If you create a mapping between your entity and the CustomBehaviour class, you could do something like: