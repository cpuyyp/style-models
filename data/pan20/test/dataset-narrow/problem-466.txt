Though this program tells the truth (unless you change the source code), it does tell Fibonacci numbers, depending on the user's input. Keeping in mind of all (or most) of the feedback given from previous questions, I wrote this program to see how well I have progressed. 

It's really just performance. There's gotta be a better way to do this, but I can't think of a single way. 

This is because quicksort is \$O(n \log n)\$ while bubble sort is \$O(n^2)\$. How I would do quicksort: 

Don't reinvent the wheel, unless you were required to. Java has a method that you can use easily, e.g.: 

It is often bad practice to catch every single exception in one catch block, especially if the exceptions can be predicted. In this case, we have and . First, we can identify where and why these exceptions can be thrown, and if they can be prevented. The can be thrown on the first line of your block because can be . You can prevent this by doing: 

What??? confuses me. Might want to do some naming changes. I would simply remove in and use instead: 

I think I can separate Python from Java anc C++ now, so the is no longer there. But just in case, is there a stray ? Is the way this class is constructed Pythonic? Are the docstrings good? 

To prevent inheritance: Easily fixed with the keyword. To prevent other parts of code to instantiate your class: It doesn't really matter, does it? You have no code that is not in the class, so instantiation does not matter. 

The tests should be easy to maintain and understand. That is the tool that drives development. Sometimes it may contradict with the widely known rules you mentioned, but it does not mean we should be fanatic about that (as soon as the tests drive the development and work as the safety net). 

Rule 1. When I add the same identifier twice, does it may sense to throw an exception saying that the cannot be added? Is there any harm in 'doing nothing' here? Rule 2. Trying to add a list id to the included lists throws an error if it's already belongs to the excluded. Does it make sense to introduce some helping methods like or ? Does it make sense to throw an if an empty is provided? 

That's totally fine and even more - introducing 'common' initialization logic increases coupling of your unit tests. Imagine you need to add a new 'common' line to setup things common for a few tests. You never know for sure if there are any other tests impacted; you may make your tests false positive. It's more safe to modify your test 1 by 1 as necessary. Tests like have about 6-7 arrange lines and 2 assertions. IMO, it is easier to read, understand and (!) maintain this single test than splitting it into two (or more) just because of the 'one assertion per test' rule. That looks like Facade tests. That might be fine to have them at some level, but it's important to understand that tests like that may be a bit more hard to maintain since there are more parts that might be broken during refactoring. Don't have any oppinion on that... Looks fine to me. 

Here, I suggest you do instead of . It is a matter of preference, but I think is easier to understand. 

Well, read on! Immutable classes should not have any methods. This is because an immutable class should only represent objects that don't change. If a person needs to be changed (not likely though), then the most obvious way to do so is to directly call the Constructor for a new Object, as a person with a different characteristic would not be the same person. 

How many warnings do you have? ANY of them means bad code. In this case, some of your variables are unused. Remove them. 

I don't think creating a object is necessary. Instead, there is a method that returns a object, which stores all the necessary solution information. is now the overrided in . It seems slightly faster (2000 miliseconds -> 1500 miliseconds) 

Now, why is the first line not necessary, and even discouraged? Well, because you should declare variable right where you need them, and not before: 

This looks confusing to me. return the title, which is understandable, but returns the old title and sets the title to the argument. What? I would rename the first methods to and the other to . Also, consider adding . This is the same with: 

In , all I see is a mess of code. What I want to see, or what I should see, is a properly formatted code: 

I've seen some pretty nasty Fortran in my time: Research departments seem to be the worse source! Your code is far, far superior to their code! In those days we were using an extended form of Fortran 77 with some structured extensions and formatting niceties. There was no avoiding GOTOs and FORMATs and their labels. I tried to keep them to a minimum and to only use them for break/cycle types of jumps like you are doing. So although I lack modern Fortran experience, you look to be on the right track. 

I would agree with Mark: I'd make the members private, and then add property accessors to them. You can then control access if you need to now or in the future. For example, you might want to make one of the members read-only. Easy to do: implement the get() property but not the set() property. Similarly, data range checking can easily be added to the set(). 

Yes I think that is going to be pretty quick. It might be tempting to move the cos calc so that it does a full Pythagoras with the radius. This will save an assignment, but I thi it requires an additional multiplication (1*1 being known already in your current version). As a matter of personal style (possible because I code in multiple languages) but I would use different names for your sin and cos variables. most languages would not accept this, and it would, personally, have the potential to confuse me. 

At first glance, this makes no sense. These numbers are more like magic numbers: make them a constant: 

Your indentation is quite messy. Indentation is usually 4 spaces in Java, so use 4 spaces. Including some other minor readability improvements (such as each line is a maximum of 80 characters), your code will look like: 

Just for practice in the mathematical side of programming, I decided to rewrite the math functions, with the addition of the function, which the Math library does not provide, but can be easily done with where you want to find out to the th root. I also wrote this to review the Newton's Method, which works like this: Given an approximate \$x\$-intercept \$x_n\$, a better estimate \$x_{n+1}\$ is calculated with the following: $$x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}$$ Where \$f(x)\$ is the function to find the \$x\$-intercept, and \$f'(x)\$ is the derivative. 

I was recently given a Sudoku Puzzle to solve, and since I began solving many Sudoku puzzles after, I decided to attempt to create a Sudoku Puzzle viewer with JavaFX. I am not done yet, but have decided to split it into parts so that it is easier to fix future problems. Part 1 is the class. The class does: 

For practice in Python OOP (first time) and for some relaxation from trying to learn Serialization in Java, I decided to write a LinkedList in Python. Now, this class would be pretty useless, because in Python, instead of: (Java) 

I need to define an entity () that contains and manages two collections of identifiers ( and ) that are ids of some other entities (). The business rules are the following: 1. The collections must contain only unique identifiers. 2. The same identifier cannot belong to both and . 3. Identifiers can be added or removed (performing the checks above). Note: Adding an identifier to the is not opposite to removing it from the . For instance, there is a list A that contains included lists B and C and excluded list D. That means that . An attempt to add list C to the leads to an error while C is in the . If the list C is removed from the , the list A will be the following: . I introduced two properties to get the collections and four methods to manage them. There are few areas I'd like to hear some feedback about. Which variant is better? Property naming 

Also, you have to create an instance of the wrapper in the production code, haven't you? So, what is the purpose of the static class then? Static classes are inconvenient for unit testing. Instead of introducing wrappers that mimics the original class, you can simply get rid of statics at all and go with simple 'injectable' abstraction and implementation: 

Does it make sense in declaring 'Add' methods as and 'Remove' methods returning ? (similar to .NET collections). Does it make sense in adding other collection-specific methods like or ? 

Similar to , but and result in , and every other combination . What is happening is that the ASCII values are 'd and 'd. Is this really what you want? In this case, you have to do it the tedious way: test each of them to : 

This is the end brace of the previous method plus the new method. Again, a couple of things: Lines 1-2: Extra newline between Line 2: Should be separated into two lines: and declaration Line 2: Space before brace Line 3: Already mentioned, space before brace Line 6: Extra newline serves no purpose, but can be left there if wanted Result: 

Is the method, constants, and return values and good practice? I couldn't find a way around this. Which constants should be , and which ? Naming? Anything else? 

I wouldn't create a new temporary map for each loop. Instead, I would create one outside the loop, and dump the contents of the temporary map into the map at the end: 

Though, as mentioned in the Bugs section, it doesn't really work. In Hmm... Here you don't do ... Also, here: 

Your solution seems to be the most efficient, except for the fact that it doesn't seem to work. You could try finding all possible groups like so: $$18=4^2+1^2+1^2$$ $$18=3^2+3^2$$ $$18=3^2+2^2+2^2+1^2$$ $$...$$ Then find the smallest group. Your code would sure like some space. After some nice, wide spacing: 

This code writes to Excel using the COM interface. The general issue is that any exception handling has to handle the "Excel is busy" exception. This occurs if information is sent to Excel quicker than it can handle it - eg. latency when a workbook is loaded/created, or the user is playing with the scrollbars (there are good reasons for letting this happen). This is probably the only example I know of which is simpler and cleaner in VB6 than in C#! In VB6 an ON ERROR would be used. The error handler would then create an error for most cases. But if the error code is a "busy" then it will sleep a short period of time (typically half a second) and then try again with a "RESUME". Don't get me wrong, ON ERROR is generally messier than C#'s try...catch and it is easier to produce awful code; however, this is one example where the VB6 ON ERROR works better. A long sequence of Excel calls can be trapped with one handler. The "RESUME" will then send control back to the line where the 'busy' occurred - this avoids duplicate calls or skipped calls. The solution I have in C# is to create a while loop with a flag. The flag indicates a repeat of the loop is required due to a 'busy' return from Excel. See the code below. Is there a simpler, more elegant way of doing this? The main problem is that this requires a method for each type of Excel call. To avoid too many duplicate Excel calls in the busy scenario, the contents of each method is atomic or close to atomic - eg. "write this formatted value"; "apply this formatting to this row". This results in lots of methods. And/or methods with lots of parameters (the example below is a short one with just one format option, but there could be more - colors, decimal points, etc).