The easiest way to have something run at boot is via . Some systemd based distros (e.g., Arch and Fedora) have stopped including this, although it is easy to implement. Which doesn't matter in this case since currently Raspbian does still have that file. It probably contains something about printing the IP address to console, but don't worry if you've never noticed this happen, neither have I, and you can remove that stuff if you want. What must be there is at the beginning, and the end: 

Not that simply. The Arduino C++ API is unique and as far as I am aware it is only ported to other similar microcontroller devices. The Pi has a normal CPU on which a normal, multi-tasking OS kernel is usually run. If most of your C++ programming experience is on the Arduino, I believe the wiringPi C API is functionally similar (in many ways the restricted Arduino C++ library is more like C than it is contemporary standard, STL powered C++) and may feel familiar (this is a hunch though, since I haven't used it). However, if you understand the library code you are using, it may be a good reference point for using the same sensors on the pi. While you would have to re-write them, likely many significant chunks can be cut n' pasted, etc. 

I'm not a Win IoT user, but I can't possibly see how this would damage anything (of course this may depend what the pin is attached to). That it will work sufficiently well is another matter. I've fooled around dimming LEDs this way and it works for that but not nearly as well as using the PWM clock (they flicker intermittently, and that it is at much less than 40 KHz). I don't know if windows allows for direct mapping of kernel/system memory. If so and you understand C and POSIX , you could start here then look at one of the linux library sources. Sooner or latter someone will get around to a proper solution. 

That post explicitly refers to firmware, so no, it is not the OS. You may still be able to configure it using the setting mentioned there (this would be in ). Although it is not clear that you could raise it beyond 85 C, you can at least test it by lowering it via . 

These two steps correspond to the distinction between a block device partition and a filesytem. The former contains the latter. Physical storage devices, as I am sure you are aware, can be "partitioned" into a number of discrete segments. Each one of these is referred to as a partition. Most often to be made useful a partition is then formatted to contain a specific kind of filesystem, but a filesystem and a partition are not synonymous and the distinction is very clearly defined although it may often be ambiguous to many users. In any case, the point in step one about deleting the partition really just means just deleting the entry in the device's partition table. This does not affect any data in the filesystem on that partition. The idea is to then re-create the partition entry and make it bigger. This is necessary before you can make the filesystem inside it bigger. It is kind of a hands on method but remember -- the pi is all about learning. However There is a very important caveat here that the ubuntu mate crew neglect to mention, namely, when you re-create the new partition, it absolutely must have the same starting sector as the one you just deleted, or you may end up destroying or losing the filesystem inside. There is the assumption on that page that using the defaults will handle this. I cannot say one way or another WRT the ubuntu mate image (it is possible this is true), but I can tell you for certain this is NOT true using a Raspbian image, i.e., if you followed those directions, you would be making a mistake. Perhaps they ran out of space after what was required at the top for all their "Please send me money, I created an SD card image" stuff (excuse my sarcasm and do not let that stop you from donating, I am sure they mostly do a good job). The pi may be all about learning but beware that does not always mean it is always about teaching, so sometimes "learning" might mean "the hard way". 

Notice on the near side the five connections in a box. These correspond to pins on the other side. They're labelled: 

The GUI login is (the is for display manager). This is started as an init service, and the init system on Jessie is systemd. I believe the name of the service is also "lightdm". You can confirm that: 

They should, yes. Glibc has a pretty high degree of backward ABI (application binary interface) compatibility. Other libraries may not have that, but if there is any trouble you can always install an older version alongside the new one -- possibly ripping it precompiled from a jessie package. 

Download an file. The ones on the download page are zipped, or gzipped, or tarred, or whatever. Find an appropriate way to un-zip/gzip/tar/whatever it so you have -- it's just one file, probably 2-4 GB in size. Insert your SD card. Do NOT bother formatting it with anything. If it is already formatted, you'll likely notice in addition to the device node -- e.g., -- there will be at least one partition, . In any case, it doesn't matter; I mention this because you want to copy onto the device, not a partition, so you need to recognize the difference. The device's node does not have a number at the end; , not . If there is no , don't worry. If you've never used linux before, it won't necessarily be , so figuring this out is probably the hardest part (leave a comment and I can explain further -- DO NOT guess and accidently trash your hard drive, lol). All you need is the device node. Then: 

I would do the test with no SD card and see which way it responds -- solid green or no green. It is probably the former, and the latter may be a kernel hang happening before it can access anything on the second (root filesystem) partition. Note that the "lite" and normal images are identical with regard to the aspects just described. Put another way, it is not a matter of both of them being correctly installed but encountering different problems. It is a matter of one of them being installed completely wrong, such that the card might as well be blank. You did not describe how you put the images on the cards. This should not be a difficult process, but it does seem to snare some people at first, particularly if they have used a MS Windows based methodology. Finally, there there are kinds of cards that just don't work, although I think an 8GB Sandisk should be fine. If both the cards are identical, try a different one (anything you can fit an image on). If you have the same problems, it is very unlikely to be the kind of card. Which ever scenario does not match the "no card" one (again, probably this is the no green light one), you need to plug the pi into an HDMI TV or monitor to see what happens. If you have a friend, relative, TV at work/school/anywhere you can access for two minutes this is simple. 

First, check that the you are editing is actually the on the first partition of the SD card. Although it is not technically necessary, Raspbian is set up to mount this partition on automatically, so online tutorials will refer to it that way -- and , used in the Adafruit guide, presumes this is the case. However, if the file doesn't exist it will be created, and if Kali doesn't use the scheme Raspbian does (comments here imply that), this means it will just create a file in the otherwise empty directory, which won't actually be used when the system boots. The Pi makes use of a vfat formatted partition at the beginning of the SD card, where firmware and bootloader must be located (and generally also the kernel). You can set things up the same way by adding the following line to : 

No, because the pin schema is not set system wide. It is set essentially per process; when you initialize a GPIO library, you may have the alternative to specify a scheme that will be used in the code (strictly then it isn't even really per process; it's just an artifact of compilation). Different command line tools may also allow for different schemes, but this is not because the scheme is set anywhere other than in the tool itself. 

You did not say which image/distribution you are using, tho it appears to be some kind of debian linux (perhaps raspbian?). Generally linux distro packages have a separate associated "development" package which contains the bits you need when compiling with them, since these are not required for normal use. For debian they are labelled with "-dev", eg: 

So, there is no shortage of packet sniffing tools. Wireshark is also available. Wireshark itself is a GUI but includes a CLI tool, . The wireshark tools in particular are very well documented. 

Which means you can quickly and easily update it later, or you can actually "Download ZIP". You can also download individual bits and pieces from inside the directory if you want. 

1. Note there are only two channels in total for the PWM clock, so if you use more than two pins with that clock, they will be doing the same thing (presuming that's possible, I have not tried). There's a chart here of the various GPIO pin functions; the relevant ones here are the cyan "PWM0" and "PWM1"; columns in the chart correspond to "ALT" function slots for each pin. You need a special library (pigpio, wiringPi, or libbcm2835) to set these and the documentation for such should have an explanation of setting the ALT functions and how to manipulate the PWM clock. 

I have not measured it myself, but this person claims the pi draws about 110 mA after shutdown, i.e., when the OS has halted and just the red PWR led glows. Figures regarding the number of amp-hours in a car battery seem to vary quite widely; if we assume 50, then that's 50 / .11 ~= 454.5 hours such a battery should last with an inoperative pi attached. Of course, if you want to use the battery to start your car, you probably don't to go even half that far (also, draining a lead acid battery excessively shortens its lifespan). The important part here is that the OS be shutdown. Otherwise, even when idle the pi draws at least 300 mA. There are people who sell power off switches for the pi; these use a GPIO pin to signal the system to shutdown, wait for confirmation, then cut the power. Note this also requires a bit of software. If you search online you'll find such switches (they are built specifically for the pi) for ~$15-20.