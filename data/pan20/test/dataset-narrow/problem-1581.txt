Looking for something that is grounded, metal case of an electronics device is usually grounded. Be careful if you are on carpet or any other surface that builds up static. Also, you should try to avoid touching the actual components even after doing this. grab the board by the edges. 

The main issue is that your calling main() from within the interupt handlers, this means they never fully finish. And usually global interupts are disabled while an interupt is being handled. Since it never finishes, interupts are never re-enabled. You only need to set the global variable x and get out of the handler. Then be looking for that change in main() I do not have your setup, so I cannot test this, and make sure I have the indentions right (what should change for each value of x) but this is closer to what you want 

No there is no need to stop the camera before reboot. Also preforming is not doing you any good as the reboot is going to force the program to close anyway. If you are worried about your program needing to shutdown gracefully, you should notify the program to shutdown rather then kill it. A simple way would be to use touch in your crontab like so: 

Or with bash Bash scripts only require a header line and then can be a list of the same commands you type in the terminal. There are many other things you can do as far as handling errors, output, etc... but to get you started Create a file myscript.sh (doesnt matter the name) add these two lines 

If you setup wifi in wpa_supplicant with default entries it will only connect to the specified . If there are different networks with the same you can restrict access only to the mac address of the network with : 

This is the prefered up to date method. You should now find the file . For most of us this should work. @w00dw0rm has tried 3 things but only flashing a new image helps. I would not advise you to use because rpi-update is unstable and may result into an unstable installation, but it's your decision. I have tested it with a fresh flashed in a with running wifi. A full-upgrade do: 

Of course this will not fit your specifc needs. You may need to start other services and start your script before or after them. This can be defined in section . There are many examples out there on google. Please have a look at them. You may look here for starting after "network-up". 

But if you have enough space on your SD Card it could be a good idea to leave the installation on /dev/mmcblk0p2 untouched. Sometimes after an update on the working installation on /dev/mmcblk0p3 I forgot to to also update the , so boot fails. Rebooting into rescue partition on /dev/mmcblk0p2 and recreating helps. Update the installation. 

Ok, i figured it out, figured I would post the answer. pythons keyboard module, docs and source here as stated in the "Known Limitations" section, (even though I don't think this is a limitation!) "To avoid depending on X, the Linux parts reads raw device files (/dev/input/input*) but this requires root." So this does bring up security issues obviously since the program now needs root privileges, but for my case this is not an issue. 

As you can see from the comparison below, the main differences you need to worry about is the ram, and the number of cores. Depending on the data you are trying to scrape, you don't need a browser. The curl command can return text data from a web site. Time is really going to be the big issue. If the process normally takes lets say one minute on your pi3 it may take a lot longer on your zero. But if its only running once a day and it now takes even 10 minutes, this wont be an issue. The zero is also only a single core(vs 4 on the pi3) This makes running programs that are multi threaded (like browsers) not work very well or are very slow. Unless you add an ethernet port to the zero you will be using wireless which will also make your data collection slower. 

To fix this problem I tried to use the as root parameter in but Raspbian does not boot with this. Is there any other usable partition identifier for the root parameter in than ? 

You mount your SD Card on different computer. All what you describe is as expected. It depends on how the SD Card is connected to the computer [1]. On your Ubuntu it is connected with an USB card reader. With this it enumerates device names just as they are connected beginning with , e.g. for your mounted hard disk, for your CD drive and for your SD Card because it was connected at last. On your raspberry pi it is connected into its slot. For this there is used a special device naming . For details look at the reference. 

Take snapshots and backups Login. Now we should take our first snapshot from this base installation so we can always revert to it: 

bootstraped stretch linux from scratch wheezy for RPi3 jessie lite jessie lite jessie lite jessie lite jessie jessie Problem with avahi-daemon At next I looked what network services are running but I don't need. This are and . By disabling these, I found some interesting results. To minimize side effects I switched over to a bootstraped installation. With this I found 100 % reproducible: no avahi-daemon (default from bootstrap), no gmediarender, ipv6 disabled Ping-test with result what I call 

I think MUCH larger difference will be in how much power the display uses based on its size and type rather then the control signals you are feeding it with. An 20 inch LCD monitor over HDMI is going to draw way more power then a small SPI screen. And if you are working with the same size/type of screen. I still think the large draw for the screen will make the small difference in power consumption between the two types of communication. 

You are already using a USB port! The desktop kit has a mSata Connection that connects to the USB port of the pi. It comes with a little dongle that connects the mini usb port of the mSata adapter to the full size usb port of the pi. You are asking to accomplish this Rpi(USB)--->mSATA--->(USB Drive) Which there is no need. You can boot directly from a USB drive If you need more usb ports you can use a hub 

Depending on what the device is, and how much you know about whats going on inside it, I would use some sort of isolation, the easiest way to do it would probably be using a photocell (which measures visible light). You would just need to shield the sensor and LED so that ONLY the LED is going to trigger the sensor, not you turning on/ off lights in the room Here is a thread from the arduino site that talks about using a photocell as a digital input. Remember the pi has 3.3V logic on the GPIO 

Is this a feature? How can I get the raspberry packages into this raspberry? UPDATE: Maybe you have to add the key from $URL$ to the apt keyring. For me it has no effect. 

This isn't specific to Raspberry Pi. Anyway, I'm not sure if I understand what you mean. The items etc. are not simply labels on a table. They are properties of the routing mechanism. And what routing table do you mean? Mine has no labels: 

You want to run a script/program at startup without login. This is usually done with a service and managed by . This isn't really a raspi specific question but here is a very short snipped to give an idea. Create a new service for : 

I have the same entry in than you and made a small test script that reads all 5 sec. from the usb drive and log it to the journal. Don't use threading/multiprocessing because already works parallel. Threading/multiprocessing within multiprocessing may be confusing. 

I've just downloaded the "archive" and got the same error like you. Inspecting the file I found it isn't an archive not at all. It is a clear text file containing a html web page. Rename it and you should be able to open it in a web browser (I haven't done that ;-). 

You can use a serial console with an . Costs about 10 EUR. This has the advantage that it works even without network connection. With network running on the raspi you can use to connect. For both solutions there are many suggestions here. Google and/or search for it. 

Also I am assuming when you write "m" to the arduino that is telling it to send the measurements? You go directly from the write to the read with no delay, this may also cause some issues as it does not give the arduino time to process your request. It may only mean that your readings will be delayed by one cycle, or could cause other problems 

Now obviously this is a very insecure way to do it, as anyone could create this file to kill your program, but I am guessing this is just for hobby use and there will be no issue there. 

The & will cause the program to be launched in the background, allowing the next line to be executed before the first one finishes. This will allow all 4 to be launched at the same time. The output of each will go to the same file named 'logfile' this could be changed to each output to their own file. 

You can take a look at this $URL$ But looks like you need multiple cameras which only the compute module has. if you could use two zero's each with a camera, and trigger at the same time it might work. 

This style of trace is usually used for impedance matching or timing. Impedance Matching, because how the traces interact with each other and other components, changing the way the traces make corners and where they are located can change the impedance Timing: at 1.2Ghz and moving at the speed of light( in a vacuum) a clock pulse only makes it about 10 inches before the next clock pulse leaves the source. This means that if you have multiple components that need to be in sync, it can be beneficial to 'delay' a signal by making it go further so that it matches the timing of another device I did not design this board, so I dont know what the specific reason is here, but those are some options 

There is no way to do what you want. Either you set static ip addresses. Then you are responsible that there are no duplicate ip addresses on your network which will confuse communication. That's by definition. Or you let it do appropriate software like a or . Of course you can mix it up but with static ip addresses you are always responsible that it isn't double and not given by software. So I suggest let only software do its work and everything is good. 

And you should get responses out from the internet, e.g. from the google nameserver. First try from the raspi then from the phone: 

references: [1] Run script to setup Socks Proxy on Pi Startup [2] Running a script after an internet connection is established [3] Python script run from crontab does not recognize USB drive mounted later [4] No access to USB port, when running python script on boot [5] Python script does not run when called by service 

From your mobile phone you can ping the raspi. This should always work. If not you have a general problem with your wifi, e.g. wrong ssid, wrong password, low signal or something else. 

Raspian is distributed with disk-images containing all the same Disk identifer, so we spread the same identifer for different storages all over the world. Doesn't matter? No, we get problems as reported here. Disk management tools like or correct this silently to a unique Disk identifier when used. But then Raspbian fails to boot because it has it's old and now wrong numerated Disk identifer in it's root parameter. In the opposite it seems that the UUID of a partition never changes as long as the partition exists, even with duplicates on different disks. It's unique on the disk. 

The solution comes down to a couple of issues. All of them are related to the fact that when google home starts the python program it does not do so from within the programs directory, so any local files that do not have full path names are not found in google homes working directory. python's import will look at its installed packages, and also at the current working directory(and others possibly) imutils needed to be installed "globally" rather then just living in the program folder 

then it does not matter if the connection comes up right away or not, your code will wait till it does, then execute the main body of the code 

Working on a project that uses a little keyboard and an E-ink display. I have tried a couple of keyboard packages for python (pynput, pyxhook) and have written/tested simple keystroke loggers that work fine on my desktop (ubuntu) However I try to run them on the pi both libraries die 

Is there any way to get these to work, or possibly a different way of a approaching this. EDIT: full stack trace of above program failing 

This is much more of an electrical engineering question then a pi question. But you don't need to be using a Darlington pair transistor. You are just switching a small load, which means you are using the transistor in saturation, unlike an amplifier which is what the Darlington pair is normally used for. 1k should be fine for the base resistor, and the circuit is right (make sure the grounds are the same as in the comments) but I would switch out the transistor for a different one Look here Also take a look at the voltage drop between collector and emitter for whatever transistor you use, because you are only working with 3.3V, if it has a drop of 0.7V the camera is probably not going to be happy. I stole this explanation from here: Back on Darlington voltages - Darlington transistors do not work well in saturation. When the primary current carrying transistor is saturated, the collector voltage of the input transistor is lower than its emitter, and it no longer provides the desirable gain. In that mode, the input transistor is not much more than a diode in series with the base of the second transistor. That is one of the reasons why it is so hard to get a Darlington into genuine saturation. The current gain of the input transistor helps, nicely, until the collector voltage gets down to about 1V, give or take a little. Then, it turns into mush. Yes, in your post just preceding. That is because of the Darlington pair, for the reason I just described. I would not describe it, however, as "taking voltage away from the device I was switching". Instead, I would say that the (effective) on-resistance simply is not very low. It does, however, provide less voltage drop across the load. Jim 

From your end-point you should be able to ping your raspi on this side. This should always work. If not you have a general problem with your connection e.g. a broken ethernet wire, loose plugged in ethernet cable into port, wrong drivers for your interfaces or something else. 

As @Milliways commented here is where the power of comes to play. There is no need to wait that sequential processed commands are finished. is working parallel (that is what it makes a bit unfamiliar). It can start services after other services are started. Because this "network-up thing" is a very common problem, we have a nice service for it named . Now it is very simple to start after . Let's do it with as template. You can replace it with . I use Raspbian Lite from . Create and test it: 

This is a typical failover scenario and this is handled by bonding. You can find information at Debian - bonding. Here for example I have made a tested configuration with Raspbian on a Raspberry Pi 3 that will bond and and switch transparent between this two interfaces. Who are interested for doing this with can look at Howto migrate from networking to systemd-networkd with dynamic failover. For the old style networking you have to configure but I couldn't get it together with dhcpcd. It's too complicated with network/interfaces and dhcpcd and wpa-supplicant and resolvconf and bonding. So for this example I disabled dhcpcd and use an old style networking configuration. First install needed packages: