The second CTE adds two more columns to the above result. It uses window aggregate functions and to match against , and where the match takes place, the corresponding is returned in a separate column, either or : 

Basically, you start with joining and to get all the event occurrences the members could have attended based on their membership dates. Then you throw in the table (via a left join) to flag the missed occurrences. Here's an example of what you get by this time: 

You could use your first query as a derived table and join it to using the predicate in the joining condition: 

The main SELECT essentially just takes the last row of each group using the filter, pulling only and and also renaming the latter to , so that the final output becomes what you want: 

Another option would be to take all the values and subtract (using EXCEPT) those that have a non-NULL : 

The above produces a row set containing employee IDs and corresponding row numbers. Store the resulting set as a temporary mapping table and do the same for the PINs table, unless its column already is a row number column. Based on your comment to Thronk's answer that the PINs table is imported from Excel, I am going to assume that the values in have indeed been generated in Excel as row numbers essentially. So, after you save the mapping set like this: 

If this is for SQL Server 2012 or later version, you could use the LAG analytic function to produce the required result: 

At this point you could use a to get each conversation's last date_created. Once you have obtained it, you can get just the row corresponding to that date. Here is the full query: 

You can use the above pattern to calculate separately the target data and the actual data and join them as derived tables to similarly to the first solution: 

This way the CASE expression simply returns either one column or the other, and the result is compared to the specified value. If each column is supposed to be matched against its own value, the solution will be different. You do not need a CASE expression at all. Instead, you need two pairs of conditions OR-ed together: 

The method would also work in any other DBMS that supports window functions and updatable CTEs, but you would need to tweak the script a little. In particular, you would need to change the aliasing style for from to and probably rewrite this predicate: 

In the derived table you are correctly grouping by but retrieving instead. That is a mistake because when there is no match, it is null. And it is because one value is returned as null that the outer query omits the corresponding empty group. Replacing with fixes the issue. 

will yield . The function will ignore the two trailing spaces and return 5. Subtracting 4 from 5 gives you 1, thus will return just one rightmost character of the string, which is a space. As I said, though, if can never have trailing spaces, either option will do. For completeness, let me suggest one more, which uses the function: 

That would effectively be your . In order to return both counts at once, you just remove the NULL check from the where clause and use in like this: 

You are quoting from the wrong section of the manual. That passage is from the Table-level Locks section. The lock type you are interested in is specified to be . That means you need to refer to the manual's Row-level Locks section in order to find out when that kind of lock is acquired. And in the beginning of Row-level Locks it says (original emphasis preserved): 

The derived table returns only the departments with a single semester. Basically, it is the original table without the departments having more than one semester. Once you have that data set, it only remains for you to join it to the table to get the final output. One could, of course, further simplify the above query like this: 

As you can see, this method allows you to include the actual message in the results as well. Alternatively, you could replace the with a (and filter on the row number, of course): 

Given that this is the only difference, it is possible to calculate both results using just one such subquery. You just need to move that extra condition inside the second , like this: 

Here is another method, which is similar to Evan's and Erwin's in that it uses LAG to determine islands. It differs from those solutions in that it uses only one level of nesting, no grouping, and considerably more window functions: 

For every row where is null, you are returning an empty string as . So without DISTINCT all such entries would be returned as 

Your query also has a filter on an attribute that in this case is an aggregated column. Such filters would need to be implemented in the HAVING clause. For your example, the filter on age would look like this: 

What you are trying to do can be resolved using two operations: an unpivot followed by a pivot. The table that is most principal to the query you are looking for, , is document-centric. It stores data in this form: 

I started with an attempt at fixing Max Vernon's answer so that it would work for any year, but ended up with two different approaches. Approach 1. Being clever In this method I am calculating the Sunday-based week number directly from the offset from the year's first Sunday-based week's Sunday. A year's first Sunday-based week's Sunday can be obtained like this: 

from your query and have your CASE expression reference the source columns rather than their aliases: 

Another way would be to arrange the arguments and their respective sorting values as a (derived) table, join that table and use the sorting column in ORDER BY: 

Update Starting from SQL Server 2012, you can also use the FIRST_VALUE and LAST_VALUE functions and substitute them for the CASE expressions in the CTE in my last query above, like this: 

Rewriting these will require more than just and outer join in order to preserve the same output format. First of all, this join 

Note that the argument in the last statement is not the rule itself but the type to which the rule is bound. 

I would start with the list of available drivers. As you appear to want them as a CSV string, it makes sense to use grouping and concatenate the names with GROUP_CONCAT(). Use an outer join of jobs to the cross-product of dates and drivers, then, to get the available drivers for each day, group-concatenate the driver name only if it has no matching job: 

Among the SET statements in your script, SET QUOTED_IDENTIFIER is special in that it is processed at parse time rather than at execute time. From SET Statements (Transact-SQL) (emphasis mine): 

I am assuming that the ID column is either the PK or otherwise declared as unique in all three tables. Now, if each of these scenarios is equally possible: 

The left join method is known to work fast in MySQL but you should test for yourself in your environment to choose what works better for you. 

But the results will be for buckets while you want the counts for periods starting from now. The final step, therefore, should be getting the running total of the counts in the ascending order of , like this: 

Both would work equally well and result in all nulls replaced with corresponding values, i.e. from this: 

all have the same pattern: they all use to determine whether to display or . Depending on the DB engine you are using, that may be inefficient. It might be a better idea to use EXISTS instead. So, you could rewrite the above like this: 

At this point, you could use window aggregate functions and to check if a file has more than one version: if the results of the two functions match, then there's just one version, otherwise there are two or more: 

Depending on what you are trying to achieve with this, you may be out of luck. First of all, names cannot be parametrised in MySQL otherwise than using a prepared statement. – So, can we use a prepared statement here? No. Prepared statements are not allowed in triggers, according to the manual: 

As Aaron has explained, needs to be checked after each . There is no avoiding that, but as for using a transaction, you could replace it with a different approach, if you are open to suggestions on that. You could manipulate the SET NOEXEC setting to achieve the same result you are using a transaction for: either both procedures altered or both left unchanged. This is how: 

The function returns four columns – the effective permissions for the specified page and user. Usage example: 

In MySQL, variables can be used in queries both to be calculated from values in columns and to be used in expression for new, calculated columns. In this case, using a variable results in an efficient query: 

The rows are sorted in such a way that identical rows are arranged in groups, the last row being the first row in each group. Each row is then assigned a ranking value with the help of variables. Variables and hold the previous row's values of and and take part in calculating the value: if the current row's and match the previous row's values, the value is increased by 1, otherwise it is set to 1. Thus, the first row in each group always gets the value of 1, because the previous row belongs to a different group or, in the case of the very first group, is simply non-existent ( and in that case each hold the initial value, an empty string). The results are used as a derived table and are filtered on the ranking value: only the rows with the ranking value of 1 are returned (they hold the last value in each group). 

*This particular implementation of the grouping method assumes there is always one row per attribute per person, so works correctly. If attributes of the same kind may, or will later be allowed to, repeat per person, use instead. 

You cannot make a check condition a part of the type definition syntactically, but you can create a rule: 

First you need to relate the first empty PIN in with the first PIN in , the second empty PIN with the second available PIN and so on. Then you will be able to use an update with a join and populate the rows thus related. One way is to assign row numbers to both sets and use the row numbers as the joining criterion. As MySQL does not support the standard SQL analytical function, you have to do without it. One alternative is to assign the row numbers with the help of a variable, like this: 

The MAX function works in this situation because it returns the maximum value only across the non-null values in the specified set. In your case, there would be only one non-null value per partition of in each of the three cases, so the function would return that one value. This would be the result of the query for the example in your question: 

Changing the dates to month names would, in my view, constitute a presentation issue but, if necessary, MySQL offers built-in functions like to do the transformation directly in SQL. Additional information can be found in the MySQL manual: 

The expression calculates a running total for each row. So, the total increases with each row (sorted in the ascending order of ) – thus with each row an ever increasing amount is subtracted from , drawing nearer to 0. The above query will give you each row's balance but not the status. To get the status, you will need to reference the value to compare it 0 and select a corresponding status string to return. is a calculated column and in order to be able to reference it you need to nest the above query and reference at the outer level. Nesting could be done with either a derived table or a common table expression (CTE). This query uses a CTE: 

The main query takes the output of and joins the original dataset to it twice: first time to get rows with the IDs in each range (more specifically, with the IDs that are greater than and less than or equal to ) and second time to get the rows only. (The second join is an outer one to prevent filtering out the 0..1 range.) This way each row is joined with all the other rows in the same range, so you can calculate the difference between the starting row's and that of each of the others. For the initial range, the difference naturally ends up NULL, because the of 0 does not exist and the corresponding in the joined row set is null. Because the ranges are adjacent and cover the entire table, the differences are obtained for all the rows.