My best guess is that Smartcard Reader is not initiated and known by the system when your service is started. To wait for the device management to be completed, you can simply add or service (don't know the exact one) to your service's line as follow. 

If you are on a ssh terminal (not the console), start your ssh with -X or -Y argument (i.e. ) and do not forget to execute command mentioned above before your command. It is required that X server is running on your local. If you are on the console, try to start without as suggested at Start JACK without X. You may need to install in addition. Before your command, execute: 

Amendment #1 - Start The highest version in Ubuntu Mate repo is as the question owner says below. Build having version equal or higher than as described at Qt for Linux/X11 - Build from Source. Be sure that you have enough space to compile Qt from source. Here is the link to source of Qt 5.7. Amendment #1 - End Set installation path to whatever you want. The default prefix is /usr. Detailed explanations about this configuration and about many others can be found in . 

A workaround would be to attach a wifi dongle to the pi and use that to SSH into it from your local network, in case the public rout is blocked. NOTE: It would be wise to secure this with more then just a password since it's public and anyone could log in to this machine More reading material on ssh and configuring it can be found here. update you might need to comment out this line in the config file. 

Make sure you are using the correct image (pi2 not pi B). Also check if your power supply is up to the task. A lot of trouble can be traced back to low power beeing deliverd to your Pi (also due to USB extention cables etc) 

If a GUI is out of the question (since your question states "from the terminal"), have a look at curl However google isn't super friendly to curl. So you might want to have a look here to have a more readable result. 

The message Unable to autolaunch a dbus-daemon without a $DISPLAY for X11 in the first verbose log means that your DISPLAY variable is not set properly. Before your command, to set it properly just execute: 

It is not the proper and right way to overcome your problem but you can give it a chance. Use to copy template img file to your sd card. It should fail for the last bytes if the sd card is smaller than the image file. But if you are lucky, that sd card will make your pi boot up. 

According to comments under the question (shame on us, it was evolved to a chat room), you should look for a solution of the problem having title Bridging Lan and WLan on Windows 10. The problem is not raspberry pi related. 

Create you omx looping script. (Keep it simple keep it easy. No need for omxd etc. =) The script will be and its content will be: 

Try the options menu to find something that could be CEC and enable it Verify if you have the CEC packages installed on the Pi Verify if it's enabled in Kodi (optional) forget CEC and download a remote like Yatse or Kore for android (apple appstore has a few unofficial Kodi remotes aswell) 

I think you have pretty much done the troubleshooting yourself, the problem is most likely in the cable. It could be a really low quality one, since moving from 1A to 2A doesn't change a thing. Maybe the cable is even broken. You could try and see of the extension cable works with connecting i.e. your phone to a PC (if it's that kind of cable). The longer the cable the less efficient it will be, so might as well go for a proper one in your case! 

By the way, to play videos continuously you may want to add an infinite loop out of the for loop. Make the script executable: 

Assumption: You have access to the source codes of FanController application. Even if you sorted out everything on the system layer, I suggest you to do some changes on the application layer. The most convenient and solid way of making is to use . Example Java Code (exception handling is not included): 

Now, forget about and focus on . We are on . Step #3: Be sure that the OS level owner of is . Step #4: (as root) Mount onto with the credentials of . We don't need to have a user on . We just need to know its credentials. Here is an example of mount command: 

To build it from source, follow these steps (as root): Download source of the latest version. (For now it is v2.0.1) 

So after going in full circle I decided to ask here. Needless to say, I'm pretty new to the building from source scene. 

I always recommend setting a static IP in your home router. Setting a static IP in the OS will bite you in the rear end at some point in time. Installing Samba/Avahi to adress your pi via its hostname. This way you don't need to remember an IP. 

Kodi was able to do this. However since IOS 9, Apple has decided to work some magic to make this feature go away on all non-apple TV devices. There are some Github projects out there that are working on reverse engineering Apples work done in IOS9, but last I checked it wasn't done yet. All devices running an older IOS should still be able to stream. Link 

After doing some more research it seems that my ISP is only a part of the problem. Some networks (like schools and office lan's) block the access to anything hosted on a "home connection". The problem isn't RasPi or config related. 

The message Autolaunch error: X11 initialization failed in the second vebose log means that cannot init an . I guess you are working on a raspi which does not have a running . If X Window System is installed on your raspi, just start before your command: 

It will be hard for you to complete the last 2 steps via command line. I suggest you to use a GUI for bind. Here, there are many alternatives. 

Then edit your bash script which will be executed on startup as it reads the text file and updates the mentioned config files according to its MAC address. For now, I don't have time to create an example bash script. I hope to share it soon. Update #1 By the way at the very first step to easily gather the MAC addresses, just create a bash script which will be executed at startup and boot each device once: 

I have always found it handy to configure your router to always provide the same preset IP to your pi, this prevents issues with duplicate IP's (ip conflicts). Alternatively you could also set it statistic in your Pi and configure your router's DHCP to a range that doesn't include the Pi (but is within the subnet ofcourse). example1: 

I found the B+ model to be a bit annoying in the way the micro sd cart is placed... when you push it up against something (i.e. a Lego case you build) it might release itself. 

I have a PIR but there is this massive plastic cover around the sensor, it's also not verry well connected so it keeps falling off... is it safe to just not use the plastic over? Will be used in a potentially moist environment. 

now you should be able to ssh into the machine (again if this is possible at all in your case) a linux terminal example: 

As it is seen in your outputs, your raspi tries to access internet over LAN, not WLAN. To make it access to internet via WLAN, just set route priorities of LAN and WLAN. Append the following lines at the end of file. Lower metric means higher priority. (Don't forget to reboot) 

First of all, you are expected to post some of your system logs. We ignore it for now, because it seems that it is your first time with the stackexchange. According to your story, I guess some kind of overwrite may be performed by user on the files (mostly lxde confs) which are supposed to be owned by . Give the following command (run as root) a chance: 

For the first 2 steps, forget about , we are on . Step #1: Be sure that Linux system permissions are OK for to read and write , because system permissions have higher priority than Samba permissions. Step #2: Check your Samba permissions for and . It should be something like the following: 

This will generate a hash string, that has to match the one found on the download page. If they match you know you have downloaded the image correctly. 

I Have been looking all over for an answer but I can't find any. My miniDLNA server doesn't seem to stream the srt files (named the same as the video and utf-8 encoded) to my playback devices. I have tested this with my ps3 and android phone. Does minidlna not support it (found mixed answers to this around the net)? Or is it a ps3/android issue? Or maybe it requires some configuration I missed? Please advise. PERSONAL SETUP UPDATE: In the meantime I'm still running miniDLNA, but have resorted to sticking to smb and doing playback on OSMC(kodi aka xbmc) on a PI 2 B. This works like a dream. 2016 update (kodi 15+) Kodi 15 includes UPnP improvements including external subtitle support. 

Because there is no sufficient info about your system, I'm editing my answer based on these 4 assumptions: 

Even if it is technically possible to read info from the card and to start a transaction with the related back-end, I think it will be really hard for a solution to be EMV or PCI compliant (or more importantly legal). In countries, there have to be a regulatory authority who gives permission or license to solutions which will be used in payment processes. Without the permission/license, a solution cannot be used in payment processes. These authorities have strict specifications/conditions. EMV or PCI standards are included in their minimal set. 

I am not a PHP expert but I think you start the omx with a function like inside your PHP code. If you send and characters to STDIN pipe gathered from proc_open call, you can control the omx sound.