For every provided regex it creates a pattern and matches and replaces the occurences with the replacement. It is also important to look into now: 

In the game Factorio there are string-encoded representations of blueprints that I wish to decode. The implementation according to their wiki is the following: 

This will automatically and automagically create a working comparator that works by comparator the field of , which is inferred to be . Now this line: 

The code is not intended to work with the and classes just yet, I have only included those classes such that the code is complete. The code is also available in my GitHub project. 

Your variables names are way too short, last time I have checked there is no penalty for using longer variable names. Variable names should be descriptive, I or any other future reader of your code is not going to figure out what each variable really means. Examples of these variable names are: 

Inspired by some older questions, I decided to create my own postfix calculator using Java 8. I'd like to have all aspects reviewed. 

Your is currently a package-private variable, it is better off just being a private variable. Your could could use some extra room to breathe, consider adding blank lines between the method calls. Your copy-pasted is a real copy paste, you should really change the to there. Always use braces around the relevant control structures! This means that your for loop needs to be along the lines of . You should use descriptive variable names, I know it is tempting to write , but I would really advice you to just write , such that all code is much more readable. 

This is a Windows Presentation Foundation application that queries active directory and can display lists of users, users by group, groups, and users by manager (direct reports). It operates on whatever active directory server the host computer belongs to, and dynamically builds a of all the Organizational Units in the active directory for the user to navigate through. Once a user has selected an Organizational Unit, they can use one of the buttons to start a query. The results of the query are then displayed in a . Complete Process: 

This class represents a single query on an Active Directory. It is given the type of query to run and the types of data to return, and performs the query and returns the data when it is commanded to do so. The goals I had with this class were to ensure that the query is run async so it doesn't freeze (and crash) the UI and to be able to create the query without executing it immediately. The queries also support cancellation (it is handled farther "down" the calling tree in the and classes). Questions I have: 

Your conditional statement using the variable reads very oddly. Granted, I normally wouldn't be using a loop over a collection with a randomly generated number as the conditional, but maybe that's just me. Outside of the code itself, I don't understand what "problem" you are trying to solve. I don't see how this type of transformation would be useful. In your example, the code will actually do nothing, as the first list is initialized empty and nothing is added to it. 

When an item succeeds to 7, it can be converted to a "32DR crystal", which can be sold. When an item fails, it will produce 1~15 Dazzling Ores and a Level 100 Chip. If the upgrade that failed was from 6 to 7, it will produce 2 Level 100 Chips. Upon failure the item is lost. To increase upgrade success, you can add 500 Shiny Crystals from upgrade from 4 to 5 onwards, which will double your success chance. My goal is to calculate the most profitable method (possibly negative profit, also called loss) given the price of the 29 DR item. Implementation-wise, I have decided for now to let it run on the console for ease of use and with a few variable parameters hard-coded. they resemble the price/value of an item in the game and that, because it is dependent upon players, may vary from day to day. It's just for personal use, so I do not think it is bad to recompile it every day. In the future I want to support multiple types of items and goals (upgrade levels) though, where the following details are variable: 

Currently it connects to the ping process, as I still need to figure out how to run my applications correctly outside of the IDE. 

Your code and Java 8 usage looks fine in general to me. I do see an issue with the class, it looks like you are intending it to be an immutable class, if so, then you should also enforce it. You need to ensure that the and fields can never be changed, you can do this by adding to them. Your code currently seems to be safe, but it is not. I can extend and offer a method there to change the and fields, which violates the assumed variant of that those fields in are immutable. Simply changing it to the following will do: 

Is there specifically any way I could improve the argument/input parsing blocks? Would it be more consistent to ask the user for minutes if they supply an hours command line argument? Should I offer the variety of options at all, or should I stick to command line arguments only or "dynamic" input only? Bonus: Are there any meaningful names that could be assigned to the 1, 2, and 3 in the parsing blocks that would make the code more readable? Magic numbers are bad, but since it is checking the number of arguments, I can't think of anything other than which seems silly. 

I have a MVVM application that fetches data from active directory and displays it in a . The exact data displayed is determined by which query a user runs, and there are multiple available queries. Each query requires slightly different logic, but they all have the same general idea. These methods are all in my . is a property that is bound to the in the . If you would like to see any additional code for this review, please let me know. I am attempting to divide this project (several thousand lines long) into reasonably sized chunks for review. These methods are contributing greatly to the length, especially considering I intend on adding even more query options in the future. As of now, the whole class is 1000 lines long, with these methods being close to 400 lines. 

Use diamond inference where possible, this means that for example can be written as . Code against interfaces instead of against classes. Take your again. Nowhere I see a requirement to use a here, you just want to use a list, so only constrain yourself to writing: . This allows you to change the exact type of at a later point. I see that you only loop over the , you have no special requirement to use a linked list, consider using the more or less default , which provides constant lookup times and generally performs better. In your case the performance seems to be equal as all you do is, underlying to the enhanced for-loop, use an . Consider changing from using the API to the API at some point, it offers more future-ready changes and will co√∂perate better with Java 8. Prefer a class that receives print statements over directly printing to during processing. In bigger projects this usually is a logger framework, to which you then attach writers and also file writers for logfiles. In your case you may use a simplified version of this. A is old, very old, use the nowadays standard called , with as default implementation a . Some method names/semantics may have changed, but they both serve the same purpose. Do not catch all exceptions with , you may have confused yourself here, but this catches all exceptions of type (so all), and gives the caught exception the name . But even then, catching s is not good and you should just let them fall through such that they terminate your program (or thread), so you can actually fix the issue, rather than a Cannot make prediction. message. 

Whenever you declare and assign a variable in a single statement, if you are not going to assign it as , use the keyword instead of the type name. 

which is far simpler. The odds that someone will be randomly working with are pretty slim in my opinion, so you should perhaps consider changing your method(?) to accept a if not a or even an instead. Speaking of "method," it seems that this code should be one. It effectively takes an input and produces an output, so why not isolate it to be its own piece of code that you can call wherever you want? You could also get rid of that statement in favor of a proper . It would look something like this: 

Converting user principal to dictionary entry. Getting direct reports property of dictionary entry. Casting property to string enumerable. Using each string (distinguished name) to search for a user principal. 

After much frustration and leaked memory from working with s and s, I have made a wrapper to get the relevant data from these objects and then dispose of them, keeping the data in a form that will be dealt with automatically when it reaches the end of its scope. Side Note: As it stands, I can't use this code. It is far slower than using , and while it might do a better job of cleaning up, it is currently using more RAM. This takes 281 seconds and 104MB to handle 58 items, whereas the other way with takes less than a second and 101MB. 

Changed signature in from to , as the method needs to be and in case inheriting multiple times is possible, would clash. Changed the constructor to , to fix that a test class must only have one public zero-args constructor. Added to make it have one public zero-args constructor. Added to ensure that this abstract class itself isn't being tested. 

I am aware that the with a as argument is obviously much nicer, however for convienience the single-argument version with only a function is much better. 

Do note that when decoding that there may appear characters with which the Windows Command Prompt may have issues displaying. 

What I did here, was passing in an , which really is nothing more than a function that converts an to an , a compatible signature would be any lambda of the form , which is where I used a method reference like , which is in its turn a shorthand for , which is a shorthand for . Note however that you now cannot change the calculations for the attack respectively defense attribute anymore, hence that would need to be configurable as well in some way. I'll update the answer when I have found a way to do so. 

This way you exit early and the rest of your code is not impacted by this flow. Variable naming Most variable names look okay, except and , I see no reason to not use the full name like and , it will not harm anybody. When taking a closer look, I actually noticed that and are also off, they are not consistent and neither in the recommended camelCase, they should be and . Code safety I would recommend to make and final, I would say it is important for , such that you cannot accidentally reassign the variable. Performance note Currently you create a on every method call, for maximum performance you could create a and reference that one such that you do not need to create a new string array at every call. It depends on the amount of calls this method receives to see whether it is really worth it. One more high level look After analyzing the code I see it can be decomposed into two methods: 

I have statement that is switching on an to build a depending on what the selected value is. While the various values require different operations in their s of the , some of them require some of the same operations. All of the s are declared as and initialized in the constructor of the class. This method is called whenever the value changes, and is set to a property that is bound to by a in my view. Switching to would allow for 'circuit simplification' per se, but at the expense of some readability (and the ease of ordering the s). 

I have made a program that given a directory, will get the permissions for that directory and all sub-directories. The output is stored in a string that can be easily written to .csv. Each permissions entry is given its own line. The path is displayed first, with each directory level split into separate cells. Obviously, if the directory nesting has varying depth, the rows have a different number of cells. The permissions data follows, aligned after the deepest level, so the output would look like this: 

The code is executed by creating a new and calling . Like I said before, if I change the program so that the string building is handled inside the directory getting, thereby only iterating over each directory once, the program runs many times faster, but at the expense of being able to split the paths and then "right-align" the permissions result. I thought about displaying the permissions first, and then the path, but that goes against the spec I was given to work by. 

The good news is that you seem to be following quite some paradigms correctly and you understand OOP quite reasonably, yet you do need to improve on some points. 

These goals have not been met yet, as currently it just wraps over the jinput library. In order to understand some of the weird stuff that is going on in my classes, you will need to understand the following things that are going on in the jinput library: 

I don't really like your current solution as it seems overly complicated, instead of fixing it, I'll suggest my own implementation, the things I found are: 

If every catalog also has a generic relation with their repository, then even more interesting patterns can be thought of, but it is always a question of whether you need so much compile time protection. Then you need to store your mappings somewhere, I suggest a singleton enum for that: 

I agree mostly with @Vogel612's answer, the second version is more concise and there is no need to litter variables all over the place as is done in the first version. Another point is that code should be self-documenting, which @Vogel612 also suggests, but else you can still add a comment behind the code lines. My review I wanted to talk about a more interesting point, as this question seems to be a subproblem of a bigger question of yours, which involves creating a high throughput program that does something with tweets. Perhaps this is a premature optimization given that I do not know how well your program performs, but your program may very well hit a threshold limit because of the way you handle regexes. You should consider what a does: