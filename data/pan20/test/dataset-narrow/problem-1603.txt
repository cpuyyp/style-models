What you would need to do is create a reverse SSH tunnel. You would have to configure the Pi to do this before you place it at the remote locations. What happens is the Pi creates a connection from inside the network. With normal NAT that is considered safe and the connection is established and any data that comes back is routed to the correct IP. Some professional firewalls might stop such actions on certain ports. You can overcome that by connecting out using port 80. Even more expensive firewalls inspect the packets to make sure they are not forged - In those cases there is not much you can do without figuring out a weak point. 

It might be a bit difficult to work out all the commands at first but it is a very robust way to control devices connected via HDMI. Most tutoritals show how to control the Pi via the TV, like XBMC does. Basically you use your TV remote to navigate the menu on the XBMC. But you can do it other way too. I hope this helps somebody in the future as an alternative to Infradead. 

This time you will drag the right edge of the partition, to resize it, all the way to the far right side. Accept 

This is the professional way of restarting any kind of hardware or listening for certain events. You can even use the watchdog to start certain scripts based on the data you are gettings. Like high wind speeds can send you warning email or something ... Source 

WebGUI accessible on by any moderns web browser. This is just a remote control panel type GUI. You an start stop processes, connect to WiFi and set other options, like Remote Display. Remote Display (not Remote Desktop) needs to be enabled (as above) on the Pi and then you can use the Remote Display client to connect on any computer and OS. This works like a monitor over IP - So you see exactly what is on the screen, literately, a remote display. PowerShell via SSH - But you need to know your way around PowerShell commands to get anything useful done. 

Or you can connect to the IoT powershell command line using SSH or Powershell, I think SSH is easier. 

Select the SWAP and click resize/move. You should be able to visually drag the partition to the far left.(make sure NOT to resize it by any mistake) Accept 

And unless you are hitting some kind of performance issue there is absolutely no reason to micromanage the code in terms of is this the most efficient or not. C# compiler and the IL (Intermediate Language) does a fantastic job at super optimising code (a team of highly skilled programmers out numbering the skills of entire stack exchange made sure of that) - So things like caching static lookups, managing memory, efficiency is all done as best as possible during compile. 

This really shouldn't be that complicated, you might just be looking at the wrong place. I hope this solves your issue. 

You can use the Raspberry Pi for the webserver. You have a variety of programming lanugauges you could use, like Python, C/C++ even C# (in Linux using Mono) or Windows IoT. It would be allot easier if you could use I2C - Which supports connecting allot of sensors (various types) typically using 4 wires (2 power + 2 RX/TX for bidirectional communication) (or 3 wires if using a leech circuit) to the Raspberry Pi's I2C 

This will void your warranty. Well if you want to start messing around with the PCB there is a kit that will make your life so easy that you will wish you knew about this earlier. 

But if you can run a cable from the router, or from your extender (usually they have a 4 LAN ports) but you can also use PowerLine LAN, this will give you pretty good results on speed. Then make your Pi work like an access point for other devices to connect. The advantage is that everybody and every device is on the same network now, and you can airplay from wherever you are connected, even remote Wifi, with a LAN backbone to the main router. There is a fantastic write up in MagPi magazine, Issue 11, on how to set up your Pi as a Pi-Point as they coined it. But you may want to skip setting up DHCP server or DNS, since you want your main router to keep all devices registered and happy in one place, so that everybody can talk to each other. DNS on the Pi will be the IP of the main router, since the main router can tell you who is on your network, or lookup internet domains. It works pretty good. 

or an exmaple I found that targets V4L directly but oyu have to have the camera present in where * is or more... 

To be able to drive it forward or backwards you create a simple H-Bridge with 3 more transistors and 1 extra GPIO. 

I got a Chromecast to replace Dreamplex(not managed by Plex community) on my Satbox which crashes from time to time. I also tried RaspBMC and RasPlex on the Pi both of which I found a bit slow to navigate the menus, and that it can have like 5 layers before I get to the movie. The payback is crisp though! But unfortunately no matter how much I tune my WiFi for the Chromecast the video playback is, putting it lightly, "poop"!. I can use Shairplay for some things via the Rapsberry Pi which is OK but still not ideal. Is there something like a Chromecast emualtor for the Pi, where I can touch play on the Plex App to the Pi Emulated Chromecast and click play from my device, so it plays from my Pi using LAN to my NAS at full quality? I am aware of PiCast2.0 but it doesn't do what I ask here. So please dont mention it. 

This is a step higher and can act as a repalcement router but does not have to. It jsut has the facility. This model allows you to use 2 VoiP lines/channels and connect 2 phones or 1 phone and 1 fax or 2FAX's. What ever you fancy. Again you can redirect your land line to your Voip DID 

-Update Aug 2017- Unfortunately pfSense has no interest in creating arm based images. pfSense HAD no interest in porting over to an ARM based version because the BSD kernel was not stable on ARM yet. Since the time of the original answer a few things have changed with the latest Pi hardware, BSD runs on ARM fine and pfSense has been overwhelmed with requests. 

These are the same used to programme Arduino 3.3v boards. basically it gives you a Console over USB on Pi, and a Serial on the other. You asked for USB, but you may just connect the two directly RX to TX and TX to RX. The problem with this is that 2 is the max. There are ways to get more but it get more complicated than needed. 

The Raspberry Pi foundation does did indeed always suggest to use their epiphany browser due to optimizations. But they did admit that no work has been done on it for quite some time now and they really thinking about abandoning epiphany. scroll down to "Updates", then "One more Thing" They recommend using the chromium browser instead with a plugin called "h264ify" that forces youtube to stream h264 which is supposed to decode better on the Pi. I did this, tested it. I am not sure how it was before but it does stream OK when windowed. Still for me when you go 1080p and full screen its choppy like crazy. I also enabled experimental GL and put 256MB for GPU. 

Chipquick kit and CPC - This stuff is really special. The solder is only used sparingly becasue it has special properties. I use this for complex part removals and I follow these steps, even on 0603 SMD's! Tools you SHOULD have. 

The still pictures is a standard JPG encoded by the MJPEG encoder, that's why you can see it. I am sure gstreamer supports MJPEG and not sure about YUV2. But! It is possible that the MJPEG implementation for ARM (Pi) architecture could still not be supported. Possibly gstreamer needs to ask the camera for MJPEG directly or something else needs to ask for it. I doubt YUY2 will work any good on the Pi.(At least it is not listed in any supported codecs - but MJPG is) It is possible that you should use something other than gstreamer. Take a look here. or at this post. EDIT OP resolved the problem by using and installing using this extensive and long guide. 

I have spent a few good hours compiling the latest for the Rasbperry Pi. I wouldn't want to do this again, if it came to it. I tried cross compiling with but I am still a noob with qemu. So I endeavoured I have finally compiled it on the Pi, and got it working.(after 3 attempts) How can I create a package with all dependencies, so I can just install it later? 

Sorry, thats the best you will be able to do. As with corruption, check disk might find it as OK, but in reality the bits are messed up. You would need to track down the binaries or files and replace them but you cannot guarantee if you fixed all the corruption, or if the file will actually be copied properly. With SD cards, bad sectors are usually managed by the SD firmware, so its not like a traditional drive where you know that sectors xyz is corrupt and file 123 is on it, because SD firmware will try and relocate the sectors dynamically and attempt to fix the data as best it can, even if its corrupted. 

Nope. Raspberry Pi is not "that" reliable for production. Arduino is much better and definitely much more reliable. You can do it with maybe a hundred lines of code at most and it has libraries to do interface with a ton of hardware. Plus once you prototype it on a Mega or Uno it cheap to programme, new stand alone boards on cheap 2 layer PCB (I recommend seeedstudio, cheap PCB's) You can THEN use the Pi to talk to the Arduino via UART or SPI and host a web page if you want. Pi sounds good but long term, you will face allot of unexpected problems :(# 

If you were desperate to this you could cut the 5V PCB trace and make your own switch, using a transistor and GPIO pin. But that will void any warranties. 

wont hurt it but in general terms yes- stick as close to 5V as possible. The BCM chip and HDMI takes power directly from this input so going overboard will hurt it. 1A is recommended for when you are using it with loads of things plugged into it. It will fine with 0.7A but if you start to experience wierd things like resets in the middle of a encoding then you need a better power adapter. 

If they are simple VGA 2D cards only they will usually work of the Pi but as mentioned before you don't want to overload the Pi. 3D devices will have separate power connections. Theoretically you should not use more than 2.5Watts per USB port off the Pi (5v * 0.5A) 

You can use a service that is connected to the GSM network. You use a simple API to send SMS messages or attach MMS images. The rates are fair. I use TextLocal in UK and you can send messages to the world. There are allot of other service providers available too. Simple PHP to send a text message 

These are 3.5" drives that must use a power pack. USB power is not sufficient. As it will use a typical molex connector to power the drive you can easily tap into 5v rail. 

Go and look at all the projects available at the Microsoft IoT developers section for Raspberry Pi $URL$ $URL$ 

By the looks of the schematic the GPIO pins are connected to +5v Rail; I have copied part of the input schematic on the USB power. In this sub section the +5v supplied from the USB connector is filtered to give a nice stable 5v supply to the Rail. 

As Daniel pointed out - True directional antennas need to be build to specification the same way as omnidirectional antennas. Real directional antennas can achieve kilometres of WiFi link at the same power as omnidirectional. First problem with directional antennas is that you need them on both sides to work properly. Second issue is that the antenna you trying to convert to direction antenna was built specifically to be Omnidirectional (send data all around it) By putting a beer can or pringles tin over it all you are doing is blocking 90% of the WiFi while letting the rest go in one direction. You CANNOT achieve amplification like this regardless what people say. You just this illusion of better range but its nothing like a few kilometres is it? The only reason you may think you get better WiFi signal is because you blocking out WiFi noise by putting a can over it. 

Just check the datasheet to make sure it can handle the voltages switched. DO NOT SWITCH THE HIGH VOLTAGE (THE VOLTAGE THAT 'SHOCKS' YOU WITH) A TRANSISTOR OR ARDUINO DIRECTLY 

*The image and more information can be found at this site The downside of using SPI slaves is that each light needs some kind of microcontroller (aTiny or PIC with SPI built in or other cheap SPI - They all have to be the same thouhg). You obviously want to use the cheapest thing out there. Then you have to program every one of these to do something that you tell it to do. That said, SPI still makes a huge saving on costs on time.