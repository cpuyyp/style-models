So that could be simplified to the following (also uses the numerical-index array syntax - see above): 

At least one property of the object returned by the proxy (i.e. in ) can be shortened using shorthand property names because the property name is the same as the variable name: 

General Feedback I can't claim to have done much with SVG creation myself but I can offer a few review points for the code that creates the SVG item. It looks like you have done a lot to abstract out the common SVG code necessary for your needs. There is good usage of for values that don't get re-assigned, and for other variables. And it is good that there are no nested ternary operators. Review points There are quite a few lines that check if arguments are arrays or not... For instance, checks if is an array, and then if it is an array, checks if each element is an array (in the callback). It appears that function is only called twice (at least with the sample code), and each time is an array of arrays. Are there cases where that is not the case? 

In this way, the result of the above example will be: . Of course, it might be worth considering to rename the parameter, e.g. to or something similar. P.S.: I setup a github repo for the above mentioned changes, and their corresponding test cases (along other tests): 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

As I said above, I'm not saying that this suggested change is necessarily better than the code you have now (in fact it is a bit more over-engineered). It is rather a way of exploring how to further OOP-fy your code. Test Code Let me first say, that I find it a really positive thing that you write your code with testing in mind, and add unit tests to cover (almost) all the cases. That said, some remarks: 

N.B.: I am not familiar with Processing in detail, but since from the question I understand that 'drawDigit' is an own method (i.e. not built in to Processing), I assume, that it is possible to introduce other own methods in a similar way as in Java. Functionality I do not understand, how the seconds will be rendered correctly. As far as I see, this is the only part that depends on the seconds: 

Feedback The code does cache DOM references (which I know we have mentioned in your other posts) using . All lines appear to have a semi-colon to end the line, except the one where text content is updated (i.e. ). While it isn't required to have one, it would be wise to be consistent, for the sake of anybody who reads your code/might need to alter it. Suggestions Using instead of If you are going to use , which not then use for the mutable strings instead of ? Setting values Instead of making four click handlers, you could just use the last one to set the values, since the DOM elements are all still present despite not being visible. That way, those variables can have the scope be limited to a single function, and then can be used there: 

1 When the array has numeric indexes, then there is no need to setup the counter variable and increment it at the end of each loop: 

Feedback The code makes good use of prototypes to assign the functions. The code uses class names to manipulate the style of elements instead of directly altering the style attribute. One reason takes so long might be that the moves get cloned, and those contain references to the DOM elements. You could move those DOM element references out to an array and store an index from that array. I will try to see if that helps when I get a chance. Suggestions: Assignment within Ternary operator 

Although lines (1) and (2) do look right on first sight, due to indentation, they are breaking the if-else statement. This kind of issue can be avoided by always adding braces. 

Further remarks: Robustness I recommend some extra checks to your program, to make sure that it is robust to potential wrong input: 

But as I understand, this code does not show any digits, just fills a space with a colour. Is this the intended behaviour? If so, then I suggest documenting why is it like that (in a comment), otherwise, I propose to extend the functionality so that seconds are rendered as well. On a side note, I recommend to use always the block-form of if-else statement (and any other statements), even if it has just one instruction per branch. In other words, I suggest rewriting it as follows: 

In general, I think the program is well readable, and demonstrates the idea correctly. I have some suggestions for further improving it. Constants Consider the following statement: 

I implemented a Trie data structure in Java, to test my understanding of the concept. I tried (pun intended :) ) to follow TDD steps along the way (i.e., add first a failing test case, and implement functionality after ensuring that it really fails). I'm posting here the end result. Besides the implementation itself, I'm also interested in the quality of the tests. I'm mostly interested in the following aspects: 

Then in that nested function , did you ever see the first conditional (i.e. ) have a truthy value? I tried running it a few times but never saw that occur... 

Because will spread the arguments out to match the parameters (i.e. ). That way there is no need to iterate over the items. Array.concat() could also be used but then the array would need to be re-assigned. Or Array.unshift() could also be used with the spread operator. Expand the snippet below for a demonstration (AngularJS code removed for simplicity). 

Then use document.addEventListener() to listen for the DOMContentLoaded event, then listen for clicks. 

Why not just iterate over the inputs, and if the values of the id attribute exists in then add the error class and show the affiliated error message, otherwise add the valid class and clear the error message? When the DOM is ready, the input values can be stored in a variable: 

One could reduce the redundancy a bit (and adhere to the Don't Repeat Yourself principle). The only real difference in the two arrays is the value at key . That change can be pulled out into a conditional block. That way if more data needs to change (e.g. add more data to the sent array), it only needs to be added in one spot instead of multiple. 

I think the logic for getting the minimal distance between the points would work even without the explicit check against MAX_INT: 

Background Linked lists are a well-known data structure, so I won't waste too much detail on them. Suffice to say that a linked list consists of "cells". Each cell contains some kind of value and a reference to the next cell (except the last one, which contains an empty reference). I implemented a linked list in Clojure as an exercise. The code 

Braces around blocks: I recommend always putting braces around each block, even if it is just one line. In your case (also, with the correction above), this would look like this: 

For the record, I checked in this code into my github repository, and probably I'll improve it based on the answers from here. Trie.java 

Out of scope The quality of the hash-functions used for testing is out of scope of this review. (I know there are much better ones, but for now I focused on the data-structure itself.) However, if you know a way to e.g. better organize them, and avoid repetition (but without making that global!), that would be very appreciated. The code 

Feedback The code looks pretty good, and thus I only found a few things that I could change (listed below). I like how the bootstrap class can be applied once to affect all sub-elements. Suggestions CSS Move the in-line styles to the stylesheet to reduce redundancy - e.g. the number inputs have a specific width, which can be put into a CSS rule-set, like this example: 

See it in action on Teh Playground. What would you do differently, perhaps for readability, performance, etc.? Would you take a completely different approach altogether? Update 10/6/2017 Taking the suggestion by J H, i.e. "You're doing a linear scan through an array. You'd be happier if you were doing hashed \$O(1)\$ time lookups in a set (or map).", I have updated the code to use the end time as the index of the output array (i.e. the hash map). Also, I have incorporated more functional techniques (beyond array_map()) and used array_reduce() to iterate through the timeslots. By using the end time as the index, the code will look for that end time in the array and if it exists, then combine it, setting the last start time, moving the combined timeslot to have the index of the new end time and un-setting the timeslot at the previous end time. Then when outputting the times, the keys don't need to be considered for the output, since the output only needs the start times. A great advantage of this is the need for referencing via the statement within the lambda function is eliminated since we aren't iterating over the keys anymore. 

Reason is to avoid accidentally breaking the if-else construct, by introducing new solutions.Consider this: 

Is this a correct implementation of the data-structure, or do you see any flaws? Is there a way to make the implementation more optimal? (E.g. is there an elegant way in to jump out of the if we encounter a bit not equal to ?) Related to the above: is there a way to make this code more idiomatic? (I.e., conforming to Clojure best practices.) Can you think of any missing tests? Or some other edge-cases which are not covered? 

Why is this last point advantageous? Because you can easily add more situations, without the need to copy-paste the gui elements (wrapping divs). Besides that, it is also possible to quickly change the gui implementation. (E.g., if you decide to have divs instead of buttons, you do not have to change every one of them.) I created a fiddle, where you can try the concept. (Unluckily, the built-in fiddle of SO is not available from tablets...) 

Leave it as it is: all output is shown, some of it might be on the wrong place. Overwrite the the end of the first string with the second one (i.e. ). Overwrite the beginning of the second string with the first one (in this case: ). Throw an exception. 

This can be simplified to a single line using an ES-6 arrow function and Array.prototype.includes() (Not supported by IE): 

Then add a click handler to the document and check if the id attribute corresponds to one of those tab options. 

Performance Comparison Compare the four approaches with this jsperf example. In Chrome, Firefox, and MS Edge it reports that the original code is the fastest. 

Then that method can be used in the method to get the pirateID. It can iterate through the array, looking for the value in each sub-array. If it is found, then it will return the index of the sub-array. 

With the current code, it seems like separating the functions into separate files would be a lot of extra network loading. I can't think of much of a benefit for that but if you have one then perhaps it would be worth it. Other feedback Arrow functions 

With this approach, there is no need to keep track of counter variables (e.g. , ), use those to index into the array, nor increment those until certain conditions change. It also makes the following line superfluous (so it can be removed): 

In this case, he would probably get meaningless results. I therefore suggest introducing a check at the beginning of the implementation of the method (if you need it at all, see below), and e.g. throw an exception if no search was performed yet. Constructors In this particular case, I would suggest initialising only in the body of the constructor, after checking the validity of the parameter. In other words, I would first validate, and only then initialise, instead of initialising with a (possibly invalid) parameter and then cleaning up. Also, it is not clear to me what the purpose of the default constructor is. Would an object constructed through that constructor work correctly? If not, then you can probably remove it, and keep only the parametrised one. Destructors I recommend adding a destructor to this class, where the file stream opened in the constructor is closed again. Idempotency Note, that currently it is possible to call only once. After the first call, we will be at the end of the input stream, and thus it is not possible to read from it anymore. I therefore recommend to either reset the stream (or close/open it again), or introduce a similar check as mentioned above for the state of the object (i.e., throw an exception if is called twice). Responsibility of the class Instead of the method , I would rather introduce a method , which would return the actual count, and then leave it up to the client how/if he wants to print this count (of course this would also need the above mentioned check, whether the object is in the right state). Maybe it would be even better to have return the count directly (and throw an exception if the word we are looking for is empty, instead of communicating this fact through the return value). Naming I recommend changing the name of the variable to something which better reflects what it is, e.g. . ( makes me think of a string holding the name of the file, not a stream through which the contents can be read). Code blocks I suggest always adding braces around code blocks, e.g. for the code above: 

Functional approach to iterating over the headers In the snippet below, the headers are iterated over using . That way there is no need to index into the array of population headers. document.getElementsByClassName() returns a HTMLCollection interface (different than an array) so the spread syntax (i.e. ) is used to put the elements into an array. 

And could also allow it to be simplified even further, though the variables outside the loop would have to be imported into the callback function with the statement, which might seem a bit wonky: 

And what is the point of these two lines? I was able to remove them and still have the code function the same... 

Specify context I support Blindman67's answer. If arrow functions were not supported by all browsers used (e.g. IE - but then again there is little support for Angular in IE anyway) then you could also utilize Function.bind(): 

Could be simplified using Object.values(), Array.prototype.forEach() and Array.prototype.push(), thus reducing the need for the iterator value . Actually, I removed the variable inside the callback function and referenced the one outside the callback function, thus reducing the need for that extra variable, as well as .