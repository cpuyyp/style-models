Note: Since is a read-only property, the method would skip it even if it didn't have the attribute. Finally, you can convert the CSV file to class members just like my previous answer, using the setters to assign read-in values: 

That is a good definition for an but I believe it is better to implement the operation directly for an (note: I don't use VB, so translated from C#): 

I don't really like the burgeoning arrow or the fall through else, but it is how I often solve this pattern. 

Then you can create another map to map header names to column (field) numbers and process the mapped fields: 

I am not sure if Reflection wouldn't be the ultimate solution (you would need to use a custom attribute to indicate non-matching CSV headers), but one possibility is to manually create a map for column names to fields in the class: 

I think the concise version is longer and more confusing, and emphasizes the wrong return (assuming the value of SomeProperty is what is really of interest). For the verbose, I don't like returning the same value more than once, even if it is a constant - so a variation on the verbose: 

Since I was looking at similar functionality for runs of sequential numbers, I thought I'd offer my LINQ solution to this. Using an extension method based on the APL scan operator, which is something like an that returns the intermediate results, which I also have modified to use to pair the scan value and matching element so you don't have to use s and keep up with it manually: 

But do whatever suits you - as long as you follow the standards of any projects you're working on, the presentation of what you code in your own time is totally your decision (many will disagree with the way I've presented the code and many will agree - opinion varies from person to person, and there's no one way to present that pleases everyone). Furthermore, a comment about your comments. I didn't fix them in my example above, however I would be more specific to the code you're commenting by. So, for example: . That comment mentions things that aren't happening in the line directly below - I would make sure to comment each line as it happens in this case. I would also be a bit more explanatory about each line - so for example, in that same line that I was just commenting on I would say rather than , something along the lines of - although I would describe each process on separate occasions, as I mentioned, rather than together like I just did for the sake of example. 

I'm learning Java too! Looking at this the only thing I might suggest is that you only do the calculations that you need to. You could then remove all answer variables and print the result of the calculations directly, saving time and memory, albeit not much. In terms of presentation, I personally would use lowerCamelCase for variable naming, e.g. firstNum, and I would also indent all of the cases as they are within the switch block. Finally, for I'd make sure there was no space there. Despite what I say for the presentation, that part of it is totally up to you, so do what you prefer, as long as it looks clear! 

My biggest suggestions for improvement are: always submit the cleanest code possible, try to follow broad, important, rules for how the language should look, so it looks clean to the reviewer, and work on writing short, helpful comments around tricky or interesting spots in the code. 

Consider having an explicit case, and making your case throw an error. It's a simple way to make sure your input is only ever A, B, or C. Unless we want to assume that anything not given a letter grade (e.g. something never assigned a grade) defaults to a 2. 

Try to avoid naming things as misspelled words. "Module" would probably not be a good choice for a package name because "Module" has a meaning in programming in general, and since version 1.9 it even has a specific meaning in Java. This doesn't mean, however, that "Modul" is better. 

This method is a little busy - it would be nice if the functionality to get input from the user was somewhere else (in a separate function), especially because you need to use it for multiple commands. Also, it really seems like (, if we use Camel Case ;p) should be an object variable. 

You definitely don't want to loop from 0 to , when is changing. This loop doesn't really capture your stopping condition, which is . How about: and in the loop you add the number to your Array(List), without needing to use the break condition. 

Part3 will have the same issue and you can create an explicit type if you want to refactor out the query into another method in the same way as part 2. I run into this quite a bit and have yet to find what I think is a satisfactory solution, so I end up creating explicit types instead. 

Note: You could use reflection to assign values as well, but I figure it is worth the effort to build the lambdas since you presumably will be assigning to the fields often (once per CSV file row). Now you can annotate the class with CSV information: 

Here is another answer, using Reflection, and to create a more automated solution. First you create a couple of custom s to mark fields or properties with the CSV Header Name when it doesn't match the class member name, or to indicate a class member isn't initialized from the CSV: 

You can create a group number for each matching sequence of keys, then group on these group numbers: 

I think you are running into a fundamental problem I often have with anonymous types: they are anonymous. C++0x has some interesting extensions for getting types back from anonymous types, though I am not sure they would help here. I suggest creating an explicit type to replace the anonymous type. This may cause early evaluation of your query. 

Double loop, great, and without incrementing variables, even better. The names "grade" and "studentGrade" leave me a bit confused though. "studentGrade" contains more than one grade? I would replace "studentGrade" with something like "singleStudentGrades". 

I can't see why this is so, since you don't add 0 to the array, and the user can't input it. Did you test this code? It seems like there is a bug here. 

The contents of the outer loop - i.e. the inner loop and the check - could be broken out into a separate function, , which could instead of . I.e. in the loop, and if you finish the loop without returning, . 

This is a configuration constant - it should go at the top of the class, before methods. If all users should have the same withdrawal limit, it should be declared , too. 

Regarding these loops: I prefer to avoid statements where possible. They tend to be more difficult to understand intuitively, especially in a loop. As a rule, I prefer my loop to end because of the condition it checks, not because it gets d. 

Using an array and incrementing the size is a little ugly, and it's inefficient. Consider using an ArrayList, which allows for index-based insertion in constant time, and hides all of the size changes (as well as doing them more efficiently). 

The Sieve of Eratosthenes works by going through and marking all numbers that can be divided into, essentially. Take your input "n", for which you want to find all the prime numbers up to it. The sieve starts at 2, and multiplies 2 by increasing amounts until the multiplication is about to exceed the value "n" - in your program, this is accomplished through the integer division and then iteration up to the calculated result. So, as it multiplies the values together, it marks the result as non-prime. Meaning that 2, 4, 6, 8, 10... etc are all set in the bitarray as 0 (meaning non-prime in this context). It moves on to the next value, so it starts at 3. The process repeats as it marks all multiples as non-prime. Time to move on to the next number - 4. As 4 has been marked as non-prime, it skips over 4 and moves on to 5. This continues until it finally reaches the number which is the value of its square root, so when you are using the sieve to get primes below 100, that means the algorithm checks the multiples of values from 2 to sqrt(100), so 2 to 10. It doesn't need to go past this value as all prime values above that share multiples which values that have already been checked. So, for example, if we moved past 10 to check multiples of 11, we'll get 22 (which is divisible by 2, so has already been marked non-prime) and 33 (divisible by 3). The values which remain with a value of 1 are prime. tl;dr The algorithm goes through all prime values below or equal to sqrt(n) and marks their multiples up to n as non-prime. The remaining numbers must be prime. EDIT: The code above adds 1 to the div operation, which I didn't mention in my explanation. EDIT 2: This specific modification of the sieve is essentially the same as the original sieve, however rather than removing square values during the normal removal process it removes them separately at the end. 

I encourage you to consider writing unit tests (I recommend ). It'll make your tests easier to write and read. The above tests are ok, but I would definitely add tests to check that you get when you expect to. Overall: Your code is overall quite clean and easy to follow. It's not quite production-level, but it is good for a Java course. Nice job! Regarding returning : There is a large discussion around this issue. I think most people believe something along these lines: 1.) should not be used in place of an error. This is because in general, methods should enforce their contracts loudly, i.e. if a method's job is to take a number greater than zero and return it times two, and it gets a number less than zero, it should complain. By returning , you force programmers who use your code (if they're responsible) to write in code to handle the possible null case, because otherwise there's no guarantee that they will be aware of the error that made your method return . And 2.) can be used as "no results", but it might be better to return an or an empty data structure instead. For more, check out this question Is it better to return NULL or empty values from functions/methods where the return value is not present? For a class assignment, though, it may well be the case that using is "ok" because its fast - and it doesn't require you to shift focus from whatever the point of this assignment is to spend time writing exception throwing code. Avoiding using as an error, and instead throwing an exception, is a best practice, though, and as you grow as a programmer you may want to do so even if it's not required. Be careful though - if your code is auto-graded and it is expected that it will return for a given input, an exception will probably cause it to be marked wrong. In this case I suggest writing code to your assignment's specification, and being content with knowing that were you writing code in the "real world", you'd do it differently