What is the reason for performing internal initialization inside the function? You're already inside a function, and you're operating on its local variables. Here are some thoughts on the insertion sort (chosen at random): 

Let me say up front that I'm far more familiar with unit testing than behavior testing, but this looks an awful like you wrote the tests after the code. When I think of "behavior", I don't think of neatly mapping it to method names. Instead I would write use cases that may require multiple method calls. 

Also, all of the conversion methods are stubs that throw an exception rather than abstract. Why? I don't know. If these weren't enums and could be extended, stub methods that fail only when called are handy for allowing optional operations--think which throws if not implemented by the concrete container. 

Solving the first problem is simple enough: use a to cause all incoming threads to block until the first list of objects is set. Ideally the system would start another thread to specifically load the data rather than letting the first random thread to come along and do it. This isn't necessary (see below), but it's much cleaner. For the second problem, wrap the list of objects in an to supply a correct memory barrier. You might be thinking, "Oh no! Not two synchronizers for each access!" but Java's synchronization primitives have improved greatly over the years, and the atomic value holders are even cheaper than full synchronization. 

Note that this assumes a single-character directory separator. My only quibble with the class, and I understand you want something lightweight, is that there's no checking of the array passed to . This shouldn't be too much of a problem since it will fail pretty quick if the parameter isn't an array or contains non-strings, but if that comes later during the execution the error will be harder to spot. I think you'll get a simple "class not found" error. Oh, and the method should be named since it removes any existing directories, or it should append them to the existing array. 

If after adding the index on and you still see poor performance, trim the query down to the bare minimum to isolate the source. Remove all of the joins and the where clause referencing those tables. Once it's doing just the distance calculation (which should be move to a deterministic stored function), you can get a better time measurement. On an unrelated note, you can set the three variables at the top with a single statement using . 

With an insert, the entire string will be inserted. Sometime in the future (when you try to fetch the font from the database), and before you output it into CSS, you'll want to escape the string for this new context. CSS escaping is something that hasn't a native PHP API, but there are probably libraries around. 

Yes, it is safe. No, it is not a good idea. Don't mix application logic and configuration with the database, the database is used for permanent storage of data. Use a file (json, ini, xml, whatever) which is named the same but has different contents in production/dev environments. Then, it's as simple as: 

The reason it seems messy is because you have one function doing multiple things. So what does your function do? 

In the above example the nonBusinessDays of the week are SATURDAY and FRIDAY, and 1st and 2nd of June are holidays. In that case, 3 business days from now is June 5th. This can probably be improved further, let your imagination run wild :P 

This code is 100% XSS proof. And it doesn't matter what has in it. Note that with this method you do not escape for HTML before you insert to the database. Always escape as late as possible. A note: This is about escaping HTML. It will not help you escape things like JavaScript or URLs. The following will not be escaped properly: 

There are several advantages to writing proper HTML and using semantic tags. Instead of asking yourself "How should this look?" Ask yourself "What does this mean?". What does it mean for a text to be red? Does it mean phasized text? Maybe text? You can always apply the on top of that (or even better, with a classname). What are the advantages? 

You should first ask yourself this: Why am I sanitizing input in this way? Let's say I have a login form, and the user enters his credentials, an email and a password. The email will be queried against the database, to figure out the user's hashed password (You are hashing your passwords, right?!), and the password would be hashed, to be compared against that hash. Both of those fields will never be outputted to HTML, the password is never kept in plain-text form for very long, and the username is queried against the database and then discarded. So why should you escape them for HTML? 

If you're passing information, pass only information, not markup. Alternatively completely generate the HTML markup on the server-side, and just apply it on the client side. There's no point in combining the two, and if done wrong you could cause double escaping issues. Second, don't use as a debug function. Use and use your console. 

I would perform the same encapsulation with building and managing the nodes from the . Miscellaneous 

but I found it easier to move the first/last element handling out of the loop. Also, negative list indexes reduce the calls to which cleans up the logic a bit. My first refactoring built a new list in-place with similar procedural code: 

While it works, converting this to a list comprehension and adding on the first and last cells using seems more Pythonic to me: 

Introducing Null Object Pattern To avoid duplicating code that checks for null values throughout the application, I would like to introduce the Null Object pattern. However, I'm afraid the only way to do so that supports the features above is to add three new classes instead of just one: 

Use optimistic locking when the logic requires separating a read and update of the same row into two transactions, usually because you're showing the original data to a user and letting them edit it. The example in your question doesn't need it because you're simply overwriting the existing age with a new value. Trevor is correct about how to implement the optimistic locking check (3 and 4 below). The only part missing is how to get the original timestamp. 

As Kinjal suggests, logging the error is a good alternative when failure is recoverable. However, I would throw a custom exception (or use ) and let the caller decide to log and continue or terminate. I really don't like returning success codes when I can avoid it because it muddies the code with checks. Finally, instead of setting a certificate or leaving the field blank consider modeling a certificate checking strategy. This would require a simple one-method interface with two implementations: and . Again this improves testability by providing a seam for mocking, separating concerns, etc. It also removes the need for checks and allows for more strategies and certificate types. 

If you can assume that every index in the encrypted message is included in the key, You can loop over the key and encrypted message together, placing each letter into the correct decrypted message slot directly: 

Iterate over each pair of rows. Calculate the better path to each cell in the lower row from the two cells above it. Return the maximum value from the last row. 

Update: Start by replacing named variables such as and with an array of number/styles so these become and . Add another loop to assign the numbers and styles.