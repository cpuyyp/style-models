It is a bad idea for a constructor to contain non-trivial code. Constructors should assign values to fields or another simple actions. If you need complex initialization, you should use factory object or factory method 

I also think that methods like Should take a File instance as an argument - it should be responsible for writing to the file not opening it or creating some directories. Same for readFile method. 

Classes in model layers should be aware only of interface of underlying layers (DAOs or something similar). If it contains than you are telling your business model what view you are using. Send text from textfield directly in you service (model) methods. Or better send them some DTO wrapper object. You misused and . belongs to the controller or view layer and belongs to the model layer and check the business requirements. Also you duplicate the name of the cities. When you want to add new city you have to change the model and the view. Put them in one place (maybe something like CityRepository accessed by the Model layer classes) and get the cities from there. So to recap Model is businees view. It should contain validation and perform your business task (in your case some traint icket processing) and should be aware only about data model. View should be aware only of controller and provide interface to interact with and methods how to get the data from the user Controller Drives the flow - it gets the data from view, wrap it in some business objects (like TrainTicket, User, etc...) and pass it to the model, takes output from the model and present it through the view. 

Therefore its either a choice between caching in memory and caching on disk or an emphasis of one over the other. This inevitably leads to additional questions about how your app will be used and the what kind of images you are working with. Some basic guidelines: 

Modify Caching Strategy It seems every image that is subject to caching is ending up both in memory and on disk. Depending on the number of images and caching aggressiveness, this could be more expensive (in terms of resource usage) than the network request used to retrieve the image. From my perspective, using both and the Cache directory together doesnâ€™t add any value. They are both volatile and unpredictable (to different extents). The system could reclaim space from either when it deems it necessary. From Apples File System Programming Guide: 

Test with no cache (this will be your baseline) Test with a simple caching strategy (maybe just using or the Cache directory) Compare the results of step 2 to your baseline obtained from step 1 Not satisfied, then apply a different caching strategy. Repeat step 3. Otherwise, if you are satisfied with the resource usage and responsiveness of the app then you can stop here until there are significant changes to either your codebase, data or the iOS frameworks. 

Someone consuming your class will get the entire public interface of . This is a lot of mental baggage that doesn't seem to be related to using class. and the concept of chat don't seem to be related at all. I would think of family of chat objects as: 

In Option #2 you cannot be sure that user of your class will pass new Object as a parameter. If you really want to create a clone of parameter you should create on yourself or implement some method on MyReferenceType 

Do not throw NullPointerException when arguments are null. NPE is thrown when you are trying to access properties and methods of null reference. Not when you are checking on some preconditions. Throw IllegalArgumentException as you do in length validation. In other method you use assertions. Chose one method and stick with it, dont mix them. You don have to define empty constructor. It is created implicitly. 

I would separate calculations of shoe sizes and distances into separate classes. It is called SRP Name your variables properly is just a random letter not a name for a variable. For methods with a lot of arguments you can use some wraping object 

EDIT Also do not put on your DAO classes but on Services. Service method describes unit of work which should be done whole or rollbacked. Consider this simple code 

What about having generic abstract dao class which will contain these methods? You will most likely have to create some concrete dao classes anyway to have specific methods. We are using this approach in our projects (behind JPA facade) 

If there is no formula to calculate shoe size from one unit to another i suggest you to put sizes in some data structure and map them together. For example in Map. Then you just query the map instead this if-else hell. Same applies to the mapping. Also i see you use Strings a lot as a constants. Consider creating enumeration of some of them. 

Why would I ever choose the Protocol + Delegate method (design 2), at least in this case? In this case... Ultimately it comes down to you design goals and the expected lifetime of your app (how long will you or someone else have to support it?). In my opinion, based on what you described, using protocols provides a more flexible design that is better prepared to handle changes down the road. 

You are also tightly coupled to the . What happens if you want to replace Parse in the future? You will likely have to throw away the implementation and create something new. Protocols Your protocol provides an abstraction for what the concept of chat means to your application. It conveys this concept without dictating its implementation. It doesn't give you working implementation, but it does score you a point for the future maintenance of your app. It gives you flexibility. With now a defined concept, other types can adopt it, filling in the details of what means to the conforming type (in this case ). Combining this with delegation (as you have), puts you on the path to a decoupled, flexible type that doesn't expose the public interface of and doesn't require your consumer to know implementation details about how Parse is being used to facilitate "chatting". "Less code is better" You don't say why this is or how you prioritize this design principle against things like readability. Is it better because its less to maintain? Less to look at? Personally I would add a couple of caveats to this statement: 

First of all name your variables properly. Name of the variable should describe what it is, but is just a random letter not a name for variable. Consider using logger instead of printing to sout. Stream closing should go to the finally block not in try. You are nesting a lot of loops and ifs. Try to separate it into methods soo you and up with 

Your method is very long. This is code smell - if method is long it maybe do a lot of thinks, but method should do one thing. I suggest you to split method into smaller peaces which defines smaller units of work and are reusable and easy to read. If you put piece of code into method you give name to the code which work as a hint to he programmer what code enclosed in method does. Also use full name of variables, not some abbreviation like . You write them once (if you are using ide) but read it multiple times so you invest the effor into the writing the proper name. I did not checked your logic. Your logic should be captured in unit test - if there is no unit test i would hesitate to refactor some code. If there is no unit test dont write them now if you dont have business requirements, but you ca try Characterization testing to capture current behavior of the method. Because without any test you cannot be sure if you did not broke something when rewriting the method. 

What is a large number? How much is too many? You will have to test and measure. Test & Measure (and then measure again) I would definitely recommend testing and measuring your caching strategy to see how much of an impact it has. Xcode instruments provides tools to accomplish this. One way to go about this is: 

The Details Let me expand on my answer by first saying that Inheritance vs. Composition type discussions are subjective and are debated amongst developers of various languages. There are many blogs, articles and posts on StackExchange sites that cover the debate. Also, since we are talking Swift, I would highly recommend taking a look at this WWDC session: Protocol-Oriented Programming in Swift $URL$ I highlight this session because instead of Inheritance vs. Composition, we should be discussing Inheritance vs. Protocols. Why? Because not only do protocols allow you to do composition, they also provide other features that let you model things in interesting and flexible ways. I would also like to point out that this question is challenging to answer (though I think it is a good question), because you have two seemingly working implementations in the present, but your design choices may not reveal their true cost until some unknown time in the future. This is where the advice based on the experiences of others will inevitably reveal itself but at the same time seem subjective if you cannot relate to their experiences. Inheritance Is really a ? According to Parse documentation: