Simply calling a machine a DNS server does not make it one. Try (google's free public ones). If that works, you could try the actual router address (can't promise it will work, but it might), or if you want to get fancy, transfer the from the master after the connection is established (maybe scripts can do that). If dhcpd turns out to be running on the slave it may complicate this and you probably want to disable that as it serves no purpose. 

Within about 30 seconds it should have told you you have a lease and an IP number, then it will go to the background and return the command line. Check with ; you should see wlan0 listed with that IP address. 

However, raspbian-ua-netinst doesn't work this way and will not refer to the location of a root filesystem, because it uses an initramfs file -- actually there are two of them to match the two kernels (one for the ARMv6 models and one for the ARMv7/8 models); kernels can be built with the relative path of this file hardcoded into them. These are the files. If you are installing from windows, you will have downloaded and extracted a file. Make sure everything including those files is correctly copied onto the card. 

However, if that file, as you hypothesize, was generated by the also missing , then it won't be found -- I get nothing on a stock Debian stretch arm system, but something here may be peculiar to Raspbian (or something that disappeared in stretch, aka. v.9, if you are using a new image compared to your other systems). by default looks for literal matches, but will do a pcre match, according to which surprisingly few things add to . A great many things, though, match . Fed through I get nothing again -- but this may still be a Raspbian peculiarity. You could try stuff like: 

A service started by init (which in the case of Raspbian and most other current GNU/Linux is systemd) is presumed to be a background process, unless special arrangements are made. A process which does not appropriately fork to the background within a small amount of time (seconds) will generally be killed by init. What you describe is appropriate to a background process, but it sounds as if it is being run in the foreground like this: 

The card would be just , and that's what you should use there. I don't think that's a complete explanation, but hopefully it will help. You should also check if there's "lock" switch on it. I think the pi will ignore that (those switches don't really do anything, they're just observable by the OS via the hardware), but your other computer might be. 

Yes, but just to be clear, you are creating the image in a file. Obviously that file has to be stored somewhere, and a USB stick should be fine for that. In addition, because that file is then formatted as a device image containing several partitions with filesystems that are independently formatted and mounted, the filesystem on the stick doesn't have to be the same, or anything in particular. In other words, you could use a standard, preformatted (FAT32, whatever) USB stick and create the device image file there. 

Maybe; what it literally sounds like is there is a problem with the C library. That could be due to filesystem corruption. It could also have to do with having replaced it... There are two partitions on the SD card. The second one is the one with the (potentially) corrupt filesystem. To check it, put the SD card in a linux box and use . If that shows a lot of issues, let fix everything it can, run it again to be sure, and then try the card in the pi. If didn't show any errors, or repairing the fs does not solve the problem, try . On raspbian, the output should reference only the man page (), since the actual library is outside of the normal search path. The only other thing and have in common is libdl, which would have been very weird to have messed with. 

Whatever's gone wrong here is not caused simply by the power suddenly dying. What it might well be caused by, though, is the slow drop in voltage that occurs when the power runs out. This presumably could cause problems on a hardware level, so setting the card RO won't make any difference. However, I could not find anything conclusive online regarding this possibility; some people claim that SD cards are not prone to this issue because they are built for battery powered devices. 

No CMA configuration, etc. This is my preference, and I can plug in an HDMI monitor and start X. Most of the memory needed to run a GUI desktop is actually CPU memory. In short, you don't need much gpu mem at all1 -- certainly the display will work with much less than the default 64 MB -- and you don't need two configurations. 

You're not the only person to have done this kind of thing; I'm sure I've noticed a few people complaining about having broken the SD card slot off altogether. Someone has instructions for replacing it. I imagine you don't want or have to go that far, but it may provide some insight -- if you are having to press down, it could be that one of the connections has come loose, and levering the card forces them together. If so, it might be easily resoldered. 

You'll need privileges for that (e.g., via ). That will take a few minutes. When it's done, it's done, just put it in the pi and plug in the power (which reminds me, in case this wasn't made clear anywhere -- don't be sticking the card in and out while the pi is plugged in). You could also check that everything worked first by mounting the partitions.2 You might have to take the card out and put it back in for them to be recognized. There should now be two partitions on the device, so if it was , there's now an and a as well. 

It's not clear from your question whether the C program is intended to act as the CGI executable or not. However, if it is, you haven't fulfilled the CGI interface. A CGI executable must output (via ) a properly formatted HTTP response. There are various C libraries for helping with CGI, although it is not necessary that you use one. CGI passes information from the server via environment variables, which you can access with functions such as . Here is a GNU lib C guide to environment access; note the interface itself is ISO Standard C. If the C program is not suppose to handle the CGI stuff, it is not the problem. "Premature end of script headers" indicates that whatever is doing the CGI stuff hasn't properly formatted the HTTP response. 

Both SD cards are defunct This would be a crazy coincidence, but not completely impossible, of course. Presuming you bought them new for this purpose, based on what you are saying about the purpose, they can't be worn out at this point, regardless of whether you used them ro or rw. Unless we consider the elephant in the room, possibility #2... Corruption due to low voltage Setting the card RO will prevent the chance of minor corruption due to sudden power loss -- this happens because the filesystem is left in an inconsistent state by the OS. You can also prevent it by running intermittently, or by using the sync mount option. In any case, this kind of corruption is: 

1. I discovered this by trying with the HDMI unplugged, which also works -- but then plugging the cable in after boot causes a problem with the display resolution, so I tried this plug and unplug with no power and voila. Again, it is very consistent. 

Note that you still have to enable the camera, which is a matter of adding to and explicitly committing at least 128 MB of RAM to the GPU. 

The GPIO itself can be pulled to ground externally by whatever it is attached to, of course, but if you are suggesting you attach a live lead to the GPIO and then send that to ground internally, you cannot. Note that anything you do attach to a GPIO should not exceed 3.3V or you will bork your pi. Also, do not set a pin as an output and connect it to ground with no resistance. 

No. The pi does not have any power modes besides "on", which is what it is while plugged in. I believe it is capable of recieving a WOL packet if it is plugged in, but of course that won't change anything, because if it is plugged in, it is already on. Once you've shut down the system that's running on it, the system has stopped, but the pi is technically still "on", which is why you must then unplug and replug it to reboot. 

Where is the keycode you got. You can put that in whatever GUI start-up script is appropriate; that should run after the X server starts. You can enable it again: 

Yes, all this is possible but the fact that the script may include a (graphical?) user interface makes it a complicated task. I'd advise you break it down and tackle, in order: 

Yes, or at least, what it is usually indicative of (but this probably won't get you too far in solving the problem). Either: 

No, it just means it's been recognized; this doesn't require any driver. However, this device ID is listed in the source for the driver. With the device plugged in, try and see if it is listed. If not, 

1. The driver does identify the hardware (, or on the Pi 2) but it will do this on, e.g., a general purpose Fedora ARM distro that includes no pi specific software. I'm mentioning this to make it clear there is nothing special about the Raspbian Xorg driver and any documentation you find around for the driver, pi oriented or not, should be applicable; witness "the hint" I found about the rotate option was from a blog about DisplayLink devices. 

According to this will "display a pattern rather than blank the video"; however, on modern systems real screen savers aren't necessary or used anymore and what will most likely happen is just nothing (i.e., the screen won't blank). You can test what will actually happen with . Alternately, you could just set the timeout value; it seems to have a maximum of 20864 (a little under 6 hours). 

The + and 2 models should be able to handle any attached USB device if the pi itself has sufficient power. Technically, USB power is supposed to be limited to 500 mA, although very often it isn't. Don't expect or depend on more than that unless you are sure it is available (for example, many powered hubs aren't regulated, and might provide up to the entire amperage of the hub's supply to one port). The model 2 when under load on all cores will draw 4-500 mA; a 3G dongle might draw 200+ mA. If your laptop limits the output correctly, then 500 mA total is not going to be enough. To confirm that, you could test by using a 1.2 or 2 amp phone charger for a while. Do check to make sure it is not less than that, some are, e.g. 700 mA, which is to tight too test this properly. The manufacturers of the pi recommend at least 1.2 A if you have anything attached.