I have a wifi adapter using the 5370 chip; actually two but they are identical. They require firmware that is in the vanilla kernel and included with Raspbian and work fine on the pi. I think the reporting via should be accurate -- this is something simple done via the USB protocol and does not require any device specific driver; the purpose is to allow the OS to identify the device so it can select an appropriate driver, if available. However, since manufacturers generally supply their own proprietary drivers for mainstream operating systems and do not claim to support anything else, they are free to do "something unorthodox" which may be what is happening here. In short there's nothing you can do about this. With regard to wifi adapters, since they are cheap and usually easy to obtain, my recommendation is (if possible) to buy something in a local, reputable electronics store that will take a return within 7 days without any hassle. First check what is available and do a bit of research, then go with the best option. 

It will show an arrow pointing to one of the above possibilities. If it is the file, you can change it the same way does: 

PL/SQL is a proprietary language owned by Oracle Corp. This is why you only see support for it in commercial RDBMS's such as Oracle itself and IBM DB2. The latter presumably pay giant licensing fees for the privilege. Any of the above could release an ARMv7 version that might work on the Pi 2, but it seems they have not. So you are out of luck. 

If it is commented out with a , remove that. Change to the name of your kernel image. If there is no such line, add it. 

If you are connecting the HD directly, keep in mind the pi USB ports don't deliver the 2.0 standard 500 mA (plus, 3.0 devices may need up to 900 mA). I.e., you probably can't use this drive directly, you will have to use a powered hub. The reason for the reboot is that there is a sudden voltage drop when you plug in the device. This is like yanking the power cord for a moment, restarting the system; I have a wifi dongle that does the same thing. Again, you won't have this problem via a hub. 

The GPIOs are not 5V logic, they are 3.3V. They may work to drive 5V inputs, but not probably not reliably. You should be able to do PWM of this sort through a level shifter, although I make no promises. 

Yes, the most obvious and straightforward way is to mount them under linux, where ext4 is the native filesystem. Keep in mind that the raspberry pi is not actually the focus of the linux world -- not including android (which uses the kernel), between 1-5% of PCs (desktops, laptops, etc), 30-40% of web servers, and 95% of the world's supercomputers run some flavor of GNU/Linux, of which Debian is a primary stream (and raspbian an offshoot of debian). So that's well into the tens of millions of users and you have plenty of options to choose from -- most of which are, like raspbian, distributed without charge. If you don't want to install linux on a PC, you could use a "Live CD". This is an install disk that boots a normal, running OS from a CD or DVD so you can try it out. It doesn't actually install anything unless you ask it too, and they are generally useful for doing recovery things -- you could certainly mount the SD card. Most distributions, including debian, have a live DVD (nb. Intel 64-bit architecture is part of the 'amd64' stream for debian; other distros call it 'x86_64'). You just download the .iso image and burn it onto a disk. Note you do not have to use debian, and you can generally presume that any install disk you download will work as a live disk, including ubuntu and fedora. Running from a DVD can be a little slow but it should be fine if you just want to check the SD card in an environment that is actually equipped to repair something if necessary (mostly meaning: you can run on the partition). It is also very easy -- again, just download the .iso, burn the disk, boot it. You can also do this with a USB stick. Running a live CD doesn't allow you to save a configuration of anything, etc. however. A popular choice in recent years, now we all have beefy multi-core systems that can do it smoothly, is to run a virtual machine with linux inside windows or OSX, so that you do not actually have to install it to a partition or boot it, but you can maintain the system on a hard drive. Finally, while Microsoft and Apple are evidently adverse to including ext4 support (there's nothing stopping them from doing so), it is not impossible to get it there (I can't endorse any of those methods as I have not tried them, but there must be something stable around). However, again, you will not be able to repair the filesystem that way. 

So it may not the best choice to use as a headed system (display and input devices attached) for a child. However, it's perfectly feasible to do what you want. 

The next time you see it, find out what process it is. Fortunately, there's a pid in the message (), so the name and some other details can be elicited with: 

Easily done and there are various ways to do it, as mentioned the general concept is "kiosk" but I will warn you that the quality and value of material with this label varies greatly. Any mainstream pi oriented GNU/Linux OS distro will do (Windows IoT is I think a bit more challenging in this context); since Raspbian is the most common one it is probably also the easiest. The exact method you choose is up to you. Mainstream HTTP servers such as apache, nginx, and node.js are capable and available. There are others. Excluding the actual web content, not much in the way of programming is required, it is mostly about configuration of the init system, (systemd), and the server software itself. 

Which leaves a file, . Now, figure out which device node your SD card is. It will probably be, e.g., or . It is not or , etc. Those are partitions on a device -- you can tell because they end with a number. Do not write to a partition, write to the entire device (, not ). 

Note that refers to the audio output (see `omxplayer --help). The video output will be the active one for the system. Making the composite active may be as simple as plugging it in, unplugging the HDMI, and rebooting. If that does not work, or you want a more detailed answer to the question, How do I select the active video output? then ask that as a separate question. 

Give it about 10-15s. That will run in the foreground so you will now need to open a second terminal and run: 

The makes this a system group. Next we want to set (used by tshark) so that it can only be used by people in that group: 

I think 8 processes doing this every two seconds will amount to something more like an "infinitesimal" load on the system. It depends a bit on how much they are reading from the file, but the bottleneck is (on the surface) I/O and so even 8 processes busy constantly reading from the SD card won't consume significant processor time; they all have to share the same bottleneck, and even at the theoretical maximum (25 MB/s) data coming from the SD card comes much slower than it does from, e.g., main memory, or could be run through the processor -- although this is also dependent on how much processing you have to do to it. I'm guessing the volume of data is actually going to be small, so that won't matter much either. If it is say, < 1 kB, then that is 4 kB/s, and if you have a slow SD card (say 8 MB/s) that's still only 0.0005% of the available bandwidth. The SD card uses DMA, so the CPU will be mostly free to do other things (such as processing read data), or nothing during that time. However, presuming you haven't used 100% of your free RAM, if this data is being read and written that often and it is not hundreds of MB in size, it will end up in the page cache, so you actually won't be reading and writing constantly from the SD card. That will just be synced periodically by the system. Of course, if you want to ensure they are using RAM and not slower storage, and the information does not have to persist across reboots, put the file in or another tmpfs backed location (you can see the existing ones with ). In case that is not clear, those are in RAM to start with. Caveat Your one much more real issue will be concurrent access, so if you use files you will should implement file locking. On linux this is voluntary, meaning all parties need to implement it to work. The native system call is (see ; the is important) which will have a wrapper version in most higher level languages; certainly python and php, anyway. 

Not unless you are running a kernel and OS userland compiled for ARMv8; there are at least a few such things for the Pi 3 around, including Fedora. For some hints about why there still isn't a special version of Raspbian, see here: Raspbian moving to 64-bit mode Otherwise, I think the only relevance is in what the processor reports itself as, which can be found via . Some people use this as a means of telling one model of pi from another, although the practice is obviously not widespread. Put another way, unless you know of a reason to do so, there isn't one. 

Unfortunately, finding what options there are requires more digging. On other linux, systemd based systems works, but it doesn't show me anything on Raspbian. There are quite a few different dvorak layouts, but probably the first two I'd try would be: 

That swaps the sort order of the files. Now run and check your executable w/ again, you should get the link to . 

No. Although ethernet jacks are commonly referred to as RJ45 jacks because they have similar characteristics, including a more or less identical looking connector, they in fact are not the same as the RJ45 jacks used in telephone systems. From wikipedia: 

This may or may not help much. If it could be arranged such that the software displaying the image were able to prep it for load before the X server started, i.e., while the boot splash is still visible, that would probably be the most optimal mechanism. But as far as I know it is not, so there is bound to be a least a moment or two of nothing. 

USB is not a symmetrical protocol, meaning, it is not peer to peer the way, e.g., IP networking is (it might be considered to resemble higher level client-server network protocols). A USB hub/controller (they are internal) and the ports connected to it (the jacks you see) are either masters (aka. hosts) or slaves (aka. clients). A slave connects to a master. A master does not connect to another master, and a slave does not connect to another slave (there is a sort of exception to this, keep reading). Because connecting two masters together can cause potential damage due to the fact that part of the master-slave relation is that the master may provide power, usually master ports are the standard size jack you find on your computer or laptop, and slave ports are smaller (mini or micro), although this is not necessary. Some have OTG capability, allowing them to act as slave or (a sort of) master; smartphones and tablets often have this, as does the Pi Zero, which can be connected directly to a normal computer host port (although it's used to mimic an ethernet, not UART serial connection). You probably have not communicated from your laptop to your desktop via USB for the reasons already mentioned. First, it will never work, and second, it may damage one or the other permanently. Note that there are special USB cables that will allow you to circumvent this but they are an oddity and not well (or: not at all) supported on the Pi. Other than the Zero, Pi USB jacks are like those on a normal computer (I believe the A/A+ may also be used in OTG client mode) -- they are masters and cannot be connected to another master. This makes them more useful for general purposes, such as connecting slave devices like keyboards, mice, hard drives, etc. 

The kernel makes its decision based on some algorithm that generally selects the process with the largest amount of memory consumed, the point being to free up as much memory as possible. However, this does not always stop the "culprit", which may be, for example, something which rapidly forks or balloons when not much was left. It is worth observing that there may not really be any culprit other than the one between chair and keyboard -- everything is behaving as it is supposed to, but you are asking for too much. At the end of the table you will find the decision made, where is a pid and is the name of the process. Again, this does not necessarily indicate misbehavior, however, if something is misbehaving and that was not it, the OOM condition will probably reoccur quickly and you will find another table further on. By evaluating these you should be able to figure out the details of what happened. To be clear: The intention of the OOM killer is not to disable the system. It is to free up memory in order to restore normal operation. This is not always effective, and the slow down created by the OOM condition may have triggered the watchdog (which is effective, at least in terms of restarting the system). To help prevent or diagnose the issue in the future, you could use a monitor such as or . For the long term (e.g., on a server), you could try monitoring specific processes with plog. 

This is a not good, as in [, sign; it may have to do with a driver, possibly the driver for the Pi's SMSC ethernet controller, probably something more obscure since it likely isn't something that's affected many people. Those console messages are from the kernel, and that final one only occurs once in the kernel source, in (bare with me for a bit if this is beginning to sound like gobbledygook). It's been around for at least a decade (probably closer to two) but there are surprisingly few references to it either in the linux kernel mailing list archive or online generally (and literally only a couple associated with "raspberry"). The "idle task" is one that runs when there's nothing else to do. Tasks, including this one, can be pre-empted so the CPU can be used to do something more urgent; they can also make themselves inactive (aka. idle), so something else can happen -- but not this one, because it's already "the idle task". It can't claim it has nothing to do, because it's what's supposed to happen when everything else has already said that. It should just keep doing nothing until pre-empted. However, a kernelspace programming error could produce a situation where the idle task does claim it's not busy and should be made inactive. Since that is definitely not supposed to happen, the idle task then reports this error and produces a stack trace, which is a list of references to recently executed code leading up the problem. That's all the stuff before the "bad" message". Stack traces lead into the past, so the last thing there is the earliest thing to happen (nb., the message timestamps on the left have nothing to do with that). At the top of the screen there's some references to the TCP/IP networking module, and further up would be whatever actually triggered the error (which is why I'm guessing the ethernet driver, but that is not necessarily so). I can't say whether this error in itself should be fatal to the system but it could, and is at least related to the chain of events. Anyway... Looking at the timestamps on the left (seconds since boot, looks like 3-4 days), that stack trace took at least a second to produce and hopefully it or something relevant that happened right before it got logged. Although the new version of Raspbian (8) uses a new logger (journald) in addition to the old logger (rsyslogd), all versions still use the latter to log everything in plain text to , including stuff from the kernel. Everything in syslog has a dated timestamp; for the kernel stuff this is in addition to the seconds since boot. E.g.,