Show me the method without a name and ask what it should be called, and I would say . The name implies that this is called in response to the street view being shown, so it makes no sense that it should itself hide or show the street view. I suspect that it's actually an autogenerated name for a button or checkbox called , but autogenerated names are not always useful names. 

Why ? Firstly, since nothing in the calling code cares about it being a , the principle of coding to the interface rather than the implementation says that this method should return an . Secondly, the use of rather than is inconsistent with the method body. I personally prefer to use the keywords for those types which have them, but this is again a matter of taste. 

The reason that returns itself is so that you can chain calls: . If you just want to mutate the contents it's not necessary to do anything with the return value. 

In Java the point of (if it were necessary, which it isn't, because that's imported implicitly) would be to allow you to write instead of . Maybe that's a difference between Java and Processing, and this is definitely a case of the blind leading the blind, but if you're not certain that you've got it right then check whether you need the namespace on the actual invocations. 

Yes. is one of those mistakes that everyone recognises is a mistake, but is so deeply embedded in so many libraries and tools that it's a pain in the neck to eradicate. 

is unnecessarily complicated. You know , so you can reduce and to one variable, with a more informative name (e.g. ): 

There's a mixture of -style loops and indexed loops which don't appear to use the variable for anything other than a single at the start. Could they all be loops? 

As for , the purist OO way of doing it would be to have subclasses and . But if you're not going to take the purist approach, you should at least have a clear way to distinguish the two cases. At present it seems that I have to choose whether to test or . Actually, it's worse than that, because it's possible that the instance isn't yet initialised and has neither success nor error. Perhaps the builder pattern would be worth employing. 

For a start, 25% of that code is dead code: neither of the two debugging functions is actually called. I'm not going to bother reviewing them. But I also see 

The scope of is the loop, so by pushing in the definition you improve readability. (And since it's only used once, and in a simple expression, you could even eliminate it entirely). 

All of those variables are used precisely once. Why not inline them? What is the identity of a chess man? I would say it's colour and type. Its location at any given time is a property of the game, not the man, so I don't understand why locations are being passed into the constructors, nor why the men are not being added to a 2D board structure (perhaps encapsulated by the class). 

Ok, so it seems this should be called (or if you prefer). To be honest, I think that should be a method of rather than , but that's by the by. I see that it has a return value. Why did the main loop completely ignore it? 

This looks like a bit much for a single loop body. Why not split the input processing into a function? 

If is the registration page then (a) it seems rather lacking in content; and (b) there seems to be a catch-22 with rendering it for the first time in order to submit data. 

What purpose does this serve? It seems to me to introduce a bug, because the spec does not ask for falsy elements of to be ignored. 

The code which follows looks like a linear search, not a binary one. Is this comment a statement of intention which was forgotten when the code gave the right answer? 

I don't see anything in there which forces the use of TLS (HTTPS). It could be that you're certain that the page can only be accessed over TLS, but even so it's good practice to double-check. The reason for using TLS on login pages is that it prevents the password from being sent in plaintext (e.g. readable by anyone on the same wifi network). If TLS just isn't an option, you can at least use HTTP digest authentication. MD5 isn't considered particularly strong any more, but it's better than nothing. See Apache's mod_auth_digest. As a bonus, you can replace your session include file and login page with a trivial password file and a couple of lines of Apache config. 

WTF? That comment is more confusing than explanatory. What is the "this" of "anywhere this appears"? doesn't even need to exist outside the loop. 

I don't believe that Python style guides prohibit early returns, and it's easier to understand what an early return is doing than an assignment to a variable which then isn't used again for a long time. Also, this is buggy. Consider the test case , which should return . In fact, it should be obvious that it's wrong because it doesn't return the same type as the case. One branch returns a list of strings, and the other a list of sets of strings. 

is presumably intended to be a speed optimisation, but I don't think it makes much difference. At each layer you will recover the previous layer anyway because the permutations have order 2 by construction, and so are self-inverse. (On timing it to check: removing that step takes us from 75s to 85s, but allows adding in an early return when which reduces the runtime to 14s). 

isn't even consistent within the same line about whether should have spaces on both sides or not. I'm surprised your editor didn't auto-format it. There is also a wide variety of whitespace in the strings which are used to prompt for input. Also in this category, 

This is a matter where opinions will certainly differ, but I would prefer to instead assign as is never used again, and the real purpose of this line is to coerce the input to the type which you want to receive. 

Alternatively, working forwards, if the points are (, etc.) then the sharpness condition is that $$\widehat{Q-P} \cdot \widehat{R-Q} < \frac{1}{\sqrt 2}$$ which is equivalent to $$(Q-P) \cdot (R-Q) < \frac{\sqrt{(Q-P)\cdot(Q-P)} \sqrt{(R-Q) \cdot (R-Q)}}{\sqrt 2}$$ corresponding to 

Two things: Firstly, a statement at the end of a loop does precisely nothing. This code is directly equivalent to 

I see cropping up a lot, and it makes for some unreadable lines of code. That should definitely be pulled into a method as a starting point for possible refactoring to merge conversion methods which are always used together. provides an operator overload for . 

An clause here would not change the asymptotic complexity of your solution, but it would surely make it much faster in many test cases. 

This looks like a showstopper bug to me. I think you need to store unused key stream between invocations of .