You may want to change the y to say y + sprite_width/2 (or - depending on your coordinate system) so that it checks to the left of the middle your sprite instead of the top (or bottom). This is how N implements wall checks for wall jumping (last paragraph). After that you must decide on how tight you want your wall jump. If the vertical velocity of your jump overcomes the horizontal before the player is able to reach that same wall again, you will not be able to wall jump up the same wall and will gradually fall back to the bottom (like in Mario games with wall jumping). If you do allow the horizontal to be weak enough for the player to get back to the wall, he/she will be able to progress up the wall (like in Meat Boy). Another approach not mentioned is Super Metroid's. In that game when you are against a wall, if you move off that wall a very short "moving off wall" animation will play. If you jump during that animation, you will do a wall jump. (Super Metroid also allows a player to climb up a wall using wall jumps, but it requires a bit of skill (in fact everything about wall jumping in Super Metroid requires a fair bit of skill...).) 

To stop the mace from looping (and only swing once when the animation is played), in your last picture there's a checkbox called "Loop Time" (first checkbox). Unclick that. 

I just implemented in C a way to calculate the angle between two vectors A,B, given an origin C. Look at this Wikipedia article to understand where I am coming from. Here's the pseudo-code: 

I've recently come across GWT (Google Web Toolkit) and have been amazed by it. I was wondering if anyone has ever put it to use making a video game? And if they did, what their experience was, whether it was worth it and whether the game was any good. 

Another method (which I answered the question Byte56 linked to) would be to check if the collision resolution puts the character in an empty spot or not. So in your problem, you get a collision from the inside rectangle's ceiling to move it up, which would be illegal (as you're still in collision with another tile). Instead you only move it if it you're moved into a free space (such as how the collision from the upper tile would move you to the left), and once you find that collision, you are done. The answer I gave had code, but it became overly complicated. I'd keep track of all collisions within that timeframe and only take the one which lead to a free space. However if there were none, I think I resorted to resetting the character's position to its last position, however that's really ugly and maybe you would rather try implementing something like the original Mario where he just moves in one direction or something when no free space resolution is possible. Also you could sort that list of collision resolutions and only move to the freespace with the shortest distance (I think that solution would be the most preferable, although I didn't code for that). 

Save game to a temporary buffer. Discard all game state and loaded scripts. Load new version of scripts. Load game from buffer. 

(Similar problems can happen when trying to collide against meshes, since meshes specify surface rather than volume.) You should also consider whether you really need more than one box to get the gameplay effects you're looking for. This is all largely speculation since you haven't specified what your collision shape is in detail. 

is a little tricky: it is a shortcut to rotate a 2D vector by 90 degrees. If you're working in 3D vectors, then you'll probably use a "rotate about the Z axis" function instead. It doesn't matter how you do it as long as the resulting vector is perpendicular to the input (if it isn't, the wave will be skewed, which might be an interesting effect). 

I think you are probably wrong here. Rendering chunks separately creates many opportunities for saving effort, and doing what you're doing has the cost of shifting large amounts of data around. Could you explain what optimization you are trying to make possible? 

If you have a higher-resolution image of your “tube” than your example suggests, then the solution is a matter of very basic image-processing. The first thing to try to generate the glow would be a Gaussian blur of your “tube” shape. Then draw the blur output (possibly with a brightness adjustment) followed by the tubes. If you find that the glow is too weak, or if you are working with very thin lines, try a morphological dilate operation before the blur (possibly even applying it to the tubes to thicken them). Combinations of these and related effects, as well as small offsets, can also automatically generate a decent impression of a shiny glass tube. All of the above are standard image-processing operators and any decent image-processing library should make it easy to perform them. 

This is just the special case of collision response for axis-aligned surfaces; non-axis-aligned surfaces would need dot products and projections with the surface normal, but here they all simplify to modifying a single axis. It's a special case of the same thing. 

Java applets are used for embedding Java applications in web pages. You should create an applet if, and only if, you are intending to do that — to provide your users a GUI written in Java which requires them to have a JRE installed on their computer. From your other descriptions, it sounds like you are supposed to be making a web app — the game logic resides on your web server, and the interface is implemented in HTML and JavaScript. There are no applets involved here. This generally results in a more widely compatible and faster-loading interface. However, the HTTP request/response model means that it is more complex to build simple interactive interfaces robustly. Personally, I would recommend reading up on the architecture of web applications before attempting to write one which is a game. 

This is probably not what you are doing though). If you want all obj_carrier's to create a bullet at once, you can do: 

I hope that's not too confusing. I've slapped together a GM:S example for you to look at (it works! although it's kind of ugly and there's no sound or polish and losing all your lives or killing all the clowns doesn't mean anything) 

), and destroy itself (so the clown is gone). In obj_controller's End Step event, check if is true and is false. This means there has been a click somewheres that isn't a clown (because the clown would've told it that the hit was good) and we can decrement a life 

(I hope it's simple to follow, because I'm sure there are better ways to implement it...) isCollision(Rectangle) is literally just a call to XNA's Rectangle.Intersects(Rectangle). I've tested this with moving platforms and it seems to work fine. I'll do some more tests more similar to your .gif to make sure and report back if it doesn't work. 

I have a few questions before I start answering this. First, in the original bug in which you got stuck in the walls, were those tiles on the left individual tiles as opposed to one large tile? And if they were, was the player getting stuck in between them? If yes to both those questions, just make sure your new position is valid. That means you'll have to check if there's a collision on where your telling the player to move. So solve the minimum displacement as described below, and then move your player based on that only if he can move there. Almost too under the nose :P This will actually introduce another bug, which I call "corner cases". Essentially in terms of corners (like the bottom left where the horizontal spikes come out in your .gif, but if there were no spikes) would not resolve a collision, because it would think that none of the resolutions you generate lead to a valid position. To solve this, simply keep a bool of whether the collision has been resolved, as well as a list of all the minimum penetration resolutions. Afterwards, if the collision has not been resolved, loop over every resolution you generated, and keep track of the maximum X and maximum Y resolutions (the maximums don't have to come from the same resolution). Then resolve the collision on those maximums. This seems to solve all your problems as well as the ones I've encountered. Here's the code I use in my update: 

What you have described is entirely adequate and appropriate to provide resolution independence. Anything you draw will indeed always take up the same proportion of your window. However, if you do nothing more than this, you will have aspect ratio problems. For example, given the numbers you wrote, if you draw a circle, it will be squashed — wider than it is tall, because your horizontal scale is 800/(50+50) = 8 and your vertical scale is 600/(50+50) = 6. There cannot be any automatic solution to this problem; you will have to choose what graphical result you want, and consider its effect on the gameplay. Some common examples: 

The four-variable representation of a plane is the coefficients in the equality ax + by + cz = d This can be seen as N = (a, b, c) being a normal vector and d being a distance from the coordinate origin (in units of the-length-of-N), and we can also write this equation as N·P = d, where P = (x, y, z). This representation does not allow defining a specific “origin of the plane” — mathematical planes don't have origins. (However, it happens that since N·P = d we can set P = (d|N|-2)N and get a specific point on the plane: the point which is nearest the origin of the coordinate system.) If you change the = to < or >, you describe a "half-space", which can be used for things such as an infinite floor in a physics engine; the opposite half-space is obtained by negating both N and d. 

It sounds like you're writing a Minecraft-style engine (infinite random voxel terrain, height limit w/ terrain at halfway point, chunks). So am I: here's my code. My world is not infinite, but the rendering subsystem doesn't care about that — it breaks things into chunks itself and never looks at the entirety of the world (other than for fast indexing). Rendering chunks individually means that when a block is updated and needs to be rerendered, only the one chunk's geometry needs to be recalculated (for new hidden surface removal, etc.). If I were to try to render the entire visible world together, I would have to rebuild the entire vertex array whenever the camera moved (at great expense) because the newly-visible terrain doesn't necessarily have the same number of vertices as the newly-hidden (opposite camera motion direction) terrain. Furthermore, per-frame I test each chunk's bounding box against the view frustum, which is a cheap test which greatly reduces the cost of the invisible parts of a complex scene. (Note: I am working in JavaScript (and WebGL), so my work is somewhat more CPU-bound than yours probably is.) 

At this moment, I can only display text once I stop updating and drawing sprites. In the code below (which is actually the game loop), you can see how if (gameloop stops drawing), the text "Game Over!" is displayed. But if I try to display any text while drawing and updating, it doesn't appears until I stop drawing the sprites. In fact, the frist block to display text ("My Game!") isn't shown, as I said, until the gameloop stops drawing. I need to display some info like, name of char, instructions, etc while the game is running, so, how can I render text in every loops and frames? The game loop: 

I'm trying to develop a simple game made with Pygame (Python library). I have a object which's the and I move it using arrow keys. If I don't move the mouse, the sprite moves normally, but when I move the mouse, the sprite moves faster (like x2 or x3). The object is inside the var. I've run the game in W7 and in Ubuntu. Same thing happens in both OS. I have more entities which move like NPCs and bullets but they don't get affected, just the player. Given this, I think that the problem maybe has a direct connection with the player moving system (arrow keys). Here is the method of the object: 

I don't know what more you can need to help me, but anything you need (more info or code) just ask for it! 

I'm making a game and I have almost finished it, but I'm usually finding the error when I iterate a sprite group. This is an example and the group is : 

I have a Player sprite (40x40 pixels) and Tiles (20x20 pixels) which build the terrain. At the 4 edges there are 2 rows or columns (depends on vertical or horizontal) of wall tiles. Those are the limits which the player should not be able to overpass and collisions player-wall are checked there. Most of times, it recognizes collisions, but sometimes it doesn't. When I move the player until the map limit and it hits the wall tile, it stops, but sometimes if I continue trying to move it against the wall, it doesn't respect the collision and enters in the wall. At this point, once the player enters in the wall tile it can only moves over wall tiles... So, am I doing something wrong or is it just a pygame collisions bug? Here is the method to check collisions: 

The group has 4 sprites (tiles) and I'm checking collision between my player and those 4 tiles to go to the next stage but I have to be doing something wrong iterating the sprite group because (I don't know why) it becomes recursive and raises the maximum recursion depth runtime error. I've debugged it and when it reaches the line, it loops a lot of times there (althought there are only 4 sprites in that group). I know I can increase the recursion depth, but probably it's better to not play with that and try to improve the code. So, what am I doing wrong? Is there another better way to interate a sprite group to check collisions?