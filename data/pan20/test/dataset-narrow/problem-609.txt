Then you could actually use 'correctly' as it will return false when you get to the end. To be completely and brutally honest, I'd still rage erase all of this code if I found it in a project I worked on. Why is it an enumerator of booleans? None of it's particularly obvious. As an aside: 

Note that I've fixed your typo (Implentation -> Implementation) and have removed the return type that was never used. 

I've had to do this exact thing before, your way is absolutely fine but I went for the other way round - checking if it was all text: 

That way you won't flatten the whole tree first. Edit: It's more difficult to talk about things so let's look at some code. SelectMany is roughly equal to: 

Use the normal cast when you know it's going to succeed: should be . I'll probably come back later and review a bit more. 

Dead code Kill it. If you have some commented out code that you aren't using just delete it. It adds noise to the reader and doesn't add anything to the code. Not to mention factorial is an incredibly simple thing to add back in: 

Do you know about radians? (and the other trig functions in .Net) are based on radians not degrees. radians is roughly in degrees. Which is a bit odd... There are radians in a circle so 1 degree is . As long as you use the same value the lines will be parallel anyway but I thought it was worth pointing out. Why do you need the Cos at all? You have a line from (x1, y1) to (x2, y2) with length . You know that you need to offset the line by an amount () orthogonal to the current line. 

Why have you chosen for the Type parameter? It's a small thing, but most people would expect to see . Try to stick with convention where you can. 

Edit: As Peter Taylor pointed out in the comments, you can take the logic further to incrementing by 2520 each time because the final solution needs to be divisible by all the numbers 1-10. However, the main thrust of my answer was supposed to be that you don't need to brute force and you can compute the solution directly. 

You have another problem - a captive dependency. You have a Singleton (as it's static) that holds a reference to a unit of work (through the settings service) which shouldn't be kept alive for the lifetime of the application IMO. 

Get exclusive access to the buffer (slow) Add a character to the buffer Increment a shared field (in a potentially dangerous way) Release the buffer (slow) Potentially throw and catch an exception 

No that isn't right. If your query throws an error you won't be closing the connection. Swallowing exceptions like that (even though you're logging it) is generally bad as well. How does the user know anything has gone wrong? If you can, just use and with a using: 

I've guessed that the parameter was actually the rotation speed from a comment in the method that calls it. You need to improve your naming throughout. Your code is very simple but is very difficult to follow simply because the naming is so poor. 

This looks good! I've got a couple of comments to make in a vague, hand wavy way so I'll start off with a comment about the code as written: 

The handles all of the encoding for you so you don't need to worry about doing it the right way. You just create the name value collection and any null/empty values will just be skipped in the method. Update As svick has pointed out in the comments it might not be ideal to use an internal class in this way. I think the risk of the implementation changing is quite low but it is a risk and should be thought about. 

Here they don't return the jQuery object, since this utility is for arrays. My point here is that there's no one shoe fits all. It depends on what you're trying to get from your plugin. Also chaining is expected but not on something like $.map(). Also keep in mind, in your callbacks should refer to the element in question (ie. in a click callback refers to the clicked element). If you're not playing with an element, should refer to the global(window) object. 

You'll see several variations of this all over the internet as you read to find out more. The one I recommend you use in this case is like this: 

Here are some quite general pointers on your code. If you put up a fiddle with everything working, I might be able to play around and re-write this for you. But anyways, I've included my comments directly into the code to provide some context: 

As a rule of thumb, when you use a jQuery selection more than once, you should cache its value. When you do , jQuery now has to go find that element in the DOM, wrap it in the jQuery object and return it. If you save what it returns, then you only do the search once - not every time you use it. The hard part is caching . This is relative to where you are in the code, function, callback, etc. and changes to provide context. For example: 

I wouldn't rely on to protect your code from other libraries that use the as well. - Click Event Handler: As was mentioned before, there are several ways to set up your events. The ones that were mentioned were and . The method simply calls the method and passes in the click. The method is incredibly useful since you can use it to set up almost any kind of event - not only clicks. So yes, the one you are using now is "the best" because it saves you a function call. Now saving a single function call in your app won't be a significant increase in performance and you probably won't even notice it. Although arguing over such a small and possibly insignificant changes is really what we developers do best. Using the method directly is hands down going to be faster, but there are many other things you could be spending your time on that will generate more significant performance results. - Don't re-invent the wheel: I strongly believe that if there's a working solution out there by all means use it. There are tons of tabs and accordion plugins available I'm sure you can find one that fits your project. If you can't find an exact fit, you can still always tweak it and make it fit. jQuery it self has an entire UI package with tabs, accordions, sliders, and all kinds of cool stuff just ready and waiting to be used. Also the jQuery UI will let you use your own CSS files and customizations really easily. Making a whole new app from scratch should be done if absolutely necessary, or if you're trying to learn (which is your case). Back to the subject of learning, like you said, you are just starting out with jQuery, and with that I highly recommend this screencast by Jeffrey Way called 30 Days to Learn jQuery. He does a really good job of explain some basic principals as well as some more complex concepts. One thing in specific I'm going to point out is the following: 

That just makes the syntax so easy to remember as well as provide you with enormous control over your events. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how they are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you understand how it works and you can contribute to jQuery. 

There is no need to store result of calculations to local variable if you return it immidiately. So you can write just 

Also, can you say what purpose of ? :) You perform swapping of array elements many times and repeat the same code in all these places (loops commented as shuffle arrays). Define the method and use it: 

I would return from . It is more general approach. User will decide then what collection he want â€“ array, or something else. You even don't need to check whether contains elements or not. 

It is a matter of taste but it is more common for C# to place opening curly braces on the next line: 

How should I exit from your program? Alt+F4? You run endless loop without any but with multiple statements that return me to endless loop again. You shoud avoid since it makes hard to understand your program flow. 

you have no thoughts to rewrite it by eliminating repeated calculations and name all those constants :) 

I make conclusion that is invalid. If you want to compare string on equality ignoring case you should use : 

I suggest to not operate by "cool" words like SOLID and just improve existing code. I don't know what type constants like and of so I'll use enum for states. Your code can be simplified to (using C#7): 

Also I recommend to define all those lexems as named string constants instead of literals. In you have a long too and you can simplify it with dictionaries as well. 

you don't need since the provides method which doesn't require additional memory allocation. I recommend to use for all variables where the type is obvious from the right part of expression. I hope you'll agree that 

If some arguments of a public method is invalid you should say about it to user. The native way in .NET to say about something is wrong is an exception. So instead of returning some "invalid" value throw an exception: 

Also I would go away from and methods. In fact user don't need all the methods and properties of . I would create methods like 

will be of the type and you don't need to repeat multiple times. Read about LINQ since it is one of the greatest features of C#. 

Every time you need to check if a value is presented in a dictionary and if yes then get it, you should use the method to avoid double search of the value by key. So instead of 

Accessing of an almost always a sign of bad code. You should attach a command to your button which will execute some actions in view model. Those actions will update some properties which will raise event. It will cause controls in the view that are bound via bindings to those properties get updated. It is the correct workflow in a WPF application so you should definitely refactor your code. The first thought that come to your mind where you need perform an action on button click should be using of . Also you use view related classes inside a view model: 

Solution Methods should have PascalCased names as well so and have to be changed to and respectively. WithinSingleEditDistance You can simplify a bit your loop: 

In my opinion it's not a good style to describe relations between objects via populating some collections using magic indices. I need to look at list to know what is the . The biggest problem with your approach is if I change order of vertices inside list, the cities network will be broken. As an option you can declare enum with your cities: 

In CLS compliant version of the indexer you should check if argument is negative and cast it to without checked context: 

Also all properties in C# should have PascalCased names according to naming guidelines. So the is a bad name and you should use as well as and .