Your contains an argument . This doesn't tell me what it means, so I would suggest using a named argument. 

Now your view is coupled loose from your datasource through the intermediate repository. You might be interested in reading up on the repository pattern, for example here. Resources I don't see a statement in your code so I assume that your is held as a private field. This context class is explicitly made to be disposed after using it once so you should use it as such. In the MSDN blog I linked just before the repository is disposed instead which is also an option although I have found that wrapping all calls to the is more often used. Braces Always add your braces to your statements, even when it's just one line. It's simply too easy to make mistakes. Inline declaration This snippet 

It's very easy: you shouldn't. An interface is used to indicate that a subset of classes present common behaviour or should be considered similar in some way. In your situation there simply is no reason to make this change because all you do is change a text value in a property, which could just as easily be done by taking an argument in your constructor and keeping a backing fields which should then be used to populate the property's regex. This will result in several code optimizations: 

General note about naming: keep things descriptive. , , , etc are all bad names because they don't convey what they are about. Don't abbreviate (unless a few specific known ones like ) and keep things expressive. 

This method shouldn't be called from a context since all communication with this method should go through the controller in the first place. 

Why do you group 3 scenarios in one test? Either use a parameterized test or extract common logic and keep it separated. Nobody wants to sift through multiple test cases when one of them fails. 

There are no differences between your two options. There are a few remarks we can make about though: Consistency Keep everything consistent. There are a few reasons to change it up (for example: you can do inline initialization all the time and only initialize those in the constructor that take a constructor argument), but that's because these two situations have a significant difference. If there is no difference (for example: initializing a field to its default value) then you have to be consistent. Multiple constructors If you initialize your fields in your constructor and you add a second one, you might forget to chain them. 

Granted, this will duplicate some fields across types but it is a fairly flexible way of allowing you to define exactly what you want returned for each request. In this scenario the type is what you use in the backend and are responses for the specific situation they're responding to. Personally I like this because it allows me to easily define what should be returned when but on the other hand it does introduce quite a bit of duplication. If you feel really compelled though you could look into generating types based off annotations but that might be going down overengineeringlane perhaps. 2. Select fields based on request I see three options here: 2.1. Either you pass in a list of strings in the request which indicate which fields you are interested in and then you build a JSON response that only contains those fields. 2.2. You define a few configurations beforehand and allow the user to pick either of those which will return a response based on this configuration. This can be done with hardcoded types or through some sort of lookup service which uses reflection like your example in the question. 2.3. You don't pass in any query since it isn't really needed anyway if you're adhering to REST principles: if you want the overview of books you should query and when you want a specific book's information you query . This will already tell you what kind of information you should return. 3. Work with pagination This is also a common approach: simply return x-amount of objects and indicate in the response what "page" you're on. When you allow your API endpoint to take in this page as a parameter, you can gradually return data which solves your underlying problem: too many objects for one response. Do note that you should define some sort of order somewhere. Either the user does this or you have a default ordering, there's a lot you can customize here. A sample implementation could look like this: 

The former two are rather unclear: what is the purpose of these two images? Naming a variable by its purpose will be a lot clearer than "image" and "image2". The latter two don't follow the convention style which (as you can see) meddles with syntax markup. Also in the category of meaningful names: and are seldom meaningful. Consider making them more descriptive. Magic numbers Take for example this snippet: 

I'm noticing explicit prefixes. Typically I only do this when I have to remove ambiguity between two variables with the same name in the same scope (or when it is required to compile, of course). Adding this clutters the code a little bit more. 

I'm about to watch Vikings so here are a few quick pointers: Naming Your code contains variables named , , , etc. This tells me nothing about what that variable does. I'm not experienced with but I assume refers to an invocation. Such a variable could then be rewritten as , for example. This tells me a lot more about will also read easier when done everywhere: 

I prefer since that also takes care of.. well.. whitespace. You never know if the pesky QA departement tries something like that. 

It's time for a fun edge case! Question: what happens when you have a reaaaaaaaaally big number? I'm talking reaaaaaaallllllyyyyy big. I'm talking 308 characters big. That's right, it will be a correct value but your code will throw an when it cannot parse it as a double. Likewise: if you have characters in your string, you're going to end up with trouble as well. Though at that point, your memory will have already been depleted so it's "okay". Unless you're building something aimed at these usecases: don't fix it. I just thought it worth mentioning. 

That's it. You're done! All we need to do now is configure our mapping so it will generate the intermediate table itself: 

Consider this a thoughtreview instead of a codereview. A lot of this will depend on your scenario; both of them are viable options. How extensive are your objects? Do you have a few but with many fields or do you have many but there are only a few fields? Have you considered pagination? There are a few approaches here. 1. Thin overview, fat detail You can have your api setup like this: 

I prefer because it clearly conveys your intent of wanting an empty string, and I don't have that nagging thing in the back of my head telling me it might be a typo. 

Working my way through Algorithms, Fourth edition by Robert Sedgewick & Kevin Wayne. I implemented a generic version of the Quick-Union algorithm and added Path Compression (not described in the book) to it. Mainly I'm looking for feedback on these two aspects and whether I might have overlooked a side effect. 

I prefer to define (almost) all of my variables as and when it's a string, I use the lowercase instead of . It just feels nicer and in the case of : keeps the focus on what's important. 

Explicit visibility I don't like relying on standard visibility; explicit declaring takes away all doubts. Instead have this: 

As you noticed: it's hard to force comments when the code is written well. Once you get rid of magic values, create descriptive names for both variables and methods and make sure each method does one thing you have basically reached a so-called self-documenting code. And that's good: this is the kind of code you want to reach. However, teachers are teachers and they won't always recognize your awesomeness. Luckily for you there are two main categories of commenting. Many new programmers comment the what: "what does the code do?". These are very uninteresting comments, an example could be this: 

I would consider using the extension method: it's just more expressive than and should be no difference in performance. 

I don't know what this does exactly but I do see a problem: right now you're directly linking the presentation of your application to the codebehind. It's obvious why this is a problem when you're thinking about multiple languages: suddenly the same menu but in a different language might not work as you expect it to (I don't know the actual code that uses it). What I would suggest is the following: since you have to work with the limitations of the lack of and your content is displayed on the same page instead of spread over multiple pages, you need some centralized way to display what is shown when the selection in the menu listbox changes. I agree with your current approach but right now you limit yourself because you can't change the presentation without having to change internal workings. I propose the following solution: 

I would back it up with the actual Java conventions, but for some reason that document has been offline for almost a few weeks by now. Redundancy 

This might be a result of the mathematical nature of your code but try to keep variable names descriptive (mainly & ). Then again, if it's an acceptable usage in the problem domain it's fine of course. For loops, is often used and perfectly acceptable. on the other hand is less common and when you mix it in with a and some mathematical expressions, finding an issue (should there be one) is a hassle. 

You're just getting a document twice. If this bothers you, make it once and pass it along to those two methods. 

This line of code allows us to loop from to or or whatever length we need. In effect this means we can iterate every value inbetween. Afterwards we create our entire new string by simply calling on the generated number. The difference with your code is that it now skips every call and a whole lot of padding. 

Your naming sometimes indicates items (content) but other times menus (navigation). Considering everything is navigation-related I'd suggest renaming where necessary to something like "Menu", "MenuList", "Navigation", etc. 

This query was already executed before. In fact, this is the query you started with except now you suddenly start from the viewpoint of instead of . You still have access to in this context which is the category that you're working with. What you do here is loop over all those products in that category, look at all their categories and then take the first one that has your specified information, essentially doing work that isn't needed. I can't execute it to verify of course but I believe you can simply omit this entire clause unless I'm missing something. 

Yes, I think it can be simpler. You basically want to generate from the minimum value to the maximum value while padding zeros to make sure everything is the same length as . I think you would be better off doing something like this: 

Keep naming in mind: members are UpperCamelCase. Underscores are only considered best practice as fields. 

Let's take a closer look at this. You'll notice that I save the generated items as a collection of strings. We can do this because they need to be written to a file anyway so it doesn't matter if it's a string or an integer. 

I'm creating a thing that does things. Part of the things the thing does is querying an API for information about movies and TV shows. The API allows me to query for changes to their data so I will first iterate over every entry they have (IDs are numerically represented), store its information locally and then periodically update the database with information I get from the Changes API. The part of the thing you see here is how I create requests and how each API call will be implemented. The setup is simple: since almost all kinds of requests are the same, I just create subclasses of a general request that implement request-specific behaviour. Advantages: 

I made a small example to show you that all your worries are in the past. Before you implement this yourself though, keep Mat's remarks in mind: I made this as a quick sketch and separating the mappings from the context, naming conventions, etc are important for your code's clarity. That being said, this small setup shows you how you can change it: 

First of all: I appreciate the clarity of your code. Variables have good names which causes the code to be read very fluently. Intendation, spacing and whitelines are also very well done so that's a major plus. Ofcourse, there are always working points. Let's take a look. Comments 

These type of comments just reiterate what we can already read very clearly from the code itself (see: self-documenting code). The other type of comments elaborate on the why. These are comments that explain your reasoning behind a bit of code, something that is a lot harder to express in code. Take for example this piece of code: 

Implicit this Contrary to the above having explicit is unneeded and takes away from the readability. You should only use it when there is ambiguity with a parameter name. This results in this: 

You'll have to convert it to the appropriate type everywhere it will be used You can get exceptions if the fields contain inappropriate values 

I have tested this code with inputs , and . If you'd want to take your approach after all, a few remarks: 

Static You're abusing the fact that the method should be and bypassing the OO rules of creating an object. Instead of using that method directly as a part of your program, simply create an object of your surrounding class () and use instance variables instead. Additional benefit: you can now start multiple games at the same time. Static helper methods A major advantage of a helpermethod is its ability to be called in a context (aka: ). By forcing the user to create an instance of it, you're losing that usability. Aside from that, it also makes no sense to do that. Your helpermethod doesn't keep track of the state of anything, so there is never a difference between two instances. Lastly: stay consistent. 1 of your 4 util methods is an instance method. Linesplits You don't have to split this up: 

Adhere to the single responsibility principle. Printing output and receiving input are two distinct tasks and shouldn't be done in the same method. 

Keep the indices in ascending order -- it's what everybody expects and you won't have silly mistakes because the arguments passed in expected 0-1-2-3 instead. 

However if you want to stay with your own implementation, there are a few things you could change around: 

Calendar You created an alarmclock, which is really just a time-representation. A has both a date and time component. I strongly, strongly suggest you use that so you can let your user define how he wants his date represented and let the API handle fancy stuff like timezones, summer hours, etc. You can also look into the Java 8 time API but I think that might not be appropriate yet. Enums When you have a limited set of different possibilities, your mind should immediately wander to enums. This way you can represent your AM/PM by saying and instead of the literal string "AM" which could mistakenly be used as "aM", "am", "AX", etc. It will provide compile-time safety and is a lot more pleasant to work with. Indentation Stick to conventions. Some people indent a block with one tab (or 4 spaces), some with 2 spaces. This will keep the code readable for everyone. Methods without a meaningful body Look at your code here: