You could use magic getters and setters, but you probably shouldn't (see the top-rated answer in that question; additionally, with the primitive approach, you would make all your private fields accessible from the outside). You should also ask yourself if you even need setters. If the properties of the object never change after construction, you should make it immutable, as immutable objects are easier to handle (you know that they never change). 

This is open to SQL injection for any additional values, either via , but also via . You have the same problems in other functions such as . 

If you still want to have all the power of a class instead of an enum, another solution would be to use a map: 

The PDO exceptions would be handled by your calling code. Depending on what is updated, you may want to log the error, inform the user, ignore the error, perform a different action, and so on. Of course now the question is if this method is actually needed. Is this: 

Filtering I'm not a fan of the function. I don't know why w3schools recommends using it, but it's the wrong approach to XSS (you should encode when echoing, not when retrieving user input), and it messes with your data ( becomes without any need for it; maybe you want to have , for example because you want to send an email to , not to , etc.). Email Validation Email validation is difficult. that being said, yours doesn't work as intended. For example, it sais is valid. This is because it only checks if any part of the email address match the pattern, which does. Structure Your code is quite nested, which makes it hard to read. For example, if I want to know what happens if is not set, I need to scroll down quite a bit. It turns out that nothing happens in that case. You can rewrite your code like this to avoid this issue: 

It's not vulnerable, but this isn't the preferred way to prevent SQL Injection. Sanitizing the variables all over the place is a nightmare to maintain, especially in a larger code base. You never really know which variable is safe (did you clean that variable already? If so, as what? An integer? A string? Do you need quotes around it or not? ... which means that eventually, you will make a mistake). Also, checking the code for vulnerabilities takes a lot of work because the whole context must be taken under consideration. Whenever possible, you should use prepared statements. It results in nicer code, and the vulnerability is defended right where it would happen, so you can be sure that it is always secure. Limiting what your input can be when receiving it (as you are doing here when accessing by passing it to , as you know that it has to be an integer) is still always a good idea as defense in depth though. Misc 

Generally with ifs, you should try to handle the shortest case (the one with the fewest lines) first. When doing validation, it's also always good to handle the negative case first. Depending on the exact context and framework, different solutions may be even more sensible. 

But what if the scores are equal? You should add an block reporting a draw. getCardfromDeck The method doesn't do anything, except call a different method. Such wrapper methods are quite useless, I would just delete it. Random Instead of 

The XSS protection is not strictly necessary, but when writing a generic function which builds HTML, it's recommended, as the function may be reused in different contexts. 

I just have a couple of small points: Exiting in Constructor You shouldn't just in a constructor, but throw an exception instead. But in this case, the only statement in the block is an assignment, so there isn't really anything that can go wrong. You should just remove the entire block. Naming Your naming is somewhat inconsistent. For methods you use camelCase, and for parameters you either use all lowercase (which you should always avoid), or under_score. At the very least should be . I would also use somewhat more descriptive names inside the queries. Having , , , as well as all in one query is a bit confusing. SQL Style Your SQL statements are also a bit inconsistent. If you write SQL keywords in all uppercase, do it always (see for example , , and ). 

You are assigning the username to the session if the user is authenticated and if they are not authenticated. My guess is that has a check such as ? Have you tried logging in with a correct username and incorrect password, followed by simply visiting ? My guess is that you might then be logged in. Even if not though, the assignment seems inconsistent, insecure, and just begging for future bugs. The other issue I have is that you use prepared statements (good!), but not always. Why fall back on the less secure ? Just use prepared statements everywhere. 

Coding Style and Conventions A nice coding style can dramatically improve readability, and thanks to IDEs, it's incredibly easy to achieve. 

You should also change the variables so that they comply with Java naming standards (camelCase instead of snake_case). Remove commented out code Remove all commented out code, as it makes the code harder to read. If you think that it might be needed in the future, use version control. Comments You need more comments in your code. At least you would need a JavaDoc for . What does it estimate? What parameters does it except? How does it estimate? Refactoring Without working code, unit tests, and a general description of what the code actually does, it will be really hard for us to refactor this. My general approach would be to identify similar code at a small scope, extract both versions of it to new methods (with appropriate arguments and return values), and then see if I can change the signature and workings of those methods to use the same method for both cases. If it does work (confirm correctness with unit tests), do the same thing for the next biggest scope. During this process, I would also keep an eye out if creating objects might simplify some of the code. 

You could extract the validation into its own function. It's shorter, and in case you change how you handle errors, it's easier to change: 

Avoid duplication Right now, you have the mapping between colors and text twice, each in a very long switch statement. This duplication makes it hard to find bugs (eg mapped to , but mapped to ), and it also makes it hard to add additional colors/text, as your code needs to be edited in two places. Instead, you could use an array to look up these values. It might look something like this: 

XSS looks like a debug statement, but even debug statements should be secure. If you don't expect arrays as input, this would be a simple solution: File Upload is completely user controlled, so an attacker can upload for example PHP files which would result in code execution. What you should do is check the file extension as well as the actual file type. The functions that are generally recommended for this are and respectively. Ideally, you should use whitelists, not blacklists. It is a good idea to additionally forbid execution inside the upload directory, ideally by using server configuration as well as OS configuration, but this should not be your only line of defense. You are currently setting these rights: 

Security You didn't post the really interesting code regarding security (the database update and the file upload), but concerning the code you do have: XSS It's never a good idea to just echo user input without encoding, as it leads to XSS. In the case of XSS in a user area, this may be exploited by creating a new account, placing an XSS payload into that profile, and forcefully logging a user into that account (eg via Login CSRF, Session Fixation, etc). The impact may or may not be serious, but it is a sign of bad design. If you have to think about which user inputs to encode where, you will eventually make a mistake. It's better to automatically encode everything. CSRF The code you posted doesn't have any CSRF protection. If it doesn't exist elsewhere, you should add it. Relative Path Overwrite You shouldn't include CSS files relatively, but absolutely (same goes for JS files). Otherwise, an attacker could place CSS code into the page, and possibly use a specifically crafted URL to execute that CSS code (eg profile.php////). CSS injection isn't as serious as XSS, but it can lead to the reading of sensitive data, to defacement, and possibly phishing. the doctype declaration means that RPO will not work in all browsers, but it should still be fixed. Commented out Code This line: 

Instead of wrapping mysqli, it may make sense to aim for less abstract methods. For example, you may have a , which may have methods such as . 

But I would actually make more methods out of this, because it seems like two different activities (check if it can be parsed as integer, and check if the integer is below 3). I would create a method (or just use a try block), and then a method (or not. if you separate the functionality, it becomes easier to see that the functionality actually doesn't need to be extracted to a method). Declare Variables in smallest scope You should always declare variables in the smallest scope possible, that way a reader only has to have them in mind when they actually matter. for example is defined at class level, but only used in . Misc 

XSS can lead to data leakage (like cookies), bypassing of CSRF protection, injection of keyloggers, defacement, phishing, and so on. is not enough to defend against this: 

It's obviously for some sort of corner-case, but which one? Confusing for loop The null check isn't the worst part about the loop. The worst part is that you change t and s on every iteration, and additionally modify t and s inside the loop as well, which is difficult to understand. Now, the easiest solution would be to use two temporary lists (even and odd), iterate over the original list, put the values in the correct list, and then join the lists at the end. I'm assuming that you are not doing this for time and space reasons. An alternative may be to use a while loop. Unit Tests I didn't write an alternative solution, as things like these are a lot easier to write when you have unit tests. You can make a small change, run the tests, and see if it breaks something. Without tests, making changes is rather difficult. You may want to consider writing unit tests first and then implementing against them in the future. 

Input and general structure Right now, the only possible way to use your class is via the command line. This makes testing really hard. I would change your function to a simple setter, and read the word in outside the class (somewhere in ). And in general, your class should only transform words to piglatin, not also print and read. I would move to as well. And your public interface for is quite hard to manage. I would make all those methods private, and then either create a method, or just call them in . I also think that you could merge some of the methods. At least and could well be in one method ( or something). Your naming is sometimes not very precise. For example, also adds , which is unexpected. 

Security Yes, your code is secure against SQL injection, that's good. You don't echo any variable data, so your code is also not vulnerable to XSS. You left out your form (and possibly other code), so there might be an XSS vulnerability there though. To protect against XSS, you should definitely read this cheat sheet. 

For a first project, your code is pretty good. The structure and formatting are fine, and your code is generally quite readable. You also didn't make any really bad beginners mistakes like having SQL injection vulnerabilities, etc. 

You can go to Wikipedia to read the explanation. Implemented correctly, the method should probably look like this: 

Blanked Exception or specific Exceptions It depends on what you want to do with the exceptions. If you just want to stop and return "not working", then your approach is good. But if you want to try and rescue the attempt, then a different approach would be better, and then you have to differentiate by exception type: 

Security The echo should be vulnerable to XSS via the file extension (but it's not exploitable - at least not easily; Still, I would HTML encode it when echoing). Otherwise it looks good to me. Regarding the various checks: 

Then you know that it is just awfully structured. It is way too nested, and I have no idea which bracket closes what. You also have quite a bit of duplication, which you could remove by introducing functions. Personally, I would rewrite your whole code from scratch, as there are so many things that aren't quite right. When you do that, try to first create smaller units of code, which you then combine. And use functions to simplify your code, so that you don't have to keep everything in mind at the same time. Functions may be: , , , , ... This is just a quick first idea, your code is a bit too confusing for me to suggest all the proper functions you may need. Naming Good variable names are very important for readability. All your variable names are too generic or slightly wrong, for example: 

There isn't much to say about your code, it's pretty good. You avoided duplication by extracting code to functions, and your code is pretty clean in general. Some nitpicks: 

Structure Your Router does too much. It routes, but it also parses input, cleans it, and stores it. This is not something I would expect from a router. Routing I'm a bit confused as to your routing actually works. You seem to retrieve the route from a GET parameter called , and then you get the parameters from that value as well (minus the first two)? So I would use it like this: 

It uses bcrypt (which uses blowfish internally), and it even manages salts for you. This should also answer your additional questions: You don't really need any of the functions. Misc 

No, they are not. All those characters pass without a problem. It only strips tags and encodes some chars (single and double quotes). The documentation is not very clear on what tags are, but generally it's something like , although the filter also removes from , so you could get problems if you want to allow the character. 

This is not a complete review, just a couple of points that jumped out at me: JavaScript Naming Short variable names are hard to understand. While , , etc are somewhat standard, , , , , , , , , , , , , etc are not and it is very hard to understand what they represent. Will you in six month still understand what is without searching in the code? I would guess not. But if you use , it is immediately clear what it does. So my recommendation would be: find good variable names for the one character names, and write out the abbreviated names (, , etc). Some function names also do not express well what they do: might be better named and better (same for ). Bugs If I set row and column count to a number different from 3, it seems that nobody can win. Long functions The function is definitely too long. I would at least extract the two red redraws to their own function. Saving fields in local variables In your method, you save fields in local variables: