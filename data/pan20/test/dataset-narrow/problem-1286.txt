Now, the solution to your problem actually depends on your implementation of world and camera geometry. You can either rotate your camera around point B or you can "rotate the world" around the camera by the inverse of the previous rotation (as usual in the "ProjectionMatrix * CameraMatrix * ModelMatrix * positionOfVertex" part of a vertex shader, if it's OpenGL or DirectX you're using). 

Inertia is not a tuple (x,y,z), it is in fact a 3x3 matrix but in the case of a simple box, calculating said matrix within the set of coordinates naturally associated with the box yields a diagonal matrix (i.e. whose only non-zero entries are on the diagonal,so there are 3). The pdf you linked to gives Ix, Iy and Iz which are the three non-zero entries of the inertia matrix I (but I'm going to call it J because I is often used for the identity matrix). But if J had been calculated relative to a randomly chosen set of coordinates (if the axes in the pictures to the right of the table in the pdf hadn't been in these positions priviledging the geometry of the solid shapes in question) then the matrix J would have been much more complex and, in addition to Ix, Iy and Iz there would have been three other real numbers necessary to define inertia: Ixy = Iyx, Ixz = Izx and Iyz = Izy. Three additional numbers only and not six because J is symmetric. I don't know what was supposed to mean, but if inertia is going to be a vector, then you'd better make sure your solids always have nice symmetries and invariances with respect to the axes of your axis system. Classical mechanics tells us that J.(dω/dt) = T where T is the torque, ω is the angular velocity and dt is a small amount of time (your timestep). Both are vectors. To get only dω, i.e. the small amount of angular velocity that you will add to your current angular velocity, you need to multiply both sides of the equation by the inverse of J and then by dt: 

This will fix a timestep to a multiple of 1/60. If you wanted an integer dt, just truncate again using . I'd advise against this, though. I would either find a more accurate timing method than what you're using or fix your timestep rather than a halfway house. 

The issue you have is that you're not taking into account the effect of the translation of the square away from the origin. ctx.rotate and ctx.scale both work relative to the top left of the canvas, at co-ordinates (0, 0). What this means is when you rotate your top left corner at (500, 100), it will move 45 degrees in an arc around from there. when it is scaled, it will just scale these corner positions, not the size of the rectangle around the corners. When you want to scale and rotate the square, you need to choose the anchor point on the square around which you rotate and undo the translation first. For example, here's an example using the top-left corner: jsfiddle.net/9atht/1/ 

which, when you put these into ctx.setTransform (along with the translation X and Y in the last two parameters) yields the correct result: jsfiddle.net/3ugzy/1/ But only works if the tile is centred at the origin. This is because if not, the offset from the origin also gets factored in to the transform and it goes slightly wonky. Hope that massive example helps! Sorry about the lack of hyperlinks, but I've kept the important ones in and de-linked the others to keep the spam police happy. 

and then plug your back in to the line equation to get the crossing point. From this we can intuitively read a couple of simple properties: If the line's direction and the plane's normal are perpendicular there is no crossing. is zero, which would be a divide by zero. describes how 'far' is from the plane in the direction of the plane's normal. N.Q then describes the ratio between the direction of the plane and the direction of the line - the more parallel the direction and normal, the faster it will intersect. 

The loops obviously have complexity O(mn) where m and n are the number of vertices of each shape. The set contains mn elements at most. The algorithm has a complexity that depends on the algorithm you used, and you can aim for O(k log(k)) where k is the size of the set of points, so in our case we get O(mn log(mn)). The algorithm has a complexity that is linear with the number of edges (in 2D) or faces (in 3D) of the convex hull, so it really depends on your starting shapes, but it won't be greater than O(mn). I'll let you google for the algorithm for convex shapes, it's a pretty common one. I may put it here if I have the time. 

This doesn't work very well with shapes that are rather long, but in the case of squares or other such shapes, it's a very good heuristic to rule out collision. The separating axis theorem applied to B and the volume swept by A, however, does tell you whether the collision happens. The complexity of the associated algorithm is linear with the sum of the numbers of vertices of each convex shape, but it is less magical when comes the time to actually handle the collision. Our new, better algorithm that uses intersections to help detect collisions, but still not as good as the separating axis theorem for actually telling whether a collision happens 

Make two separate vertices. Make a circle around one of the vertices (the base vertex), that is within a plane perpendicular to the segment between the first two vertices. Hopefully you can make a circle using trigonometry, right? That's already all of the vertices of the cone. That's also one third of all the edges (there are n edges in the circle and 3n in total). Make n edges from the base vertex to the n vertices in the circle. You can make one half of the faces (that's n faces) as you do that. Make n edges from the tip vertex to the n vertices in the circle. You can make the other half of the faces (that's n faces) as you do that. 

What do you get if you try and swap the order you draw them in? Transparent pixels still create depth buffer entries. If you're drawing the back one after the first it's not processing the pixels behind the front image, making it look like there's no alpha. For reference, take a look at the Painter's alogrithm. 

It probably doesn't look so good since interpolating between them relies on always having the next set of data to interpolate to. This means that, if there's a short lag spike, everything has to wait to catch up. There's an old article on GameDev about using cubic splines to predict the position of an object past the point where you last had data for it. What you then do is use that position and then adjust the spline when you get new data to account for its new position. It's also probably much cheaper than running a second physics simulation, and it means that you don't have to decide about who you trust, since you've explicitly implemented the client making it up as it goes along. :) 

I would use the built-in methods. Much less hassle. ;) If you want to specify directions at arbitrary angles, the easiest way to do this is using trigonometry: 

This will draw a small portion of the map centred around . This will offer you smooth scrolling around the entire of the map, as well as sub-tile movement - you can store the player position as 1/32ths of a tile, so you can get smooth movement across the map (Clearly if you want to move tile-by-tile as a stylistic choice, you can just increment in chunks of 32). You can still chunk up your map if you like, or if your world is huge and wouldn't fit in memory on your target systems (bear in mind that even for 1 byte per pixel, a 512x352 map is 176 KB) but by pre-rendering your map like this you'll see a large performance gain in most browsers. What this gives you is the flexibility of reusing tiles across the world without the headache of editing one big image, but also allowing you to run this quickly and easily and only consider one 'map' (or as many 'maps' as you like). 

The image of a point A under a rotation around another point B (an affine rotation if B is not the origin of the space) is A', with 

In your code, you calculate but the weight does not depend on the immersed volume (). I think you misunderstood the law of physic you mentioned. I don't quite see what you were trying to do with 

First of all, in the case of axis-aligned rectangles, Kevin Reid's answer is the best and the algorithm is the fastest. Second, for simple shapes, use relative velocities (as seen below) and the separating axis theorem for collision detection. It will tell you whether a collision happens in the case of linear motion (no rotation). And if there's rotation, you need a small timestep for it to be precise. Now, to answer the question: 

I have a bit of work to do so I'll come back later and add pseudocode that translates this, with a few necessary remarks regarding the loss of precision due to floating-point operations, etc. In the end, the code is very short. Edit : I forgot to mention that R is also required to compute ω(t+dt). That is because of the very definition of J. To quote Wikipedia on the moment of inertia, 

How to tell in the general case whether two convex shapes intersect? I'll give you an algorithm that works for all convex shapes and not just hexagons. Suppose X and Y are two convex shapes. They intersect if and only if they have a point in common, i.e. there is a point x &in; X and a point y &in; Y such that x = y. If you regard the space as a vector space, then this amounts to saying x - y = 0. And now we get to this Minkowski business: The Minkowski sum of X and Y is the set of all x + y for x &in; X and y &in; Y. 

If you're not sure of this (i.e, you might have caves or overhangs or similar features) then the way to do it is slices. Slices are all the same size (the whole of your map) and you would have one for each and every Z level possible. You would also require a new tile type of 'Nothing', which means you just don't draw anything. This way is more expensive, but if you need the flexibility it's the way to do it. 

Quite a common thing to do with some matrices is to cache the value and only update it when it's changed. There's two ways to manage this scheme, push or pull. Pushing matrices would involve, at the point of a matrix changing, letting child nodes know that the matrix has changed. These nodes will then have to let their children know, and so on. The upside is that it only requires storing the extra matrix, but you re-compute it every time it changes - if you change matrices within the hierarchy a lot then the matrices at the bottom will change an awful lot during the frame. The reverse it to pull matrix changes - when a value is changed, it sets a boolean value which says that the matrix has changed since it was last read. This is commonly referred to as a dirty matrix (programmers are weird.) Upon requiring a matrix, you check if it is dirty (or its parents). If it is, you recalculate the matrix. The downside of this is that you need to check if things are dirty all the time. When I said there was only two methods, I lied: you can go for a hybrid approach somewhere in the middle. Push the dirty flag down the tree, and let children know that at least one of the parents' matrices are dirty. At the same time, calculate the matrix only when needed. If your only ever process the tree in a downward fashion (from the root to the leaves) then you can get away with only one matrix multiplication per node as a maximum.