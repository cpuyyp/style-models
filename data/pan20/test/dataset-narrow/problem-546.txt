Also this test if the file is openable for reading (not if it exists). So you may want to use a more appropriate function. 

Yes I know this is stupid. But the point is people get into weird situations and it may happen. It is your responsibility to prevent your class from being used incorrectly. A couple of solutions, make it privately inherited (as you have done), or the method I would use is to make a member (rather than a parent) to control the ring. Then your class can not be abused (and you do not need to make the destructor virtual). I personally (but this one is a personal opinion) don't like the use of a pointer in join: 

Thread start-up and avoiding busy loops In your thread phase you basically have a busy wait. if is false then the loop repeats very quickly without releasing the processor for other threads. I bet this shoots your CPU utilization to 100% very quickly if you do anything before calling on the . There are two solutions to this 

But you will need const versions of all these (and a type) to be a fully compliant container. You are going to have a hard time making this work if the buffer is of type T. Every time you expand the buffer all the elements in the buffer will be initialized with constructor. For this is not a problem. But if has a non trivial constructor then you are going to pay a heavy price initializing elements that may never be used. 

Identifiers with two underscores are reserved for the implementation (so don't use them). Also MACROS (things defined by #define) are traditionally all uppercase (because they do not obey scope rules (because they are not part of the C language but part of the pre-processor system) we make them all uppercase to make sure that we don't accidentally clash with other identifiers). 

You should only be making objects dynamically like this if you can not tell the lifespan of the object until runtime. Most of the time you should be using automatic objects. 

Yep. You implemented the standard brute force implementation. Personally I think that is fine. For some silly reason though a lot of interviewers expect you to swat up on string manipulation for interviews and want you to know the non brute force versions off the top of your head. In my opinion if you know a clever versions exists is enough (because in real life I would Google "efficient strstr implementation") if you happen to know the name even better (because in real life you will find it faster). 

No this should not be quicker (but always time things). NRVO (Named Return value optimization). The old C++03 compilers can easily see this as a value that is not used in the construction function and will actually build the string in place at the destination (rather than build it locally and copy it out). You can test this by rigging up your own version of a string and seeing if the copy constructor is called when you return it (if you have optimizations on it does not). With C++11 we introduce move semantics. The return value of a function is an r-value reference (may be some other complex names for it). Basically if the compiler can not use NRVO/RVO then it can use move semantics to move the object out of the function (rather than copying it). Short story don't bother to pass output parameters. It is much more logical to use return values. The compiler is going to do a bunch of optimizations that make it as affective (if not more so). Better approach. Try and use algorithms: 

A minor note: As the code may be changed to have bigger arrays by modifying . I would make the user instructions reflect this automaically. 

To wrap everything up in a namespace but keep very simple. Reason The reason to do it this simpler way is the OpenClosed principle. Your code is Closed/Closed. Nobody else can add any conversions without modifying your class. Changes to the class mean that any other libraries that depend on your library will need to be re-compiled. With this design we can add new conversations to the namespace re-build the library and re-distribute. There will be no breaking changes to existing code (just new functionality). 

Before I do a C review I just want to do a literal translation of your python so you can compare it. Personally I think you can make your C look identical to your python (a small amount of extra work required for memory management and the array like container but otherwise the same). 

So checkForWin() returns 0 for no winner 1 for winner and 2 for a draw. The first check above will result in win being 1 or 2 even for a draw, while the second check will result in 2 or 3 (which is probably correct). What you really want to do is make checkForWin() return the result you are looking for. 

BUT. This looks so ugly. Why not just add a method for deleting the data that is called by this method and the destructor. Does not Provide Strong Exception Guarantee Another problem here is if the type is not trivial. 

Your code could be much simpler if you use a sentinel node(s). It removes all the code that checks for NULL (as an empty list has the sentinel in it so no NULLs). Because you don't need to check for NULL it makes the code much more trivial to write). 

Couple of issues: The code is not exception safe. Any resource that has an open/close symantic should be handled via RAII 

In my ongoing attempts to become a better blog writer I have some written some more code that needs reviewing. Full Source: $URL$ First Article: $URL$ This is a Simple Client Server implementation using RAW Sockets. MakeFile 

You are making assumptions about the result of . Why do you think will ever be correct. The documentation is very clear. If there is no match to the find it returns . Dont make any assumptions on what that value is. The standard way of testing for out of bounds is less than though your test is perfectly valid it looks weird. Prefer pre-increment to post increment. It makes no difference in this case. But in general siuation it can make a difference (because we use the same kind of loop with iterators). So to be consistent and always get the best loop characteristics use the pre-increment. Would not need to clear token if it was local. 

Its not going to crash but you are left with lots of crap on the input stream. User input is line based so read a line from the user and then try and parse the line. Because a line can be any length don't use that version of get line. 

No. The way way you are using struct assignment is fine. BUT personally I would provide one so that you can construct this object from a single short/int/long. That way you can construct from a single integer literal. 

Design Accessing matrix elements is usually done with in maths. To make your matrix easy to use by other maths like people maybe you should implement this (or something close). Simple V1 technique: 

Code Review Please specify parameters. Please provide parameter names even in declarations. It helps understanding what your code does and is part of the "Self Documenting Code" principle. 

If the log level is not going to print anything. Then calling the function is a complete waste of time. You need to defer the call of and only call it when it will generate something useful. Bad Code: This is not even legal C++ 

This one fact would have caused you to be rejected. I would have seen this and I would not have read any-further into your code straight onto the reject pile. This fundamental flaw in your style shows that you are not a C++ programmer. Next the objects you new are stored in RAW pointers. This is a dead give away that you are not an experienced C++ programmer. There should practically never be any pointers in your code. (All pointers should be managed by an object). Even though you manually do delete these two it is not done in an exception safe way (so they can still potentially leak). You are reading a file incorrectly. 

And I prefer to put the statement the for loop is going to run on the next line so it is obvious what is happening (but I am not going to care that much about it). typedefing a structure is not needed in C++ 

It is changing the state so its not really a const method. Commit There seems to be no way to call commit!!! 

So the rest is just some personal preferences. Nothing I could complain about in a code review. int rightMost_of_curElem(int A[], int curElem, int ind, int n) This returns the righmost element. Which means the user has basically has the index to beginning an end of a range. Most C/C++ like functions use a concept of beginning to one past the end. So I would have made this return the index of the first element that did not match (and re-named slightly). Slight improvement is that you pass the index of the current index which you already know equals the value. You should pass current index + 1 (avoids one compare). int remove_duplicates(int A[], int n) You hard code the number of elements to retain. In an interview (and in real life) I would have parametrized this. Using as a test seems a bit hard to read when testing one or two elements. I would just use the distance between and to find the number. I would have written like this: 

Using is not a good idea. Prefer . The difference is that flushes the stream. Flushing is usually always wrong. The streams will flush themselves at appropriate times let the code do its work. Note: The most common complaint about C++ stream is that they are slower than C stream. This is usually down to inappropriate calls to flush that significantly degrades performance when done incorrectly (and manually is usually always incorrect). Questions: 

Its easier to ask the object to display itself rather the pull details about the object and then display them. The simplist example is just printing information to a stream: 

Personally I would use a doubly linked list and sentinel values (thus you don't need to check for NULL). This makes both inserting and removing the values very simple. 

Its an implementation file. Stick to the header files defined by the standard (they don't have on the end). You covered this yourself: 

You basically repeat the same piece of code twice. This violates the DRY principle. Remove this code into a function and call the function passing parameters for the differences. 

Now your object files will build as you expect. But normally you don't want to build your object files into the same directory as your source files. This is because you can have different versions. eg you can have a debug build and a release build. You should never mix and match object from different builds. In fact no compiler manufacturer makes any guarantees about object files built with different compiler flags. So any differences in compiler flags can potentially make the object files incompatible. As a result build your object files into different sub directories based on the type of build. Personally I build release into a directory called and debug into a directory called . I know very boring. I also suffix any targets with their type. Say I am building the lib . 

Declaring arrays like this is not valid. It is C functionality. your compiler is letting you get away with it but not all compiler will. The size of the array must be static and known at compile time. If you need to dynamical size arrays then use std::vector 

Just because a src is an IsourceAccount does not mean it is also sourceAccount so casting it may not be valid. But it looks like what you are trying was to create a wrapper class (like this): 

At this point points at the new node. Which had its value set to during construction. Another trick you could look up is using a sentinel node. Basically you always put one fake node into the list. Then the code for handling insert/delete become much easier to write because you don't need to check if the list is NULL (because there is always at least one node). 

Well actually what you have written will compile: Unfortunately it does not do what you expect. Here you have object slicing. The Base part of the object you created is sliced out and copied into d. What you need is a pointer (or a reference). It looks like you are used to languages like Java. Where all objects are dynamically allocated. C++ has a much superior mechanism that allows us to accurately control the lifetime of the object. The disadvantage is that it adds complexity to the language. What is called a pointer in C/C++ (to distinguish it from C++ references) would in most other languages be called a reference. C++ has both local objects (automatic storage duration object) and dynamically allocated objects (dynamic storage duration objects) thus we need a convention that allows access to both types of object, hence we use to refer to objects that are dynamically allocated (to distinguish them from local objects). BUT it is unusual to use pointers directly in C++ (unless you are implementing some real low level stuff). Most of the time when you dynamically allocate objects you will use a smart pointer that defines the lifespan of the object (much like other languages with garbage collection (but better)). would be the equivalent of in Java. 

Note: If you have any more that your 11 items then I would use one of the methods by @Jerry or @200. I am not going to reat what they have written so beautifully. But for so few elements I may just write them out by hand. 

NameSpace Put this in your own namespace. I can easily see somebody else defining a class or function . You should be using namesapces to keep your code separate from other peoples. If you are worried about all the nested namesapce making it to verbose then let people use namespace alias. 

Think about 10 years of maintenance on this code. The code now covers 5 long pages. Try and find and update all usages of . This becomes a pane as will appear in nearly every other identifier in all the comments in lots of places etc. So try and use variables that can be easily searched for. In your ConvertXXX() functions. You are saving integer values into the string. This is fine. But you are then extracting those char values and converting to int for printing. Why not convert the values directly into the characters you want to print. 

That sounds perfectly reasonable. BUT is it it the best thing to do? That will depend on context. In your example above I would argue that it is not. In this simple case I would have a member method. That way you don't need to pass the object or the vector, you also don't need to expose a member variable as a public. 

But OK. lets use it (just as a demo case). In this case I would not make the result as this prevents further mutation. Just return a reference to the and it will allow you to chain operators. 

Prefer "\n" over std::endl The only difference between the two is that also flushes the stream. The stream will flush itself automatically when it needs to and thus forcing a flush is only going to make it less efficient. Humans are notoriously bad at making this decision; the code is actually very good at. So let the code decide when to flush. Don't use pointers in C++ 

Why do you think it is efficient? On integers this is a left shift. On Floats this is incrementing the exponent by 1 (assuming IEEE754 representation). Both relatively trivial operations. 

But: 1) You don't check for invalid input as a result you may push back (a big number that is converted is probably converted to -1 when assigned to long). 2) This is O(n) for every digit. it can be done in O(1). The standard guarantees that the character-set has all the numbers -> in a contiguous range. So you can convert a character (that is a digit) into a number by subtracting the value of from the character. 

If we change the code so you include values on the line (ie first or second == 0) in an appropriate quadrant. You don't need the last if statement which reduces the number of comparisons so that: 

This should be refactored out of the branches. You have implemented all this as a function. That is called multiple times and uses some global data. 

Design With a singly linked list it is to find the end (assuming you store the beginning). So it is often nice to track both the beginning and end of the list inside the list object. Personally I would have gone with a doubly linked list (next/prev). That way you can store just the head but finding the tail (on a circular list) is simply getting the link before the head.