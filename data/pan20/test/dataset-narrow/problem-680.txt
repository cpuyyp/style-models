Now the function must consider 2 different classes of objects. The classes are different but similar enough that the client code can stay as it is as both classes contain a field . Let's see: 

Define all your error types globally in some file for convenience, like the built-in errors are defined. Mixing promises and callbacks is a big anti-pattern, just think in promises and let .nodeify handle the mapping to callback equivalent at the end. 

Ok so the situation is still pretty good but here we are relying on the fact that properties are in same order and that there are only 2 different classes. Let's do the same in different order so that V8 can't use the same instruction () for both objects: 

In a good implementation you pay for a lot of functionality only if you are actually using that functionality - so a lot of functionality doesn't necessarily mean slow. In fact, more often than not, implementations with small amount of functionality are very sloppy and not fast. Consider underscore using a -statement. This slows down performance unspeakably but is done because it takes no effort from the implementer. Implementing variable referencing properly without using would take a lot more code. Overall an optimized library will always have a lot of more code than an unoptimized one. It's a simple physical law. 

Yes, I think it will. All access to the field is protected by a lock, so I do not see why this wouldn't be thread safe. A nice coincidence of using immutable lists is that you can also nicely implement or even just return the list of all elements currently in the stack - because the data type is immutable, it can be safely shared with other threads (this means, you won't get into the usual troubles with "Collection was modified; enumeration operation cannot continue" that you'd get in C#. 

If the idea is to have multiple threads sharing the state, then they'll need some way of sharing & mutating the state. Another approach in F# would be to use an agent and keep the current as a parameter of the asynchronous loop - in that case, you're not using mutation in the F# code you write (but there is hidden mutation and synchronization going on in the agent). Logically, the agent-based version is quite similar to the one you have using locks - it might be a bit nicer for other reasons (getting locks right is hard, agents do not make it possible to do the same kinds of errors), but that really depends on what you want to illustrate! 

This however needs knowledge of the standard library. So how do you find those functions if you don't know them yet? Welcome to Hoogle. We can find by searching for , by and by . If we didn't have any of those helpers, your code would be fine, except for the strange explicit result in 's first argument. That was too complex, as you will stop as soon as you find a either way. 

All those small improvements were reported by . Use if you know how many elements you will have For your main algorithm, you should use if you know the number of characters you want to store: 

You don't need overloads if you provide default arguments You don't need constant s You don't need to check the length of your collection (except for ). 

When you compile a language, you usually split the input into tokens with a lexer, then parse those tokens with a parser into syntactic elements in an abstract syntax tree (AST) and then use that to optimize the program and finally generate machine code. With Brainfuck, none of this is really necessary, but it makes your code much easier to understand, especially the AST. The biggest problem in my point of view is that you don't actually have a program at the end. Your results in a and a jump map, which by the way is not complete. Try the (malformed) programs or . The latter will result in a " called on empty list" error, the first will silently ignore the during parse but will crash during interpretation. The latter error is too late. It should have been found during the parsing step. However, this is a lot easier if you use a new datatype: 

So the same function body ran 15 times faster because the object passed to it always had the same class. It is also hard to predict if you will actually save memory if all those 10000 objects allocate a different class for instance. It is also complicated to really look at all the downsides but having optional properties is one of those things that it is easy to say is very bad. 

Notice what happened here, V8 saw that we always pass the same class of object to the function and generated really tight code that assumes we will always get that class of object in the future as well. Now let's do: 

Ok just as expected, just using different offsets depending on the class. So you can see where this is going, if you end up with 10 different classes then you will just get 30 instructions (instead of 3) whenever a function will need to lookup a property. Which is still much better than a hash table (100s of instructions?) lookup. Well no, turns out there is a limit of 4 different classes and then you go into megamorphic mode. So with this, we should see radically different code output if we use 5 or more different classes: 

which immediately tells you what type has. I don't need to scan the rest of the code anymore. Remove unused imports You import , but you don't use it. Even more general cipher While your is now rather general, there are still some small things off. First of all, your cipher's only work for ASCII letters, yet the only ignored character is a single space. We can fix this if we use a predicate instead: 

You can of course use other data structures with better asymptotic complexity, but since there are only \$2^3\$ instructions this might be an overkill and should be benchmarked. But wait a minute: the return type has changed. That's because the text is allowed to have superflous characters. and are the same programs in oOo. This leads to a slight change in : 

Your code is fine, except for the stray method. at that point isn't valid, and you will try to connect to a server called . Just try your call with , you will notice two connections: 

Now we just need to get a list of strings. Since we now want to get something from the user, we have to use : 

I think that Mark's answer gives a great alternative perspective here. That said, I would probably write something that's quite similar to what you did here. There is a couple of small tricks that I would perhaps use to make the code a bit nicer (at least for my own personal idea of "nicer" F# code :-)), so I thought I'd share those. First of all, I would probably use and tuples-syntax for the definition of the interface. The is recommended for members and I think it makes sense to keep those aligned with the .NET style. You can also omit : 

The type annotation is interesting. It says that the argument is a function that returns a list of some values that implement the interface - but it turns this type into a generic type argument that is then passed to the other function (), so when you use the function, the compiler knows that the argument of has the same type as the thing that you obtain from . The annotation allows you to write in the filtering function. The two functions can now be defined as follows: 

Good code is written for humans and machines, but the latter are second class citizens. So let's try to get rid of some noise: 

Your compiler should have told you that you never actually use , , or . But even then, you have all those values scattered around. Is always the player's HP? Is the amount of attacks the player has left? We shall group the values that make a character: 

You write down the numbers from 2 to \$n\$ (only the odds). You start with the next number that you haven't looked at and that isn't crossed out yet Put "maybe prime?" markers on all numbers that aren't multiples of it Cross out all multiples of your number (all that don't have a marker; that step is implicit) Go to step 2, until you've run out of numbers 

Otherwise your isn't safe, since also returns on Unicode Characters in the 'Number, Other' Category. 

The latter is effectively only , since is already handled by in your first condition. Modularize If I give you an from to , you can print a grade. That's something we can put into its own function: 

The next thing that is a bit unfortunate is that you always have to write , which makes all your method headers long. If the private helpers are not used anywhere else, you could avoid this by turning them into local functions. That said, this might not be all that nice, because it makes the function very long (just syntactically, not logically): 

Another thing you could do would be to use object expression rather than a full class. Here I don't really have one preferred option. But I might write: 

I also think there is no point in pattern matching over booleans, because you are effectively just writing simple with more complex syntax, so I turned your original pattern match into an inline in (I also changed spacing to 2 spaces in the last snippet, but that's just to fit things on the web page). EDIT: Using nested local functions would also quite nicely work with Mark's suggestion to pass around functions. This way, you would not have to propagate them through all the other helper functions, so it might even look nicer than my answer. 

But that might be your design, so let us ignore that for now. Instead, let us have a look at your first cipher. Caesar The nice property about Caesar is that you can encrypt the same way you decrypt. If you move a character characters forward, how many characters do you need to move it to get back the original one? . With that in mind, we can heavily reduce the size of : 

However, since our stateful function is now so powerful, we don't actually need anymore. If we want to ignore a character, we can just do so in our : 

So if all your (standard-layout) structures were only involved, we would actually have defined behaviour. But there's the , and that's not guaranteed to be even memory compatible to the almost trivial struct. Yes, even and aren't guaranteed to be memory compatible. Even if they were memory compatible, the standard doesn't describe the behaviour of 

It's important that we only use to gain a maximum of laziness. This function will transform a line into another that's exactly one number longer: