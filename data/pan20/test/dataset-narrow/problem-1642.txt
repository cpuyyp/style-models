Are you using one or more GPIO to control the peripherals? If so you need to connect the peripheral and Pi grounds. If the 12V power supply ground is common to the peripherals that would be an appropriate ground point. 

It sounds like you were lucky in that the Pi appears to still work. To test the GPIO use either my gpio test (requires pigpio) or wiringPi's pintest utility. These test the basic GPIO functions. 

The byte endianess is determined by the I2C device. It may be low endian or high endian as defined by the I2C device's datasheet. 

I've placed the following script in /usr/lib/cgi-bin with the name joan.html (made executable with chmod +x) on a Pi2 called paul. 

You need to understand how hobby servos work. Perhaps google? You send a pulse 50 times a second. The pulse is between 1 and 2 milliseconds in length. The length of the pulse specifies an angle. Once the servo reaches that angle the servo stops. You shouldn't use software timed pulses to control a servo. The timing jitter is not beneficial. I suggest you use servoblaster, or RPIO.GPIO, or my pigpio to control servos. Note, RPIO.GPIO is not the same module as RPi.GPIO which you are currently using. 

Setting a sample rate of 3200 samples per second is a setting for the ADXL345. Transferring 3200 samples per second, which is presumably what you want to do, is not quite so simple. There will be the time to transfer each reading over the physical link. This depends on what SPI clock rate in bits per second you are using. From memory the X, Y, and Z data is each two bytes long, so 16 bits each for a total of 48 bits. Divide the SPI clock rate by 48 to get the maximum number of samples you can transfer per second. Then there will be the overhead of each SPI transfer (the spi.xfer2 call). This will be partly the Linux SPI driver overhead and partly the Python overhead. You are doing three calls per sample. That is wasteful, you could do one read of 6 bytes. Then you have the general Python interpreter overhead to do all the looping and calculations. A compiled language such as C would be much more efficient. 

If you are you using the Adafruit sensor. The receiver is open collector. You need to enable the Pi's internal pull-up resistor for the GPIO you use or use a 10 k resistor between the receiver output line and 3V3. The receiver output line should normally read high (beam solid) and will read low when the beam is broken. 

It depends on how serious you are and the character of the interrupts. Given that this is tagged with home automation I guess you don't have challenging requirements. Python will never be the best way to monitor interrupts while it is a interpreted language. The interpreter will impose a limit of the order of 10,000 interrupts per second if you are running on the Pi. Using C and Linux interrupts on the Pi you will probably be able to get around 25,000 interrupts per second before they start to be missed. The "best" way is likely to be my pigpio library. Depending on the nature of the interrupts it'll handle 100k-500k per second and still leave time to do some processing. It also has a built-in socket interface so it can be used over the network. See piscope, a digital waveform viewer, for an example of monitoring Pi gpios remotely. 

Google points to $URL$ which has old Raspberry Pi Foundation images. You will have to work out which Linux kernels they use. $URL$ (Branch: tab) suggests that 3.2.27 was the earliest kernel used. 

For the Pi3B+ you need to use the updated Raspbian image dated 2018-03-13. See $URL$ You can try the following which may work for you. It didn't work for me as I don't use the default repositories. 

You are probably referring to an out of date web-site. I thought that raspi-blacklist.conf was deprecated and no longer used. I2C/SPI are not enabled by default because not many people use them. If they were enabled by default it might confuse users who wanted to use the I2C/SPI gpios as ordinary inputs/outputs. There is unlikely to be any power difference in using I2C versus SPI. SPI is typically faster. 

GPIO 12/13/18/19 can be connected to the Pi's hardware PWM generator. This type of PWM is the most accurate and most flexible. All the GPIO can be toggled by software and thus may provide software timed PWM. Software timed PWM is fine for DC motor speed control. It will suffer with timing jitter but this will not be noticeable because of DC motor inertia. Software timing jitter would be noticeable if used to dim LEDs or drive servos. There is a third type of PWM which the Pi may supply on all GPIO. That is hardware timed PWM. This is fine for DC motors, LEDs, and servos. This uses DMA to time the pulses. It is provided by modules such as (my) pigpio and servoblaster. 

It's much easier if you can connect a keyboard and screen for initial set-up. Two things to try. 1) connect the Pi to a the same router as your laptop. Boot the Pi. It should grab an address from your router. Use ssh from your laptop to login to that address. 2) connect your laptop to the Pi's serial link (P1-8 is TXD, P1-10 is RXD, P1-6 ground) using a 3.3V serial dongle. Start minicom or similar on your laptop. Boot the Pi. You will be able to login via the serial link. $URL$ 

I'm not sure if anyone will write the code for you. It's too broad a question. You need to acquire a basic understanding of Python programming first, otherwise you'll be forever asking questions. Personally I'd use the Python curses module (import curses) to handle keyboard entry. There are example of using curses within pigpio at $URL$ and $URL$ On the servo speed. Generally the speed of continuous rotation servos is controlled by the pulse width. 1500µs is the dead band and means stop (perhaps controlled by a trimming screw in the servo housing). As you increase the pulse width to 2000µs the servo goes faster and faster in one direction. As you decrease the pulse width to 1000µs the servo goes faster and faster in the other direction. 

EDITED TO ADD: I forgot the 2 amp polyfuse at the microUSB. So two amps is the effective maximum you can feed into a B+ via the microUSB. 

You can send the same commands from any programming language you want (slightly easier from C or Python). 

It may be because the SPI struture is not fully initialised. This error did not use to matter but now causes problems. 

The most likely clash is with GPIO 18/19/20/21 (pins 12/35/38/40). PWM (medium quality audio) uses GPIO 18/19, PCM (high quality audio) uses GPIO 18/19/20/21. Check to see what your motor driver is using which clashes and use alternative GPIO. 

The normal way is just to stop the servo pulses. You do that with pigpio by specifying a pulse width of 0. Remember that when the servo isn't getting pulses the only thing which will keep it in place is the friction in its gearing. 

Here is some Python I used to test the reliability of software serial. The input side is fairly trivial. You just make the appropriate bit bang serial open calls in Python or C. The output side is more involved as you have to use waveforms to construct the bit stream. The code here is using 7-bit rather than 8-bit data. The test was written at about the same time as I was adding support for different bits per byte. The code writes blocks of binary data to a gpio connected to a laptop (via serial dongle). The laptop echoes the incoming serial data to its output serial line. The Pi reads the serial data on another gpio. The code checks for discrepancies between the sent and received data. The laptop is assumed to be error free, so any errors are assumed to be in the bit banging. Looking at the logs anything less than 19.2kbps was solid. Anything up to 115.2kbps was reasonable (but would require checksumming) and 230.4kbps gave a 13% byte error rate. 

If possible replace /tmp (or whatever you choose) with a file system stored in RAM or on the nextwork to minimise SD card read/writes. Then to view your debug messages use 

No, there is no way to guarantee the state of the GPIOs between power-up and the time your software runs (likely to be at least 20 seconds or so). You will have to use external hardware to drive the GPIOs high or low if you want to control the GPIO state during that period. 

If it does that shows the software is correct which suggests either a problem with the TMP36 or the wiring. 

By DT11 I assume you mean the DHT11 humidity and temperature sensor. The principal problem appears to be the very common fault of incorrectly connecting the cobbler. The ribbon cable appears to be twisted. To check the cable test the 3V3 and 5V points on the breadboard with a multimeter. If you read 3V3 where 5V should be and 5V where 3V3 should be the connection is wrong. A problem of lesser importance is using the Adafruit software which is particularly poor at reading the DHT11 and DHT22 sensors. However it may have improved since the last time I looked at it. 

The standard Pi SPI driver has two slave selects (CE0/GPIO8 on pin 25 and CE1/GPIO7 on pin 26). If you are using SPI then simply connect the other SPI device to the other SPI channel. 

The actual error is probably the call to f.closed rather than the intended f.close. f.close will close the file. f.closed will return a Boolean indicating if the file is open or not. The script presumably fails when it runs out of file descriptors or memory. 

My bold. See $URL$ So the HAT is queried via I2C on GPIO 0/1 (pins 27/28 on the expansion header) and has the needed device tree information to set up the GPIO. This is all handled by the kernel during boot. 

The crash is probably because Python never gets a chance to garbage collect and runs out of memory. Add a time.sleep(0.05) or similar in your while True loop so that garbage collection gets a chance to run. 

Download piscope as it will show you pretty much everything you need as far as GPIO changes on the Pi. $URL$ is a Python example of a PWM monitor and may be more suited to your needs. 

You have misread the eLinux site. SPI on the Pi can manage a transmission bit rate of 32 Mbps, i.e. bits per second not samples per second. The "official" SPI driver tops out at about 20ktps (twenty thousand transactions per second). If you talk directly to the SPI hardware you can manage perhaps 100ksps for 12 bit samples. E.g. $URL$ I'd expect 100k transactions per second is pretty much a limit. If you can squeeze more than one sample into a transaction you might get higher sample rates. The chips I've used only provide a sample per transaction. 

The HC-SR04 sonar ranger is not an I2C device. You should not connect it to an I2C bus. It needs to be connected to two spare gpios. An output gpio for a trigger pulse and an input gpio for the echo signal. To take a reading you set the trigger gpio high for >10 µs and then set it low. The echo line will read high thereafter until the sonar echo is received when the echo line will be set low. The high time indicates the round trip echo time. If the round trip time is measured in µs the round trip cms can be calculated from round trip cms = round trip time / 1000000.0 * 34030 If you power the sonar ranger from 5V (as you should if you want reliable readings) you will need to use a voltage divider to drop the 5V echo output to a Pi gpio safe 3V3. An old example for a similar ranger is given at $URL$ 

Raspbian is based on Debian. Debian generates three releases: stable, testing, unstable. See $URL$ The "stable" distribution contains the latest officially released distribution of Debian. The "testing" distribution contains packages that haven't been accepted into a "stable" release yet, but they are in the queue for that. The main advantage of using this distribution is that it has more recent versions of software. The "unstable" distribution is where active development of Debian occurs. Generally, this distribution is run by developers and those who like to live on the edge. Raspbian sort of tracks stable and testing. It does not have the equivalent of unstable. jessie is the current testing. If jessie doesn't use the version you want you'll need to wait or build it from source. 

ALL the Pi GPIO are 3V3. NONE of them are tolerant of voltages outside the range 0 to 3.3V. EDITED TO ADD: The only pin which feeds into the Pi will be that connected to MISO (Master In Slave Out). The simplest thing to do is use a voltage divider on that line to cut the ADC 5V output to a Pi safe 3V3. A voltage divider is typically a pair of resistors. For an example see $URL$ 

A GPIO can only supply a little current, perhaps 60mA or so, whereas the 3V3 rail can supply up to 1 amp depending on the Pi model. It is probably not safe to draw more than say 20mA from a GPIO for an extended period (which may be of the order of seconds) as they are not designed for that purpose and you may destroy the GPIO and/or the Pi. It is also dangerous to drive any inductive load (like a motor) directly from a Pi GPIO because back EMF may destroy the GPIO and/or the Pi.