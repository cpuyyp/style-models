The word "copy" implies an operation that is non-mutating and non-destructive. When I copy something, I expect to have my original and something new. Allow for the case that no copies are generated. It shouldn't be an error if I ask for 0 copies, just give me back my original object and an empty container. If I pass in a k > 0 as my number of , I would expect some container with a bunch of copies of my original object. Not one extra copy to account for the original, but k copies. I actually prefer a container of multiple copies of my original element, as I can then decide whether I want to append the various copies or interweave each individual element. If my , this is an exceptional situation of user input error, and should handled appropriately. 

The declaration for shadows the declaration of for . The C++ Standard says this behavior isn't allowed. 

If you define or suppress any of the special member functions, define or suppress them all. This is known as the rule of five. 

Pivot selection is important for ensuring performance that avoids the worst case of \$O(n^2)\$. Selecting the leftmost (as you did) or rightmost for a pivot makes quicksort vulnerable to sequences that are either ordered or reverse-ordered. 

Note: While the concept of is being added to the standard in C++17, a isn't being added. Dispatching on will use the optimized call to the contiguous operations of for all random access containers except . is not guaranteed to be contiguous and would fall back to copying by element. 

You already realize that you need a destructor to clean up the s on destruction. Do you need a user-defined copy constructor? The copy ctor value copies your data members. So, copying only copies the pointer, not the pointed to . Copying a populated results in two stacks, both with pointers pointing at the same data. You'll get undefined behavior when you double delete this list. 

If you explicitly define any of the special member functions for a class, you must define them all. The following five are considered special member functions. (see Rule of Zero/Three/Five) 

Know and apply the Rule of Zero, Three, Five. When classes are concerned with ownership semantics, they should define all five special member functions: 

You can minimize (re)allocations by reserving space before appending to your container. We know how large the data set is going to be because it's provided by the subtasks as the first value read. Use the information provided. 

Order your includes. On small projects in may not matter as the number of includes are small. As the project size grows, you'll find yourself with a long list of external resources and you want to ensure that you do not have any cascading dependencies. Ordering also helps with readability as it is very easy for the reader to find whether an include already exists in a sorted list. Typical ordering is usually done by source type (interface/user libs/3rd party trusted libs/stl) then name. Use the c++ version of c libraries. Libraries like , , and others, typically just dump all of the variables and functions in the global namespace. This is a source of pollution and can cause issues related to name collisions and implicit conversion errors. Avoid these issues by using , , etc.... 

are not null-terminated strings like C-Strings. What you wrote still works because the standard allows it to work. From the C++14 standard (n4140 was the last publicly free draft before standardization) 

Literals types are implicitly convertible to , so you don't need to explicitly check. , (which is just a macro for ), or all implicitly convert to , so if is , the conditional evaluates to . If is any other value, the conditional evaluates to . 

Avoid as it does more than stream the end-of-line character. If you want the behavior, explicitly stream to indicate to the reader that it was intentional. Careful with your passing-by-value in the lambda. Prefer to use instead of explicitly typed variables to minimize your commitment to details (minimize rigidity). 

Be consistent with your and reference () usage. Did you intend to copy by value or did you intend to reference? Should the argument be ? Avoid loops without braces. Braces help make it clear to the reader that there is a block of code present. Braces also help clearly define the boundaries of a sub-block. Prefer using a separate line for single-line blocks to simplify setting breakpoints in debuggers. 

You're pack expansion could be abstracted into a general purpose function that applies a parameter pack to a function. 

Note: You don't have to use exceptions, but RAII does provide you with the flexibility to choose whichever error handling system you want (exceptions, checked errors, etc) while simplifying the cleanup process. 

Prefer to construct data members through the member initializer list. Prefer the literal type instead of the macro . 

Keep functions short and simple making them easier to read and test. Functions should perform a single logical operation. Look for opportunities to reuse code. An example; Let's start with some basic IO helpers that uses NRVO. You can extend it to print out prompts, validate input, but for this exercise, it's something basic and can be used on all of the challenge sites. 

Don't repeat yourself. You have some duplication in the digit check between the first character and the rest of the string. may have null characters embedded in its contents. Unless you intend to read up to the first encountered null character, prefer to use the / member function. 

Again, polluting the global namespace. You can avoid many common errors by not importing the entire standard namespace and just qualify your types/functions with . 

This is probably not the intended purpose of as copies and buffers are used in the background to handle resizing. You could just use the erase-remove idiom. 

Other options include using typesafe with containers like Alexandrescu's , , or classic / result types. If you don't care about the error type, you could use an . 

Carefully name your functions with a meaningful name. doesn't really tell anyone what to expect as a result. Prefer to distinguish language constructs with spaces. You can use the contextual boolean conversion operator to check the if the stream has failed rather than explicitly calling . Prefer to avoid . Be aware of what the manipulator actually does. Stream as it explicitly states your intent, correctly outputs the end-of-line character, and is shorter to type. 

When recursively pack expanding, you have to consider what can be passed. You handled the cases where the pack contains arguments. What happens if the pack doesn't contain arguments? As @prettyfly mentioned, define the behavior for that case. Looking at "Parameter Pack", we can also expand through a braced-init-list (). A braced-init-list guarantees left-to-right evaluation of the parameter pack. Note - The reference page for "Parameter Pack" uses for the pack expansion. Zero-length arrays are not standard and are only supported through compiler extensions. Ensure the resulting expansion has a size of 1 by padding the resulting array. - end note 

Avoid . Directly state your intent in code and be aware of what does. The following two statements are equivalent (ignoring localization). 

If a class has a raw pointer (), consider whether it might be owning. Use (C++17 library feature) or a raw pointer for non-owning pointers. Use when you need to represent single-ownership. 

Obey the Rule of Three/Five/Zero. Resource management frees the client from having to worry about the lifetime of the managed object, eliminating memory leaks other problems. A resource could be any object that requires dynamic creation/deletion. R. Martinho Fernandes defined the Rule of Zero as follows: 

Optimizations: Use a better pivot selection. If you select the ends, you are vulnerable in the worst case on sorted and reversed sorted inputs. If you select the middle element, you are vulnerable to bell-curved inputs. Better Single-Pivot options would include median-of-3 and ninther. There is also a Dual-Pivot approach to quicksort. For single-pivot partitions, you should guard against sequences with many repeated elements by using three-way partitioning. Partition in-place. Your partition algorithm wastes a lot of space as it allocates two temporary buffers that cover the full sub-sequence. You can optimize pivot selection and partitioning to the iterator type. See Alexander Stepanov's Notes on Programming. Consider using insertion sort at a certain threshold. Insertion sort performs fewer operations (swaps, comparisons, etc) and takes advantage of architecture caching for smaller arrays. Reduce more space by taking advantage of tail-call optimization. Call qsort into the smaller side first then use a tail-call to recurse into the larger half. 

Prefer to give macros unique names. Macros do not obey scope rules and if a common name collides with a symbol of the same name, problems will occur. You can add uniqueness to the name by employing a naming convention. Let's say the file could be found in \mylib\container\stack.hpp. I could use a common directory structure header layout with a randomly generated universal unique identifier: 

Use RAII to encapsulate your resources into objects that enforce the create/destroy pairing. You can write your own RAII wrapper objects or (better) use a resource factory that creates /'s. A concrete factory for arbitrary SDL resources: 

While this is a small project and your includes are minimal, I would still recommend you order your includes. From John Lakos' "Large Scale C++ Software Design": 

Certain inputs can make your partitioning algorithm behave poorly, degrading from \$O(n\ log\ n)\$ to \$O(n^2)\$. In your implementation, your pivot choice of picking the median is vulnerable to organ-pipe input sequences (\$1, 2, ..., n/2, ..., 2, 1\$). If you want to use the median, consider using a stronger pivoting rule, such as the median-of-\$k\$ (median-of-3, median-of-9, etc). Certain inputs also just break your code. Your implementation produces a segmentation fault when trying to sort an empty sequence. 

Keep your headers organized for readability and maintainability. Any source files you generate should be self-sufficient by including the headers of any symbol used. While some files will include others (e.g. including ), the behavior is not guaranteed. You are missing: 

returns copies. Have you considered returning [-]references? Consider providing on member functions that do not mutate. See -correctness. 

Doesn't make any changes to the itself, consider -correctness. If the denominator ever became negative, do you plan on simplifying (normalizing) the sign to the numerator? 

If you refer to 's constructor documentation, you will notice neither nor the allocator accepting version are as either could throw. That violates the commitment you made in your function signature that was . You are constructing the container with default-inserted instances of . What happens if is not ? 

Calculating the size is a linear operation. Have you considered just storing the current size in the structure and updating the value as you operate on the list? That would make calling size a constant time operation at the cost of the size of an . 

Don't pollute the global namespace for other users who might use your code. Either wrap your helper trait types in their own namespace or alias the trait type locally. Template arguments must be a type. Don't forget . 

Consider using a circular buffer or writing your own LRU cache adaptor for some buffer type. By decoupling the LRU functionality, this object can focus on just adapting its interface to the composed-from objects. It also removes the need to explicitly define a default constructor (unless you define a conversion ctor). 

Abide by the Rule of Zero/Three/Five. If you define any of the special member functions (destructor, copy constructor, move constructor, copy assignment, move assignment), then define them all. Scott Myers takes this a step further and recommends you declare them explicitly and explicitly opt into the compiler-generated implementations. 

As Jerry Coffin mentioned, you are basically reinventing . I wasn't sure if I wanted to review this or flag it as broken code, but it technically compiles and it technically works for one conversion (perhaps a discussion for meta-cr). Test your code thoroughly. 

Don't say in comments what can be or is already stated in code. Vowels do not cost $500. Having a smaller variable name because your abbreviation strips vowels or truncates the end doesn't translate to better code or performance. Abbreviations negatively impacts readability and maintainability, which are two very important aspects in programming. 

Focus on using as building blocks for larger functions. In the case of insertion sort with bidirectional iterators, you could separate the logic of finding the insertion point from the shifting. 

Use symbolic constants instead of magic constants (, , ). If you are taking a modulus of 7, will never be greater than 7. The branch is never taken. 

Prefer initialization to assignment in constructors. For members initialized by a constant, prefer in-class initialization to member initialization. This helps avoid repetition and maintenance issues. Your code is explicit in that the same value is expected in all constructors and you avoid use-before-set errors. 

Applying this to a single pass approach, you will need to store the preceding element in a temporary. 

Functions cannot be defined to take arguments of type . If a type is passed as an argument to a template, substitution failure will occur, and the compiler reverts to the built-in comma operator. b. Discard the result 

If you plan on writing portable code, prefer guards over . While most compilers provide support for , there is no guarantee every implementation behaves the same. Be aware of the pitfalls of if you decide to use them. 

Package meaningful operations as carefully named functions. Code becomes more readable, more likely to be reused, and be easier to test. Your functions essentially search (by value or index) then insert (after node). Return the correct types. C++ has the for returning or . attempts to cast an to whatever is, which could fail. If you need to return to the callee the state, consider an enumeration or one of the error reporting strategies listed below. Check to make sure your preconditions are not violated. Should the default behavior for passing an out-of-range index into (either too large or negative), result in a new node being appended to the end? 

If you are using any modern compiler that supports c++11 or later, you should be using in place of . It has been determined that rand() is harmful and should no longer be used in C++11. 

You should be getting warnings about unused results. If someone you were working with was evil enough to overload the comma operator, that could have a side-effect on the expansion. You can guard against that by casting the result of your each expanded expression to . Casting to has the effect of ignoring the result and ensuring the built-in comma operator is used. 

That trailing could potentially cause problems later. Put each conditional branch on its own line to assist with readability and maintainability. When interrupting flow control of a program using , , , do not use or on that returning branch. This helps reduce excessive indentations that may harm the readability of the non-branching path. 

Follow the rule of five. If you define, or any of the special member functions, you should consider if the behavior of the other special member functions are appropriate. In C++11, the special member functions are the destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator. 

Since programmers and their tools work mostly from header files, prefer to assign default values at the function declaration site, and only assign to that parameter once. 

Also, some non-member free-standing functions, like comparisons, math functions (abs, sqrt, pow, invert, truncate, modulus, negate), boolean conversion (including ), increment/decrement, sign determination, etc. 

Use class access modifiers to prevent users from calling member functions designed to be used internally only. For pointers and references, prefer the C++ declarator layout. C++ emphasizes types, not variables. Anchor symbols to the type () or leave them unanchored (). Whichever you choose, be consistent. Note: This enforces the suggestion that you should only declare one variable per line. 

Organize your includes. On a small project like this, it's really easy to make sure you've included everything you want. On a project that has 30+ includes from various sources (STL, Boost, LLVM, your own stuff, etc), it will be difficult to make sure you've included everything and there are no side-effects like cascading dependencies. You should order your includes by reliability of source then name. 

Every line that gets printed prints an extra delimiter at the end of the list. An extra whitespace character might not do anything, but it certainly isn't intended. Strive for correctness in your programs. Avoid . Directly state your intent in code and be aware of what does. The following two statements are equivalent (ignoring localization). 

Note: The third parameter in the detail functions utilizes integral types for priority tag dispatching. 

So, if you have types and are working with contiguous areas of memory, something as simple as a and a call to can offer speed-up. You would end up with something like this: 

Don't use macros for functions. Macros don't obey argument passing, scope, or type rules. Macros may be interpreted differently by the compiler compared to the reader's interpretation. Prefer throwing a standard-library exception type or a type derived from the hierarchy. 

If a class manages a resource, define a destructor. Don't rely on users manually calling a function to free resources. Destructors are designed to do this. If you define a destructor, you probably need to define or suppress copy/move operations. Obey the rule of five and be aware how the default behavior interacts with your owned resources. 

Is responsible for the lifetime of data? Is it an adaptor that operates on some other set of data managed by something else? Someone has to clean up data when the program exits.