As we are printing out the natural numbers, starting from 1, and going to r*(r+1)/2, I would just have a variable that keeps counting upwards. Then I don't have to work out what number the row starts with each time, and you are incrementing i anyway, so there is essentially no extra work done by having a count, and you save a few operations too. 

I only have a few quick points, Names and consistency: In general, keep variable and function names to starting with lowercase. When I see an uppercase word, I think it will be a class. A second point here is if you are getting input, make sure the function name states that. There is no reason NameAndEmail couldn't be getNameAndEmail, and I know what the latter function does immediately. NameAndEmail looks like a class. 

I may have missed some bits and pieces, but the idea here is to give you a starting point so you can look at your own code and decide what is good, and what needs to be changed menu.py 

Lastly, and most importantly, since the triangle is symmetric, only half of it needs to be generated in the first place. The mid point of the row is given by row/2 + 1. 

At first: This is a really nice question for an interview. You can show off your knowledge of data structures and algorithms here, but you can also demonstrate how familiar you are with your programming language and concepts like test driven development for example. So, what went wrong here? At the first sight, your solution looks "ok". If you look a little closer, there are some issues: Data Structures You were pretty spot on when choosing a tree here. You could have done a little better by calling it with its common name, Trie. That comes from retrieval and is described in detail over here. This data structure in its simplest form (we don't need any more for solving your problem) consists of trie nodes that have 1.) children where each child is assigned a character and 2.) a marker if this node is the last character of a word (so that we can distinguish a prefix of a word and a complete word). You tried printing a graph as an example, which unfortunately got lost in formatting. Here is one from Wikipedia: 

Bam, test is green now. Next one! (Don't do more that you need to make your test green. Deleting the NotImplementedException is enough for now.) 

It's just a convention but being able to easily spot names that denote types helps if you start to use more complex expressions. For example: 

One disadvantage is that you can't easily construct a temporary with explicit initial values. If you need to do this you could consider a helper function analogous to . E.g. 

Otherwise I think I'd go with with a hash of subroutine references. It's easily readable and simple to update. 

Because either is technically acceptable, you are right that it is a style issue and simply a case of choosing a coding convention. However, I think that you have hit a very important point. So few other languages that use parentheses for functions allow a parameterless function call without parentheses that it can be very surprising for developers unfamiliar to perl. This point would sway me in favour of always using them and, indeed, I always do so out of habit because I use other languages a lot and it just comes naturally. 

The comment is really bad because it talks about whereas gets the value and gets the value . I think the comment needs a pair of parentheses if the code is doing what you meant. To be robust, you should check whether the parse worked. 

Why not call it playerX_name? Then the comment can be removed Self documenting code is always preferred over comments if possible. 

If it makes it through the loop, we should just return true The second thing of note is the definition of a palindrome, here are two ways of looking at it 

I gave a naive solution as seen below, where I simulated the grid with a 2d array, and applied each operation as it came. I also tried to implement an array of fenwick trees, but that solution gave more timeouts, so I believe there are a lot more add and remove commands than query. Code: 

This is equivalent to a list comprehension (or a filter) that might be easier to read. also reusing peiceSet for both the iterating variable and the list seems weird and possibly buggy 

I attempted this problem from the ieeextreme, and I got timeout for just over 40% of the cases. Now that the competition is over, I was wondering what could be improved. The problem is as follows: 

This is discouraged, I don't think it makes much difference in a program of this size, but it can be a bad habit to rely on. 

Lets have a look at the algorithm you are using, and see if we can tweak it. First you get each vowel. Then you reverse the list Finally you get the index of each vowel and replace it with the next vowel in the list. There is a bug here, list.index will return the index of the first occurrence of a vowel, so if you replace the word with "aapiple" you will see the bug in action. The main area of interest is getting the index of each vowel, so lets do that. 

In addition to the other comments, I would also use a different naming convention for types and objects. For example, this looks unconventional. 

Being a trivial POD-struct, most compilers will have little difficulty in eliding most of the implied copies. There is some argument that deserves to be a class as you have no setters for its members, but given that it has little behaviour and the behaviour it has can be provided by free functions I would keep it as a POD . Clients can choose to make a instance should they so choose. Also, I don't see any need to make take a reference to a . It can return by value for more readable code. 

I don't think that your solution looks bad. I would probably use a temporary variable to make the line length a bit more readable. You could consider from the module. E.g. 

If you are using the standard library classes of the same name, I would give the following names the correct namespace qualifier: , , . In C++, this works just as well, IMHO it's mildy more idiomatic. 

If you can pass in the subroutine it makes the code a lot simpler, you also don't have to deal with an unknown string format as the subroutine itself has been passed in. 

There is a little room for improvement here. While we only use constant extra memory, our time complexity has gone up from O(nm lognm) to O((nm)**2). For a better time complexity, I would recommend using inplace quicksort which brings us back to O(nm lognm). Another point is that we are doing too much work. Once we have worked our way up to the row N // 2 and the slot M // 2, we are actually done! We have put the median element in it's place, and we can stop. This is a simple enough check to add, but can cut the actual running time of the code in half. 

Algorithm What can we say about a knights move? It moves the piece 2 squares in a line, and then 1 square perpendicular. You have listed all the possible moves, but we can just check if one of the absolute differences is 2, and the other is 1. 

and are used without or , if you are using them for the size of the text, this is easily fixed with CSS. There is also a break-line tag inside the for some reason? Again, style with CSS, not with whitespace. 

There is a decent chunk of text here, so TL;DR is rename variables so that they are more descriptive, don't treat players any different from one another and make functions that represent that ideal, and finally removing duplicated code often gives leeway to notice patterns and simplify code even more. I hope you take on some of the points and post a follow up, I'm very interested in seeing more from you. Good work! 

You could add additional features like a collection of values for each trie node or prefix search, but I guess this simple implementation would have solved your question. 

Instead of looking for one child node, a "?" means looking in all child nodes. We can generalize that: GetChild(char) gets renamed to GetChildren(char) and returns an IEnumerable: 

This is the tricky part. To make this work, we have to add the aforementioned dictionary of child nodes. Adding "word" creates child nodes for each character; finding "word" checks if the next child node exists and recurses down the tree: A trie node finds "word" if it has a child node "w" and this child node finds "ord". 

In your solution, you have used two HashSets (of TreeNodes and chars). I don't understand what the Index set is for, as you didn't include your code for adding nodes. The bigger problem I see here is the type HashSet itself: They describe unordered lists of stuff ("sets"), and you are trying to access them using an indexer (e.g. ). This will not only give unpredicted results, it won't even compile. There is no indexer on HashSet. What you actually want to use here is a Dictionary. Looking at the graph above, we seem to be navigating along using characters. That means, in every node, having one character we can determine the next node to go to. A dictionary can do that for us. The whole thing Rather than trying to come up with some working code during the interview, I would have talked about the architectural and algorithmic features of the to-be-built solution. I guess, if you had written out some unit tests that specify the behavior of the system it would have come out better than writing code that obviously won't even compile. Let's see how we can easily build the whole thing using TDD (Test Driven Development), writing tests first and then bringing them from red to green by developing and refactoring our Trie. Please create an empty Unit Test Project and create a new file in there. Add the NuGet package "FluentAssertions". You can paste each method stepwise to see how the solution matures. If there is a attribute above, add it to the class. If there is no attribute, add or update the method in . We start with: 

Personally, I would also avoid . You need to either or to use it. Although the system call itself is standard C++ (from the standard C library), what you pass to it is system dependent. In general I don't believe you should make your programs stop artificially. If they are designed to run in a terminal then the terminal user will be able to see the output even after the program exits. 

is almost always a bad idea. Even in small programs I would avoid it. Your algorithm for is just plain wrong. The area of a triangle is half the length of a side multiplied by the perpendicular distance from the third vertex to the base line, not the distance from the vertex to the mid-point of the base. (Think of a triangle with vertices at (-1,0), (1,0) and (1, 1). The area of this triangle should be 1, not sqrt(2).) Reviewing your class, the default constructor doesn't initialized the member variables. This may be acceptable for performance reasons - for example - if you deliberately want to be able to create large arrays of uninitialized but it's often safer to explicitly initialize all class members in a constructor. Having both getters and setters for and effectively makes them public data members. The only functionality that has is but this can be provided as a non-member function. Once you've done this your class provides no functionality that a simple doesn't. In addition, you can use aggregate initialization for a which can be useful. E.g.