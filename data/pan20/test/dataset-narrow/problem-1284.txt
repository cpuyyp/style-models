You can use MonoTouch and write your own GL code, but it isn't nearly as fast to get something up and running as using Unity. $URL$ 

There are two basic concepts: 1) Parallax mapping bullet holes (This is what Fear 1 used). It doesn't actually change any geometry, but due to shader magic it looks like there's a hole where you shot. 2) Actually breaking off chunks of geometry. The Unreal engine has something called the Fracture tool which helps author this content. I'm not sure how it works under the hood, but here's the documentation on how to use it: $URL$ 

At its core you are going to have to predict which tile the target will be on. A simple solution would be to take the current velocity of the target, figure out where the target would be in the amount of time it would take the bullet to traverse to the player (to get a rough estimate you could use the current distance to the target), and then aim at that tile. 

Yes. But most of them are subjective. There is a huge gamut of different patterns in making a game. Some related to 3D graphics (and all its various subgenres like lighting, filtering, shaders, etc. etc. etc.). Some for features like streaming in level content. Lots of books on collision paradigms. There's a battle for OO vs. data-driven design. Components vs inheritance hierarchies. People can't even agree on what is the best way to pump updates to entities in a world (fixed rate or passing in per frame deltas, for one part of the argument). People have different opinions about whether or not generic programming is a good thing. There's no way to really answer that question as stated (other than "yes"), it's too broad. 

I'm just going out on a limb here and assuming that your drawing is painter style, in that something drawing first will show up behind something drawn after it. If that's the case, it's simply a matter of sorting your entities by y position before you draw. I'm assuming you have some mechanism of iterating through all of your entities. You'll have to sort every time the list get modified, which if you have continuously moving entities will probably be every frame. There are a handful of optimizations you can do with this. For one, you probably want to discard objects that aren't in your viewport at all, first. It's pretty common to put entities in tiles and then only sort those tiles. But those can come afterwards, depending on your performance issues.. 

If you have the Yaw and Pitch giving you the X and Y, can't you just assuming your roll (Z) is 0? Most game characters don't allow you to rotate on that axis. 

Each draw call has a certain amount of overhead. By using sprite sheets you can batch the drawing of things that aren't using the same frame of an animation (or more generally, everything that's on the same material) greatly enhancing performance. This may not matter too much for modern PCs depending on your game, but it definitely matters on, say, the iPhone. 

It "just works". None of this trying to ham fist tech together like in your OSS solution. Lots of tech focused on realistic humans. Ragdolls are good, IK (for proper foot placement) is good. Pathfinding is there (I think). Physics is pretty polished. And you get their facial animation tool which lets you do passable cinematics in-game along with gestures (partial additive animations). NPCs have things like "interest points" that they'll occasionally look at when wandering about, or event-based reactions to things (for example, saying something if you throw a physics object at them or if you're at low health). It's not Unreal. You're working in C++ as a programmer instead of UnrealScript. 

Do you mean if the circles are overlapping? That's easy, just figure out the distance between the two and compare it to the r1 and r2. Or more specifically, calculate the squared distance between the two (it's faster) and compare it to (r1 + r2)^2. If you mean what the actual intersection points are of the two circles, then I don't know the math for that offhand. 

I think looking at it from the "this item is too powerful" point of view is missing the point a bit. In my view, it's more about hoarding items because they're limited. A good example of this problem happening is in a game like Skyrim where you can make potions. Sure, 5% fire resist for 5 seconds isn't terribly powerful by almost anybody's standards, but it still accumulated to the point where I didn't want to get rid of them because 1) they were a limited amount and 2) I couldn't predict the future. So that being said, I would look at the problem as a way to mitigate hoarding behavior. One of the most successful approaches I've seen is to take the items away from the player at known intervals. For example, make it so you get consumables inside dungeons, but once you leave the dungeon the consumables go away. That way, the item can't be hoarded because it isn't permanent. Since you don't have persistent consumable inventory beyond the dungeon, the user doesn't feel that the item has as much value. Alternatively, you could also do things like dramatically limit the number of single use items the player can carry. The logic being that if you don't use the items you're leaving a bunch of consumables behind. It isn't as good an approach as forcing the items out of the user's inventory, but it might also encourage the user to churn through their items. 

The iPhone 3GS is just as capable as the 4 (armv7, ogles2, latest iOS software) and there are a decent number of them out there. I don't think there's any way to prevent those devices from seeing your game in the store so unless you want the occassional bad review I'd try to support them. $URL$ 

So reading through your updated question, it seems you're most concerned about "redundant data" on disk, with some secondary concerns about load times and what the industry uses. First off, why are you worried about redundant data? Even for a bloated format like XML, it would be pretty trivial to implement compression and get the size of your levels down. You're more likely to take up space with textures or sounds than your level data. Second, a binary format is more than likely going to load faster than a text-based one that you have to parse. Doubly so if you can just drop it in memory and have your data structures just there. However, there are some downsides to that. For one, binary files are next to impossible to debug (especially for content creation people). You can't diff or version them. But they will be smaller, and load faster. What some engines do (and what I consider an ideal situation) is implement two loading paths. For development, you use a text-based format of some kind. It really doesn't matter which specific format you use, as long as you use a library that's solid. For release, you switch to loading a binary (smaller, faster loading, possibly stripped of debug entities) version. Your tools to edit the levels spit out both. It's a lot more work than just one file format, but you can kind of get the best of both worlds. All that being said, I think you're jumping the gun a bit. Step one to these problems is always describe the problem you're running in to thoroughly. If you know what data you need, then you know what data you need to store. From there it's a testable optimization question. If you have a use case to test against, then you can test a few different methods of storing/loading data to measure for whatever you consider to be important (loading time, memory usage, disk size, etc.). Without knowing any of that, it's hard to be more specific. 

One of your best bets is to look at SmartFoxServer Lite. It's free, but better packages cost money. It's basically a socket server that uses JSON for all its communication and works well with various clients. (I haven't used it myself, but heard it recommended in the past.) 

With the current version of Unity, just check in anything in the Assets folder and ProjectSettings folder. Don't check in anything under Library, or at the top level. 

One relatively easy pattern I've seen several games use to a varying degree of success is to have the player change something about themselves instead of something about the world. Red Dead Redemption is a good recent example of this. Basically the idea is that you try to structure your player's goals in a way that they can choose to do "good" vs. "evil". The end result is mostly the same (or if it's different the difference doesn't affect much outside of the little area of the world). The way the player feels like the world is changing is then solely due to the semi-emergent behavior of the NPCs reacting to the player given his notoriety. You set up your NPCs to say random things to the player and have good and evil player chit-chat banks. You might even go so far as to start structuring the major quests' wording depending on how good/evil the character is. Maybe you set up some kind of ancillary "faction" system where if the player starts down one path they can reinforce it with a separate (but smaller and therefore more maintainable) set of quests to accomplish. Of course it doesn't have to be good/evil. You could do stealth/action, or whatever kind of choice dichotomy you set up for your player. 

Well it isn't just the percentage of users at the point in time you are starting to make the game that you care about. It's the percentage of users when your game is scheduled to ship (which for a lot of games can be several years down the line). Specifically in this case, Windows 7 has significantly less of a bad rap than Vista has in the gaming circles. Whenever those XP users upgrade their machine next they'll probably install 7 on it. Plus you can be pretty sure that the techniques in DX11 are probably going to be part of the platform for whatever Microsoft's next console will be, so there's that.