I suspect this is a glitch. The online info version doesn't say anything about -- which as you correctly argue would not make sense -- but does say: 

It depends on exactly what you mean by 'control'. If you, the attacker, get to choose two files that should have the same hash, that's what cryptographers call a collision (attack) and for MD5 it's now very easy. If you can choose both files freely it takes seconds; if you have to satisfy fairly weak but common constraints like 'it looks like a PDF' or 'it looks like a tar' maybe hours to weeks. On the other hand if you have one file pre-specified (usually a 'good' one) and you must find another ('bad') file with the same hash, that is not a collision to cryptographers, it is a second preimage. The best known preimage attack on MD5 is only slightly better than brute force at 2123.4. Your $5k can probably buy half a dozen good GPUs, which gives you somewhere in the vicinity of 237 trials per second (about 100 billion). That is roughly 262 per year, so it will take on average about 260 years (about 1,000,000,000,000,000,000 aka a quintillion). In more convenient terms, that is about a hundred million times the age of the universe. Your computer probably won't last that long. 

CA cert and privatekey must (both) be in PEM format; you can include the privatekey in the cert file and omit the option. If you omit validity defaults to 30 days. oldcert and newcert are PEM by default, but can be changed with and respectively. If you are only doing this once, it's easiest to use for the new serial. If you will or might do this multiple times for one CA, to ensure each one gets a unique serial let OpenSSL use its serial-counter file by specifying on the first one at least. By default extensions are left unchanged. If oldcert has an AuthorityKeyIdentifier extension pointing to the old CA, and the new CA is different, this will make the resulting certificate unusable because it can't be validated. Other CA-related extensions like CRLDP and AIA may also cause problems. Use to remove the old extensions; if you do need (any) extensions in the new cert, you must configure them (all) in a file specified with and optionally (section). See $URL$ (and follow the link to x509v3_config if you need extensions). The warning under "... without the -req option the input ... must be selfsigned" is overstated; if not openssl gives an error message about "unable to verify", but does create the new cert as desired. Also, release 1.0.1 before f had a bug that causes this case to produce wrong output; make sure you don't use one of those versions. And as already noted unless you have the matching privatekey somewhere (possibly on a different system/app/whatever) the resulting cert is of very limited utility. 

When your alias runs that commands your shell to run the backquoted pipeline locally, which finds the name of the newest file in your current directory on your system, and sends that filename as part of the command to the remote system, where of course trying to tail that file doesn't work. Your options are: 

Not a complete answer yet, but some ideas/directions: That cipherlist change is meaningless. The term you added is in standard RFC format, also used by Java and some other things like Wireshark, but NOT the format used by OpenSSL; the OpenSSL format is which was/is already in your list. Also, is useless here; it would remove any export suites that had been added, but none have been, and it would prevent any further specs from adding them back, but there are no further specs. Some early versions of Java 7 SSL (JSSE), I don't remember exactly which but probably including 7.03, did have their default cipherlist in the wrong order, which could result in selecting a poorer than necessary ciphersuite, but your ignores the client order, so that can't be it. Recent versions of httpd have started defaulting to larger DH groups (for DHE, which you are preferring), and that does cause problems for Java 7 (and earlier) at least using its default crypto providers. But $URL$ says these changes were 2.4.7 and .10, so .10 to .12 shouldn't make any further change I know of. Query: Do you in fact have DH 1024bit configured as $URL$ suggests? If that isn't it, I would need more data. Is anything written in the httpd log(s) when the problem occurs? Can you get more details from the Java client with the problem, like an exact exception message? (Is this a client you can run yourself, or does it belong to another person or persons?) Can you get a network capture of a failed attempt with Wireshark or tcpdump or similar? If all else fails, can someone run the Java client with or equivalent, and get the (rather voluminous) resulting output? 

This is unrelated to KB and MB in your example. You are performing a numerical sort in reverse order. 80 and 20 are both bigger than 8.5, so they get shown first. The letters are ignored for the sorting. See also 4.0K which is right in the middle of your list. 

Also be aware that by forwarding port 22 from your router to your reconfigured port, you are essentially exposing port 22 to the outside. This was to be avoided through setting an arbitrary port in the beginning. Setting your router to forward another port to the sshd port on your server would probably be what you want. 

Yes. You can write your own scripts for Greasemonkey (Firefox) or Tampermonkey (Chrome) For the example you mentioned, this Tampermonkey UserScript will set all JavaScript links in the search results to open in new tab / window (this depends on browser configuration, it's tabs for me). 

A typical implementation used in the field is to route the destination hosts () towards . This is called a Null route. 

Though you can write more generic versions of this, enabling this functionality for all JavaScript links without breaking other usability will be hard. A middlepath could be to set an event handler for Ctrl, that will temporarily set the target for ALL forms to "_blank" as long as the key is held. 

You have to differentiate between MITM and someone intercepting your traffic. For unencrypted traffic (and logins), an attacker just needs to sit somewhere between you and the server you are connecting to. He can then sniff your password from the network, or any other information that is exchanged. For encrypted traffic this isn't as easy. To attack an encrypted connection MITM (man in the middle) is used. As the attacker does not know the key that is used by the server, the attacker pretends to be the server to you. He then connects to the server and pretends to be you, forwarding your original request. Instead of one encrypted connection between you and the server, there will be two. One between you and the attacker, and a second one between the attacker and the server. This could be easily detected by you, if you care to check the key that the server presents to you while connecting. As the attacker needs to use his own key, you can quickly realize that you are not really talking to the server. With HEARTBLEED things get ugly right here. Heartbleed allows an attacker to obtain the original secret key directly from the server. At this point, you have no chance to figure out that you are being attacked. If you are using unencrypted connections all the time, HEARTBLEED doesn't affect you negatively. This is comparable to driving without a seatbelt on, when it is announced that there is an issue with some seatbelts that might cause them to unlock in a crash. It doesn't matter for you, because you are taking advantage of readily available safety devices. PS: Heartbleed leaks random data. It can be the private key, or anything else the server currently has in memory. Leaking the private key is just considered to be the worst case in this scenario. TL;DR: MITM attacks are rare, because they are hard to set up and are easily detected. Heartbleed is serious, because you can not detect it and it is much easier to apply. 

Select NAT. NAT stands for Network Address Translation. In this case, it will make all traffic from the VM appear to originate from your host system. Unless you need incoming connections to your guest system you should be fine with this. 

These shortcuts are not key combos, but key sequences. To save your current work you would first use Esc to leave mode. Then press :wReturn in succession. In there are many commands that are key sequences instead of combos, though both exist. Personally I think Engadget VIM 101 is a good introduction to (which is vi improved, and probably what you want). 

The easiest way is to use if your version of supports it. I have sort (GNU coreutils) 8.22 and it works like a charm. Is that the complete list? You should see the same amount of files as before, maybe different files due to sorting and cutting off a part. Please provide the exact command line you used. 

As should be clear from the manpage on your system or online assuming the CA cert specified in your ca.cnf is ca.crt and is the root cert, the basic function you want is 

SSH uses two different sets of asymmetric (private/public) keys -- one to authenticate the host/server to the client(s), and optionally a different one to authenticate a client to the host/server. The configuration in is for the keys for the host, not for any client. The directive in that enables pubkey authentication for clients is , but you don't need to specify (or usually uncomment) it because it is on by default. It should work, and does for me, to convert an OpenSSH-generated key with PuTTYgen and use it in PuTTY as you described, but ONLY if it is in for the appropriate user (*) -- this is required for ANY client key, no matter where or how generated. Generating a key on one Unix system does not automatically add it to on that system (since you don't usually need ssh to access a system you are already on) nor any other system (since this system can't know which other systems you might wish to access, including perhaps several years in the future). You mention adding to only for your new PuTTYgen-generated key, not the Unix-generated and PuTTYgen-converted one. (*) or other location if specified by in but that's rare 

In general you could also provide the command as input to the remote shell instead of a commandline (argument) 

and when you want to stop it, at latest before starting a new one using the same file, do (as the same userid) something like 

This won't work (and neither will piping) if needs to prompt for a password; that means you must either: 

If instead of displaying the decompressed output, I put it in a file and try on it (as SMIME format by default), it parses successfully but fails verification because the cert is selfsigned; if I extract the cert and manually trust it (which is of course not secure, but this is just a test) it does verify. HTH. 

(Answer from comments reorganized to logical order.) The encryption key value in this example is 32 chars that are valid hex digits, which are inherently also valid base64 chars. Normally one should know the encoding of data from the process that created (or where applicable sent) it. This value is very unlikely to be base64 because a base64 encoding of more than a few bytes, unless deliberately crafted, will almost always contain some chars that are not hex digits. And it is impossible to be base64 because 32 chars of base64 not using base64 padding () encodes a 24-byte value, but we know the value is an AES-128 key which is 16 bytes. Thus this key is hex encoded, and giving it to which expects hex decrypts correctly. 

OpenSSL routines read and write DER (d2i means DER-to-internal, i2d means internal-to-DER); read and write PEM. Routines where type is read and write public keys in generic X.509 SubjectPublicKeyInfo form, which is usually preferred (although there are alternatives). You have a private key in PEM format (nongeneric, but that doesn't matter) and the program wants a public key in generic DER format. Do 

(expanded from comment) has a capability to select 'ranges' of lines which matches this need perfectly, as described in the the GNU-awk (gawk) manual. (This feature works in other s but the manual is easy to link.) prints lines starting with the first one that matches and continuing until the end of input because is a condition that is never true. starts printing with a line that matches and stops after a line that matches but NOT (and thus cannot be the same line as the starting line). It will start again on a subsequent and so on; if you want to prevent that there are slightly more complicated ways to do so. If the stopping lines always have some character other than before the this can be simplified to which stops after a line that matches any character other than 2, followed by A. You might want a variation of this, e.g. to stop on any-single-digit-A different from 2A, but not other As like ; for that the stopping condition might be .