Why set the value of the checkbox to if it's not ? Shouldn't it already be false? Or can the value of a checkbox be "null"? I can't remember, but it's probably worth a comment if you're doing this to make sure the value is false instead of . 

Two Left Outer Joins and a Full Outer Join. There may not be much you can do about this unless you can trim down the fields that need to be returned. Start with trying to remove the Full Outer Join. It will have worse performance than the Left Outer Joins. Scanning an entire field will also be a bit on the slow side, but again, there may be little you can do beyond making sure there are proper indices on the table if this is truly a requirement. 

Which isn't really so much work, is it? However, to make this work cleanly, we'll need to define a simple data structre and populate it with appropriate values for high, medium, and low. I've used a here, but it might be worth creating a full blown class for down the road. 

Yes, that function terminate (unless the semantics of are stranger than expected and is an infinite generator). One thing to be concerned about might be that, should your query take a very long time, you would not delete a single blob before a is thrown, and so schedule another task without doing any work. This is a bad thing, as you may end up with many jobs that simply get half way through a query, give up and then schedule themselves to run again. The worst part is that your only indication would be that your log would be full of level messages (i.e. messages that will be ignored), giving you no idea that this travesty was unfolding in your task queue. I would recommend you add some kind of limit to make sure you are decreasing the number of blobs towards zero each time. You could think of it as an inductive proof almost; see Burstall's 69 paper on structural induction if you feel like formulating a mathematical proof. However, that is probably not necessary in this case. My suggested rewrite would be something like: 

Work continues on the Rubberduck VBA Editor Add-in. I have a need to call some VBA code from the add-in with . Unfortunately, the part of that refers to the particular Office Application that is hosting the VBA editor. So, if I'm working in Excel, refers to the instance of Excel (Word, Access, etc.). Unfortunately, these do not share a common interface, so I wrapped them up in one of my own so I could use them interchangeably. 

This way reduces (no pun intended) each step of the problem into a simple function and applies each in turn. Get comfortable with the filter/map/reduce concept. It greatly simplifies your code. 

Your class is very clean. I particularly like that you over rode the method so that it returns something meaningful. It's a little detail that often gets over looked. Well done. That said, I'm not sure what you're really getting from the class. 

The factory should return an instance of the base class or interface. Yours returns a concrete instance of the particular type. The factory itself should adhere to an interface and be broken into one factory class for each concrete type. 

Instead of using a global and variable, I'm returning the non-global and variables. This means that I have a lot more flexibility in calling the function: 

Q0Handler Numbers in class names make me feel slightly sick, and I have no idea what means; question 0? Because this view seems to handle all questions, not just question 0. We've already discussed the bug. There are a couple of other bugs; if I delete my cookie, I'll end up causing a bug when you try to do ; (same problem exists for ). When you do to increment the score, I think you could be vulnerable to a race condition, but that's not too big a problem (I think Mongo supports an atomic increment, use that instead). Python convention when passing named parameters is to use spacing not , but that's just stylistic. 

Overall not bad code. I don't agree with your comments on how would be inappropriate there, but it's far from the end of the world. In general, I'd try and be more careful to validate user input, but it may be that you do not need to worry about that. 

This catches every possible exception in the world, including potentially fatal memory errors. Be as specific as possible when catching exceptions. What specific exception would you expect to happen? Catch that instead, or none at all. The only other thing I want to mention is that is a poor name and the variable itself is kind of useless. Take advantage of the statement. 

Your method of obtaining a database connection string is misguided. If something is hard, it's usually because you're going about it the wrong way. Just use the data context ctor overload that takes in a connection string. 

Do you really need every column? Even with proper keys/indices in place, this will typically force a table scan. Explicitly state only the fields you need to return. It will result in less I/O and could possibly turn a scan operation into a seek. If it doesn't, you'll need to find the missing index to be added. The next thing you can do is remove the duplication. 

Instead of checking for the negative condition, check for the positive. It removes several lines of code and a comment. 

I think that covers it from me. There will probably be someone out there who will turn up shortly to shout at me for talking about security without a PhD, but I think you should be OK (Hash your passwords, kids!). 

MainHandler The name tells me nothing. Due to your routes being defined in a different place, maybe naming it something like would be better (though I still don't like that). An oft advised idiom on this site is the use of guard clauses. I'd recommend using that here; instead of 

Note that this does not explicitly address the lack of an inductive variable, though it does limit any damage done. Another thing to note is that you have a race condition on the . Should the method be called concurrently, say by process A and B, then the call to could return the same set of bobs to each. They would then attempt to delete the elements twice, which would raise an error on the call, leading to fewer blob deletions than expected. This problem gets a lot worse when we consider more processes and things like unspecified ordering. The correct way to handle this is to treat any exceptions thrown by the in a more nuanced way than you are currently, and accommodate multiple attempted deletes without prejudice. Your current code will work fine at the moment, the problems will manifest themselves when things get more complicated. While I am sure Google's infrastructure can handle these upsets, your bottom line may be less flexible. 

I'm not bashing on VBA, I <3 VBA, but it's just not the right tool for the job if you need it to run faster than this. What you really need is a language that's capable of multi-threading and asynchronous programming to make the most of the CPU time while you're waiting for those Http requests to return. Sounds like it's time to learn some C# or F# to me. Even Powershell may be a good option. 

I've been looking at this question for a while and I don't see many opportunities to improve performance. Nested loops 6 levels deep is going to perform poorly. It doesn't seem that there is any case in which you can return early either. Not all hope is lost though. Have you considered using a ? From the documentation: 

It's good to use the keyword when "newing up" variables as you declare them. The type is obvious and it will allow the type to be changed more easily should the case arise. 

General advice for decoupling logging from application code: Have your logger listen for events instead of injecting your logger into application code. This inverts the dependency so that business code doesn't need to even know that a logger exists. As for the amount of code related to logging in your class, I don't see it as something to be concerned about. If there's anywhere in a UWP app to wire these kinds of things up, this is the place. 

Are there any other reasons for using the -syntax without filtering, selecting or ordering that I might have missed? Which syntax is better and why? 

However, I would not recommend it. It is very likely that it severly reduces performance. There is just not much you can do about the switch statement and I would not mind seeing it there where it is now. But an alternative might be to move the switch statement altogether into another method, with the added benefit that it is possible to early out of the switch. 

Concentrating on the method, I see three times so that is something I would move to a common place. In fact, only its last argument -- lets call it -- changes. The initial value for is actually the default for when the two -statements don't fire. So I would put that initial value as an to that -statement. Last but not least: accounts for most of the clutter. By specifying an alias ( at the top) it conveys more meaning and makes it all more readable. The end result would be like this: 

I'll give some general comments now Application You currently hard code your urls, which could lead to a very brittle structure, and make extensibility a pain. Have you considered using class decorators to register route handlers? They'd look something like this: 

I'm not 100% sure there is a particularly elegant way to write this. If the code did not have a different body for each statement, one could rewrite it like this 

With that said, I would praise you for your style. For every problem your code may have semantically, it is formatted very well (hooray for PEP8) 

This is known as a guard statement, and they are very nice. Avoid using without specifying the type of the exception you wish to catch. In this case, it's particularly bad as you are not even logging the error; someone could come along, shoot a bullet through the hard drive of the machine you were running this on, and your service wouldn't note that anything of interest had happened. I'd suggest that when a request fails, you return a non-200 status code; at the moment, your bullet ridden hard drive will not cause a single non-200 status code. Download If the file exists in Mongo, but not in the FS, currently you say . However, due to the statement which doesn't specify exception types, your code also says that no matter what else goes wrong (recall the hard drive with a gun wound). I'd find out what class of errors come under the file not found category, and then treat them differently to others. Currently, if the user looks up a file that doesn't exist, you return , which I think bottle will complain about. It'd probably be better to add a guard clause along the lines of 

Holy arrow code batman! =) You might want to try to reduce the levels of nesting here. There's are several approaches you can take to do that, but neither do I know Java well enough nor have I studied your code hard enough to suggest how. 

Use an anonymous type to store a single object retrieved from the database and then populate your view from this temporary (and anonymous) object. Answering from my mobile, so I apologize if this doesn't compile. 

This line ties your class to access. It won't compile in any other host app. I try to keep utility classes like this host agnostic. Removing this option will allow you to use this class in any app that supports VBA. I honestly don't like this option anyway. It ties how the code behaves to the environment it's running in by letting Access determine how string comparisons are made. If you're going to use an , choose either or depending on your needs. Both of those are available in any of the host apps by the way. (I know, Access probably inserted this line for you, moving on...)