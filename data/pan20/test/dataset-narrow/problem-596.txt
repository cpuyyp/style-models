What are the alternatives? Since you seem to be using C++17, this is an ideal use case for . If this is not the case, then the guidelines support library offer as variety of string spans. If both of these options are blocked for you, you could template your way out on the type of the parameter. As a last option, you could also just simply take a or . About Overall, this method seems a bit unclear to me. Starting right from the definition, why do you have an anonymous first parameter? What is the point of it? This seems highly dubious to me. There are only few reasons to have such a parameter anywhere in the first place, and none of them seem to apply here. Does this method follow an interface requirement that you did not tell us? Seems unlikely since it is private. Following, what kind of Frankenstein string is ? When I was reading through the constructor, I was really confused at first because those last strings in the calls to this method didn't seem to make a lot of sense. In fact, these strings only make sense in the context of . It seems to me like you were hit by a sudden case of design pattern madness: Valuing the DRY principle above everything else, you reduced those two message strings to the bare minimum, divided every common divisor out. If this were normal code, that would be most likely fine, but we are talking about strings here. Even if this method is private and no user ever would have to deal with this quirky interface, think about what you are actually doing when you are defining any method. You are abstracting away a certain functionality behind a name, and this name now has to convey its meaning where it replaces the code it contains. In your code, however, nothing conveys the fact (which is not at all obvious) that only part of a sentence should be passed to . In general, splitting up what logically belongs to a single part of a string (such as a sentence, a phrase, a name, etc. depending on context) is almost never a good idea. You are certainly decreasing readability, at the gain of a few characters of saved code. Another thing I am not a big fan of is using numerical indices instead of iterators. Doing so gains you very little, but decreases the semantic integrity of your code. After all, is not a very useful name. All it says is "this here is an unsigned number", while expresses "this here is a position in a ". Iterators do have some drawbacks, such as the possibility of invalidation if the underlying container is moved, but those do not apply here, since everything you do that could be written using iterators is a single logical action. This would also get rid of the (arguably) ugly , and the ugly method of (to be replaced by ). One last point: is quite heavy implementation wise. While it is, in general, not a design problem at all to use it (and I would go further and say that it is even a good practice), it can have pretty heavy stack and performance drawbacks. If you don't mind those, you can go on using it. If you do, you should make the type of a template parameter, or go with the C way of passing a simple function pointer (which is arguably much worse style-wise, but better for code size). Ignoring Values 

Do not use , especially not in a header. It can introduce subtle bugs. You class has no destructor and is leaking memory. Everything that is allocated through has to be d again (or, in the case of arrays, d). makes no sense because your array is not two dimensional (and I doubt that a two dimensional array would perform better than a one dimensional, but you are free to prove me wrong). If this is meant as a hint for you to improve the implementation later on, you should probably mark it as such (e.g. using the well known comment). Comments like are superfluous when followed by lines such as , because the variable name makes its purpose sufficiently clear. Generally, using comments is good, but they can also be overused (or written badly); using them effectively is key (and also not easy). You should generally avoid using , at least when the code is supposed to be portable. In this case is not portable at all (it is VS only) and generally also hints at bad code separation. If you think your file is unreadable without it, you should split it up into multiple. 

As to question 1: Yes, what you are doing is unsafe. Yes, there are better alternatives. Why is allocating memory manually unsafe? The most simple reason is: You might forget to free it (in which case you cause a memory leak), or accidentally free it twice (in which case you cause undefined behavior), or use a pointer to manually allocated memory after free (also causing undefined behavior). Let's see whether any of these points apply to your code. 

file that corresponds to the current file headers from other parts of the same project/library header file from external libraries standard library headers 

is highly suboptimal. First of all, it actually contains a bug: is of type , but returns an , because may not fit into a . Depending on whether is signed or unsigned on your system, you might get an infinite loop or an early termination. Fixing this is easy: Just change the type of to . Secondly, is of type , but since it is an index variable which can never go below zero, you should use an unsigned type at least. Also, if your file is very long, you might run into problems because of overflow. To counter these issues, C offers just the right type: . You should use it every time you deal with the size of an array, a struct etc. (just as the name suggests). From a performance point of view, this function is terrible. You start off allocating a single byte for , and then call for every single character read (also, the reason why you allocate bytes instead of eludes me). As you hopefully know, calls to are not cheap, and calls to even less so (especially if has to copy data). Now you say: "Sure enough, but how do I do this efficiently if I do not know the file size?" Worry not, for the c standard library has just the right tools for you! They are called fseek and ftell. Most commonly, they are used as following: 

Now that we have a way to find the most significant set bit, let's move on to step Shifting the number right so that the most significant set bit is in the 12th position. This is trivial to do. In code: 

Now, let's talk about in particular. One issue I have with this function is that should never, ever be a string. You're wasting performance and causing binary bloat, when the fix would be to simply add an with three members , and . The other big issue is that this function limits its own usability by necessarily writing to . This has the potential to cause people using that function and wanting to separate outputs much grief, and is easily circumvented by having the function take a as parameter and writing to it instead. When invoking the function, you then simply pass as an argument. Finally, this function does a little bit too much; two completely separate tasks, to be precise. One is taking a number in a given format and converting it to decimal, and the other is actually printing that number in a nicely formatted way. You should thus split it up into two functions: One which does the extraction, and one which does the output. 

are confusing because of the wrong indent. Leave some horizontal space. Generally, it is a good idea to leave a space around binary operators (which you already do most of the time, but not always). Also, Most people prefer to have a space between a control structure keyword and its condition block and between a closing parens and a following opening curly brace as well (e.g. instead of ). In , why do you have a variable that you only ever write to? You could just write and be done. 

Taking a closer Look You did not ask for this kind of review, so if you're not interested, feel free to simply ignore this part of the answer. While your overall code makes a pretty good impression on me, there are some things that don't look and feel right and, to my mind, deserve another thought or two: 

This method is completely redundant because c offers the method isalnum which does exactly the same. 

As to question 2: No, your queue is not threadsafe. The problem is that you are handing out pointers to the same data to different threads without synchronizing any accesses to these pointers, which constitutes a race condition, which is undefined behavior. Citing from the most recent working draft of the C++ standard before the release of C++14: 

from . This is a horrible wall of text, and it is not even barely readable. What if you ever have to go back and change something in that -block? Are you willing to spend most of your time and energy to parse that wall of text if you could spend it instead of getting on with your work? Why not opt for something more like 

First off all: Please fix your spelling. The functionality you are trying to implement seems to be about items, so your classes should be called and , respectively. Also, there is at least one place in your code where you misspelled "quantity" as "quntity". should be . I know that it's hard for a non-native speaker to get such things right (I'm not a native speaker myself, so I understand your struggle). However, to make your code clean and easy to read, it is important to keep a certain level of cleanliness throughout naming and comment writing. Speaking about name cleanliness, keep your capitalization consistent. Why does start with a lowercase i while starts with an uppercase? Decide on one naming scheme and stick with it. The same applies to your method names. Instead of defining a default constructor for that does nothing special, assign default member initializers and that constructor (just as you did in your other class). You do not need to define a copy and move constructor in . The compiler is nice enough to generate them for you automatically in most cases. You only need to define them yourself if your class does some fancy resource managing, or something alike. The same is true for the destructor. Don't take as a const reference. Take it by value instead. I don't know of a single architecture out there where and could not be passed efficiently in a register (or on the stack). You do not need to forward declare . Instead, you can just turn into . Actually, this is a case of -declaration abuse. Instead of making a friend of , should define an actual public interface (i.e. getters and setters). As of now, the whole class is somewhat useless. Don't use unless you know exactly what you are doing. In most cases, the compiler is going to ignore it anyway. Don't define as a member of ; it violates the single responsibility principle. Reading and parsing data is not part of the responsibility of . manages it's content using a... ?! Hopefully, you realize that this is a blatant mismatch between name and functionality: When I see a class that has "list" as part of its name, I expect it to use some kind of list to store its content. That being said, does not seem like a very good fit here. Indeed, a list would suggest itself very nicely if you want to keep the O(1) deletion and insertion property. Also, the identifier is already part of the s; it is redundant to add it as a key to a map. If you want to keep the map, you should extract the key from the class. Again, methods such as violate the single responsibility principle and must be extracted from your class. The responsibility of is managing a list of items; reading in and creating items is the responsibility of a different piece of code. Furthermore, don't output debug messages from your class directly. This, again, violates the SRP. Keep spacing around operators consistent, especially around and . In general, it is considered good practice to leave a space before and after all operators. As with , severely lacks a public interface. Please add getter and setter methods in exchange for all those IO-methods. Don't keep around as a member. Make it local to instead and return it.