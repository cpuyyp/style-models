I somewhat support using an MVC structure even for a simple mobile game. If nothing else, it helps with an issue that plagues developers who haven't gotten bitten by it enough times: separating the display code from the game logic. I'll also say, though, to keep in mind that MVC, like all design patterns, exists to make your life easier. That means that if, at any given time, staying within some set of rules about what you should and shouldn't do when using MVC is making your life harder, ignore it. One of two things will happen: 1) you'll get bitten later, and then will understand why doing it differently in the first place would actually have made your life easier in the long run, or 2) no consequences whatsoever. Computer programming, by its nature, gets a lot of rule-followers who value adherence to elegant principle over actually accomplishing anything, and they love to propound their value system; don't let them make you one of them. The most important thing that can happen to your game is shipping it. 

These data structures don't completely encapsulate the situation -- you need the uniqueness constraints, and some of the categories need meta-rules, like needs handling of the "to the right of", "to the left of", and "next to" concepts, for example -- but the structure of the problem seems to strongly suggest them. Dunno if this will take you very far, but I hope it helps. 

The minimum effort solution is to pick a maximum size (X and Y extent) that you want the dungeon to reach, put your starting point in the center of that, and don't allow growth outside of it. No need to do any shifting. Depends on a fixed extent being acceptable, of course. 

Since you say a "small" text RPG, my advice would be to just preload everything. If we're not talking about an enormous amount of content, then it shouldn't make a great difference to startup time, and it keeps things, as Bjorn advises, simple. One thing that occurs to me, reading your question, is that you may want to consider the difference between a weapon and a weapon type. My preference is always to have a clear distinction between the two, and to have both modeled in code so that I can ask questions about the weapon type without necessarily having to have an instance on hand. (One way of doing this is to have the weapon type be the class, with class methods that allow you to interact with it, and the weapon be an instance of that class. I actually do not prefer this approach because then it's either impossible or incredibly messy for a weapon to change type. Obviously that won't be relevant to all games.) 

A lot of early 3D games had the problem where you'd be trundling merrily along and suddenly everything was black, with an island of what looked like the hollow facade shell of the scene you'd been walking through rising into the distance above. Because you'd fallen out of the world. I remember this being a particular and long-standing problem for Bethesda Softworks, though they certainly weren't alone. It's been a while since I've seen it in the wild, so it seems we've gotten past it. My question is two-part: 1) What was the cause, or causes, of this? (My guess is that it's to do with floating-point-precision related seams between polygons, interacting with point-modeled character position, i.e. floor chunk A ends at position 1.0, floor chunk B starts at position 0.9998 and for a microsecond your position is 0.99992, and boom, you fall through the world. But that's just a guess.) 2) How did it get fixed? 

To my way of thinking, the main pitfall of a small core stat list is when disparate capabilities wind up tied together in a counter-dramatic way. Maybe the most recurrent example is when perception winds up being a function of intelligence, making it impossible, or at least against the grain of the system, to play the extremely-brainy-professor-with-his-head-in-the-clouds type, or to represent animals having highly acute senses! The enormous mass of things that get lumped together under a Body stat can be pretty questionable, too, and don't get me started on Wisdom. Your deviation-from-baseline traits can address this concern in a lot of cases, which is very helpful. The cases where they can't address it are probably a key indicator of where separate underlying stats are needed. 

I use IDs (for entities, not components), though I could do without them if I didn't want weak referencing for purposes of persistence + lazy loading. Mine do not defeat polymorphism as you describe, though. Try having your IDs provided by a universal registry and accessed via a standard interface. 

Disclaimer: Please note that this answer contains a high quotient of bitterness and cynicism, and that its contents reflect a worst-case scenario that the gaming industry is unfortunately notorious for. There are many ethical and benignly-motivated people performing hiring and management in the industry, and being asked any of these questions does not automatically mean that the "translations" apply. 

There's lot of good general advice in this thread, but in specific advice, for some solid base material in helping name weapons in a futuristic game, you can do a lot worse than to go buy a copy of GURPS Ultra-Tech and read it cover to cover. Because it's intended as a genre sourcebook, much of what it contains is workups of well-established science fiction tropes that you need not concern yourself overmuch with stealing, as opposed to concepts specific to the GURPS system or any particular setting. (An exception would be "electrolasers", which are a very-particular-to-GURPS way to avoid saying "phaser".) 

Lives are a way of tuning the feedback loop that players engage with the game through (reward/punishment for actions taken toward goals). A crucial part of gameplay is learning; a game design where punishments of lesser degree than termination of the game are available gives more opportunities for players to learn which behaviors earn rewards and which earn punishments, and so promotes engagement. Of course there are many ways to accomplish that, but since "death" is a common metaphor for game termination, a natural modification of that metaphor becomes "multiple lives". 

This is exactly the sort of thing A* is for. All you need to do is assign the vertices between the nodes costs based on the terrain types. (It looks like your examples uses a graph where all vertices have a cost of 1.) 

Beyond the collection-management issue you identified, it's because your first function exits, returning a sprite, as soon as one colliding sprite is found, so no further sprites are examined on that iteration. The version that performs the removal internally checks collision on all the sprites. 

I am not a lawyer, and this is not legal advice. In the US, parody is a class of "fair use" of copyrighted material. The primary litmus test used appears to be whether the derivative work offers significant commentary on the original work. If the derivative work simply emulates the original, parody as a defense to an infringement claim is hollow. An example of a parodic commercial game derived from another commercial game was 1996's Pyst, a parody of Myst. It was basically a tour of Myst Island as interpreted after everyone who bought a copy of Myst had tromped through it. It didn't have significantly similar gameplay to Myst, and obviously presented a significantly transformed version of its setting. It was also subtitled A PARODY at every possible opportunity, which came across as a slightly desperate "please don't sue us". Intellectual property law outside the US should not be assumed to grant any protected status to parody. 

If you're using MySQL as your persistence layer, I don't see any reason why you wouldn't keep your combat logs there. The amount of sense that your listed options make goes about like this: 

You'll probably get farther with Google with a bit of terminology: the usual jargon for a recalculation of an A* path is a "replan". In more specific direction, the situation you raise is the primary stated motivation of HPA*; it's a fairly well proven-out algorithm at this point and is likely to provide solid guidance. 

Basically, the question is, why are your enemies getting disorganized and jumbled? You only describe one factor controlling their movement, so unless there's more relevant information you're not telling us, the only scenario I can think of where they'd lose alignment is one where you're flipping the vector right there in the middle of the movement code as soon as one of them hits the edge. This would cause loss of alignment because you're partway through processing your movement when you change vectors, so some of them have moved with the old vector and some will now move with the new vector. If that's the case, try this instead: when an enemy hits the edge, turn on a flag, and at the end of your movement cycle, check if the flag is on; if it is, flip the vector and turn off the flag. 

Part of the way I've approached this in the past is, rather than having completely separate representations for players and NPCs while requiring that they both implement a common interface, driving toward convergence of representation between them to the greatest extent that I can, as by subclassing them from a common model into which I push as much about them as makes any sense to generalize. This helps avoid issues with running NPC operations on players and such by making operations more generally applicable, since there's less natural tendency for the representations to diverge than if they're completely independent implementations. Basic leveraging of polymorphism helps handle the cases that have to diverge (for instance, if you made your responsible for handling what happens when somebody dies, you would have to do typechecking to make sure you used the right logic; so don't, have players and NPCs implement separate, appropriate methods). I agree that your is part of data. However, building on what I was saying, I would actually tend toward removing or limiting the role of your in favor of having the combat logic draw values directly from the , perhaps with only storing expensive, single-combat-specific calculated values. Your test mockups would then be oriented more toward providing fake models than toward populating . (Having duplicate a lot of information from the bothers me in much the same way that a denormalized database does. However, if you believe in the Law of Demeter, which I passionately do not, you won't want to do things the way I'm suggesting. Of course, if you believe in the Law of Demeter, I'm not sure your should even provide access to the .) 

That populates with status arrays that map resource index numbers to booleans indicating whether or not the available quantity of that resource is sufficient. 

If you wanted them to act really smart, usually in RPGs the best thing for the monsters to do is all attack the PC with the highest ratio of offensive capability to hit points. You don't see this actually done a lot, though, since it tends not to be rewarding for the player. :) One place I might recommend starting is to come up with some general categorization scheme for your PCs -- bucket them as melee, casters, healers, and stealth, or as offensive, defensive, support, or what-have-you -- and have each type of monster display a preference for the category of PC it will attack. Maybe some almost always go for that category, while some have a mild preference. This provides something useful the player can learn about the monster types and gives more interesting behavior than pure randomness. You may also want to make monsters "sticky" in their target preference to some degree, i.e. make them tend to continue attacking whoever they last attacked. 

Your case is pretty much what HPA* was invented to address. If it seems like overkill, though, I would tend to think that pathfinding every half second or so should work out pretty well. 

I'm considering creating a position in an online RPG where the responsibilities would mainly involve conceiving roleplaying-oriented events and plotlines and executing on them using developer tools such as the ability to create instances of NPCs/items and the ability to control NPCs. Examples of events/plotlines might be "ancient god of evil breaks loose from his prison and attacks the realm" or "upcoming marriage between offspring of powerful dynasties has political opponents trying to disrupt it". What is the best job title for this sort of position? The first thing that popped into my head was "customer experience associate", but this appears to have an established meaning in retail where it's a way of dressing up "salesperson". "Game master" positions in MMOs are generally helpdesk positions with no creative duties or authority. I want to select something that neither exaggerates nor undersells this person's level of responsibility. 

I would implement a hook system (a mechanism by which callbacks to specifiable functions can be added to and removed from an object when events occur) on the container, and have components set up the appropriate hooks when added and tear them down when removed. For instance, the AttributeBonusComponent might use and hooks to add and remove its bonus, the AttackComponent could provide values to and hooks, and the UsableComponent could talk to . So the container winds up only having an abstract understanding of the kinds of information that can be requested of it and ways it can be interacted with, and the components are responsible for defining how they interface with those. 

Your question is extremely cryptic (we can only vaguely guess, for example, that in some way refers to the building type you're trying to create, and some of your sentences are unintelligible), but I suspect you mean something like: 

Because this server will be handling relatively little traffic and only has to be talked to to set up a game, it probably wouldn't be terrible to make it an HTTP-based service. I would tend to advise rolling your own application-level protocol over TCP anyway, though, if only because it's of fairly major concern here whether a client is still there and waiting for a game, and HTTP complicates that considerably with its pesky statelessness. As far as examples go, here, have some pretty good, well-commented example code for a general network service daemon in Python that you can start building from. 

but the basic curve should be pretty close to what you want. For cooldown, decrement at some rate (I suggest trying 1 per 300 ms and tweaking from there) and recalculate as above. 

I would like to introduce you to this neat concept we call a content management system. Also, listen to Kylotan. 

Let's say I have a large number of conceptual objects of some kind, each of which occupies a pre-known set of points in a Cartesian 3-space. 1) What is the best combination of data structure (for modeling these objects, their occupied points, and/or the enclosing space) and algorithm for the purpose of being able to retrieve only the point within each object that lies closest to an arbitrarily selected point, with speed the first concern and memory footprint secondary (but still important)? 2) Let's say that that a point may be visually occluded with respect to another point, according to a black-box true/false rule, and I now want to retrieve the closest visible point of each object. Asking the same question as in #1, is the answer the same or is something else now advisable? 3) Let's say that the pre-known set of points for each conceptual object may potentially change somewhat frequently, enough so for computational expense in data structure management to be a concern. Are the answers to #1 and #2 still good, or are they expensive enough in setup/teardown to be likely to cause problems under this condition? (I really do want to know the answers to these items separately, if they have distinct answers. Mega bonus points for any answers that generalize well to a Cartesian 4-space.) 

I don't think TDD, as such, is appropriate as a foundation for game development. Automated unit testing as part of methodology, sure, but too many of the key concerns of game development are subjective and not machine-testable for testing to be the driver of development. How are you going to write a scripted test for whether a game mechanic is fun? That a level is visually appealing? Even that a level takes a typical player around 15 minutes to complete? TDD fits situations where the maturity of a project can be quantitatively measured in terms of its compliance to a specification, and that just isn't game development.