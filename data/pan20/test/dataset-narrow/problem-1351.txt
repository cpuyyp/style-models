I meant having each agent have to do the same rounding that you do for your mouse clicks which is very value centric, and you end up having to do a lot of the same clean up work of hard coded values, and you get the same end run checks as when doing . but if you do just find the nodes nearest to here (its up to you if you want diagonals), and if you really wanted to you could use the same logic for mouse clicks instead of rounding values just ray-cast to find the nearest node. 

depending on your target (platform/engine/framework) there are full communities of people, and many times there will be a section in these community forums whose sole purpose is "help wanted" (where people either post their skill set requesting a job, or post a job requesting applicants) for Example 

No. from an application standpoint think of an empty gameObject as a modifier that is modifying something, or nothing. I can create an empty gameObject, and then move it around the world/scene, and then I can rotate it, and scale it, but if it doesn't have any children nothing happens, but the changes are recorded. then if I take, and create a sphere, and make it a child of that empty gameObject then that child will take on those modifications, and have its own values stored with respect to its parent, but in essence of physical logic that empty gameObject is nothing (no size, shape, or anything), but it does have a transform, and can receive components. 

The problem with exceptions is you have to deal with them anyway. If you getting an exception because your out of memory then it might be possible that you will be unable to handle that error anyway. Might as well just dump the entire game in 1 giant exception handler that pops up an error box. For game development I prefer to try and find ways to make my code graciously continue with failures when possible. For example I will hard code a special ERROR mesh into my game. It's a rotating red circle with a white X on it and a white border. Depending on the game an invisible one might be better. It has one singleton instance initialized on start. Since it's baked into the code rather than using any external files it shouldn't be possible to fail. In the event a normal loadMesh call fails instead of throwing back some error and crashing to desktop it will silently log the failure to the console/logfile and return the hardcoded error mesh. I found out that Skyrim actually does the same thing when a mod screwed things up. There's a good possibility that the player wont even see the error mesh (unless there's some major problem and many of them are like it). There's a fallback shader too. One that does basic vertex matrix operations but if there no uniform matrix for some reason it should still do the orthogonal view. It has no proper shading/lighting/materials (although it does have a color_overide flag so I can use it with my error mesh). The only possible issue is if the error mesh version might permanently break the game in some way. For example ensure that it doesn't apply physics since if the player loads an area, then the error mesh kicks in it might fall to the floor then if they reload the game this time with the correct mesh working, if it's bigger it might be embedded in the ground. That shouldn't be too hard since your probably going to store your physics meshes with your graphical ones. Scripting might also be a problem. With some stuff you will just have to hard die. Not really sure what use a fall back 'level' would be (although you could make a small room with a sign saying there was a error, just make sure the save is disabled since you don't want the player stuck in it). Instances of fall back objects/components would be more problematic since they need to be unique but you can still have a special position that sets things to (0.0, 0.0, 0.0) or (-1000000.0, -1000000.0, -1000000.0) but once again you have to ensure it wont be saved or anything. In the case of 'new', for game development it might be better to look at using some kind of a factory. It can give you various other advantages like preallocating objects before you actually need them and/or making them in bulk. It also makes it easier to make things like a global index of objects that you can use for memory management, finding things by an id, (although you can do that in constructors too). And of course you can handle allocation errors there too. 

instancing in Unity is based around the prefab system (basically make up your thing then create a prefab, and then use it again, and again in your game/scenes) 

I would appreciate if someone would look over mt deriviation I used $URL$ I would suggest to copy to a text editor that supports side scrolling in my notation I used q^(-1) to mean conjugate, and not inverse, and different identifiers, but I hope that it is follow-able. I think that the majority is right especially where on proving the real portion of the vector would disappear. 

200 cubes (even 200 RigidBodies) is not that much in Unity. on the part about emulating in code depends on what you absolutely need your nodes to know. 

I am trying to design the algorithm for my level generation which is a rule driven system. I have created all the rules for the system. I have taken care to insure that all rooms make sense in a grid type setup. for example: these rooms could make this configuration The logic flow code that I have so far 

I will not downplay the knowledge you would earn in college earning a degree even as a general developer/storyteller/etc.., but it depends on more then just these specific things many even small studios might not be to kind to a person who only wants to write stories for games they typically want someone who can follow the development process from story to gold, but this is more the job of the producer (many companies don't hand this out), but I would suggest maybe picking up some programming experience (game make can be a good jumping off point), or maybe some level design work (UDK can be a good tool for someone just learning) that being said I would say still right up a brief/treatment/script (sometimes when lumped together are called just the GameDoc, or script) for your game idea, and then send it in to companies (remembering to express confidentiality, and ownership of the idea). another possible rout is sites like $URL$ have a place where you can post game ideas, and if you follow through with it then you might be able to get a team together, and get it made, and even sent to retail (at least steam). but the first question that anyone is going to ask is "have you written the documents that define your game" (brief/treatment/script) you should be able to find the information that belongs in these documents, but if asked I could provide an outline (keep in mind it would be like an outline to a book which is unique to each book) 

In OpenGL 4.0 there are uniform subroutines. These allow you to define functions that can be swapped out at runtime with very little overhead. So you can make 1 function for each pass. Also 1 function for each shader type. There's a tutorial here. For older OpenGL versions your best bet is to either have a bunch of different shaders and swap between them. Otherwise you can add together values that you multiply by a uniform that is either 0.0 or 1.0 to turn it on or off. Otherwise conditional if statements can be used but OpenGL will execute all possible outcomes every execution/pass so make sure they aren't too heavy. 

The manpage for gluLookAt might be of use. That is deprecated now days in OpenGL itself, but glm has an implementation. Then you just use that plus basic trigonometry for working out the X/Y coordinates of the camera. 

You might need to bind your vertex attribute id's to your shader, look at glGetAttribLocation. In your 4.0.0 version you have the layout statement telling it what will be in what id's. The program needs to know that "in_Position" is for attribute 0. It's possible that your implementation will default to using the first attribute as vertex coordinates and the 2nd as color. But it might not either. I'm not sure what the standards say about the default states, it might be up to the implementation or vary depending on what version your context is. Here's the code I use to get a log of the shaders/programs. 

I am working on a game that will be a 3D-shooter (camera trailing player), and want to impose some architecture on the game being that a is composed of where each room can hold (the player, enemies, pickups, projectiles), , walls/floor, and (more on these in a little) my first concern/iteration is to get a single room functional, and then link rooms together in a later iteration(this is so that rooms to render are dynamically chosen to accelerate render times on larger level). my direct question for this iteration is what would be an optimal data structure for holding my for the room? keeping in mind that whatever structure I use needs to be searchable, removable(single/group of items), sortable(this can be given up if needed), growable, and possibly be able to take pointers to the . this structure would probably also be used for my doors. my initial thought was to use linked list though removing items from linked lists can be a chore, and if not done right can just create a memory black-hole. I keep bouncing back, and forth on putting walls/floor into the same structure as the as it would be mostly efficient for collision detection (i think), but I know it can cause a graphics nightmare (more things being rendered means longer it takes), so maybe keeping walls separate, and create a separate list of walls to be rendered vs collisions. the next part would be linking the rooms together by doors(see picture bellow where the joint between each room is a ) where my first though was adjacency list. I understand that the has an adjacency list that it uses though I don't feel that it would work in my situation as just rooms , and / don't work within a so would it be worth while to build a custom adjacency list (might need to see an implementation as I keep getting lost on connecting adjacent things that should be connected) 

It isn't really possible to have an 'infinite' space. You need some way to index the positions, so if you used an int then the maximum size would be MAX_INT. You can use bigger index data types. Maybe a long or even something more esoteric like a long long long long. There are some ways to have numbers that can grow arbitrarily but they will add performance/memory overhead. At the end of the day you will still be bound by the memory of the system. Do avoid floats/doubles at they loose precision the further away from 0.0 you go. Look at the Minecraft end of the world videos. So it's probablly better to use a 'fixed' sized world and just make it very very very big. With a fixed sized world you could use a GPS system. You can also make the world 'wrap' around so it's like a sphere. Having said that I wouldn't give the player raw coordinates to have to deal with. You are just making them remember stuff and giving them extra work. Place names seem hard to implement in a procedural system. Seems like they would come out too uniform (ie you would be naming square regions rather then points of interest). It seems like having a 'waypoint' would be the way to go. Combine A map, compass markers, plus a list of waypoints that the player can turn on/off and possibly a 'pillar of light' at the position' so it can be seen on the horizon (that only makes sense for 3D games) and a fined grained marker at the point on the ground. Also let them set their own waypoint. As a simple version would just have a direction (an angle, or arrow that points there) and distance to target. The problem with that is the player sometimes has to go around the long way to avoid obstacles rather than straight in the direction. You can also use the waypoint system for 'points of interest' within a range like Skyrim does for dungeons. 

if you can mask your entire game level/scene in a fixed grid you should in theory be able to use standard grid traversal, but all of your book keeping will probably need to be specificly value centric, and in the end run this is not going to be very clean/efficient. 

Why would you do this? I see no value besides having something that you can physically see in the editor, and when it comes time to run the game you wont be doing anything with these cudes as cubes, so why have them in the first place if your just going to take away their collision, and rendering. All you have left is a transform which you could have right away by having empty gameObjects. the easiest way to do nodes in Unity is to create empty gameObjects(mainly for the position), and then give them a script for all the variables you need, and then put all those nodes onto their own layer. EDIT (In response to request for more detail in comment): 

this is actually the meat of your question (I know you didn't say gambling, but in essence you are "put down amountX for the chance to win amountY" is gambling) this falls back in a circular fashion to the previous section where if the currency is easy to obtain then players will be more likely to wager more. though at the same time players will also see it like they would putting money down on a game of High card draw or Black-Jack. The higher the anti the higher the likely-hood of better players, and the statement "to rich for my blood" comes to mind. for this reason I would advocate for a tiered wager system(tier1 costs x, tier2 cost Y, tier3 costs z... || x < y < z < ...) this will allow for your in game economy to feel more open, and also give players a sense that "if I go to a low wager match then I will see weaker opponents, and a high tier match will have strong opponents" this also gives the player the chance to try the system out by possibly entering at the lowest tier to get a feel for how the system works. then the "better" players will gravitate toward the higher tiers, though your more casual players will gravitate toward your lower tiers, and the middle tiers will only ever be used for the high tier player to recoup losses, and get back into the high tiers, or the low tier players to seek a challenge, and improve their skills. In conclusion: you can't really set hard and fast numbers for what is to much, and what is just right its the same as balancing how much damage a weapon does with respect to how much damage a shield can take, or how many points eliminating a given enemy type is worth. Though when you throw in perception it does make things interesting (low to one person can be high to another). It will come down to how easy the player perceives earning currency in your system is. if they see that after every "story event" they earn 1,000,000 currency, but for most other "events" they earn 20 currency then you can put higher prices on things, but if there are only say 10 of those "story events" in the game, and the player hasn't seen one in a while they might tighten up the purse strings a little. In short the key word is balancing. aside: If your going to have a wager system on a section of the game have a defined rule set that you state up front (winning/losing, scoring, and objectives) even separately (or mandatory the first time they enter the section, but still reachable later) otherwise a new player might feel cheated if they lose the first time, and if it is at the beginning of each match an experienced player might get bored having to sit through it every time. 

Is there any way that I can control in which order elements are drawn with instancing? Do all elements get drawn in the same order they are added to the instance buffer? Edit: What about the Z coordinate! Since I am drawing my GUI through this, I should be able to just put elements in front of others, right? I am not at home to try this out yet. I will keep the thread updated. 

How can I make a black shadow/glow around my drawn rectangle made of primitives? Drop-shadowing is easy, but it's not exactly what I am looking for. 

What is wrong with my vertex declaration below? I am using it with instancing. After adding TextureInformation to it, it renders weird and has an epileptical seizure. 

I'm making a tower-defense game for Windows (not phone) in XNA. I've seen this video of another tower-defense game for Windows Phone that uses particle effects, which I really like. They change color, glow and density as they move away from the explosion. Really cool stuff! $URL$ I would like a similar result (particle-wise) to the stuff in the video, however, I don't know where to start. I suppose I need to do linelist hardware instancing to achieve the result, and then update every particle position on the CPU. Or is there a better alternative? Post your suggestions. That'd be great, thanks. Edit It's the explosion particle effect that I want to implement. Not the particle effects that the projectiles leave when they fire. 

Giant imposing list aside, just about all of that is all insanely fun to learn, you programming will likely improve heaps as a result and much of it is useful in other areas or programming. Obviously a lot of that can be cut down depending on what you are trying to accomplish. You will probably want to split up all that stuff into small projects. Much of it might not be 3D at all (like the networking and data structures). And lots of it isn't specific to 3D games either (networking, scripting , etc...). One big problem with learning 3D is you need to make it interactive a lot more in order to understand it and have anything useful. Having a scripting engine for example can be great since you can just spawn in stuff at runtime, it break you out of just having a 3D rotating mesh on the screen and actually having something that looks like a game. Once you have the script engine maybe you can just store your levels as scripts rather than trying to invent your own data structures. Dumping in a physics engine will give you collision detection which is much harder in 3D than in 2D as well as all the cool physics interactions you will get. Choose a more inefficient scripting langauge that will let you introspect object properties. Perhaps you could start off learning the api by porting your 2D game to it as a bunch of 2d squares. Then maybe you can look at trying to 3Difiy parts of it. Use a 3d mesh for the main character, then other ones, then 3Dify the tiles and background. Even that is kind of heavy since you need to learn things like animation and probably shading. Another idea is a massive cutback on stuff. Some is obvious extras like multithreading. But maybe you shouldn't bother with any kind of lighting, shadows or texturing. Choose an art style that works with everything being flat like a cartoon (although actual cell/toon shaders also require learning different lighting algorithms). It would also save on making a whole bunch of textures and your models could probably have lower polygons counts. Or wireframe (although that might actually be more work since OpenGL core profile doesn't support actual wire-frame rendering any more, you either have to draw a bunch of lines which means either several redraws of your meshes or having different line based geometry layouts rather than the traditional triangle ones for your meshes or use a special wireframe shader. On the flip side using a premade game engine allows you to skip much of the stuff in that list and you can concentrate on making an actual game and it's content. Just place an object as X,Y,Z and let the engine figure it all out. Of course you will be restricted by what you can do to what the engine supports or what you can make it support.