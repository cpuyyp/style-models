the good news is that as RAND_MAX grows larger, the bias approaches (but never reaches) zero as 1/x (which is also true when using the modulo approach but exaggerated by the bad entropy in the lower bits). For example for RAND_MAX=3000 you will have 1001 trials that result in rnd=0 and 1000 trials each that result in rnd=1 or rnd=2. Depending on your requirements, this may or may not be enough. Use all the bits - Integer only w/ re-rolls So we want to use the whole range and use integers only, if we split the range of random numbers from rand() into equally large "chunks" and depending on which chunk we "land in" we determine the outcome. In the general case there will be some slack at the end of the range as the chunk size doesn't evenly divide the range, if we roll a value in the slack we just roll again: 

Your principal algorithm is a correctly implemented BSP, so yes. You are creating a Binary Space Partitioning tree. Also, FWIW: You only need two points on opposing corners to define an axis aligned rectangle which you seem to be using here. So you could simplify. Edit: Just noticed your question about connectivity: Just checking the immediate parent will give you a subset of the possible connection information. Since your BSP is axis aligned and 2 dimensional each node can have 1 to 4 neighboring nodes (depending on if it's positioned along the edges or not) or 0 for the root but lets ignore the root because it's not interesting. If you're interested in the full connectivity you can either traverse the tree top down and keep track of all edges and in that way find which rooms are neighboring. Or you can keep track of north,west,east,south neighbor of a node during tree generation and use this information to determine connectivity. If you only look at the immediate parent, you only get one connecting node (out of possibly 4). I do not know how you intend to use this connectivity information so this may be enough for you. 

This method while better than the modulo in the aspect that it has higher entropy as it uses the high bits of the rand() call still suffers some bias problems. Consider again if RAND_MAX=3, min=0 and max=2; 

Style I understand that this is a quick and dirty piece of code to earn some points on some code-challenge website. I will still offer some comments on style. 

Note that the width of the grid at level is (example: 1, 2, 4, 8). Here is an optimized integer power function. If proves to be a bottle neck, you can use a LUT for the powers of 8 and 2. Benefits 

If the constructor was called with a temporary like so where and are arguments, then arg would deduce to . Which is an r-value reference, you are then storing the pointer to this temporary into which refers to... you guessed it something that might be dangling as soon as the constructor returns. The other constructor: 

First you check if you're inside the node, then you repeat the same check for each of the children, this is a lot of branching. Unnecessary branching. Assume for a second that the root contains the point (check this only once for each point) then one of the children must contain the point. The distinction is instead of asking: 

If you are going to roll your own math you need to provide all the operators for vectors. When implementing operators there are certain tricks that you can use to reduce code. For example you can implement all the relational operators (not that you would for a vector, just showing a concept) like this: 

The code works as is and I have achieved my sought for syntax for iterating over specific types of items on the loadout. However there are a few things nagging me, most prominently the unchecked cast in . I would like help with: 

Once you realise the above you can use the Barton-Nackman trick for making all these operators easy to implement in many classes. Using raw pointers is bad Using raw pointers is considered bad practice in modern C++. For some interesting reading check this question. By using smart pointers (such as since C++11) your code would simplify as you would no longer have to care about calling at various points so cleanup would be easier and would simplify too. Use The standard library is implemented using a tree (typically a Red-Black tree. As such it has logarithmic insertion, lookup and removal. But whats worse than the logarithmic time complexity is that it is a tree and traversing a tree is prone to cache misses which will severely impact your performance. On the other hand has (amortised) constant time lookup, insertion and removal which is faster and because it has to be implemented using a Hash Table the elements will be in a more or less contiguous memory region making your CPU cache perform better. Use enhanced loops Replace this kind of code: 

Which method to choose depends on how long the expressions , and are and which one you find more readable. Your code Use with caution! I might have missed something as my PHP is rusty. 

First use which is \$2^{31} -1\$ to mask out the sign bit and then just take modulo. Handles negative values without a branch and is as fast as it gets without assuming the hash table is a power of two size (in which case simply use ). 

@Incomputable already said most of what I was going to say. So this is not as much an answer as it is curious fact. Seeing your problem formulation, I remembered one thing from my CS classes, many years ago: 

just in case the JVM is unable to deduce that those stack variables shouldn't be initialized unless you actually get there. 

Naming Looking at I would prefer the name as it's more descriptive. Design I would much prefer a design where the class doesn't expose its internal data structure but rather has member functions to manipulate and traverse the tree. This is a big rewrite so I will not do it here. In any way, objects in C++ should be constructed as close as possible to their final state, as such your method should actually be a constructor to . The syntax for adding children is a bit weird, why should I have to know where to place it? It's a binary tree, I would use a class for a binary tree to avoid having to do all this logic. You should simply have a method instead of the etc. at the top. It's common to have the section of your class at the top because this is what your client will likely be interested in, instead of forcing them to scroll through the implementation details. More memory leaks You need to have a destructor on to remove the root node when you're done. Use Also in C++ we have a dedicated boolean data type , prefer to use this over returning in an int. So the signature for your class should be something like this: