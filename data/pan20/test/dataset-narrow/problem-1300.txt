I don't know how the landscape in worms was implemented exactly, but I'm pretty sure they used a bitmap for the landscape (at least in the older games of the series). A very basic approach would be a bitmap image (B/W) where black pixels represent air and white pixels represent ground. Destruction of the landscape can be done easily using pixel operations. So if a rocket hits the ground, paint a black circle with at the point of impact. You can then render your world (or just a portion of it) using that bitmap. For better performance I suggest you implement it in a way, that you can update/render just a portion of the "world". Eg. if some parts of the landscape are destroyed by a rocket, just re-render the affected areas, not the whole world. Instead of a B/W image as your "collision-map", you could also use a 24bit image where you use two channels to store the surface-normal (x,y) per pixel and one channel to store the actual "collision-map". Having the surface-normal at hand will greatly help you to calculate bouncing grenades, or to determine if a character can move in a given direction. 

This architecture doesn't need or lengthy statements. It's also really easy to change the flow of the states or add in new states. Imagine you wanted to start the after the ? Change one line to: . Then in the you could branch into whatever you want, depending on which buttons have been pressed etc. 

A*, BFS or DFS all search graphs. It doesn't have to be a graph with equidistant nodes as in a 2D Grid. It could also be a graph like in the following image (from Wikipedia): 

What I encountered quite a bit when working with vectors is that I want to normalize a vector, but know about the length it had beforehand. With a bad Vector class implementation, this would look like this: 

While it's certainly possible to implement the animation yourself (see Jon's answer), I'd suggest to use a tweening library for that. There are lots of AS3 tweening libraries available. Personally I used the GreenSock Tweening library a lot. Several AS3 game frameworks (such as Starling or Flashpunk) already have tweening implemented. 

Adobe Illustrator is a professional vector drawing tool. An open-source alternative would be Inkscape. If you'd like to animate the sprites too, there's some basic animation-support in Illustrator. A better tool for vector-animations is Flash though. These professional tools are rather expensive. If you just want to get your feet wet with vector graphics, it's maybe better to learn a free tool like Inkscape. You'll find some Inkscape tutorials over at: inkscapetutorials.wordpress.com 

Here we would iterate endlessly between the state on the left and the state on the right. So to ask an actual question here: What's a reasonable approach to this problem? I guess using compound polygons for complex shapes is a reasonable idea but I really wonder how collisions should be resolved in that case? How do I detect a dead-end as shown in the third image? 

Pixel-art and bitmap-graphics isn't exactly the same. A bitmap (or raster-graphic) doesn't imply anything about the "style" of the image. It's just a bunch of pixels... Exporting from flash (or any vector drawing application) to a bitmap is certainly possible. Pixel-art on the other hand is a graphical style, usually with a limited palette and also often hand-painted (pixel per pixel). Naturally a piece of pixel-art is stored as a bitmap. Creating pixel-art with a vector-drawing application is counter-intuitive really. Pixel-art is made for a specific amount of available pixels. Scaling these graphics will result in blurry a picture, so there's no benefit in having them as vector-graphics. A good vector-graphics artist has quite a different skillset from a good pixel-artist. It's not a simple matter of "export as bitmap". 

But instead of doing that, you better figure out the required prefix of the browser beforehand and then just use the property that is supported by the browser. Here's a short explanation how to figure out vendor prefixes using JS. 

Personally, I would use a linked list. Iterating over a liked list is fast, as well as adding and removing items. Using an Array or Vector would be a good choice if you need direct access to items in the structure (eg. access to an index), but it doesn't sound like you need that. Whenever you remove an item from the linked list, you could add it to a pool of objects which can then be re-cycled to save on memory-allocation. I have used the polygonal-datastructures in several projects and have been very happy with them. Edit: Sorry, I think the answer wasn't very clear in terms of removal strategy: I'd suggest to remove the item from the list, as soon as it's dead and add it directly to the pooling-structure (recycle). Since removing an item from a linked list is very performant, I don't see a problem in doing so. 

To give the effect of a rotating sphere, you would simply move the image (checkerboard) and mask it with a circle (or all the pixels outside the circle radius). 

And finally in your "Level" or "Game-World" you would have something like the following (note that you could also move the initialization of the player-node to the players init method, but it's easier to keep everything "outside" so you could read stuff from a data-file etc.): 

I would suggest something similar to dilation used in image processing. Use your vehicle as a kernel to dilate your obstacles. Eg. your kernel could look like this (this would be a good kernel if your vehicle has it's "origin" at top-left): 

There's a button and virtual joystick implementation for cocos2d called "SneakyInput". Here's a tutorial that might help you use it. 

Having such a story- or progress-file will easily allow you to swap and re-arrange levels and cut-scenes. If your cut-scenes are really simple, you could even get away with something like above, where the entire data of the cut-scene is in the story-file. Otherwise you might just have to reference a file for the cut-scene. Also you're free to add more meta-data. For example you could add an array of resources to load for each level (if that isn't already specified in your level file). So in your game you would load the story-file and then move from one entry to the next... 

You can't confine the system cursor to a region with Flash. What you can do is hide the system mouse-cursor using (only works when the cursor is over your game-area), then use a custom cursor instead. There's also an event called which will fire whenever the mouse leaves the stage area. You can't tell where the mouse will be on screen, but at least you know that it's no longer inside your game-area. Eg. 

This will use a square-root twice which is totally unnecessary. Especially when you use operations like this frequently (eg. several times in an update loop), you're going to start appreciating implementations where the method also returns the length of the vector before normalization: 

I don't know about any 3D physics-engine implemented in JavaScript. But maybe you could have a look at the Quake2 > HTML5 port and look how they did it: $URL$ From what I understood, they used the Google Web Toolkit (GWT) to compile Java-Sources to JavaScript. I think this approach may have some benefits for your project as well, since it's much more likely that you'll find a good 3D physics-engine for Java than for JavaScript. 

which will create 20 colors, nicely distributed. This assumes you're using integer math, so and will create the same hue value. Of course this doesn't scale too well.. if you have 100 color values to create, the hue spacing might not be enough and you'll end up with similar colors again. In that case you could also vary the (brightness) value. I don't know what your background color is like, but HSV makes it also easier to compare colors (just compare the 3 components and don't forget that HUE is circular (0 == 360)). UPDATE: Since I didn't really answer your question but rather provided another approach, here's how an algorithm for an arbitrary background and completely random colored balls could look like (this is a brute-force approach but should work fine for your use-case): 

Usually such sprite sheets come with an additional file with coordinates for the packed frames (some might even be rotated). Extracting frames without these coordinates can really be a cumbersome task. Automating it would also be very hard to do, since a single sprite doesn't necessarily have a contiguous shape. If the coordinates file is missing, I'd probably use the Photoshop Slice tool to mark individual frames and then you can export all slices at once by using "Save for Web & Devices". 

It's very hard to create such a texture by hand, therefore it's usually obtained by baking the high-res mesh to the texture-space of the low-res mesh. Baking texture is a process that's generally useful to get a good starting point for your textures. A common approach is to bake an ambient occlusion map. It will look like this (image Â© vitamin3d): 

I don't think COLLADA makes for a good format to work with. The standard is too open and seems to be implemented differently across different software. So some features might not be readable by other software and vice-versa. Ideally you would have your working-assets in a proprietary format, eg. the one of the 3D modelling/animation package you're using. That way you can leverage the full potential of the 3D package and not care about compatibility and format-specifications. Exporting your final assets to COLLADA is ok though. As long as it covers your needs and you got a decent parser for it, then go for it. I suggest you create one asset for testing and import it with the parser at hand. Then you'll see if everything gets imported correctly. Otherwise you should probably use another format... but that won't be too much of an issue, because you'll only generate the "production asset" at the end of your workflow. 

From my experience this is normal behavior. The measured time can change slightly and if 59.99 FPS are calculated and you output that with just 2 digits, it's going to show 59. Don't worry about fluctuations of one frame. 

Definitely look into flixel. It already covers a lot of your requirements. Also check out Flash Game Dojo. That will help getting you started. Update: For the sake of completeness: Also look at FlashPunk. It is similar to flixel but has some other strenghts/philosophy. Check out the Flash Game Dojo page for a brief comparison. 

If you use an algorithm like Bresenham, where the two lines can be different, depending on their start- and end-position, you then have to either: 

If you don't want your progress bar to be distorted when scaling, you'd need something like a 9-slice sprite (also sometimes referred to as 9-patch). Here's an article that explains the technique (the examples in the article are for Cocos2D, but it should be clear how it works). When you create a GUITexture in Unity, you have 4 properties in the inspector called , , and . This is effectively a 9-slice implementation.. so if your progress-bar image has a border of 3 pixels that should remain intact, set all 4 border-properties to . Then you can just scale the GUITexture to your desired size and the progress-bar should adapt nicely. Unity 4.6 will also provide this in their new GUI system, so do some of the popular GUI Frameworks/Toolkits (2dToolkit, NGUI, etc.). 

Not sure if your question is appropriate for gamedev, probably an edge case. Nevertheless, I suggest you start here: $URL$ (Here's a direct link to the getting started videos: $URL$ There are a lot of good videos there and mostly they already use Blender 2.5 which is quite different from 2.4x (2.5 is a major rewrite and has a completely new GUI). 

To do that, we could dynamically create the required mesh in Unity (using the Mesh class). So let's assume that of our coordinate-system lies at point and our coordinates from to are then we would write something like this in Unity: 

Just find the hill-element that's at the position where you want to place your item and rotate it to match the orientation of the hill-element. You can get the angle of the element by doing something like this (please note that the angle will be in radians): 

Of course you could just use the shadow layer if you don't need the highlights (which is basically the same as the simpler approach mentioned above). 

There are already several Browser based MMOs out there. They usually don't use 3D graphics though. I'm a bit sceptic when it comes to WebGL. The current crop of browsers don't support WebGL in their normal release builds. You'll have to get special builds or mess with config files, which is more complicated to the average user than downloading a plugin. Speaking of plugins: Several people mentioned Unity, but don't forget Flash. An upcoming release of the Flash player (code-name molehill) will have GPU-accelerated 3D. My guess is, that flash will provide hardware accelerated 3D graphics in the browser before WebGL takes off. 

In the method of your monster-class you would initialize your graphics (and assign it to the property). Creating multiple monsters can be done using something like this: 

This is a very specific problem and is very hard to answer without some knowledge about your code. I'm not sure if gamedev is the right place for this kind of question? My guess is that your entities aren't located in the same coordinate space. Is the entity placed in the same level as the entity? If is on , then needs to be on as well. Otherwise you'll have to convert the coordinates of to the coordinate-space of and then perform the hit-test using these coordinates. Edit: Sorry, it has been a long time since I last used . According to this page, the x and y coordinates must always be global coordinates. So you have to make sure the and coordinates are relative to the global coordinate space. You can use localToGlobal to calculate these. 

I like the component architecture, but for a Tetris-clone it might be overkill. Instead I would just move away from the monolithic Game-class to separate classes. Here's an idea how you could separate into several classes and what methods/properties they could have: 

I think you're comparing apples and oranges here. Polymorphism isn't replaced by messaging at all. You would probably want events/messaging to connect loosely coupled components. Eg. to send a message from an entity when a collision occurs, to update the player score or maybe to trigger a sound-effect. So that these individual classes don't know the other classes and just send out and/or handle messages. But your game is most likely going to have an update loop somewhere and since you have that update loop, it can easily be used to update all game entities that need to be updated every frame as well. This doesn't prevent you from using messaging though... If you have some sort of structure where you add/remove game-entities, you can just as well include them in your update loop instead of dispatching an update message to them every frame. So why not call update on your game entities directly while you're using messaging to connect different sub-systems of your game? I also like the Signal/Slot concept (see qt example) for event-like systems. Bottom line: There's no better approach, nor are they exclusive. 

You could probably use flash.net.LocalConnection for this. This would allow you to implement an API where other flash files can connect to and run commands locally. What this means is, that you'll have your game client (running in the browser) which exposes methods through . Somebody that implements an A.I. for your client could either run an Adobe AIR application, or another SWF file in the browser that connects to your and issues commands over it. This could get cumbersome with lots of exposed methods and requires really good documentation, so that somebody can work with your API. Another option would be to expose a RESTful web API, that any client can connect to. So the A.I. could be implemented in any language that can issue an HTTP-request. 

Wow. That's a lot of data. As Ricket said: Try to split the files into smaller chunks. Loading these huge files into memory will cause problems otherwise. As for compression of the data: The easiest way would be to simply enable gzip compression on the server. When using Apache, you would have to enable mod_deflate and configure it, so that it also includes your xml files into compression. That way, all your files will be gzipped before sending to the client and automatically extracted by the client-browser. If you can't modify the server settings (eg. enable gzip compression), then you could also zip your files manually and use ActionScript (AS3 Zip Library) to unzip the data. I used this on 3D data (Collada XML files) and it works a charm. 

That's certainly possible, but you might have do some tests to find the exact forces needed so that it works to your satisfaction. Almost all joints can have a "motor" which you can enable and which applies a force to your joint. So in your case you have to set: 

Not sure if that's the issue, but you have an error in your init method. You should put all your initialization within the block. So remove the first two lines from your init block (as they seem to be redudant anyway):