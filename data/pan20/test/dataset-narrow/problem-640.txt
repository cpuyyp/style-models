For the refactoring, I suggest that you should wrap the logic of the for-loop into a do-while loop. Something like this: 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

Alternative While the recursive approach is elegant and easily understandable, it might be less convenient for very long inputs. I suggest another solution, based on the idea, that if you want all permutations, then each character can either be part, or not be part of a permutation. This gives us 2^N possible permutations, where N is the length of the input. So, you can just generate this number (2^N), and then iterate from 0 to 2^N-1, and calculate the corresponding perm. for each number. So, if the number is represented as binary digits, then 1 means that the character at the corresponding position should be part of the permutation, 0 that it should not. (If you do not need the empty perm., just start the iteration from 1, instead of 0.) With your example, 'AA2', this would work as follows: N=3, so iterate from 0 to 7 (=2^3 - 1). 0 corresponds to the empty set. 1 = 001b, so '2' is part of the permutation. 2 = 010b, so only (the second) 'A' is part of the permutation. 3 = 011b, so the perm. is A2, etc. Remarks: 

As I said above, I'm not saying that this suggested change is necessarily better than the code you have now (in fact it is a bit more over-engineered). It is rather a way of exploring how to further OOP-fy your code. Test Code Let me first say, that I find it a really positive thing that you write your code with testing in mind, and add unit tests to cover (almost) all the cases. That said, some remarks: 

Again, I like delegates as much as the next guy, but only when they're buying me something. The only difference between the different delegates is the string key that you're passing in. I'd create a protected virtual (and generic) method in your abstract base class that takes in the string key. 

The enum here isn't a bad way to go, but it could be better if you introduced some OOP. Create a base class that inherits from . In this base class, you'll set the shared properties (like ) in the ctor. Then, create a new subclass for each of your menu commands. In the end, you should get some code that looks something like this. 

Pass things as parameters, or through the ctor instead. It's called Dependency Injection, you'd do well to study it. Don't go thinking you need some special framework or anything though. Look into "Pure DI" a.k.a. "Poor man's DI". Lastly, I think you missed the model-view-controller pattern by a bit. The controller doesn't seem to do much, while the views's code behinds are doing an awful lot of work. 

Y r vars all 1 ltr? Is that hard to read? You betchya and so is this code. Just glancing at this, I'm completely assaulted by a large number of single letter, very similar, and practically meaningless variable names. Words to the wise: 

You can do the same for and , but you will need to Override the property. You should also do yourself and the devs you work with a favor and study up on the C# Naming Guide. Properties and Methods should be PascalCased, variables should be camelCased. Also be careful with your bracket placement. It's usual to see brackets on the new line at the same indentation level. They're all over the place in your second snippet. 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

In Scala, never use unless some API requires it of you; use instead. If you have to interface with an API that returns , convert the result into an . As long as you do that, you can ignore checks, for they'll always be errors: you got a from some code that shouldn't be producing it, or you forgot to convert some return value to , or else you didn't even know you had to. Use or -- seems better suited, but either will do with the proper conditionals. Also, do not use -- use . Yeah, it looks weird, but / is idiomatic, and faster. There's a function that is used for parameter validation. Either or will do. 

The solutions given are simple but have quadratic complexity. I tried to improve upon it, while keeping it strictly functional. The solution I came up with is huge, though some of that resulted from breaking it up into smaller pieces for readability. While it is much faster, I'm not sure if that's due to an improved complexity, or just better heuristics detecting when no more palindromes are possible. I feel like it could be improved, perhaps with some Scalaz tricks. I see a couple places where I could remove some code by using an Scalaz abstraction, but not enough to be worth. On the other hand, I'm not particularly familiar with Scalaz. So, here it is: 

You're likely to run across 101 different little gotchyas by rolling your own here. For example, you're not escaping any invalid characters in your solution. I would build your implementation on top of the existing UriBuilder class. By using it internally, I'm certain you'll save yourself many headaches down the road. 

Just a couple of notes. The biggest of which is that I think you've misunderstood what does. It creates a default instance of the class. Which allows you to do things like this 

I'm going to go down through the code line by line. I may be harsh at times, but remember, I say these things so that you might become a better programmer. 

Let's also remove the . It's not serving much of a purpose other than to further nest the code. Let's also remove as it's not being used at all. That brings us to here, which is getting somewhere. 

Don't use . Use . It won't matter to you, but the next guy will thank me. You're missing indexes on the items you defined foreign keys for. They're not free, you have to create them yourself. I find it really odd that the can be null. If a part is on the BoM, shouldn't there be at least one of them required as part of the "kit"? I may even consider using a default value of one. 

Personally, I don't see a point to the and functions. It seems they don't do much except save a few keystrokes, but you've already written them and they're not actually hurting anything. I guess they're ok. This statement really needs some braces. 

Work continues on the Rubberduck VBA Editor Add-in. I have a need to call some VBA code from the add-in with . Unfortunately, the part of that refers to the particular Office Application that is hosting the VBA editor. So, if I'm working in Excel, refers to the instance of Excel (Word, Access, etc.). Unfortunately, these do not share a common interface, so I wrapped them up in one of my own so I could use them interchangeably. 

Ok, I'm changing the answer now that I understand what you are doing. The main problem here is -- while Scala people, in general, don't mind special operators, they don't add operators just because they can either. You can replace with the existing just by adding to any one of the terms. Views aren't often used either, and it's important to have a very good understanding of how they work if you are going to use them, and it's not that easy to gain performance with them, since the machinery they use to support non-strictness is quite heavy, and not everything takes advantage of it. For example, will create a new collection before and are applied. Views can gain when you have many mapping/slicing steps, and few elements of it are ever used. Most of the time, iterators will gain you much more performance, at the cost of the mutability problems iterators have. If you want to reduce the number of times you iterate through the list of proportions, there's at least one place where you can simplify: 

And, yes, was a good start, and for new comers to FP it is not obvious to implement something that will stop at the first incorrect size in functional style -- at least on a strict language like Scala. You'd either throw an exception or use recursion. 

As to the objection: in idiomatic Scala, you don't use . If there's some API which might return you a string, then, at that point, you turn it into an , and handle the elsewhere as needed. Handling (or even ) at the method is misplaced. 

One could also keep a , then either use it alone when computing (instead of zipping stuff), or skip that altogether and put that computation on -- incurring the cost of computation O(nlogn) times instead of O(n) times. It would make the code shorter, but whether it would be faster or not is something I'd leave to a benchmark with a real application -- I'm guessing it would depend on actual sizes for . So, let's talk a bit about performance. Before Scala 2.10, if you want performance you should avoid methods added through implicits on critical paths. The code you wrote will probably get inlined by JIT. You can also reduce the number of computations by pre-computing , and if you make that , then you don't need . More specifically, views are not guarantees of speed, particularly if the computations are light, such as here. I'd not use them at all, unless I'm specifically optimizing the code. Doing a fixed size of multiple passes on small data structures is often not a problem. You are not changing the complexity, just losing memory locality. If the data is bigger, you can incur in gc overheads, which are more substantial. If maximum performance is required, just drop immutability and go to mutable arrays. Finally, is faster on than -- and, in this particular case, a would be way faster. Call it , however, since is a general method on traversables, while set's apply is a fundamental operation. If one of them is less than optimized, it will be . This is the most idiomatic beginner's code I have ever seen... do you come from another functional language? 

The single most important thing you can do right now is indent your code so that it can be read. It's nearly incomprehensible as it is. You should also be consistent with where you put the braces. Sometimes you put them at the end of the line, sometimes at the beginning. I believe it's Java convention to place them at the end. 

And now, to define an interface for your view. (Note that I left everything but what you need for the data grid out.) 

I don't know enough about the data or requirements to give any real concrete advice, but nixing that Full Outer Join is the best bet for getting a performance boost. Looking at your query carefully, it doesn't seem that you ever select from so you should be able to replace the Null check on the ID with a clause and get rid of the Full Outer Join altogether. Something like... 

Every implementation of is expected to have a reference to a COM object as a member. Therefore, it should really extend , because all of it's implementers should really be implementing the interface. It's really not good to be letting the release of the COM object up to a finalizer that may never run at all. 

There are probably a couple of other things that could be said, but I'll leave those to another reviewer. 

Sidenote: Replacing was a real PITA. Lastly, Sub and Function names should have Verb-Noun type names. tells the dev using this code absolutely nothing. Perhaps would be a good name. WhiteSpace Again, this is a readability thing. (I do promise to get around to a better way to do this, but first we do need to be able to read the code.) You are indenting your code, which is good. I've seen worse, but it could be better. Indentation should visually tell me at what level we're currently working at. For example, consider this snippet. 

The on can be replaced by using . I'll let you work out for yourself how to do that, now that I called your attention to that method. And, yes, it that method works on as well, though it doesn't appear on Scaladoc for Scala up to 2.9.2 because it is added implicitly. I suggest you use the nightly scaladoc to look things up -- the documentation there is better, though it may show things not available on release versions, and so is the tool itself. 

That is, if used as you did. I'd make it an instead, and initialize it at creation. I'm not sure would help you here, but might. I just don't think it is a particular good fit for BFS, but it might just be ignorance on my part. 

I wanted to know how efficient all that set manipulation really was, so I benchmarked it all. My solution is two order of magnitude faster than the one in the question, and three than the accepted solution for the greplin input. Since the big-Oh is different, this would change depending on characteristics of the input and input size. 

The first two being means this cannot be reused. However, if you turn them into , then will already return a valid iterator. 

The name of the identifiers here suck, and I could have written without trouble. I choose putting them in a because it shows how well it can scale. One could also make and chain them with , for the cases where you want only the first condition. You see this kind of thing used in web frameworks, such as BlueEyes, Lift or Unfiltered, for example. 

This is a fold, not a scan. A scan produces something with the same number of elements, and change the elements. A fold produces something new.