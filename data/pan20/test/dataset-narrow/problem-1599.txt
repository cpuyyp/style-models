Obviously this means a lot of locking/unlocking and other multithreading drawbacks. I believe this multithreaded approach is not very efficient because each additional sensor means spawning an additional thread. The initial idea was that the task of reading sensor values simultaneously was solved long before the development of multithreading in its current form (a simple user space API). In addition, this is somehow solved by the kernel drivers, for which the thread as a concept does not exist. 

Similar code handles GPIO updates, I2C sensors, SPI sensors and so on. Some sensors are fast to respond, some are quite slow. I am trying to implement a code in which each following sensor update would not depend on the delay from a communication with a previous sensor. I could do it like this: 

so now I am wondering if it works at all (and how?). I've also found this topic where value has been listed, which looks almost identical to mine. It confused me even more - a random guy on the internet won't have the same temperature. Previously I was working with DS18B20 sensors and I always had to divide by 1000 (three decimal places) to get the correct value and the values has always been correct. But my current values are confusing. If I move the floating point (4 or 5 decimal places) these values sometimes make sense, but still I feel like I am doing something completely wrong. I am able to write the communication part myself by, as I said, I am almost sure I am missing something completely obvious. I ask you to help me with these issues. Why do I get so high values? How do I correctly parse decimal fraction from the given value? I am unable to unmount these sensors in the near future to test them myself. I am also using a good quality cable and hardware so I doubt there could be interferences or hardware faults. 

I successfully installed: $URL$ on my pi and compiled "red_object_tracking.cpp". Code located here: $URL$ when I executed "./red_object_tracking.c" I see the GUI pop up and I see the first few video frames my webcam captures, however, after 5 seconds it freezes and the frames don't update anymore. The program doesn't crash because when I execute "top" I can see it is using 93% of CPU and like 30% of memory. When I tried building and executing the same program on my mac it worked perfectly (i.e. the frames were updating and when I placed my red pen in front of the camera it correctly boxed only the red parts within a rectangle. Does anyone know why it's not working properly on my pi? I"m running the latest version of Raspbian Wheezy and using Open CV 2.3.1. 

I have a cross compiler that allows me to compile code on Mac OS x 10.7 and produce binaries for the Raspberry Pi. Compiling simple "helloworld.cpp" programs works like this: 

I'm running 2012-08-16-wheezy-raspbian image, expanded to 8gigs. The website I am following is installing an older version of Open CV [2.3.1] on a Debian img. Do you think this is the problem? Is it worth perusing to fix this problem or should I simply revert to a older version of Open CV and use debian instead? 

As you may know, DS18B20 is not the quickest sensor and answers after around 750ms delay but, afaik, 1-wire is a relatively quick bus. I have multiple sensors connected to the board, which means if I iterate over them , I waste around 4-5 seconds just to read the values. Is there a way to read multiple values at once. I can do this via /, but it means that the memory consumption increases with each connected sensor (I believe each thread allocates around 1mb of memory) which seems pointless (and stupid) for such a simple task. I guess I am looking for a way to handle multiple open connections (with the hardware) at once. Some people recommended a with approach, but I am not sure if they make sense as I am not completely understand if the read actually blocks and/or notifies the system if there is any data available. I am not sure if is allowed to link my own post, but the original question, which pointed me to this was $URL$ Edit (clarification): Right now I read sensor values 1-wire sequentially in a loop (simplified pseudocode) 

The first value seems normal to me - it means 65°C, but the other two values ( 2047,812°C and 1236,062°C) do not make any sense. I measure temperature on a steam generator and the temperature could not be higher than ~200°C. The minimal value (65°C) is still incorrect because I measure a water temperature on the input of the generator - it could only be around 20-30. Overall, my values are very confusing (at least for me) and don't look the temperature at all - might be some kind of message that I need to convert to an actual temperature. I've looked to the datasheet but found nothing on this. I've also looked to "w1_therm" source and determined that this kernel module might only support DS18xx, DS28xx sensors - a conclusion based on the following s: 

And perhaps some links to some stuff I can read up on. Or some links to some tutorials. Of course not necessary but if you happen have that that would be nice. also i would like to use it to make more then one database. I will probably only be accessing them one at a time though. 

Here's what it want to do. I'm using my raspberry pi kind-of as another computer. I'm not using it as a server. I'm not accessing it remotely. And I don't care to do either of those as of this time. So I just want to put/make a database on my raspberry pi. and access it and edit it with that same raspberry pie. I'm not using it to host a website I'm not using it as a server of any kind. It's not even hooked up to the Internet all the time. I only hook it up momentarily when I need to download this or that 

I went and I found something called Firebird. Which looked promising. And they do have a version that they call "embedded". Which on their website is said to be used as a desktop database. I thought "that sounds like what I want". so I went ahead and downloaded and transferred it to my raspberry pi. and then I figured out that it is a ".RPM" file. and what I really need is a ".deb". it appears that I can convert it to a " .deb" file probably by using some convoluted method. I don't have any experience with databases. and I don't know how much of a learning curve Firebird would be in light of that. So I was then wondering is there a better option that is designed for raspbian and related versions of Linux that use the ".deb" extension. MySQL looks like it would work fine maybe. I just have to learn how to use it. Except I would then want to probably make a GUI for it. and from my research about that... all I can find on that is stuff talking about making a web-based GUI. which sounds like it then throws me back to using my raspberry pi as a server and accessing the database through the web. Which I don't want to do I want to access it locally through my raspberry pi (for now (not that it can be changed later)). as you might be able to tell I'm not very experienced at all with Linux or with raspberry pie. I know this is really not a technical question. But I would have no idea where else to post this. And I don't have any friends that have more experience with rasberry pi than I do to ask them about this. Certainly somebody else has done something similar to what I want to do, with there raspberry pi. 

I just don't know how to connect both of the above using my cross compiler? Do I need to rebuild Open CV 2.3.1 on my Mac but instead of using the g++ that comes with OS X force cmake to use my cross compiler? Would something like this work: 

According to the verified peripheral $URL$ my Logitech C910 HD camera should work with the "uncvideo" driver. How do I install this driver? Is it a simple as copying it to a particular directory or is there a more elaborate process? And when it says "works with external power" what exactly do they mean by that? Does it mean I can't depend on my raspberry pi to power the web cam? How else am I going to power it then? 

which produces "a.out" that successfully executes on the pi. However, I'm a little unclear how do proceed with my cross-compiler when producing OpenCV binaries for the raspberry pi. Some background information: 

I am trying to install Open CV on Raspbian by following these steps: $URL$ Everything works up until I do a "make". It gets up to 61% and then I get the following error: 

I have successfully installed OpenCV 2.3.1 on Raspbian image and I would like to build/run some of the C/C++ programs located under the ~/OpenCV-2.3.1/samples directory. For example, if I wanted to create an executable for ~/OpenCV-2.3.1/samples/cpp/kmeans.cpp how do I do this? If I do g++ kmeans.cpp I get a whole bunch of compiler errors saying "undefined reference" to OpenCV functions. So obviously I need to pass it in libraries, but I'm not sure how?