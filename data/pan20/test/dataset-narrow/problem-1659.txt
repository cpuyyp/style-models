Wired up that way, there is nothing you can do that will cause any damage except accidentally set one of the inputs as an output, which could cause a potential short. However, you'd actively have to do that, since the default for GPIOs that don't have another purpose is as an input. So make sure you use two of those (17, 22, 27, etc). This guarantee of safety covers the possibility that two of the pins are hardwired together, or even all three of them (which would make it a bit of a joke switch, of course). Again, there are three possible outcomes here that can be summarized in three tables, but two of them are the same with the rows switched, so I'll only type it out once: 

I don't see why not; in fact this is kind of an ideal use case for it. All the prerequisite software is available, and unless you expect hundreds or thousands of users on the LAN it should easily be able to juggle everything. The thing I would look most closely at is MongoDB. I have not used it much, but I seem to recall it can be a little greedy memory wise. It is still hard to imagine whatever you have planned there as being so elaborate that this is a problem though. 

That's IP in a nutshell. Networking protocols exist in layers like onion skin, each layer wrapping the information in the next; the information in the IP layer is what allows one system to get a message to another. The next layer of information is (almost always) TCP or UDP, which govern some things about the how messages are packaged for transmission and includes a port number, which is an address internal to the system, since the system may have various concurrent but unrelated channels of communication going on via the same physical connection. IP plus TCP or UDP details are handled by the OS kernel. The point at which your program receives a message is the point at which the kernel has decided this message is for this system (because of IP address) and for your program in particular (because of port number). However, you do have to have a basic understanding of IP addresses and port numbers because you do have to manually address your messages to someone, at least in establishing a channel of communication. How you do exactly that depends on what language you want to use, etc. The Client-Server Model of Communication The other important thing to understand about networking, besides addresses and port numbers, is the client-server model. A server is a program that waits for messages addressed to it from anyone, anywhere (it does not have to accept them, however). A client is a program that sends a message to a server, and once such a channel of communication is established, can then receive messages from that server. A client cannot receive messages arbitrarily from anyone. It must initiate communication, with a server. However, servers can rely messages between multiple clients. Web browsers are network clients; they communicate directly only with web servers, not other browsers. A server can establish communication with another server, although it does so as a client, using client style mechanisms. This is sometimes called "peer-to-peer" networking since it can involve two copies of exactly the same program on two different systems. What's in a Message? There are protocols that are wrapped within TCP (or UDP) within IP. For example, the WWW uses the HTTP protocol. Unlike the previous layers, these are implemented completely in userspace, meaning your program has to interpret the details. The idea of a "protocol" is to provide a set of rules about how a message is structured and what it means, such as: 

You don't mention your pi distro so I'll assume raspbian or some other debian wheezy variant. There's no dropbox in the raspbian repo -- perhaps because there might actually be no dropbox in the normal debian repos either. You can't use the .deb package from the Dropbox site because it was not compiled for the pi's oddball processor, but you can build it from source. But don't bother: after that, you still need to install the "proprietary deamon" online the first time you run it. That fails with "platform not supported" :( Since the deamon is not open source, the only way around this is for Dropbox to compile a version for the pi. 

The simplest and most effective way to monitor or manipulate a GPIO pin in C is to use the existing kernel sysfs interface,1 which is actually language agnostic since it makes use of file nodes in . Some programmers naively believe this is a clunky choice because it is file node based, but note that these are not files on disk, they are communication lines with the kernel, and and , etc. are system calls. This means it is equivalent to the direct memory addressing via method used by wiringPi and recommended in the links from joan's answer, except it is much less esoteric and obviously more portable (if that matters). The kernel docs explain this pretty well; note the point about using in the discussion of the and nodes. 

I tried this here and they ended up in . It's more than a hundred types. I don't know whether you will have to reopen anything (the file manager, the LXDE session itself) in order for this to apply; you shouldn't have to log in and out again (except to the extent that you will if you are using a display manager and you want to restart LXDE, but I suspect the most you'll have to do is restart ). Possible Gotcha Once that's done Geany should be in the list under "Open with" and you can set it via the GUI as the preferred application. Except that if it isn't there already, this implies it doesn't list that MIME type in its file. You can customize that by finding it in and copying it to , then modifying the copy to include the long list of MIME types... Beware also the invocation will have included all source code types, since they are text, so if you have different applications you prefer to use for those and you can't choose different defaults via PCManFM you'll have to do some tweaking of .