Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload. 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

Now, we'll need something to keep track of the inventory levels. We could use a simple for this, but let's go ahead and abstract it out into an class, so that we'll have a place to put some convenience methods. Since we know we'll need to be able to remove an item by name (not caring about the price), we'll need some help to find that entry. We can also add some convenience methods around adding a product. 

One way is to have a function that returns a table composed of two s, corresponding to each of your s: 

5) Try to use mainstream frameworks such as EntityFramework to handle data fetch dirty work. Fetch would look like this: 

Eager load is recommended to avoid separate queries generated when Chart object properties are required (less SQL verbosity, significantly faster for large collections). will automatically map properties having the same (and type, if type is different and no implicit conversion can be done, it will throw an exception) and not ignored ( attribute). 

I will try to cover several points: 1) Naming Try to use homogeneous naming. Pascal/Camel case seem too be used most often, so stick to it. E.g. should be , should be . 2) Improve readability of your declarations Your table variables could be declared like this: 

4) Separation of concerns It is better to separate data connection setup from your data fetch, as setup can also be used for other operations in the future. Also, methods should have meaningful names (e.g. -> ) 

Complexity should be as all dictionary operations are done in . If your documents were copied from some other data structure to your response, I think it is better to construct the dictionary from that data structure and obtain from the merged data. Otherwise, you have to use a loop to remove documents already merged (somewhat more convoluted than version). 

Also, table is not required anymore and the whole block is slimier. 7) Proper data types suggests that Sales_Closing_Date is not a DATE (maybe a or ). If possible, use the most appropriate data type to avoid explicit or implicit (silently occurring in queries) casts. 8) Comments It's a matter of taste, but I like comments written as normal text, not using CAPS 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

Alright, this is the first time I've used Typeclasses so someone feel free to slap me with a tuna if I mess something up. First of all, I don't understand why the use of "FlexibleInstances" is necessary, and it scares me because these kinds of warnings are usually put in place for a reason. With that out of the way, I'll go through the code. 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

This is the key: asks the question "Is this proposition false for all possible inputs"? To test this, we split into two parts: its first argument and the rest. If the first argument is , then is it possible to satisfy proposition with the remaining arguments? If not, then it's a contradiction. This is the part . is itself a function of 1 Bool argument, so it is in class , and so we're able to apply to it to see if it's a contradiction. We also need to be sure that it's not possible to satisfy if the first argument is either, which is why we this with . I'll leave the function as an exercise, and move on to the next inductive step. Inductive Instance Definition - Inception Since is of class , then so too is . I could be mistake, but I'm fairly sure that is actually just short-hand for this. So this means that a boolean function of two boolean variables is itself a proposition. How do we determine its validity? We check if both and are valid. The former means 'if and both evaluate to True'. Hopefully you can see now the recursion that's going on (I haven't done a great job explaining it; sorry)-- what we're doing is recursively defining the ity of the type so that such a function is valid if and only if it evaluates to for all possible inputs. 

I would also mention a little about your naming. C# uses a CamelCase notation for most identifiers (class names, public methods etc.), so you should try to use also for your structures: 

However, keep in mind that your function will be called for each row returned from (clearly visible in profiler, estimated/actual plan does not show function calls, if I remember correctly), so performance might be affected. Also, * should be avoided since it can lead to performance problems (selecting all columns may inhibit indexes usage) and also may also lead to unexpected results (changing table structure without procedure recompilation, means that * does not actually brings you all the columns). If possible, please provide code from - maybe it can be rewritten to be more set based. 

I am not familiar with Autofac (I am a Ninject fan), but I expect similar concepts and implementations, so I have a few ideas: 1) data models serialization I see attributes in your data models, which leads to serialization (?). As far as I know, directly serializing EF data models is not a good idea because it might lead to circular references caused by navigation properties (which crashes the serialization). One way is to define some service models that are obtained from data models. Mapping can be done quite easy using a auto mapping library such as AutoMapper. 2) Repository implementation can be extended with some useful functions 

4. Tests - it is a good habit to accompany a function with a test suite. It is particularly efficient when the code changes much (regressive testing) and helps to cover scenarios that are usually missed when developing (developers have a tendency to think in terms of making it work, not making it fail). 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

It says that a boolean function of one boolean is valid if and only if and are both valid. Of course, the validity of boolean is just that boolean. So in this case, can be thought of as being a bit simpler: 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

Notice how as soon as the grade matches the range corresponding to something in the Enum, the method immediately returns. Now an example of how you might use that : 

What stands out to me is that you initially perform a check against every grade range and insert into the map in the right one. By that point, you've already found which grade is right. But then you initiate another loop to start searching for the grade corresponding to . I think instead, you ought to alter your method to output a enum, and delegate the string handling to another function. I feel that it's better practice to return a Enum from the first method because of the strong typing-- you may want to use this information for other methods besides finding the grade name. In fact, s are particularly nice because you can use a on them. 

Couple of quick comments, since you don't really specify what you were looking for. Seems like everything other than should be ; I probably wouldn't make them extension methods either. I think the whole thing would be better suited to a rather than 3 or 4 coupled methods. Your recursive is an odd implementation that I haven't seen before. It looks like it'd work OK, but doesn't seem standard. Your method seems broken; it never adds the ; I'd probably just replace that class with a or something since it doesn't seem to add much value but could be a breeding ground for bugs. No reason to on ; just return the generic . What happens if or is ? Looks like a , when I'd expect a list of all the added or deleted instead. 

I'd advise that if you're looking for 100% compatibility with here, you'll probably want some extensive unit tests. Here's what I came up with that handles the edge-cases I threw at it, but I don't expect it's bullet proof either. Main changes are using the format specifier, and using to get the number of digits before the decimal place instead of . 

That should clean up the code some. As I started typing that, I figured I'd check for edge cases too - since is filled with them (eg., it includes the negative sign in the length, returns if it overflows, etc.). You're handling the case, but a couple of edge-case values fail: 

Your unit tests for now only need to be concerned with the results of - which verifies the was constructed properly (an important bit to test, since it's weakly typed). You can dress it up with generics, extension methods, builder patterns, etc. - but that's the basic pattern. 

4) Defensive set If by any chance, the select for year returns more that one year, set statement will fail. You might consider assigning with and/or using , just to be sure it does not fail (however, it may return an incorrect value). 

It has been a while after toying with the notification factory and directive. Now I had to actually use it in several dozens places in a real Web Application. Doing so, I realized how much code must be replicated in controllers and markup. In order to avoid this, I tried to keep markup and controller code as simple as possible: The factory: A factory creates a "class" that takes care of the dirty details of setting visibility, type, text and so on. 

Your models project should contain only functionality related to data models such as: data models themselves, data context, repositories. Provided code does a simple thing: gets a model based on its identifier, so this can be included in a Repository. E.g: 

This allows for future types of attacks. E.g. magic attacks Here, the are already some refactoring done, as explained in the steps: 3) Avoid hardcoding values, especially when they meaning is hard to guess. So your comparisons should be made against meaningful constants (I tried to guess their meaning): 

I have used properties, a more generic list type (IList<>) and put a more C#ish capitalization (Pascal case). 2) Proper disposal of disposable objects implements and should also included in a using block (as its close friends and ). Also, in order to shorten things a bit, C# allows usage of to replace the actual data type: 

Inductive Instance Definition - First Step This is the fun part. We're using induction. Here's the full code snippet, and then I'll break down each line. 

Now to be fair, I don't know what the bottleneck in this code actually is, and I'm sure your application probably doesn't call for such niggly optimisation, but I still think it's interesting. I'd wager that the third version is the fastest. 

says that the function mapping our proposition type of to whether or not it's a valid formula is the function . (This function just returns whatever it's given). says that the function mapping the proposition type to whether or not it's a contradiction is the function . Just as well, because takes just one as an argument, and returns a . This is compatible with the contract we laid out earlier in the typeclass definition of . says that the way of comparing two of these propositions (once again, of type here) for logical equivalence is to simply invoke the already existing method . 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

It is also recommended to use enums for your units, so that unitConvert caller cannot provide an invalid unit: 

Some things that just pop out when seeing your code: 1) Classes/POCOs definition They do not seem properly written, probably reproduced from memory. A better version would be: 

4. Simpler and more natural iteration Your logic is fine, however a chess board is 8 x 8 and a natural way to iterate is by rows and columns, rather than tile by tile. 

One way to make it easier to follow is to construct your merged documents result separately from your input (above code is not tested). Construct a dictionary to easily get the document to append to, based on type. It also ensures a fast operation. For each document from the input, append its pages in the dictionary: 

1. Functionality extension - besides already mentioned answers, I would extend your functionality with a back-off mechanism which can prove useful in some situations (e.g. a SQL deadlock). Since the options are quite a few now, these can be contained into a special class: 

A possible approach is to put all the repositories in a UnitOfWork class, so that multiple changes can be done in a single unit of work (transaction). Something like this: 

HashMap operations have a complexity of , so function's overall complexity is , where n is string length. [edit] Based on correct observation, a HashSet is a better choice (elements only, no key and values): 

2) Variable declaration closer to usage C++ allows you to declare your variables anywhere before they are actually used and it is a good idea to be as close as possible. The first part of your program may look like this: