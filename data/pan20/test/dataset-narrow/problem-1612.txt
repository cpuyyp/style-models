I have raspi 3 with a Cirrus Logic audio card, with this kernel: $URL$ complied from source It is working, and I have audio for the root and pi user, however an arbitary newly added user does not have correct audio capabilities. The new user in the audio group, it is in the same groups as the default pi user. The new user can see the sound card via aplay -l, even can play waw files via aplay, but nor VLC neither mplayer are working. They play audio files without showing any error, but there is no sound. 

I tried to install pillow inside a virtualenv under the interpreter: $VIRTUAL_ENV/bin/python3.4 I used the command: 

I'm leaving this here for others that may be looking for this. IT CAN'T BE DONE You need an ASIC (Applicaiton-Specific Integrated Circuit) to drive the display. ================ What I need to know is where to start doing research in how to render stuff on a replacement Kindle (preferably a paperwhite) screen. What I want to achieve: Make a rather expensive bed-side alarm clock. What will make it unique: It'll have a nice big e-ink display screen Why? 2 reasons. 1: Right now I use my cellphone as an alarm clock and I think that having that next to my bed is keeping me awake at night, so I want to move my cellphone out of the bedroom completely. This means that I need another alarm clock next to my bed. 2: I sleep in total pitch-black darkness. Even a very dim LED bugs me and will keep me from falling asleep. So the idea, is to hook up a Pi to a new replacement Kindle screen so that there's no light. But it'd be nice to be able to touch the screen and the back-light will come on for a few seconds and then go off again so that I can see the time if I want to. The question is: Where should I start figuring out how to insert tab A (Kindle Screen) into slot B (Raspberry Pi) and then get them to start talking to each other. I've found people that have turned a working Kindle into a WiFi Pi terminal. But I don't want to (1) buy a whole new kindle to just be a bed-side alarm clock and (2) I don't want to void warranties by rooting any devices just to do so. Also, I've looked at the PaPiRus, but it's way too small, even the big 2.7" one. I want something chunkier. 

I want to use git as a version control for my system configuration. So I initialized a git repo in "/". However on every reboot my .git directory is deleted by the os: Raspbian. However the .gitignore is not deleted. On my desktop (Gentoo Linux) I do not have this problem. Why is this happening? How can I prevent this behavior? Update: I tested further and it seems: The system removes any dotted (hidden) directories in "/" but not files I will use git submodules, so please do not suggest to init repos per dirs like /etc. I really want all of my configs in a git repo and some hierarchically nested repos (submodule) inside it. 

I've got a 3Tb External Hard Drive that I would like to use to run my Raspberry Pi2. I'd like to have a few separate partitions for various services: 

I've written a few (what I consider to be cool) bash scripts (that are specific to the Raspberry Pi), and I'd like to share them with the community. Is there a jsfiddle-like site where I can put up the scripts? Maybe even a community-based, cloud-sourced, site would be good for this, maybe in a wiki style. Does anyone know of one like this? I just added a very brief script to JSFiddle to see if it'd work. Please let me know if you guys would use this. Or if it's just a horrible idea. 

Using python2.7 installing pillow with apt, then trying pip virtualenv install again Other info I can install other packages like picamera, ipython etc... I can install a fully functional pillow via apt. Some other packages show similar pattern when I tried to install them inside a virtualenv: for example zbar python module gives the following error: 

I recomplie the Raspbian kernel for Cirrus Logic audio card, following this description. $URL$ and I wonder what does mkknlimg exaclty do. and I found these: "Note that DT and ATAGs are mutually exclusive. As a result, passing a DT blob to a kernel that doesn't understand it causes a boot failure. To guard against this, the loader checks kernel images for DT-compatibility, which is marked by a trailer added by the mkknlimg utility; this can be found here, or in the scripts directory of a recent kernel source tree. Any kernel without a trailer is assumed to be non-DT-capable." at $URL$ What I found: From ATAGs I found that They are used to pass physical memory layouts to the kernel at booting process on ARM arch, and they are incompatible with the Device Tree blob. My question: What is a "trailer"? 

Naturally, I'd also want a partition for booting. The big question is: how big does that partition need to be? Naturally, dedicating a whole Terabyte to it would be overkill, And I know that I can have it on 16Gb (or even 4), but is all that space necessary? What is a good size that would not be too small and at the same time, not wasting space? Also, is a swap partition needed? 

So in frustration, I've thrown a little site together that has one script on it so far. It's very much a static site. I plan on adding a comments section on it later, but for now, it's very much non-interactive. If you've any feedback on it (positive or negative) let me know. $URL$ I hope the stackexchange sites don't mind me imitating some of the styling. 

I am currently working on a small rpi3 kiosk. I managed to set up a boot splashcreen with fbi started by an initscript. However I can not make a smooth transition between the splashscreen and the openbox background (image loaded into the root window of X) Even if I use the Esetroot command at the very beginning of the .xinitrc file (or openbox-session file in the case of using lightdm), there will be short period of grey ugliness before it loads. Are there any way to make X server to load/show its root window already with an image in it? or as a fallback change the background color to black. $BG -solid "#000000" is the openbox startup file did not do the trick. My .xinitrc: 

Is there any way to force the shared memory to ? I'm running Jessie on a pi3 (and a pi2 and a few zero-w's) as a headless server and only ever access it via SSH or a WebUI for certain services. I just do not see any reason to keep any memory reserved for a GPU. Now I know that the documentation states that the minimum is 16Mb, and if you try to set it to 0 using , it ignores you and resets to the default 64, but there must be a way to free up those last 16Mb to other services that will actually use it?