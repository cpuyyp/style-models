However, by employing the strategy of making the removed path be in the last place the deterministic algorithm will look for it, it can force the algorithm to either not find the path (and not be able to distinguiish $H'$ from $H''$) or examine $\Omega(n^2)$ edges of the graph. In particular, as long as it is possible to answer a query (what is the $i$th entry of the adjacency list for vertex $v$) consistently with $H$, the adversary does so. Once the adversary is forced to choose the remaining path edges, it makes this choice arbitrarily, along with the choice of $H'$ or $H''$, and then answers the remaining queries according to the choice it made. In order to force the adversary to choose between $H'$ or $H''$, the deterministic algorithm must see a set of edges that covers all two-edge paths on at least one of the two components on $H$. But each component of $H$ has $\Omega(n^2)$ disjoint two-edge paths, so the deterministic algorithm must see $\Omega(n^2)$ edges before it covers them all. And if it doesn't force the adversary to choose, then it is unable to distinguish graphs that have a cut vertex from those that don't, or to tell which vertex is the cut vertex. 

The cells in a $kD$-tree can have high aspect ratio, whereas octree cells are guaranteed to be cubical. Since this is a theory board, I'll give you the theoretical reason why high aspect ratio is a problem: it makes it impossible to use volume bounds to control the number of cells that you have to examine when solving approximate nearest neighbor queries. In more detail: if you ask for an $\epsilon$-approximate nearest neighbor to a query point $q$, and the actual nearest neighbor is at distance $d$, you typically end up with a search that examines every data structure cell that reaches from the inside to the outside of an annulus or annular shell with inner radius $d$ and outer radius $(1+\epsilon)d$. If the cells have bounded aspect ratio, as they are in a quadtree, then there can be at most $1/\epsilon^{d-1}$ such cells, and you can prove good bounds on the time for the query. If the aspect ratio is not bounded, as in a $kD$-tree, these bounds do not apply. $kD$-trees have a different advantage over quadtrees, in that they are guaranteed to have at most logarithmic depth, which also contributes to the time for a nearest neighbor query. But the depth of a quadtree is at most the number of bits of precision of the input which is generally not large, and there are theoretical methods for controlling the depth to be essentially logarithmic (see the skip quadtree data structure). 

The time is essentially the same as that for sorting numbers in the range $1,\dots M$. Graham scan (in the version where the points are sorted by their x-coordinates (with ties broken by y coordinates) rather than the one the textbooks unaccountably use in which they are sorted radially) can find convex hulls in linear time after the sorting step. So for your problem in which the coordinates are small integers, all the standard bounds of integer sorting apply. In particular, radix sort can achieve time $O(n(1+\frac{\log M}{\log n}))$ (e.g. linear time whenever $M$ is at most polynomial in $n$), and a randomized sorting algorithm of Han & Thorup 2002 can achieve time $O(n\sqrt{\log\log n})$. These are in models of computation in which machine words hold integers of some word length that is big enough to store the numbers $n$ and $M$ and in which one can do arithmetic and table lookups in constant time. Conversely, you could use a convex hull algorithm to sort a set of numbers $x_i$, by finding the hull of the points $(x_i,x_i^2)$. So if you could do convex hulls any faster than this, you could also improve the times for integer sorting. (The range $M$ of $y$-coordinates of these points would be the square of the range of the numbers, but since all the time bounds involve logarithms of this range, squaring $M$ makes no difference in terms of the eventual $O$-notation.) 

You need to specify that $G$ is a simple graph (else the trigonal hosohedron is a counterexample) but then the answer is yes. What can go wrong? If a dual face is not a simple cycle then one of its edges is repeated, giving a self-loop in the primal, or a vertex but not an edge is repeated, in which case this face and vertex form a configuration of the same type in the primal. If two dual faces meet at more than one edge then there is a multiple adjacency in the primal. If the dual has a self-loop or multiple adjacency then we get a face with a repeated edge or two dual faces meeting at more than one edge in the primal. If two dual faces meet at two vertices but do not share an edge between these two vertices then a configuration of the same type happens in the primal. And if two dual faces meet in an edge and a third vertex then in the primal we have three faces sharing the same two vertices and they can't all three contain the edge connecting these two vertices. 

Short answer: no. Let $G$ be a complete DAG (transitive tournament) on $n$ vertices with $s$ and $t$ its source and sink, and let $k=\sqrt{n/3}$. Observe that there can be at most four disjoint cuts that contain more tham $n/3$ edges incident to $s$ or more than $n/3$ edges incident to $t$. So, if there are to be many disjoint cuts, we can assume that there exists a cut $C$ that does not contain large numbers of edges incident to $s$ and $t$. Now let $X$ be the complete subgraph induced in $G$ by the set of vertices $x$ such that edges $sx$ and $xt$ do not belong to $C$. The number of vertices in $X$ is at least $n/3$, because otherwise $C$ would touch too many edges incident to $s$ or $t$. However, $X\setminus C$ cannot contain a $k$-path, because if such a path existed it could be concatenated with $s$ and $t$ to form a long path in $G\setminus C$. Therefore, the longest-path layering of $X\setminus C$ has fewer than $k$ layers, and has a layer containing more than $(n/3)/k=k$ vertices. Since this is a layer of the longest path layering, it is independent in $X\setminus C$, and therefore complete in $C$, so $C$ contains a path $P$ through the vertices of this layer, of length $k$. This path must be disjoint from all of the other cuts. Every cut that is not $C$ must contain either the edge from $s$ to the start of path $P$ or the edge from the end of path $P$ to $t$, or else it would not block the path $s$–$P$–$t$. So if $C$ exists, there can be at most three disjoint cuts. And if $C$ does not exist (that is, if all cuts cover more than $n/3$ edges incident to $s$ or to $t$) there can be at most four disjoint cuts. Either way, this is a lot fewer than $k$ cuts. 

One way to augmenting an embedded planar graph (i.e. a plane graph) to become biconnected, while preserving the embedding, is 

We form a variable gadget for a variable $v$ that belongs to $k$ different clauses of the NAE-3SAT instance, by gluing together $k$ shared $4$-cycles on a shared edge. Then in each of the $4$-cycles, the opposite edge to the shared edge has to be oriented consistently with all of the other $4$-cycles. We will associate the truth value of the variable with this consistent orientation of these edges. Additionally, in any valid orientation of each of these $4$-cycles, there is no path from one $4$-cycle into another $4$-cycle, so these gadgets can interact with each other only in the orientation of their edges and not through the existence of longer paths. We form a clause gadget for a 3-variable clause of the NAE-3SAT instance by gluing together three of $4$-cycle edges, opposite the shared edges of the appropriate three variable gadgets, into a 3-edge path $P$ and then adding a degree-two vertex to complete $P$ into a $5$-cycle. As discussed above, this $5$-cycle can be consistently oriented if and only if its three edges are not all oriented as a directed path, which (when glued correctly) is true if and only if the truth values associated with these orientations are not all equal. By the way, DAGS with at most one $s$-$t$ walk for each $s$-$t$ pair have been studied previously, as "multitrees", "strongly unambiguous graphs", or "mangroves"; see $URL$ 

$O(kn+n\log n)$. See P.B. Callahan, S.R. Kosaraju, A decomposition of multidimensional point sets with applications to k-nearest-neighbors and n-body potential ﬁelds, J. ACM 42 (1995) 67–90. In some models of computation the $O(n\log n)$ part can be reduced or removed; see also T. M. Chan, Well-separated pair decomposition in linear time?, Inf. Proc. Lett. 2008. 

The linear time algorithms for this sort of problem are based on the SMAWK algorithm rather than more straightforward dynamic programming / memoization. I have an implementation of a linear-time line-breaking algorithm (possibly not exactly the one you want, but likely similar) in the Wrap.py module of my collection of Python algorithm implementations (you'll also need SMAWK.py). 

You can recursively decompose each triangle into a smaller triangle and a trapezoid, and each trapezoid into two smaller triangles. The corresponding tree decomposition (whose bags contain the corners of a triangle at one level of the decomposition and a triangle or trapezoid at the next or previous level) has five vertices per bag and therefore has width four. There is no $K_5$ minor, because the graph is planar. There is, however, a $K_{2,2,2}$ (octahedron) minor (actually, a subdivision), shown below. As this is one of the forbidden minors for treewidth three, the width is four. 

Aren't you missing (AC)B? The number of ways of completely parenthesizing $n$ objects (where the parenthesization matters but the pairings are commutative) are given by the odd double factorial $$(2n-3)!!=\prod_{i=1}^{n-1} 2i-1,$$ 1, 1, 3, 15, 105, 945, 10395, 135135, ... (OEIS A001147). But of course for an actual database many of those won't make sense as a join, because the relations won't share a column. Are you looking for the number of different choices when you haven't yet determined the schema (for which the answer is the one above) or for when you have a fixed schema (in which case it would depend on the schema)? Update: it seems that what is being asked is not just the parenthesization but then the sequence of operations. If the joins are non-commutative, then the $n!(n-1)!$ answer would be correct: you have $n!$ ways of placing the tables into a sequence, after which a parenthesization and sequence is determined uniquely by a permutation on the gaps between consecutive items in the sequence. Each gap describes a pair of things to be joined (input tables, or results of prior joins) and replaces them by their join. However, I still maintain that joining is generally a commutative operation, so that $AB=BA$. With the above formula, each sequence of $n-1$ operations is counted exactly $2^{n-1}$ times, once for each way of swapping the arguments for each operation. So the actual count should be $n!(n-1)!/2^{n-1}$. This gives the sequence 1, 1, 3, 18, 180, 2700, 56700, 1587600, 57153600, ... (OEIS A001147) For instance, there are 18 sequences of operations on four items. The first pair to join is one of the six pairs AB,AC,AD,BC,BD,BD, and they're all symmetric, so let's say we start with AB. Then there are three sequences that start this way: ((AB)C)D, ((AB)D)C, and (AB)(CD). Each of the other five starting pairs also belongs to three sequences, giving 18 total.