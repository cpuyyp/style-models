Throwing errors is in my book an action of last resort, something done to continue execution. If I throw, I will catch. Or you can use throws to help debug code, but that should be removed on release. 

ES6, ES7 and general style review This review will focus on language use and general style. Looking at the code it is well written, and works (always a plus). Though I have not looked in detail at the logic of the solution, whether it is optimal in terms of memory and cpu usage I will leave to someone else to maybe expand upon. As pointed out in your question's comments by jonah, the rendering would best be suited to a separate module, I do not think in this case that is all that important as it is clearly an experiment and not designed as a general path finding solution (e.g. here is a maze, find a path.) Modern JavaScript. The most obvious issue with the code is that it uses the older JavaScript language specification (with the exception of ). Though this is not a reason to say the code is bad, but if you are doing this as a learning experience you are better of using the latest and greatest. Latest versions of JavaScript ES6 and ES7 (links are to compatibility table) provide many useful syntax shortcuts that can take a bit of getting used to, as well as a lot of new functionality. As example the spread operator. ECMAScript (stage 3) Spread operator You use to create copies of the object. The object is just a simple object that you have not assigned a prototype. ES7 provides a simplier method of assigning an object properties from another. The spread operator and object shorthand constructor syntax 

State The second does not create a new array and keeps all references It is "functionally" impure and ensures that the changed state is available to all references to the original. It is considerably quicker and uses less memory. 

Repetition, similarities, and redundancies To simplify code you start by looking for repetition and similarities. In most cases you can remove the repeating/similar code by adding variables to take care of the minor differences. Count how often you use a variable name, eg and are defined 5 times, and you have had to type them in 10 times each, and has even more. Variable names also should not have repetition. If you find yourself creating a pile of variables that all share some prefix or postfix, it's a good sign that you can optimize and simplify. Don't do something twice when once is enough. A common practice is 

As you are a beginner your time is much better spent learning to use the native DOM directly. This will give you wider, future proof skill set. Direct element reference If you use element ids correctly (they must be unique) you can use the id to directly reference elements in javascript. This is supported by all browsers. 

Passing arguments Parsing arguments is easy using rest parameters and the spread ... operator For example 

Recursive memory hog!! I have to say that this is not at all a practical way to zip two arrays. Recursive functions are huge memory hogs in JS if done badly In Javascript calling a function adds a minimum of about 1 - 1.5K to the call stack, and you create copies each array of each call, ouch.. Test I ran your function giving it two 8Mb array (1,000,000 numbers each) and it crashed Chrome. Something I would expect to do using a function like zip. Crashed at 0.01% complete Canary 65 devtools has a live performance monitor, so I ran that and I watched memory climb in less than a second to 1GB befor the browser interrupted and paused the code. The heap is full and the function was only 97 iterations in (approx 0.01% complete). Why the memory usage? Your use of is the reason. Slice creates a shallow copy of each array. So if you have an array of size 100 and slice at 1 you now have two arrays for a total of 199 items. Lets follow the recursion with 2 3 itemed arrays 

Recursion is a state stack. Function context Every time a function is called JS creates a new context (function state), even if the function does nothing, creates no variables, has no arguments, only calls another function, it still requires its own context. The process of creating and pushing to the heap costs memory and processing time. The minimum memory cost varies between JS engines, but 1K is a reasonable estimate for an empty context. Note The exception is Proper tail call Functions that by nature of the return, may not require their own context, they use the calling functions context. (No browser current lets you use this ES6 required standard feature) Recursive state stack In general recursion is used as a way create a state stack. Each iteration (recursive) call creates a new function context, with closure that is pushed to the heap. When the a function exits its state is deleted popped from the heap and the calling function's state is reinstated from the heap. Example showing states pushed and popped The following illustrates the state stack. The state includes a random value. Each iteration waits 200ms before creating the next. When the recursion exits each state is popped from the heap, the functions complete execution until the stack is clear. 

Quick review. It is not bullet proof. So much so that it is a bug dressed in javascript. You must protect against improper use, inadvertent error, or failure to complete. The next bit of code shows a variety of ways it will fail. 

Solve all at once. This is 3 problems in one but they all share some similarities. There is no clear cut way to effectively separate the 3 functions without some code repetition. The best option would be to solve all 3 at once and just return the appropriate result. You are looking for two values, the closest value below and the closest above. If you search from the lowest up, you can exit the search as sone has you get to the first value above searched for value. This will on average reduce the iteration by ~half (depending on the distribution and number of items). Because the array is already sorted the search is very simple. Get the dif between the submitted value and array value. Each value less than 0 must be the closest so far (as array values are increasing) As soon as the dif is greater than 0 you have found all the data needed to answer any of the 3 types of data. Exit the loop and then check what needs to be returned. 

Follow instructions. Both answers (in my opinion) are wrong, as they have not followed the instructions and added additional behaviours not specified in the instructions. The question is very clear as to what the function should do 

Simple conditions Make the condition statement as simple as possible. You had the additional not clause is extra work (if not optimised) is the same Use variables Some javascript engines (V8) are not as quick handling literal numbers. eg is slower than but you must take into account the declaration and assignment of the variable. If you use the number once or twice there is no advantage, but if you do it many time there is. Math rather than Loops Alway check to see if there is a way to directly calculate the result rather than use iteration. You do not actually need any loops Use memory Memory is cheap and fast, CPU cycles are not. So rather than iterate have a predefined object that can be used to create a result You have 

Use rather than to set just pain text. ES6 offers many features that you could have used to simplify the code. One of which is getters and setters. In the rewrite below I have used setters to change the score, check the answer, and start the countdowns There where many places you could have used ternary expressions rather than if/else statements. 

Cyclic references. But still the approch is unfortunately flawed. See what happens in the next example 

The function is called (should not be capitalized) though to me it seams to find highest template. Maybe a better name? The function is about templates, is there a need to add template to , Good naming uses the context to infer. Keep names short by not adding redundant and inferred details. 

The rows are symmetrical, the right side is a mirror of the left. There is a formula that lets you calculate a row which can help reduce the complexity. 

To do the flow you can define some simple directions and then just iterate following the instructions. For example the human readable form. Start top left, move right until edge,turn down move one step, move left until edge,move down one step, and repeat. Stop when no more places to move. And the machine readable form 

Note that I create and add the list item to the task. Also note that the dirty flag is set to true whenever I make any changes. 

No you should not underscore. Underscore has no meaning, and thus makes for a bad variable name. It is just noise that makes the code harder to read. 

BTW you break the codeReview site rules by not supplying working code, you have given example of what your working code does. It is incomplete and non functioning. 

Which is twice as fast again at 1ms or 1,000,000 calls per second. Which is the best, that could be debated forever as all three work except for one problem that is often forgotten when manipulating numbers. is not dealt with. The two string methods fail as they try to evaluate the and the pure number version fails trying to maintain the least significant digit that is way outside the 64bit Double's precision. But then we assume that arguments are vetted. Results of a benchmark Not runnable just hidden to avoid clutter. 

Closure is very powerful and you should use it as much and often as you can to gain experience. Closure is very secure, fast, and does not carry syntactical baggage 

Naming and Commenting An important part of being a programmer is good naming. Looking at your code at first glance it seemed fine, until I started to rewrite it (I always rewrite when reviewing). For good code I should be able to rewrite the code without the need to go back to the original source for clarification. In this example I was constantly going back to try and understand what you were doing. The main reason was that the name of variables that did not match what the variables contained and conflicted with important global names. Comments To make it worse the comments confused things even further So let's examine the comments 

Sort all events by . Reduce the events array to event , adding an array of times to each type. Sort the reduced events by . Empty events array and reconstruct events using the following method. From the lowest time search the reduced array for matching times. Add to the events array matching time and associated type. Removing from if more than one , and or remove if only one for , until reduced array is empty. 

Which is a lot more readable. Performance Now the problem of performance. , and are both slow and use more memory than is needed. Each recursive call does not release memory until you exit, which happens at the end of the searches. Plus all the paths that are not part of the solution that you filter out each iteration A quicker solution using a simple loop and changing when you create the new path so you don't need to hold paths that go no where. 

Faster does not mean smoother. Some very quick notes. Queries to the DOM are very slow compared too what they do. You should only query the DOM for the elements once and then just use the references you have. When page is ready 

A need I have always found dynamically creating SVG content and filters a painful and messy process. 

Or use direct DOM refernces to access the DOM. Just use the elements id as a variable name. Be sure that element ID's are unique on the page. Example of direct element reference, and what not to do. 

There are very few situations in when you need to use a block. I feel that if you are using them you are being lazy. There are many problems that can be overlooked when using try catch. Here are just 3 for your case. 

And submitting to keetCode it got a lower score than using a loop, being only ahead of 73% of submissions ??? Then I tried 

Don't create a new object every time you find the next highest version. Set the properties of the existing object to the new highest. Only call once, you should not call it again when you find the highest version Don't pass strings to it requires additional overhead to convert the string to a RegExp Don't test for the same thing twice. and can be done in one step. 

The above object defines an array of cells (items) and a description of the projection used and details about a cell size and details about the cell layout. You can call the function and it returns a cell if you have given a coordinate over a cell. It does it very fast compared to a search. Improved search Even if the cells are randomly placed and you need to do a search, converting to world coordinates means you can work in axis aligned coordinates rather than the complex inversion you do for each cell. 

Testing Technically your question is against rules as it is not a working example, and I wonder if you ran it at all See what happens when you run it. 

Render at 60fps Or just render at full rate and control speed in the game rather than via the frame rate. 

is an array holding the array and by adding to the array I have created an cyclic reference. If you were to use the dimensional description it would be a infinite dimensioned array, which is clearly impossible (no memory store is big enough) but still works. I have never tested how far you can nest the [] but there is a limit somewhere. 

DRY but not a desert. It is not possible to be without repeating code, sometimes the complexity of the problem makes it hard to avoid repetition, or repetition may be the quickest way to solve the problem when time is short. Sometimes when execution performance is the driving force repetition is the only way to get the best performance. The length some coders go to too avoid repeating code can become so complex and difficult to follow that they have lost any advantage they would get from DRY code. A DRY KISS is best. DRY is practical, saves you time entering and modifying code. DRY code is more compact and thus should be easier to read and understand. If this does not happen then it was best left as it was. 

@Aaron Goldsmith thanks for the edit suggestion but I have a style rule that is no object property short hand on the same line as standard properties. So I leave the line as is rather than break it up. An alternative. To accommodate points made in the comments we can leave the responsibility of what to do with the information generated by the function to the calling context. This version returns an array with an item for each century. 

Now you have an alternative solution without a slice in sight, improved memory and CPU use because you can avoid the recursive over head, and a reduction in the overall complexity by turning many of the merge call into simpler single statement sort. 

Example I have done a very quick rewrite of your map generator using some patterns you may not be comfortable with. Take it as an example only and use what you want, it is not the only way to do this type of thing. I have provide various links in the code to MDN in regard to JS language features you may not know about. MDN is a good reference for all things browser and worth having a bookmark to. The example generates a map using the same logic you used. The additional calls to and are needed. You can define many worlds each with a different set of terrains and set ups. The example only uses one named Click on the map to regenerate a new one (it uses the old map so not a completely new map)