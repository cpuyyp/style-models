You should consider using a plain 2d-array or alternatively an array of rooms, where each room is a 2d-array or a grid. A would looks something like this: 

In other words, it does everything that is needed for the groundwork and does not decide the rules of your game and how things look and sound but it allows you to display those things, write those rules as a human readable & programmer friendly script and play those sounds and music. It will help you to enforce some common rules like physics and collision detection. Longish version ("this way there be dragons"): 

Convert the meshes to voxels. Do a boolean operation on two resulting models to get the differences. Use some transformation to gradually dissolve the pieces that exist on the original source mesh and do not exist in the target destination mesh. Use another transformation to grow the pieces that exist in the target but not in the source. Replace the voxel model with the target model. 

The images are often changing, so it needs to display things in motion. (the walls might not be moving but the camera is hence in motion and not necessarily moving). Now if we generalize it depends if the game is 2D or 3D. 

Common physics - often time Engines may provide physics simulation. This is very difficult to implement on your own. Collisions are also hard to detect in 3d space or in a pixel perfect way without compromising performance and most importantly getting it bug free, unless someone who does it well, sits and invests the time to get it right. Cross platform support and networking anyone? So you written your game in some low level language. Does it support other platforms and do you have stable, bug free multiplayer? Probably not. Unless you used a library like SDL/SMFL. Often left unnoticed, conventions (emphasized over configuration [this is important in large teams but also for time pressed individuals]), solutions for bike shed issues. Support for multiple input devices like keyboards, mice, XBOX controllers and such. Some Engines come with excellent tools to create assets like levels in your game. It may even have a large database for assets for sale or ones that are free to download. 

In order to compute left and right, you need the concept of "up". For instance, if you are flying a spaceship and performing a "barrel roll" then the concept of "up" changes and with it, left and right change as well although you are facing in the same direction. Up can be based on the plain the character is standing on or simply be an absolute direction. 

The wrong approach is to simply delay the user input from activating the command. Assuming you know the other clients can be informed 99.9% of the time in half a second, delay the command for half a second and send it to the other clients as the pair so the other clients could all preform the command synchronously. Obviously, you have to sync the clocks when the processes start which is a question on it's own. The correct approach would be to perform the command slightly later on other clients but have them behave programmatically as if the command occurred at an earlier time. i.e you time-step back some milliseconds into the past, preform the command and then re-evaluate the simulation from that point, preforming any other later command as necessary until the current time. This could lead to jittering (sudden changes in position). You can smooth these out by interpolating the animation between the true state and the subjective state on the client. i.e starting from and increasing by easing out and easing in. Alternatively, you could abandon this approach completely and use one of the clietns as a Server and the others as "dumb terminals" that only accept input and display the current state of the game; this way instead of sending orders, you constantly send updates on the new positions of units, evaluating a few steps into the future for slower connections and a more accurate present state for faster (LAN) or low latency connections. 

3D - We need to talk to the 3d api (like OpenGl or Direct3D) and render models (data representation of a 3 dimensional visible entity) in real-time (this is not easy to do). 

Outside of loops and constructs that cause the player character to shift position in the depth axis, what you wish to achieve can be done by implementing the game in 2d first with programmer art. Playtest the 2d game to tweak the game and level mechanics. Then use the 2d level as reference to construct a full blown 3d level that lives across the x, y plane and matches the original 2d design across that plain. The meshes can still have some depth for platforms and walls of course but that depth needs to be sliced in the middle by the 2d plane that defines the level spatially. The gameplay will be completely 2d as before (other than some minor tweaks like the loop where the player character may need to be in two different depths in the same area). The only difference being that you will now use the xy values to position a player character model and use a camera to render the scene instead of simply using sprites. The is no reason to use a spline or a path cause that will allow for no vertical motion. You definitely need a plane to allow the character to move freely, up and down and left to right. 

This is not classic spring behavior as it does not consider the fact that the spring will repel an object if it is too close (closer than the equilibrium point). If you wish to emulate that, detract a constant from the distance and it will push the object away if it is too near. To make the object stop, you will need to weaken the spring, otherwise it will continue to move near and then away after reaching it's attractor. 

The models are important but all the processes will likely need to be handled every frame. If so then why trigger them with an observer? Why connect them conceptually to input? Why mix all the different types on manipulations that are done on the model with one another? 

This function appear strange because it does not actually compute force, it compute the delta in velocity (the change in velocity) which is needed in order for the agent to turn and pursue the target. It has nothing to do with force and mass and yet those are artificially squeezed in there for no reason. If you want gradual change, compute the desired change (like you already do) and make partial changes each frame. This could be done in several ways, one is to cap the acceleration like you do with the velocity. The other is to compute the desired change and then multiply it by some fraction. The change is gradual only when is bound or partial (e.g. 10% of the needed acceleration). Whenever acceleration is used to change velocity and velocity is not changed instantly to a new value, you get the desired gradual smoothness. In this case there does not appear to any gradual change. It appears that the change is instant. This is because the acceleration is not capped or multiplied by some fraction e.g. 0.05. If you wish to make change smooth and gradual, simply multiply the acceleration by some fraction such as (frame time) and perhaps cap it with some maximal value. Otherwise you are just setting the new velocity to the desired velocity for pursuit. You can use: 

See the image, you would check the green ellipse against the green circle cause they are both in (1, 2). 

You check if a point is inside a tile by dividing that point's position by a tile's width and height and then check if there is a tile in the resulting position in the 2d array that represents the tiles. 

Again, I don't see why updating every second should be a huge concern but some benchmarks and tests you could easily perform would alleviate or affirm your suspicions. Then you could lower the rate of updates and/or employ a different strategy (offloading some of the work to client-side [Angular]) or something like that. 

Where do you get the variable from, is it large enough to ensure the will be low enough to meet the condition the second time? You said that it stops for a second and then continues to fall so my educated guess is that you are not fixing it up enough. Give this a shot: 

You are wearing a very uncomfortable pair of shoes because someone said so but do you understand why it was suggested in the first place, vs a dynamic array of Entity instances with data members like most moden oop programmers would write? It is there for very specific performance concerns that are unrealistic for most modern indie games. You should ask yourself why you are doing things this way precisely. What do you wish to accomplish by following these guidelines? There is no point in moving away from the simple tested concept of a dynamic array (read Vector C++) or Entity instances with data members and methods relevant to those entities. There is not one needed advantage that you pointed out for having an array for each property. It does not make any sense if you are an indie and not encountering some mysterious performance issues that you think you'll resolve by reducing the amount of cache misses you get. In fact, the cache is pretty big nowadays. If you only access relevant entities at any specific time then it's likely you'll have plenty of cache to contain their data. Besides even if you do need to access memory, it is unlikely that will greatly reduce performance. Run some benchmarks and realize what you are so bent on achieving by writing less readable, and harder to maintain code, is possibly not worth your precious time. What do you actually want to make? If we don't know what is the you want to get, we can't understand why you wish to when it's clearly inferior and questionable for a lot of situations. 

To answer your question, here are some factor of assets cost, as a factor of time, skill and quality of the resulting art. To make sense, shall we quantify that we are talking about a single asset. A game character. The pricing will differ greatly, not between 3d & 2d, it will differ between professional experienced artists and skilful amateurs. It will also differ if you decide to use outsourcing. Now, lets look at 2D vs. 3D, again, the cost will differ a lot based on the amount of animation the character requires, more animation = more work. That being said, it is generally less time consuming to animate in 3d because of advanced software that offers tools like bones. When animating a 2d character, the artist has to in most cases(unless using cut-out style rotating limbs) render each frame of animation by hand, that is a very time consuming process. Generally per character, it is nearly completely obvious from a technical perspective that building one 3d character with basic animations, is more expansive than one 2d character in the same 'league' of quality. Why is that? Well, when building a 3d character, you need to construct a model, create a uv-map, paint a texture, rig the bones and then animate it. Since it is 3d, it has to look good from every angle, so a lot more thought and work has to be put into examining the model from various angles while animating and constructing it. Also, because of the technical aspects of UV-mapping and rigging - bones, certain software related issues could rear their ugly head and the artist will have to face these technical issues. You can normally only see 2d characters from one angle, so that is worked out, there is no use of advance software need to create classic animation. That said, animating something like King Of Fighters takes great mastery, knowledge and dedication. So the short answer is yes, 3d is more pricey in terms of work hours. high level 2d animation is also very pricy. The previous two comments are less prevalent than the choice between outsourcing vs. working with someone in the same office and the choice between taking on someone who has proven experience vs. a skilled amateur. The most important variable is the scale of the project. Also, remember that if you take a 3d-modeler you would probably have to hire a level designer as well, cause a professional character modeler might is not very likely interested to be involved at all in level design. A 2d artist that can design characters well is likely a reliable source for background art too. I suggest you ask several artists and compare their proposals. Good luck. 

Add a meta graph that explains the route between floor entrances / exits from floor to floor . The vertices are entrances / exits, the edge length is the path between an entrance and an exit in tiles on floor . Each entrance / exit is connected by such weighted edges to all entrances and exits that are accessible from it through the floor(s) it's on. Use your existing tile-graph A* per floor to find a path from an entrance to a desired exit. The path length will serve as the edge weight on the meta graph. The meta graph will be used to quickly know, which entrances and exits need to be accesses but it's edges and their weights should be computed in advance. It explains through which floors you need to travel to get from floor to floor . The meta graph uses actual vertices and not tiles, in the sense that you need a list of neighbors for each vertex. A floor is not interesting as an object and is only used to connect it's entrances and exits with edges computed by the tile based path on each floor between them. Remember that is an area on some floor is blocked, that floor should be logically divided to several sub-floors as entrances in one blocked sub-floor, do not allow direct access to other sub-floors. Once you use the meta graph to figure out which floors or sub-floors you need to travel, you simply use the same tile based path-finding on each floor to get from entrance x to exit y. 

Using a gray-scale bump-map and N sources of colored light, what is the algorithm to render the light on the textured surface, assuming I have the angle(s) and distance of each light source? (I am pre-rendering in software). I have the part where it renders light based on the position and angle of light source. My question is twofold: