Using a dictionary As an update, I have considered a second soltuion, that should significantly reduce the amount of iteration in the inner loops, at the expense of lookups in a dictionary. The dictionary maps the sum-of-factors to the values that have that sum. For example, the sum of factors for 6 and 25 are both 6. (sum of factors of 6 are , and for 25 it is ). The mapping looks like: 

Now, about those performance improving options.... Let's assume that the best way to solve this problem is to do a cross-product of the two tables. Compare each value in table a with all values in table b. Oracle ha a few options for doing this. I will list them in what I consider to be a worst-to-best order: 

Since changing trhe data type in the column is not feasible, the above query has been edited to do the conversion in just one pace... Here's the from/where clause if the table had numeric .... (Replace the original from and where clause ) 

Observations In general, date processing is hard. The daily, and weekly schedules are managable, but the monthly and semi-monthly schedules require more smarts than what you have coded so far. It also requires more of a specification than what you have given. Should monthly be the first day of the month? Should it be the last? Should it be the 30th, except for Februaries where it should be the 28th, or 29th? Should it be the same day-of-month as today, but adjusted for february and other months if our day does not exist in those months? For the semi-monthly system there's the same problem. Your specification is too loose for us to go further with this implementation. 

Note, there are a few key items in there... (and also note, that you cannot describe all of the Java memory model in 7 bullet points). The first thing to note, though, is that there is a monitor, and that anyone who uses that monitor as a lock will have to wait for anyone else. In your code, you have: 

What that means, is that the average time to parse 2000 values using the regex is 1.20 milliseconds, and using the exception system is 2.56 milliseconds - more than twice as slow. Additionally the fastest parse is 1.03 milliseconds, vs. 2.31 - again more than twice as slow. Bottom line is that in Java (unlike Python), you should not use exceptions to handle data validation when you expect data to regularly be invalid.... 

That's what would be a successful insert. Even though thread 2 started first, it added after. But, what if the order was: 

The Java system will terminate when all non-Daemon threads stop. If your only non-Daemon thread is the Main thread (it is always non-Daemon), then the system will exit cleanly when the main thread ends. You can use this to your advantage in a number of ways... including having a terminating variable like which any thread can set to false, and the main thread will periodically check... (using a Selector and a ServerSocketChannel - an advanced concept) The bottom line is that you are not setting Daemon threads appropriately, and as a consequence, you need heavy-weight . Your ServerSocket management should be on the main thread too (or, it is possible, to make it on the only non-Daemon thread by spawning it from the Main thread, and letting the main thread exit normally). 

Then you should also support expanding any directory results from the chooser. This will make the behaviour in the GUI match the commandline more closely. A second problem is in the JTextArea display. It should have scroll-bars so that you can inspect the results before copying/pasting them. While looking at those changes, I discovered that you were doing all your File IO on the event-dispatch thread... this is bad practice.... I had to do the following: 

Note that you still have a synchronization vulnerability - the other column's column could be changed between checking for whether it's column is null, and using the column in the equals. You could still get null pointer exceptions if someone changes the other column in the middle of your equals. You should consider synchronizing on that other column too: 

There's no notion in the above of the internal implementation of the pool. That's a good thing. You use basic Go mechanisms like slices to aggregate functions to run, and you use basic go parameter manipulation to expand the slice for entry. I played around a bit, and settled on this function: 

The point here is that all the logic is contained in one place.... You will need to add a way to schedule the background runnable every ten minutes, or when needed. That should be easy, with an ExecutorService.... 

Now, when people use your class, they have access directly to the configuration too (with, and without your 'helper' methods). The bottom line though, is that your implementation does not enforce type-safety between the and the . The only thing it does is return null instead of throwing a ClassCastException when people use your code wrong. 

When I ran that test, it passed the password: which is 13 characters long, and the rules say the limit is 12. Checking your Regex, I see you mis-typed the range-limit on the match: Hate to be the bearer of bad news, but an interviewer could look at this as being an indication that you are not 'detail-oriented', and dismiss the application immediately. For what it's worth, I look at your code and feel it has a strong structure, a reusable and extensible model. Generally good. Perhaps overkill, but that's OK. But, bottom line, if your code does not meet the specification, you can expect to be moved down the pile of applicants ...... P.S. It also blew up on a null password, which I removed from my test because I did not think it was 'fair', but regardless, you should handle null input gracefully. 

Note that the loop in the above code will iterate only \$\log(count)\$ times where, which can be a significant saving in the event that is large, though the ArrayCopy is still an \$O(n)\$ operation, so it is a toss up as to whether it will improve the speed at all... it will need some benchmarking. 

What happens if there is an IOException part-way through the ? You end up overwriting the old copy, and losing the new one. Your data is gone. A more traditional way to prevent this sort of loss is to write the output to a new file, and then do an atomic 'move' operation: 

When you use a class in a 'hacky' way, like you do by using a PriorityQueue as a TreeSet, you should make sure that you document why the class is used, and what properties of the class are being leveraged. 

can be reduced to a single \$O(1)\$ operation using the math behind a Arithmetic Progression / sum-of-sequence This boils down to the fact that the sum of a sequence: $$ 1k + 2k + ... + (n-1)k + nk = \tfrac{n(1k + nk)}{2}. $$ The equation: $$ \tfrac{n(1k + nk)}{2} $$ can be rewritten as: $$ \tfrac{kn(1 + n)}{2} $$ Now, either \$n\$ or \$(1 + n)\$ is even, and any even number times any other even number, is even, so you can always safely halve it. Thus, the function can be reduced to: 

It is apparent that you have put some thought in to this implementation, and apart from the not-synchronized isEmpty() method, it all looks functional. I have some minor nit-picks though, and please bear in mind that these are just my opinion... I prefer to have the notifyAll method to be the last thing in a synchronized block, where possible... You have: 

a connection to a SQL Server database with that connection you from a complex join query with that record you create a couple of other prepared statements, one for the update, and another for a possible error condition. you then update the record's location with a new file location.... and at the same time also add an 'issue record' so that the record is not selected the next time through the loop. you then return to step 1. 

the value at this point plus the sum of all values above-left of us plus the sum of all values above us plus the sum of all values to the left. 

you have used generics it appears to all look functional it has advanced concepts (you have a double-linked list, not a single-linked list). 

it is not obvious why you loop 1-less time than you have characters in the code. Additionally, I am uncertain why the backward-direction loop is useful. Should be: 

Note: This review is based on the (apparently incorrect) assumption that the sequence in question is 'contiguous'. In other words, the 'right solutions' in the example: 

This is a case where a preset table of values will be helpful to test your conditions. Consider a structure which identifies what three buttons represent a winning condition: 

This would be a thread-safe class, and it has just one synchronization lock point (the class instance itself). There is no internal possibility of any deadlock, and it would be much better than what you have. There is a better solution though.... The problem with the above solution is that you expose the locking system in the instance and make it public. Anyone can do: 

There is a major bug/issue, and also stringing together three very different recommendations here. Bug/issue in the Game-Of-Life you are supposed to scan the entire board, and only then apply the changes. You are applying changes part-way through the process (as you check each cell, you change its state). So, if you change the cell in one location, when you check it's neighbour it will affect the results). You need to 'store' the counter for each cell until you have completed the scan, and then re-set each block in the board. Essentially you need the following: 

The advantage of doing things this way is that you don't run the risk of a bug where you forget to call . Note also that I added braces to your 1-liners. My experience suggests this makes for more reliable code when your code enters a maintenance cycle. 

This will operate in O(m log m) where m is the square-root of the input.... which will be really fast. Here's some code: 

Old question, new review.... I think, in general, I don't believe you are actually building anything better than what can be done with regular locking..... let me rephrase that to: the risk of spin-looping during an add is a significant drawback over regularly locked systems. So, while AtomicReferences may in fact be (marginally) faster than a ReentrantLock or a synchronization lock, the CPU cost of a spin while waiting for a 'slow' may in fact be significant. Another problem is that you may in fact be over-supplying new List instances. For example, you have to create a for every , but, if the current list is empty this is a waste. Also, it's a waste if the buffer is locked. This may add up to quite a lot of waste. While talking about this area of code, to get around Generic warnings, you should stop using and instead use the type-safe and generics-friendly (See the Javadoc). So, as an academic exercise, I think your code is reasonable, but unnecessarily cumbersome. I think a simpler lock will suffice, produce better looking code, and provides functionality that you may not even consider now (like a blocking that only returns when data is available) Bottom line is that I don't believe your solution will have a noticable gain over something more simple/traditional. Certainly your solution has a number of complicated and esoteric concepts.... the Mark-flag is challenging, and the spin-lock-wait process is inefficient. So consider this alternative: 

Then change each of your Enum values to also send the char it represents. If you do that, then your getChar() method becomes simply: