For access control use the groups instead of individual users. Create a group called public to which all users belong therefore any graphs assigned to public will be visible. Look to Role Based Access Control (RBAC) for more on this Each graph can be accessed by one or more groups, which allows you to have graphs that are visible to different cross sections of users (through groups). This means your access table will be graphid, groupid, edit, view with a unique key constraint on graphid and groupid. Answering the question can a user edit this graph will require a join from User_Group to Access table There is no special meaning for nulls, as none exist Handling users with no account is easier since no authentication is provided For the graphs, you need a graph table, and also a graphid added to the node and relation tables to simplify queries. 

I have placed the answer here since I was restricted by the size of the comment field. This is based on an approach initially suggested by @FrustratedWithFormsDesigner. I would recommend MySQL 5.5 from a cost/performance basis, but PostGresql would work as well (free license). The two step approach to loading the data is as follows: 

I would recommend the following approach: a) Each developer has their own database that they can work with, try out different things, destroy and restore at will independent of the other team members. b) Have a shared database instance for integration testing so that the whole team can see the shared progress at any one time c) Use windows authentication to speed up the connection process, and the devs do not have to remember new passwords, and easier to track and audit Of course all this depends on the size of the database and what resources are available on the test server. 

Go for the latest version of the MySQL Server that you can get, there have been some pretty impressive work done on 5.6 although the production ready version is 5.5 Go for InnoDB - comes as the default for the higher MySQL versions Configure InnoDB as follows: 

You can get that information from PHPMyAdmin by clicking the "Data Dictionary" link at the bottom of the list of tables in the database. I thought that PHPMyadmin would create an ERD or database documentation, but I cannot seem to find the link. However you can use MySQL workbench ($URL$ to generate an ERD by connecting to your database or from an SQL file export 

So in maintenance mode all we need to do is apply the changerequest.sql script during deployment to production 

a) An Entity-Attribute-Value model approach to tackle the attributes of the different devices to a device type. Each device type will have a list of attributes whose values you track b) For each device type, you track the inventory details by serial number which corresponds to a single device. 

My thinking is as follows: a) I would keep all person information in a single table whether they are customers or employees - including login information b) Create a customer table with a link to Person, and details of when they became a customer, when they stopped being a customer, and other customer specific information c) Create a table for employee to track employee related information d) Create a table employeebranch so that you track the start and end information for the employee in a branch, add a column for personid so that you can easily when the person was assigned to a branch, start and end date for the assignment to the branch e) In real life, a person may have different contact information as a customer or an employee - you can create a contact table, add a contact type - for person, customer and employee, start date and end date (addresses get invalidated) f) Create a table roles where the roles are defined g) Create a personroles table so that you can assign one or more roles to a person, this is irrespective of whether they are customers or employee (as the rules become more complex) it will make more sense - this is how Role Based Access (RBAC) works 

You can consider the web and mobile as just delivery interfaces to the functionality/services for your application. With this regard the backend functionality (server side - processing etc), should be the same for both interfaces, so yes they should have the same database. You may want to add data to identify the sources of data addition or changes or traffic, but essentially its the same app. UPDATE: Think of a mobile app just like a separate UI to be supported, I am not going to exhaust the possibilities but look at potential list of possible interfaces below: 

Use an after insert trigger on the invoices table to set the value of the invoice number once the row has been inserted successfully. This means that you do not have to do the computation in your PHP script, but in the database. 

MySQL Workbench does not have the capability to "infer" the relationships from table column names, or MyISAM tables. It requires that the constraints be defined in the database or SQL script being reverse engineered. 

The major reasons why you would use a one-to-one mapping to break a large table into two are for performance reasons for example: a) The table has binary/clob/blob data in a frequently accessed table hence slowing down performance since the large columns are handled differently. b) The table has many columns which are accessed by different queries, hence the performance is degraded therefore you would move related columns into a separate table to improve on access performance However having many integer columns does not justify the additional effort of breaking up the table into separate tables and having to query them. 

UPDATE: To cater for the computation of the room coefficients with dependence on the building in which the room is located To compute the different room coefficients you can have either: 

Through the tag cloud you show a category name but pass an id - show sport, but pass 101 TO get all the products in category sport SELECT * FROM db1 INNER JOIN db2 ON db2.pid = db1.id WHERE db2.catalog = 101 

Oracle is a Humvee, MySQL is a Camry or Prius, while SQL Server is a RAM truck (in between the two). However you can follow $URL$ for insights of an Oracle DBA to MySQl. Alot has changed over the past year but it still a good primer. 

MySQL views are a terrible solution to anything because they are VEERRYYY slow and also cause lots of issues during database backup and restores (due to @DEFINER keyword). You store the id of the current user in the application session session and always use it as a filter for any queries that are executed since its a foreign key in each table. 

How about making each of the elements of your XML a table or child-table and using in-built stored procedures to generate the XML from an SQL query result. This provides you with the data consistency and validation of the relational model plus additional database functionality with the ability to generate your XML document on the fly. If you need the XML documents handy you can create the equivalent of a "reporting" table into which the XML is stored ...