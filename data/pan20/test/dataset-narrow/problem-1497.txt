Boldly Go... First, I'll just say yes, it is a good idea to introduce things (let students see them) before they have to deal with them in detail. There is actually a Pedagogical Pattern, See Before Hear, that suggests that it is a good idea to let students see things before you even lecture on them. This isn't true about just syntax. The essence of the Spiral pedagogical pattern is that you teach things repeatedly to different levels of detail over a course and a curriculum. I'm pretty sure you would think it foolish if the first time the students hear the word "compiler" is when they need to build one. Research But to address the question of "Research" is a different issue. I think the kind of thing you might mean by research would likely be unethical. Educators, like doctors, have a "do no harm" directive. You can't run an experiment in education in which you even suspect that some technique might be worse than another, but apply the two techniques to two groups. You run the risk of doing harm to one group. You can only apply techniques that you believe to be best practice. The only kind of experiment that would be valid is to poll teachers on their practice and then either (a) ask them how their students do or (b) somehow measure their students actual performance. The first is just opinion based and the second is very difficult to arrange, partly because it can be disruptive to the educational process. Another reason why such research is usually not repeatable (hence basically invalid) is that there are too many variables in education: between teachers, students, environments, etc. An alternative: Patterns Patterns, are a kind of "experiment" in that they are a means to capture the practices of experts, vetted through a process (the patterns process) by other experts. The process is quite involved requiring many re-writes to have a pattern accepted. This is true of all patterns of course (design patterns, org patterns, etc.), not just pedagogical patterns. The pattern not only includes the what should be done but the why this is the right thing to do (resolution of forces). Another pedagogical pattern that pushes your syntax idea to the max is the Fixer Upper pattern in which you give students a fairly large program that (a) has good structure overall, but (b) you have broken in some well determined ways. The student task is to repair the program. This can be a first day exercise, in fact. The students first look at any syntax is a complete program that they need to work through. One of the reasons that this sort of thing "works" is that (a) much of what you want to teach them they may already know or will pick up instantly, but (b) which particular things that is differs for each person. Letting students see an organic whole lets each of them draw on his/her strengths in understanding it, leaving you only the task of filling in the holes as needed. Each person needs to learn different things from the class; not all the same thing. Another reason that the opposite thing does not work is that everyone learns differently. If you make the assumption that people learn by seeing or hearing something and then immediately "knowing" it you are treating the brain like a disk drive. I doesn't work that way. The brain works by reinforcement. So, if your teaching style is to teach everything only once and completely, then you guarantee that you will reach only a tiny fraction of your students, and many of those don't need the instruction anyway. 

One of the issues with new students is that they are likely to think at a very concrete level. To program effectively, just as to be good at math, students need to be able to understand and form abstractions. In other words the students need to start to think at a higher level so that the concrete detail can be largely ignored most of the time. But this only works if the abstractions are accurate and compose-able. So to follow up on the answer of user @nova let me suggest that using analogy and/or metaphor is a useful way to do this. In the specific case you mention (access to members of a collection) you can use your classroom itself as the collection and the names of the students as keys. Or, for arrays and such like you can "number the seats" and refer to "the student in seat 5" for example. Building nested structures is another thing you mentioned. Russian Nesting Dolls (Matryoshka) can be useful for this. Structures inside structures. A box full of boxes can be imagined. An "if" box inside a "while" box, for example. You could use a physical analogy, a projected image, or just "imagine a box full of other boxes that may contain yet more boxes." Lots of things so that the student gets a mental picture without looking at the concrete details of code. But, I'm guessing that you have mental pictures for most of the things you are trying to teach. Figure out a way to share them. Even more powerful is to suggest some metaphor or mental image and then ask the students for something similar in their "Own Words" (A Pedagogical Pattern). In hearing the answer you can get an idea of their level of comprehension and correct it or move on. 

Actually, what you want to do is commendable. And no, at the scale of things you talk about, I don't think you are likely to get yourself confused. In fact, you may have the opportunity to learn different things in an integrated way. In some ways the educational system, which puts different topics in different boxes, isn't optimal and everyone needs some experience in integrating what they know into a personal whole. I once learned quite a bit of French by reading Math papers from French mathematicians, though I was already pretty good at math, but you could, for example, read CS papers in Russian. Knowing something of the underlying ideas before you start lets you focus on how they are expressed in Russian, rather than Japanese or English. You already seem to be aware that you will need discipline and to set aside time for your studies. That works for nearly everyone. If you are studying several things then you can also switch to something else at a point at which you either get stuck on some idea, or get tired of the current topic. Often letting your mind work on something else is a good way to let your unconscious work out details that you might miss when working in a concentrated way. You should also be aware that you are now (age 20) at the height of your mental (as well as physical) powers. It is never too late to start, but you are starting at a good point. Onward. 

An alternative to code reviews, of course, is pair programming, where the need for reviews is lessened or eliminated. Two minds working together are stronger than than the two working separately it turns out when creating code. Code quality has been observed to improve and quantity (statistically speaking) doesn't go down by enough to overcome the quality issue. 

Just a couple of ideas here for an easy intro to Scala, though not very deep. Note that there is an online Java to Scala converter. The first idea is to translate (offline) something you are currently doing in Java into Scala and show it to them. The converter will make this trivial. They are already familiar with the code's structure. The second idea, assuming that you are doing something like Swing, is to use anonymous functions (lambda expressions) as listeners in some code your colleagues are already familiar with. The third is to use the fact that Scala does an even better job than Java 8 at pattern matching for typing functions. You could show them something that uses, say Consumers or BiConsumers and matches by structure rather than type names. Of course, you can already do this in modern Java too. But the above ideas build familiarity without inducing much confusion. The ideas are all in Java, but the syntax is a bit different. Then, if you have time and know the language well enough, you could develop some simple class from your own app in Scala directly, using pair programming. All you would need to do is get started, so if you run out of time things should still be fine. Here you can introduce a few things that are not the same as in Java. The earlier steps should ease the path to this step. 

I'll note in also that a statically typed language such as Java can do even better here, since the explicit declarations of the variable types, unavailable in Python and Ruby, makes it clear about what is a Strategy and what is not. In general, though a Strategy is very simple, a method or two, named for the task at hand. 

If the set of "allowable" topics is set by a ministry, then you have no power to do anything better, but it is misguided. Tinkering around the edges of an inadequate set will have some effect, but not a lot, I'm afraid. The problem is this. Students taught this way will solve math-y problems for quite a while before they see more interesting problems. They will build up strong reinforcement patterns that "this is the way we program". Then later, when given a difficult problem they will default to those patterns again and their solutions will look like C code even in more modern languages. One reason that this dominates is that the student has two problems, one is to decompose the problem somehow and the other is to put a solution together. If both problems are hard then they get lost. But if they have already built up strong reinforcement patterns on the second part they can use their mental energy on the first part. But since they "know how to program" (i.e. C) then they will just code it that way to minimize their overall effort. My preference is to turn it around (though recognizing that you may not have that opportunity), so that students think first about problems and how to decompose them (into objects in my case - OOP). Then they build up the reinforcement patterns on that, so it becomes "obvious" to them and they spend their effort on the coding part. The overall result is better programs, since they are more likely to have better problem decomposition into small parts that are more easily coded anyway. Note that I've seen the effect of this kind of learning in industrial practice. While consulting to IBM is was approached by a team member (an employee - and a good and smart one) who wanted me to look at his code. My practice was not to do that since my charter was to talk about higher level process, but he was a good kid so I consented. He showed me a bit of code (less than 2 pages) and started out by saying he could no longer understand it (his own code). It was written (Java) using the tools you describe above. The code was one method that consisted of some deeply nested structure that would be difficult to untangle. Factoring out helper methods (a la Procedural Programming) would be difficult. My first response was that I wouldn't have started out trying to write anything that looked in any way like that, and that by the time we got to the point of solving the particular problem the method attacked, we would already have a decomposition into parts that made the required (set of) methods quite trivial too write and to understand. The overall effect of what you propose is that you are, in the long run, reinforcing poor habits of thought. Or at least, poorer than the alternatives allow. That sounds like just opinion, I know, until you consider the effect of reinforcement and the tendency to fall back on what you know "best" which is often what you learned "first", since you've practiced it the longest time. tl;dr You are starting with the machine and with machine level solutions. Instead, start with problems and their decomposition. Assuming you can.