That's responsible for 102.2 seconds out of the 108.9 it takes. If you want to optimize, do it here. The rest is peanuts. Do you notice anything? You're wasting half a minute on handshakes. That's almost 30 seconds you could be doing something useful instead. Unless you find a trick to carry all files over one handshake, there's not much you can do about it. It also takes almost 60 seconds simply to (AKA: download) the data. That's only slightly more than I'd expect with my internet connection, so there's not much you can do about that either. 

Why is that called ? Only use if it has a meaning, like in a 3D graph as third axis. Here, it's a bad name. Might even want to drop the z entirely and simply return when is False. 

But it didn't improve readability a bit. I've also tried putting everything in a module and use more specialized functions. That got very messy, very fast. Anything and everything is up for review, including the design of the whole process. The current execution time of the program is low enough that I'm not worried, even for larger amounts of data. 

While reading your code I had one thought coming over and over: Get yourself acquainted with Object-Oriented Programming. Python allows you to build your own classes. Use that to your advantage. Why? It will remove constructions like: 

It's at the moment. But what if you want to support more or less characters? A different character set? You'd have to change those hard-coded values every time. 

I'm not certain whether adding shebangs is a standardized practice in libraries and their example usage. I suspect it's not for the former but is for the latter. Any input on this during a review would be great. 

5 authors. (That, by the way, is an unfortunate example of improper naming. An artefact of being inconsistent and lacking a thorough naming scheme, but irrelevant for the database.) The current idea is the program will deliver a list formatted like this: 

Python usually has basic functions like this already available to you. If it's already available in commonly used Python libraries, it's usually a good idea not to re-invent the wheel yourself. 

The following code transforms multi-line input into the the Brainfuck equivalent. One line turns into one program. The resulting programs are split by newlines for readability. Brainf.cpp 

While learning to play the keyboard, I find it helpful to write down the score of the pieces I play, regardless of whether a score already exists. The code is written using Frescobaldi as IDE and using LilyPond (docs) as format and engraving tool under the hood. The music is engraved to PDF and a MIDI file is generated. Writing music in LilyPond is somewhat similar to writing a book in LaTeX. I want to share one of the easier pieces. A shortened, simplified piano version of Morning Wood (Morgenstemning) by Edvard Grieg. Specifically, it's a 1:1 translation of the version provided by Flowkey (no affiliation). 

For starters there is only one , not three. And we don't need a comment to indicate it's because it's on the next line. It's like putting up an awfully big sign to indicate where your store is while the name of the store is also above the door and you're already at the entrance. Your other comments are doing pretty much the same thing. They point out the obvious. No point in keeping them around. This checks whether is : 

Naming is important. Try to avoid variable names like , and . and are widely accepted as iterators, so those are fine. 

Line 51 violates PEP8, but all alternatives I could think of wouldn't be any better. There's a couple of magic numbers in the code, notably , and , but since those are never going to change I'm not inclined to put them into pseudo-constants. The program is 'dumb', it doesn't remember much. So regardless of whether a number is divisible by 4, it will also check whether it's divisible by 2. It's written in a straight-forward way and can probably be written in a more generic manner. However, I couldn't figure out how without overly complicating the program. A smarter approach with a class containing all results would probably be better. Prime not needing it's own output method would probably be better too, but I couldn't figure out how to merge it into the dictionary I use for the other vulnerabilities. Since the player can't reach a level higher than 99, values above are invalid. Because 99 is a relatively small number, a cheap prime test has been used instead of a Sieve. Any and all feedback is appreciated. 

You're using in all functions except the top one. Why not declare it at the top of your file? You seem to have thought about readability. You're declaring variables for just that purpose here: 

The goal is to learn decent BASH. The FizzBuzz has no need for optimization, it's mostly about style, how data should be passed from script to script and whether I followed BASH-practices or not. 

is pretty straightforward. Two formats per row, newline at the end. The lines that don't need to be formatted (first and last) can be put on the screen using instead. To the best of my knowledge it isn't possible to put both statements in one printing statement, so I made it a function instead. Keeps things neat. My naming is probably horrible. As usual. 

This forces your to lower-case and checks whether the user wants to continue or not. This will also counter empty input. You can also easily expand on this. You're currently using the following variable names: 

Something along those lines. Note that is the preferred method of writing function names in Python. The moment you see so many , you know your code won't survive in the long run. It's not maintainable and not extensible. Classes are your friend. So what's the deal with ? is required if you want to modify a global variable inside a function's scope. You can read a variable without that keyword, but modifying it without one only modifies the local version of that variable. Basically, you're potentially shadowing variables with multiple versions of themselves depending on what local scope they're currently in. This means you'll have to declare your variable is in every function where you modify it. This could have it's cases in variables which aren't changed often, but I hope we can agree a is a variable which is supposed to change. Keeping up your current method of writing will lead to big lists of variables at the top of each function, which is among other things considered needless repetition. Simplified your code looks like this and it will only get worse: 

That's and having non-descriptive names. is input from the user. isn't a great name, but better than . Perhaps even or . could be named , , or something similar. 

You got a great project running, but it's far from finished. If you leave it in it's current state and take your mind of it for a couple of days, can you still understand what it's doing and why? How about multiple weeks? Lack of structure is how good projects die a silent death. 

First, the of the is too complex. You're doing something simple here, but it doesn't look simple. Make it look simple. If that means splitting it up, go for it. You're checking for a . Very good, but what can cause this error? Consider what the function will look like when you simply check whether before dividing. If you want to go the route anyway, consider what happens when taking the square root of a negative number, or the logarithm of zero: 

Where is the amount of spaces to print. Of-course you could extract this number to a which would make your code easier to maintain. That said, there are many things you could extract into and other variables for increased maintainability. Note we need to include for this to work. The following code has all the above implemented plus one inconsistency fix. I leave it as an exercise to the OP to find it. Inconsistencies in writing style can lead to confusing code in larger projects and should be avoided. 

was provided, as was the empty function (and no, it is not allowed to pass as an argument to the function). The required code is as straight-forward as it gets, but I feel there's a more proper way to do the string formatting. 

Naming Illegal names The following is quite important. Don't EVER name a variable or function after a built-in. It confuses everyone including (possibly, although you usually get away with it) the interpreter. 

Where first there's the title of the book, second there's the authors of the book and last there's the publishing year. Author names should be seperated by ampersand, any other character except an underscore will be considered part of an author's name. If the author of a book is unknown, it will be . If a publishing year is unknown, it will be . Books published before the year 1 anno Domini are not supported. If the file is not a PDF, it will be . Such files may or may not be a problem, but a list is kept. For example, a link may have been created instead of a copy, resulting in a instead of a . File names can be very long. Example: 

Basically, you're slowing down your code by checking the time. The generating of random numbers takes some time, but and are surprisingly fast. The real bottleneck? Your OPC connection. And I'm not sure whether this can be fixed at all in code. 

I'm not sure what you're trying to convey here. I am sure there should be a space between the hash and the rest of the comment for improved readability. 

Whitespace Indentation In Python, indentation is important. Forget to indent a line of code the proper amount and your code will do something different altogether (if it still does anything at all). To notice indentation problems, it helps if the indentation is enough to be easily noticeable but not so much that it will make the lines unnecessarily long. 4 spaces is good. If you prefer using tabs during programming, set your editor tabs-to-spaces with a tab length of 4. If you're not sure what editor to use, give Atom a go. Runs on everything. Blank lines The amount of blank lines between pieces of code help to see in just a glance where you are in the program. While not as important as indentation (blank lines, or vertical whitespace, won't make or break your program), every bit helps. Remember what I said about consistency? For example, between imports and the rest of your code there'll always be 2 blank lines. Between methods? A single blank line. Between global functions? 2 lines. Between class declaration and the first method? Zero lines. Operators All operators get spaces around them, except around the when assigning default values. After a comma there's always a space, but never more than one. So this: 

You're not interested in multiples of 10, you're interested in combinations of 20's and/or 50's. That all multiples of 10 from 40 and above happen to be valid combinations of 20's and 50's is irrelevant. If you'd fix your function to do what you want it to do, you no longer need your const. That name should probably be anyway, since the withdraw won't be made if the amount to withdraw is invalid. 

Note that since we don't return anything, a will do. Now you're reading all lines of data (up till every newline) and iterate over them, which appears to be what you want to do. Not only will this stop when the file has reached , it will also check whether the stream hasn't failed or took a bad chunk somewhere along the way. 

This part is an in an in an in a in a . Not only is that ugly, it's not idiomatic in most languages. The moment you go deeper than 3 levels you should be asking yourself if this is really the way you want to go. 

And all of a sudden, a black ring appears at coordinates 50, 50. Now, you can re-use your code without actually touching your old code. All you need to know is you can use the function from the file and what arguments it takes. Noticed the docstring on top of the function? It's there for (among others) exactly that reason. Telling your user (or future self) how to use the function. On default arguments: Default arguments (default parameter values) help with setting a default ring. If we 'just want a ring' and don't care about it's size and color, simply calling the function will do. They are the values used if no other values are provided. Basically, giving a default gives you the option of making that parameter optional instead of obligatory. If it's missing, the function will simply take it's default instead. Note: is probably your radius, diameter or a value derived from either of those. Renaming it to something more sensible would be beneficial. 

Make it work The code looks more like Python 3 than 2, so let's stick with that one for now. The main reason your code won't work in Python 3, is because of your statements. In 2, is an exotic statement. In 3, is a proper function. So let's make them all function calls. That's all! 

There. Done. I just threw out 50 lines of code. Instead of adding something to , you now add something to .Instead of adding something to , you now add something to . The following makes me think you really wanted to create a object instead: 

Globals in Python are not necessarily a bad thing, especially for what you're using them for. However, they can be prevented. There are a couple of major flaws I found so I'm glad you came over to get a review. The point you're most worried about will be handled at the end. Style Clean Python code adheres to PEP8, the general style guide for Python. Your code violates this guide in a couple of ways. I'll explain the violations I deem most important and fixed it up for you to show the difference. I do recommend you read PEP8 yourself as well. To verify whether your code adheres to the guide, you can either use the tool inside Python itself or pep8online. This will validate your code against most of the guide. Import Import statements should be on top of your file for maintainability purposes. This is a common practice in many languages, including C, C++, C# and Java. If I now skim your code, I'll see unexpected functions like because I didn't notice the following line: 

However, it's often preferred to include explicitly. If you use threads, include . Even if you don't have to because it's already included by another include or because your compiler sorted it out for you. If you refactor your code and removing one include suddenly breaks functions you didn't expect to break, you'll know you didn't include explicit enough. It's also a good overview for the next guy reading your code about what features are used. Including the same include twice won't matter for your program since the compiler will notice the include guards and only include every include once. The following function could use a better name: 

The mathematically inclined can probably tell us what such a sequence is called, but it should be obvious to the rest of us that the first 7 characters are always the same and only the 8th varies. Now, there's an achievement for lighting up all 8 dots within 60 seconds. Since it's already 128 clicks for lighting up the 8th one alone, I decided to automate the process using SCAR Divi (manual), an environment running Pascal scripts which allows you to automate keyboard presses and mouse movements. Code The resulting code is ugly, but I was mainly looking for fast code. This means it may not be up to par with Pascal-style and I took a short-cut wherever I thought it would influence the execution speed. I'm looking for improvements on readability wherever this does not hurt the performance in any way. I've written a fair bit of Pascal but I've always been a little fuzzy on what did and didn't impact performance. General tips about this are welcome. The most used procedure is , short for Move'n'Click. It moves the mouse to whatever coordinate you give it, clicks once with the left mouse-button and halts in between to give the rest of the computer time to catch up. Or whatever it does in that time, but it breaks terribly if it doesn't wait long enough. All values are hardcoded. I'm aware I can put them at the front of the program as global variables, but I wasn't sure whether the additional look-up would penalize performance. Current script manages to win in 21.86 seconds :-) virgilwBrain.scar 

The above is valid for all values above and up to and including . However, with the current data flow it's not possible to just lump the latest two statements together. There's a bit more work involved. Since the length of your statements is quite long, you could define functions for that instead. It would definitely increase the readability of your code. You could even make it generic enough so the function covers both cases. You could even pass the as an argument to that function and let it figure out what to print.