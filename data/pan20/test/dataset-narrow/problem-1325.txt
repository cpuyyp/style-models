I'm assuming that this is a platformer game and that your character collision shape is a rectangle. You didn't give enough information for me to definitively say what the problem is, but I can guess. Your character will look like he's sliding down the slope if you are applying gravity every frame and always project out the shortest intersection distance. Instead, you want to always move him up on the y axis. I drew a diagram that can explain my thoughts better than words: 

My current solution performs a binary search between the before and after positions until the length of the blue vector is known to a certain threshold. It works but it's a very expensive calculation since the collision between shapes needs to be recalculated every loop. Is there a simpler and/or more efficient way to find the contact point vector? 

If you decide to implement the networking code yourself, or if you're curious, you'll need to start learning about the best techniques. After lots of reading myself, I've found these guides to be a cut above the rest: 

There are several ways to solve the problem of objects that are larger than your tiles. Perhaps the easiest way is just to add the entity to every tile that it intersects with. Essentially the entity is in a wide range of tiles at any time. The is simple to implement but doesn't scale well for performance if your entities vary greatly in size. A more flexible solution would be to use hierarchical tiles, where you have several tile sizes, and you place entities into the set of tiles that best fits their size. This works well if you have a fixed number of different entity sizes. The most flexible solution would be a quadtree, which starts with very large tiles and recursively splits them so that they always fit the smallest object. I drew a diagram of some simple cases to illustrate the ideas. The green boxes are the tiles that the gray object would be added to in that tile structure. 

Just because it hasn't been mentioned. Since quaternions used for spatial orientation are always unit length (or should be), the following will also work. 

where EPS is some fudge factor to allow for small errors due to limited floating point precision. If (and only if) both quaternions represent the same orientation then , and thus . If you want to make sure they're the same rotation (rather than just orientation), then remove the . 

Where is force, should actually be an omega and is the rotation vector, is just a cross-product operator, and is the current velocity of the ball. is some kind of constant factor depending on what kind of surface the ball has and so on, that one you basically have to try different values and see which fits. The vector is pretty straight forward, just the direction and speed of the ball. (or omega) might seem unintuitive though, the magnitude is the rate of the spin (usually radians per second, but since we're multiplying with an arbitrary constant anyway, it might as well be RPM), and the direction is the axis around which the ball is rotating. To know which way is 'up', it's easiest to take your right hand and bend your fingers, the rotation is in the direction of your finger tips, and your thumb is basically the rotation vector. In 2D, birds-eye perspective, a counter clockwise rotation would have the rotational axis pointing into your eye (away from the ground). You don't really need 3D stuff (like the cross product), buts it's easier to work the stuff out on paper and use zero all but one of the components (like z) to reduce the formula. Also remember Newton, , but again, the is arbitrary, so we can just bake the mass into it, making . Where is the acceleration (vector). Birds-eye again, z pointing away from the ground (into your eye), x to the right, and y up the screen. 

($URL$ Now it makes sense to me why the origin can't be in region 4, since we just came from there. However, I can't think of any case where the origin would be in region 1 either. We just traveled from B to the origin, and if we didn't reach the origin, then we know there was no collision. So won't the origin always be in 2 or 3? Why does every algorithm always check whether the origin is in region 1? 

I discovered my answer. If the origin is in region 1, then it is a termination condition. It means that the origin isn't inside the Minkowski Difference, and therefore the shapes are not colliding. We just return the single point so that the next loop will terminate, and we can keep our support code general, without any special casing for exiting early. 

Instead of making full copies of every entity in the world, just save the entities and attributes that are relevant to what you want to lag compensate. For example, in a first person shooter, often the only thing to lag compensate are the bullet shots. To calculate whether a bullet hit, you only need to know, (a) the positions of other players and, (b) their hit boxes. That's all you should store in the history buffer. When you need to lag compensate, update the positions and hit boxes of the players, without touching anything else. Additionally, you can be intelligent about which entities you choose to lag compensate. If you know your skill has a maximum range of and players can move at a maximum speed of then don't bother lag compensating any entities farther than distance away, since you know that they won't be hit by the skill. P.S. I'm also working on an MMO that uses lag compensation. Just because it's not expected by MMO players doesn't mean we should deny them a good experience! WoW is over 7 years old now. 

If you add shear to your list (although rarely used in games), it is generally known in mathematics as an affine transformation. The general term 'transformation' has been mentioned already, is a usually considered a superset and includes projection transformations as well (which are not affine). 

This is a really broad topic, and I suppose the answer would be 'it depends'. I can recommend the book 'real time collision detection'. There are a lot of options, and they all have tradeoffs. My guess for easiest early out would be using a grid, then again, it's not very effective if you only have two large objects, in which case bounding volumes are a good choice. Only having two objects is kind of weird though, could you give us a scenario? (as it is, it smells a bit like a homework question) 

In order for an object to remain stationary in your field of view, it has to move directly towards you, or directly away from you. Incidentally, this is why mid-air collisions with airplanes are so nasty, our eyes are trained to see movement in our field of view, and an airplane on a collision course would remain stationary. Bit I digress. What you need to do is figure out the world space coordinates of the point 'under the cursor'. If you're just displaying a rectangle this should be fairly easy. If you're displaying a full 3D-scene, things get more complicated, and you need to figure out what you're actually pointing at. There are a number of ways to do this, but it would be more suitable for a separate question. Once you have the world space coordinates of the 'point under the cursor' you need to translate the camera along the vector from the camera to that point, note that this will be moving the camera sideways. Strictly speaking, when using a perspective transformation, a point on screen corresponds to an angle in world space, if you move along the track to the point, but do not turn the camera, the angle from the camera's forward-looking vector (center of the screen) and your target point will remain the same. 

I'm working on my first multiplayer game as well. It can be daunting just learning the problems specific to multiplayer, so I highly recommend that you get good at making single player ones first. First, see if any of the game/networking engines fit your needs. For an Android game especially, starting with a well-developed toolset is almost always a good idea. Here are some of the popular ones that I know of: 

The Separating Axis Theorem (SAT) makes it simple to determine the Minimum Translation Vector, i.e., the shortest vector that can separate two colliding objects. However, what I need is the vector that separates the objects along the vector that the penetrating object is moving (i.e. the contact point). I drew a picture to help clarify. There is one box, moving from the before to the after position. In its after position, it intersects the grey polygon. SAT can easily return the MTV, which is the red vector. I am looking to calculate the blue vector. 

Let's say you're creating a single-player game where you expect the player to go through 10 levels and get a new skill at the end of every level. In that case, you don't need a complicated system for managing skills. You could simply create a new class for each skill and hard code specific methods for each skill (e.g. , , ). On the other hand, let's say you're creating a multiplayer game with a release cycle of a new skill every week, and you expect to have hundreds of skills. In that case, you need an easy way to deliver new skill definitions to players, so XML or some binary format makes sense. Additionally, skills will likely share a lot of features, so a component-based entity system makes sense. The same logic applies for your question about the fireball skill and particle system. Is the fireball skill the only class that will be using particles? In that case, just hard code the relationship. If many skills will be using particles, then you may want to use a message passing system, so that any entity can request a particle to be created without needing a reference to the actual particle system object. You could use dependency injection if you expect to have multiple types of particle systems. There's no correct answer to code architecture, just a bunch of tradeoffs that you decide upon that best fits your game and development team. 

High school physics should do the trick here, preserve total energy (unless you want energy to dissipate into friction, heat and deformation) and preserve total momentum, which will give you the result of the impact. Adding rotation to the equation makes it a bit more tricky (although not so much in 2D), preserving angular momentum as well, do you want to go there? Actually getting the force which is applied, you need to look at the characteristics of the impact, the most simple assumption is that the force is constant during the impact, in which case, the force is the change in momentum (known as the impulse) divided by the duration of the impact. Do you really want to know the applied force (useful for damage models, but rarely for simple physics), or are you just looking to determine final velocities? 

here I've used as the spin (rate of rotation, positive being counter clockwise, denotes the unit vector in the z-direction). 

I think you need to go platform specific for this, SDL's SDL_GL_SwapBuffers (i think it's called) will wait for retrace before swapping. If you specify your platform, there might be more we can help you with. HTH. A quick google turned up this: $URL$ search the page for 'retrace' and you'll see it. 

One way that I've found helps alleviate this problem in platforming games is to prioritize which axis gets checked first in your SAT algorithm. For example, even though the x distance is shorter than the y distance, you can adjust your algorithm to always push on the y axis first. That way, even when your character is standing over the edge of a platform, he gets pushed upwards. Performing multiple collision tests between the start and end positions is a fine solution if you're not having any performance issues. You can optimize it somewhat by moving the maximum distance you can get away with instead of a single pixel at the time. For example if your shape is a circle with radius 40, then moving 20 pixels at a time would work (half the radius so you don't go through thin objects). If you want a more robust and faster solution, then you should use a continuous collision detection algorithm. Instead of intersecting with objects and then correcting, a continuous algorithm takes velocity into account and determines the time of impact, which you can then you to position the object where it needs to be. It's actually not too difficult to implement continuous collision detection using SAT (assuming no rotation). The algorithm that you're using probably has you moving the object, then checking for collisions on multiple axes by searching for overlapping ranges. To modify this to be continuous, don't move the object first. Instead, you can calculate collision time on multiple axes by finding the distance between the closest points on each axis and dividing by the speed that the object is moving (on that axis). The minimum time will be the time of impact for the object, and if it's less than zero, then the objects are already colliding.