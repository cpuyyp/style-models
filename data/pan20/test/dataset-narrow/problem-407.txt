Now it seems to work. The fact that this code has several easy-to-spot bugs(especially the fact that any constructor call throws) makes me think that you haven't tested this code. I'd recommend picking a habit of using unit-tests. It is a good practice to always test code in an organized, systematic manner. Now let's switch to the design of this class. 

The answer to a is , where is the number of occurrences of a char between and inclusively(it can be done in time with preprocessing using prefix sums). Why does this formula work? We can take all string that end before . Now we need to subtract the number of strings that end before . We also should subtract the number of such strings that start before but end between and . 

The API of your class: in my opinion, there should be one more method: that returns the minimum element but not removes it. The only way to get it now without deleting is to call and then re-insert it into the heap, which is inconvenient and inefficient. There is a bug in the method. The fact that is less than does not imply that . It can lead to a . I have written a simple unit test that exposes the problem: 

The smallest divisor of any natural number greater than two is a prime. Let's assume that it is not the case and , where is the smallest divisor of . But then and is a divisor of . Thus, is not the smallest one. This statement also shows why your original solution is correct, even though the list is contains some composite numbers. Any composite number has a divisor that does not exceed its square root. The proof by contradiction is very straightforward so I will omit it. 

It's correct, but it's ineffiecent. It uses time in the worst case (for instance, if the input's ). You can do better than that by iterating over the input string and keeping a stack of brackets, pushing opening brackets to it and popping when you encounter closign brackets, checking that it's not empty and that the top bracket matches the current one. 

In my opinion, there are also too many blank lines inside methods in your code. Comments: you should try to write self-documenting code. That is, if you have to write comments inside methods, it usually(but not always) means that the code itself is not clear enough(probably a particular part should have been in a separate method) or the comment is just redundant. At the same time, you should write very detailed comments for all public classes and methods(in particular, they should say what a method does, what each parameter stands for, what exception can be thrown, what it returns). Design: one class should do one thing. That is, I would make two separate classes here: one for the GUI and the other one for the game logic. Moreover, comments in your code(like before a bunch of fields) indicate that there are two loosely related group of fields, which makes this class a good candidate for splitting it into two or more separate classes. The same is true for methods: if you have several loosely related blocks of code inside one method, it is a good candidate for making several smaller methods. One method should do one thing. 

The name here: is misleading. This variable represent just one neighbor at a time. I don't see why would you make it plural. 

can be simplified to unless you're using an older Java version. If you plan to work with large files (really large, such that their content doesn't fit into main memory), you'll need to get rid of reading the entire file into a . A more space-efficient solution would be to read it in chunks and process them separately (the words are normally short, so it can save a lot of memory). Sure, it makes the code more complicated (for instance, you'll need to carefully check when the word ends), so it's worth doing only if you plan to work with large amounts of data. A method name is normally a verb. doesn't sound very good to me. I'd rename it to something like . I'd also put cleaning one word into a separate method to make it more manageable. You can go even further and put all cleaning stuff into a separate class to increase the flexibility (it also makes sense from a design point of view: cleaning and counting are different responsibilities and they are pretty much independent). The way you work with the output file is potentially dangerous: if such a file already exists, it'll be overwritten. I don't think that doing it silently is a good idea. There're a few different ways to deal with it: generating a different unique name, aborting the program or letting the user choose the output file. Either of them is better than replacing the content of the file silently. 

You use of whitespace is inconsistent. For instance, there's a space after the name of the function, but there's none after the name of the function. Whatever style you choose, you should always be consistent with it (according to the PEP standard, there should be no space after the function name, but there should be one after the comma. I would stick to it unless I have compelling reasons not to). It's also a good practice to write doc comments for all your functions and classes. The comments inside the code should be more about telling why the code does what it does or why a specific design decision was made. Redundant comments that just tell what the code does create noise and actually make it less readable. For instance, this comment is self-evident: 

This way, you main method would just read the input, call these methods and print the result. It would make your code more readable and testable (you would be able to test your methods separately) The comments should explain what the code does and why it does what it does. They shouldn't describe how it works. That is, it's a good idea to create a doc comment for each method saying what it does, how it behaves if it gets an incorrect input and so on. Conversely, comments like or actually harm the readability. They just create noise. They don't add anything useful to the code itself. Writing self-documenting code is a good practice (that is, ideally it should be clear what your code does from the code itself). doesn't sound like a good class name to me. I'd rather call it a (it's conventional to name classes with nouns and methods with verbs). The message looks kind of strange. I think it should say that it requests the user's height (it's not clear from the message itself). It's fine to keep the height as an , but I would show a message to the user saying that. Otherwise, they may get an unexpected error. You could also add some kind of input validation and error handling so that your program doesn't fail with an exception (it might be confusing for the user) but rather prints a more suitable message and possible prompts the user again. 

Variable naming. It's conventional for the names of variables to start with a lowercase letter. Moreover, a doesn't look like a good name for a matrix to me. It's confusing. You could call , for instance. Code formatting. It's conventional to surround binary operators with whitespaces. The opening curling bracket shouldn't go to the next line according to the Java coding conventions. It is also common to use , not C-style in Java (it has the same semantics, though). You could also get rid of redundant variables and assignments (I'm not talking about performance, I' talking about communicating your intent as clearly as possible): 

I'd use the method here. You can avoid using the queue altogether. You can keep the leftmost index of the current "window" and the set instead. 

usually indicate that this block of code should have been a separate function(in this case, as I have mentioned before, there should probably be another class that implements this data structure). In general, you should try to write self-documenting code. Spacing and indentation: separating different functions with an empty line makes the code more readable. 

to make your code more concise. Prefer interfaces to concrete implementations. That is, use instead of unless you need some specific features of the latter. Passing strings around as node identifiers make the code less understandable. I'd recommend creating a separate class. 

. That's wrong. It returns a dangling reference. You can't return an rvalue reference to a temporary object. Return it by value. It doesn't change the , so it would be better to pass it by a const reference. The same is true for . It's also broken because it returns a reference to a temporary object. . Once again, if you don't change the input objects, pass them by a const reference. You can also simplify this function using function with a custom predicate. This piece of code is a little bit confusing: 

The product of the salary and the tax rate has two digits after the decimal point. So does the quotient. The method is unnecessarily long and complicated. You're trying to find the largest entry in a such that is less than the given value. That's exactly what the lower method does. Printing something inside the method is a bad idea. It makes the code less reusable (what if I want to just calculate the tax without any logging?). And violates the single responsibility principle (it calculates the tax and prints something to standard output). This kind of comments: 

In the constructor, is allocated: . However, it is never deleted. You can do it in a destructor. The same is true for the array(you should delete it at the end of the and member-functions). 

It's not about constant optimizations. It's all about a more efficient algorithm. Here is a simple observation: the given graph is always a tree(because it has exactly edges)(if it is not a tree, it is not connected and it is not clear what the answer is(maybe +infinity), so I will assume that it is a tree). That's why we can use the following algorithm: 

You can use a more efficient algorithm. It's clear that the unique value is equal to the xor of all numbers in the vector. One can write a nice one-liner to compute it: 

Taking into account that it requires that an element is present in the graph, we could simply write it as . And here: 

All GUI updates must be performed on the GUI thread. But you create new GUI elements in the method of the , which runs on the main thread. It is not correct. You should use the method and a (possibly with a lambda expression) instead. It looks like there is no need for multiple timers here. One timer(with the shortest delay) can do fine(it just requires small changes in the event listener). Overall design: the class knows to much about the internals of the and the . It seems to me that intersection methods should belong to the class and bounds checks should be in the class. You code also violates the single responsibility principle: the game logic is tightly coupled with the GUI. I'd recommend creating separate classes for performing computations and rendering the game. Variables names. There is no need to make them so short. Keep them descriptive. For example, this piece of code: 

would be nice (otherwise, the user might not which file this message refers to). In the function, you don't need to compare anything to one: . contains boolean values. You can use it directly like . Functions and methods are usually named with a verb. The doesn't sound like a good function name to me (moreover, it provides little information what it actually does). I'd suggest calling it like or . You code is lacking proper documentation. Your comments are quite terse and they don't make it clear what a specific function does. I'd suggest writing proper doc comments for all functions in your code to make it easy to see what each function is supposed to do and be more specific about it (for instance, if a function reads all files in a directory and loads the data, it would be reasonable to write what kind of input format it can handle and what it does if it fails to work with a file). Your specification also says that the application is supposed to handle new data. I don't see that functionality in your code (as I can see, it just reads all the data in bulk and combines it before processing the data). You could also make you system more flexible by trying different ways of outlier detection (at very least, you could make your filtering function take and as arguments). 

is not good. It requires writing additional comments instead of storing all the information in the code itself: 

Whitespaces. It is conventional to have a whitespace after , and keywords, before and after curly brackets. Variable naming. Non-static, non-final variables' names should start with a lowercase letter(and different words are separated using camelCase). It is not consistent in your code: , for instance, follows this convention, but or violates it. Design of your class. Having one huge method that does everything is a bad practice. Moreover, the entire class does too many things: it handles GUI and the conversion logic at the same time. I would recommend creating a separate utility class that converts speed units into each other. Current design makes your code very hard to test. Avoiding code duplication. Several event listeners contain the same code: 

The time complexity is the same (as a hash table works in on average), but this code is likely to work faster in practice. It also requires extra memory, while your solution needs , so it's more space efficient. I'd also say that your code is little bit confusing (it inserts keys implicitly via operator but erases them explicitly). It took me a while to figure out what's going on. I think that the solution with a set is a little bit more clear as it makes all insertions and deletions explicitly: 

An array of 1 million booleans is not that large(1 boolean takes one 1 byte, so it occupies about 1 MB of memory). Using a may save some memory, but it is not necessary under given constraints. I'd recommend formatting the code properly to improve readability. It is conventional to surround binary operators with whitespaces. Take a look at this piece of code: 

This solution requires only two breadth-first searches so it has a linear time complexity. Why is it correct? I will not post a formal proof here, but drawing several trees on paper should help you to understand it. It is important that a given graph is a tree(this algorithm does not work for arbitrary graphs). This algorithm actually finds a diameter of a tree, but it is easy to solve the original problem when a diameter is found. We can just pick the center of the diameter. To do it, we can find the path from to (it requires a small modification in bfs: we also need to keep track of a parent for each vertex) and store in a list. After that we just need to get the middle element of the list. If the number of elements in the list is even, we can pick any of two middle elements. 

I will start with refactoring the class. I will override the method and the method from the interface(I will also rename and to and ). 

,isn't it? A loop in the method looks strange. When the number of iterations is known beforehand, using a loop makes your intentions more clear. 

I think that intersection methods should belong to the class. A rule of thumb: if you need to write comments inside a method to clarify what's going on, you can either rename variables or extract a method instead. The code should be self-documenting. As I have said above, it is often(not always) a smell to have comments inside a method. However, it is a good practice to write comments for all public classes and methods(which explain what they do, not how). Do not make fields unless it is really necessary. For instance, the field of the class does not look like a good candidate to be . It belongs to an instance, not to a class(what happens if you create more than instance?). Avoid "generic" names for your methods. For example, does not tell much about what the method does. The questions is: move where? The same is true for fields. Use consistent indentation: always have one whitespace before an opening curly bracket. 

I don't get the point of returning the from the function. The return value is never used (and the which is passed as an argument is modified in place). The functions prints the , doesn't return anything and then it's returned value is printed: . There're two reasonable options here: 

is kind of useless. There's , which does the same thing. You can make the design more flexible (and more standard library-like) by passing an output iterator to the and function instead of creating a new container inside the function. It's useful if the user wants to write pairs that represent groups to an existing container or to a C-style array.