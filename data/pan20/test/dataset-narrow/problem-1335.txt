So I'm doing something wrong, its probably not much since the result is not completely off, however, I cannot figure out what I'm doing wrong. TL;DR: Am I either misunderstanding how the Algorithm works, or if not, what am I missing or doing wrong in my code? 

I have trouble while detecting collisions on my 3D-Game. I have set-up Rays, to detect collisions (Screenshot) and my main-rountine already analyzes them. But now there's the question what to do with that. One possibility would be, to move the player back to the last position, but that's dirty, and does not work if the player can walk in multiple directions (e.g. if the player runs along a wall). My question is, what to do with the collision data / or in which direction, by which amount move the player? I'm sure there is an algorithm for that (as for almost all is). 

It depends if you are walking on it or flying over it. i.e. collision frequency. also it depends if your cubes are squares like minecraft, which makes it easy. You have to make some kind of mesh collider, or some triangles around the point of collision. Normally your program should have a way of making a mesh collider. For advanced coders, and specific kinds of projects, you can use the perlin noise function to see how close an object is to a the terrain boundary. the isovalue is a guide for collision. as a rough guide, the cheapest way to check collision is ISO value of noise, you can find a value, say >4 which is very far from the 0 isometric value, and only objects with a diamter larger than 20 say, could reach it. so first check the isovalue of the objects or of their boundaries. if they are within a few meters of the boundary, have a 3d array of all the cubes in space, only a few of which will have triangles precomputed in them... fill that array when the cubes compute, and when necessary, you can check exact cubes that can collide using that array, very fast also. then you can construct a dynamic collider using this array because you can access all triangles positions that you need instantly. also there is the bullet physics engine under zlib licence. 

The result should be: 1 blue group (all hex's connect) 3 green groups 1 black group Any suggestions? Thank you. 

For this post, we'll assume my game is multiplayer chess as it essentially requires the same functions. User logs in to the server and requests a game - the server provides a simple matching service and once done, they start the game. They get 30 seconds timed by the server per turn with 6 players in each game and however many spectators (probably very limited). I would like to know how you would scale this. I've considered two options: Option 1 1) Main server to handle login / match making (which regardless of user numbers should be a fairly easy task) 2) Start new Node servers for each game that close when the game ends. I'm not entirely sure how this could be implemented yet. (i.e. would the user connect to the main server still and the requests just be passed to the new server or would the user change connection to the new server and then back again when done? changing connection would reduce the load even further and as the two servers won't require communication between them, should be fairly simple) Option 2 Have 1 Node server and somehow scale it. -- Suggestions / input? I'm planning on hosting on Amazon AWS and am well aware that the chances of my game even warranting this level of detail are probably nil but I'm taking this as a learning opportunity. Thanks. 

But that runs painfully slow (I guess because the atomic operations aren't very well for parallel processing). So what would be the best / fastest way to do this? 

I want to filter my shadow map generated by PSSM, but the problem is that I have a inconsistent filter size. The problem is that the shadow map sources rotate to find the best fit for the camera frustum, and thus sampling with a constant offset (e.g. 10.0 / resolution) produces inconsistent results. A gif shows it probably best (same shadow and sun position, just different view angles): GIF showing the issue My idea was to, instead of using a fixed filter offset, compute the filter offset by projecting 2 world-space points to light-space and taking the difference of both, like this: 

The game servers wait using BRPOP for new games. When they get one, they wait until the game has a minimum of 2 users then start a timer. If they don't fill up in that time, they begin with the users they have and subsequently remove game:queue:small:id (thus forcing the matchmaker to request a new game). Whilst my method is working, I'm not convinced it will work well in production and it seems very convoluted. I can see the potential for the following issues: 

I'm using Node.js and Redis. I'm trying to come up with a reliable way to automatch players. There is a matching server and then multiple game servers set up. The following is what I need to have happen: 

I think a sprite is a multipicture where you change the frame you want, it will have an alpha as part of the bitmap... the sprite class isnt really for inanimate ground images. in unity, colliders i think should be part of a 2d mesh, mesh renderer, and you can apply the bitmap to the mesh. 

to make blue lines via shader, you need to have the texture_uv in the surface function, or in the fract function... to make blue/grey grid lines in shaderlab, you have to add a total of 4-5 lines to the shader, inside the surf function: xline = ceil(frac(uv.x*.1)-.75); yline = same for y grid = max(xline,yline); o.albedo.blueval = grid. then you can change yoru grid size using 1 call to the shader, to change the shader value, .l makes a 10 meter grid, change that value to ajust grid size, .75 makes a grid 3/4 of the area of the screen. then tweak the color adding maths to the same that was used on the previous version /splatmap. 

First of all, if the line is commented, the compiler can most likely optimize out the loop, which is why the shader runs faster then. You have a lot of branches (/) in your shader, which is most likely your performance issue. Branching (especially on mobile devices) is something you generally want to avoid. If your uniforms (hue and offsets) do not change very often, you might consider hardcoding them into the shader (i.e. regenerate the shader whenever they change). I am not sure about the method, but it looks rather vectorized, which is why it might perform fast enough. Your however is full of branches, which will most likely be the performance bottleneck. You might want to consider generating a 3D-LUT on the CPU side, and then sample that in your shader. That will most likely be faster than evaluating all those branches. 

Player sends join request with game type (small/medium etc) Matching server adds player to the current game type that is waiting for players Game server sends player the game ID 

If you call the old image again later, this is fine as the images are cached by Corona. Secondly, you can use an image sheet: 

I'm using Lua. I have a hex map. It is randomly generated into an table. hexmap[y][x].color = "red" I wish to find each "group" of hex's. i.e. all hex's of the same color that connect to each other will belong to one group. As an example, in the following image: 

How does an SM5 compilation handle loops and if-else statements, are branching execution routines unwound and if so, to what degree? Is it only Direct Compute that can optimize branching code? searchwords: dx11, shadermodel5, 

The lightmap shouldnt be dissasociated from the vertex information. if the vertices are lined up to display no cracks and no rounding errors coming from the CPU (i.e. object positions + vertex positions interpolation) they they won't let anything through, the edges have to be aligned and no triangle intersections. If the mesh doesnt have cracks, nothing will. 

My initial thoughts were to change to a single queue of users waiting for one game type. However, this presents further issues: 

This allows you to pull images from an efficiently packed image sheet. I must admit I don't fully understand what you are trying to accomplish. There is no reason you should be struggling with this and storyboard. Perhaps post a few more details with the specific problem. As a side note, you should try and use newImageRect as this allows for scaling: $URL$ 

Matching server listens to game:queue:small using BRPOP Checks if game:queue:small:id = id exists Checks if game:id:users length is <= 6 (max players) Adds player to game:id:users list if it is If game length is now 6, it removes game:queue:small:id 

here is some code for any number of equally spaced vertices of a sphere, its like an orange peel it winds a line of dots around a sphere in a spiral. afterwards, how you join the vertices is up to you. you can use neighbour dots in the loop as 2 of each triangle and then find the third would be a proportional one twist around the sphere higher up or lower down... you can also do triangles by loop and nearest neighbour on it, does someone know a better way?