Oracle Recommended Patches (PSU) for Enterprise Manager Base Platform (All Releases) (Doc ID 822485.1) There is no PSU released for 12.1.0.5 yet. 

Comparing apples to oranges. The 2 queries and the results they return are not the same. First query retrieves 999 rows from + , joins to and sorts the result. The result of the 3 table join can be 999 rows or 10 million rows as well, depending on the data. If it is 10 million, it has to sort 10 million rows. Second query retrieves 999 rows from + and sorts them right after. Finally joins the , and does not sort the final result. The first query sorts everything, the seconds query sorts only the result of the subquery. Sorting 10 million rows will most likely need more resources+time than sorting 999 rows. The cost of sorting is often overlooked. The first query returns a sorted resultset, but for the second query, there is no guarantee of returning a sorted result. The second query may return inconsistent results between different database versions because of how the optimizer works in different versions. For example if column is indexed, the optimizer may choose to access the table using the index, and returns the first 999 rows sorted anyway, because data is already sorted in the index. Or it may choose to scan the table, get whatever 999 rows it can, then sort that. This can be easily tested with a hints such as: and providing different versions. The first query is guaranteed to return the same result on all versions, as long as the data is organized the same way. As there is no criteria specified for getting the first 999 rows (first, based on what?), after reorganizing the table (move, shrink, export/import, redefinition), it may also return different results for the same base data. In this aspect, both queries are inaccurate, unless you do not care about consistent results - which is a quite rare situation. 

I'm attempting to display the same number of invoices that have the same number of days between two specific dates (e.g. issuance date and payment date). I can ascertain a segment of the aforementioned with the following query: 

Here is a screenshot of output for clarification: My second attempt is closer to the expected result, sans "DESCRIPTION" column, necessitating the JOIN clause; I've also included the query and output below: 

Evidently, this is how you copy tables from databases with permissions via remote connection to a local file-folder on Oracle SQL Developer (Mac OS X Yosemite): 

So essentially, I'm attempting to display the average NUMERIC_GRADE for the correspondingly grouped category types (i.e. Participation = avg percentage) but my attempts invariably return errors (not sure why). I believe my logic is directionally correct, albeit flawed; could someone please advise? Thank you! 

N00b question here: I'm still learning Oracle SQL Developer. Although I understand how to query databases/tables remotely, I'm unable to manipulate the data due to permissions-basically I would like to download/export copies of the databases/tables so I can manipulate or adjust the data within the table. I'm running Oracle SQL Developer on Mac OS X Yosemite and I'm unable to place a copy of the original table in my table space. I've consulted Oracle dox, but I believe these are dated because the GUI isn't as described. I'd appreciate any assistance. Thank you. 

The problem with that: you can not grant password protected roles to another role. See $URL$ for details. 

A basic overview of feature availability for different database editions: Products and Services - Database - Enterprise Edition - Comparisons Java is not available in Express Edition. 

TNS Ping does not care about service or SID, all it checks is the availability of the listener, so this does not mean your connection string is correct. Connecting through SQL*Plus successfully however confirms it. Your tnsnames.ora uses SERVICE_NAME in CONNECT_DATA, but your JDBC URL uses the SID syntax. SID and service name are different concepts, and their value can be different. In your case, you can connect with CMSQA provided as service name, but not as SID. In this syntax, CMSQA means SID: 

So far so good, works like a charm. Now let's say I have a TNS entry pointing to another service, that does not exist, for example: 

Notice how the optimizer completetely eliminated the DISTINCTs in the first and second queries, but not the GROUP BYs. Unfortunately in these cases, since the DISTINCT elimination happens in subqueries ("views"), this information is not present in the optimizer trace, just like for the original queries in the question. So now we know that DISTINCT and GROUP BY are handled indeed differently, lets go back to question 1. To be continued in the next post... (Both answers together exceed the 30000 characters limit.) 

This is an interesting question, and I have a similar one in myself. It is my belief that in certain situations, multiple files per file group can help with performance depending on your hardware configuration (number of cores) and physical I/O design (the files can be distributed across multiple drives) Although of course you will be using SSDs in Raid 10 configuration for the production data drive(s), and have a ton of server memory, so that the majority of pages are being read from disk. With that hardware I'm not sure how much the physical design will matter. 

I am going to suggest an alternate solution. Rather than trying to mock-up a database design in Visio, why don't you create the database design in the relational database? Once that is complete you can use software to create the database diagram from your actual database. Most relational databases have database diagrams built in, and if the built in diagrams don't fit your needs there are a variety of third-party alternatives, many of them free, or with trial periods. The advantages to this approach is that doing the actual design will help you think through your choices, and even if it doesn't end up being the final design, you can use the work as a starting point. 

I would try persisting the computed column. If you do this the cost of computing the column will be incurred on writes, persisted, and then it won't slow down reads.