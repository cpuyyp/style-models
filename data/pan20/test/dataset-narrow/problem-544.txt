I don't think you should have constructors that don't take a as parameter. It doesn't have any value since this way the won't be able to operate. If I want a machine that'll execute 0 operations, I'll pass an empty . You should specify visibility modifier for your class members, at least I think. We could argue that since the default value is private and that considering OOP members should always be private this wouldn't matter, but I think it would add to the readability! In your method you could use instead of 

That's a simple example I made that could work out well in your code. We use a Dictionary to hold which to call when given a certain . Now, each way to build an URL has its own method, most of them are one-liners. This way, you don't have the in your code, and if you happen to have more ways to build URL your switch wouldn't grow in complexity! (But you'd have more methods, solution incoming!) You could argue that I'm just moving the problem. You don't have an high complexity now, but you have more methods in your class. You could move these methods to a that would help to build URLs. And if that ever becomes a problem, you could use inheritance to have multiple instance of.. . These are the solutions to deal with your high cyclomatic complexity. Finally, as said @Heslacher, if we knew what is inside the method, we could rework it to use something like instead of using a loop to join your ports. 

You will realize that both the options are, excuse me, useless. The language already supports this behavior and if is a , will simply return all the time. 

Are useless in code. They should be in a product backlog or something like that (An issue on your Github, a note on a napkin on the side of your desk). Keep as little comments as necessary. But I understand, right now, that it means this code might not need to be reviewed as it will change. Don't use brackets when it's not necessary like here : 

shouldn't exist. It's not clear what the function is used for. We're used to the syntax and you should keep these separated. That method has too many responsibilities : Check if it's null, check if there's something then filter. is fine. It's exactly as for the . But in that case, you don't check if the enumerable is . You'll get a in such a case. Also, I don't think it's useful for this method's return type to be anything else than . But well, it could be a weird case of fluent API! and are alright! Why doesn't use ? If it's to "rebuild" the LINQ extensions, you should consider not to use any of the LINQ's extension methods to learn better! (Using and check if there's an element would be a good other solution) with a has a side effect you probably do not expect. 

Since your cache will be used application-wide, I think it should be thread-safe because otherwise the state of your cache might change halfway through an operation. To do this, add the keyword to your method signature. (I've never done thread-safety in java, only c#, so I might be a little off on the best practices about that in java.) Also, the method named might add an object into the cache, but it is impossible to know this without first checking the source code. I don't think a single method to do and is a good idea. Why not split in 2 different methods? This cache implementation is not generic. Imagine I want to use your cache in my application, I wouldn't be able to do it since my classes wouldn't be part of your ,,. Throwing isn't a good idea. You might want to create a custom exception like . 

First of all, you really need to space that code, it is hard to read when there's no space. Also, because of the block, the indentation is messing with my eyes. Try to keep it in one line, it would be easier to read, even if it is a little long line. Appending strings together is never a good idea, it is heavy in terms of performance. You should use a StringBuilder. In fact, why do you keep the string? It doesn't seem to be used anywhere. You should remove this line as it might be expensive on large files. Also, I don't think you should catch the . How do I know what happened if is returned. Was it the file that was locked, non-existant, was there no in the script? Let the exception be, so people can catch it and do whatever they want with it. Catching it now seems irrelevant to me. 

I ran benchmarks of this class versus an "assignator" that uses reflection and mine quickly becomes much faster, which is good. But for sure, if something could be made faster, that'd be great. 

I've written this infix to postfix converter using this website as an helper. At the end of the web page, there is the procedure for the algorithm. 

I would change to , it is way more clear what your property is in charge of. Finally, I don't think you should have braces around one liners if it is to put them on the same line as your code. What I mean is either do this : 

Otherwise, there's some good stuff in there, you've done a good job for a first little application :) 

Boom, you now have a common place to get all your factories. You'll have to add lots of though, as the time passes. We could fix this by changing our interface, which would change some things in the structure of our program, but this solution also has drawbacks. I'll show it to you anyway, so you can decide which fits your need better. So if our was instead : (Note : While typing, I realized that should be named . After all, you already know you're about to create a problem since the return type is ) 

I think all the comments should be removed. The point of a comment is to explain why you wrote this code, not what the code does. If anyone reads the code, they will be able to understand what it does without reading the comments. When you write comments, always ask yourself : "Will this comment help me understand why I wrote this code 5 years ago?" (Or.. 2 weeks if you have a bad memory like mine), if you can't answer, you probably don't need comments! The formatting looks perfect in my opinion. 

In your class you expose a public field, which is a , you shouldn't do that. Instead you should expose a read-only property interface (Like or ) and initialize this property in your constructor. 

If we quickly work with this, we get . Doing this will remove the need for the method, since is dependent on and . Meaning we just removed one loop from your code. Now, still following the original problem, we know that . So, in the nested loops, we could make increment until we reach b's value! 

You now have 3 classes, one interface which define your responsability. In the class that has the method, you can add a then loop through the validations in order to verify them all. You won't have more than one condition, and it will be easy to add other implementation of the interface. 

Notice that the method is now , since it's an helper method. You'll be able to use it in any context, which is great! I changed the parameter to , as it's clearer this way. You didn't pass a , you passed a as a parameter. It's important to be very clear. I'm copying the . I'm not 100% sure that's useful, but it's to avoid a problem with references. If for example I did : 

is usually bad. Consider returning a , because otherwise the one that launches the async task won't be able to "follow" it. If the "launcher" doesn't want to follow it, that's his problem, but you must give him the opportunity to do so. Instead of : 

Now, there's still a problem. Since your list doesn't check for unique elements, your "randomness" is flawed. If I add the character 100 times in 110 elements, there are much more chances for me to get an then something else. But that's up to you and this issue wasn't addressed in your original code since your class isn't , this isn't really a concern. It is fixed in the set since sets contain unique element. We couldn't do the same thing with since the sets do not have no mean to get an element at an index, which is needed for you. Methods should have names that are verbs, not names. So should be . Overall, you'll gain performance using these data structures over . The rest looks pretty good overall. You might want to give a little more empty lines in your code since multiple lines stuck together are hard to read. Also, don't forget to check your entry parameters for in your public methods. Each time a is thrown because of a missed check, Santa removes a gift from your presents list. :p 

That is it for the structure of a . Now, the class. I use a to hold my graph, the interface is defined as this : 

So, let's look at that timer! This class as an property, which well... auto-resets the timer at the end of each interval is set to . Which will be the main difference between your and methods. 

This factory is used to create or wrap an object and attach the method of the controller to the created object. Here's the controller's interface : 

Using extension methods and the interface makes me think you should use an abstract class to encapsulate the logging framework you use. I put the method and the overloads but you could put it back if you need. Also, as you'll see it, I added brackets to your one line's if. I believe that even if it adds some lines of code, it gives a much better readability to your code. 

Your solution seems good, but your comments aren't helpful (as tim stated). The explain the use of the and operator. I think the intention is good, but these comments aren't helpful to you or to anyone that already knows what these operator do. You should remove them and assume the next developper who will go through your code will go check on internet to find the signification of these operators. I think you should add an helpful comment to the algorithm that would explain why you shift bits to the right in your loop as it will explain your algorithm. Remember, comments are there to explain why, not how. 

Going this way, the clients that uses your repository could create a query by themselves, which means you don't have to worry about the quadrillion possible queries (With ,,, etc..). The danger with this method, and with your current method, is that I, as a client of your repository, don't know if the query was executed or not. The interface, as the interface (since the first implements the second), defers the execution of the query. Meaning that each time I call a on my query, I return to the database to do the query again, which is super expensive. I don't know if that's clear, so here's an example that uses the method (Imagine I added the method to the interface): 

is pretty obvious, so the comment isn't neccessary. I think it is the same for all your comments, except the third. But what I need to understand, as a developper who reads your code, isn't that you used a formula to get the total, but to understand how your formula works so you can get the total. Both your methods use the same , which makes me think it should be a parameter of both your methods, this way you can be sure they will never be different. 

Header's comments should be helpful short information. We (you included), as developpers, will try your code and understand what it does. On a side note, I don't like . Maybe that's just me though. If your class is small enough (and it should be if you remove some comments), regions just bloat the code! What I'm trying to say is : The code has all the value (ok, maybe 95%), make it look this way in the way you write it :) 

Your code seems really good, I would change the methods to return instead of . Also, I suggest you would add a method signature to your generic repository interface that would let you query your DbContext. 

You can then reuse this constant everywhere in your code without fear of breaking something if it happened to change. This : should be extracted from a configuration file (Like the ). What if you had to change the port or the host of your application? You'd need to recompile your application. This isn't good. It might be a mistake when you copied your code here, but your indentation is off : 

Overall, you didn't need to members, you can use read-only properties from C#6. You have a tendency for useless parenthesis! For example here : 

Remove the from your class, it doesn't belong there :) The indentation is quite small, maybe it is this way because of how you posted your code here but I hope your production code has a better indentation. Finally, consider commenting your code, it will be easier to understand your algorithm for other programmers. 

Your code seems really good to me, I don't have anything else to say but that I'd remove the override, as it has no purposes. 

Now, that's up to you to find it more readable or not, I just think it removes some lines of codes and is more readable to someone who knows LINQ. But wait, there's more! Considering you at the first your find, using might be a good choice : 

Finally, your application will crash if the user enters anything that isn't an in the prompts for the scores or the number of players. You should validate your input and maybe re-ask the user for the score/number of players until it is a valid input. 

should use brackets, just to make sure you don't introduce some nasty bugs. And hey, you could reverse your condition to remove some nesting : 

lacks comments. I have almost no idea what is happening in that method. In , fields/properties/constructor are mixed up. 

What you need, I believe, is a (the name could be changed, that's what I'll use to talk). The query service is somewhere between your application services (or controller, depending on the complexity of your application) and your data access layer. This service will hold all specific queries that are used by the application services (or to show data to a GUI). I can't draw here, but in CQRS (or CQS, doesn't matter in that case), you have a separation between the and . When you write in your application, the process goes something like this : GUI -> Application Services -> Domain -> DAL Now, a common mistake is to mix the Read path with the Write path. What is just above is made for multiple purposes : Catching user intent, validating it through the domain and saving it in a DB. This process is captured in the 4 layers I wrote above. When you read, none of the purposes I wrote above apply. You usually want to do A : Validation, which requires a database read or B : Expose data to your user via a GUI. What does that mean? I means a different path of course! GUI -> Query(?) Services -> DAL The query service would usually return Read Models, or primitive types. Hence, I believe you should have read services. Application service definition : If your application has little complexity, this is probably mixed in your controller, otherwise you probably have classes that take care of validating/parsing/saving/etc. input from the GUI, that's my definition of an application service! 

Now, I need to talk about the recursive call. Recursion is, in my opinion, a beautiful monster. It is a pain to read, to write but so awesome once you understand it. In your case, recursion seems a little over the top. Recursive calls aren't that great, seriously. You could make this a little easier to read (and write) by using a loop.