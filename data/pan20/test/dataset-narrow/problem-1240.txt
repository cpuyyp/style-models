It is impossible to solve the problem in less than $cn\log n$ time in standard models, e.g. using algebraic decision trees. This follows from the work of Yao and Ben-Or that shows that in this model it is not possible to decide if a set of $n$ input numbers are all different or not (see $URL$ In case of your problem, imagine that all of them are on the real line. If two points are the same, then your output would be two points with distance zero, while otherwise not, so a solution to your problem would also solve the DISTINCT NUMBERS problem. If you want to suppose that all your points are different, then just add $i\epsilon$ to the $x_i$ inputs of the DISTINCT NUMBERS problem, in this case if your output is at most $n\epsilon$, then the numbers are not all distinct. (Although in this case you have to use a promise version where the difference of any two distinct numbers is at least $2n\epsilon$, but I think the same proof works to show that you also need $\Omega(n\log n)$ in this case.) 

Let the first part of your given solution be $p_1=\{N,N,0,\ldots,0\}$. Then in any other solution these two elements of weight $N$ must be in different parts, therefore the problem reduces to finding a (not necessarily balanced) partition of the elements of $p_2$, which is $NP$-hard. 

No. Let the normal vector be $(a_1,\ldots, a_n)$. If these numbers are $poly(n)$ small integers, then there is an $I$ and $J$ such that $\sum_{i\in I} a_i=\sum_{j\in J} a_j$ by the pigeon hole principle. But then we have $\sum_{i=1}^n \varepsilon_i a_i=0$ for some $\varepsilon \in \{-1,0,1\}^n$. 

How is the oracle given and what do we know about $g$? If the oracle is black-box and we only know that $g$ is continuous odd, then already for $n=1$ we might require infinitely many questions... If the oracle is given by some Turing-machine, then you get that your problem is 

If you want any two people to sit at the same table exactly once, then this is called a resolvable 2-design and has been studied a lot. Of course allowing to skip a few meals would give a solution to your problem when two people can meet at most once. (But other solutions might exist, I suppose.) 

The first paper essentially gives a subquadratic algorithm if we know that every input number has $w$ bits and we can add two $w$ bit numbers in one step. This was not a very surprising result and it did not rule out an $\Omega(n^2)$ bound. The second paper does not use any such assumptions and improves the exponent of $n$ for decision trees, which is a surprise, although not as big as it would be for all algorithms, for which they have only improved slightly (thus disproving the strongest conjecture). I would guess that more results will follow shortly. 

1) Yes, but only because of your definition. Take a unary language $L\in EXP\setminus BPP$ (yeah, I know this might be empty, in that case just take something even bigger than $EXP$), that is very sparse in the sense that $n\notin L$ if $n$ is not a tower of $2's$, i.e., of the form $2^{2^{2^\ldots}}$. Define $p=\sum_{n\in L} 1/n$. This $p$ is not $BPP$-computable, but $p$ can be approximated in $P$ up to a small enough additive error that allows the simulation of a $BPP_p$ machine. Had you defined $BPP$-computable such that you want to approximate $p$ up to an additive error of $1/n$ (instead of $1/2^n$) in polynomial time, things would be different. Update. The below answer is for the case when the additive error we allow is $2^{-n}$ instead of $2^{-n-1}$. 2) Yes, because here you can forget about the polynomial restriction on the classes and by sampling $2^n$ times you can get the $n$-th bit of $p$ in $BPP_p$. 

This might be embarrassing, but it turned out I don't know what is $DTIME(n^a)^{DTIME(n^b)}$. It is between $DTIME(n^{ab})$ and $DTIME(n^{a(b+1)})$ but where? Update: There are three possible ways to define oracle machines. 1, They have an oracle tape, which they can read (see wikipedia). 2, They have an oracle tape, from which they can pose questions (see Arora-Barak book). 3, Same as two, but after each question the tape is erased (I could swear I heard this too). I had 2 in mind, as the most common (?) definition. In case of 3 it is easy to prove that the answer is $DTIME(n^{ab})$ (see Kristoffer's answer). In case of 1, I am not even sure that the bounds I claim hold, but maybe it is not hard to prove, I have no clue about this version. Update: I have realized that the number of tapes changes the power, so it is best to forget this question... 

Given a boolean function $f$ on $n$ bits, how hard is it to determine its decision tree complexity? (I assume the decision tree is simple, i.e., the allowed questions are the bits of the input.) If $f$ is given by an oracle, then this is surely exponential in $n$, still I wonder if it ever has been studied, if there are algorithms that run in $2^{O(n)}$. I am even more interested in results about when $f$ is given in another way, by a polynomial over some field, or by a Turing-machine computing it. Is there anything known about this? Are there any hardness results? 

For example, the game where the first player picks the values of the variables of a CNF (that might not have a solution), while the second player is trying to solve a SOKO-BAN puzzle (that might not have a solution), is such an example. 

This question is related to Benefits for syntactic and semantic classes. As mentioned there, $\mathsf{PSPACE} = \mathsf{IP}$, which can be interpreted as the semantic class $\mathsf{IP}$ obtaining a syntactic definition. What are other non-trivial examples for "syntacticizing" a class? 

They don't necessarily imply a partition, here is a counterexample. Each set in each $S_i$ will have an even size, while $U$ will have an odd number of elements, this already guarantees that a partition is impossible. $U$ is the nine vertices of a cycle of length $9$, whose edges are colored with $3$ colors, in an alternating way. With the union operation each color class generates a set system, these will be the $S_i$. In more detail, the generating edges are 01, 34, 67 for $S_1$, 12, 45, 78 for $S_2$ and 23, 56, 80 for $S_3$. It is easy to check that your separating condition holds. 

The directed Generalized Geography game is well-known to be PSPACE-complete, however, I could not find anything for the undirected version. I saw that in Hans L. Bodlaender, Complexity of path-forming games, Theoretical Computer Science, Volume 110, Issue 1, 15 March 1993, Pages 215-245 (thx to Marzio De Biasi for the link) it is posed as an open problem. Is it still open? In fact, I wonder if there is a simple gadget that we can put in the place of every directed edge to make a straight-forward reduction from the directed version. Is it known that no such gadget can exist? 

Is there a sorting network that makes only $O(n)$ comparisons and finds the median? The AKS sorting network sorts with $O(\log n)$ parallel steps, but here I am only interested in the number of comparisons. The median of medians algorithm finds the median with $O(n)$ comparisons, but it cannot be implemented as a sorting network. Remark. In fact, in a recent work, we needed a version that is less powerful than pairwise comparison and resembles sorting networks. In our model one could input two elements, $a$ and $b$, and the output was either "a" or "b", such that the output is at least as big as the other number. (In case of equality, either one of them, and we are interested in worst case complexity.) In this variant we could prove that there is a solution with $O(n)$ comparisons. Of course I am also interested if anyone knows anything about this model ever being studied. 

This is a special version of the Beck-Fiala theorem. Define a set system on the vertices whose sets are the out-neighborhoods of the vertices. The in-degree condition will give that every element is in at most $n$ sets. The theorem states that in this case the elements can be colored with red and blue such that the difference of the red and blue elements in any set is at most $2n-1$. This means that in your digraph the out-degree of each vertex $v$ in the corresponding subgraph is between $d(v)/2-n$ and $d(v)/2+n$, so for your specific question $c(n)\ge 6n$ is sufficient. 

The seemingly pointlessness of cryptocurrency mining raised the question of useful alternatives, see these questions on Bitcoin, CST, MO. I wonder whether there exists an algorithm that can convert practically any computational challenge $\mathcal C$ (whose solution can be verified efficiently) into another such challenge $\Psi(\mathcal C)$ (which is used for proof-of-work) such that 

I claim that if for some language there is a CFA with with $s$ states and $0$ or $c$ accepting paths for every word, then there is a UFA with $C_ss^c$ states. The basic idea is that the states of the UFA are the (ordered) c-tuples of the states of the CFA and it accepts if and only if all c states accept. Of course we also have to make sure that these were indeed different computations and that we do not count all $c!$ permutations, so for these we need some extra $C_s$ bits of storage. A bit more detailed description of the basic idea: If $(s_1,\ldots,s_c)$ is a state of the UFA, then it has a transition from it (reading some letter $a$) to the state $(s_1',\ldots,s_c')$ if and only if the CFA has a transition (reading letter $a$) from $s_i$ to $s_i'$ for every $i$. A state $(s_1,\ldots,s_c)$ is accepting if and only if $s_i$ is accepting for every $i$. Of course the starting state of the UFA is $(s_0,\ldots,s_0)$ where $s_0$ is the starting state of the CFA. The problem with the above is that the $c$ simulated runs of the CFA might be the same. So we add some extra information, encoded, say, in a graph on $c$ vertices that has an edge between vertex $i$ and vertex $j$ if during the run so far at least once we had that $c_i\ne c_j$. Now we still have a problem, that we have counted everything $c!$ times because of the possible permutations. We can remedy this by requiring that if the $i$-th and $j$-th states have been the same until now and in the next step they would differ, then in the next step the $i$-th state should have a larger index. 

I think there is a pretty fast way to do this. Let the coefficients of the yet unknown polynomial $q$ be $b_i$, so $q=\sum_{i=0}^d b_ix^i$ where $d$ is some small number. Now let us start computing $p \pmod q$ where $p=\sum_{i=0}^D a_ix^i$, where $D$ is big and the $a_i$ are known. This we do by reducing the degree using equalities as $a_Dx^D= \frac {-a_D}{b_d} \sum_{i=1}^{d-1} b_{d-i}x^{D-i}$. Eventually what we get is a degree $<d-1$ polynomial, whose coefficients are polynomials of the $b_i$ (since the $a_i$ are known). These polynomials we can compute fast once we get $q$. 

There are several algorithms that decide in polynomial time whether a graph can be drawn in the plane or not, even many with a linear running time. However, I could not find a very simple algorithm that one could easily and fast explain in class and would show that PLANARITY is in P. Do you know any? If necessary, you can use Kuratowski's or Fary's theorem but no deep stuff, like the graph minor theorem. Also note that I do not care about the running time, I just want something polynomial. Below are the so far 3 best algorithms, showing a simplicity/no-deep-theory-needed trade-off. 

I think your problem is NP-complete already for M=3, as there is a quite straight-forward reduction to it from 3SAT. Just for each variable xi, make a pair of squares, truei and falsei. For a clause Cj, make a pair of squares for each of its literals, e.g., Aj1, Bj1, Aj2, Bj2, Aj3, Bj3. Let Aj1 intersect the respective square of the variable (e.g., truei) (but disjoint from any other similar clause-squares intersecting it), while the Bj1, Bj2 and Bj3 are put somewhere in a disjoint way. Finally, for each clause we have a collection of three squares, which is also Bj1, Bj2 and Bj3. 

$\;\:\:$4' (Update). As pointed out by Noah in a comment, the previous condition should be strengthened to requiring that preprocessing $\mathcal C$ should also not give any advantage in solving $\Psi(\mathcal C)$. This last condition is required so that no one can be put into an advantageous position just because they know a solution of $\mathcal C$. Using this method, people could submit computational problems that they want solved and a central authority could pick some worthy of solving (like finding aliens vs. breaking passwords). Note that it doesn't seem to be an issue if the problem takes even a week to solve (I guess those aliens can't be that good in hiding ;), as this could result in a bigger reward for a solution. Anyways, these topics are not related to the solution of my theoretical problem, but of course I'm happy to discuss them in the comments/on the forum. A possible solution would be the following: $\Psi$ maps $\mathcal C$ into $(\mathcal C,HASH_r)$, that is, to solving $\mathcal C$ and some other, computationally hard challenge. One problem with this is that knowing a solution to $\mathcal C$ does make solving $\Psi(\mathcal C)$ somewhat easier (how much easier depends on the difficulty of $HASH_r$). Another issue is that $\Psi(\mathcal C)$ became more difficult than $\mathcal C$.