I agree with comment to post about potentially investigating web sockets. I guess the decision on what approach fits best would really be based on how frequently your data changes. Even in thinking about the AJAX approach, I would say the same thinking also applies to how you decide to call the backend. Does each component in the UI have data that changes with different frequencies? If the components are highly related perhaps it makes sense to just call a single service endpoint every X seconds to get a single data feed you can use to update. Conversely, if these outputs all change with different frequencies, maybe they should each have their own polling intervals. In the latter case, you may even go so far as to begin to think of applying a more proper component architecture in the UI, where each component has it's own view definition, data bindings, etc. There are a number of UI/javascript frameworks out there that are designed specifically for this use case - React, Polymer, Angular, etc. That being said, what you have works, and so long as you do not have a bunch of browsers open and you have your backend scaled appropriately, the number of queries you are making against the database should not be problematic. Since you are loading each component asynchronously now, you might even consider adding a "jitter" to your calls so as to make the query load less spiky against the database. For example: 

I think your dependencies are totally inverted. You are treating the Model object as a dependency to the DataSource object, when these should probably be reversed. Why does a DataSource object need to have knowledge on how to retrieve a model from the database (i.e. what queries to form)? I don't really understand you pattern of instantiating a model first, and then passing that model to the DataSource which then "initializes" the model and returns it? This seems like an odd initialization sequence. Why not just give DataSource to the model as a dependency for object initialization? You would then implement all the logic in the Model classes around how to populate/instantiate itself from the DataSource. You might even want to consider a separate model factory class to manage model instantiation or, at a minimum, placing static methods on your model classes to do things like instantiate a model given a primary key id. A public constructor for a model might not even make sense for your application. As a caller to this code, I would like to see something like: 

You need to explicitly exit execution once failure condition is met, and typically anytime after a redirect header is sent. This section of code is is actually VERY problematic. One could meet all of the failure criteria. One could actually fail every one of these tests, yet code execution would continue through all additional tests until the message is echoed out, with the location header being overwritten every time. So, the end effect is that if more than one condition fails, the end user will be redirected with only the last id value set. Your code should be more like: 

Consider getting away from type queries. These can be problematic and end up sendig a lot more fields from the database to this application layer than needed. Think about a typical database that may have timestamp fields or similar fields that are not mean to be used by the outside world. I would actually specific name all the fields you are setting on the object rather the looping over a (possibly unknown) set of fields and automatically set them as public properties on the object. Also, should this method have a return value? Possibly even to allow for chaining of methods. Just seems odd to not give caller any response to indicate that the operation was successful. 7) I would be explicit in defining accessibility of your methods (public, protected, private). 

I guess foremost, I question the mutability of this class. Should one really be able to change the value of ? 

Why do you need to have both and as parameter here if your DI framework has already injected a into for you? Do you now have two different objects in play in the controller? 

Consider placing this code in a try-catch block since can throw. I know that since is hard-coded here that we would never expect to get into a state where that exception is thrown, however I think it best practice to always use try-catch block in such a case so that as someone working in this code, you have quick understanding of how methods you are calling might perform. Who knows, maybe the implementation of changes at some point and throws exceptions for other reasons besides the passed relations parameter. 

Your custom exception seems to have a very limited use case. It really only exists to format the message string from a passed array, functionality that might rightfully live in the code where the exception is thrown not within the logic of the exception. Is this message even meaningful to caller as is? You can't tell what kind of relationship exists amongst the types provided, nor the specific ID's of the relationships that exist, so there is questionable value in preparing this specific message string vs. just a simple 'Cannot delete because this post has relations' message in the exception. You could easily provide this message in context of where the exception is thrown totally eliminating the need to override the constructor (or maybe even this class altogether). Is this class going to be used elsewhere in your application? If not, should it even exist (vs. using other exception types)? If so, are you always going to want to pass this class an array of relation types as parameter to format into message string? I actually question whether you should even be throwing an exception here at all if a relationship exists. Since you are specifically building this functionality, my guess is that you are expecting the application to handle deletion requests against posts that have relationships as part of normal operation of the application. If so, should this really be an exception or just an alternate code path that needs to be followed to handle this condition? Only if you truly never expect the application to be put into this state would it make sense to have this code throw an exception. 

It seems a very odd choice to define as an interface instead of as a base class (perhaps abstract). Your interface strangely does not require any methods or constants outside of a constructor. This doesn't suggest to me a viable interface, as there are no actions or properties whatsoever inferred by being a class implementing (which coincidentally could be any concrete class). Though I am a big believer in being biased towards composition over inheritance, I think you truly have an inheritance situation here with the way you have implemented this. 

Adopt a coding standard (look at PSR standards for PHP as some good suggestions) and enforce it via stylechecker. 

That would remove for the need for this method in this class altogether. After all, why does a login class need to understand the logic around whether a device is valid for a user? - I think as a class name is probably not the best naming for this class, which seems to expose functionality dealing more with a collection of devices. Is that class itself doing too much? 

You should strongly consider using a PSR-4 compliant autoloader. This can move you out of the world of having to write a lot of code around locating and loading class dependencies. 

I am concerned that you really haven't defined "difference" here and that perhaps your code does not perform the way you expect. You example is quite simple in that you would expect . But what if you had arrays like: 

In your diagram, you talk about having a router, but I see no evidence of there being a router from either the code or directory structure you have shown. This is a critical piece of functionality for a framework. Where is it? 

For this simple use case, you are correct that you could do all this work in a reduce step saving yourself an additional iteration over the array created by the operation. Now whether this is enough of a performance impact for your expected use cases to move away from the (probably clearer-to-understand) map-reduce pattern is something that perhaps you would need do some testing to decide how you want to approach the problem. If for example, you ever foresee yourself adding a step, then perhaps keeping separation between map - filter - reduce steps makes sense. I do think there are some edge cases around your basic query-split approach which might not be handled well here. For example, what about parameters with array notation (i.e. )? You can certialny do plenty of search on the internet to gets lots of ideas on how to approach the basic query string parsing logic. 

Avoid unnecessary code branches (such as the unnecessary shown in the example above). This could be: 

Stylistically, I would like to see you be consistent in how you order your properties and methods within your classes. 

On your page itself, you simply instantiate your validator, define the callback you want to trigger in response to validation, and then attach event handler to call validation. 

It certainly makes no sense to increment your counters an input fields at all. You could probably reduce all your javascript to something like: 

Consider using constants for these, as they don't change during script execution. You might also find this helps readability of your code when you begin to concatenate with these. 

I don't like your model's and methods in their current form, or perhaps not their naming at least. The concrete model, will, after all, be an object. So is what you really want to do simply extract or associative array representations? If so perhaps method names like , , , etc. might be more meaningful ways to name methods that give certain renderings of the concrete Model (and also perhaps a good serialization interface that you are wanting your models to implement) where might be defined as having methods like: 

I like that you are considering your , , and objects as being immutable. That is, if you needed to change one of these on the object, you would simply discard the old reference for a new one. As you rightfully stated, using these classes makes it much easier to simplify code where these dependencies are being used, as you can enforce the dependency via type-hinting, and skip all the guarding clauses. With regards to the question around whether to write getters/setters, I think your approach is fine. There are a couple of other approaches you might consider to find what works best for your application's needs: Use magic methods defined in a trait or base class to provide immutability to classes that use/extend on this functionality. Trait example: 

SVG is structured data and should therefore not require regex to work with it. I would suggest that you work with either an XML or SVG-specific library in PHP which would let you parse in the input SVG, remove any unwanted nodes and then render it back out. Here is a starting point for common PHP tools for working with XML that should be able to do what you want. This also looks like a library that could meet your needs. 

Again, the conditional doesn't seem necessary. Why would you ever get into the state where you have an active session and don't have this cookie set? If you are running your sessions in strict mode (you should be). Then this code is really not necessary, as the cookie would in essence be ignored going forward. If you are trying to be specific about overall cookie size then this code still makes sense. 

I will add a few thoughts beyond those in the excellent answer by @EliasVanOotegem Typically the use cases one might consider for wrapping a very well-established DB abstraction library like PDO would be to do something such as: 

Also, if you are not using eTags, you might consider it such that, even if a cached item has passed expiry, the browser still may not need to download the item if the eTags haven't changed. 

This is easier to read and reduces your potential code paths by one. This is also at the heart of my early comment to get rid of all those if-else conditions. They simply are not needed in this case and can be designed away. Similarly, 

To generate your insertion counts you should not need to keep manual counters. For example, if you used the strategy I mentioned above, would give you the count for number of rows inserted/updated as a result of the last query execution. 

Consider adding helper method with to decouple key retrieval logic into it's own (testable) method with appropriate exception triggering to make your class less fragile to bad input. After all, if some portion of your application is expecting some config to be available and it is not what is expected, you should be failing loudly, because your dependency is not being met. That might look like: 

Consider working with SPL's fileinfo and iterator classes (i.e. , and , , etc) to build something a little more resilient. Example: 

I don't understand your class, in that it doesn't actually perform user authentication. It just persists authentication status to session. It seems odd to have password verification in while having a method on . Why do you need anything other than user id and authentication status/timestamp to be stored in session? The other fields should come from user object. The only thing the session should be used for is to recover status of user login between requests, not be authoritative on user information, including authorization privileges. I would think once the session has recovered the user object (something that is unclear how you are handling from shown code), it should no longer be the authority on user status. Most of your methods should probably be move to class. In fact, I would consider just ditching this class altogether in favor of just providing methods for login/logout along with session persistence and object recovery from session there. 

Other than for simplicity of being able apply all replacement rules easily, and with more maintainable code, I don't see an absolute need to use regex for this, as simple string manipulation should be able to be used here and may be better from a performance standpoint. There is no reason for you to loop over the regex array and each individually, as accepts arrays for both patterns and replacements. So you could easily do something like: 

This class frankly seems pretty trivial and would have a long way to go to get to something useful. I would agree with thoughts in other answer around adopting a consistent style. I don't understand the static / concrete duality of this class. Why the need for the static instantiating method at all? The biggest problem here though is that this code is incredibly fragile, and here is where you would need to put in most effort to get towards a class the really brings value over simply writing queries manually. There's nothing to validate input to your various methods is suitable to produce a valid query. There's nothing to enforce that these methods are called in the proper order, and you concatenation approach simply hopes that the order of properties when cast to array are proper. You don't even specify the properties in the class, instead defining properties on the fly when methods are called, so there is nothing to enforce that all properties even exist on he object. You lose flexibility in writing your queries. Unless you want to build a significantly more complex set of methods on this class, you can really only build the most basic queries using this class. And you introduce all these problems into your code for what? I don't see what value this class brings versus to writing out the queries. Just write the queries. They would be easier to read and maintain. 

You are inconsistent in your approach to validating data passed to your public methods. You do throw in one case, but you do nothing to validate integer values for example. Of course, that can get taken care of quite easily in some cases if you take the suggestion to put favorite into class that can be type-hinted against. 

Your layout/templating model seems very cumbersome and doesn't deliver a clear separation of format (i.e. HTML) from code, nor does it seem to consider component-based layouts (i.e. components for header, footer, or other common elements that can be re-used across different views). There are a number of templating solutions out there in PHP, so I am not sure that rolling your own makes much sense.