So, apart from the good points already given, I'll add my comment as an answer: Your method should return the first of each type of element. This would only really make sense if the stream itself is ordered, so that the encounter order is deterministic. When there is no fixed order, 'first' does not have any sensible meaning. A way to check it is: 

I'd like to give some thoughts which spring to my mind when I read your given code. Now, you have an implementation specific for primitive ints. A more advanced step would of course be to implement a generic like the one in the JDK, just mentioning it. First up, I like that you use clear variable names, and that you reuse methods like \ . Kudos for that! As an aside, you do not need the variable, as it is the same as . It is a fixed size stack, so it does mean you have to know beforehand how much elements it would take up, in order to not waste space (or run out of it). Perhaps for a follow up exercise you could try and make it dynamically resizable? Now, for the method. I would not let it silently succeed if the stack is already full. Seeing as it is a fixed size stack, I would probably opt to throw an , because to me it looks like a programming error. A possible second idea could be to return a , signaling succes or failure (though I don't think it is the better solution). Same with peek. It now silently succeeds and returns , which is very well a valid value which could reside in the stack ( exists by the way!). The solution would not work here of course. Also, I personally do not think the extra new line is an improvement, on the contrary. Finally, to me means taking off the top element of the stack. So why not return it? 

Well, I do not want to be the one always hammering on using s, but your second solution was almost immediatly clear to me, whereas the first was not. It does help that with the second one you split it up into methods, a very good thing! Nontheless, I still think you can improve the second solution: 

I have a feeling there is a direct way to compute this amount, but I am not really into all the mathematics, you could possibly look it up. I'll talk about your code as is: 

I think it makes the loop implementation a bit confusing, because this is only called once to add the first element to the merged elements. I wonder if using and iterating over that would be better, or a manual iterator... Also, should the s become immutable, it would change the implementation a bit. Note that you are now changeing objects which are coming from the outside. Your method assumes that the start time of first is always the smallest start time, and that the end time of second is always the greatest start time. This would be wrong for e.g. first = [8, 12], second = [9, 10]. It will return [8, 10], when it should be [8, 12]. The overlaps method also is a bit incorrect, because multiple meetings starting at the same point in time will not be merged. Also is the same as . Finally, your show method ends each line with a comma. Should you want to simply delimit each meeting with a comma, but not one at the end of the line, you could solve it for example as: 

You have to keep in mind that Streams are not the solution to everything. In this case for example, you need to keep track of multiple values, i.e. the current individual, and a cumulative sum (and you have to return a a value as soon as a certain condition is met). Yes, there are ways to do this with Streams, but I think in this case it is best to implement it with a simple loop like you have. A couple of side notes: 

If you're using , you shouldn't have the shebang in the second script. If you're using the shebang, you shouldn't use . But rather than use directly, I would the script once at startup, and in it define a function that was called at the later times. You should use instead of to avoid forcing a separate subshell to spawn. I would provide a default instead of exiting if no argument is passed. Something like . Also, I always use named variables as early as possible. Note that if you were using a function (with or without ), you should use to avoid leakage. 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler). 

That said, your short-circuit if the lengths mismatch is a good idea no matter which implementation you use. There are some style issues that jump out with your implementation: 

There is no good reason for you to make 4 separate calls. Most likely a single call for would be enough, but even if you have a pressing need for them to be on separate pages, you should still 4 pages in a single call. You don't need to open to get anonymous memory, just pass as the FD and add the flag. 

By the way, \$O(2n)\$ is equivalent \$O(n)\$. However, the bound is actually tighter: \$O(n + m)\$, where is the number of distinct elements. This is, however, an average bound, because it relies on a . If the worst case hash collisions happen, you get \$O(m(n+m))\$ 

My preference is to then use so that I can stuff it in a or or set along with any other read- or write- file descriptors. 

That way it can be run directly with (and possibly other harnesses, I know the standard requires wrapping them in a dummy class, but I haven't used any others). 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

If you don't like nasty bugs, always use for allocation sizes, not . Yes, somebody will do it, this is a fatal flaw in the Qt libraries. You're missing move constructors/assignment. Most likely they should be implemented by moving the ownership logic out to a separate class (if you don't take all of my advice, would work) and then using the Rule of Zero. There's no point in providing a method (this is a flaw of ), you can just use on the iterators (that you need to implement). Most implementations use instead of , or even just a single member which points directly to the string data. and stores size/cap information at offset . Newer implementations often use SSO (Short String Optimization) as well. You're missing slicing operations. Slicing operations should return a class though, instead of allocating a . You're missing , which most people want from a string. Though I'm not convinced it's useful; I treat strings as opaque blobs rather than containers. If you choose to have mutable strings (see below), you're missing , , and . In either case, you're missing . You're missing , , etc. These should allow mixing with .