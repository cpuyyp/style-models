Replace with whatever you named your task. Here is a document listing all of the command line options. Note that if you run this while ConEmu is already running it will just open a new tab in the current window. This is usually the desired behavior but this behavior can be overridden using the and switches (depending on your current setup). How to add task bar jump list items If you are using Windows 7 or higher, you may also be interested in looking at using the jump list to select a task to startup. This can be done in the 'Main' -> 'Task bar' options page. Check the 'Add ConEmu tasks to Task bar' box and press 'Update Now!'. 

Update I just installed it to confirm but dd is installed with the default installation of DSL. The following only applies if you've somehow removed it (if that is the case then you may have a lot of other important stuff missing too, you may be better off starting fresh too because this could be really difficult to fix manually. -- Open a terminal. At the prompt, type the following: 

When the processor needs to read from or write to a location in main memory, it first checks whether a copy of that data is in the cache. If so, the processor immediately reads from or writes to the cache, which is much faster than reading from or writing to main memory. Most modern desktop and server CPUs have at least three independent caches: an instruction cache to speed up executable instruction fetch, a data cache to speed up data fetch and store, and a translation lookaside buffer (TLB) used to speed up virtual-to-physical address translation for both executable instructions and data. The data cache is usually organized as a hierarchy of more cache levels (L1, L2, etc). Working memory is the actual data used by your application (as well as a copy of the executable itself; which in the old days you were freely able to modify at runtime, BTW). This is the only thing you really need to worry about as a computer user. It is stored in main memory which is (almost always) a different physical object in your computer. The caches I've talked about here are all on your CPU (which is why they are faster for your CPU to access than your RAM modules; which is were it has to look if it can't find what it needs in the cache). Remember though that the word cache is a very generic term. In computing we have caches all over the place so you need to be specific when you are talking about caches. 

Proxocket written by Luigi Auriemma. It intercepts API calls and saves captured traffic as Wireshark-ready .cap file in tcpdump format. Nothing is more explanatory than an image provided by Luigi himself: NirSoft has SocketSniff application which allows one to capture a traffic of a specific process. A picture is worth a thousand words as well: 

The last item does not relate to the issue directly, but I've added it for a completeness sake. In a nutshell, all of the above components have to support more than 4 GB of memory in order to succeed. Central Processing Unit Lets start with a CPU. But first it is important to note, that a CPU does not have any magical ability to use any memory at all. Instead it could just access any address within its addressable space. Now here comes the bitness-thing. 32-bit CPU is capable of accessing addresses in range from 0 to 4 GiB. This range however has to accommodate not only the available RAM, ROM, SMRAM, Graphics Address Remapping Table but also all the required Memory-mapped I/O and many more, which might require substantial part of this address range. As a consequence it might be perfectly possible, that some memory addresses were shadowed by those uses and therefore are not available for operations on RAM. In order to regain hidden memory it is necessary to extend the CPU accessible address space. In case of 32-bit CPU Physical Address Extension could help. Which allows addressing up to 64 GiB. 64-bit CPU operating in native 64-bit mode is by default capable of accessing up to 16 EiB, which is rather huge and does not require such tricks. But on the other hand it is impractical for a 64-bit CPU to use 64-bit addressing, so in reality they are still limited by their address bus to a lesser range than 16 EiB. Memory Controller Unit Initially it was located in Northbridge, but was moved onto the processor die by AMD beginning with their AMD64 processors and by Intel with their Nehalem processors. Even if a CPU with PAE is capable of accessing 64 GiB by itself, it still needs a MCU to access RAM. Simply put: a CPU accessing particular address gets its reply either from PCI device, BIOS ROM flash or MCU, if the address requested resides in RAM, and so on. It is not uncommon however for a MCU (be it in Northbridge or in CPU) to support much less addressable space than 64 GiB for marketing reasons for example. BIOS / (U)EFI BIOS / (U)EFI are also important as it is their duty to configure the hardware before anything can actually operate. Among other things they are responsible for mapping the entire processor addressable space with memory ranges of hardware devices, buses, RAM and so on. Interestingly it might happen that the whole RAM split in pieces and mapped at several available non-contiguous spots. The problem with BIOS is that it's developers might not expect more than 3 GiB of RAM usage within their system and as such BIOS will not properly map all of the memory to be used. Most likely this will not happen to (U)EFI. Operating system Operating system should also support addressing more than 4 GiB memory. To be more specific, it should configure a CPU to use PAE. Some 32-bit OSes are perfectly capable of using PAE and accessing more than 4 GiB, others have software-limit on maximum memory, even though they enable PAE for enhanced security (Windows XP being an example). Once again 64-bit OSes naturally do not have such difficulties and normally support more than 4 GiB of memory. Application The last point is from a different world, since applications commonly operate in a Virtual Address Space, I have added it for a completeness sake. Nonetheless it takes some additional steps while compiling for application to be able to use more memory. By default 32-bit application only capable of using 2 GiB of memory. The same 32-bit application could address up to 4 GiB of memory, provided that OS does support that and has enabled CPU PAE. More specifically, it could use up to 3 GiB of memory, the other 1 GiB would be addressable as common libraries and OS kernel, but not writeable (ultimately this depends on OS architecture rather than application itself). Again, 64-bit applications natively support addressing more than 4 GiB of memory and do not have such troubles at the first place. To put all of this into perspective, lets consider several examples. Consider Intel® 82945G Memory Controller. Intel website states, that it does not support PAE and is limited to 4 GB of RAM. Lets consult paragraph of the datasheet. It has lots of information. Most interesting is : 

You simply need to add an entry to your host file. Then you'll be able to use a DNS name to access it. The following command will do what you want: 

The command is good if you want the window to close easily. Just press any key and it's gone. The second option is better if you typically want to run other commands after it runs. 

While checking my facts for this I ran across a good tutorial on using matchbox as a browser kiosk on the Pi. If this is too easy, then you can make it much more fun by using only X and nothing else. If this is what you want to do then I suspect you already know how though. 

Use ; passing the property of the process which you want to know how long has been running. Here an example which shows how long has been running: 

This will download the file onto . If this did not work, your problem is probably your internet connection. Check if the file was downloaded properly by confirming that its size is around 1.2 MB ( ). Then at the prompt, type the following: 

Name this and put it anywhere you want the files listed. Be sure to set the prefix for the URL path and the pattern for the file type which you want listed. If you list all files then you'll need to remove and remove\handle directories for Linux servers (in Windows, PHP will do this for you). 

No. You need to forward the port (probably 21) through your router. It is that simple. Exact instructions for every router are not possible in the space available here but there is a website dedicated to answering that question. 

Should do what you are wanting. This command has been standard in Windows since Vista and XP had it available in the . It also has the ability to set variables on remote machines if needed. 

After creating a rule targeting specific application, nothing changed as if my new rule was just ignored. That is if my rule says to allow, but default is to block, application is still blocked. Should I disable Windows Firewall completely, the application in question could establish connection. 

As it says, since it does not support PAE, it is ultimately unable to remap PCI and every other MMIO above 4 GiB, therefore some of the memory will be shadowed and unused. Which means that even if it is used with a CPU supporting 36-bit addressing, memory above 4 GiB will still be unavailable and some of the memory close to 4 GiB limit will also be unused. Conversely, lets consider Intel® 82955X Memory Controller, which is related to the previous one, but it is specified to support 8 GB contrary to the previous one! Datasheet paragraph suggests, that it does use 36-bit address bus to the CPU, which is a good sign. Paragraph has further insights. Compare to the one we saw before: 

Sadly, mentioned tools would likely not support 64-bit applications. However it is possible to write a custom interceptor using mhook library supporting both 32-bit and 64-bit API. 

It does a good job illustrating the issue with memory shadowing by PCI devices etc. Also it suggests a way of overcoming this issue by mapping a range from real RAM to upper address range within CPU-addressable range. Thus reclaiming that hidden memory for use. Note that this remapping is done by BIOS/(U)EFI upon hardware initialization and it is exactly for this reason I did include BIOS/(U)EFI in bullet-list above. I have taken Intel products as an examples, but the same is true for AMD. Now lets discuss how Operating Systems are involved. The Linux kernel includes full PAE mode support starting with version 2.3.23 and it is perfectly possible to have more than 4 GiB of memory usable with Linux kernel on a 32-bit system. However be aware of an undetermined issue with 32-bit Linux kernel on a system with more than 4 GiB of RAM on some hardware (in my experience it has something to do with TLB shootdowns). Anyway Wikipedia has a good information on PAE support. Interesting is how Windows XP is limited to 4 GB, whereas Windows Server 2003 Enterprise/Datacenter SP2 is capable of full 64 GB. Same is for other Desktop-Server Windows pairs. As you can see there are many combinations among components listed and in some cases replacing a CPU or OS might help. It is much harder to deal with BIOS/(U)EFI or MCU since the former is proprietary and built-in into the system and not easily modifiable, the latter is built into the CPU or soldered on board. 

You want a junction point. They act like links do for files. This will make the two folders actually point to the same location. This is done with the MKLINK command: 

It sounds like what you really want to use is the option instead of the option. Then you should not need a special style for the last item. The option is just preventing page breaks between paragraphs (which is most likely not what you want for lists made of larger paragraphs; you wouldn't want to chop off only the last item in your lists). is going to prevent your individual list item paragraphs from being broken up with page breaks (which is probably what you want for larger list items). After experimenting with this a little, it seems that both together produce the best results. More explaination: $URL$ 

Type this in the omnibox (address bar): Set the option named to . You can press Ctrl + F to search for it. It is about halfway down the page. After you are finished, restart Chrome. Source Update After updating to Chrome version 44 (July 2015) you will notice that this no longer works. Chrome is really wanting to force this on us (against the wishes of most of it's users; weather they know it or not). It is still possible to remove (for the moment at least) by using a command line switch: 

If this isn't good enough for you then your best bet is to make a VBA script or .NET Application-Level Add-Ins for part of this because this can't really be done in BATCH alone. 

Tablets Yes, your tablets and smart phones will also (generally) have a host file but you'll need a rooted device in order to edit it. Once that's done, all of the common Tablet OSes have several terminal apps available. Another option would be to use the Android Debug Bridge to edit it. Just copy the host file to the device and use the following command (assuming that the device is at F: and you've put your host file there): 

This clearly suggests that it is capable of utilizing more than 4 GiB of RAM, provided that it is used with the CPU also capable of 36-bit addressing. It is also worth noting that paragraph states that . However it is further clarified, that maximum usable RAM is limited to 8 GB. This once again declares the difference between addressable and usable as I was trying to convey in the CPU section. To conclude this, I'd like to note that two related chipsets have in fact huge difference in memory handling. Lets inspect Intel® Pentium® Processor Extreme Edition 840. It does support 64-bit instruction set, but does not support PAE. Which means that if run in 32-bit mode, it will be unable to use more than 4 GiB of RAM (please, correct me if I'm wrong with this assumption). Lets check the datasheet and table . Even though that this CPU is 64-bit capable, it is still limited by it's address bus being 36-bit wide, thus limiting it to accessible address range starting from 0 to 64 GiB. Now lets examine a more recent CPU. Take Intel® Core™ i7-7700 Processor for example. It is advertised to support up to 64 GB of RAM. Now lets check the datasheet of it. Paragraph convinces us that this CPU's addressable range is from 0 up to 512 GiB due to 39-bit address bus. Note that it is still far from the theoretical 16 EiB range for a 64-bit CPU. Surprisingly though it further clarifies that this CPU does support up to 32 GiB of usable RAM maximum (contrary to 64 GB on the website). There is also an image of interest here : 

you might need to add to kernel boot options if you've converted a fairly old ext2 to ext4, it might be lacking online resize capability with the only solution - create new ext4 fs and then move your files there (sad, but true) if you've converted a fairly old ext2 to ext4, you might notice a .journal file at the root. it does not appear on other mount points, since hides it automatically. Sadly it canot do the same to / mount point - you need live cd or any other running system to hide this node 

Assuming that you meant to say H:\ then it isn't a file it is a directory. It also means that you are missing H: (the H drive) which is the actual problem. In reality, this is how Truecrypt works. When it encrypts a drive that drive then becomes completely unreadable by your OS until you decrypt the partition again. At that point Windows will see it as a completely different drive and assign a new drive letter. As dumb as Windows is about handling this it is smart enough to remember your settings when you tell it what you really want which is all we care about. Tip: Windows will give you all sorts of trouble with it until you decrypt it. I would suggest going to your drive management tool and hide the unreadable partition. When you actually decrypt that drive it'll be given a new drive letter anyway and this does a good job of shutting Windows up. The solution to this is that you must actually decrypt the drive before you can begin using it. To decrypt it you must open Truecrypt and select the encrypted partition using the "Select Device" button in Truecrypt. After that you'll be able to mount the drive using the 'Mount' button (this will require authentication). As long as you remember your password and\or key file location you'll hopefully have no trouble with this. Once mounted the newly decrypted folder will open up in Explorer ready for use. 

To specifically answer your question, if an application wants to intercept a system keystroke then it must catch it in the system message queue which is not the way applications typically work. The system will automatically create a special queue for each application which is more efficient for application to use because that queue doesn't include the messages intended for other applications. The system queue has all messages for all applications which means that any application which is reading it must throw out a lot of unneeded messages.