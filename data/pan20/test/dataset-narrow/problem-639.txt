ansi function usage. such as CreateProcessA this is very bad. windows is unicode (utf-8) system. almost all api implemented as unicode. the ansi (A) api - is shell over unicode (W) api. the A shell convert input ansi strings to unicode, call W api and finally convert out unicode strings to ansi. this is very not efficient. more bad that use ansi strings simply wrong by design. ansi code page is not invariant. it different on different systems. if you hardcode some ansi string in code, which use characters > 0x80 - you got different unicode strings after convert, on different systems. finally not any unicode string can be converted to the current ansi code page. use ansi code page for cmd is wrong. cmd use for pipe input/output not ansi but oem code page. this is different code pages. when cmd read multi-byte string from stdin file - he convert it to unicode via with . and when he output something to stdout file - he translate unicode string to multi-byte via with . so until he output characters in range you not view different. but if will be say "not english" file name in output, or you pass some command with "not english" file name - will be error - because you and cmd use different code pages for translation. you pass him ansi but he wait oem. he pass to you oem strings, but you wait ansi. also note about inherited handles - begin from vista better use also with for restrict list of handles to be inherited by the child process - not all inheritable handles, but only one pipe handle. yes one but not two as you use. 

Putting It All Together With all of this, we end up with the following. Notice that we've reduced the size of the class by almost half and made it a lot more readable. CodeBehind 

Factor Out Constants Several of the numbers used are constants which could be factored out, such as the difference between Kelvin and Celsius (273.15). This will prevent typos from causing calculation errors. Something like the following: 

Ideally, it would be great to have a result information class that we could serialize and pass through, which might include the percentage, which answers were right/wrong, etc. Note: It really shouldn't be using the session at all here (see reasoning above), but the architecture of transferring the data is out of the scope of this question, so this is here for a proof of concept. Separate Data Access From Rendering Currently both handles data access as well as calling the rendering method. I would extract the data access to it's own method, something like: 

Overall, I think this code is a great first try. That said, it has a lot of room for improvement in terms of simplification and improving readability. As an aside, I'm not sure if you have a strong motivation for using Visual Studio 2010, but if you don't, I would recommend considering using a more up to date version. Visual Studio 2017 was recently released. Naming Conventions The naming of the methods should be PascalCase, and should not be abbreviated. For example, instead of , use . This improves readability and is consistent with C# conventions. You also use Hungarian notation for the question class. I would also denote that it is a model. Instead of , it should simply be . See $URL$ and $URL$ for reference. There are some great points in that documentation. Use C# Auto-Implemented properties The class can be greatly simplified using C# auto-implemented properties. Use instead of creating you own backing fields. See $URL$ for reference. I would also rename the Question property to QuestionText to avoid confusion. With this, the Question class could be extremely simple: 

interface of course also must be absolute another. here faster need export class with virtual functions. class implement cmd exec and write commands to it. virtual callbacks with read data from cmd. you inherit own class from this base interface class, implement your own on read data handler and cmd exit (disconect). some basic implementation of class: 

in this case and out only parameters. and you need say to caller - which api need use for free returned buffer. 

then look for (full nightmare) ; you all time read to to buffer begin () and never change . so what sense try reallocate buffer if you any way try read only bytes. then you all time read to buffer begin - so new read overwrite previous data. you use wrong and senseless , , instead of . for what you use before ? when you try reallocate buffer after every read ? even if still exist free space in current buffer ? on which size you try realloc buffer ? on 1 byte ?? and every time anyway try read constant to begin ?? for dynamic buffer buffer usually used 2 strategy: allocate memory chunk (usually 0x1000..0x10000 size). read to this chunk until exist free space in it (of course not all time to the begin of chunk but to the begin of free space inside chunk). when no more free space in current chunk - allocate new chunk (not reallocate existing !!) and so on. but not copy anything. when read will be completed - once allocate new buffer and once copy content of chunks to this buffer. for example. 

I've got a couple quick notes. Overall it looks like this method will work. Validating args[0] The only validation that you do on args[0] is to check if there are any images in that directory, but you don't check other possible failure conditions, such as if the directory provided doesn't exist. For a user, no images being found and the directory itself not being found would have different actions required to fix the problem. It would be helpful to perform better validation here and providing meaningful feedback, and perhaps a different return code. Duplicate Calls to Get Path There are a couple instances that call . This could be factored out to a variable. Use TimeSpan Formatting TimeSpan provides functionality for converting to a string in a particular format (see $URL$ In this case, I think you'd want the "g" format. Return Codes You return -1 in the event of no files being found, but you don't handle returning a different value if fails. If this was being called from a script, I'd expect any failure to return a failed return code. Catching Exceptions While the exceptions thrown by are likely all IO related, it would be helpful to catch at least some of the individual errors and displaying helpful information where possible. For example, if an exception was thrown because of a write permission issue, it would be helpful to let the user know that they need to correct their permissions, as opposed to hoping that the library you use provides a helpful description. There are also some instances that I bet could throw an exception that you don't handle. For example, I would expect to throw an exception in some circumstances. If some exceptions are handles and displayed in a user-friendly way, I'd expect all of them to. Commenting Some of the comments are helpful, such as the reference to documentation for a method from StackOverflow. However, there are also some trivial comments ( is pretty clearly going to get the elapsed time). But there are also instances where comments would be helpful, such as what the values you set on the MagickImage are (what does do?) 

another way - use for buffer. windows let reserve memory space. we can reserve tens of megabytes how minimum. this operation not allocate any memory but simply mark memory region as reserved. then we can already commit memory to region begin. when, after read, will be not enough committed memory - we commit more and so on. advantage - we from begin will be have contiguous memory - we never will be need copy/move/reallocate memory with this way. this solution is better when we assume big enough final data. example: 

if buffer not big enough - error is returned - (in case no valid data in buffer at all) or - in case exist some valid data in buffer, but need large buffer anyway. anyway you need here additional out parameter allocate buffer yourself 

but main question - are you need Contiguous Memory buffer at all ? for what you need cmd output ? for send it to remote system, display it in interface ? for this not need. after you read some data from cmd in fixed size buffer - just display this chunk in interface or send to remote system. and begin read new data chunk. of course you need absolute another interface for this. for parsing cmd output ? for this yes - need Contiguous Memory buffer.. but we never need parse cmd output. for what ?! if say we want list files/folders - we need do this yourself but not run dir command 

Two items I would have a look at in terms of the actual calculations. Use Full Names in Methods For clarity, and because the few characters are inconsequential, I'd prefer to see the full names of the units being used in the method names. This will improve readability and understandability of the code. 

This is unnecessary. Without it, it will propagate the exception up, the same as manually rethrowing the exception. Remove Unneeded Controls You seem to have both a radio button list and 4 radio buttons. We really only need the radio button list. There are also a few panels that aren't needed. Use ViewState Instead Of Session Instead of using the session to store data between questions, we can use the ViewState. The ViewState doesn't persist the data on the server, but rather stores it on the client side. Since we don't need to make use of the internal state data (such as the current question), we can store it in the ViewState. Using ViewState also allows a user to have multiple question sessions going on at a time in separate windows, whereas the session data would otherwise be mixed between them. We can also use properties to simplify this access. Instead of using strings to access the variables, we can implement the access in the property, which will prevent us from accidentally using the wrong key. For example: 

here - in/out parameter, but in only - if you reallocate user buffer - you must return new buffer size to user. may be next signature: 

you not need handle this at all. return number of bytes read. and you need use it. no any difference what bytes you read. 

again bad and wrong. for what you create 2 pipe pairs ?? when 1 pipe pair only need. one pipe handle in you process and one connected pipe end in cmd. pipe must be duplex. what you write to this pipe end in self process - will be read in cmd. what cmd write to self handle - you read via handle in self process. so not need additional pipe pair. next - always need use asynchronous pipes and io here. synchronous is not efficient and can deadlock. 

then reallocate caller supplied buffer - this is very bad idea. for reallocate you need exactly know how caller allocate buffer. you must add to interface contract - how caller must allocate initial buffer and free final. which concrete routine use. say for example caller must allocate initial buffer with and free with . but nobody do this. usual used 2 ways: