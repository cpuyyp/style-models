This will improve readability and speed of your code as Java will optimize the call to the . (Also note that there is nothing wrong with making your base case zero, all this does is zero index the triangle. If you want to make it start at one, then you will need to change the base case to check against one and the loop in will have to check against one also. I suggest leaving it like it is, it's actually more mathematically correct.) The other alternative to the recursive algorithm is to use an iterative method by use of combinations. The row and column of Pascal's triangle are the Binomial Coefficients where and . Using the equation for finding the binomial coefficients will be faster than a recursive method for large values of and . 

You will have to for this functionality. This drastically reduces the number of computations and repetitions in your code. Its important to keep in mind the acronym (Don't Repeat Yourself) and if you see something that happens over and over again, see if you can write it once but get the same computations out of it. It will speed up your code and make it more readable. I hope you found these suggestions helpful. Good job and good luck! 

Also, rename the other getters to and accordingly. (Edit: perhaps can stay, but is not a good function name.) Next let's talk about . You should move the constants that are defined at the top of into the class definition itself. I suggest making a constructor for a that takes in those arguments. This way, you have the ability to make several unique objects. If, for example, you want the user of your library to test the in a custom way, they can build their own objects. Provide that ability to the user: 

The point of doing this is that you're putting all the details of the object in the class itself instead of the main program. The function would end up looking something like this: 

Now for your algorithm. The Pascal triangle is an inherently recursive structure, and therefore it would not be unreasonable to write a recursive method to calculate its values. This works for small values of and but it will most likely lead to a stack overflow for large values. If you want to stick to a recursive function, the best thing you can do is remove the variables all together and try and get the function into a "tail-recursive form" by which we mean that the function itself is returned as the last statement. Here's what I mean: 

Whenever you have repeated blocks of very similar code, you should always seek to merge them into one generalized block. Sometimes this exercise is hard, sometimes simple, depending on the nature of the algorithms/paradigms embodied in the code. Here, without changing the HTML or the CSS, the javascript will simplify to : 

it is an exercise in a form of classical inheritance, by which methods bound to an element are inherited by selected child elements. methods are defined as properties of an object bound to DOM elements with . These methods are intended(?) for private use (within the plugin) but are ultimately accessible by user code. the child elements (spans) will retain a relationship with their original parent after being moved elsewhere within the DOM. the selection of first child spans is hardcoded. 

Then consider sacrificing readability for performance by not assigning what the terneries return. Instead write them directly into the expressions where the resultant strings get used, eg : 

... and in general that is what we would write. However sometimes it's advantageous to start a promise chain with a resolved promise, even if it's not strictly necessary. For example, we might want a chain such as ... 

Due to the volume of code, I would be inclined not to touch it. Recoding and revalidating would be a lengthy exercise. I wonder if the way ahead might be to enhance the (already good) comments, to provide better guidance to the existing architecture. 

The following code is designed to demonstrate the above principles. Its probably not 100% correct; I had to make a number of educated guesses particularly regarding the static DOM hierarchy. If you want to try it, be prepared to do some debugging. 

would need to return 1 for to return . Therefore the last question is unlikely ever to be selected. For equi-probability (well as near as possible) use : 

Very often a generalization is hard to spot when you are developing code. It is often easier, while developing, to write the everything out in its long form, then seek to generalize as part of a tidying exercise when it is working. The more experience you acquire, the more likely you will become at spotting a generalization early, but even experienced programmers will often write verbose code before boiling it down to something more manageable. 

Automated tests would be fairly simple to code, though it's hard to envisage something flexible enough to handle any set of input elements. It's maybe more realistic to prepare a few sets of test cases, each comprising input HTML (a container full of elements) and an array representing the expected sort order. It would be a fairly minor challenge to run a sort and compare the resulting order of DOM elements with expectation. 

Answers to your questions 1. I find it hard to judge either "Sane" or "Decent". I think "Clean" is more important: single responsibility, clear separation of concerns, no side-effects, etc. Reading Clean Code by Robert C. Martin can be invaluable there. 2. If the set method actually set anything this would be less clean as it causes side-effects. Since it is really only another getter, there's no real problem. 3. Yes. This can become problematic. The best thing for it is simply to learn how to write unit tests (it honestly isn't all that difficult) and having tests with your code will teach you how to create code that is easy to test. 4. Yes, the array in setConfigData() is set again every time data is requested by . This is because it is being used from local scope and not from the class scope since it does not have a in front of the variable name. You don't need to make the array an object to resolve this, just load it from class scope using . 5. OK or not is mostly a point of view. Most folks will probably think it is fine. In my personal taste the conditions could be cleaner/less muddled. 6. Yes, MAJOR issues. Configuration should live outside of the class. It can be injected into an object at the point where it is being instantiated. You really don't want for me to edit the framework code when I want an application I build on top of it to alter its behaviour! 7. Personally I would not put all of that functionality into one method. I'd create separate methods for separate scenarios to keep the class signature (or interface) simple and easy to understand. In closing If you feel inclined to look at this from other angles, you should probably also take a look at other data structures that can/could be used for configuration other than an array. For instance, the ARC config component uses a tree structure. If any of my comments seem unclear or need more elaboration, don't hesitate to ask. I will update my answer as needed. Furthermore, as you stated that building a framework was mostly about the educational values, I think you will agree that something as essential as configuration has a lot of lessons in it. You seem to be learning them quite well. Keep it up! 

General impression You are not actually injecting any of the dependencies into , you are injecting a service provider that has to locate the dependencies. It may feel like dependency injection but it really isn't. What you are doing here is, basically, creating spaghetti code. Suggested improvements My question would be: What is the responsible for? Your UserProfile class depends on a View, ORM and FormBuilder class. It is in control of retrieving the user from the DB, outputting a header and outputting the user in the view body. The FormBuilder does not even seem to be used. There are several ways this could be cleaned up, for now I'll use "classic" MVC. Assuming (based on the function name) that this class is primarily a View, it should only need the user Data and your ViewCreator to function. Your router would call the Controller that would retrieve the Model and pass it on to your View. The suggestion below completely removes the service locator from the picture. Please note that the code is written for clarity in conveying the message, it is not meant to be 100% working or correct (especially the static call syntax in the controller). 

The worst issues are cases of the same element being selected multiple times in order to apply various methods. Repeat selection of the same element should be avoided because selection of DOM element(s) is expensive. There are also are cases where multiple selections have the same method applied. This isn't so bad for performance, but leads to unnecessarily bulky source. The code can be improved with the following techniques : 

Macro Observations As written, is a jQuery static method, not a plugin. It seems more appropriate to write it a genuine plugin, and invoke it on DOM element(s) with . You will then need to purge hard-coded selectors and take great care to ensure the independence of multiple invocations. Strict mode will help avoid making certain mistakes. You may get error messages in your console. Try passing the code through jsLint to check for unused/undeclared vars and heaps of other stuff. Meso Observations is "ul li a", therefore will select all ul,li,a elements on the page, not just the ones you are interested in. Try constraining the selection with something like . Probably similar elsewhere for other selections. is an initialisation function and would more conventionally be named . Default tab: Typically with this kind of functionality, you would write initialisation function devoid of code that sets the initial condition. Then, as a final step when all other initialisation is complete, emulate user interaction by triggering a click event to select the default tab. This approach can save much time and many lines of code. Micro Observations should be declared in the main declaration block with a good explanatory comment. 's local variable appears to be unnecessary. At the point where it is tested, it will only ever be , won't it? can be initialised simply as , same as . is rather oddly named given that it is used for jQuery collection object, not a reference. !? Look for unnecessary operations, such as : 

The expensive part of the opertion is finding the full set of qualifying TDs in the DOM, so you should avoid doing so more than once. 

Untested and includes a few assumptions, therefore may not be 100% correct. Be prepred to debug, or just raid for ideas. 

Timer as a widget Your timer is essentially a widget. As such, it would be more easily invoked by passing in a single container element and having all the internal elements generated on view initialization. Hence, most of the statements would become statements (or their jQuery equivalents). 

Presumably statamic statements allow you to include/exclude statements within tags. If so, then you can write something like this in the document's :