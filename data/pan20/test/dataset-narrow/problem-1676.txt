You can find these steps and more details in my blog post about doing this with archlinux arm images. The process is very similar for any raspberry pi distro. Note that you can mount the image directly, but with losetup you do not need to worry about offsets and various other things. It also allows you to manipulate the partitions/filesystem should you wish to. 

You are setting up stdout and stderr as pipes for the ffmpeg process, but never read them. If ffmpeg is producing any output at all then it will start to fill up the stdout and stderr buffers. The kernel buffers input/output to programs to stop them blocking for any read/write but they are of limited size. This is not normally an issue but in your case you never actually read from them. Once the i/o buffers are full any writes to them will block, this will stop ffmpeg from processing any more of its stdin, which your process will continue to write to. Once the stdin buffer fills up your process will block creating a deadlock. Instead you should either pass stdout and stderr of ffmpeg to the terminal (this is the default when you do not specify or ) or throw them away entirely (by setting them to and ) or read and handle them yourself inside your loop. 

This is much easier to read/understand and less likely to break randomly if you edit it slightly. You may be interested in this blog post on the subject of scripting the creation of raspberry pi images. 

The recommended power supply for the rpi 1b+ is 1.2A and for the rpi 2b is 1.8A you can find a more detailed break down here. Note that this is more then the maximum a pi + peripheral can draw. From what I can tell the device you listed is rated at 2.4A @ 5V, which is per port (2.4*5 = 12W per port, the device support up to 36W which you wont hit with 5V) so can drive both devices with plenty of room to spare. 

is what is syncing your time, normally it tries to slowly adjust the time to stop time suddenly jumping forward or backwards. The exception to this is when the clock is out by a large amount. This is likely the case when you boot, but still takes some time to adjust. You can force the sync your self with as root (select your closest time server from here). However you cannot run while is running, so you must stop it first. Given you are only booting the pi for a few hours the clock drift is negligible during this time (almost immeasurable) you do not need to run ntpd at all. Instead you can get your application to sync the time manually before doing what it needs to do with , once it returns the time is in sync. Note that sometimes it requires a couple of runs to fully sync up, luckily ntpdate reports the current offset in its output, you can parse this until it is an acceptable amount. 

With running on the pi you can run on your computer and see them communitcate. Now you can expand these programs to do anything you want. 

Mount the loopback devices partition, most pi images have two partitions, boot and the root but your might vary. 

Its quite simple to modify raspberry pi image files. The only requirement is a linux box and if you wish to run commands within the context of the image (aka in a chroot). The basic steps are: Loopback mount the image: 

The hardware handles the bootloading stage on the pi and knows how to boot the linux kernel without looking at the mbr record on the disk. Therefore you do not need to do anything special to boot the pi besides having all the expected files in the /boot partition. What you are doing is similar to how the archlinuxarm image is installed, format the drives and mount the drives and then dump the contents of the root filesystem into the mount point. You should not need to do anything else. 

When you get to the command you only have 1 partition, so fdisk auto selects it since you could not possibly mean anything else: 

They are both single cell 3.7v 2000mAh batteries - they are effectively identical as far as power is concerned. They might be slightly different shape but that is all. Also, any 3.7v single cell lipo battery will work in its place, the capacity (mAh) will affect how long it will last for before needing to be recharged. You can opt for a larger battery if you require the project to run for longer, or smaller battery if you want a cheaper/smaller form factor. 

DHCP servers just listen for dhcp broadcast messages from devices requesting ip addresses and responding with an ip address (as well as some other networking related information). It does not cause traffic to pass through the DHCP server. In order to monitor network usage you need to see the network traffic to monitor it, which means you need the network traffic to pass through the device that monitors it. Devices attached to routers and switches do not receive all the traffic that passes through the router or switch as they are smart enough to learn where to send most traffic and avoid it being sent to all devices. Network hubs do not have this problem, they forward all traffic received on one port to all other ports. So if you attached a pi to a hub it would be able to see all the traffic sent through the hub and thus track/monitor it. But you already have a device that can monitor all traffic through the router - the router. Most decent routers can already expose this information and if you are that interested in networking it pays to invest in a decent router that does what you require. 

From here you can add/delete/modify any file in /mnt and it will change in the file. Once you are done simply unmount and detach the loop back (see below). If you need to run a command inside the image then you can chroot into it. For this you need qemu-arm-static to emulate an arm cpu and allow you to run arm binaries once inside a chroot. Assuming you have it installed: 

You might want to look at resin.io. They offer docker based raspberry pi os that you can install on your pi as a one off - then deploy and deploy your application by building a docker image which gets pushed to the pi - no need to reboot the pi or even touch it after the initial install, everything can be done over the network. The basic workflow they offer is 

It looks like your version of npm is too old to support scoped packages which blessed-contrib is making use of. But it is only using it for a dev dependency. You can try doing a production install to skip it with 

The principle is the same as for a wireless -> Ethernet bridge, you just use a second wifi dongle in client mode in place of the Ethernet connection. 

Then reboot. The terminal program running on your computer should be silent for this boot. Python Serial Listener Using python you can read from and write to a serial device using pyserial. Start by installing pyserial on the pi: 

Simply drop the after the and it should work. Alternatively move the to after you have created the second partition. Note that fdisk is really meant to be an interactive program. or are better suited to scripting. Here is what I generally use to set up raspberry pi images: 

The pi has no inbuilt real time clock (RTC), when booted it has to guess the time, on the first boot it will default to epoch (the beginning of time for computers), specifically January 1, 1970. Current distros also save the time on shutdown, and restore it on start up which means most of the time you will get the last date/time the pi was running. The pi also uses the cpu clocks which are not accurate for tracking time over a long period of time without slowly drifting and without an RTC it has no way of tracking time while powered down. You can get external RTC modules that are battery backed, these give the advantage of being able to count time while the pi is powered down (so long as the battery is not dead) as well as being more accurate resulting in a smaller clock drift. However all clocks slowly drift (this could take years to be of concern). The network time protocol (NTP) was created to correct this. What it does is syncs the time with other NTP servers (some of which as backed by atomic clocks, making them very accurate). A constant connection to an NTP server is not required, as the cpu can count time while it is not connected, but when it is time will slowly sync up with the NTP servers. This does require an internet connection, either by ethernet or wifi. If ethernet is out of the question (even occasionally) then you can use wifi instead. If no network is available at all then you have to rely on the internal clock or external RTC to track time and adjust it occasionally (like you would adjust a watch). 

All of the GPIO pins can be configured for different purposes. At their simplest they can all act as general purpose input/output (hence the name). This means they can be set to act as an outputs, thus the pin can be driven (0v) or (3.3v). It can also be configured as an input where an external circuit drives the pin or and the pi can read this state. Some of the GPIO pins also have a specific alternative function. These alternative functions are tied to special hardware in the cpu which is why only some pins have alternate functions. Typical alternative functions are UART (generally also called serial, but there are other types if serial communication), SPI, I2C and PWM. UART is a bidirectional serial protocol, but can be used in a unidirectional way. It requires 1 pin for input (aka rx) and 1 pin for output (aka tx). This is why there are two pins labeled as UART. Pin 18 on the raspberry pi is a PWM pin (I think you meant this rather than PCM?). PWM is another protocol that can be used to send simple data, it does this by rapidly switch the pin from to very precisely and rapidly. The data is encoded in the width of the pulses, this is often used to tell servos which position to move to or motor controllers how fast to move. It is sometimes used to fake a voltage change such as in dimming LED. Due to the precise timing it need special hardware which is why only some pins have this function. All pins can emulate the special hardware functions behind the special pins by toggling the pins on/off in the way the protocol describe. But doing so is often slower or results in more errors due to missed timings. This is especially hard under linux on the pi as it is not a real time OS so has no timing guarantees at all. 

dev locally, run any local tests or anything else you can do on your host. use git to commit your code locally use git to push to a remote on their servers 

Run this on your pi and then use the serial program we used before to talk to it on your computer. Note that most serial program send '\r' when you hit enter, but the above waits for '\n', you should be able to send that by pressing Ctrl+J. Python Serial Writer Once you have this working you can write another python program on your computer (not the pi this time) to send the messages for you. Remember to replace /dev/ttyUSB0 with you actual serial device. Save the following to