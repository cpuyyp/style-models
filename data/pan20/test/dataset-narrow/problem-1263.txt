There are some other things that need to be taken into account. For example some stuff needs to be loaded even though it isn't visible. For example an enemy that is standing behind the player outside of the region would need to be active so they can run toward the player and attack them. Possibly the occlusion test stuff is unessential since you will immediately want to load anything near so its there when the player moves and it becomes visible but it could shave off a second to get straight to the render (but if time is that close then you are likely to get problems with stuff appearing). If possible those steps should be started before they are required, threaded off in the background. For example if you are at the main menu of the game then it should start to preload the starting area the loads after you choose "New Game" (or as soon as the menu appears) and the last save for continue. Other saves can preload when you move the mouse over them. As you approach a dungeon door, it should start to load the next level (although if you can do that then you don't need a special dungeon door since they are really only to trigger a loading screen). Load in the background while the video plays. That way you wouldn't even need a short initial loading screen. You can skip a lot of that if you don't mind stuff 'popping' into existence. Something like Second Life just leaves you with stuff appearing, since its being retrieved from the internet there's not much you can do about that. Assassin's creed has that effect where stuff whooshes into the scene so you might be able to get away with stuff for artistic reasons. 

Firstly look up basic spacial geometry formats like Octrees and BSPs. As for your actual map level format, chances are you will want something very customized to your game. Are you using 1 giant mesh for your game world (Like a FPS), a bunch of modular meshes something like an indoor Skyrim area or for the outdoor areas they would also probably have a heightmap (Stored as a texture? maybe a bunch of floats? Maybe inputs for a procedurally generated algorithm). Do you want a massive open gameworld like GTA/Just Cause or a bunch of small detailed areas? Do you need to embed lighting maps or is that done on the fly? Custom meshes/objects or all build from components? You might actually want to start with something like XML or ASCII and just convert it into something binary at a later point once you have your details hammered out. You might find the XML gives you good enough performance anyway. idGames actually use plain ASCII for their stuff and in doom3 at least it compiles most of the stuff on load since lighting now doesn't need to be prebaked as it's done on the hardware. It's split over a few different files but I think they are all ASCII (even the 'compiled' stuff). So you don't really need any superefficant packing methods. You can look at using formats that are outputted from 3D modelling software like 3D Max, Maya, Blender and so on. That way you don't have to make a level editor. But you will have to find a way to embed game information in your 3D scenes. COLLADA is a very general purpose 3D XML format. But it might be a bit too general and feature rich and requires some parsing and cleaning up. You will also have to fidn a way to gameify it (Maybe 1 file for overall level layout while keeping your mesh stuff in another file or even different format). Some other random advise would be to give every object a unique id (at least the non-static ones), that way you can easily save/load just the changed data. It would probably also help with network replication for multiplayer. Other advice would be to split up everything. Don't try and embed textures in your level format. If you do want to pack everything together for redistribution just zip it. 

Having the central control object will allow you to fall back to the old ways of doing things. usePhong could either change which uniform subroutine is set or change which shader is in use depending on what is supported. Setting variables could either update the shared buffer object for all shaders or set the uniform variable on the shader (although you have to keep track of which shader will need that variable and if you need to resend that stuff when you swap to a different shader.). You can also look at using #include in your GLSL sharers. It's not in core yet but is an ARB extension so it works on at least nvidia (not sure about AMD). If you don't have it on the platform you can have your shader loading code do a quick search and insert the code manually, if you do have it then you need to load the files into OpenGL's "named strings" in advance. That way you can write 1 bit of shader code and #include it either inside a routine function or a separate shader. You might even want to go further and write some code that will generate the correct shaders wrapping code for your supported extensions. 

Depending on the specific requirements, it might be better to use a color picking system rather than converting the coordinates back manually. Basically give every selectable object/tile a unique color and when you render the object also render it's silhouette to a secondary unseen buffer. Then when the user clicks look up the color at the coordinates they clicked and look it up. This would allow you to ensure that what the user clicks on is what they select. You could select a plane flying high above the ground for example. Or pick out a object in a stack of overlaying ones. It is also more general solution that could work with any rotation and completely different engine types. You can even expand on it to do per-polygon picking in 3D. Of course it has the cost of some extra memory (for the buffer) additional rendering time (possibly a 2nd pass depending on what you are using to render) and having to keep track of the objects. Neither of which would be an issue on any hardware now days (or decades ago even). 

I have been encountering some problems too. What I have found is if you don't specify the context version or use core profile it seems to load the latest version of OpenGL without issues. The glew error might be because of it using the older glGetString(GL_EXTENSIONS)â€‹ rather than glGetStringi. You might be able to work around it by using glewExperimental=true before calling glewInit(). See here. Otherwise you can drop GLEW all together and use the official Kronos OpenGL extension header glcorearb.h (previously it was gl3.h). That won't load 3rd party extensions but it seems to work fine for what I have been doing (not sure if it's suitable for large projects or not it's only listed as a reference implementation). Also make sure you have called glewInit(). You can check if an extension is enabled with: 

If your a small company don't bother with DRM or copy protection, or if you do just make it a very token attempt. While personally I don't agree with people calling DRM totally useless because it gets cracked (I do agree that all forms of DRM short of online streaming will be cracked). Financially DRM probably does make sense for large companies, just because those games do get cracked doesn't mean there isn't enough inconvertible to people who are not that competent when it comes to pirating (this can inhibit school yard/soccer mom piracy), or impatient to wait for a crack. That horrible highly invasive always online DRM for example takes weeks or even months to get cracked as they encrypt the game content with various different keys requiring people to play through them inorder to unlock all the keys. For most major games a majority of their sales are likely to be right after release. Although I think companies selling that stuff should release a DRM removal patch after a few months of being released. But a small/indie company doesn't have the same business model. Firstly you require your customers to be happy (large companies don't, they own established brands that you can get elsewhere and they are the only ones that can afford to spend millions of dollars on making highend games). Small companies rely on word of mouth. DRM is bad PR, people hate it. It can only be a bad thing for a consumer (unless you buy into the idea that more games sold end up with games being cheaper as a result but I doubt companies pass on the savings, that charge what they can get away with as they always have). The customers who buy indie games are normally willing to pay to help small devs also tend to be very anti-drm. Form a bond with your community. Secondly most indie games lack the massive hype that big AAA games can afford to buy. They will probably have a much flatter sales curve, it might start low and go up as word of mouth spreads or otherwise if you don't get word of mouth you will just get a somewhat constant rate of sales trickling along. Thirdly you just don't have the resources to implement DRM. You either have to code in a hole bunch of copy protection things or pay for an off the self solution. If you do use some kind of DRM just make it the most basic version possible. For a small game Piracy might actually boost sales. People will tend to pay more attention to something hitting a release site that one of the 10,000 $2 games for sale in some app store. The best thing you can do to stop piracy is to add online services. Either post frequent updates online, that add new stuff not just fixing minor bugs. Require an online username/password linked to the game purchase/key to start the game (but preferably with some purpose other than requring the login). Add multiplayer, ensure that the server code verifys a game/useraccount is legit with a central authority server. Have a game browser (Gamespy style) that pull in the games from the server. Multiplayer will only help stop piracy if the multiplayer is a big focus of your game. Multiplayer can be cracked but it's generally going to have much less players and more cheats. Allow users to create game content/mods and share it with each other through some site/integrated ingame thing. You can host the servers yourself and ensure the client doesn't have the server code, this is what MMORPGs do, I wouldn't advise it for non 'massive' games. Another thing you can do is sell through Steam. People love Steam. People love steam sales. You could also try getting into the next Humble Indie Bundle if you make it cross platform. Sell your game cheap. People will buy a legit copy of a game if its only $5 (unless it looks really basic like a tetris clone), $10 if it seems like a fairly solid game (decent 3D graphics, gameplay, etc...). The problem is what people are willing to pay and what is worth it for the game developers don't necessarily line up but there will be a price point where people who would have pirated it or passed it over will buy, you might make more money selling for less. Just accept piracy. There is a whole bunch of talk that if you make a really good game then people will buy it to support you rather than hitting a torrent site. Maybe that's true for a small % of the community but pirates don't go by how much they enjoy a game. I doubt Minecraft would have sold as well as it did if it wasn't for the online portion. 

The choice between using an array (a good choice for tiles), or a list/quadtree will depend on your data density. For tiles you know you will have 100% data density because each cell on your map requires a visible tile (although for a massive 'growing' game world like some kind of a Tile based MUD this might not be the case). Choosing between a list/quadtree will probably depend on your total object count and the types of operations you are performing (a list would be quicker for updating every object once per gametick, a quadtree would be quicker for locating an object based on its position in the game world). But you don't have to choose just one representation. You can store reference (pointer/smart pointer) to objects in multiple different data structures. Rather than scan though all your objects every game tick, just make a list of objects that need to be updated and also have them in a quadtree for position lookup information and rendering purposes. This way only objects that need to be updated will be check. Just remember to remove them from all the possible locations when they are destroyed. So don't have any operations that require you to 'scan' your map, that will kill performance. The possible exception to this rule would be path finding. There are also many kinds of 'lists'. Rather than a basic 'linked list'. A que or cirque might be a better choice for a list of things to be updated. You will want to learn about different data structures (or containers in C++ terminology). There are different types of 'arrays' as well. Some kind of dynamic array (or C++ vector_ might be a better choice if you need resizing (maybe you want a client to request chunks from the server based on the resolution of the screen, so you need to be able to resize all your arrays on the fly. But that is probably overkill for most purposes, it would probably be simpler to just blow away your arrays. When it comes down to it, 'graphics' and 'game' tiles are basically the same thing but the graphics could use much more data pertile since it has to have the rendered graphics there. Both of them can use the same buffering algorithms to store nearby tiles. For the 'game' tiles, 1000x1000 isn't a huge number of tiles on a modern system. You could probably load the whole thing into memory in a grid array. At 4 bytes pertile (just enough for a int for a tile index id, it's about 3MB) At 32 bytes a tile (kind of a lot, it's 30MB). This is only the game datastore side of things, for graphics prerendering the whole map into memory would be excessive. Although you could probably get away with having all your tile sprites loaded in at a set and just using an index pertile and looking it up on the fly when rendering, of course then your maps are limited to a specific 'style' such as 'dungeon', 'snow', 'desert', 'forest', etc... Something like Zelda would have worked that way but now days I think we can do better and remove the need to limit graphics to a fixed set. So for the graphics you will defiantly want a buffer system A game like Minecraft breaks the game world into chunks rather than loading tiles. This allows for an entire area to be loaded at once which is much more efficient. Also you can do things like memory alignment. Or having some chunks hosted on a totally different server. Minecraft uses something like 64*64*128, but for a flat 2D game you would probably want something bigger. But don't worry about things like memory alignment at this stage, optimize later. So for a MMO with a big map I would probably recommend streaming in the 'game' tiles into a buffer too (just like the graphics tiles). Just load chunks off the side of the screen. Do remember that the number of chunks you need will be based on the resolution of the client. Aim for having basically an infinity sized map. All you need to ensure is that loading the tiles is faster than walking the distance (not hard on a modern system). On the client side when you walk, don't 'move' all the tiles in memory. Instead have a tile_offset that represents the first left tile (either the buffer or visible tile). When you walk change this offset and load in new tiles behind it. You will also want a scrolling animation so have another pixel_offset that represents how many pixels each tile is moved over by (this will just cycle once per step). Use the % modulus operator to handle wrapping on these offsets. Chucks can be a hassle as you have to be able to handle boundary conditions. Another thing to consider is if you want your maps to be based on the client-side or server-side. Most MMO's use client-side maps where the client and the server have an identical copies that are shipped with the game (or possibly via an update). Something like a MUD or SecondLife has server-side 'maps' that are stored on the server and sent to the client. Server side maps allow for continuous changes to the game world, if you allow others to get the server software then also totally different worlds, and can even be edited live if you want. But the down side is they will delay the tile loading time, will need a larger buffer for tiles off the edge (in case there is an intermittent network interruption), it will put more strain on the server (since now it has to stream chunks/tiles to the client). You could possibly make a 'hybrid' version, where when the client enters a map it checks to see if they have the current version of it and if they don't will download it all from the server in one go (or you can download it perchunk to stop a 30MB transfer for a small edit to a single tile somewhere, or you could look at something that lets you make a 'diff' between 2 maps and just send the diff). The main difference between implanting client/server side maps will be where the 'game' tiles are loaded from. Either from disk (client) or from a network connection (socket). You might also have to implement the 'graphics' tiles transfer/synchronization if you want to be able to make new tiles as opposed to just maps. In that case you would need to transfer image sprites (simple file transfer would work fine), maintain a list of all the tile_id to image_file mappings, and transfer/synchronize that to clients. If you are doing a MMO you can try to separate the visual components from the ones that effect gameplay/physics. The server only need to know about collisions and any possible interactions. But this will depend a lot on your specific setup (is it pertile collisions or perpixel). For example World of Warcraft looks like a 3D game but if you think about it, it's probably only taking place on a 2D plane (I haven't played it that much so I could be wrong), they could theoretically treat the entire this as a 2D game at the server side.