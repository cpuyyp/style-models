I find it weird that the bootstrap class actually changes the configuration. Configuration to me is a read-only value storage. It gets written in the config object only once in the life cycle of the application request: When it's read from it's permanent storage. The AppController for some weird reason has dependencies on a session manager, a configuration object, and TWO database connections. None of them should be the business of a controller. The controllers task is to be the combining layer between the incoming request on the input side, a number of models that act upon the data in the request as the processing step, and passing data back to the response as the output. Analyzing the input data from the request usually is done by helping objects that represent HTML forms to do validation (none of the controllers business). The models usually make use of some database access or session, but this also is not for the controller to know. Preparing a response means to push some values into the answer, which might actually be rendered by a template, but this also is not really the business of the controller. When I look at your AppController class, I see that it offers a whole lot of methods that have nothing to do with controller tasks, but with implementation details of a concrete application. I see methods like , , , that shouldn't be there. I especially wonder why does not use the to terminate the session. It was mentioned before, but I want to underline that if you force all the application classes to be extended from your frameworks classes, you make it hard for others to use your framework. For example the - for some reason they have to be extended from your mother helper class. A much better approach would be to only force the implementation of an interface, and offer an abstract helper class that already has a basic implementation that can be extended if there is no need to build from scratch. 

If you know that your clients have Javascript activated, I would recommend you to go for the first version. 

But as-is, the never finish, because the input channel is never closed. So we need to modify the computation functions to close the channel after the for loop. 

I think having a at the very end is also nice to quickly check the type of result returned by the function. 

vnp and Peter Taylors suggestions are very good. One could go a step further and make nice methods on the type: , and for instance: 

But joining paths like this is not very pythonic (and might cause problems on windows). Instead, is what you are looking for. About the arguments You can take inspiration of the os.path.join even further and change the order of your arguments (and completely remove the branching): 

Your classes do too much different stuff Your classes do not implement proper dependency injection. But if they do, they have very weird dependencies that will fit a certain use case, but not all. 

You are doomed! Basically you try to allow an attacker to define which code should be executed, and you try to find out if you are smarter in detecting malicious code than him injecting and hiding it. The "EXEC" mode is completely insecure, we need not discuss this. But I doubt the blacklist mode is of good use either. I feel it to be insecure as well, but I cannot prove it in 5 minutes. For example, I can try to read any file on the webserver by calling . I can try to overwrite any file by using . I could install my multipurpose script this way that is called a second later, and you get owned. In the end, only the whitelist mode seems reasonably secure, but this is just a generalized form of AJAX RPC calling - and a very dumb one, because it is limited to single PHP functions, you cannot do anything more sophisticated. And if you really think about it: There are already plenty of working solutions to allow Ajax calls to do more useful stuff within one single call. Some of them are called "restful webservice". 

"callback pattern" shouldn't be frowned upon (they are used in "first-class functions" for instance: $URL$ $URL$ However regarding your code, I don't think that it looks like idiomatic go code. 

The method could also be faster if it didn't use . For instance, it could use the last 7 bits (from 0 to 127) of (or multiply the probability by 10 and use the last 10 bits - from 0 to 1023). But there is probably a bigger optimization regarding the generation + insertion in the database. Currently the data is generated and inserted into the database sequentially. You could do it concurrently with a channel and two goroutines: 

I would recommend Don't repeat yourself As you can see, the two branches of your are very similar. Instead you could do a 

Adding or subtracting monetary values is a common task. How can we add two amounts of the same currency? Simple addition. Let's add a method for it. Note that I add the method to the Money_Currency class, which can be discussed. If I do not want to do this, I'd need an independent class that does all the math. If you have such a class, try this different approach. If not, continue following me... 

Although it does plenty of things, it has no answer to the problem of how to actually recognize which currency any amount is in. Adding two amounts might be valid, because you add GBP and GBP, but might actually be invalid because of GBP and USD. Your variable would only contain the integer or float value. So split it up. First create a class that actually represents an amount of money in a specified currency. This can be as easy as making a class with two public values, $amount and $currency, but usually you do not want to allow write access to these, so the two values should go into the constructor, stored as private properties, and be accessible via get methods. 

As Pimgd stated, all your request are synchronous (and wait that the previous one terminates before executing further). To make the calls asynchronous I see two possibilities: 

Readability To ease the readability (and testability) of your code, I would recommend you to split it in multiple functions communicating via multiple channels. For instance, for the client: 

This code code should work (I can't test it), but the way the "address" is managed could be more elegant (for example to manage in case of multiple listeners). Here is a proposition, where each listener is in charge of forwarding the frames to a particular address, via a given connection. The main loop is in charge of maintaining a slice of all those listeners and forward every frame to all of them (without blocking). With this code, we see clearly, that only 2 connections are used (monitor and session), which might not be the best idea (I don't know how they behave when concurrent goroutines write data at the same time). To fix this, you should simply adapt the main loop. 

I have some criticism on details you didn't ask, but which should be addressed: Autoloading Make use of it! There is no need to make manual calls to . There even is a standard: PSR-0, which defines how you should structure your class and namespace names together with the directory and file structure. When I look at your code, I see some issues: Because the underscore was used as a separator before PHP got namespaces, it is considered a separation character in class names. Namespaces Make use of it! I cannot see a reason why the exception \DH_MVC2_Application_Exeption is located in the root namespace, and not called \dh_mvc2\application\Exception. It would be so much easier to simply inside the "\dh_mvc2\application" namespace. Whitespace and coding style Endless debates might occur, but I really don't like yours. Especially the inconsistent placement of parentheses. Personally, I'd rather prefer not to use that much spaces, but if you really have to, use them everywhere. For example, if you want to find the function "set_ini_default_paths", and want to make sure not to find "set_ini_default_paths_directory", you'd search for "set_ini_default_paths(" - which will find only function definitions, but not usage. To find these, you'd have to search "set_ini_default_paths (". Dependency injection Doesn't take place. Objects are created inside your class. There is no way I would be able to change for example the Config object if I'd use your class, I must use yours. I even cannot change the config filename! Include path Be careful what you add here. If a PSR-0 autoloader is used, there is no need to add anything to the include path. In fact, you'll get a good amount of performance if you include as few directories as possible, preferably only ".", to be able to include files with a relative path. 

A buffered channel is just a way to allow goroutines to be more independent when they are producing/consuming a channel. 

The key is the microserie and the value is the number of series done by the user. For microseries without any result, you will need a default value (0 here: . With a similar technique you can have the total number of microseries. 

Looking at your , I have the feeling that you are doing only integration tests (from the request to the database). You should split you tests to the individual layers (the current one if for routing: it could use a mocked DB). With this approach, the could be deleted (do only the setup that is necessary for each test). 

I didn't find much to say about your coding style. Maybe is not a perfect name: would be easier to read in my opinion (putting the at the end is more consistent with you other variable names) 

I must criticize your tests. They are not part of your question here, but available in your github repo. Your SlotTest does not test slots. It does test the page. Why? 

Bonus: It is easily extensible should new fields appear. Negative: Still a lot of code duplication for three basic comparisons... But we will address it: Extracting all basic functions into separate variables (an array would work here, too), and adding the field that should be compared to this function, you get an almost universal arsenal of comparison of object properties. 

Easy. And completely unrelated to your currency conversion so far, but it solves a problem you might have, unless you are only offering a web service that inputs amount and currencies and translates this to the other value. What about currency conversion? What about adding two different currencies? Decorator pattern to the rescue! You can build a decorator that implements the same interface, which wraps around a currency object and does the calculations for converting the currency. Let's fix the interface stuff first: 

go-torch beein able to generate a FlameGraph ($URL$ Here is a video introducing profiling in go: $URL$ 

Grid entity removal Maybe instead of actually removing the entities, you could mark them as 'visited' (via a boolean property). It might prevent some heavy memory usage. 

A minor refactoring might be to put the statement out of the loop. It makes a real uses of the and remove an indentation block. 

In your main, you "iterate over generators to create values for each key". You could actually create a "base" generator for this! It would be an array generator (10 elements, 0 nullPercentage) of objects (being the objects that you generate). Using @ferada's answer leads also to much less code (I also renamed to ). It uses embedding (one could further optimize, by using the as base - instead of ). There was a typo on the function : it should be and not (because returns between 0 and 99 included). Here is what I come up with: 

It converts currencies. It validates currency identifier. It fetches HTTP resources It caches fetched HTTP resources. 

Reading the tests, I do not really see how a single slot is to be used. I only see how multiple slots inside a page are used. Also, I only see tests for several GET methods. If I want to verify that the results that are coming out are correct, I somehow have to read the config fixture file - a secondary source of information. This situation actually is bad. I want to be able to read the tests, and actually CHANGE some input values in a certain test method to see whether or not it changes the output and breaks the test. If I cannot see the input, I cannot play with the values. One final improvement: If you include files, they can actually return a value. You do not need to define a global variable that will transfer the config values.