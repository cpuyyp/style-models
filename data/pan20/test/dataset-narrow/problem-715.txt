EDIT: This is a new answer now that we see the HTML and understand what the OP is actually trying to do. There is a much, much simpler way to do this. Conceptually, instead of maintaining manually controlled relative positions of every div, we just make them all absolutely positioned on top of one another with only one div visible at a time. To show a new one, we the current one (which we maintain a reference to with an class and the new one. Since they are all on top of one another, it makes a smooth opacity transition from one to the other. Here's a working demo: $URL$ You can change ALL of your Javascript to this: 

This version is coded to return for , but that can easily be modified to return if desired (which seems more logical to me). 

Use to set hours, mins, secs,ms to 0 Calculate the A-F hex value rather than a bunch of statements Returns a string from since that is always what is needed Put the multiplication multiples in an array that you can loop over rather than copying code Calculate the final string directly rather than using the intermediate object with first through sixth properties 

I'd really rather see this in a subclass of an Array rather than modifying the built-in Array object, but alas we can't subclass the Array object yet in most browsers. 

You could, perhaps, derive RecursiveObject from FlatObject. In the degenerate case in which all objects belong to a single lineage (every object has one and only one child, except the last one) and you have lots of objects, then your recursive method will try to use an awful lot of stack space, possibly failing with a stack overflow exception. The way to correct this is by avoiding recursion and adding a stack data structure within your function, which then works in a loop. But of course you would not want to do that unless there is a very clear possibility of such a degenerate case ever occurring. 

Version A is definitely better, as it employs a more familiar pattern to get the job done, and it makes use of bit of trivial code () to save you from duplication of non-trivial code. () I would trivialize the trivial code even more, by saying right before entering the loop, and as the last instruction of the loop. Note that even though this is two lines of code instead of one, its complexity is smaller, because it deals with constants, not with variables. I could perhaps give more advise if you explained what you mean by 'algorithm to position boxes in a grid'. A grid is generally thought of as a two-dimensional structure, but I only see operations in one dimension, on variables which are defined outside of the code fragment that you provided, so... what is this code trying to accomplish? 

Here's a jsperf that illustrates the speed difference: $URL$ If you had a much large data set, then it might pay off to put the values into an object to serve as a direct lookup index (faster than ), but that's probably only faster when the list gets a lot longer because there's setup overhead to build the initial index. 

In most places you are retrieving , I think you really want . You don't want to be using over and over again because you keep making a new jQuery object over and over again. Evaluate it once into a local variable are refer to that from then on: . Then refer to whenever you want it. But don't get confused because not all values of are the same in your code so some places will need their own . Declare all local variables like so they are not implicit global variables. I think you need to convert quantity to a number in because you use it in numeric comparisons later which won't work properly unless you make it into a real number: Your ajax has me baffled. You're loading into the clicked button? Is that really what you want to do with this line ? That doesn't make a whole lot of sense to me. What are you trying to accomplish with your ajax call? You don't seem to ever be using . 

Normally there's no need to specify the color to change from. You only need to specify the coordinates and leave it up to the flood fill routine to find out what color is at that location. I would define another method that is public, and make the recursive method a private implementation method. The public method would look up the color at the location and then call the private method. 

Update: As requested by David Harkness, I have knocked together an implementation based around a polymorphic Node object. I'm not saying this is necessarily a "better" implementation, but it just shows an alternative way of implementing the code that removes a large number of the conditionals. Note: It's not a fully working implementation. It's just a gist. I haven't bothered implementing and if you the same value twice it won't overwrite the original. I haven't done any testing on it, so it may be full of bugs. I'll leave it as an exercise to the reader to finish it off. 

It's neatly formatted and follows standard naming-conventions. I found it easy to follow the logic. I'm not sure why you switched from a to a . It doesn't buy you anything, and makes the code more verbose. (If you did it as an optimization, the effort is misplaced. These days, Java compilers turn simple String concatenations into StringBuilder appends behind the scenes. In any case, even if you were doing this trillions of times in a tight loop, the possible savings from StringBuilder would be negligible compared to the time to format dates and whatever I/O you're doing). Rather than using a method, you could create an (e.g. ) and one or more implementations. This would be a bit more object-oriented and more future proof. You wouldn't have to add the flag (or whatever future formatting options might be needed) to the interface, but have that knowledge in a specific implementation. What is the foreign character string when ? If it's not a typo, it might be worth writing a comment to explain, for people who can't read that language. I'm not sure that is the right name, nor whether it is necessary. You don't use a constant for the other date/time formats in the method. 

You need to find the item that is in the same block of HTML as the one being hovered. One way to do that is to go up the parent chain from the one begin hovered to get the tag and then use from thereto find that item in that block. You can use this code to do that: 

Correct (produces the desired result) Reliable (always produces the desired result) Robust (handles errors appropriately and is not brittle when things change around it) Readable and Maintainable (try working on someone else's code or even working on your own code 3 years after you wrote it) Appropriate Performance (most code does not need to be optimized for performance) 

There are problems with your readFile and writeFile functions. These functions are asynchronous. As such, the callbacks you pass to and to are called some time in the future, long after and have already returned and finished executing. As such, the return value you have in those callbacks just returns back into the bowels of the file I/O sub-system and does not go back to any of your code. So, as you have the code written, you have these problems: 

FYI, jQuery will also measure the natural width of any DOM element for you so you could also have a span that is styled with the right font that you insert this text into and then ask jQuery what it's width is. jQuery will temporarily make it position absolute (so it will layout to it's natural width) and then let the browser tell you how wide it is. This would be much, much more accurate than what you are doing. Letting jQuery measure it for you would look like this: 

Normally it would disgust me, but you appear to have a valid reason to use it, which stems from the pre-existing disgusting situation that you have to cope with these data objects that use ints. The only thing I would ask is, why can these data objects not use enums? What is it about their auto-generation that precludes enums from being used? I do not think that enums receive any special handling at the IL level, they are handled just like primitive types are. 

This class has a well defined role and by keeping it intact you are satisfying the Single Responsibility Principle. So, I would leave it like that. Perhaps you might want to look into how you could refactor some common code out of each method and into a separate utility class, but that's all. 

If you cannot modify , then write two helper methods, one for getting and one for setting the value of the day member of : Each method has a and modifies the appropriate member of . Good luck and have fun. 

I think you should add a numeric field indicating the order of a card relative to the other cards. You do not need to use it for anything other than sorting. Also, instead of taking the identifier of the enum value and doing uppercase and lowercase tricks with it in order to turn it into something presentable to the user, you should just store the name, too, as a separate string in the enum. So, it would look like this: (where 0 indicates lowest order for sorting.) Furthermore you can also add one more number, the 'weight' of a card, to use in calculations which determine whether a card beats another. In general, enums in java are very powerful, so powerful that you pretty much end up not having to use the switch statement with enums anymore, because you can include a big part of an enum's functionality within the enum itself. 

Here are two different ways of doing this, one using repeated calls to and one using repeated calls with a regex to . The regex solution requires the pattern argument to be a regex compatible string or an actual RegExp object with the flag on it. The option should be much faster than what you have since it avoids repeated operations and as a library function should be faster than your own variation. The regex option is a lot more flexible since you can search for phrases that match a regular expression. 

If you move and into an object called rather than just top level variables, you could also use a map-driven approach like this: 

You can combine the two identical assignments at the end into the same line rather than recalculating the same value again: 

Creating modules to contain shared code is a generally good idea. But, when working with async functions and their responses, you need to make sure you preserve full async response and error handling when you write cover functions that use async library functions. In this case, you missed some of that, rendering your cover function not fully functional. In addition, when covering a built-in function, you should pretty much make sure you're adding enough value to justify a new interface. Simple defaulting one argument is probably not enough change/improvement to justify creating a whole new set of functions that someone learning or modifying your code would have to become familiar with in order to be productive in your code (which would not be an issue if you just used the standard functions). 

To add one more thing to janos's review suggestions, one thing I noticed is that many of your comments are saying essentially the same thing as the code. I'd suggest leaving them out. Developers can read code and trust it more than comments, which often get out of sync with the code. 

A more drastic change would be rather than using , you might consider using the "Null Object" design pattern. That is, create a implementation of (an interface) that returns, for example, for any and for . This would eliminate a lot of conditionals and make the code significantly easier to read. 

The public interface of the class is nice and small. The code is laid out well and follows Java coding conventions. The tests have reasonable coverage. There is a lot of unnecessary looping and casting in your code. Here's a more concise version that passes your tests: 

Having lots of conditionals makes code difficult to read, which is reflected in the fact that you've had to put comments throughout the code to remind yourself how it works! How about this... 

Other than that, you have implemented the algorithm correctly. It's worth noting that the way this algorithm uses recursion could lead to a stack overflow for a large block of color. Also, by dint of the +1 and -1, will end up calling fill() multiple times for each cell. 

And, you'd have appropriate CSS for a testItem span (see the jsFiddle demo for details): jsFiddle demo: $URL$ 

What you have looks like it would work just fine. Declaring the structure does not execute the functions you've assigned as properties. It just defines the functions and assigns them as properties (waiting to be called later). You could save a little execution overhead by moving the static definition outside the function so it just gets defined once (I'm assuming this is private module scope so moving the symbol outside the function is fine) and change it to . You can also remove the and since neither add anything here. You're just returning a promise anyway so you can just return the promise directly without and . I also added more explicit error checking for the category name. 

is pretty harsh (removing all possible styles). If you're just trying to show the menu again when the width has exceeded a desired value, then you can just do this: 

If you can allow fetch to load potentially before promises are available, then you could use the fact that fetch presumably can't exist without promises in a native browser environment (because fetch returns a promise) and could use this shortcut: 

Note: You don't need accessor methods for these properties. They are directly accessible as properties of the object. If you don't want them directly accessible as properties (e.g. you only want methods to be able to access them), you can do this: