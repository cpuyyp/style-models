Once you've got the image file, you may wish to try as @eftshift0 suggested. I have no experience with it, and I can't comment further. Good Luck & let us know how you get on - your feedback will help others. 

[EDITED RESPONSE II] I will guess that the message may be due to some permissions issues between your RPi and your Windoze machine. If that's the case, your files are not actually corrupted. Your most recent update would seem to support this. I'm not familiar at all with VNC, but I've read this statement: Have you added your username & pwd to the VNC configuration? From the looks of it (your latest revised post), things with RPi itself are "as they should be". That is to say, you do have a mount point, and from the terminal at least, you can read and write to the shared drive. If that's not the case, please clarify. I do wonder if you can write to the folder through VNC? The permissions suggest you can: 

Starting the python3 interpreter will give you the prompt. Type a command, hit return, and see what happens. returns a code that informs you if it executed successfully. When I , I get a back, which means no error. Lots of good references for this sort of thing... here's one Hope this helps. 

My existing setup (XQuartz & RPi-hosted idle3) handles this fine. Both of the other commercial IDEs fail to return a value for , nor do they raise an exception/error. Maybe it's just me, but this doesn't seem like good support for remote development and remote host execution. I've been in touch with both vendors' tech support, and it seems they can't really execute this code on the RPi, but instead offer "work-arounds". So finally, here's my question: Does anyone know of a "full-featured" IDE that supports Python (other languages would be nice, too) that really and truly support remote development and remote host execution? 

My answer is only a slight variation from the one proposed by @MatsK. First, you should know that your question does not seem (to me) to reflect a carefully-considered set of alternatives. You haven't explained what requirement or objective drives your specification that you will use power from one supply over the other. But your question does have an answer - perhaps not the answer you wanted, but if this doesn't fit, you can re-phrase your question, and perhaps we can do better! Again, the "Diode-OR" arrangement proposed by @MatsK is the correct approach, although it may not address your preference for one supply over the other. I will attempt to do that here with a slight revision; actually I'll propose two different approaches. While you are considering all of this, you should read some more on the subject; here's an article on "Fundamentals of power system ORing". I've not considered the more complex design in this article (using a MOSFET instead of a diode) for this answer, as it just doesn't seem to warrant it. Approach 1: Use a LM2576-ADJ To give the LM2576 "priority" over the USB supply, you need to set its output slightly higher than the output voltage of the USB source. You can do this by using the "adjustable" version of the LM2576: LM2576-ADJ (brilliant name). As long as the LM2576 voltage output is higher than the USB, it will supply the current to the load, and the USB will supply little or none. The trick here will be setting it high enough to take the load off the USB, but not so high that you exceed the RPi specs for max voltage input. Schematically, the same as @MatsK's, but labeled to show the diffs: 

I don't think this is what you want to do... you've only got one wifi adapter, so both IP addresses will have the same MAC address. That's allowable, but without some routing/networking configuration, it may not accomplish your objective - whatever that is. 

I've been looking at doing something similar, but I've not actually gotten around to trying it... and so you have a chance to be a true pioneer here :) In addition, this is not the only solution, or even the best one, but it's the one I'm going to try. Note that the steps to install the dependencies and get the actual code are embedded in this post from Nov, 2016. 

The RPi needs a 5 volt power source with 2.5 amps of "capacity". There's a reasonably thorough explanation of the RPi's power requirements and options in this blog. You should read this. You may also wish to read this answer. Reading these will give you some general information and ideas, regardless of your background with electronics. With respect to power for your RPi, I'll assume that "mains power" isn't a practical option, and that you've determined the RPi must be powered from a "portable" source - a battery in other words. As you will not be able to power the RPi directly from your 6.4 volt battery, you have two (2) battery power options: 1) add a "voltage regulator" that will produce 5 volts dc from the 6.4 volt battery, 2) add a second 5 volt battery dedicated to your RPi. The simple and likely trouble-free option would be to obtain a 5 volt battery dedicated to your RPi. If you have the space, and weight budgets, you should consider this as a "place to start". You can find such batteries at several shops; here's one that may suit your needs. To add a 5 volt dc regulated output to your existing battery, seriously consider a "series pass" regulator. They are simple (at least externally) to use and inexpensive. If you take this route, you have another decision to make as there are two approaches: 1) DIY, or 2) BUY. If you want to go the DIY route, look at this linear regulator from TI. If you want to go the BUY route, here's a switching power supply that is certainly inexpensive, and it might work. Finally, if you take the "single 6.4 vdc battery" route, keep this in mind: The RPi is sensitive to power fluctuations. Power fluctuations can cause some really odd behavior that might not be easily recognizable as such. To give yourself the best chance, consider decoupling the RPi power source. I've included a generic schematic below to illustrate "decoupling". 

I have a strong hunch that @ChadG and @joan have identified the issue: power. RPi's are not known for their robust power supplies, and (we're guessing) you're using a battery for Pi power. That could easily compound the problem unless you've taken steps to isolate the RPi from the car and its motors. The solution for you is two steps: 

Unfortunately not... unless you made a backup, or saved the files somewhere other than on your SD card, the installation overwrites everything that's on the card. Looking at it in a positive light though, you've learned a lesson that all of us get "refresher classes" on from time to time. 

CONCLUSION: started in and therefore controlled by After reading and reading some other forums, it seems there is some question as to exactly how to do this; i.e. 

and you'll create a "schedule" for executing your Python program. Also, Debian (and therefore Raspbian) support non-standard schedules, including which runs a job/script/whatever when the machine reboots. Lots of online resources available for "hacking" cron: 

This script (call it ), simply pings all possible IP addresses in your subnet, just in order to refresh your host's ARP cache. Once the cache is refreshed, do this to learn what IP address your Raspberry Pi has been assigned: 

I feel the easiest way to configure wifi on your RPi is to edit the file on your microSD card. In your case, you'll remove the microSD card from your RPi, put it in a suitable card reader, plug that into your Windoze/Mac/Linux laptop/desktop, and edit the file in your favorite text editor (see NOTE below). Once you've made the necessary edits, re-insert the microSD card in your RPi, and you'll have wifi when you boot up. There are some instructions on what entries are appropriate for the wpa_supplicant file here, but don't be confused by the fact that this guide references /etc/wpa_supplicant.conf. It's the same file that's in . NOTE: on current versions of Raspbian is an SMB partition, and so is accessible from any OS and editor! 

But this is NOT the default, and therefore the man page is INCORRECT as MUST be specified for this to work in Stretch. (see above) 

I hate to be the bearer of bad news, but you can't do what you propose (at least not in a practical way). Reason is that Raspbian is compiled to run on an ARM processor, and AFAIK, there are no laptops with ARM processors that also run an OS with support for VMs. In other words, a true Raspbian VM will only run on an ARM processor, and therefore won't run on your laptop. There are Raspbian VMs to be sure, and you can download and run them on your laptop. But they've been compiled for execution on an Intel processor. Consequently, they could not be plugged in to your RPi. 

I don't think you want to use the voltage coming into your flat on the doorbell wiring. Instead, you want to use a change in resistance that results from the "switch closure" when someone presses your doorbell. I'll hazard a guess that 3.51 volts you measured is being supplied by a transformer/rectifier somewhere in your flat, and used to power the "buzzer" you currently hear. If all this sounds confusing or complicated, have faith that it's only my explanation, and not the reality of it :) The general approach I feel you should use is along these lines: 

One possibility: You may be attempting to make a connection to the wrong host. Have you verified, or do you know for certain, that is the address of your new RPi? Try this: 

Whereas Jessie & earlier were happy with or , Stretch insists upon The man page for states for the version option: 

An RPi MAC address will begin with , so if there's any doubt that it's an RPi you're trying to connect to, the arp command above will help you verify that. 

Your question is a good one, but it may be a wee bit misleading. I say this because the life of your RPi will be shortened by running at 55.8 °C compared to say, 25 °C, but it will be lengthened by running at 55.8 °C compared to running at 75 °C. In general, heat is the enemy of semiconductors, and electronic components in general. You can think of heat as being analogous to blood pressure in humans... keep your BP low, and you'll live longer and healthier. In other words: "in general and all other things being equal", the cooler you can keep your RPi, the longer its life will be. That said, I don't feel that 55.8 °C is excessive, and you will likely get quite a long life from your RPi at that temperature. Your actual experience will depend upon more variables than is possible to enumerate, and lifetime predictions for electronics modules are generally modeled in statistical terms. But I don't believe anyone has developed such a model to predict statistical parameters for the expected life of a RPi. Nor are they likely to do so as this is generally an exercise in uncertainty, and undertaken by organizations with deep pockets; e.g. NASA probably did studies for components of their Voyager project. In case you're interested, many of the models for semiconductor life dependency on heat are based on a physical law known as the Arrhenius equation. There are a variety of resources online that explain the physics behind semiconductor aging and temperature - this one is reasonably good. Again, if you're interested. I believe it's far more likely that the technology cycle (e.g. Raspberry Pi 4) will bring about the end of life of your current RPi than operation at 55.8 °C :) 

simulate this circuit The game in this circuit is diode selection. Both should be Schottky diodes; the one for the USB supply should have a slightly higher forward voltage drop. Ideally, the load and temperature curves for Vf will be similar. Again, the diodes here are not optimal, as that exercise is left for the reader. 

And no, you can't do it every 5 seconds! You'll need another solution if that's an actual requirement, but I can't even imagine why you'd even need updates every minute since DHCP leases usually last far longer. And finally, if you want to run this on reboot, put this line in your crontab: 

I guess you've been assigned that IP address by the (Raspbian) system because it's not getting a proper address from a DHCP server; if so, that clearly makes it your actual IP address! If you can't "figure out" how the network is configured, I'll guess it's not your network :) I'll also guess that whoever set it up knew what they were doing, and has configured a proper DHCP server for it. If I guess all of this correctly, then once you set up your RPi correctly, you'll get an IP address from the network's DHCP server that will actually route on the network, and you'll be able to access network services. 

Seems this is already solved, but wanted to add an alternative solution for starting a Python program (or any program for that matter) at boot time: open as follows: 

Once you've activated your vm, install picamera in the usual way. It should work - let us see what you're doing (commands, etc), and we'll try to help. 

I feel that's thorough enough for your time requirement in this post, but once you get this far, you can always come back and post more specific questions (and perhaps get more specific answers :) 

Airflow is more important than a heatsink; which is to say that no heatsink will be effective without some airflow - or some way to conduct heat away from the CPU. Also, for whatever airflow you have, the cooling effect can be improved with a better/bigger heatsink. The heatsink draws the heat out, but it takes some airflow to dispose of that heat! When I researched and considered solutions a few weeks ago, I decided to go with a small aluminum "stick-on" heat sink, and more importantly: removed the cover from my case. Q: Why? 

Verify that your SSID (ESSID) is in the list. There's a detailed how-to for wifi configuration at the Rpi/documentation website if you want to setup wifi from the command line. And finally, the if you're running "headless" you can now edit the file in on the uSD card... actually, I'm pretty sure you can do this running "with head" :) also, but it's required for wifi access if you're headless. 

There are some who say no heatsink is necessary, but I find this "luddite logic" faulty. If I wanted a Pi that ran at lower clock speeds/had lesser performance, then I would have stuck with my older unit! OTOH, if you're OK with "throttling", then you can ignore all of this heatsink business. But if you're overclocking, then clearly you're not interested in a "throttled" Pi 3B+. 

Isn't it instead of ? And why invite problems by declaring arguments this way? And why use instead of ? I think the latter will lead to less confusion. And why use when you're getting started? And why don't you try this in the Python interpreter first to see if any of it is going to work, and not being able to see valuable feedback? Let's crawl a little before we walk :) Try this for starters: 

Yes, this new thing called "Google" is an amazing tool :) Reed-Solomon and convolutional codes do FEC. Reed-Solomon is actually part of the Linux kernel in some distros, but unfortunately, it seems to have been deleted from Raspbian. However, there are numerous libraries with source code on GitHub. What I don't know is how much (if any) extra effort is required to get these libraries to compile for Raspbian's ARM processor: 

That said, be aware that there appear to be some "issues" and new twists in the code in Raspbian "Stretch": 

I'm surprised and confused to learn that both WiFI and Ethernet have the same MAC address. It seems to me this could lead to confusion, but I'm not sure. Anyway, just be aware of it I guess - that's my answer... and my question :) 

Oh, this is weird... I was working on a different issue, and found something that might offer an explanation: You can refresh the ARP cache in your PC (Mac in my case) like this: