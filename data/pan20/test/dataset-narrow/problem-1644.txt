You need to configure your Pi to route between the VPN interface and its local network interface and then configure the Mac to use the Pi as a gateway to the VPN. You'll need to know address of the network you're connecting to when you connect your VPN; if it's not obvious from the configuration you can run on the Pi before and after connecting and see what new routes were added. I'll use 10.128.0.0/16 (netmask 255.255.0.0) as an example. On your Pi, once the VPN is connected, you need only enable packet forwarding with 

Bash can be started in three ways: as a login shell (interactive or not), as an interactive shell (but not a login shell), and as neither. (All following quotations are from the "Invocation" section of the bash manpage.) Bash is started as a login shell when you log in at the text VGA console, serial console or via ssh: 

Try to ping 8.8.8.8. If you can't, your Internet connectivity is broken and you need to fix that. Check your to make sure it has working nameservers in it. Run to check that it's producing good replies. Replace the nameserver in with (after checking as per the two steps above) and see if resolv.conf` is not being set up properly. 

determines only the resolving DNS server that local programs use; how that server resolves is up to the server itself. If you're using , that would be in the configuration in file and friends. Typically, a resolving server (unless it's specifically configured to forward to another resolving server) does the resolution itself. Asked to resolve , it will first go to the one of the root nameservers (from its preconfigured internal list) and ask about and receive a reply telling it about the nameservers that serve things under . Contacting one of those with a query about , it will then receive a reply giving the particular servers used by . Sending the request to one of those will finally elicit the answer (e.g., an IP address) that it's seeking, and it will then return the answer to the client. Which servers it goes to after the root servers, and how many servers it needs to query before it gets to the end of this process, depends on the particular domain name it's looking up. 

The Bluetooth adapter you're using has a chip in it that needs to have firmware loaded into it to work properly. As per this plugable.com blog entry, you need to download a copy of the firmware from here (the firmware is the same for the A0 and A1 revisions of the chip) 

(This will also display useful information about the certificate, such as the identity, who signed it, the validity dates, and so on. Be particularly careful to check the date range for which the cert is valid as that's a common source of authentication breaking.) Note that if a file has multiple certificates (it has more than one line) this will display only the first one. You can copy the file and edit it to remove the first certificate to display the next one. This is not at all a Raspberry Pi-specific question but an OpenVPN one generic to any Linux system, so if this answer still leaves you confused you should probably start by checking the more Linux-oriented Stack Exchanges for questions about similar problems. 

The Linux kernel is trying to load firmware from a file under to install it in to the device and not finding it. (In these cases this usually needs to be done every time the device is initialized.) The path given in the error message is relative to ; you need to find the correct firmware and put it in that file. There are several ways to do this. Install a Package Containing the Firmware There are a number of packages that contain open source or freely distributable device firmware; will list many of them. The easiest way to see if one of them has what you need is to use the command to search for a fragment of the name of the missing firmware file: 

One last note: please ensure you use a strong password on any SSH private keys. Remember, anybody who gets that file has access to system on which you've installed your public key! 

How do I make my device work? This question has been asked in various forms about various specific devices many times both on this StackExchange[1][2][3][4] and others[5]. I'm looking for instructions on how to debug and fix this problem in the general case so that I don't need top keep coming back with similar questions for every new piece of hardware. 

The first gives you a clue that it's trying to read PEM data; this is the data format typically used for SSL certificates. The second and third lines make it clear that it's trying to load a certificate and failing. The last line makes it clear that it ain't gonna run unless you supply such a certificate. It doesn't say here exactly what file it's trying to load, but if you go through all the certificate files you've configured for OpenVPN, checking each of them, you'll probably soon figure out what's missing. There would definitely need to be a server key and certificate, which is the most likely cause of this; there may also be client certificates to tell the server what clients are allowed to connect. Given a configuration line along the lines of (this is probably not OpenVPN syntax), you could check to see if the certificate file exists and actually has a certificate in it with 

The directory contains the configuration for the APT package system. In it there will be a file containing the sources for the base system and a sub-directory called containing further files also listing sources. (These files are added when you, other packages or programs you install add new sources.) Note that the files ending in are the ones that are actually read; the files ending in are backup copies of old versions of those files. You can search these files to find the two that have duplicate lines: 

NOOBS boots up just fine, and I configure the network as I did before, but now I see far fewer operating systems in the list: just a media player distribution (I forget which one), Raspbian+PIXEL, Raspbian Lite, and the empty partition for exchanging data between OSes. If I add (shows all available OSes regardless of your Raspberry Pi model) to the file and try again, I'm shown an additional version of the media player distribution (I think it added a "Pi2" version), but still nothing further. What's gone wrong, and how do I get back all the other operating systems? 

Whether , some other file, or no file at all is sourced when a non-interactive shell is started, such as with depends on the setting of the variable: 

The Arduino MCU is programmed with a bootloader that is able to reprogram the MCU's internal flash memory via commands sent over the serial port (which you talk to via a USB to serial converter). When the MCU is reset, the bootloader starts, waits a bit to see if there's a PC connected that wants to send over a new program and, if not, runs the program previously programmed into the flash by the bootloader. Basically, you want to do the same thing on the Pi, but the way the Pi boots is different. You don't say or provide links to the tools you're currently using to program the Pi or the details of what exactly you're putting on the SD card (what partitions you create and what files you put in them), so I can't really provide any help on how you might tweak them to be able to upload via USB. However, the general idea is going to be similar to the Ardunio in that you'll need to write a program that takes control on boot, decides whether or not to receive a new program over USB and write it, and then passes control to whatever's written. NOOBS does something very similar, coming up with a menu and eventually starting another system on another partition. The details of how it works provide a good guide to what you need to do. 

Details All computers on the Internet are addressed by IP addresses that look like . To help people, a system called DNS can translate names, such as into these addresses, but it's very important to remember that the Internet Protocol (IP) networking itself never uses these for communication, only the numbers. The way DNS works is that code on your computer called the "resolver" sends the name to a DNS server (which it obviously must know the IP address of) and the server sends back the address for that name. The message indicates a DNS error; this is on a level above IP connectivity. Here's how to start debugging it. The name resolution code in your system is trying to send messages to DNS servers to get the IP addresses of names like . To do this it must already know the address of one or more DNS servers. These addresses are stored in . If in that file you don't see any lines, your networking system did not add them. In that case you can try to get things working temporarily by editing the file to add a nameserver such as Google's public resolving server: 

If you've generated an SSH keypair with PuttyGen, the public key you can copy from the PuttyGen screen is in the correct format to use for this. The key comment field (which is at the end of the key in the text box) can be changed to anything you like as it's ignored by SSH. I suggest you use include the date and where or why you generated the key in order to make it easier to track what keys you've used where. Double-clicking on the file for a previously generated key will not load PuttyGen, it will instead load the key into PAgent. To view or convert the key again after generation you need to click "Start" and type "puttygen" to find the program, click on it to start it, and then use File / Load public key to load it. The private key file format used by Putty is not readable by OpenSSH, the SSH client usually used on Linux systems. To save a copy in a format that OpenSSH can read, click the Conversions menu and choose one of the Export OpenSSH key options. It doesn't generally matter whether you use the old or new OpenSSH format; all modern Linux systems can read both. Once you have the private key in a format that OpenSSH can read, you can copy it to your Linux system. There are several default locations that will try to read; is the most common of these. However, you can use a file from any location by specifying it with , e.g., . However, it's usually easier to use . There are detailed instructions all over the web for this, but the short summary is 

(The parameters are network address, gateway address and netmask of the network address.) If you have difficulties, the easiest way to debug is to use on your Pi. You can have it running twice in different windows with different options to look at the VPN interface and the LAN interface at the same time and see what's arriving and leaving on each. 

Debian 8, like many recent releases of major Linux distributions, now uses systemd to manage the daemons and servers, so you want to use to see whether it's currently running and the last few log messages and , and in place of above to perform those actions. Keep in mind that can take several minutes to start synchronizing time after a restart. 

If you've added a or file, your file will no longer be executed, and that might be why your is no longer being sourced on login. If not, check the contents of your to see if these lines have been changed or removed. Additional Information is sourced automatically if you start an interactive (but non-login) shell, such as by typing at the command prompt: 

You type and successfully log in to your Mac, but you didn't say how gets access to the private key you need to log in. Typically it will either prompt you for the passphrase for your keyfile (which file it will then decrypt and load) or it will use a key that you've previously loaded into an agent. The problem you're running into is that the TriggerHappy daemon, , is not running as you but is running as user . Thus it doesn't have your environment (for example, is different) and, even if it could find the file with your key in it, it can't type a passphrase. Fixing this without breaking SSH security isn't trivial. To do it properly you need to do the following: 1. Generate a new SSH private key that will be used only by user on this particular host (your Raspberry Pi) and store it in a file without a passphrase: 

If you don't have connectivity, either the name servers there are incorrect or your lower-level networking setup is not working. In the former case you can simply replace the nameserver(s) with one known to be working, as above (but do the same ping test on that one). In the latter case, you need to look at why you don't have Internet connectivity; your VPN setup instructions will hopefully provide some help here. You can query a server directly to see if it's giving you good replies using the command: 

Typically adding a web application to a server will make it considerably less safe. There are two main reasons for this. One is just that a web application itself has a much broader attack surface than an SSH server. A web application must process relatively (as compared to SSH) complex unauthenticated requests (to handle, say, login to the site) and there's a lot more and generally much more sloppily written software involved in that. (OpenSSH is just the one server and perhaps PAM until you complete authentication; even a simple login screen on a web site typically involves a web server such as Apache, a language interpreter such as PHP, a DBMS such as MySQL, and the code for the application itself, all of which communicate with each other in complex ways.) The second reason is that proper configuration of web applications and their associated software is very much more complex than configuring an OpenSSH server. Just getting appropriate SSL certificates and making sure that the keys are secure is probably more error-prone than an entire OpenSSL configuration. Beyond that you also need to handle configuration for all the other software, editing configuration files and making sure that, e.g., MySQL isn't listening on a network interface to which attackers might have access, you've got the right PHP interpreter settings (improper PHP settings can destroy the security of an otherwise secure application), your Apache is doing only just what it needs and serving nothing else, and so on. And then you need to keep all this software up to date, which is not as easy as a simple followed by a reboot. I suggest you stick to administering your system through the command line only, accessed via SSH. Make sure you've configured OpenSSH to disable root logins and password logins (but make sure you've tested your key based login first!) and ensure that you've got a copy of your Pi's host key in your on the clients from which you access it. In the long run this is considerably simpler (because there's so much less software to set up) than using a web-based control panel as well as usually more secure.