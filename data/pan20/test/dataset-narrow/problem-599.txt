I know you've found a solution you like for the final line of your code, but I'm a bit concerned with the overall performance and characteristics.of your code. Oh, I do have an alternative to your compactness solution but I will keep that for a different, shorter answer. Confusion of metaphors filters the lines from . does not. It transforms them from possibly-commented lines into lines with no comments. This may seem like a minor or pedantic point, but calling two different things by the same name can cause errors. would be a better name, I think. Overengineered and unsafe functions None of your three functions are stack safe. Each one of them is recursive but none of them is tail-recursive. This means that processing a large file could blow the stack. Each one of them can be rewritten safely using combinator functions, which are usually more efficient than pattern matching and explicit recursion (and gives an extra bonus that I'll explain later). filterComments This is not tail recursive because it prepends the transformed to the beginning of the list returned by . It could be rewritten with a tail-recursive inner helper function, but this function can be done much more simply as a ... 

You are doing the same thing to both a_counts and b_counts. Duplication that could be eliminated. You have a loop updating a mutable variable. A for...yield block would be one more idiomatic (and functional) way to do this. If one of your lists has values not present in the other, you are wasting effort totalling counts of those values. 

Using this way does grow the heap in proportion to the size of , because of the lazy . There are other ways to do this, still using the continuation-passing-style of Found/NotFound, which don't even do that. If such a solution isn't clear to you, I can provide one on request. That aside, using an Iterator to build the final collection is a win. As to variance, I can see no use for it in SeqLikeOps. Your aim here is to be returning the same collection type wherever possible and the same always. Any subtype of is going to be and you return , so variance has no purpose. Sticking with the direct use of the builder (which may give the best performance), you might want to consider rather than find. Then if it returns -1 or 0, you just return the original. Otherwise you can build using , and with no recursion or other tricks needed. Oh, and you forgot ... 

This does fix the issue of both and returning the same result. It also allows us to be sure whether an iterable contains passing or failing elements but only if we keep careful track of whether we're looking at even or odd indices in the list. That makes it difficult to fold or recur over the list or to perform other higher order functions (filtering, mapping etc.) which take into account whether iterables contain passing or failing elements. More Functional: List[Either[Iterable[T], Iterable[T]]] If, instead, we 

This is not an Enumeration and you have not called nextElement(). This is not an appropriate exception sort() should really take a list as a parameter and return a sorted list. Give it a list as a parameter; if a null is passed, Java will do you a nice NullPointerException, free of charge. If the given list is simply empty, return an empty list. Being asked to sort an empty list is not an exceptional error situation. It's no more an error than being asked to sort a list with 1 element, which you do show you can do. Which brings me to the more important stuff... Method and object conflated and confused. You've combined a sorting algorithm with the (hand-rolled) list to be sorted. It would be better to have a properly usable list class and either a mergeSort method on that class or a static helper class with a MergeSort method that can act on any list object. Then you could create a list, examine it to show that it was a well-functioning and populated list, create a mergeSort()-ed version, check that this was a valid list, that it still had all the right elements (none missing, none added or substituted) and that they were in the desired order. You'd have something useful you could do more with. List object cannot be tested/examined. This is part of the problem created by the previous issue. There's no way to get at the list data. You print it out on the screen, but it's inaccessible to the rest of your code. What use was the sort? Did it even work? How is this validated except by the naked eye? Since you don't print the unsorted version out on the screen, how does the viewer know you did anything? Make the list fully usable. Provide a way to traverse and inspect it. Then your code can verify the sort (and do something useful with the sorted data afterwards, if you like). Printing directly from within the merge class. Don't do this. Have your class methods return useful values which can be inspected and tested. Print out the results in your main method if you want, but don't litter your classes with println statements. Final, what? What do you think you are gaining with those final keywords? Those local variables are going to evaporate when that tiny method returns, so what have you achieved? I should go on to examine the actual sorting algorithm but I think I'll leave that to somebody else - it's late and I'm tired. 

You could convert the iterator into a stream. This has the lazy file-reading advantage of the iterator and doesn't have the touch-only-once limitation of iterators. However, it's actually a touch trickier than with iterators to make sure you don't keep the whole file in memory. Oh, and is a . Whichever of the 3 options you choose, you can still have and friends take/return either or , because all descendants have a method and vice versa. So you can write them not to care about laziness or how you actually implement it. Don't keep references (till you really need one) For different reasons, you lose some of the benefits of laziness if you keep references to any of the intermediate collections (including the output of ). With iterators, it's dangerous. So 

where values is some collection of booleans and values which CrockPotTree will know how to build into a tree. the apply function would need to call an append function recursively. In Option 2 style, Empty and Node classes would both have their own recursive append function. Secondly, I am not at all sure that Boolean is an appropriate type here. You might want to create your own binary type (if that really is appropriate for this tree structure). Guess what? It would also be an ADT (algebraic data type). I leave you with some useful links: 

Make the abstract class sealed (improves pattern matching performance and keeps the type sound). Create a BinaryTree companion object containing an apply factory method for creating trees. Make the constructors for BinaryTree and EmptyTree private (if the user can create them directly, they might create invalid trees). Make the class immutable. Turn each var into a val. 

With the apply method added, will return with no need for . It's a minor convenience, in the case of your simple class, but feels more natural. Note: It would also be very useful to add an method, for pattern matching. Ask if you need details. Implicit conversions This is not necessary for the scope of your current, simple code but if you intend to do more with your , it may be useful to be able to add fractions and integers and get fractions as a result). If you add one simple method to your class... 

Your loop detection will almost always take longer than the classic hare and tortoise implementation; in the case where the entire list is one loop, it will take nearly twice as long. Consider that latter case: You will not detect the loop until the slow node has caught up with the fast node, while the classic implementation detects when fast catches and passes slow. Your implementation will only return when slow has run once through the list and returned to the first node (and fast has therefore looped twice through the list). The classic method will return once slow has reached list.size() - 2 where list.size() is even or list.size() - 1 where it is odd (this is the point at which it will be lapped). In a list of 1 or 2 nodes, slow never moves at all. Adapting your version minimally to make it into the classic implementation gives this: