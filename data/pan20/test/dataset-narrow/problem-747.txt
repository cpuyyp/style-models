If you would like to make another project and use this class, you would have to copy it and change those values. That's not a good idea. Programmers hate copy-pasting code within their projects. This class could be made more flexible by not making it dependent of which project is using it. The best way to do that would be to store the constants in a project-specific class, and that the project calls your class with the resource-ids (such as ). Currently, if you've forgotten to call for a sound but try to play it directly with , you wouldn't hear anything. You could save yourself some debugging time from making it either log a warning or try to play a sound with that id. Using the values directly would help with this. Some final words As you've said yourself: This is working like a charm. Your code works, be happy! Really, I mean it. 

Method header Your method header can be improved, the generic type is not necessary, it can instead be written as: 

is not one float value, it's actually three floats. , and . In Java 8 you can use as separator. Android however, doesn't really support Java 8 code yet. 

It seems like what you are trying to accomplish here is to make your Queue class immutable. That in itself is good, but there are a couple of issues with your approach: 

It is especially important to use braces when you're code's not formatted properly, as it is easy to accidentally add an extra statement inside the , which would cause unexpected results. 

However, I would not recommend creating a Scanner inside the class, it would be better to create it in your method and pass it along to the Person class. 

I see absolutely no need to have these as . As it is right now, your code would get problematic if you instantiated one , waited for a while, and then created another game. Each should have it's own and values. 

SQL Injection-wise, this is completely safe. You don't run any risk of SQL Injection. However, some parts of your code is not optimal: 

Your code is very readable, well-formatted, very clear. Well done. You have implemented hashCode and equals well and all other methods look well-implemented. It's good that you define the only once. Your exceptions are clear and well-implemented. If I have to complain about something, it would be these variable names: 

Naming, naming, naming. OK, naming things totally correct is one of the hardest things in programming. But then there's also... bad naming. Instead of naming a variable something and explaining it with a comment like this: 

In addition to this, I also suggest adding to all possible fields in your class. Once your s and s has been created, they shouldn't be recreated again, right? 

You are currently creating one each time you are generating a number. objects are meant to be re-used (for "better randomization" - I know it sounds fuzzy but trust me on this one). 

Therefore, you're actually not saving any memory at all. (Technically you're wasting memory by creating a map for it, but that's so little memory it barely counts) Instead of creating a you might want to use setBackgroundResource() and setImageResource() (assuming you're using s) As for the name , I don't see what would be wrong with it. It's purpose is clear: A provider for cell drawables. 

@Pimgd were definitely on to something big in the last part of the answer, but not on to it enough. Simply changing to did not help much. However, what certainly did help, is to use a (as ugly as that type declaration looks). And to iterate through the List without modifying anything. It turns out that this change alone made the code NINE (9) to TEN (10) times faster. The new method is like this: 

I don't think that's a good approach. should be called by the Android framework, not by your code. It is automatically called by Android after a call to . 

Bug! In your program, it's impossible to use any operator besides addition. As Code Review is not meant to be a code-bug-fixing site, I think you should try to fix this yourself. Hint: The bug is in your method Now, about your question Yes, the template method is a good choice. Removing code duplication is always a good idea, which is I have to inform you about some other improvements you can make as well. Some things you should think about first 

Integer.parseInt Now, it's not clear which datatype you get from . If it is an (or ), then will be sufficient. If it is an Object, instead use Anyway, if possible, change the values you store in your to always be of the same type (, preferably). This would make your code cleaner as you don't have to use every time you pop something of the list. 

Hresult in the first part of the code essentially has no effect because it will be overwritten by Hresult in the second part. Now let's see what the common areas of this code are: 

The first time I read your code I was like.... "Wait, what?" Now I start to understand what you are doing here, but I have some comments: First of all, to answer your specific question: You don't have another option for this than to use try-catch. I would not use a private field for the flags, but rather change the method signature to return a , then create this set at the beginning of the method: 

Let's call this Matrix This gives us all paths of length two. We see that the paths from node a is . So that's two paths to itself and one way to . But still no paths to b, c, or e. So we'll multiply with the previous matrix, : 

First of all, Android supports some Java 8 features if you're using a gradle plugin. (Don't know if it would support this) Secondly, did it ever occur to you that perhaps the method you are trying to place here does not belong here at all? The class can just as well be placed as it's own class in it's own file. No need to be an inner class inside this interface at all. Static variable 

However, when you apply the advice above and encapsulate the inside the class, you can use something like this in your class: 

Also work on your indentation. Fixing the indentation, the if-logic and the string concatenation, and I suggest that you write your HTML tags with lowercase, this can be: 

Does it really matter if or ? No, it doesn't here. And if then neither of these current ones would be true which does the . So that's a giant bug waiting to happen. So those two first if's should be shortened into: 

Optimal solution: Remember all the visited numbers and for each number store the number of visited numbers. For example, for the number 3 the next number is 10. So calculate the Collatz sequence for the number 10 and then add one. Then when your outer loop actually reaches the number 10, you can use the number you calculated before as you already know the Collatz Sequence for the number 10. Hint: There is a good data structure you could use for this 

You are using instead of in your entire program. You can use a primitive instead, which is preferred. 

The most reasonable way to time Brainfuck executions is to count the number of instructions being performed at runtime. I added a feature to my Brainfuck Interpreter to allow me to easily count this. I also used a certain Brainfuck Developer IDE that includes a "Text generator" tool to generate BF code for your string, this tool produced the following code: 

If I want to execute an event whenever a property has changed, I override the corresponding -method in my code to do what I want to be done whenever the property is changing. There are way too many interfaces that has to be implemented/extended for me to want to use your code. I don't think it is worth all the trouble of your code just to make it a bit more typesafe, I would rather use the built-in Java Reflection API. 

These operations makes your code become \$O(n^2)\$ Additionally, it then afterwards does a operation which is \$O(n * log(n))\$ How to do it faster 

If I understand your code correctly, you are stopping Mario whenever his velocity () gets close enough to zero. This can be accomplished by taking the absolute value of (which will get rid of a possible negative sign) and check if it is below . If it is, Mario should stop. I think describing this as "stop Mario if his speed is too slow" is more accurate than "ensure Mario's velocity doesn't go below zero." 

These constructors can be removed completely without altering the behavior of your application in any way. As all they do is call , which is implicitly called anyway, and that you don't have any other constructors, they're not required at all. 

Right now you are mapping cardId --> function name in and then you are mapping functionName --> Actual function. When I started refactoring this to skip the name I realized that you really need it that way, because of the function. A comment about that would be helpful so that I don't try refactoring it again :) One thing I noted about the functions/abilities thingy though is that your only contains one thing: . Why not simply use the directly? always returns a table. I don't see the usefulness of this. You can make it return a single function and viol√†, it will have reduces table nesting. I managed to re-write your FunctionsList code to this: 

Java 8 If you are not allowed or unable to use Java 8, skip this section :) If you can use Java 8, there's a way to do this very smoothly. It may be a bit advanced if you are new to the Java language, but if you are willing to learn I suggest you check out IntBinaryOperator. Your can be replaced with . Operations can be declared like this: 

A nice thing about using an Input Component is that you can easily detach it from one entity and attaching it to another entity. Unfortunately you have not posted your exact code in this question, making it a bit of guesswork to fill in the blanks, but my guess is that your current code is directly tied to a specific entity which is supposed to be "controllable" by the human player. This is where Entity Component System has an advantage. It is Single Responsibility Principle at it's very best, and it decouples your different classes, a lot. Right now all your "states" that are making use of the Input "singleton" is directly tied to it. Reducing their reusability greatly. I don't think that the Entity Component System approach should be mixed up with the State Design Pattern as you have done. If anything, you can have the State as a Component inside your ECS, and then have a System for each possible state. Having more context of your actual game would have helped significantly here though. 

First of all, your does not contain any state, it is a simple input --> output operation not depending on outer factors. This makes it an ideal candidate for being a method. Your naming is okay overall, but I would use the name for your class. 

A few other comments: Even though it's not really 'up for review', there are a few comments I have about your framework class: 

I don't see any reason for why you want to call in a loop. Calling it once is enough. And there's definitely no reason to call it inside the method. Call it in the constructor instead. Additionally, it is possible to initialize that array in a more compact way. 

Not the prettiest one-liner I've ever seen, but I believe it works. Personally, I'd prefer a non-one-liner for this method. Writing code on one line just because you can isn't always the best option. Note that this uses the Ternary Operator, which you should read up on to make sure you understand it in case you haven't seen it already. Edit: As correctly stated by Josay in the comments below, the ternary operator can be re-written once more using boolean OR: 

I'll try to say this the best way I can... Completely useless unnecessary! Sorry. I couldn't find any better way to say it. The code that you have is well-written, but it is not necessary in the first place. The reason is that the interface Closeable already lists as a "superinterface", which means that . So all objects are already . Which means that your code: 

method: This method is slow because a) You're using a loop to find the gap b) You are storing the results in a . Solutions: 

There is one important thing missing on your and fields. What if I do ? That's right, I would break it. You must specify them as 

I also have to question the usefulness of your code. Hibernate is already an abstraction and does a great job in simplifying things. What is it exactly you want to make easier with these methods? Your current code: 

A method named provides exactly the same information as the above piece of code, therefore the method does not really provide any additional value. I don't consider as duplicated code. Or rather: I'm considering just as much code duplication as a call to .