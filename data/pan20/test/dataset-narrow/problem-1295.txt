How about adding a spring connection, i.e. force the object carried to move back to the carry position based on the distance, but still allow it to be pushed away by solid things (like walls). Constantly adjust the carried object's velocity (by changing acceleration based on position/distance) to point towards the position of the tractor beam (i.e. your second approach). If the object is pushed away too far, drop the connection (and the object). I'm not really sure why you'd need high velocities. Especially the "player lets go" case would indicate that your rotation velocity might be too high or unrealistic. Also don't forget things such as air resistance and gravity. 

Doing the animation in code would essentially be the same, just with the added step of rotating/adjusting the weapon frame based on the animation step (rather than using a different frame). This will safe you drawing time and texture memory, but it might look rather odd depending on your overall art style (it works fine with HD graphics, but it will most likely fail with classic pixelated graphics unless using special shaders to ensure "proper" rendering (e.g. to avoid lines getting removed while rotating or edges being too thick, etc.)). 

For an Asteroids like game, you could essentially do the same. Just use the x coordinate as your angle and the y coordinate as your rotation (or similar). 

So should you translate your game? That's really up to you, but if you provide localization, make sure it's good. While I can't speak for others, I think that playing a non-translated game provides a far better experience than playing a game with a bad translation. If I start a game or app and the translations clearly uses the wrong context, I consider it a lost case already. One very obvious example for this has been the initial release of Dungeon Defenders (might have changed in patches): 

The static boolean value will keep the code from running each and every call. I think .NET version 3 or so introduced the concept of static constructors, which would be the perfect choice for this, but you might not have access to it: 

I guess you want some ant like behavior (at least as far as comic ants are concerned)? $URL$ If so, I'd try the following: 

So choose either approach? You could most likely combine both: Done right, you can probably reduce the number of weapon frames to 2 or 3 per direction/animation (which might save you 25-50% for some animations) and just move the weapon's origin when drawing. Secret of Mana does this for some weapons in some animations. Although I can't give any specific examples right now (as screenshots), I'm rather sure that both the axe and javelin (and possibly other weapons) have been a perfect example for this, both consisting of only 1 or 2 frames in some animations. 

I don't think this is something you can answerin general. In my opinion this really depends on the actual gameplay. I'd split games into two categories: 

Since no energy is lost (perfect case), this means the ball will bounce back obtaining the same amount of energy. Due to the mass being constant, the velocity will be the same as well (just with changed direction). For a more realistic simulation, you'll most likely want to add in some friction though. Due to this the ball won't bounce back with 100% energy, but maybe 90% instead (the actual value can be adjusted to simulate different materials). 

There's no generic solution, as it essentially depends on how far away from the screen you are as well as the dimensions of your screen. Imagine the screen being a transparent window: Depending on how far away you're sitting (and the screen size of course), you'd be able to see a different amount of the world behind you, with anything outside a specific angle being covered by the window (screen) borders and the wall (or outside world). If you'd like to measure this for you personally, take your head's position and imagine two lines (or planes) from your head to each of the screen's borders. Measure the angle between those and you've got your own personal preference for a good FOV. This is especially important for FPS games. It's less about immersion, but more about being able to play the game without getting motion sickness. Not everyone is similarly affected and some might have no problems with game x, while having issues with game y. In general, just play safe and don't force any fixed angle. Instead, allow the user to choose an FOV. To avoid cheating, you should still limit the angle, but I'd suggest you do so leaving much room for configuring the game to the user's likings. Personally, I'd suggest allowing any value between 60° and 120°, which should be perfect for pretty much anyone. This can be a challenge for level designers as well as artists, but overall it should greatly improve user experience as well as review scores and the like (I always love TotalBiscuit going to options first, hunting for a FOV setting, and then starting to rage if it's missing (which I consider a completely legit and understandable reaction)). 

I'd simply transform the game/world coordinates of the target into screen coordinates. You might end up with a position outside the visible screen (like negative coordinates), but you'll still get directions for this. If the resulting coordinates are on screen, just check whether the target is in front of or behind the player and you're done. 

However, there is one downside to this: Moving elements will give you quite some trouble, because you'll have to update the lists they're in, if they move around. To solve this there are different approaches: - Create another set for dynamic content that is updated/recreated once every frame (might be too ineffective based on the number of elements moving). - Store the "parents" for every object and only remove/add them just-in-time when required (e.g. moving over a boundary). As for the actual implementation, that's really up to you, because it might as well depend on whether your game world is 2D or 3D. 

You should be able to use to limit rendering to a specific portion of the screen. Just keep in mind that you might have to adjust your matrixes as well. In C++, the call would be as simple as this: 

Finally, will set the monochrome color (which is actually grayscale again, 256 different values!) based on the grayscale value. represents white, represents black. 

But apart from that, there are some simple things you can try out on your own without having you to be some huge or awesome designer: 

It's rather easy to understand once you know the general idea: By multiplicating a value between 0 and 1 with ne number of steps and then rounding the result you essentially force the result to be a multiple of . With the final division you're scaling the value back to the range between 0 and 1. 

While Zhen's example code is perfectly fine, I'd use one big expression (might not be possible based on your actual language): 

So, how to store the data in a game file or submit it for a networked game? Pretty easy: Just iterate over the containing the deck and store/submit values if the value is not 0. Keep in mind that submitting your deck to the enemy might not be a good idea and subject to abuse (to see the enemy's/your deck). 

When the user tries to move, you're using a pathfinding algorithm such as A* to look for a route between his current position and the target position. You'd have to explore all possible paths till you're running out of options (impossible move) or you've found a valid distance (the move is valid). Whether you'd like to allow "too short" paths is a different story. While this is more complicated to implement (and setup), you'll have to clear advantage that your board doesn't have to be aligned to a grid. You don't even have to use uniform positions (e.g. some could be square, others round etc.). For presentation, you'll just need coordinates assigned to each node (they're not game logic related). 

Due to this (and probably due to simple logic, i.e. you have to setup what you want to draw first), I think pretty much any game will usually update first, draw second. 

For a highscore or ranking, you can now compare these ratings. You could do things like "highest rating overall" or "highest gain last week". To avoid people stop playing to Keep a good position you simply lower their score over time if they don't play at all. Just find a good name/system to actually visualize this. Just don't display raw numbers, as this might get People into number crunching, trying to manipulate it, etc. 

The basic steps are pretty much self-explanatory and there are multiple ways to approach this, also depending a bit on how you handle your game state, progress, etc. 

Your own idea isn't that far off. However, you'll have to multiply the final color, not the light color alone: 

The character is then moved based on the following rules: - If is not solid, drop down. - While is solid, move up. - If and both are solid, the character dies (squeezed). headhead` is solid, move down. Checking left/right works in a similar way. Doing this right will also solve stuff such as ramps instantly for you. Reading through the poitns above, it should be clear, that you essentially "bounce" the character instead of having him standing still. This is true, but the player won't notice, because you don't draw inbetween these steps. 

Another interesting question where I can cite that awesome quote I've found on the internet a few years ago regarding the creation of multiplayer games: 

This really depends on the browser you're using (not all support mp3). I'd recomend using mp4 audio. This should soon be supported by all popular browsers out of the box (actually I think even the Firefox stable supports it by now; that would mean all of them). 

Basically, you'll need some kind of container or collection to hold all entities. Then create some spawn or factory function to actually add them. When drawing (or updating) your game entities, you'll just iterate through this list and modify them accordingly. Here's some pseudo-code example: 

Of course, this is simplified a lot and this won't allow you to create caves, floating platforms, etc. However, those can be done as easy, you'll just need a more complex algorithm. Rather than checking a chain of points, you'll have to determine whether specific parts of your character overlap with map objects (= polygons). Edit: Since I've had a few minutes, I've created a quick example utilizing jsFiddle (Source). Just make sure to click in the results window and you'll be able to run around using the left/right arrow keys. 

This is actually rather easy to do. Just get every item some bitmask to define how/where it can be equipped. Some random example: 

Have you tried any other OpenGL based game? This sounds a lot like your drivers don't provide proper hardware acceleration (happens for some of the default drivers bundled with Windows; at least in the past). Also, might be useful to show your main application loop (minimized, to see how you update, if you wait somewhere, etc.). Maybe something is happening too fast (e.g. the time between frames would always round to 0) which essentially screws up something. 

Alpha blending in 3D is tricky, simply due to the fact that you're (usually) still rendering the quad (or polygon) to the depth buffer using the depth buffer, even if your visible texture is just a tiny part of that. To achieve proper rendering you'll have to render everything in the correct order, essentially from back to front. If you don't use the correct order you'll get weird things like objects disappearing behind otherwise transparent surfaces (e.g. water or something like the thing you experienced). For example, assume you'd like to render a scene with a sphere sitting in shallow water: 

Something like this can be achieved by using velocity/acceleration as well as dampening. A simplified example could be something like the following. , and are supposed to be vectors, but they could be single values (for one dimension, like forward trust) as well - you'd just have to modify the movement code. 

You'll just have to adjust your frame time based on your speed (or use a different animation based on your sprite's velocity). As for jumping, you'd either have to play the animation after landing or make sure you know you're landing soon, e.g. by having an invisible physics object below your character that gets notified of collisions in advance (but which won't cause anything else to bounce or anything similar). 

No, you don't have to use any specific toolset and you don't have to use any specific (physics) library either. It's just a question of convenience, since things like Box2D will provide you other benefits as well, e.g. being able to do collision, physics simulation etc. If you're not using tiles, you'll most likely want to write your own custom editor. As an alternative, you could as well use tiled to draw rough outlines that are then interpolated by the game engine to create smooth surfaces (this could get tricky to edit!). Creating smooth landscapes is actually pretty easy, but there are many things where you can optimize your algorithm. Here's a short example of some basic "smooth landscape": 

I guess what you're looking for is the Marching Cubes algorithm or some variation of it. Basically, you do exactly what you described: Look at the surroundings and then pick an actual "piece" that fits in. 

I'm not really sure on what you're trying to achieve here. You can't return a pointer to a string () and cast it to an integer (you can but you shouldn't do it). Instead, you should organize your whole saving in a different way (the following is pseudo code, you might have to replace or implement some of the functions based on your target system etc.): 

This should get you some basic movement. Based on your coordinate system (e.g. in which direction the y coordinate becomes bigger) you might have to negate one or more parameters. Once this is done, just apply the gravity as well: 

This is a really hard question to answer properly, because it really depends on the actual use case, your implementation, etc. The more similar the behavior is, the more likely you could handle them all with one class, but due to this not necessarily being the case, other options might be more interesting. E.g. if the only difference is their speed or appearance on screen, simply using some member variable might be enough for Differentiation (although being not 100% perfect). If you've got different behavior as well (e.g. pathing, passing through things, etc.), using separate classes might be the best way to go. On the other hand, if you're using some kind of component/system based approach to entities, just changing affected components might be the best Thing to do. In short: The bigger/more complex the differences, the more likely it's useful to split the logic into its own class/entity type. 

It's a simple sprite sheet of a guy running to the right (four frames of animation). While the first row includes the full sprites that will be tinted, the second row contains the non-tinted areas. To draw one of those characters, I'm using two sprites. Sprite one uses the first row of the texture and to draw colored clothes. The second sprite is drawn on top without tinting to draw the hands and face using their original colors. 

There are different approaches you can use. For a start, I'd use a rather simple (maybe even a bit naive) approach: You're essentially checking two points on your character for now: 

Ah! I missed the obvious reason for the odd behavior while first looking at your code (I think). Essentially, there are three potential problems here: First: Missing Updates Each and every iteration you'll update your game logic only once (or not at all). In a similar way, you draw your screen (or skip drawing). However, this causes one problem: