Again, add one, subtract two? Wouldn't it be simpler to just subtract one? But if this subtraction runs on Sunday, you'd end up on a Saturday, right? Should you something after the final ? Now it only returns anything if the test for 1 or 7 matches. algorithm Actually, I can't understand your algorithm from this code, so I can't say if it's correct. Mostly because of the confusing conditionals. I would approach something like this by writing the logic down, in some human language if necessary, and then implement that. (Actually, skipping a fixed number of days is almost painfully simple, since it'll always go from a known weekday to another known weekday. Mon->Tue, Tue->Wed, Wed->Thu, Thu->Fri, Fri,Sat or Sun->Mon, so 8,8,8,8,10,9 or 8 days ahead, depending on the starting weekday.) structure I think this could be condensed to a single function. Preferably one that would take the starting date and number of days to skip. Even if you need a larger class around it, it would be easy to just drop the function in as a utility. 

Though if you really want to be smart, you only need four conversion functions: Celsius to/from Kelvin, and Fahrenheit to/from Kelvin. (or with Celsius on the middle.) Doesn't matter much here, but if you wanted to convert between angstroms, mils, inches, feet, yards, meters, chains, furlongs, miles, light-years and parsecs, you'd appreciate a common "standard" unit to convert from and to. As for the function names, I wouldn't find it sinful to use even something like here, in the case of local helper functions that will not be called from the outside and since the units are so few that there's no place for confusion. (Of course with more units, like the 11 I listed, the latter point would not apply.) 

These should be in the function that draws the circle, as they're part of the logic of drawing, not the circle as an object. 

From a memory management point of view, your implementation is a linked list, that is, all items are allocated separately, and the next item is found by following a pointer. As the theoretical advantages of linked lists lie in insertions and deletions from the middle, they don't make for a very good implementation of a stack, where you only really care about adding and removing from one end. Especially here, when you're only storing a single number, the pointer to the next item is likely to be at least as large as the data stored, and that's not counting the space overhead of malloc. (Let alone the time spent on updating malloc's internal bookkeeping.) I would suggest storing the values in a single array, and resizing it with as necessary. Something to the direction of this quick mock-up: 

But, as you saw before, you have to optimize frontend and backend in different way. How to solve it is up to you. 

Complexity Sequence definition $$ F_{n+2} = F_{n+1} + F_n $$ which means that your complexity is \$ O(n) \$. Matrix definition $$ { \left ( \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right ) } ^ n = \left ( \begin{matrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{matrix} \right ) $$ As you can see with matrix definition we can improve complexity using exponentiation by squaring which tells us that $$ A^{2n} = A^n \times A^n, A^{n+1} = A^n \times A $$ Which means that complexity using matrix definition is \$ O(\log n) \$ Big integers Fibonacci numbers are fast growing sequence, so in order to store values you have to use arbitrary-precision arithmetic. 

You can find full list at codeschool At least you can replace your div#some_id with section#some_id which brings more semantical meaning. Если можно, я буду писать на русском (: 

Theory Fist of all check this article about memory management, it will help to find leaks if any. Look closer at this part 

Performance improvements related to approach Interger base For better performance we can split number not by every digit but by set of digits with given base. Look at Number.MAX_SAFE_INTEGER and some math \$ max\_number = 2 ^ {53} - 1 = 9007199254740991 \$ \$ digits = \lfloor \log_{10} max\_number \rfloor \$ \$ base = 10 ^ { digits } \$ Note: base will be lower by one if logarithm gives interger. What I want to say? \$ max\_number \$ can hold \$ digits \$ digits to be able to handle overflowing during additions. What meaning of \$ base \$ ? Currently you are using algo with \$ base = 10 ^ {digits} = 10 \$. Here you are performing modulo operation with base equals 10. Which means you are storing array with numbers that consists of single digit. But allows you to store up to 15 digits. Execute in you browser to find this value (do not forger to take floor of resulted decimal). Look at c++ example at e-maxx.ru for idea how to implement this. I have not found good enough english article, but you can use google translate. Benchmark base \$ 10^1 \$ vs base \$ 10^{15} \$ 

You can use 2 custom attributes instead of one. In this case you should not swap value, just replace it. 

Nodejs and preallocation Lets start with this test where we conditionally switches allocation from static to dynamic. 

... where did they come from? Proposals IMHO: following blocks should not be part of view, it's can be some util that implements needed behaviour. 

This is a bit confusing, since you're testing the date 8 days from now, but printing what the current day is. Why not just test if the starting day is from Monday to Friday, if that's what you mean: . Also, is True for values 2,3,4 and 5, but not for 6, which is probably not what you want. 

As for the code itself, I won't repeat what @Loki stated. But, you're not handling errors fully, a memory allocation error will leave the file opened: 

Doing extra work in printList The thing that most catches my eye, is that in , you first get the length of the list, then iterate over it, calling on every iteration: 

Straightforward, though a bit repetitive. From a UI point it might be useful to just show all (both) conversion results for the given input value, so the user. i.e. if the user gives Celsius, give them both Fahrenheit and Kelvin. 

Make a function to initialize the struct, esp. as you have fields that are initialized to as uninteresting a value as zero. 

Also, I'd separate the functions of creating a node, and inserting a node at a given point, since there might well be cases where you just want to move a given node from one list to another, and doing a malloc/free pair at that point is a waste. What if the list is empty The funny thing is, that having a pointer that is when the list is empty, seems natural, but it requires always checking if the list is empty. You can see this in that the insertion functions specifically test for , and you have to assign to in the main program after calling them. It also makes adding in the middle a bit difficult, since if the list is empty, you'd need to change the pointer (to point to the newly added item), but if it isn't empty, you don't want to touch at all, for efficiency's sake. A bit of a conundrum, I'd say. One solution would be to make a separate structure for the list in general, which would contain a pointer to the first item, and possibly some metadata about the list. (e.g. it could cache the list size if that is often needed, and a pointer to the last item to make it faster to add at the end.) That has the downside that all additions would require handing out a pointer to the main structure, and the node being operated on. Having no actual nodes would still be a special case, too. Another way is to just demand that the list never be empty(!). This is easiest to do by having a node that contains some invalid value (a sentinel node), something that is skipped by all functions actually handling the data. Sounds like a bit of a waste, though it's just a trivial version of a separate main structure, with the advantage that this time all the structs and pointers would be the same type. (Or rather, build the list functions such that they don't handle empty lists. The application program could of course have a pointer to a list node, that happens to be .) 

Data structures for characters set Storing characters set in the form of the in order to use method every time you what to figure out a position of the element is not the best choice in case of performance. You should probably use additional for excample: 

At least this code is called more than once, so it is reasonable to make a helper function for this purpose and make more reusable code. But I'm sure that you need few strategy classes and multiform manager to hold options and build flow using strategy instances. 

Improvement You don't need to make loop at all. You need random generator that will provide 2 values at each iteration: 

About code style, I highly recommend you to read angular code style even if you have no idea what is it. It contains a lot of sanity approaches about how to make HUGE classes clear and smooth. About comments: they needed only if you have no idea what is going on, or it is hard to understand. Don't overuse them. UPD: I always met problems of bad design when I have no idea how should I do something. Fist stage - write you code, code that will do what I want. Second stage - refactoring. Take one piece of responsibility and move it into separate location until all code is rewritten. As I see, you already have such pieces, that can be placed in separate location, e.g. plugins like they are really tiny, but there are no need to write ugly comments, that make code unreadable. Move it into single file, and configure grunt-contrib-concat for glueing all pieces together. Then I'd start refactor . There are a lot of thing that you can do from covered code style above. Firstly make constructor for your plugin, and move there this code 

parameter is just a length of the , so it can be computed in the method. Because method is not the static method, you already have initialized class instance so you can use array received in method in case if the user does not provide to the method itself. For an example, you can write something like: 

Note: it is not final or most optimized version ever, I have tried to show you set of approached you might want to know to optimize your code even further. Benchmark using browser Just open console in your browser and paste following code 

IMHO: first way is preferable, because you can see objects signature just by looking at constructor with no need for overview whole source file. Just don't forget to sort methods and properties in alphabetic order for quicker search (it really helps, do not ignore). 

Calculate the rate the grains are eaten and just divide to get the result? If a pigeon eats 1 grain in t seconds, then it eats 1/t grains per second, and the rates sum. Though this will result in a rounding error at the end, after there are less grains than the number of pigeons (since they don't actually consume partial grains), so you'll have to fix that if you care about the exact result. Another way would be to find the least common multiple of the time intervals, and iterate over time slots of that length (you know they'll eat a whole number of grains in that time). Though with a large number of pigeons or large intervals that will be unwieldy. Just so there's at least something about code review here, I'll just note that technically your code lets the number of grains get smaller than zero, if multiple pigeon try to eat the last grain. Doesn't matter though, since it happens on a single second, but some of the pigeons could mind. Often intervals are also counted downward, it saves one subtraction on every iteration. 

(Granted, that is not likely to matter much, since if fails your program might not be able to continue anyway. But still.) Make sure to on every error exit after opening the file, either in every single place where you do an early , or by collecting the cleanup code and to a single place. 

Do not put functions in header files. Headers are the public interface to your module, so they should contain the declarations of the public functions and (possible) variables. The C source file is the private part of the module that actually contains the implementation. So, 

This means that you're iterating starting from the beginning again and again for every node in the list, i.e. doing \$O(n^2)\$ work, instead of \$O(n)\$ which would be enough for simply iterating over the list. The point of a linked list is that you don't need to know where the end is when you start walking it, and that you can hold valid pointers to the nodes in the middle and do something useful with them. Here, every operation starts from instead. For printing, I'd rather make a loop similar to when you count the nodes: 

I have nothing on the scripting as such, it looks good to me. But given the subject matter, there's one big point, and two small ones: 

Put the circle drawing in a function, and make , etc. locals to it. As for , you might want to scale it based on the circle's radius. Or make it a parameter to the function. I think you have a sort of an off-by-one error here, as (1) on the first iteration of the loop, you draw starting from (old_x, old_y), but and aren't set yet. And (2) when the loop ends, you probably want to draw a line from the last point (at angle 49/50*2*pi) to the very first point (at angle 0) to complete the circle. Also, decide if you're writing C or C++. You can't define a as just in C, and in C++, you should make the class have a proper constructor.