I can then do a loop and echo out the information returned. However, since returns an array, even if it's empty, I have to check it first before starting the . As shown below: 

I use 'GROUP_CONCAT' to get comma separated lists of a person's educational background. Included in those lists are the type of degree, major, issuing establishment, and year received. is a required field and cannot empty. Prior to looping, I split the lists into arrays, like so: 

Wow, that's a HUGE class. At least it seems that way to me, but I'm no pro. Is that too long? How should it be split if so? Is this me doing a whole bunch of procedural code, wrapping it in a class, and deeming it OOP, or am I on the right track? Just a few of my concerns there. The Display Page 

You have written nice small methods with clear names that greatly helps with understanding the code. However it is very easy to mix up parameters that are passed into the method and fields of the object when reading the code. Therefore it is better to prefix all your fields with “_”, so making the code read like: 

So if writing unit tests don’t help you writing the code then don’t write unit tests for code that is tested by acceptance tests. However unit tests help you developer the API to your class and provides examples of how to use the class, so may be of value even when you already have 100% test coverage. On a normal sized code base, it may also be quicker to track down way a unit test if failing. 

This information is being entered into the database without any checks, which can lead to bad data being stored. I'm assuming that there may be checks client side (browser), but those checks are by no means fool-proof. Javascript could be disabled, rending those checks useless. There is for HTML5, and some browsers have implemented that functionality. However, not all have, and many users will inevitably be using the older versions that haven't. What if the name and username are blank, or the name is . Checking the length and content should be done both on the client and the server. +1 for prepared statements! 

Also your qSort could be written to be a lot faster by not creating 3 new , it is also very important to quickly choose a good item to privet on. You do not even set the size of the list when you create them, hence each list will have to be reallocated and copied many times as you add items to it. You have a qSort that is implemented is an inefficient way compared to a boubleSort that is close to the best implementation for boubleSort. Yet as you confirmed in your comment the qSort does better when you have over 10000 items, slowing just how much better qSort scales. 

Yoda has some good points, and I agree with it being safe. I noticed you mentioned validating, but I figured I'd add my 2 cents for future readers that may come across this question. A few things jump out at me from the following: 

I've been working with PHP for a while now, but unfortunately haven't delved into the OO side of it until recently. I've been reading up on separation of concerns and OOP best practices, and I think I have an idea of what is expected, but there's always room to improve. At any rate, is this heading in the right direction for PHP OOP? The Class (profile.php) 

Thanks to ANeves for pointing out that I could also submit my comments as an answer by invoking question 5 :) Original comment: Not a direct answer to your question, so a comment: your approach hides useful information from the caller. You handle the exception, which has lots of information in it, by passing much less information to an event. For example, an IOException will tell you why the file couldn't be opened; the event does not. Exceptions have a stack trace; the event does not. Sometimes it's best to let the caller handle the exception, since the caller knows best how to react to a given exceptional condition. 

The value of the privete field should NOT be tested, as it is only an internal implementation detail. Also what should do if the user has not yet logged in? 

On Fixed Size: I don’t think I have ever backed a queue with a fixed sized array apart from code written for university exams. However it is easy to extend what you have done to allocate a new array of double the size and copy the item over if the queue gets filled. Doing so tends to be faster than using linked lists on modem CPUs (due to the processor cache) and also creates lets garbage so helps the garbage collector. See Strategy: Stop Using Linked-Lists On Naming: Lets take this code for example: 

That's because (lower + upper) / 2 can overflow. Of course, in the 32-bit world, this is no longer very likely to happen. The linq soution proposed in another answer does not meet your requirement of "needs to run as quickly as possible." Linq will do a linear search rather than a binary search. You can get rid of the variable (note that you assign it at the very end of the loop body, after all): 

I think there's also no point in adding or subtracting 1. I once long ago did an analysis that showed that this doesn't improve the efficiency of the algorithm. You reduce the search range by 1 on each step, but you lose that because of the division by two. I'm not certain of this, however; it was a long time ago. You also don't need if the branch returns. Therefore: 

It is normal in production quality qsort code to switch to another sorting method (maybe a unrolled bubble sort) when the size of the input is small (often 8 is used). QSort has very high overheads, but scales well, for a small input size the overheads are much more important than the scaling. If you run your code on an input that is 1000 items long, then I expect that your qsort would be faster than your bubble sort. Try writing a test problem that increases your input size in steps of 100 and then graph the results with both sorting methods. The other way to look at it, is to find the largest input that each sort method can sort in say 5 seconds. 

Most likely, yes. The ReadFile method takes a file path and fills a collection of strings with the lines of the file. That's pretty simple. By using the event-based pattern you've developed, you require the consumer of the method to subscribe to an event if they want to know about exceptions. The built-in exception handling mechanism, on the other hand, comes for free. Indeed, the direct caller of ReadFile might not need to catch the exception. It might be appropriate to allow the exception to bubble up to a higher point in the call stack. In general, any given method should only handle exceptions that it knows about, and for which it has some specific course of action. (Such a course of action could be, for example, informing the user that the path was invalid and asking for new input.) At the entry point of your application (the entry point of each thread, actually), you'll usually want a general exception handler for logging exceptions that weren't handled more specifically. Back to your program: to decouple the ReadFile logic from the calling class, you could have the method return a rather than operate on a private member of the class. This has many advantages: easier testing and greater reusability come to mind. Another suggestion: Since you concatenate all the lines in the end, you could skip a lot of this and use the method instead. In general, it seems, you might want to focus on the single responsibility principle as a way of arriving at a decoupled design.