If you look at the legend you'll see that the running average is shown at about 20% (the "#" marks) with the asterisks being peak percentages. The CLI graph is really imprecise, but what you're generally seeing is periodic (and very brief) spikes. 

The traditional class-D range for multicast is 224.0.0.0/4 - which is 2^28 host addresses. If you mapped this to a 24-bit namespace you would, in fact, end up with a ratio of 2^28 / 2^24 = 2^4, or 16 IP's per MAC instead of the current 32 IP's per MAC. The reason the additional bit is used is that the most significant bit is actually a flag indicating whether the MAC is multicast. The idea was to leave a full 24 bits for OUI's while still including some kind of signifier for the frame being multicast. It actually makes a certain amount of sense as a concession given that there used to be a lot of other protocols besides IP that used Ethernet and that these protocols didn't have any kind of universally recognizable upper-layer mechanism for network hardware to pick out whether a given frame was multicast. I suppose it might have been possible to put a multicast flag elsewhere in the header, but that would have caused other compatibility issues. 

"sho ip bgp sum" isn't going to show you numbers for EVPN routes. You could, in fact, completely omit the stanzas if you wanted. Seeing an established / working session with no messages is actually expected for your setup. If you want to see some routes show up then create a network statement pushing some routes from the global network (i.e. the underlay). The correct equivalent to would actually be - which, if things are working, will show EVPN routes received from various peers. Other variants of this command tree will also show you info about EVPN: will show you the raw EVPN routes, for example (including L2/L3 info, VNI, etc, etc). The routes received (and used) will show up not under but rather under . It's best practice to actually push the subnet routes within the vrf's on the leaves. So, for example, under the VRF's stanza in the BGP section (ideally using some kind of tag as a discriminator): add where the route-map would simply match some tag value that would be added to the interface IP address on the SVI. The point here is that you want to have the leaves initiate the subnet's /24 (for example). If you don't then you'll only see the individual host routes that the HMM creates on the leaf. This is especially painful for situations where traffic is being sent to hosts that haven't been seen/announced yet, as they'll be sent an unreachable message. Do not use SVI's for carrying VXLAN traffic between leaf and spine. It can- and might- work on particular hardware but it's a far, far better design to just set up the transit interfaces as routed () and let things work that way. Put another way, there should be no SVI's on the spines (for leaf connectivity) and any SVI's on the leaf should only be host-facing. The "route-reflector client" statement ONLY goes on the spines (..where I'm assuming you'd want to run your RR, otherwise we should be seeing more peers on the leaf). It's not breaking anything yet, but set up jumbo frames on the transit interfaces between leaves and spines. If you want to run jumbos to end clients my recommendation would be to stick to 9000 for such SVI's while using 9216 for inter-switch links. The fact that you're seeing anything under the suggests that things are actually working better than you may realize. These won't generally form unless BGP is operating. EIGRP actually isn't officially supported by Cisco for EVPN configurations. It works fine and there's zero reason why it shouldn't, but hasn't been explicitly validated (IS-IS and OSPF have been). Is there some typo with the router-id's? The sample leaf calls out a BGP router ID of 107 and 108 for leaf and spine respectively but those IP's don't appear as loopbacks in your configs (17 and 18 do, though). Also, specify a router-id in your global EIGRP process. 

There are two sub-variants of BGP - internal (iBGP) and external (eBGP). In the case of iBGP the ASN's of the two peers are identical. In the case of eBGP the two ASN's are different. In your example you're using eBGP. I mention this because a number of rules are different between eBGP and iBGP. Most typically eBGP sessions occur between directly connected interfaces. In your example this would mean that R1 and R2 would peer to one another as 1.1.1.1 and 1.1.1.2 respectively (i.e. R1 has a neighbor statement to 1.1.1.2, R2 has its statement to 1.1.1.1). This works because each router can reach the other via a directly connected route. If you deleted the update-source and static route and simply peered the routers on their directly connected interfaces the peer would come up without any further configuration. Also - as an aside, if you have a point-to-point link use a /30 or /31 prefix rather than a /8. It's possible to configure what's called multihop eBGP. This means peering two router interfaces that aren't directly connected. This requires that another route needs to be in place for the interfaces to be able to pass packets. When you changed the source of the sessions to loopbacks you needed the static routes in place to allow the session to come up. Typically the peering session will require an additional statement specifying the maximum number of IP hops for the session but since in this instance they're only a single hop apart it may not have been necessary (..although it used to be). This is also known as a recursive route - so a route received with a next-hop of the remote router's loopback will actually use the static route as a way of resolving the interface that a given packet will take (in this case 1.1.1.x). By default for eBGP routes will be advertised with a next-hop of the peering address (unless specifically altered via a knob or route-map). This is one of the differences with iBGP where the next-hop address will be normally unchanged across peers unless configured to behave otherwise. 

You need to account for Internet Options in the header. Take a look at the third example in appendix A which shows a few option fields appended to get well past 20 bytes (the example adds 12 bytes, but the number is variable and can be more). The upper-layer header lengths aren't IP's direct concern. The header obviously contains information about the protocol type but apart from that the upper-layer protocol spec is outside the scope of the IP header. So the RFC is basically saying that, for a router, the biggest possible IP header is 60 bytes and the smallest payload is 8 bytes (so, a 68 byte packet). In turn a given end host must be able to receive a final packet of up to 576 bytes (which may be made up of a bunch of fragments, depending on the MTU's of routers along the path). So the minimum sized packet could - in theory - be 20 bytes of header (no options) plus the minimum 8 bytes of payload. This would have to be a fragment, as otherwise the packet would include some amount of L4 header protocol information.