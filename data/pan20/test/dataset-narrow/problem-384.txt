Why not install another instance of SQL Server e.g. a named instance called or something similar that suits your needs. BTW, there is no Windows 2007 version. 

You can check how much the database has changed since the last backup using SQLskillsDIFForFULL.sql. For log, you need to use the undocumented or documented or in sql 2017 and up using --> column . You might be having operations running overnight like rebuilding indexes or loading the data (as mentioned by @hot2use) 

Removing SQL Server from failover cluster - you have to run the setup.exe and in maintenance you have to select remove node. Then removing the node from windows cluster, I would suggest you use PowerShell 

Dont try to reinvent the wheel as there is a cost to reinventing it. Use Ola's maintenance scripts - they are tested well enough and follow best practice. You can even use LockTimeout in Ola's solution. I would not worry on the fragmentation levels where the page count is less than 5K. 

SQL server will have everything in the registry settings. For shared Features, I believe the registry is Refer to File Locations for Default and Named Instances of SQL Server 

The easiest (quick and dirty solution) but risky in terms of security approach would be to mark the database as using . Remember that marking the database trustworthy elevates the database to a de-facto You are getting below error : 

Remember: Auto-close is deprecated, so one more reason to avoid it. Seems like you should invest in reading - Multi-Tenant Data Architecture 

You can use either Alter database Modify File or Detach/Attach methods. Note: Both will require some downtime, so has to be done during maintenance window. This assumes that you have same directory structure on the new drive e.g. C:\data\ and D:\Data. -- using Alter database with Modify method (preferred one) 

We create the jobs (and sync them as well) across all the instances that are part of AlwaysON AG. There is an additional logic that you should put in the job to check if the instance is primary and then only run the job. A pseudo code would be like below : 

For Documenting sql server, I highly recommend just recently released : SQL Server & Windows Documentation Using Windows PowerShell written by Kendal Van Dyke Brief description from the link : SQL Power Doc is a collection of Windows PowerShell scripts and modules that discover, document, and diagnose SQL Server instances and their underlying Windows OS & machine configurations. SQL Power Doc works with all versions of SQL Server from SQL Server 2000 through 2012, and all versions of Windows Server and consumer Windows Operating Systems from Windows 2000 and Windows XP through Windows Server 2012 and Windows 8. SQL Power Doc is also capable of documenting Windows Azure SQL Databases. 

where is the number of rows in each partition. Taking above into consideration, below will explain : 

IN SQL Server 2012 Enterprise edition, you can use AlwaysON Availability groups to achieve what you want. If you have 2 servers set up, then you can configure AlwaysON. Primary server will be your main and secondary (Replica) - when configured as "Readable" will allow you to redirect all "Read Intent" requests to secondary replica as well as the secondary replica is a read-only replica. Note that, your clients are connected to the Availability Group using Listener, which allows seamless failover for your application. In case of disaster you have all your concerns covered 

Very interesting question .. Based on my understanding, I will try to answer this. Other experts can correct me wherever I am wrong. 

Below is the script that I wrote for myself to make copy of database. Its flexible and can be converted into a stored procedure. The comments will explain what it does. Test it on a Test server before running it in PROD !! 

There is no way in SQL 2000 - as it does not support any DMV's introduced in sql server 2005. Your best bet is to use an AUDIT trace or run server side trace. Note: depending on what you are capturing, it will be resource intensive and might end up filling up your disk space as well. EDIT: @rhughes Refer to this para in the link : 

You dont have to manually cleanup the old/static snapshot files, the distribution cleanup agent will purge the old folders for you. A bit of under the hood story of what and how snapshot files gets generated : Basically, the snapshot agent creates snapshots for the subscribers to initialize. The snapshot folder will contain various types of files like - 

If you want to audit on an ongoing basis then a server side trace will do the job. Below is how you will script out from Profiler 

The only downside that I see is, it will make changing the table schema a bit difficult, even if it is just a small change e.g changing a NOT NULL column to allow nulls. 

Make sure you use when storing data. You can think of using SSIS to do the same and schedule the package using SQL Agent job. 

The best way will be to use backup-restore - using .. This will take care of migrating entire instance including all databases, logins, jobs, etc. Make sure you use switch with appropriate network location e.g. 

SQL Server editions differ by the features and capabilities that they provide like no.of cpu's , memory, database size, High Availability options, Disaster recovery options, etc. You can refer BOL for more details. When you say Trial - it can be Enterprise Edition for 180 Days. Unless you have the same database version, I would recommend your to do a backup restore from Express to Standard/Enterprise edition (trial version) and test it with your workload. Pretty sure, that it will outperform compared to Express edition in terms of performance as well as maintenance. 

A differential or FULL backup does not break the log chain. Also, logshipping would not skip the files. There has to be something that might be taking ad-hoc log backup and then breaking logshipping. I have set up a 3 way logshipping (dont know what to call .. so calling 3 way - one primary ships to 3 other standby servers) and it works without any issues. 

for your second question - Every time you start the named SQLServer, it uses the port that is allocated. In case if the port is used by another program, then SQL Server chooses another port at the time of restart i.e. The dynamic port is chosen at first startup, and will generally remain the same through future restarts (stored in the Registry) - but if its used by another program then SQL server will choose a new port. note: For Prod Servers, I use only static ports - security and ease of manageability reasons. Note: More cools thing to find out : Check if Dynamic port is being used or not using T-SQL : 

So to answer your question, a COPY_ONLY backup cannot be a part of a restore that involves T-log backups (doing a point-in-time restore). Its whole point is to have a backup set outside regular backup chain NOT impacting the restore sequence. A full backup must be performed on primary database (cant be a copy_only backup). Only T-log backup (as mentioned above) can be done on either primary or secondary with a CAVEAT that it wont mess up the LSNs on the PRIMARY i.e it will keep the LSNs consistent - regardless of where you take log backups in the availablity group. Best is to check the so the log backups will use the Availablity group backup preferences for Log backups. Refer to : Performing Transaction Log Backups using AlwaysOn Availability Group Read-Only Secondary Replicas - Part 1