Store a flag for each triangle in an array, associated with the mesh. This array is allocated once and owned by the mesh. When testing the triangle, use the triangle ID to first check the flag. If the flag is unset, add triangle ID to resulting list of candidates and set flag. Ignore triangles with flag already set. I encode this as a bitflag array so 8 triangles is 1 byte. I share this with all queries as long as it isn't multithreaded. Right before each search for triangles, I clear the array to zero. Performance is not bad. Store a last_search byte per triangle in an array, allocated once, associated with the triangle mesh. Have a static search_number byte for all queries, again associated with the triangle mesh. Initialize each triangle byte to zero via memset(). Initialize the static to zero. On first search increment search_number. Any triangle last_search not equal test and set to new number. If search number, when incremented, is zero memset last_search array to zero. Result is a clear every 254 searches. 

No - this won't cause any problems as long as you guarantee sending all of the visible, front-facing triangles - the GPU only cares about what is visible, not the ones that are clipped off screen. Ultimately, I don't think this is worth the extra effort as breaking up the draw calls will reducing batching, which is really important for performance. 

I wonder if chopmunk allows the object to be made static inside a callback issued from the guts of the physics engine. What if you set a flag on the object and after updating physics you set things static? It would be worth checking the documentation on cpSpaceRemoveBody. I looked into the source code for chipmunk, and here's the relevant function: 

The best option is to perform all the mid and narrow phase in the local space of the instanced mesh object. Most collision detection algorithms air pair-wise using two matrices, one for each objects transform. In this case create an inverse matrix from the instanced object's matrix and concatenate it with the other objects matrix. This effectively moves the collision detection into the local space of the instanced object. After detection is performed multiply the results by the instanced objects transform to get the results in world space. This removes the need to move every triangle into world space. It also allows you to use an acceleration structure shared with each instance. Some pair-wise detection algorithms require extra treatment when dealing with scale but this is certainly where I would start. 

As you can see, it's not simple like the initial equation. But it does work nicely for the game I created. Thank goodness for linear algebra! Update After writing a simple Point class with various operators, I simplified this answer to the following: 

Which of my mechanics suggestions best avoid the pitfalls I mentioned? Or is there a better idea I haven't considered? Please also highlight mechanics that could annoy players. 

I like to think of "permadeath" as just part of the genre. For instance, could you make a first-person shooter with no guns? Sure! You could replace them with swords, etc. But would people see it as a FPS? Probably not. Roguelikes, by tradition (and arguably, by definition), include permadeath because that's the way the genre was defined. 

I took those two equations and made them into a system of linear equations. Solve this system of equations in any method you choose. (I used a rref method. Also, some graphing calculators can solve this problem.) The final equations looked like this: 

Clearly this could get complex. But I still want to explore this idea some. I worry about balance in a few fundamental ways: 

I had this same problem for a game that I was writing. I imagine that this problem will differ based on how exactly you implemented you isometric system, but I'll explain how I solved the problem. I first started with my tile_to_screen function. (I assume that's how you are placing the tiles in the right location in the first place.) This function has an equation to calculate screen_x and screen_y. Mine looked like this (python): 

I like the complex, branching structure of games like visual novels and RPGs like Mass Effect. But I also like multiplayer cooperative games. So I thought, "What if there was a multiplayer dialog system?" My thoughts on several ways it could work: 

I've been working on a several simple games, and I've always come to a decision point where I have to choose whether to have the Level object as an attribute of the Player class or the Player as an attribute of the Level class. I can see arguments for both: The Level should contain the player because it also contains every other entity. In fact it just makes sense this way: "John is in the room." It makes it a bit more difficult to move the player to a new level, however, because then each level has to pass its player object to an upcoming level. On the other hand, it makes programming sense to me to leave the player as the top-level object that is persistent between levels, and the environment changes because the player decides to change his level and location. It becomes very easy to change levels, because all I have to do is replace the level variable on the player. What's the most common practice here? Or better yet, is there a "right" way to architecture this relationship? 

Using btConvexTriangleMeshShape as a dynamic collision shape isn't recommended. I would use a cube and a plane using the classes btBoxShape and btStaticPlaneShape respectively. They have distinct properties (boxes are solids, planes are one sided) that give better collision response. Colliding two triangle meshes together is unlikely to be supported well by Bullet. Furthermore, btConvexTriangleMeshShape is for convex triangle hulls. A plane is not a convex shape. You can read the author's response here: $URL$ 

I took a look at a number of implementations that are all based off of this paper: $URL$ Here is one that I extracted and ran with your numbers - it returns no collision. You can look at main() to see the invocation with your test numbers. I have not done any more analysis than that. Good luck. From $URL$ 

When in a skidding condition, every frame capture the contact point of the skid, and the normal of the surface contact point - you would probably already have this from the raycast/contact you used for your physics simulation. When you have two or more points, you can start drawing the skid - to begin with just draw it as a line list or line strip so you can visualize it. See the red line and P0 to P4 in the diagram below. Once you are sure you have your points in the right place, you need to create three basis vectors for each point so that you can create your polygonal data. The first basis vector is the the normal for each contact - this is your UP vector. The second basis vector is the forward vector - this is you point's position subtracted from the next point's position. Use the cross product and normalize to get the third basis vector - the RIGHT vector (or LEFT vector, depending on your coordinate system). With the basis vectors you can now use the RIGHT vector to create two points, one to the RIGHT of the current point and one to the LEFT of the current point. If you were to take those points and draw them you would have to lines parallel to each other (see the black lines in the diagram below). Since the RIGHT vector is a unit vector, your two points are now P_left = P - RIGHT * half_width; P_right = P + RIGHT * half_width where half_width is the half width of the skid mark. You now need to take those points and turn them into quads, or triangles (two triangles per quad; see the light-grey lines in the diagram below). How this is done depends on how you draw your data. In the end you want to stitch together each pair of points into a strip of triangles/quads.