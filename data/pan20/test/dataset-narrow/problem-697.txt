Your code here is far more complicated than it needs to be. The trick you need to follow is four-fold: 

That code takes an input value , multiplies it by 10, adds 4, and then divides it by 10 million. Consider an input value . Take that, multiply by , and add , to get . Now, divide by million, to get . Now, round that value to 6 decimals, and get: , right? Then multiply that by 1 billion to get Unfortunately, the actual result is: 

your instance variables are not private, and should be. the and variables should also be final instead of having a method, just override the , and et all should probably be renamed to and , or really anythong other than 1 and 2. You used the variables and so why not and ? 

Conclusion So, that's the real problem with exceptions, the performance is unpredictable... and, for example, if you run it inside a Tomcat container, with stacks hundreds of levels deep, you may find this completely destroys your performance. 

This approach is O(n) time complexity (n is the number of pixels in the matrix), and O(1) space complexity I have tested this and it works. You can use the right-handed approach for 

Note that the logic is essentially the same, but you focus on the important things. The variable is a better name, and it's scope is limited to inside the outer for-loop. The hard-to-understand loop-terminator is removed. Note, using streams, and a regular expression, would actually be more compact solution, but may not be as readable... I played with the stream version and a regex, and got: 

The second 'obvious' issue is the lack of generic types on your interface methods (indicated with ): 

Logging in Java often is tied to the class that the log message is called from. For example, the Logger is created with a name of the class as a constructor/key. This means that the logging of the exception may/will be logged with the name of the ErrorHandler class rather than the class that threw the exception. Depending on your circumstances, this may be a problem. Logic flow in situations like this are often complicated by the return types of the class. For example, your code may look like: 

The challenge here is to find all the discrete loops inside a vector, and to call the above function just once per loop.... to solve that, I recommend having a 'seen' vector of bool, that allows you to identify which indices have been visited. Combining the vector with the various loop rotations, allows you to iterate the vector twice, once looking for unseen values, and the other doing actual rotations. Since each seen member is visited once, and since each value is rotated just once, the result is that the overall solution is a regular \$O(n)\$ loop. This reduces the complexity from \$O(n \log(n))\$ that your solution currently has. Now, here we can prove that the actual values in the vector are not significant any more, and all that's important is the index. We can make the method a template method, and it will work on any vector data: 

Well, when you decide to something as a learning exercise it's normal to tackle just one problem at a time. In your program you have databases, object-relational mapping, JSON encoding, OAuth protocols, closures, REST, and more. It almost makes me a bit sad not to see slices, channels, and go-routines in there. What happened to the good-old FizzBuzz? Your ambition here is admirable, and I understand the motivation to accomplish something meaningful (a cool slack-bot is awesome), but I worry that you'll maybe miss some details in your haste. General In general, your code looks like it has been through the wringer a few times, and it has wrinkles, and a few worn spots. While it looks like you are already in the habit of running your code through the routines, you should also add and to your tools. You have a few issues I can see off-hand: 

Then, with that break-point enabled, you need to debug the program: Right-click on the 'main' word in the and select 'Debug As -> Java Application' This should prompt you to go to the 'Debug' perspective, and you will have a window with the 'Variables' displayed. One of the variables will be and you can expand it to show its contents. Here's a screen-shot: 

I like that you have separated the CreateGrid method out in to a reusable method. This is good. Your logic inside the method is even quite good, despite your concerns about the duplication. There is a trick, though.... use a boolean: 

Your solution here is wrong, it produces incorrect results when it compresses chars that are in two different places in the string: For the input: your program produces: 

for primes in the range of through to (which will keep within the limits of -999 to +999). Note that there are no primes less than 2, and only a few hundred primes less than the 'worst case' Only if you satisfy those two conditions would I consider even calling the prime function 

As I say, though, the loop above does 1-less than the number of chars in the pattern, should it be indexed from 0? If not, it should be commented. As for the duplication of code, you should make the class have a private constructor, and you should create an instance of the class each time you call one of the static 'search' methods. When you create the instance, you create the various state information (the , the , etc.). Then, have a method that just gets the location of the next match. Your two static methods would then look like: 

But, that's the least of my concerns. The synchronized equals is probably there because other methods are synchronized, but synchronization comes at a cost. Unless you are sure you need it, remove it. Additionally, synchronized methods are seldom the best solution. It is normally better to have tighter control of your locks so that nobody but you can hold them. That normally means using a private, internal "monitor" for synchronization: 

That should be an , surely? EDIT: You should seriously consider having a pre-calculated set of prime numbers. You can get these lists from many places on the net. This will save a bunch of time. I have found a large number which illustrates how slow these algorithms can be.... BigInteger arithmatic is much, much slower than primitive arithmatic. But, you can significantly reduce your BigInteger arithmatic. Boxed__l is correct about doing 2 as a special-case, and then only checking odd numbers. This will reduce your computations significantly, but, let me suggest another, different approach. First, if the BigInteger number is smaller than Long.MAX_VALUE there is no reason to use BigInteger. I would recommend that you implement the algorithm multiple ways, one using , and the other using . Now, I would then have a 'entry' method that looks like: 

As for your recursion, you can simplify it a little by recursing one level more, and returning 0 (eliminating a duplicated division on each level). Consider your code: 

Instead of having each socket handled by a thread, you have a small-ish pool of threads ready, and waiting, to handle the few sockets that actually do something. At the same time (actually, shortly after) as NIO was introduced, the cost factor of creating, and maintaining many threads was significantly reduced, in Java, on the core platforms (Intel, AMD, etc.). As a result, it became effectively just as reasonable to have 1 thread per client again, even if there are thousands of clients. The issue is now mostly confined to places where thread handling is still hard, slow, and expensive. NIO is still relevant today where there are many, many client connections, or where the infrastructure still has expensive context-switches, or thread startup times. Tutorial For NIO Selectors to make sense in Java, you should follow particular pattern in your code: 

Gimmicks are fun, but, they get tiring fast. And, they break the 'spirit' of UNIX scripting, which is that they can do things for you in as many situations as possible. 

Your code could be simplified significantly if you remove your checking algorithms, and work off only the assumptions and facts given. What can we say about the inputs? 

Note that I have chosen to use real variable names, instead of 'a' and 'b'. I find this helps me, even in functional declarations. OK, so is a lambda expression that returns true in the event that two positions are unsafe relative to each other. While we are talking functions, here's a part of the scala that needs to have a matching concept in Java: 

In general I found your code easy to read, and follow. When implementing complicated math in an algorithm, it is important to document things carefully. Why does the following make sense? 

Exceptions: It is common practice to throw an IllegalArgumentException if the input values to a method are not legal. In the sepcific case of null values, there is debate about whether the right response is an IllegalArgumentException, or a NullPointerException. I prefer IllegalArgumentException.... Also, in Java, (and most languages), it is very easy to introduce bugs when making small changes to 1-liner conditionals (just ask apple). When making the changes correctly to 1-liners (without introducing bugs) the actual small changes require adding in braces, so small changes change a lot. In general, use braces, even for 1-liners. The code: 

I don't like this. The reason is that it has too much negative logic..... and even though it relates b to a constant you return instead of . Consider the following alternative: 

as I look at that specification, and the code, I can't help but think you have missed the 'simple solution' that they were looking for..... Now, the spec says: Your implementation must implement the FlattenTree interface Did the spec include the interface for the ? If it did, that's horrible, and as a person being interviewed I would say the Tree interface was broken. If they jsut gave you the interface definition: 

Now, having stripped the complicated exception handling from the main part of the code, the rest becomes significantly simpler.... A second method would be useful for converting a document to a map of translation elements: 

Other answers have good input on a number of factors I agree with, especially about the early-return logic, the bugs that were pointed out, and the bracing strategies. My suggestion though, is to use a different (the right?) tool for the job. Regular expressions are a tool that are designed for text processing, and a well-crafted expression is typically faster and more concise than the hand-coded alternative. Regular expressions are not always the solution, but in this case, the result would be simpler to read (for someone familiar with them). In this case, the logic requires checking that all 'g' chars are happy for the check to return true. Alternatively, to make sure there are no unhappy 'g' chars. The expression to check for unhappy 'g' chars will be: 

Finally, for reasons I can't quite rationalize, I don't like the algorithm. I think your analysis of the complexity ( \$O(n*m*log(n))\$ ) is optimistic, I think it is slower than that. The issue is that... you loop through all the data times (which is essentially ): Each time you do that, you do a poll, and an add to the heap. each of these are log(n) operations..... 

String concatenation String concatenation with the operator is often frowned on... in this instance, it makes the code cleaner, and I am leaving it in. The alternative is to use a , but that has other issues in this use-case. Like you, I would use string concatenation... Conclusion All told, I would recommend something like: 

The logic is the exact same as yours except I have big things I use a part of, whereas you build it up bit by bit. The important part is the Math.abs(...) statements are identical to the previous version.... they are the limit to the values we build. Here's a way to do it: 

There are a few problems with your validation, and the code itself could be a bit neater. First up, your code will try to validate impossible puzzles. Sudoku puzzles need to be square-sided You check that the puzzle is square, but your slot-size is not valid. It assumes a side that is a perfect square (4, 9, 16, etc.). Additionally, you only check the first row is the right length, I suspect your code will validate as true if one of the rows has an extra element (with a carefully-chosen value). In multiple places you set , and in those places you should just . You know the puzzle is not valid, so why continue checking? Finally, it would be nice if you could make the checking generic. There are 3 things to check: 

One other thing, which is android specific..... I found a bug in the Android Dalvik implementation/SDK relating to this problem... you should be setting the 'cause' for your AssertionError so that it is logged correctly. Unfortunately, the bug (which is fixed in Jelly-Bean) makes this impossible. If you are sure you will be testing on Jelly-Bean or newer (the bug was fixed a while ago), you should also be initializing the cause on your AssertionError: 

I get the impression you are using vim or some other console editor to manage your code. You should consider the shortcut in vim to re-indent all your code consistently. 

If there is an error in there, you log the error, and then immediately will panic when the next line runs: because buffer will be . Hmmm... I looked at the code, and no, the panic won't happen in the next line, but in the following one when the image is manipulated: code. Now, the consistency is also a problem. You declare the return value to be called in the function declaration: If you use a named return value, then don't have return values in the return statement. Also, no need to have a return as the last statement in the block. Logging some errors to the console, and not others, is also inconsistent. StdErr Use the standard log functions to set the output destination of log messages $URL$ and then don't use the option in each call.