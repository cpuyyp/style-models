Does it make sense to check if a file writable in the constructor (i.e. long before a "save" method is ever called), or is there perhaps a reason to support read-only "mode" of operation. If so, should read-only be a setting at time of instantiation, such that Exception can be thrown to caller that they are trying to write for a read-only INI file? I guess my thinking here is that the class is potentially being put into a bad state that can either be detected up front, or more specifically addressed in the interface. I also note that you have no place where you are validating readability of the file. Should this happen in constructor or at beginning of parse method before you try to operate against the file? 

I would not get all worked up about having to type a few extra letters when referencing a variable. I could get worked up over possibly doubling the storage space required for your data depending on it's size. Let's walk though what PHP is doing behind the scenes here to understand: 

Why do you need three different method calls to start this game? The caller should be able to just do something like: 

There is no reason to apply this format until you actually get to the point of logging, thus no reason to have a concrete object to pass around. Even in your static method, you instantiate an object of the class, which I just don't see any value in doing. I would consider having a single public static method like (though I think method name could be simplified as it seems redundant to class name), and have everything else be private static functions to break up different elements of the work like you are currently doing. Also, if you are thinking about being compliant with PHP7, you might need to make this class operable against anything that implements interface, as in PHP7, typically become and thus might need to be handled as well. In your method, which is currently your public interface, you should type hint that the parameter should be or . Right now you don't do anything to enforce that a proper dependency is passed to this method. 

Since this is such a simple aggregation use case, I would consider aggregating this information in MongoDB rather than in PHP. As far as code review comments go, I would state that for a simple section of code, it is kind of a mess stylistically. You have: 

Get in the habit of using exact comparisons ( and ) instead of loose comparisons ( and ). These will go a long way in making your code less fragile to unexpected truthy/falsey behavior that can lead to bugs. You should only use loose comparisons in cases where you truly have a need to match loosely. You might find that these cases are really few and far between. 

Once you get to the point of calling operation on the view, you may consider building a object. That way, regardless of the type of view to be delivered, you could always have the contract of having a structured response object that contains headers to be sent as well and content itself (regardless of format) and would, in essence be the last thing called (i.e. ). Right now, I don't really see any consideration in your framework for how you handle response headers. I would think this would be a base requirement for any framework. 

In your type="test" GET use case, you do not explicitly set http response headers. This is actually probably not a problem, but this is not consistent with your usage in POST path. 

Otherwise you might find yourself eventually adding filter, sort, etc. methods to your class because you have hidden away the underlying capabilities. 

Then I would question whether you should in fact use an id on these DOM elements vs. using a class, since you are clearly only exepcting a single element for each of those classes. Selecting by ID is preferred approach in javascript to get a single element, as elements are indexed by id. They are not indexed by class name, thus requiring document traversal to find all elements that meet your condition. I also think you need to think about breaking your application into logical components, each one with its own event listeners and animation logic. right now having single functions with complex case statements and branching logic has the bad code smell. Have you considered trying to define different javascript object classes for each of your application elements, with each object owning properties for play state, DOM elements that are related to the object, callbacks, etc. This current approach seems very fragile from a maintenance perspective, in that if you need to make a change to one of your page components, you could unexpected impact the other components. This code should also not be running in global namespace. At a minimum, I would think this code could be placed inside an IIFE. 

I don't like your approach of building the regex pattern in two places, why not define entire pattern in regex array? You might have something like this: 

If you should consider incorporating style checks into your static code analysis such that you can automatically flag style issues like lines of code that are too long (typically ~80 characters). 

I would be VERY concerned with performing any operation that can change data in your application via . Typically is used for these sort of operations, such that people don't accidentally bookmark the URL and keep returning to it, potentially performing unwanted changes in your application. Get in the habit of thinking as as a read-only protocol. 

Start with the query and work backwards. A poorly-written, poorly-performing query is not a good foundation to build on. Here is your query (re-formatted to more readable) 

Having a SQL statement in a variable makes it easier to debug the code and provide more meaningful error messages, IMO. 

As opposed to directly modifying before making assignment to like shown below , which would not double memory utilization: 

You are making wide use of type-hinting, which is a good practice, but you perform no other validation for parameters passed to your public methods that are not able to be type hinted. 

You attempted to use components, but didn't really use a componentized approach. You probably could have had a single component defined to render the test element and the state of each and a separate component defined to deal with the tests at a suite level which would handle triggering tests, updating test ordering, and display of suite-level information. 

You also obfuscate dependencies to someone reading/working with your classes. With the approach I suggest, the exact dependencies of the class are explicitly stated in the constructor method signature (or in other method signatures if you have static methods or load dependencies after instantiation for some reason). If someone needs to add functionality to the class that requires a new dependency, you actually have to add that dependency to the class. This may seem like extra work, but, in fact, it is good coding behavior in that you have to be thoughtful and specific in how you consume dependencies. You avoid someone just introducing new dependencies in your classes by simply adding calls against not-previously-used dependencies stored in . 

First and foremost, I would worry about getting rid of that awful code nesting you have. This nesting yields increased cyclomatic complexity which tends to lead to more buggy/fragile code and code that is harder to maintain. So, at a minimum, think of re-writing your code like this: 

First, let's start with the way your query is formatted. I would strongly recommend you get in the habit of breaking your query across lines when they get long like this. I oftentimes use heredoc/nowdoc synteax for this. For example: 

Since you are just POSTing url-encoded query string, can you not simplify setting of for AJAX call to: 

4) You might consider dependency injection. Right now you regularly use the approach of instantiating dependencies in class constructors. If you actually did take some above advice and properly handle all the possible things that could go wrong everytime you need to instantiate some resource or object, you will find yourself having a lot of dependency-specific logic in your classes. With a dependency injection model, to can pass in valid instance of say a DB connection or validator class, with the class receiving that dependency knowing that it has a valid instance and not having to worry about all the instantiation handling for the object (or even knowing how to instantiate it at all). You model class constructor could be rewritten like this: 

This approach would limit the repeat code you have for each transformation string and would also take care of your concern in that only those transformation types specified in the config would be executed. This also more directly injects the transformation configuration information into the function that generates the strings, meaning you no longer have to rely on variables that may or may not be present in inherited scope. This means you could now have your function declared in a wholly separate include file from the code where the actual transformation(s) values are generated, promoting code re-use. Since you are using ECMA6, I would also consider building this as a class (or classes). Finally, from a stylistic standpoint, I would recommend sticking with camelCase instead of snake_case, as this is pretty much the de facto standard for javascript. At a minimum, don't intermingle the two. Additionally, I would suggest watching your line length. You should strive to keep lines of code under ~80 characters per line to improve code readability. 

If you decide to keep setters, why have two methods that do the same thing in and . Why have one break method chaining? There really isn't much value in returning the value the caller just sent you back to it. 

My next comment is related to the above exception handling comment, in that code that is not designed to message the end user about error conditions, should not do so. Don't just leak out end user error messaging about DB connections failing with technical exception messages. For the end user you likely want to clean up the messaging to something more meaningful as well as something that doesn't potentially leak sensitive application state information to the end user. Typically, code up the call stack from code that is actually interacting with the database is much better positioned to handle this end user messaging. 

You should begin thinking about adopting use of Exceptions when writing your classes. They are one of the primary methods for notifying calling code of errors in trying to perform the caller's requests. They can be used to convey appropriate information to let the caller make the decision on how to handle the issue (i.e. pass it along for end user messaging, try to recover, etc.) as calling code is almost always in a better position to know how to handle the issue globally than is the code being called. You are not validating any input to your public methods, thus leaving your class vulnerable to being put in a bad state (which for your class, as written, pretty much means the application will die, perhaps without useful trace of the problem being recorded in your logs). Before doing things like opening up database resources and the other things you are doing in your method, you should be first validating that passed parameters are as expected (a non-zero-length string and an integer. If this simple conditions are not met, you should ideally throw and exception or otherwise immediately stop executing the method. Ideally if you take on the suggestion to refactor, you being to get in the habit of passing around object which are easier to validate as parameters via type hinting. This means that if the objects are set up properly before being injected as a dependency into the class, the class can fully rely on the functionality exposed by the dependency to work properly. 

I don't see great need to store the reference in here. It seems odd to have callbacks against the object split across different areas of your code. If all that is happening with this request is that you retrieve the JSON for question configuration, why not just execute and store the questions on the object and then not have to maintain reference to and pass around between methods? You could even unset and make that memory available to garbage collection immediately after callbacks are processed. 

Be consistent on your usage or non-usage of semicolons to end lines of code. It seems like you have chosen to use the no semi-colon style, so why is there one after ? 

When you take out the comments from the suggested coding approach I noted above, you can see that the calling code (index.php page) would now need to know very little about the underlying mechanisms for managing the user login, the database, etc. and now only contains a handful of lines of code to get your user information set up in a state that is meaningful for the page. Login/registration 

Given: m = needles array size n = number of alt needles per given name p = haystack size This reduces overall worst case complexity from \$O(m*n^2*p)\$ to \$O(m * n)\$ In best cases (single needles, no alternate names) this solution degenerates to \$O(1)\$ complexity, whereas, yours still always requires at least \$O(p)\$. Now, if you have the opportunity to really rethink you data structures, this can be improved even further. For example, are what you really calling "alternate needles" really simply alternates on the haystack? In other words, can the alternate names simply become a part of the haystack such that you can get \$O(1)\$ look up for each needle? 

Reverse this conditional to get rid of the huge section of code within this conditional (whihc is actually not even closed with the code shown. So something like: 

From a security standpoint, you should get in the habit of always embedding session tokens in hidden form fields so you can validate that an incoming request is coming from a user with a valid session as opposed to some automated post. This is known as a cross-site request forgery (CSRF) attack. You should be able to find good example for how to prevent these attacks from Google search. 

It is not clear to me that you fully understand the difference between garbage collection of session data (i.e. bulk deletion of non-active records) and destroying session data. Your implementation is a little naive in terms of handling session destruction and garbage collection. To implement sessions in a secure and resilient way, one should strongly consider thinking of session destruction as nothing more than setting session data as invalid. That session data might need to remain (i.e. not be garbage-collected) in order to handle things such as race conditions from asynchronous requests, such that you can maintain good user experience in your application. Most mature implementations require setting of timestamp-based controls around data validity and a separate process for data deletion (garbage collection). For me, the database datamodel should include the following at a minimum: 

If you know your API is going to give you redirect, just set curl to follow. Don't write a bunch of nested code to handle these redirects. What if there are two redirects here? Your code fails. 

Do either of these implementation really do what you seem to say they do (ensure that all visible items that are orderable are selected?) Perhaps it's hard to tell without understanding whether one can "select" something that is "shown" but not "orderable". If they can, then I think your logic is wrong and you should be comparing that all three number "shown", "selected", and "orderable" are equal. 

The first thing that jumps out at me is the tight coupling it has with the current application in which it is being used. Why hard code all those CSS selectors? This class really cries out for configuration. You might see a pattern like this used to achieve decoupling of class from config. 

Consider building this as object rather than associative array, as this really seems to be more of a set of object data rather that a hashmap type of data structure. You might over time also find a need to add behaviors around these properties such that having your own class or similar makes sense. Passing around an object dependency with known properties and behaviors might be preferable to just passing around a data structure. 

If you answered "yes" to all of these questions, you should have this configuration in your main Apache server config, rather than in a directory context, and simply turn off directory overrides. This eliminates the performance hit of checking every directory for an htaccess file on every request that hits this server. This is the best way of "improving" most htaccess files. Site performance can impact your SEO. As long as you answered "yes" to the first question, you should still probably consider moving this configuration into Apache config as long as you don't have unusual needs such as not being able to restart server without complications (either on your site or possibly other sites on same servers) or having a high frequency of change to this configuration logic such that you would be restarting the server too frequently. You can also enter directory-specific configuration in the main Apache config, so typically just because you have different configs for different directories, this alone should not be a reason to stick with htaccess.