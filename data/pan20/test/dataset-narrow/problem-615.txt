Your sorting of cards to buckets takes a lot of code, which is because the names of your buckets don't match with the names of cards. The cards have just numeric values (10, 11), while buckets are named with words (ten_bucket, j_bucket). I would represent the cards as such: 

First off, consider which browsers is this DOM library supposed to support. Then test that it works in all of them. 

This separation between components and logic is good. I would suggest separating them even more by moving the and functions to separate file, which you can then test completely independently from the component. The component rendering test however is dependent on the logic. That's not good: 

That's better, but we still need to loop through all the views to find out which ones need our data. Perhaps there are hundreds of views and only three need the data. A better approach would be to use a publish-subscribe model. Instead of having to loop through all the views, each view that needs data would subscribe itself on the view who's data it needs. When the data for that view is loaded, it would publish this data to all its subscribers For example: 

You've created a tuple of parameter values equal in length to the number of parameters specified in your query. 

I will comment on the JavaScript only. Each of your change handlers are doing essentially the same thing: check if the field is null, a single space, or the empty string and add a message to a notification panel. The textbox text attribute will not return a null -- only empty string. I assume in checking for a single space you are invalidating whitespace values. As written however, a double space (" ") would validate. I'm not familiar with the YUI library, but given its prevalence would be quite surprised if it did not contain dim sort of utility method. The same notification area appears to be updated each time, but is looked up each time. Only the message is different. I would suggest the following factory method: 

This allows us to short-circuit the assignment of a value such as a name. Let's remove some of that duplicate code, and make a few more names clearer. 

This can be further modified to support your use case: checking if removing a single character will make the string a palindrome. Instead of failing when a character doesn't mirror the opposite position in the string, look ahead and behind to see if the next character will match. If so, increment a counter and continue. If the counter is equal to the number of occurrences expected (1) then the result is true. 

Follow the You ain't gonna need it principle: Don't add methods/properties to a class just-in-case. Have a clear purpose and clear plan how you'd expect your class to be used. Unless you're really sure, it's better to leave it out. Less is more. Design first for your own specific use case. Leave out everything you don't actually need. Then try to use it in another project - see if it works as is, or do you need to improve it somehow. Only after having found it useful in several places of your own, consider sharing it with a wider audience. 

Business logic or not I guess the general dichotomy is View logic v/s Business logic. So, to decide whether something is part of your application business logic, try to imagine your app having a completely different UI, like a command-line UI. Would the logic still need to part of your application with this new UI? If yes, then it's likely your business logic. Email validation and checking if user is logged in, seem to me as part of business logic. Controllers The role of a Controller is the most vague one in MVC world. That's why there exist several Model-View-* patterns: Model-View-Presenter, Model-View-ViewModel, Model-View-Adapter. To answer your question: 

Something @mjolka corrected but didn't comment on was the unused parameters in your method signature. If method parameters are not used, don't add them. This is an example of the YAGNI principle. If you later implement the functionality you anticipate using the parameters for, you have locked yourself into an implementation which may not fit your future needs. You also risk breaking consumers expecting the current behavior. If unused parameters are needed to satisfy an interface definition, seriously consider if your object fits the intent of the interface. This is commonly considered design by contract. Otherwise, implement the method to satisfy the interface contract. As a last resort, document the discrepancy in XmlDoc comments if the the object satisfies the intent of the interface and a proper implementation is not reasonable. In your example, should be implemented. A consumer relying on proper behavior could have disastrous consequences. There doesn't seem to be any reasonable custom logic possible in this implementation -- indicate is ignored if it can't be removed entirely. 

Idiomacy Idiomatic c# expects PascalCase class names and public members. Member names should be a description of their function. Consider , , , etc. OOP Dependency Inversion Your constructor is hard-coding the values needed for your connectionString. If this is simply demo code, either hardcode the entire string or do it right and have the values passed in. Scope 

Java doesn't allow you to implement it like that, but you could implement a swap function like that: 

Why do you need to display thousands/millions images? Without knowing that, it's hard to propose a good solution. 

So your component test really is more of an integration test, not a pure unit test. There are basically two ways to improve on that: 

Well... now that you've learned how to use loops, why don't you just throw it all away and try to write it from scratch. Often it's easier to rewrite the entire thing instead of trying to improve the existing code. Don't be afraid to delete the code. You've learned a lot by writing it for the first time, it will not go to waste - you'll be smarter now, and it'll be much easier to write it the second time. You can back up the original code, so you can always safely return to it when your rewrite fails for some reason. There's nothing to loose. 

As @kruga and @qntm have pointed out, it's easy to write a function that checks for the right ordering as long as the input only consists of numbers. Like so: 

That still leaves a lot of duplicate code. We will want to clean that up. Finally The truthy nature of javascript allows us to do this as well: 

I would recommend an interface with read-only properties (getters, no setters) and have your final class implement that interface and return its constant values. I'm also not a fan of your Log class. 

Your code is well formatted and easy to read. Congratulations. With regards to SRP, I believe your code complies just fine. Each dependency: the cart, rentals, and loyalty points is retrieved with a single call. The mapping for those DTO are isolated in a small single purpose anonymous method. The single responsibility for the method matches its name . If your uncomfortable with the idea of anonymous methods being separate from the method where they are defined, consider creating private static named methods in this method's class and referencing them. The only SRP violation I'm concerned with is the invoice DTO. I would recommend using the raw cart id and letting your presentation code format the title. Here's an example of how I may clean it up: 

This helper doesn't really help you much in performing a swap. I can see from your pseudo-code, that you'd really like a helper like this: 

This way it would become clear that the creation of array only depends on the count of values, not on the values themselves. Additionally the function only uses assoc-array to extract values from it - therefore I would recommend only passing in the values in the first place (it shouldn't be the job of the averaging function to extract the values to be worked on). 

Both controllers instantiate a Session object. (Confusingly inside Payment Controller two Session objects are created, I suspect that the creation of the second one is not actually needed.) Seeing within controller code I'm thinking that it starts a new session, but really it's just using the current session. The controller needs session to do its work. If a class or function needs something, it should ask for it. Best way to ask for something is through a parameter. Similarly the controllers create PDOConnection objects. Is it really the job of a controller to set up database connection? Could the connection instead be provided for the controllers. Services What is a service? Saying that something is a service, doesn't really tell us much about what it does. Like the name CartItemService only tells us that it does something with CartItems. We could have equally well have called it CartItemHelper or CartItemUtil. Its real responsibility is storing CartItems to database. So why not instead call it CartItemStorage.