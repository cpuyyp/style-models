Error handling or the lack thereof. Sending an email can fail for a variety of reasons, and you don't handle exceptions or failures. In you're sending emails in a loop - what if there's 10 managers, and sending it to the second one fails badly, shouldn't we try to ensure that the remaining eight would still receive their notifications? You don't handle edge cases either (such as an inexistent recipient: it would result in a once you tried to retrieve from a null , if didn't contain any entity under a given id). 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

and are . Did you test what happens for very large numbers? All your tests use trivially small values, certainly not the ones that would warrant the use of . Lagging constructors are a big no-no. I would aim for lazy evaluation here, or at least replace the constructor with a static method, with a name indicating it's triggering a process (create, evaluate, convert?). Constructors should be fast as lightning. 

Again, is it worth it? Sometimes the clever thing is not to be too clever, and keeping it simple beats trying to make it pretty. 

So how on earth is it able to correctly detect whether is present in the collection? Standardization Custom collections should support standard .NET interfaces such as IList. Otherwise other code can't really use it (other than as an ) unless specifically refactored to do so. Besides, your implementation doesn't allow inserting an element in between pre-existing elements, which pretty much defeats any major benefits of implementing a collection as a linked list. Generics As @MatsMug remarked already, it's supposed to be generic, yet - same as your previous implementation - it doesn't support , only its non-generic, legacy version. Documentation It's good that you now use documentation comments (at least for a class that's supposed to be of general use). But this "this is" (as in "this is a singly linked list data structure" or "this is the Node class") is unnecessary. It's just fluff. We understand that it's a class, and that the comment must refer to this class, not some other class elsewhere. Typos don't make great impression either ("Implementatoin"). If your class is opinionated about nullability (which is an improvement over your previous submission), this should be described in documentation comments. As of now, your comments are stating the obvious, for example: 

Joseph cleaned up the code a lot so let me point out a few things that you'll be able to use in your future code. 

You are duplicating the code that advances the cell indices in : once if the cell comes in already filled and again when you place the next guess. You can drop the latter and simply pass in the same cell indices since you're setting the cell's value first. 

Without the real code to be tested, I can only provide an example of how I've tested something similar with QUnit and Sinon.JS, though you don't even need the latter. You can either use Sinon.JS to mock a response to the AJAX call or substitute your own manual mock for or . I find the former preferable as it documents the AJAX call and tests the full front-end code, but it's beyond the scope of this question. You could argue that you're needlessly testing jQuery itself, and you'd be right. YMMV :) Mocking JQuery Let's assume this click event handler that uses the AJAX call to acquire a JSON string. I've omitted the extra deferred for simplicity as your current test of the promise attached to the element is fine. 

Here's a more traditional (heavyweight) OOP treatment of the problem. Note that it produces duplicates due to permutations. The fix is to change into or manually remove duplicates at the end. Both classes are immutable to make the code safer. You could also clean some of it up a bit by using Guava's collection helper methods. 

I have a simple two-class hierarchy to represent U.S. ZIP (12345) and ZIP+4 (12345-1234) codes. To allow clients to allow both types for a field/parameter or restrict it to one type or the other, the specific types inherit from a common generic interface. Update: A ZIP code is five digits. A ZIP+4 code consists of the primary five-digit ZIP code plus a four-digit plus-4 (+4) code. You can create a ZIP+4 from a regular ZIP and get the primary ZIP from a ZIP+4. Thus, the interface which the two classes implement knows about the two classes, and they know about each other. 

You have not implemented exception handling (the last requirement). Eg. if calling code passes to or , it won't crash straight away, but as soon as you call , it will result in an unhandled once it gets to this null "fruit". Also note that we don't know what calling code may pass in as an argument - could be some object that implements one of the interfaces, but actually explodes once our code calls its or ... The requirement states that it's the responsibility of this code to handle exceptions, so if this was my homework, I'd prefer to be on the safe side here. Less importantly, you implemented as a property of rather than a field (which is what the description asks for), although public fields actually are considered a bit of a code smell, and a backing field is automatically created for properties, so I would leave it. Aiming at good code style you could make it immutable though (as a field, or a property with a private setter), and set it in the constructor - it stands to reason that name of a given fruit isn't subject to change. and could be too, but that's nitpicking already. Apart from the lack of exception handling, it seems okay to me. I like that you used some modern C# features to cut down on verbosity. 

the else-return bloc doesn't serve any purpose. The same with calls at the end of methods (, , , , ): redundant. These methods are exited anyway. You don't need to use both and clauses. It's one too many. Eg.: 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: 

Let me say up front that I'm far more familiar with unit testing than behavior testing, but this looks an awful like you wrote the tests after the code. When I think of "behavior", I don't think of neatly mapping it to method names. Instead I would write use cases that may require multiple method calls. 

Parser The code as written solves the small problem of configuring a PDO connection via an INI file, but it won't scale to handle other connection types. As tim pointed out, barely abstracts the act of parsing the file. Its validation is already handled by : an unreadable file or malformed sections will result in a return value. Worse, pulling values from another section requires reparsing the entire file. Also, while it looks like omitting the section will allow you to access the top-level values, I suspect it won't actually work because will not pass. My first step would be to design an INI file abstraction with these features: 

Style Variables and functions (except constructors) in JavaScript are normally written in with a leading lowercase letter. It's not mandatory, but you'll find it easier to work with others if you follow a language's conventions. There are many guides out there, but I mostly follow Google's JavaScript Style Guide. Some of the variables do not change once set. These should use to denote that they are constants and probably assigned at the top. Another point in the guide is to surround all operators and keywords with a space. Omitting the space between , , etc. and the opening parenthesis makes it harder to skim without syntax highlighting. You can omit comments that merely restate the code in prose. At best they waste the readers time, and at worst they become misleading or incorrect when they aren't changed with the code. Good comments state programmer intent or clarify tricky algorithms. This comment adds no value. 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

What's the point of catching a ? When do you expect it to happen? I don't really like that this method mutates the list passed in as a parameter - and then also returns it, even though the returned value is actually redundant as the calling code already has a hold of the now modified list. You're kind of sharing the result of the operation in two ways at once, which feels redundant. And I know it's often done that way, but I think it's bad practice nevertheless, and can lead to confusion. Personally I'd prefer to be more explicit about what's going on, and either a) make a deep copy of the original list, and return an independent version of it (with entries removed), without affecting the original one - or b) make this method , like Collections.sort(). See command-query separation principle. Making a method look like a query can lead me to believe it's a pure function, with no side effects, whereas it actually does cause side effects, mutating the input data. The name is very vague - "remove", remove what? Is the blacklisted data ("FIRST", "SECOND", "THIRD") likely to ever change? In the spirit of making this code more modular I would consider extracting that list to a separate parameter. Single responsibility principle indicates that a method should have one clear responsibility, and one could argue that filtering out certain entries and knowing the blacklist are two responsibilities. Your mileage may vary though, depending on the cnotext - which I don't know. Not a biggie, but whitespace is out of control (, ), not to mention it's , not . Depending on how class is implemented, which I can't see - if it's a light-weight object and if its method would compare instances by their value ()... then we could leverage Collections.removeAll and save ourselves writing the iterative removal by hand. 

Perhaps will better convey the fact that it's solving the puzzle. sounds like a function that fills in the initial positions from a file or string or something. You could shorten the "is the cell is filled" check by dropping the for maximum C-ness: 

Another option is to forego separate classes altogether and check for a special value in and to signify a missing ZIP code. 

I hope this gives you enough to go on. The idea is to move the scene-specific logic into the model so that you can continue the story without writing more code. 

Not Go-specific since I've only skimmed the syntax, but good advice in any language, you should refactor to extract several methods: 

Looping over the rows and columns in and is costing a lot of time. You can achieve those effects more efficiently by tracking the possible values available to each cell, row, column, and box. The last three can be modeled using a collection class that knows the cells it contains while each cell knows which groups it belongs to. 

Design Review As the story grows you'll find yourself spending a lot of time tracking down copy-n-paste and errors in the handlers. A lot of the code is repeated with minimal changes: key numbers, scene names, and virtues mostly. Now that you have a representative example for each type of scene it's time to generalize the handler code and move the data behind the logic into the model. The simplest is the menu as there are only two choices (one implemented) with no warnings or virtues. I've removed the explicit keys since you're using numbers and it shortens the code. 

Blech! :) You could solve the problem and expose a cleaner API by providing type-specific accessors. 

Shouldn't this be a , or ? And why is it defined in ? It feels wrong if a parent class knows about its child class. 

But why would you assume that whatever time passed between opening the connection and disposing of the entire object, was consumed by query execution? Especially since you do this at the very end, after disposing of the connection, params object, transaction and command objects :) and the object is apparently supposed to be reusable (). Disposing 

There, I'll say it: it can't be done. C# doesn't allow identifiers to start with digits. All workarounds either won't meet all your requirements (eg. @radarbob's answer, while clever, doesn't let you narrow down numeric values to a predefined set of legal ones, which I understand to be your main goal) - or will get you on a ride that ends up back on square one (if you use a dictionary as @Malachi suggests, then the name of this dictionary will go upfront, and it still doesn't start with a digit). Underscore prefixes are as close as you can get. Abusing Unicode a bit might work to a degree: 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

from (minus the case sensitivity discrepancy). Unless there are some good reasons not to do so, I'd stick to only one implementation and reuse it in both methods. 

Correctness Does it even work? Did you write unit tests for it? For example I can't see where the method makes any use of argument (other than to assert it's not null). 

The parser is doing way too much to cram it into a single method, and that it knows every operator requires two operands paints yourself into a corner. The first step is to move this code into a separate class that can maintain the stack and do the work to manipulate it across methods. The parsing method needs to be refactored into methods to scan the input, parse each token, apply it to the stack, and finally return the result. Here's a rough cut: 

Gotta say that I'm not a big fan of a single space for indentation or putting multiple statements on a single line. I've worked at a company where we used two before, and that was confusing. One is asking for trouble. And with 24+ inch monitors common, there's no need to be so frugal with your vertical screen real estate! :) The assertion seems like a good choice, though you might consider returning a signaling value instead. It really depends on what callers will expect, and make sure you document your choice. 

You can improve the code even without a separate class in the case that you don't need other detection mechanisms. The following will allow you to easily add new prefixes but nothing more. 

Another aspect to consider is cache locality as the pool grows. The cost of allocating a small temporary string may be far less than an L1/L2 cache miss. You could randomly generate strings such that the pool will grow to thousands of unique values to see if it has any effect on the benchmark. 

If after adding the index on and you still see poor performance, trim the query down to the bare minimum to isolate the source. Remove all of the joins and the where clause referencing those tables. Once it's doing just the distance calculation (which should be move to a deterministic stored function), you can get a better time measurement. On an unrelated note, you can set the three variables at the top with a single statement using .