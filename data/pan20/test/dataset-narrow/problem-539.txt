Edit: You could move the declaration of both event listeners out of the loop body. However, the dropdown toggle's 'click' event listener needs access to the dropdown element it belongs to. So you would still need a closure or alternatively bind the event listener's to the dropdown: 

Especially the last two changes are subject to personal preferences - some prefer the declarative style, some stick to everywhere - it's your (team's) choice. 

Also, I use inline comments to help the reader and my future self to understand complex statements such as 

Let's build a schedule for 10 teams. I intuitively came up with the following circulant 10x10 matrix with entry denoting the opponent of team in round : 

We can get rid of the self-made zero-padding by using or - if compatibility is a concern - one of its many alternative implementations. We can't really get rid of the many hardcoded constants, but we can name them to make them meaningful and less magic in appearance: 

Now, it is much easier to see that the inner loop is actually just checking the existence of an element within an array. You can use the faster built-in method instead: 

To keep things simple, all comms between client and server send and receive delimited strings which are read by each component and handled in a particular way for each. Is this a fairly decent implementation or a client/server program? How can I improve this or make it more functional? 

Well, it's 2 applications really. Each one does its own stuff on the front-end. It's the networking that I'm most concerned about. The Server starts listening for connections on the specified port as soon as it starts up. When clients connect, it accepts, serves and boots them in turn (or rather that's the idea but I think there's a flaw in what I've got here). The server is multithreaded to handle requests on new threads so as to avoid locking its UI while it works. 

To generate a password, I generate a key using RNGCryptoServiceProvider. The key is 9 alphanumeric characters long into which I insert a single non-alphanumeric character for a full length of 10 characters. Having a mix of Uppercase, lowercase, numbers and symbols and being 10 characters long, as a plain text password (which you'd enter when logging in somewhere), this password should be more than adequate for most situations. 

Apparently is a and is an . In order to parse this as a date, I need to convert it to an int. These bytes represent the timestamp (or ). I have code to convert this byte array into an int, but there has got be a better way to do it than the way I came up with. 

is the "Date" header, is the data length (4 bytes) and the 4 following bytes represent the date (timestamp). I have code to read those 4 bytes and return it to me as a : 

This is just an extension to @palacsint's answer. You shouldn't pass strings to , it uses , which is inefficient and insecure. You should pass a function. Problem is, in the loop changes, so you'll have to use a closure. Don't do this: 

Like I said, this code works, but I just feel there's a better way to do this than to convert the bytearray into a string and then parse that string back as a base-16 int. 

I feel like I had to invent a whole new way to do this because I couldn't find anything that did this the way I wanted to... The basic process involves reading changes to cells and capturing information about those changes as they relate to the actual Entities in question and then persisting them to the database. Here's the XAML. I didn't use databinding because I don't quite understand it yet and I'm on a bit of a deadline for this one so that's item number 1 on my to do list when I get a break. Note that this project has been my first every foray into WPF. I've dabbled a bit in the past but I've really pushed myself to do things properly here... As properly as I know how anyway. 

I used to use PBKDF2 but I was informed that bcrypt is better so here we are. While I understand the rule "never use your own auth", is this code likely to provide decent security? What sort of vulnerabilities are present in implementing this system for security? 

Since the best-case runtime complexity did not change, we only see minor performance improvements. The runtime is dominated by parsing speed. Worst case - input queries repeated 

You asked what happens when you don't initialize in the loop body? Initially you create a single array instance . Then, during each loop iteration, you modify the content of this array and push it onto . So in the end, each index of contains a reference to the same array, similar to this: 

Also, it is not clear how strong the given assumptions are and whether or not violations of those assumptions can occur and should be dealt with. 

returns an array. So don't bind the result to a variable called . Or better, since you can't have multiple array entries with the same name, replace with : 

The native is fast, but comes with a certain constant setup cost that makes it slower than your implementation for very small strings. As soon as the input strings get longer however the built-in outperforms any other solution: Small strings: 

I thought of a neat solution to this. Not sure how efficient it is, but I thought it was neat. If you look at your result array, you'll see results from "0000" to "2222". These are the numbers from 0 to 80. In base 3! So, using that, I whipped up a function to create all numbers in that range as an array. 

For fun, I made a function queue in JavaScript. I named it tinyq. You can add functions to it, and each function is passed the next function in the queue. You can also pass parameters to the functions, and they can return values. 

I am working on a program to decode MMS PDU files. They are binary files and I am reading them byte by byte and decoding each header value as I come to it. One header value is the Date, and it's represented as follows (in hex): 

So, what do you think of my function queue? Any improvements, or anything I'm doing wrong? P.S. I was also trying to make this small, any suggestions on making it smaller? 

From here the user clicks on a save button which loops through the changes captured in this list and updates the relevant records in the database: 

The Client is much the same, except its not listening for connections. It's only job is to send requests to the server and display the result that the server sends back: 

I've struggled with this for quite some time. Today I finally wrote the following code. The ViewModel contains an property which later tells the view how many pages the data has been split into. The controller splits the data by taking a specified amount of rows and, in the event of paging, splits by Take a look: The ViewModel 

I can then validate the input at login more or less with this function - I haven't tested this code since I'm writing it for the first time for this question. 

In this code, assuming 300 posts are selected from the database and 10 posts are specified per page, then there should be 30 pages.