You should take a look into ambient lightning. This means you set a light color which is applied to all elements. This could be done in several ways. If you are using a shader for postprocessing you can add it there as a parameter and just change it to simulate day and night cycles. A nice example was shown here (its in german, but maybe the source will help you a bit). It basically uses blend states to mix up different render targets containing the light sources. 

Hey I will try to give you a starting point. Your problem of handling the input in more than one method could be solved by creating your own small messaging system: 

What about using a DispatcherTimer ? You could start the timer with your timeout a Interval value and register a tick event. When the event fires you throw a exception for a timeout (or do whatever pleases you). You could even hook up the DownloadProgressChanged event of the webclient and reset the timer or smth. like this. 

So in your problem you would just set to true in the script manager and return the message. Your InputManager would see this and break the loop. You could even use this system to change input messages in your components, if you ever need to do so. Logic in InputManager could look somehow like this: 

Edit regarding your edit: Just to clarify: There is a huge difference between a list beeing null or empty. When you are creating your var, you basically just tell the code that you want to use a list somewhere. This object ist still null, which means there is no memory allocated for it. You need to create the object (again in C#) usally by using the constructor. The list constructor will yield you an empty (but no longer null) list. To this list you may add objects. This is your error, accoidng to this article about collections in unity your syntax is not wrong, but it is incomplete. See this snipped from the article: 

As you notice you need to initalize the list first via constructor, by calling it with the new keyword. 

As Gustavo mentioned, you can use gameTime in Draw and Update. You may also write your own small timer class, which gets updated with the gameTime (and simply adds it up). This makes sense if you want to add some more logic to your timer class, like events or callbacks. 

You can also define a Routine in every card (if you are using OOP) for the Animation and pass the SpriteBatch as an Parameter: In the card class 

While this is a possible approach, maybe you can handle A and B in one turn, skipping half of your collision checks Hope this gets you started =) PS: Even if you said you dont want to hear it: Try to keep the collision detection in the same thread and just speed it up enough. Threading it seems like an good idea but with this comes the need to synchronise like hell. If you collision check is slower than your update (reason for threading it) you WILL get glitches and errors, because collision will trigger after ships moved already and vice versa. I don´t want to discourage you, this is just a personal experiene. EDIT1: Links with QuadTree tutorial (Java): $URL$ 

You might be interested in shapes. It is an c# with XNA library to work with shapes of every kind. I dont know what language / platform you are targeting but with the source code provided by codeplex you should get an idea of how to handle shape creation, collision and picking. Slicing is a problem for itself, you need either to composit your shapes of smaller shapes and split them after slice, which would be the easier approach, but also limit the player. Or you regenerate your new shapes with your algorithm after the users sliced the old one. Depending on your desired shapes you may want to have a look at metaballs, which handle composition of bodies (and therefore shapes in 2D) from particles. 

I created a minimal test project to test your solution. The problem with the 2nd stack having a count of 10 is related to some reference and value passing mistakes. There are plenty of resources about this topic online (search for 'pass by value vs pass by reference c#') However I discovered a new bug :) When the first stack is full, the backpack always created new stacks with count 1, as you don´t check if the second stack still has room: 

Ok at first glance there are some things you should try out. At first you should try to reduce your collision checks, you can do this by using some kind of spatial structure like a quadtree. This will allow you to reduce the second foreach count, as you will only query entities close the first one. Regarding your threading: Try not to create a thread every Update turn. This overhead is maybe slowing your down more than its speeding things up. Instead try creating a single collision thread and let it do the work for you. I have no concrete copy-paste-this-code approach, but there are articles about thread syncronising and background worker for C#. Another point is that in the foreach loop you don´t need to do because you already accessed the dict in your foreach header. Instead you can just write . I don´t really know about the impact of this, just wanted to let you know ;) One last thing: At the moment you are double checking every entity, because it gets queried in the first AND the second foreach loop. Example with 2 entities A and B: 

There is a very good post by Shawn Hargreaves about XNA with WinForms you should definitly check it out. In addition here are two tutorials aout XNA in WinForms and WPF, with a bit more complex event handling (both are in german) Maybe try to set up a timer and rebuild XNAs fixed time step. This will queue the timer in your UI thread processing and update the drawing. Invalidate will be called whenever a new frame is prepared and ready. 

You can just draw the animation over the card by a second draw call. The code will look something like this: 

Just add a boolean indicating which direction you are currently moving in. Depending on this you in- or decrease the current frame. You need to set the boolean to false, after you reached the last frame (to move back again) and to true after you reached the first frame again. This will oscillate between back and foreward 

Ok I am going to give you simplified answer here. Start with creating a spatial structure like a quadtree. There are plenty of C# docs about this online. The main idea is to divide your galaxy into a grid, you start with one big cell and divide it into 4 evenly sized cells and so on. Here is an article about QT in C#, but please try to unerstand the concept and don´t copy - paste, as your problem calls for a very special implementation. After reading the article you should be aware of a mechanism that lets particles register with cells if they move. So if particle A moves from cell [1,1] to cell [2,1], then it has to unregister itself in the first cell and register itself in the second cell. With this structure you gain a tree, with different granularity. What you can now do is creating a Level of Detail for your mass points. On the finest level (the leafs of the tree) each particle will have its own mass and center. If you now step one level up, you will have a node which contains a number of leafs (planets). You now calculate the center of mass and the mass for all planets combined (by c*alculating the median position of all planets* and adding the mass up). Now you again step a level up and got a node containing a number of sub nodes (which we just calculated). Now you do the same thing again and generate a new center of mass and a new added mass. Continue with this process until you reach the root node. You will now have a tree, where all planets are singel leafs and every node contains the median center and cummulated mass of all planets below it. In your Update-logic you now won´t check against every single planet any more. You will calculate the exact force for planets close to the object (maybe the same node level). For planets further away you will not step down into the tree until you reach leafs, instead you will use the previously calculated median values to genereate and approximated force. Whenever a planet / object changes its tree-cell you need to recalculate the tree from there upwards, but it should still reduce your calculations by a great amound. Try to implement a system like this and play with the paramters. You should be able to create a quite powerfull system with this tools. This is a lot of text, try to wrap your head around this and feel free to comment back for questions :) PS: Its baffeling me that your movings planets create such a huge drop, as you are calculating gravity for static ones too (aren´t you?) maybe there is a also a problem in the movement code. PS2: maybe try changing into . while this won´t be the source of your problem it should increase speed a bit ;) 

There is a wiimote plugin for unity. I have never used it, so I can´t tell you how much customization it needed to make it work with Android, ios and wp8. I guess you could get some help from the unity community but nevertheless this would be something for experineced unity users. At least for WP8 I know about a bluetooth api, which may be used to connect to the wiimote, while you need to write most of the logical mapping by yourself. 

As an alternative you can use an int array for the numbers and another array for the walls and binary code the walls. As for XNA it will help you with some higher MAth (which I assume you dont need) and with the rendering part. It is basicly a framework which helps you at working with directX, so if you want to extend your game in this direction (maybe use 2D graphics instead of plain numbers) it may get very handy. For me the structure used by XNA also feels very confortable so I use it even in some non directly gaming related project. But this is of course a personal opinion. I hope this helps a bit! Regards floAr 

InputComponent would we an interface or abstract class adding the Takeinput function to your class signature. Hope this gets you started, feel free to comment, if you got any questions 

Extending the comment made by @ashes999: Make a big Excel spreadsheet, then calculate every metric you can get. This includes: 

Update and Draw could be defined in the entity base class, then you main class would not even need to know what exact subtype of entity it is dealing with. I would vote for a similar approach for your draw method. Just call each entities Draw method from the main method and pass the context into the function. 

This will test with a rectangular shape. If you want a really 100% accurate result you will have to look into picking (This may get you started) Hope this helps ;) floAr 

Just creating a backpack an passing 15 NEW items to it. Backpack.cs is the one taken from here. And a simple Items.cs stub, just with the necessary Properties: 

Hey Noupoi and welcome to gamedev.stackexchange! Starting with your first question: As your game board will be a nice rectangular thingy you can use an array. $URL$ To represend the game board you may want to create your own data structure which contains the folowing informations: 

You could just du a ray / plane intersection with two rays, after deciding how the triangle intersects with the plane (To intersect at all 1 point has to be on side A and two points on side B of the plane) This is my standard 'way-over-the-top' ressource for intersections you can look at different implementations and pick the one best suiting your need. I little less complex is this side, explaining what to do and providing a trianlge-ray algorithm in c (and a lot more under 'algorithms')