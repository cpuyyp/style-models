The sensor datasheet will tell you the permitted input voltage range. Although you will get results by powering the HC-SR04 from 3V3 the results will not be reliable. If you want accurate readings you need to power from 5V. See this post. 

$URL$ shows the needed SPI GPIO. For the auxiliary SPI (spidev1.x) you need to connect miso, mosi, sclk. You also need to choose a slave select line as follows. It doesn't matter which you use. 

You should undo all that configuration and use device tree. Other methods have been deprecated for several years. Edit and add the following entry, then reboot. 

Be aware you should never connect a voltage greater than 5V to a Pi GPIO (they are all 3V3 safe only). There are plenty of GPIO libraries which will display the GPIO state. Depending on your operating system both wiringPi and (my) pigpio are likely to be pre-installed. For wiringPi use the command. For pigpio use where is the Broadcom GPIO number. See $URL$ for lots of alternatives. 

It's impossible to properly answer. We don't know how efficient your LEDs are or how bright you want them. I'd be looking at resistors in the range 300 to 1000 ohms. If you do plan to have them all on at the same time then perhaps try resistors in the range 800 to 1000 ohms. 

Q1 I don't remember but the code may well use a rolling average to calculate the RPM. This helps smooth the data. Q2/3 The code as given is instantiated with 

I suggest you use a recent Raspbian (it would have been helpful to know which operating system and version you have installed) and a recent RPi.GPIO (ditto its version). RPi.GPIO on Raspbian has not required root access to manipulate the GPIO for several years. By the way there is other SPI software to read SPI devives, the Python spidev module would be a typical choice, it would do away with the Adafruit dependency. 

Alternatively perhaps you should try GPIO4. GPIO2 and GPIO3 have hard-wired pull-ups to 3V3. Does your button take this into account? EDITED TO ADD Given that both of the above variants work on my system perhaps your system is out of date. Try updating the modules, e.g. 

I'm not sure of the maths behind the speed but of the order of 4000bps seems to be the maximum data rate for typical IR remote devices. E.g. $URL$ I presume this limit is to do with the 38kHz (or about) carrier wave. IR devices without modulation can talk at 4Mbps (FIR) over limited distances. E.g. $URL$ 

1) You can use the command iwlist channel to find the channel. 2) No idea, I suggest you look at iwconfig. 

A GPIO set as an output and driven low will only show high if it is connected to an external power source greater than that driving it low. I suggest you switch off the Pi and post a photograph of the circuit. 

I can't find any definitive information. My own experience is that timing the length of the echo gives correct measurements. Timing from the end of the trigger would introduce a fixed error of about 7 centimetres. Of course as the error is fixed it could be removed from all results, however the offset might vary between acoustic rangers. 

I can't see anything wrong with your logic or your code (although I haven't tried running the code). Double check you are using the correct GPIO. GPIO 6/12 are on pins 31/32 of the 40 pin expansion header. You could test the code receive logic with my pigs utility (part of the pigpio suite). 

One method which is tailored to the Raspberry Pi would be to use my pigpio library. The pigpio daemon could be running on each Pi. That would allow you to control each Pi using a Python script running on your Ubuntu box. Alternatively you could arbitrarily choose one of your Pis to be the master and run a script on that to control its and the other Pi's gpios. I can't say that I'd want to do this over the internet though. It would possibly be more sensible on a LAN. 

The UART connected to GPIO 14/15 (pins 8/10) is normally named . Only the Pi3 defaults to using as a different UART is connected. So to talk to the Arduino try 

The HC-SR04 specifications say it needs a voltage between 4.5 and 5.5. Using 6V will likely destroy the sensor. You need to split off the 5V supply from the Pi, for that you need 5V and a ground. To operate the sensor you also need two GPIO, one (OUTPUT) for the trigger and one (INPUT) for the echo. You can get ground from pins 30, 34, and 39 on the Pi2. GPIO 5 and 6 are available on pins 29 and 31. You just need female to female Dupont jumper wires to connect those pins to the sensor (but see echo pin note below). For the 5V supply I would strip one end of a female to female Dupont jumper wire. I would solder the stripped end to the underside of the Pi to one of the 5V pins. Please note that the sensor echo pin will be 5V which will eventually kill a Pi GPIO as they are only rated for 3V3. You need to drop the echo pin voltage from 5V to 3V3, perhaps by using a pair of resistors as a voltage divider. 

You can only control the voltage of pins connected to GPIO. Pin 1 is connected to the 3V3 rail and is NOT a GPIO. GPIO 1 is connected to pin 28 on the Pi models with the 40 pin expansion header. 

The digital output will tell you when the set threshold has been exceeded. You set the threshold with a screwdriver and the blue pot on the board. It's simplest if you power the device from 3V3. If you need to power from 5V you will need to add a voltage divider on the digital output to shift it from 5V to 3V3. 

Finally remember that pigpio only ever uses (Broadcom) GPIO numbers. So 14 refers to GPIO 14 (pin 8) and 21 refers to GPIO 21 (pin 40). 

The sysfs system filesystem access to the GPIO is all that is provided as a standard library from Linux. There are dozens of third party libraries. See $URL$ for some of the third party libraries. 

define an environment variable given the Pi's host name or IP address. E.g. or . pass the address in the call. E.g. or . 

I have just connected a MFRC522 module to a Pi3B and it works fine. I used the following connections 

I'm not sure there is an appropriate solution (there are solutions which I'll leave to others as I don't think them sensible). You should only run up against this problem when you want to do system administration. You shouldn't need to use sudo for general day to day work. The system is blurred on the Pi as the normal user will almost invariably be the same person as the system administrator. I'd spend some time examining why you need to use sudo. It shouldn't be needed for anything you do in your /home/user directory. For the rest I'd just launch a command shell from the GUI and enter the needed sudo commands there. 

Given that the maximum 3V3 output of the Pi is claimed to be 50 mA that puts an upper limit of 3.3*50 = 165 mW. Furthermore given that an individual gpio is said be harmed if you source or sink more than 16 mA that suggests an upper limit of 52.8 mW. In practice I expect it's much less but have no idea how it could be measured. 

The diagram does not show pin numbers. Neither can I find anything on the diagram labelled 1. The diagram does appear to correctly label the ground and 5V pins. You can power a 5V fan by connecting its power leads to a 5V pin and a ground pin. It will be on all the time as you can't switch the 5V pins on or off. Do not try powering the fans from a gpio. The likely result will be one or more broken gpios and possibly a broken Pi. 

On occasion you might want to run a script as root in which case precede the previous two commands with sudo. Use the following commands for help 

1) DHT-11: The manufacturer should recommend a resistance (pull-up to supply voltage on the data line). If you are supplying more than 3V3 you will need another resistor from the data line to ground to act as a voltage divider to cut the data line to 3V3. For a 5V supply the resistor to ground should be twice the other resistor. 2) PIR: I didn't think one was needed. What is the resistor for? 3) Soil sensor: I didn't think one was needed. What is the resistor for? 4) Sonar ranger: The data output line needs a voltage divider if you supply the device 5V (as you should if you want reliable results). The resistor to ground should be twice the value of the resistor to the data pin. 5) LEDs. A rule of thumb is a resistance of 200 ohms per volt of supply voltage. So for 3V3 try 660 ohms. If the LED is too dim try a lower resistance. 

The Pi is more than capable of handling this task. There is no need for a separate Arduino. You will need a motor driver board to drive the motors (assuming you plan to use ordinary DC motors or stepper motors). I have no knowledge of LabView. This site prefers not to answer multiple questions in one question. 

You can reliably read Wiegand devices with my pigpio library. There is C, C++, and Python example code at $URL$ 

You would probably get better results if you use pigpio callbacks which do not suffer this problem as the timing is handled by the Pi hardware. A Python example. Other examples including C. 

pigpio provides the C and Python hooks needed by a programmer to use arbitrary gpios as serial links. The incoming C hooks are somewhat simpler than the outgoing C hooks. For the Python hooks see $URL$ 

Yes, it should work, the Pi2 has four USB ports so will support at least four USB devices. No one can answer the second part of your question. We have no idea of the relative quality, reliability, power consumption etc. etc., of the devices you might purchase. 

It should work. All the Pi's gpios are 3V3. The 5V pins on the expansion header are not gpios, they are pins connected to the 5V power rail. In effect they are directly connected to the microUSB power socket. 

My pigpio Python module supports this mode of operation. You have the pigpio daemon running on each Pi. You have a control script on the master Pi which connects to its own Pi and the remote Pi. This allows you to manipulate both sets of GPIO from the one script. 

Have a look at how I implement a Sonar Ranger and a Rotary Encoder as Python classes using GPIO callbacks with my pigpio library. A GPIO callback is a method of being informed of GPIO level changes asynchronously of the main thread. The callback can set a flag or if a class a method can be added to get the current state. You should be able to do something similar in your code. 

The 16000000 figure will be the SPI bits per second (so 16 million bits per second). That is the transfer speed between the Pi and the screen. Presumably 24 million bits per second (Mbps) is leading to corrupt data on the link. It is close to the "safe" toggle rate for the GPIO. The SPI hardware supports the following baud rates 15.63, 17.86, 20.83, and 25.00 Mbps in the region of interest. It is not obvious how the SPI driver chooses the baud rate. I suggest you try baud rates from 16 million upwards in 1 million steps until you find the highest stable setting. 

Yes, you can use such a circuit. Whether it could break the Pi or not would depend on what you are switching on and off. A LED will be fine, a relay coil, motor, or other inductive load, could damage the Pi. 

It depends on the module you are using and if you have changed the GPIO state using the module (rather than indirectly by calling a shell program to change the state). My pigpio leaves the GPIO in the last set state. I'm not sure about wiringPi (Python). RPi.GPIO and RPIO.GPIO both have a cleanup function. If that is called then any GPIO you have changed with RPi or RPIO functions will be set as inputs with no (resistor) pulls. 

I suggest you monitor the commands you are sending and compare them to the commands received from a unit known to work. You can use my piscope to monitor the pulses. An alternative terminal based script is monitor.py. Both programs require the pigpio daemon to be running (). It's also worth checking to see if the range is the problem, i.e. place the receiver close to the transmitter. 

Possibly normal if it's a very brief flash. I'm surprised you notice the flash, most people don't. The system checks (presumably) twice a second to see if an SD card is present. See $URL$ 

You could try my test program to see if the gpios are still functional. $URL$ It's more likely that you have managed to get incompatible software versions in the process of installing webiopi. 

Yes, it is normal. GPIO 0-8 have their internal pulls to 3V3 enabled at boot. That will allow enough current to flow to dimly light a LED. 

You need to ensure each sensor is measuring exactly the same environment before making a judgement. Have a look at the I2C based Si7021. I left a Pi plus DHT11/DHT22/Si7201 under a plastic tub for seven hours, taking a reading every 3.3 seconds. The DHT22 and Si7021 are clearly in the same ball park. The Si7021 seems to have a lot less jitter. Relative Humidity % 

The Pi does not have factory settings in that sense. Everything is held on the SD card. You will have to burn a new image to a SD card. 

The Pi Zeros have no additional protection when powered via the microUSB socket over a 5V pin. The other Pis have three types of protection when powered via the microUSB socket. 

You need to switch on with an SD card containing an operating system inserted in the Pi's SD card slot. Otherwise nothing will happen. 

Assuming that you have wired up correctly the most obvious error is the softPwmWrite() parameter of HIGH which I assume will be 1. You need to give a larger value, try something like 100000 (I don't know what the legal range is but I believe it is clipped to the maximum value). Given that you use I would try . The relevant prototypes are 

I do not believe you can successfully execute those instructions from Linux userland. I thought only Linux kernel code could successfully execute those instructions (sudo/root is not the same as kernel). A kernel module to enable access to the CPU cycle timer is given at $URL$ It uses the following (kernel) code to allow access to the CPU cycle timer from userland. 

I'm not sure if this would give quite the symptoms you appear to have. It may be because your current directory is not where you previously stored the ip file. Try adding the following line as the second line of updateip.sh. cd /home/pi/scripts 

The first 26 pins on the 40 pin A+ expansion header have the same functionality as the first 26 pins on the standard A expansion header. If your screen works on the A expansion header it should work on the A+ expansion header. Why not post a link to the screen? 

If you connect ground as an input it should return -50 degrees centigrade. If you connect 3V3 as an input it should return 280 degrees centigrade. 

The Raspberry Pi has hard-wired 1k8 pull-ups to 3V3 fitted on pins 3/5 (GPIO 2/3, SDA/SCL). You shouldn't have any other pull-ups on the bus. Some I2C devices have their own pull-ups, if they are to more than 3V3 they can feed a risky voltage into the Pi. Measure the voltage in the idle state. It should be 3V3. If it isn't there is something bad going on with the bus. 

That might get part way to what you want. You can also tell Linux not to use a core (at least I think there is a option or it may be a standard Linux boot option in ). However if Linux isn't using the core how will you execute code on the core? I've heard of suggestions to use bare metal on the dedicated core. I don't remember reading of any successful hybrid experiments.