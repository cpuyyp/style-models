Those are quite different things and it's hard to give a definite percentage. QA (â‰ˆ hunting bugs) is usually the job of a entire QA department, this can include several employees, and even several companies or locations. This is a day-to-day task: the earlier bugs get spotted, the earlier they get fixed, so the bug hunt is really running continuously. Usually this task is taking more and more space when production advances, from almost nothing in pre-prod to almost 100% when getting close to a gold master. E.g. at the end of a production, big studios take advantage of time zones to get daily builds tested overnight, literally from the other side of the world. Playtesting on the other hand is something that's performed less often, but requires more preparation. For it to be useful, you need to find and select playtesters, you'll want them to match your target audience, and you'll have to prepare playtesting sessions to get the most useful information out of it. "Digesting" what gets out also takes some time. Because of those requirements, this is something performed occasionally, but regularly anyway (I'd say from two week to two months for a big studio). But that's for formal playtesting, everybody involved in making a game actually gives input on it on a daily basis: that's not something really measurable. 

You could get a Junior position in a studio with the very same requirements, especially considering that you've already developed a few games. Prepare a good-looking resume, your portfolio, and hit the road. This would be a much more valuable experience, and IMHO will teach you at least as much as this course. Not to mention that, well, you'd get paid for it instead of having to pay. 

As Trevor mentioned in his comment, your only option might be to reduce the size of your kernel or to perform further downsampling . But did you thoroughly read the tutorial you've linked to? There's a tip about exploiting hardware filtering, that the author calls the "sneaky" version. It's probably the best trick you can use to optimize you bloom effect without affecting its quality. 

You use but you never set it, as your loop goes from 1 to 8. I suspect that the method is more expecting some kind of id defined in your rather than a file name. 

Sorry, you can't use D3D9 directly for Metro-style apps. But you can use D3D11 and limit yourself to some feature level (e.g. ) if you want to support legacy hardware. 

It's apparently straightforward to exclude files/directory from version control with Plastic SCM, by using an ignore.conf file. 

I'm not sure you should go through the burden of using a library just for rounded joints. You could draw thick lines with discs at the intersections, i.e.: 

It used to be PIXWin.exe, not winpix.exe. At least that was the case for the last DirectX SDK (June 2010). It seems that things have changed now: 

Be aware though that like any multithreading technique, this is error-prone and you need to design you process carefully to avoid nasty issues. 

When your player picks up a new buff, you simply create it and push it to the back of the list. When you need to cancel a buff, remove it from the list. The buffs with a duration will time out by themselves after a while. This will apply the buffs "chronologically", but I personally don't recommend this gameplay-wise. For instance the sickness divisor would be more or less penalizing depending on if you get it before or after a boost. To circumvent this issue, I would rather always apply the divisors/multipliers first, and the bonuses/maluses second: 

I've not searched the documentation for this but Windows is probably not spamming messages all the time: they have to come at regular intervals or they'd be clobbering the system. Maybe they use the keyboard refresh rate if you keep pressing one key. Maybe they use the screen refresh rate. Let's say a new message comes every t ms, reasonably greater than epsilon. The part of the loop will process all stacked messages very quickly: it will run for epsilon ms and start again, which leaves no chance for new messages to arrive. As soon as all messages are consumed, the part will run and new messages will stack again. Here's an illustration to try to make my point, are processings of the messages sent by Windows, and are actual frame updates: 

Deactivating input isn't the usual way to react to environment collisions. In a nutshell, it's probably a better idea to affect your tank position when a collision is detected. Roy T. just gave you one proper solution. You could also do as follows without modifying too much code, just stick the tank to one of the reactor's edges when a collision is detected: 

Keep going, and be good at it, we'll need low-level engineers for a long time to come. Innovation happens everywhere, from the very high level to the very low level. But don't limit your vision to a small part of the spectrum, you should always maintain a good picture of how things work at all levels. A side effect of team sizes growing is that people are getting more and more specialized, so a deep knowledge of the machine is valuable, as long as you're able to work in a team so this knowledge gets beneficial to everybody. 

There is indeed an optimization part in this. The more programmers get used to a console hardware, the more they learn how to squeeze graphical quality into it. But it's far from being the only reason: 

Just because you're adding a third dimension to your game doesn't mean you suddenly become inapt to develop it. There sure are concepts to grasp and things to know but nothing that should worry you. At first vectors, matrices and quaternions might scary you a bit, but once you've seen how they work in practice you'll soon understand they're not that complicated after all. Game development math is easy compared to what true mathematicians manipulate. Pardon the lousy analogy, but you could figure mathematics as an engine: just because you're not an engineer or a mechanic doesn't mean you can't drive a car. My advice is to do as you did with 2D games: grab a good Three.js tutorial, maybe grab a good book (e.g. Essential Mathematics for Games and Interactive Applications: A Programmer's Guide), and start working. 

So in your case, if you really just want to disable a binding, you could do the following in UDKInput.ini: 

In a client-server model, all procedural generation should be performed on the server. When your server generates an object, it gives it an UID, which is then used in all client-server communications. If you're doing procedural generation on the client, then this isn't only a client. 

It's very likely that you'll want to share images between different tiles, so make sure you don't mess up and that every pointer in points to something real. A debugger might help spotting issues. Last thing, if you're using some kind of asynchronous loading, you'll have to wait for your images to load before you start rendering them. 

That's an interesting question. I don't think game developers intentionally leave space for evolution when working on a new console. To me this is only incidental. But I stand to be corrected, maybe some big studios do this strategically after all, I'd be curious to see any evidence of that (testimony, anybody?). 

Even if there might be ways to select specific cores for parallel tasks, it's considered bad practice. Number of cores vary from machine to machine, and it's better to let the OS decide where to put the load. You should just create a few Windows threads and let the scheduler manage. 

So, seems to be the position of the sprite you're animating. If the player was moving the sprite with say, arrow keys, you'd need to compute the sprite's direction upon moving it, and get the angle out of it using . But here your lucky. You already have the sprite angle available in your controls update. Let's say you store it in a _spriteAngle variable: