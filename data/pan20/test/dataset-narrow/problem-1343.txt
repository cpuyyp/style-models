First, rivers and roads are very different. Roads tend to follow isolines (same/similar elevation) - the reason being it is much easier to travel on roads that don't rise or fall much. Rivers, on the other hand, travel perpendicular to isolines/isoclines (downhill). Rivers form in basins (collections of mountains that all flow downwards to a given valley) and tend to form tree-like structures. Additionally, roads often travel perpendicular to rivers, in order to form logical bridges. Best idea is to first generate rivers, and then create logical roads (i.e. roads between cities). I don't have time to go into more detail unfortunately but hopefully this will get you on the right track. It might seem obvious, but look at Google maps at various types of terrain and roads; you will get a better sense of how they should look. 

[Edit] There appears to be some confusion about what I mean by "marketing." When I say a good game will market itself, I mean a good game is likely to get featured in blogs and in app stores. That is to say, the user has to spend $0 on advertising. [End Edit] The simplest way: Make a good game. A good game (or any good product) will market itself. "Good" is a very nebulous word. But from my view a "good" game has two requirements: 1) It is unique (you can clone another game, but you should bring significant improvements or new features to it). 2) It is fun. Fun is in the eye of the beholder, but generally, if your game is fun, at least a certain niche of people will enjoy it. A fun game is also functional, without frustrating bugs or design flaws. A boring clone will fail. A fun clone probably won't stand out in the market, unless it is really well made and marketed (or free). A boring, unique game might stand out, but probably not for the right reasons. A unique, fun game will entice its users to spread the word, and news/review sites will be eager to talk about your anomaly. Obviously, there is grey area on the line between good and bad, but your first few games will either be unfinished or not that great, because becoming a good artist, programmer, and game designer is not an overnight endeavor. There are very few cases where successful titles were the first thing to come out of a developer's efforts. Rovio was around for 7 or 8 years before Angry Birds was made. Notch was 30 before he made Minecraft, and had worked on many other games prior. The list goes on... 

When used properly, there shouldn't be any overhead in performance. But, they aren't exactly zero-overhead compared to raw arrays. Size overhead A typical std::vector container will use 3 pointers. Since you probably already track width and height yourself, your raw array could be done in one pointer since you already know the size. Allocation overhead You will incur some overhead when allocating the memory for the std::vector. However, this is the same overhead you incur if you allocate your own memory. Zero-initialization overhead std::vector will actually zero-init your memory when using resize(), which may or may not be significant to what you're doing. But, from a performance standpoint, accessing a std::vector is the same as accessing an array. 

Attending college not only builds your skills as a programmer, it gives you an opportunity to build your social, communication and teamwork skills. Just the social aspect of being with other people is a necessary experience for working in teams inside a company. Beware of online school scams, however (same goes for some colleges, but there are alot of online ones which are just scams). They'll take your money, give you a pass and hand you a diploma, but that diploma won't be recognized by any company once you graduate. Be careful! 

With regards to dynamic branching, one additional note (may be obvious, but still worth noting to some people): it can severely affect the performance of unrolled loops (you obviously cannot unroll a loop if there is a non-constant number of iterations). 

The "gluLookAt" function (as mentioned by Cong Xu, is definitely useful, but I find this to be even better: $URL$ It is really the same thing as a lookAt matrix, but gives you a deeper understanding of its functionality. Using tangent space vectors, you can easily rotate an object into a given position. It is actually really important to understand how this works (I think) if you want a firm understanding of 3D vector math, but you can just as well use it without digging too deep. 

I would generate a cloud of points inside areas where the terrain is solid - you can experiment with different densities. Then I would use an algorithm like a minimum spanning tree to connect all of the points - this will ensure that every area is reachable. Then simply draw big hollow (composed of air) areas from node to node (i.e. a thick line of voxels). 

The harsh truth is that ideas are worthless. I am not trying to be condescending, as I myself was once protective of my ideas. If they were worth something, there would be a market for them. Have you ever heard of someone purchasing an idea before?* No matter how great you think your idea is, the human race is very large and very creative, and your idea has probably already been thought up 10 times, and if it is any good there are probably implementations of it in the works that you don't even know about yet. The best thing you can do is spread your idea as far as possible - this will test for traction, give you valuable feedback, and potentially gain you some support. Its very unlikely that anyone will try to steal your idea, because every person is more interested in their own "great" ideas. *(Note, intellectual property is an entirely different thing. IP is worth something because it has a mindshare, and previous implementations that have built up this mindshare). 

You are using a derivative of the song, which falls under copyright. Also it doesn't matter whether you credit the original artist or not make a profit. It is still copyrighted. 

Downvote me if I am wrong, but I don't see why people are recommending swapping y and z. That would make your coordinate system from being right handed to left handed. Try this yourself, swap the y and z, and reorient the axis so that x points right and y points up. You will see that z points the opposite direction from its original (away from the screen). The proper way is to rotate around the x-axis, which is swap y and z, and then invert the sign of the final z. I think the easier solution is to build your models with y value being up. 

Mentioned many times on the topic of 3d model loading, AssImp is a very easy to use library that reads both .blend and COLLADA files as well as many other formats. You can use it to load models directly into your engine or use it as a conversion tool to convert to your own internal format. I think it would be a good library that suits your needs. 

I don't know if this is the correct answer (as I know relatively little about blender's behavior), but are the bones long enough? It kind of seems like the deformation is not being applied properly because of the way the bones are weighted. I am used to seeing other skeleton systems where the end of one bone touches the beginning of the next - here they appear to not connect. 

I've done a fair bit of work in this area, although most of my demos are older: (flash 2010) $URL$ (click and drag mouse) $URL$ (directX 2006) $URL$ I highly encourage you to roll your own, if you are doing this for fun. You will almost certainly need to work with Quaternions. Understanding them is very hard, but you don't need to go too deep to use them. Think of a quaternion as a vector with an extra component: rotation. If you want your plants to twist and turn as they grow, they will need quaternions. Other things to learn: Lichtenberg Figures Laplacian Growth Voronoi Diagrams Nearest Neighbor algorithms (google them) I (personally) would discourage the use of L-Systems, other than to perhaps dictate a grammar for what grows where, i.e. [seed -> [root] / [trunk->branch->[flower/leaf]]. L systems are not good for responding to environmental stimuli like sunlight direction, gravity, obstacles, etc. As for speed concerns, a single tree can be generated in realtime. For memory purposes and performance though, you will likely only want to generate a small set of trees and instance them a bit if you are dealing with forests. Most existing tree generators are not that great (IMHO), besides the high-end ones used for Maya and such. I also highly, highly recommend using voxels to generate the tree (then skin with a mesh if needed). The advantage of voxels is that you can easily simulate growth algorithms using things like Laplacian growth and various automata (not Conway's game of life, but other rules produce interesting results). 

This is more of a question of, does the use of the accelerometer improves/or integrates well with the controls of your game or does it makes it worse. Having good controls contribute to the overall design of a game, so ask yourself whether you want to design a good game or a bad one, then implement the best controls (whether it be a touch interface, onscreen pad or accelerometer) for having the best experience for your game. 

Use your common memory management sense. Use pools/freelists for things that are frequently allocated and deallocated (i.e. particles), free memory blocks that aren't in use. However, don't try to preallocate large chunks of memory upfront. iOS doesn't guarantee memory nor does it swap, so any memory you have allocated is taking resources away from the system and other apps. If the system cannot get enough memory because your application is hogging all of it, then it will resort to killing your app. You should handle the applicationDidReceiveMemoryWarning for what it was designed for by deallocating as much memory as possible. Although iPhone 4 has lots of memory, but with all the multitasking features and the way people tend to use them, you may actually have less memory than you think. (Also, don't forget to profile your app to see whether memory allocation is a bottleneck!) 

This program draw a triangle with a smoothing of colors defined for each vertex. For a better tutorial, look this wonderful document. 

Do you want to synchronize on vsync ? There are differents solutions depending on your platform. Search vsync on google. On directx, you can limit on fullscreen app with D3DPRESENT_INTERVAL_ONE or use WaitForVerticalBlank on windowed app. Look this article 

Please remove the MipMapping flag for your texture... You need glGenerateMipmap because you use MipMapping and OpenGL need a smaller texture. On bad cards(INTEL), GenerateMipmap is a costly operation. This operation must be called one times. Add this instruction when you load your texture after glBindTexture : 

With good texture atlases, i use 10 drawcalls (glDrawElement) for my 500 sprites and have a good framerate. Ps: for OpenGL ES 2.x, i use the gpu to do translation in the Vertex shader. 

You should search Toon Shading too. For english readers, a short tutorial. For french readers, there is a great tutorial. 

Android APIs are Java. Since 2010, Google provides the NDK (a SDK) for C/C++ developers. The NDK offers two ways: 

I'm working on a game which can't run at Full speed on some devices. On Tegra2, with many optimizations, performance is near 40 fps. The framerate is stable but animations aren't smooth enough, so i need a vsync. With 2.3 Android SDK, we can use EGL library natively. So i try to use eglSwapInterval but no success. In this GDC Paper, it seems that Tegra2 can do it. Ps: Thread.sleep() to force a constant FPS is not an acceptable solution 

If you plan to sell the game with their font in it (whether you transfer it to a bitmap or not doesn't matter), then you are distributing it outside of the scope of the license so you will need to contact CheapProFonts (whom I presume are the owners of the font) for a commercial license. 

In my opinion, since your only job is art and design and you are by yourself, you have a very weak stance getting to become the owner of the project since you have the least contribution of work out of the whole team. You are highly dependant on them to make your project work, whereas they do not need you to get their passing mark on the finals. If you want full ownership, either work alone on your project, pay people to put it together, or somehow manage to convince the people you are working with to assign full ownership to you despite working for you for free. 

Just show them the design document. Game ideas/design are rarely the main factor in ones success. It's how you implement the idea and the team that puts it together is what will make the difference. You need not to worry about people copying your game idea, that is, if your game ideas were truly revolutionary, you will have many copycats but will always be one step ahead of them. Only you know how to implement your ideas in your unique way and no one can copy that. If your ideas was easily copied, it is not because someone stole your idea, it is because you did not have the ability to carry out that idea in a successful way. You will need this level of confidence to gain investors trust.