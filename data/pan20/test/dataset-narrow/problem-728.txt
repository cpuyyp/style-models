I would wager that each of these will be significantly more time than the per-cycle cost of your code. Optimizing your code will make no difference to the accuracy of your timing, and, as it is, your reported precision is probably far more than the actual accuracy. In fact, I would suggest that anything within 1/10th of a second (instead of 1/1000th) is a 'tie'. 

and we will test the OP and Regex code a different "depths" of nesting, 5, 10, and 20 layers deep. The benchmark code is: 

Variable conventions as a variable name is a great idea, if the variable is the control integer in a loop. In your case, I presume it is short for 'item', or something, but, a Queue, being called is unconventional. As it happens, the letter is perfect as a substitute.... Now, your variable is actually the odd. Function extraction With synchronization, return-balues from methods are often a great help for readibility. Consider this code you have: 

if the cell in the current column is not set, then the square at the current position is size 0. if the cell is set, then it is 1 more than the smallest square above , above-left, or left of it. This needs a picture..... 

And you can then populate that dictionary with lists of words that have the same sorted-char anagram key. Once you have that, you can return all words that are anagrams of each other. 

Note how this is really just a re-expression of your second query using Common Table Expressions I put that query together on the Stack Exchange data explorer as an example using a couple of different column names.... you can see it working there. 

Lock Free is consistently performing faster than the alternatives when more than one thread is accessing either end. 25% faster would be about the right ballpark. Here's the lock-free code. Note, instead of using an array, it uses a linked list (calling it an is a bad name - I agree): 

@maaartinus has excellent advice about the naming and structure of your code. I even appreciate his suggestion about doing an odd/even sort. It's slower for larger scales, but the code simplicity sure wins out. Talking about scales.... part of your question is: What is the minimum space and time complexity we can achieve for this problem? Well, the sort from maaartinus would be time-complexity of \$O(n \log n)\$ from the sort. That is not horrible, really, but it is not as good as the \$O(n)\$ of your implementation. It would not be possible to beat your \$O(n)\$ time complexity. As for space complexity yours, and maaartinus's jestful sort would both be \$O(1)\$, essentially nothing added. What's the minimum possible? Time is \$O(n)\$, and space is \$O(1)\$. Bottom line, your code is about as good as you can hope for, in terms of scalability and complexity. I realize that maaartinus is not really serious about converting to a sort, but, in reality... perhaps he should be. The real issue with that is the need to box the values to Integers, etc. What I really want to comment on, though, is your algorithm. Problems like this have 'landmarks'. Things you look for when processing the data. The landmarks are an indication of how you think... what you think the highlights are. In your code, your loop changes 1 thing each iteration... either the left pointer, the right pointer, or it swaps a pair. In a sense, your code is: 

the above code no longer uses "using namespace std;" The sum method no loger uses static variables. Those are a bad idea especially when it comes to re-entrant code. Output a newline after the last line. 

This is not so much a question about mysqli and php, but about databases and database theory. Consider two simultaneous accesses to your page... they will both get the same result for: 

find a 0-bit pair that has some number (perhaps 0) 1 bits before them allow that pattern to repeat as many times as needed (perhaps 0) then allow there to be other 1 bits after them to the end of string. 

The first "obvious" thing here is that your Agent and State classes don't specify the generic type of the 'nested' State/Agent. For example, there should be something "here" (where "here" is represented by ): 

A class called should have a primary method called or something. It took me a moment to discover that is the primary method. That's doubly confusing because it is a hungarian-style name, (setting an Object), but it is not an you pass in, instead it's a . I like how you have made the method final, though. I would instead have something like: 

EventHandler I thin kit is naive to have the method have no error handling (it swallows all exceptions). I think you should at least document that there is an unchecked exception thrown from the method.... (these are significant problems) like: 

Note that you can remove the channel completely. Edit: Note that by dedicating a response channel for each command, you can do things like return the actual channel from the function, like: 

Note that I used the more convenient 2-argument constructor instead of the constant Further, I would suggest getting a better-performing new NIO2 functions, and wrap the resulting with a buffer: 

it should be declared at the top, before the add and other non-static methods (and constructors). I have mentioned before that I prefer inner static classes to have getters and setters for the private members (even though it is a private nested class). You have chosen to ignore that, that's OK, but I should still point it out. I have also suggested before that there is no need to have the left and right as part of the constructor. You never use them (when constructing), so it is redundant and confusing. 

You go to great lengths to store the data in two arrays (with bad names and ), and you use the one to check for words in the other. The right structure in Java is a Set, which automatically, and efficiently does the check for you. Further, there's another specialized set, called the which stores the data in sorted order already. Regular Expressions are a good way to identify patterns in the data. They take some getting used to, but, because of the way they can be pre-compiled, and reused, they are fast. Note that the class looks for regular expressions. When using input, and output, you get better performance if you use fewer operations. You should wrap the in a BufferedInputStream, and perform all the output to a , and then dump that to in one operation. Now, about bending the rules on the input side..... Many programming challenges are set up to work in many languages, including things like C, C++, etc. Some of those languages need to have an idea of how much space to allocate before processing the data. That's why the description says it will contain the number of lines, as well as the maximum line length. If you assume that the input will be valid, then there is no reason to process the data line by line, you can do it word by word, and just forget about the line count in the first line.... How would I do it? 

Notice how I have also removed the redundant braces you had around the conditions. The operator has a higher precedence than so it does not need to be elevated. 

That should be removed "just because". It's hard to understand, the logic is inverted, and it is not short-circuit, so it tests the even when I think what you have is an inverted logic problem. You are looking for all the digits in the input, when, instead, you should be looking for not-digits.... The supporting logic, using StringBuilders, etc. is not a bad idea.... but, have you considered a regular-expression? 

what's for? That's just an infinite loop.... and your code makes the loops hard to see (yes, I use loops as a plural there, there are actually 2 loops you have merged in to one....) you have a bug with , you have , but that should be . Instead, you are doubling point each time. 

it is a pain, but you benefit from getting all the information in the stack trace. Currently you are losing some. The only other issue I see is the extension of the AsyncTask. You have re-implemented the methods: 

I use a dedicated object to lock on to. This prevents someone from using my instance as a lock for their synchronization needs, and breaking my class. E.g., with your code, if someone did: 

If you want the best performance, then change your database schema. A second option is to trim the values on the database side before returning them to the client.... adding to your SQL will remove the need for any handling on the client side. What you are doing is the worst of the options.... handling the trim in the client, after all the hard work is being done by the network, database, and now the browser. Doing it right the first time would remove the need for anything to 'suffer'. As for the JavaScript handling, it has issues too, it is processing values which have no need for processing, and it is introducing bugs too. You should probably inspect the metadata of the query, and identify fields that need processing, instead of checking each and every value. In other words, if the query was your code is checking every name, and every ID, and there could be many of them. Instead, you should check the name column, and identify it as String results, then check the ID column, and identify it as numberic. Then, you should only process values in the name fields, and not even check values in the ID. Finally, what if white-space is important. What if the value in the table is... padded numbers, for example, or... a formatted field, like 

That function has a useful name, I have made it static because it does not rely on any instance data/fields, and it is a simple stateless function. Now, we can reuse that in the main method. All we need to do is separate the first and last names..... and a simple enough way to do that is your call. 

(Note the return type is the interface, not the struct). Now, here comes the trick, you need to link your interface to a pointer of the struct, not the actual struct instance. Your full method will be: 

So, if I break your code in to three sections. One section closes an open file, the next section starts a new file, and then a simple loop that checks to see whether it should start a new file, the code is much simpler. Note also the general lack of global variables. Also, the 'id' line is not printed to the file when the file is created, but rather after the file is created as part of the 'normal' loop. Finally, the process below copies the input lines unchanged from the input to the output. Your code 'reformats' the lines to 56 chars wide. This code does not do the reformat. I consider this to be a feature because of two things: