Pong, Asteroids, Space invaders, pac-man, super mario bros clone, zelda 1 clone. That's the order I'd recommend. Pong and asteroids would teach you the basics of game programming, space invaders would expand on that. Pac-man would teach you a bit about AI and programming a more abstract game. Then there's mario and zelda like games that really teach you about tiles and building larger levels with scrolling, events, map data etc. 

I personally NEVER use SendMessage. There's still a dependency between your components with SendMessage, it's just very poorly shown and easy to break. Using interfaces and/or delegates really removes the need to use SendMessage ever( which is slower, although that shouldn't be a concern until it needs to be ). $URL$ Use this guy's stuff. It provides a heap of editor stuff like exposed interfaces, AND delegates. There are heaps of stuff out there like this, or you can even make your own. Whatever you do, DO NOT compromise your design because of Unity's lacking script support. These things should be in Unity by default. If this isn't an option, drag and drop monobehaviour classes instead and dynamically cast them to the required interface. It's more work, and less elegant, but it gets the job done. 

You should create the matrices on the cpu and pass them to the gpu so there's as little redundancy as possible( you don't want to create new transforms per vertex if all of your vertices for a mesh have the same transform. ) As for multiplying matrices on the gpu, you simply use the * operator with any two valid operands. To answer your question; there is no function in glsl to create any matrices for you. You either need to create them yourself or upload them from the cpu. The common practice for this is to create you model, view and projection matrices on the cpu and upload them separately so that we have all the information needed for each coordinate space. 

This will rotate the origin( camera position ) vector about the origin( 0, 0, 0 ). This isn't what you want either. If you want to rotate about the target, you write: 

If the tiles are stored in a linear way( sorted so that the top left tile is first and the bottom right is last, or some other reasonable order ), you can access the array / list by an index that describes tiles that only lay within the screen bounds. This will be a bit faster than doing a bounds check every tile. 

GameObject.Instantiate returns an Object reference that you can then cast. Use GameObject.GetComponent() to get a component of type T from that gameobject. Since scripts are components, you can get them through this method. So: 

This design goes completely against Unity's design, unfortunately. If you try to use a large class hierarchy within Unity's system, things are going to be very difficult. Unity chooses to use composition over inheritance, or has-a over is-a. To build unique objects in Unity, you should prefer to compose components, rather than inherit functionality. This makes functionalities reusable, independent and focused. Look at what you have in your monolithic classes and see how they might be split up. For example an actor may be broken up into these components: 

What I've found more useful in Unity is to really take advantage of editor, and realise the fact that you're working towards a solution that is drag and drop able rather than flexible in code. An enemy movement in Unity could be represented by a single method, but I believe it would be much better, and much more to the style of Unity to have separate components for these different movements. Where you would pass a delegate into a method, you would drag and drop a "Movement" component. I would start by defining a interface, so we can interface with these components in a common way: 

Coroutines are very useful for actions like these. When programming a game you've probably found yourself wishing each object was independent with the ability to do things over time without blocking other objects from executing. To achieve this normally, we'd need a new thread for each object that exists in the game world ( which is is impractical for several reasons. ) Coroutines allow us to program objects as if they run on a separate thread ( but they don't. ) Using "yeild return" we can tell Unity to continue the execution of this method later. My implementation: 

This is just simple arithmetic. This vector is scaled up to 5 units. It is now 5 times higher than it was before, however the x and z components remain unchanged, because they are 0. So, each of the vertices that make up your cubes have a vector to describe where they are. They are all relative to some origin( ( 0, 0, 0 ) in this case ). So, if we have a cube made up of the following vectors: 

So, Unity 5 has changed asset bundles quite a bit from what I can see(never used them in 4). In Unity 4, you had to push and pop asset bundle dependencies and gather a list of assets that will go into your bundle. Unity 5 provides some editor support for asset bundles. Basically every asset that has an AssetImporter can be assigned an asset bundle using the editor. There's a small UI that helps you create new asset bundle names and assign them and their variants to an asset. First you select the asset in the editor, then at the very bottom of the inspector you should see where you can assign asset bundles. The UI is pretty self explanatory and pretty much the only thing about asset bundles in 5 that's decently documented, so I'll talk about the more complicated stuff. So, once you assign all the assets you want an asset bundle, how do you build them? Well we have to do this in an editor script still: 

Is it possible to make network independent components that allow networking details to be specified externally? For example, if I have a "Follow" script that follows a game object, it would need to do certain actions on the server and certain actions on the client. However, these things can change based on the network architecture. Single player games would not even need to consider what runs where. That makes perfect sense, except why should a component as general as "Follow" need to be different across different types of game? I've tried creating a base component class that figures out how to call each method based on options set in the editor, but that failed due to RPC names needing to be different across all components attached to one game object. Not to mention it was messy. I've tried abstracting method calls to figure out how they should be called, but that doesn't solve the problem of WHICH methods should be network invoked. I really don't want to build this into the components themselves, even though it might be the easiest / most obvious solution. That would destroy their portability across projects.