Order your s alphabetically. This will facilitate checking whether all required s are there. Also, consider leaving a space between and as this tends to be a coding style issue most programmers agree on. Also, you don't seem to use anything from , so you should remove it. No, I disagree. You're putting your code up for review here, so you should be posting your real code and not some changed variant that will never actually see a compiler. Using or not can mean the differences between subtle bugs that may not manifest until some edge case occurs, and you'd probably want to be told about those in a code review. Also, in all honesty, writing every few lines doesn't change the length of your code much at all. It is discouraged nowadays to use for simple numeric constants. You could either use here (or, if you don't have anything >=C++11, ) or define constants. Again, if you have C++11 or beyond available, you should prefer to , because it is much more readable and versatile. Being explicit is good, but being too explicit is bad, too. can be written as , which is most commonly used today. Ultimately, though, this is a personal style issue, so don't take this point as a required change. is not the right type for everything. For example, might overflow because might be bigger than and, in any case, unsigned. The standard offers for sizes, so you should make use of it where appropriate. Don't use because it's horrible. Although it does insert an endline character into the output stream, it also flushes the underlying buffer which is very rarely required (and for that cases there is ) and can seriously harm performance if you're doing a lot of IO. Just write instead, the underlying system takes care of converting it to the correct end-of-line sequence for the current OS. Use member initialization lists where possible. Lines such as should just be part of the member initialization list of your constructor. Your code violates the Single Responsibility Principle. To be exact, is doing not only its main purpose but also IO, which violates its responsibility. Extract the IO to a helper class/function so that other people can use without getting extremely annoyed at standard output they don't want. The same is true for benchmarking: You shouldn't have a method that measures time, but write a separate benchmark class/function, possibly utilizing a benchmark library that allows you to get more reliable results. should take its first argument by . Currently, you're making a copy of every single time, but don't do anything with it that would change its contents. Taking the parameter by reference to const will remove that copy and thus speed up the code (probably). is a lot of code that does remarkably little. is very handy in some cases, but this is definitely not one of them. Just write , or just use ( is not exactly what you would call expensive to copy). Don't make assumptions about the container type everybody uses. Instead of taking a or a or any other container as a function parameter, take a begin and an end iterator instead. Iterators enable the caller to use whatever container he wants while not putting a huge burden on the library implementer to ensure correctness for every available container type. The keyword here is test. You should restructure your project and write actual tests and benchmarks for correctness and performance. The function is not the right place to do any of those. Since we are talking about restructuring your project: Nearly all of your code should be extracted into a header and an implementation file. is terrible to read and verify. You should have a separate object definition, maybe even a dedicated generator function (in the test class this actually belongs to, of course). 

I wrote a random world generator for the classic Snakes and Ladders board game. Snakes and Ladders is a dice game played over a grid, usually 10x10. You win by reaching the last square first. The board has ladders and snakes that connect specific squares. Land at the base of a ladder and you climb to the ladder's head (good). Land on the head of a snake and you slide down to the snake's tail (bad). Snakes and ladders are key value pairs; the represents the start point, and the represents the end point. Both are identical except that a snake's start point must be greater than its end point, while the opposite is true for a ladder. World rules: 

The following converts Arabic numbers to Roman numerals. I decided to factor each digit into its place value, then use a mapping to convert it to its Roman equivalent. For example, 1997 is factored to: \$(1 \times 10^3) + (9 \times 10^2) + (9 \times 10^1) + (7 \times 10^0) = 1000 + 900 + 90 + 7\$ The Roman numerals for those numbers are then retrieved from the mapping. 

If I find an opening bracket, I add it to an array. If I find a closing bracket, I remove the last element from the array and check if the brackets are a pair. If I find neither an opening or a closing bracket, the string must be invalid. 

A square can technically contain the tail of a snake and the base of a ladder, or head of the snake and head of a ladder. But this could have weird side effects (presumably why I've not seen a board with those characteristics): You slide down a snake only to reach the base of a ladder that takes you to the winning square; or you climb up a ladder only to reach the head of a snake that drags you down. While not fatal, such side effects muddle the role definition of ladders and snakes; in that, ladders are no longer necessarily good, and neither are snakes necessarily bad. Example World 

I improved with my second iteration, but it still relies on iteration. I narrowed the range down reasoning that the largest palindrome is likely to be the product of two numbers within 901 and 999. This time I multiplied all the numbers, but only saved the palindromes in the array, then selected max, which saved a step. It's noticeably faster, but still not optimal. 

The idea is to isolate presentation logic that is only needed for the report, in the report class itself. You then have cleanly defined responsibilities for each class. 

Your view will be simplified too. Instead of calling you can treat the decorator as the binder object. 

The first check is for the length of the string: If it's odd, the can't be balanced. I then iterate over the chars of the string: 

I honestly think your first version is the best one. It's readable, and makes more sense at a glance than the refactorings. That said, I would consider a couple of things. 

The best way to ensure a bullet proof implementation is to avoid having a square contain more than one object. For example, there's an edge case where a square can contain a ladder's head and a tail, causing you to progress even further. To do that, the placement should be delegated to a method that checks if the square is occupied. This requires tweaking the initialize method, but it's worth it: 

Yes, no, maybe. Some people do it one way, some the other. Personally, I prefer splitting declarations and definitions up so that I have an overview of what my class offers at the top. Some people argue, however, that this method tends to be very verbose (and it can be, especially with multi-layer templates), so either way is fine. Yes, there is at least one memory leak in . This is evident by the fact that you're allocating memory there, but not freeing the old memory. After the method returns, the internal pointer points to the newly allocated array while the old one is left abandoned and unreachable in the depths of the heap. To correct this, just the old array before you assign . Probably, but I don't want to go into those here as 

Apart from the fact that you should prefer writing algorithms to work with iterators (to enable you to sort things that aren't arrays, such as s), there are a few things here that are problematic: 

I'm not convinced that it is still appropriate to define as a macro in our modern times. You likely know about all the drawbacks macros have (no type safety, proneness to bad behavior because of missing parentheses etc.), and you don't have any significant drawbacks if you defined it as a function (except for the issue of type rigidity, which does not apply in your case, however, since you only use once and could define it for the appropriate type). In my opinion, and are rather obfuscating the underlying code. Since both of these functions consist of a simple check, and their names do not actually convey what is checked, you are actually losing clarity here. Encountering calls to these functions in the code inevitably makes you go back and read their definitions, because the name just suggests that a check is carried out, not what check. My suggestion would be an -like method to which you pass a condition and which calls if that condition is not met. That way, you abstract a part of the functionality away (the fail-on-error), but retain the self-explaining property of those checks. You can omit the parentheses around the argument of if it is not a type argument. For example, can be written as . The advantage of removing the parentheses here is to make it clear when the argument is a variable and when it is a type name. I don't know how much you care about such things, but ideally, you should check the return value of functions that could fail. This includes , and if your program fails, it is a matter of grace and correctness whether you let it just crash or fail gracefully (correctness in a sense that failing gracefully implies that you accounted for a certain edge condition, such as out-of-memory). Consider factoring "run once"-code out of loops. For example, 

This, on one hand, serves the purposes of checking whether each header file actually contains all required includes (say, for example, your header actually used something from ; with your current include order, your compiler would not complain because you include in before , thus hiding the missing include), on the other hand helps readers of you source code to verify includes quickly. Quite frankly, I don't see the reason you do this here. Why not just use ? Anyhow, if you really want to have this (and also have a good reason to), I would expect a similar for here because of consistency. Alternatively, one could argue that you should be taking an and a as template parameters, especially since the s and thus the seed types of random number generators in the standard library are different for different generators (for example, uses whereas uses ). Instead of , you should write to prevent subtle bugs when changing the type of The name is not very clear. Although the abbreviation "rng" is quite common, what "bp" means will not be clear to most people on first sight. Since your header is named , I would expect your class to have the same name. currently takes a as argument by value, but you only ever output it to , so you should take it by const reference instead. Don't write where would suffice. For example, when writing to , the former implies a call to and an additional indirection while the latter just passes the value directly. is not really a fitting name for the second parameter you pass to . I was confused the first time I glossed over that function because, for me at least, almost exclusively stands for . I would have grasped that parameter's meaning much more quickly if you had actually named it or anything along that line.