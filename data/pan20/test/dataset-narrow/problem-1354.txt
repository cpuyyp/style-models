Your code only makes a single test with before advancing. This skips over certain nodes that are in a straight line. For example, if you have 5 points (A->B->C->D->E) all in a straight. The smoothed path should only contain two points (A->E). In your logic you test if you can travel between A->C and if you can then B is eliminated. You then check to see if you can get from C->E, and if you can then D is eliminated. Here you reach the end of the path and you are left with an extra waypoint (A->C->E). Because you are moving your further down the path at ever iteration you are not eliminating all possible waypoints. You should check to see if you can walk between and , if so, mark for deletion and advance to . If you cannot walk between then advance and . 

Probably the easiest way is to alter the A* heuristic. Once a tile has been used in a path, increase the heuristic for this tile so that the next pathfinding call will try to avoid that tile. This will also make the zombies gather around the player. 

So coming up with strategies for "retention and monetization" mean you maximize the numbers at each point in the above flow. Firstly, to do this, you want to come up with a way of measuring your performance at each step, which is usually done by measuring user behavior with gameplay events, which look something like the format below, and then analyzing it later to establish behavioral patterns 

In my experience relying on users to send you error reports to you even if it's only a push of the button isn't always reliable. Most users won't send these reports, they'll just stop playing and remove the game or app. In most games I've worked on the fraction of users who send bug reports even with a 1-click option is less than 5%, so the subset of users sending you error reports might not be big enough to solve bugs decisively. It sounds like what would optimally help you here is some kind of tool that would help you take data from all game sessions automatically, aggregate it, and then allow you to look through the aggregated logs for deviations in optimal behavior without relying on the user at all. Assuming most of your players have an internet connection, what I'd recommend is sending logs to a 3rd party log aggregation tool like Loggly . This way you can send logs from all clients and will have the full set of data from almost all of your users (minus those few who lack internet connection). As far as what to log, there's a few different ways to go about it 

This example probably still needs some tweaking to make it just like you want, but it should get you started. 

To make the tile set look good, a basic rule needs to be followed. That is each tile must tile seamlessly with all the tiles it can connect to. Some examples: tiles E, and J must tile with themselves in all directions. Also, the top of tile E must be seamless to the bottom of tiles B, M, and N, while the top of J must be seamless to the bottom of G, H, and I. Tile A's top edge should be seamless to the bottom of J, G H, and I. Tile A's Right edge should be seamless to the left edge of B and C. Tile A's bottom edge should be seamless to the top of D, and G. And finally, tile A's left edge should be seamless to C, F, I, and J. Tile B's left edge should tile with the right edge of A, B, and M. Tile B's right edge should be seamless to the left edge of B, C, and N. Etc, etc, etc. As you can see this is a long tedious list to write out, but at this point I think you can figure the rest out. Creating multiple sets like this you can make some intricate maps. You can have a dirt/grass, and a grass/water tile sets. If you use the same grass tile in both set, you can go from dirt to grass to water seamlessly. This same approach can be used to construct building exteriors, fences, caverns, and mazes. 

Sounds like you're interested in things like Crash Data, stack traces, tracking 3rd party vendors etc. Another option to do this is to perhaps use Loggly. It's different from Crittercism it's geared more towards consume & visualizing game logs than automatically categorizing performance data but they have a REST API which will allow you to use it in Unity and you can log the exact same information (transaction logs, device used, monitor service provider HTTP response times, crash/exception logs). 

The event usually includes an event name, a userID, a session ID, timestamp, and parameters that allow you to record whatever data you find useful to record surrounding that event. And in my experience, relational database formats are the best for recording such a structure. 

And so once this firm grounding in understanding users is established, we can take a look at the strategies developers use to maximize player retention, engagement, and monetization. ---- Monetization ---- What will work for any given game is different, but some free-to-paid conversion techniques that have seen success recently are: Advancement pain points: Points in the game where users are interested in advancing but it is difficult to advance without buying premium items. Games that require "grinding" to advance use this a lot as do games that are level-based (multiple levels the user plays which get progressively harder) Provide a competitive impulse: Many games that feature a competitive or P2P mechanic allow people to spend to get ahead of other players. (Personally, when I spend on mobile games, it's usually to better PWN other players.) Play limitation: Users have limited plays or lives and have to wait a certain amount of time before playing again without paying for more tries. Games such as Family Feud 2 and Bejeweled Blitz employ this strategy as a primary monetization tactic. Time-to-completion: Tasks that take certain amounts of time that can be sped up with premium currency. Many games that have a building mechanic often employ this tactic. High-priced offers/Social distinction: Design expensive offers for players that allow major advantages or major distinction. This will give highly engaged players an incentive to convert to whale-level spending. Many game types offer this, but MMOs or social games with lots of direct player interaction can rely on this more. You want to ensure you really know your player segments so that you can target individual play styles with content that theyâ€™ll be most likely to buy. ----Retention---- Some retention strategies used frequently by successful developers include: Heavy immersion in enjoyable experiences: The game gets people into the most enjoyable core gameplay mechanics fast Smart Tutorials: Tutorials recognize how much help a user needs and offers more if they do need more help, and less if they don't. Predictive individualization: Ability via predictive behavioral modeling to determine what a user likes within the first 5 minutes of play and to customize the experience to maximize their involvement in gameplay mechanics and content they love. This strategy is hard to pull off because it requires statistical modeling. Care Obligations: Creating timed tasks that users must come back to finish Early Customization: The ability for players to customize their in-game avatars or possessions. Establishes an early sense of ownership Early re-engagement notifications: Re-engagement push notifications, emails, and social network notifications Eliminating Error: Error is ESPECIALLY damaging to early retention. In a player's first hours and minutes they are very skeptical of your game and error in this phase absolutely kills retention. So again, you'll really want to make sure you integrate a good QA process and a log management tool like Loggly to monitor error while the game is live. It seems like a no-brainer, but MANY MANY developers miss this point and end up losing the cash and time they invested into the game to easily manageable errors. 

In my experience with android, it is the garbage collection the kills the performance, not the allocation, although these two are tied hand and hand. As mentioned on the comments, pre-allocation is a way to deal with this issue. This is known as a memory pools. Another similar solution is object pool pattern. An object pool allocates as needed, but does not immediately destroy an object. If an object is needed and an old object is still alive, the old object is issued. this saves on the allocation and destroying of a frequently used, short lived objects. In both cases, the objects are checked in and out of the pool, so you are never creating or destroying the objects yourself. This object pool example is a generic pool, which you can use to create a pool for any object type. 

One thing you can do is not let the character travel diagonally when the path crosses the corner of a wall. The character is free to travel diagonally out on the open, but not next to a wall. This is done in your a* algorithm. 

There are a lot of specifics that make networked gameplay much harder to debug, but in very very general terms it comes down to 2 basic points: 

Once developers collect this data, they can begin to analyze it by looking at any immediately visible trends that emerge. Once a large enough dataset has been gathered, developers will usually develop statistical modes to establish patterns in player behavior. These statistical models seek to establish: User Segments: Developers put players into different behavioral cohorts based on their play style. This is done so that individualized content and features can be targeted towards individual user segments. Unique value of each segment: Each player segment has a different value. Some will spend more money, some will be extremely viral & invite a lot of other users, some will serve to engage other users. Once players know the value of each segment, they can add new content and features to the game that maximize the value of each individual user segment. Create custom KPIs relevant to their game's retention, engagement and monetization: Since games are all different, developers will define metrics that define success for their individual game so that they have custom measures of success at each phase of the player lifecycle. Examples might include: