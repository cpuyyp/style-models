With the generic, misses the whole point of having the 'EnumResourceBundleAware', you can pass any enum! it should be this: 

Other than that, the code is quite straightforward, the "stuff, which has to be done" is separated into subroutines. 

The reader is not sure, what the purpose of the contains is. If I had to change something in that code, I'd ask myself: "Why can't I delete the given user, if it is present in that map?". To be honest: I would have assumed, it would be the opposite: Only delete, if a userId is present aka "can't delete unknown users". To be really sure, I actually have to read through the code and check, what happens, if the given userid is present in the map. Or look at the annotations and check, who committed that and hope, he's still working for us or check, if there's a link to the issue tracker, where the requirements are described. So, your descriptive method (or a well written test case) would have saved me a lot of time. Just keep in mind: We devs often find us reading and analyzing and debugging a lot more than writing code. I have had implemented requirements, which took maybe an hour and the "figuring out what to do" took days. We read and try to understand code a lot more, not only because of bugs, but also to check, what the impact of our changes would be or where else we might have to change the code, to either fulfil the requirements or verify, that we do not break something else. If we try to be as clear as possible in the code, we can reduce that amount and can do more of the fun part: the coding. Hope this helps... 

Since the http requests will be the main bottleneck, I'm not sure if the asynchronous http calls will improve the performance. The asynchronous call will be executed in a separate Thread again, which takes ressources, but your main app will have to wait for the backend anyway, right? Again: Measure. 

Maybe some of my answers and thoughts from this thread (Scanning through logs (tail -f fashion) parsing and sending to a remote server) can help you. What I want to point out: It's very important, to measure. If you just post a piece of code and tell, it takes that amount of time and ask, how to increase 'performance', it's usually ghost hunting. If you can reduce the time of a routine by 99% but it only takes 1% of the overall time - you just wasted your time. My main concern about the app is the use case: You're reading millions of lines into memory into a tree structure for further processing/querying - at least that's my interpretation. Have you thought about using an indexing library, such as Apache Lucene? Usually, people invest more time in better response times, instead of "indexing times" - which is, of course, also important, if you have a real-time or near-real-time requirement. But then I would analyze the software architecture first. Other than that, I can't identify any major problem with the code. One problem could be the garbage collector, since millions of lines are using a lot of memory. And more memory means more memory managament. But that has to measured too and also analyzed in detail. Playing around with collectors, heap sizes, collector threads and so on, can improve throughput significantly. Hope this helps, slowy 

That way it can be run directly with (and possibly other harnesses, I know the standard requires wrapping them in a dummy class, but I haven't used any others). 

Other answers have handled specific issues, mine will handle larger design issues. Some of my later advice is highly opinionated, but it is motivated by real design problems; be sure to understand the problem before dismissing it. 

There is no good reason for you to make 4 separate calls. Most likely a single call for would be enough, but even if you have a pressing need for them to be on separate pages, you should still 4 pages in a single call. You don't need to open to get anonymous memory, just pass as the FD and add the flag. 

Instead of , use to avoid precalculating and storing the entire sequence in memory (and also spawning an unnecessary subprocess). Instead of , use to name the argument then use . Note that is an alias for , but it's idiomatic to use for assignments and for expressions. Beware of the possibility of failing! Using an chain as @glennjackman suggested will avoid this pitfall. It would also be possible to replace with but that's ugly IMO. 

If you don't like nasty bugs, always use for allocation sizes, not . Yes, somebody will do it, this is a fatal flaw in the Qt libraries. You're missing move constructors/assignment. Most likely they should be implemented by moving the ownership logic out to a separate class (if you don't take all of my advice, would work) and then using the Rule of Zero. There's no point in providing a method (this is a flaw of ), you can just use on the iterators (that you need to implement). Most implementations use instead of , or even just a single member which points directly to the string data. and stores size/cap information at offset . Newer implementations often use SSO (Short String Optimization) as well. You're missing slicing operations. Slicing operations should return a class though, instead of allocating a . You're missing , which most people want from a string. Though I'm not convinced it's useful; I treat strings as opaque blobs rather than containers. If you choose to have mutable strings (see below), you're missing , , and . In either case, you're missing . You're missing , , etc. These should allow mixing with . 

Most python users would just use . That's \$O(n log n)\$, which is not that much worse than your \$O(n)\$ solution. But the code you've actually written is just a reimplementation of: 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler). 

First of all, it's very well written and I can easily understand what's going on. I also want to point out to another post which is similar to yours with a lot of good code, answers and comments: Object Oriented Design of Card Deck However ... What 'hurts' the most is the very long main method. A lot of things in the main method can be moved to separate types/methods, for instance, the loading of the Deck: Consider writing something like . It's still quite clear what you should happen, but it's written / summarized in one line. As others have mentioned, it's better to move the 'game itself' to its separate type. Why? Assume you want to provide a GUI for your game - what do you have to change? Yeah, a lot, because a lot of the code is not reusable. I think, with that in mind, you will have a total different approach of writing the game, its classes and methods and the control flows. And by how your posted code looks, and how you are already "thinking in objects", I think you can do that without me pointing out every single tiny thing I see - so I won't go into detail about what part of code you should refactor to where and why - which would really take a lot of time. Now, some smaller thingies: 

The 'having an interface for enums for indicating that it is translatable'-thing I have seen before. But with the main goal, to have a test case which crawls the classpath for those enums, to verify, all enums are translated. Another variant I've seen was to have those enums annotated. 

basemoveRate is never used again. Beside that, it should be a constant: private static final BASE_MOVE_RATE = 10.0; 

Now what? What can I do with that? Do I need that? Is this ... important? I would have chosen 'getMessageKeyPrefix' or something like that. Why must this be exposed anyway? 

There's some other fishy stuff, but I'll conclude now, because in my opinion there are some problems even without the reflection stuff: It seems like an over engineered approach for an easy problem. Or: It looks like the solution of a problem, which probably isn't even a problem. It certainly is, from my point of view, the wrong tool for "the problem". The usage of reflection makes maintaining the code harder and more error prone, at least in my experience. The usage of annotations, too, by the way. I'd suggest to take a step back to the solution before you implemented reflection and analyze what object oriented principles are violated (e.g. SOLID, coupling, cohesion,...) and what patterns can help you get rid of those problems. Now, that's the major point: Ask what design patterns help you get rid of your design problems, do not ask would reflection get rid of the design problems?. I recommend fowler's web page about gui architectures: $URL$ (presentation patterns). It's not exactly a "good read", but it certainly is educational. It helps you to understand, which presentation patterns suits your application best and gives you some guidelines about how to implement you presentation layer. 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

In my experience providing or on strings is a mistake. Instead, strings should be constructed via one of: 

You're matching the regexes in a loop, giving it \$O(n m)\$ performance instead of \$O(m)\$ where \$n\$ is the number of regexes and \$m\$ is the length of the text being matched. Any halfway decent regex engine can match an arbitrary number of regexes simultaneously and then tell you which one matched (a trivial extension to the way is matched; I've done this in C); I am not familiar enough with JavaScript to know if it has one. Possibly since these regexes are fairly simple, you could capture a fixed piece of text and then use that in a dict lookup? 

My preference is to then use so that I can stuff it in a or or set along with any other read- or write- file descriptors. 

By the way, \$O(2n)\$ is equivalent \$O(n)\$. However, the bound is actually tighter: \$O(n + m)\$, where is the number of distinct elements. This is, however, an average bound, because it relies on a . If the worst case hash collisions happen, you get \$O(m(n+m))\$ 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

All of the above, except for the last two which are special, provide exactly the same public API (except ) and can be implicitly constructed from each other if it makes sense. 

That said, your short-circuit if the lengths mismatch is a good idea no matter which implementation you use. There are some style issues that jump out with your implementation: 

Likewise, it is exceptionally rare that allowing mutation of a string after construction/assignment is actually useful. This makes the constructor nearly completely useless. 

If you're using , you shouldn't have the shebang in the second script. If you're using the shebang, you shouldn't use . But rather than use directly, I would the script once at startup, and in it define a function that was called at the later times. You should use instead of to avoid forcing a separate subshell to spawn. I would provide a default instead of exiting if no argument is passed. Something like . Also, I always use named variables as early as possible. Note that if you were using a function (with or without ), you should use to avoid leakage.