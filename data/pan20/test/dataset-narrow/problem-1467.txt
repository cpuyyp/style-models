I also want to try ideas based on Bret Victor's ideas of direct manipulation, and immediate feedback: no compilation, no pressing run. Just change the code, and see the change. 

After doing @Buffy's active learning, the next step would be. For you to to create the program, and remove the guts of the functions. Just the skeletons for the students to fill in. 

Summary Not all IDEs are the same. Not all editors are the same. You will have to look closely at your editor, IDE, to see if the IDE provides anything more, and does not make things too much more complex. 

Simplicity You can write the definition of scheme on the back of a postage stamp. Therefore as @Buffy says, you don't have to learn the language at the same time as learning the concepts. It is a pure functional language. You will be a better programmer, because you learnt functional. Better to do it first, few people learn functional second. Education vs training Education is about learning the concepts, training is about leaning a language. Education is long term, training is short term. Training is about learning, Education is about learning how to learn (meta learning). A personal experience I leant scheme late, after basic,pascal,C,C++,C#,python,tcl, et al. I have never done it again, but I have not stopped using it, in the way I program in other languages. 

The way our network is setup I have access to my students network shares. So, if a kid is absent I can get to their stuff and copy it for their partner. Not ideal, and definitely doesn't scale well if there are a bunch of students absent. Plus, I really don't like the privacy implications. But it works in a pinch. I've also had groups share a flash drive, and then leave that flash drive in the classroom. Works okay if there's no plan on working outside of class. Some groups will zip up and email themselves the work they've done at the end of class. Or, upload to DropBox, Google Drive, or something like that. My personal preference would be some type of source control. I've been looking for a reason to introduce git into my 2nd year course. Maybe this would be a good excuse. 

The lawyers of most organisations, write the contracts as if they are about property rights, and to protect their own rights. The organisation does not want to loose their own property rights. However software is not like apples: If I have an apple, and you have an apple, and then we swap apples, then we both have one apple. If I have a program, and you have a program, and we both give each other a copy of the program, then we both have two programs. The programs have not diminished. Therefore to give one person rights we do not have to take them away form another. Therefore with software there is no need to deprive others, for you to have a right over it. (software/music/etc is not property.) The best way to do this, and protect the students is to allow the pupil to keep her/his copyright, and only giving copyright to the school, with a clause that they can not re-licence (This only gives the school power to prosecute infringement, but not to abuse their power. The pupil could not be prosecuted, as it is impossible for them to infringe the copyright, as they are a full copyright holder. You will need to see a lawyer for advice on this. Or better to talk to the FSF). And then to use the GPL licence (a copyleft licence). Other licences, including the MIT licences (that are permissive), but especially proprietary licences can abuse the power that the school (or anyone else) has over the students. This imbalance of power, may also invalidate any contract that you may think you have. I believe that a permissive licence is just as bad in this situation, as it can use this permission to take advantage; It would allow the school to create proprietary derivatives, of the pupils work. As the school may be in a better position to sell the software, this may not be fair. Where as a copyleft licence such as the GPL, makes it much harder to take advantage of the author. Any work that is licensed under the GPL gives anyone that has a copy of the program the following freedoms: 

I think you should develop your practice plans based on the competition that you're preparing for. I'm a high school teacher that has brought teams of students to Lockheed Martin's Code Quest for the past several years. Many of the problems can be solved by students towards the end of their year in AP CS. The additional training my students need is with File I/O. The best way to do that? A quick chalk-talk on I/O and then practice old Code Quest problems. Project Euler problems are excellent challenging programming problems, but they won't prepare my students nearly as well as old Code Quest problems. Take a look at what contest your students are competing in and work old problems (often readily available on the contest's website). Simulating the experiences that your students will encounter at competition is their best practice. 

I have just written myself a web-mark server, to store book marks to my website. I got fed up with the proprietary ones, and decided to make one of my own (probably could have found a ready made one with a Free Software Licence). It used Couchdb. This involves writing code in Java-script (the manual says that the server side code can also be written in python, I chose JavaScript, so it would help be learn it), but because it provides the framework, you write lots of small functions. You will also end up learning about the no-sql db couchdb, http, and client side web design (html, css, Java-Script). I used jquery and knockout.js on the client side. First things first Because I did not follow a tutorial, I ended up looking stuff up as I went. This would probably be to effort-full, if it was your first language, as you would be looking up everything, and not know what to look up (how can you look up how to do a foreach in java-script, if you have not yet heard of a foreach. Therefore it would be beneficial to find a tutorial to do first, then work on a project. You can also work on an existing project. There are many Free Software (Open Source) project that you could help with. It is much easier to contribute to an existing project, that to start from scratch. If you want you can contribute to my bookmark project. (If you do work on someone else's project, and it if for an assessment, then ensure that you tell the assessor what bits you worked on). Learning two languages at a time may make things confusing, and make it take longer to learn. However research into natural languages shows that, for babies and infants, learning two or more languages at a time has a positive long term affect. Though it does slow externally measurable performance at first. For these children the languages are in different contexts, one for each parent, or one at home / one at school. I would suggest that you focus on one language, until you get sufficiently skilled. Python seems to be widely used as a teaching language (1st scratch, then python). JavaScript has may pitfalls. A good language to learn Object Oriented is Eiffel. However you could learn, non-OO first (OO just adds to structured, most modern languages are structured or structured+OO). Therefore, if you have not used scratch, then have a play with it, then start on python. Other project Ideas — python 

I semi jokingly tell my students at the beginning of the year they can play any game they want on the computers, as long as they write it first. It at least gets a laugh. For me it takes two things. One, I need to be able to see their screens. Given, this is probably much easier with school provided devices. When I moved into the classroom I'm in all of the student seats were facing forward with the monitors facing away from the teacher. First thing I did was push all the desks to the wall so that the monitors are facing the center of the room. I can see almost every monitor from almost any spot in the room. This also helps getting to students to help them since I don't have to squeeze through rows. It does help that I have a pretty big classroom though. And two, I need to keep them busy. What I've found is that once there's a student playing games it spreads. And the first one usually isn't playing because they're screwing around. They're probably done with their assignments. I throw more assignments at a class than most students will be able to finish - some are extra credit. I also have a list of enrichment activities that they work on when done with labs - Coding Bat, Code Combat, Project Euler, making their own game, that sort of thing. That way there's always something CompSci related to work on. We are partially BYOD in that kids are free to bring their devices, but aren't required to. There's always a handful of students that prefer to work from their own notebooks. My rule on that is that they're free to do so, until I catch them screwing around on something else. Then, they have to use the school computers. For most, that's enough incentive to keep on task. 

I'm going to suggest that you don't use either Swing or JavaFX for an AP CS course. Instead, I'm going to suggest that you use Princeton's Standard Draw library. It does a great job of abstracting all of the ugly canvas and window setup that traditionally comes along with Swing or JavaFX. I have leveraged their library for multiple projects throughout the year and my students never complained about not understanding the graphics side of the projects. Full disclosure: StdDraw isn't as powerful as Swing of JavaFX, but why bring a nail gun to a job when a simple little hammer will do the trick? We use StdDraw within the first couple of weeks in the course and it simplifies the process for both teacher and student, while still allowing you to focus on the important learning outcomes. Plus their API is easy to read and serves as a great introduction to students about how to read documentation. tl;dr: The easiest library to add graphics to your project and for your students' use is Princeton's Standard Draw library. 

However often the teaching language does not directly support these. This may be an argument for choosing a different language for teaching programming. The problems that I am having I was teaching in the order I outlined for an ideal language, but are getting problems. ( I am teaching in python). For an infinite loop we use in python, however students ask or struggle with this. I can not explain it without explaining . So pupils have to hold something that they do not understand in their head. Similar for in python it is , this is a lot to keep in ones head without understanding. The question So the question is “what to do?”. Do we start with 

Do it in code, so that pupils can play with it. This code will throw an exception if the invariant is not met. Show how this can be useful in finding bugs in the program. The book a touch of class by Bertrand Meyer, is very good for teaching Object Oriented Programming and has examples (can't remember how many, but it is where I leant it). 

Keep the students in mind. Remember where they are coming from and that your goal isn't to turn them into CS researchers or software engineers in a single year. Expose them to the content in an order that appropriately challenges them, while avoiding the statement "You can ignore that for now" as much as possible. 

We teach AP CS assuming that our students come to us with no prior computing background. Being that the language for AP CS A is Java, we plan our sequencing accordingly. We don't follow the approach of starting with and user input because I think it (, , and ) produces too much of a cognitive load at once . I always try to minimize hand waving as much as possible in the early parts of a CS course to help students build their confidence in navigating code. While Eclipse is commonly used in industry and higher academia, an introductory course isn't industry or higher academia. So we use an IDE that is more appropriate for the new learner. We utilize BlueJ to begin demystifying Java from the very first day of class. Thanks to BlueJ, we don't have to discuss or making tester/runner classes to run our code. In our post-AP CS course we can introduce IntelliJ or Eclipse, once the students can comfortably grasp the idea of multiple classes and project directories. Our decision to introduce objects early was inspired by Dr. Kolling's book's sequencing and the fact that Java is the language taught in AP CS. Others may chime in by saying they think objects should be introduced late. I disagree for the reasons previously mentioned. Should we leave AP and teach Python or Javascript, I would wait until later in the course to introduce OOP. That being said, here is our general outline: 

I post solutions after the due date of an assignment. And usually, I'll go over them in class as well. Two birds... 

Wish I had a good answer, but I can sympathize with your Scratch example. What I started doing was just giving up on the first day we did Scratch. I would show them the drawing tools before we did any coding. Spent about 5 minutes showing how to make sprites and backgrounds and then gave them the rest of the period to play, with the understanding that was the only day that they had to just play around and doodle. Day two, we start coding. Worked fairly well. It was at least better after I started doing this than before. I think the novelty of it wore off when they were allowed to goof off for a day. Haven't taught Scratch in a few years, but I noticed the same thing happening with Jeroo. Kids love painting the island with flowers and water. The last lab in the set is one where they get to build their own lab, and make their own island. I think having that to look forward to helps. 

Note I have intentionally included some examples that may not fit in ether, and some that an arguably do. 

Decide what the test is before you code. Run the test to check that it fails. Write some code. Run the test to check it passes. Iterate as required. 

What is needed A box, that you put all of your votes into, and out comes a count for each candidate. Possible solutions How do you know that the output is correct. Ah that is easy, you produce an audit trail. But now we have no anonymity. So we add encryption. But for it to be audit-able, anonymity can still be broken. (If you can check your own vote, then I can check your vote (if I torture you long enough, then you will give up your key). A solution that works, but does not use a computer. The many boxes - you walk into a room (box1), and show your ID, your name is removed from the list, and you are given a voting sheet. - you walk into a subroom (box2), and make your mark on the sheet. - you then fold(box3) the sheet. - you leave box2 and walk to a locked box (box4), and place your sheet into it. - at all times observers (from all interested parties) are walking around box1, to check that the rules are being followed. - at the end box 4 is sealed. - latter box 4 is opened and the sheets counted. With lots of people watching. A set of totals is produced and announced. The sheets are put back in box 4, sealed and locked. I have probably missed some detail, but this solution cannot be implemented electrically, because there is no way of putting people into the electronic boxes to observe. Some videos on this The problem Some solutions I found a problem with all of these solution, as I was watching it (Did not have to sit and think for days). Other stuff