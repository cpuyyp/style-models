Execute next should follow the same idea and be split in a few methods like: that produces a list of arguments and that will take care of processing them and do the appropriate thing. 

why don't you use simply a ? Again, it is the same discussion related to marker interfaces we already had in your original question. I'd define in the following way: 

I think that having a class representing a recipient is good. It makes it much easier to understand what your code does that, for instance, having just a string representing the value. I'd take a step further and create the class such that it only represents a valid recipient. If you do that, you'll always be sure that your object contains valid data and you won't have to check for its validity all the time. You can do that quite easily with a builder method, that takes as input the email address and the name, validates them and either creates an instance of or throws an exception if the data is not valid. This has also the advantage of letting you detecting bad data as soon as the user enters it instead of when you need to actually use it. 

In I'd probably move the declaration of and of in the block. You're not going to use them outside that scope so it could be a good idea to give them the smallest scope possible. 

First I feel I should warn you that computation about time are hard, damn hard. You probably want to use a library specifically designed to address it like Noda Time. For instance, your code takes into account weekends assuming a Monday to Friday work week (it is not the case everywhere in the world) and does not take into account bank holidays, which are not working days. Said that, I think that your code is ok but I would rewrite it in this way to make it clearer. I'd like to split the code that computes the working days in full weeks and the code that computes the day in partial weeks. I also don't like the casting you do too much in the for loop. You can avoid the for loop altogether if you think a bit about how you should handle remaining days and do the maths. If the logic I'm following is not clear from the code leave a comment and I'll explain it a bit further. 

I agree with Resharper and I'd go for the version. The reason is that I associate with operations in which the number of elements actually matters while in your case you just need to check if there is at least one element. On the opposite helps you communicate that you need to iterate until you have no more elements. 

Once you encapsulate all the logic in that class, you can think at another class to encapsulate all the user interaction. That class should implement the following interface. 

You can read the choice of the user as you did, but you should change how you handle it to use the function we defined earlier. 

I'd try to go with a different approach. At the moment you're evaluating all the possible combinations, while I think it could be useful to evaluate only the meaningful ones. To do that I'd start with a two phase approach. First you can generate all the valid fleets and then you can sort them using a comparator that takes into account their Range/Variance. This is the code you can use to generate all the possible fleets: 

You should work on your comments. Why do you say that the class "Returns a GeneralEmployee object"? A method returns something, a class represents it. The comment on the constructor looks quite redundant. What does it add in addition to what is already written in the code? I think you should try to write self-esplicative code and limit comments to explain the reasons why you did something in that way or something that is particularly obscure. There is no point in repeating what it is already clear from the source code. Talking about the actual code, do you really need to change the values of and ? I'd rather make that class immutable, which has a lots of advantage in terms of ease of understanding the code and in term of maintaining it. Why do you have ? Isn't equivalent and more readable? I cannot see a reason why you want to do that. Are you sure that id generation it should be responsibility of the class? I think it would be much better to have a separate class, with a method and call it from outside the constructor and then pass to the constructor of the computer identifier. In that way you will have separate classes that address different concerns. I see you defined but not . In general it is better to define both of them. Here you can find more details. 

Let's see what I don't like in your code. Object initialisation The first thing I noticed is that you create new objects all the time when you probably don't really need to. Why do you need to create a new instance in main? Why do you need to create a new instance in and in ? They all look classes that you should instantiate only once in your application. I think you need to review what an object is and how you should design object oriented programs. Misplaced responsibilities Why do you have this statement ? should not both handle choice of what to do next and getting its input. Input should come from an external source. Naming How does your class represent a word? It doesn't look it does to me. Try to use names that really represent what your class does. If you cannot thing at a meaningful name you probably want to revise your design until everything has a natural and clear name (and hence has a well defined role). 

I have not implemented the methods , , and but they should be obvious. act as an immutable collection of ships. Once you get all the possible voyages you can just sort them using a comparator and Linq sort. I'm not sure this is going to help much, but it is worth giving it a try. A possible way to improve it is to keep track of the best fleet we generated so far and to just compare it with every fleet we generate instead of doing all the comparisons at the end. This could possibly prune a lot of solutions once you find a good one and it is definitely worth trying. 

I think your design introduces a few more dependencies than it should. Let's have a look at your interface 

Let's start with an alternative, more object oriented design. Then I'll make some comments about things you can improve in your code. You should try to clearly separate your game logic with what you need to do for handling input/output. Consider for instance the following class sketch to represent a game. 

I think you should probably also revise who should be in charge of implementing the method. From the names you're using it is quite clear that it is more natural to think at a player that uses an item. That's fine but what your code suggests is that different objects should be used in different ways, hence you need to implement it on the specific instance. Does spreading the logic on how a player uses an item across a lot of different items makes sense in your project? If you don't want to do it you might want to have a look at dobule dispatch as a possible way to retain all the behaviours on player instead than on objects. If you do double dispatch you can have interfaces such as and then have a method in with this signature . should expose a way to determine how many energy is added by the food to the player and the mutation of the state of the player should happen in the specific method you just created. If you show us how you intend to use those classes we can help you find the best way to design them. 

If you do this now you have different classes to cover different concerns with a very lightweight API. I appreciate your use of dependency injection instead of using singletons. I think it is quite good. 

Your design is quite good. Reading the code you wrote I have a few notes. What's the point of ? I am not sure that it is a good idea to define an interface and then put almost all the methods you're supposed to used to interact with it in . I think that you want to cover two different concerns. The first is what the client of your library should use, the other is what you need from your logging backend. I'd rename your in and I'd introduce a new class implemented as follows: 

In the first case you would need to produce a new list filtering the source one. In the second you would need to wrap an existing list providing a view that does not show its duplicate elements. What I don't like in this approach is that the name suggests that we have a linked list but it does not follow the APIs in the list interface. Another thing that looks quite bad to me is that you need to explicitly call the method to remove duplicates 

Generally it looks ok, but there are a few things I don't like. Do your really need you to contain mutable , , , and ? All of them would look better to be read only fields set by the constructor. What's the difference between and the value returned by method? In general, I think that a more even driven approach could be beneficial. What if you have an that allows s to subscribe for new messages? As soon as you have a new message you can feed it to the , which in turn it will be able to add the relevant information to . Note if you do that you will have a much simpler because it will not need anymore to poll queue. Basically, the idea is to have a that gets twitter messages, a that just has the responsibility of analysing them and to just store the processed data. Does it look any better? Finally, you decided to run two threads in parallel. That's fine but I think you should pay more attention to concurrency related issues with your queue. It is not synchronised so you could possibly have one thread reading from it and another modifying it, which could lead to crash or to inconsistent results. 

I don't understand the reason why you need . What you need are concrete classes imlementing your interface for your specific types. Imagine you want to map a to a . You need something like this: 

why do you do output there? It would be much better if you return an with all the prime factors of the number passed as input. Let the client decide what it needs to do with the result. It might need to output it but it might need to do something with all the prime factors instead. Why do you create an object for that class? It should not hold any state. What you need is a static method. It should be something purely functional. . With your code, the client of your code has to instantiate a new instance, which is useless. Holding the state also causes it to produce wrong results in cases such as the following: 

Once you have it, you're ready to compress all the duplicated code as follows. You create a list of tuples. Each tuple is in the form . Yes, you can pass around functions. 

I would replace and with the function invocation. I don't think they add much value. Probably replacing the while loop with recursive calls could help you express better the nature of the problem and it could simplify the code. C# compiler does not perform tail-call optimisation so you should be careful because recursion could cause a stack overflow. I would define in the body of the loop, so you can get rid of its assignment to . Finally, I'd move the logic to compute the bounds for the next iteration to a separate function 

I prefer using meaningful variable names, such as , even if I'm not sure if it is idiomatic Haskell. Ditto for the parentheses and the introduction of the helper function. 

I like more the first solution because it visually groups together the variables on the left side of the and the value on the right side. Unfortunately I can't back this preference with a strong reason other than personal taste. In your situation I'd struggle for uniformity across your codebase and define a single convention that every programmer should follow. It seems that you and your colleague are already trying to agree, but I wanted to point it out explicitly because I think that it is very important. 

I'd try to make your code more readable by giving a meaningful name to the variables you use. What about changing the signature of your method to 

I see you're writing Java code but you're not using object orientation at all. I think it would be nice if you think at how you could structure in classes your program. Why are you using a field for your variable? I'd also change its name to , it will improve the readability of your code. I think you should also create some more functions. Looking at your method I immediately felt it needs at least to be split in and in , or something similar. As I said earlier, you could probably get a better result if you introduce some classes. looks a bit too complex as it mixes your game logic with dealing with user interaction. Ideally they should be separated. You should have a method that deals with reading the number from the keyboard (dealing with possible errors as you do) and another one that takes as parameter the number inserted by the user and determines whether it is the right one. Why do you use when you could use ? Both the methods work, but I think the second is closer to the result you want to achieve. You can probably also replace most of the code you use to generate the formatted representation of the string if you create some methods like that takes as parameter some integers that represents the number of spaces and puts dots between them. You asked for comments on efficiency. I think that the problem you are addressing is simple enough that any reasonable implementation will perform well. I recommend you to focus on how you structure your code and on how to make it readable and easy to maintain rather than doing some micro-optimisations that you won't ever notice. 

I don't think that is a good name. What about ? style doesn't look too functional. What about ? In that way you'll have a function you can use to count the number of items matching a predicate in any list, instead of having to compute first the a list of boolean values. If you use you'll need to rearrange change and . 

I think it is worth it, even if you're implementing a simple mathematical function like this one. I'd also try to make it clear what you're doing with the expression. What about introducing an variable? I think introducing it (or an equivalent function) would make your code more readable. I'd also rename to something like , which would make it clear that you're computing the factor corresponding to each binary digit and deciding whether to use it or not according to . I'd also recommend you to do some validation of your input values. What happens if you get passed a negative value for ? You can either make it an exceptional case and throw an or handle it knowing that