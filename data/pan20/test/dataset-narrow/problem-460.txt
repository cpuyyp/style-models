I agree with most of the remarks by @JerryCoffin. In addition, I would shorten the computation of and to a single initialization using : 

Here's a two-line solution using some of the standard algorithms: first a copy of the string, then use to determine if any adjacent characters are identical. If there aren't, will return the iterator of the string copy, so you simply compare against that 

I am in the process of learning Python (background in C++ and R). So after the obligatory "Hello World", I decided that my first non-trivial program would be a port of a Java implementation of the counter-factual regret minimization algorithm for a simple dice game called Liar Die [original source, Joodle online compiler]. The program runs a million simulations of the dice game and computes the optimal bluffing/calling frequencies. It does this by creating class instances for all decision points in the game, and keeping track of the various actions the player to move can make, as well as the expected values of those actions. I then tried to translate this into Python as faithfully as possible: 

In a professional setting, the advice would be: "scrap this entire code and use ". But suppose didn't exist in the Standard Library, or suppose you wanted to write some other container-like entity not yet invented. The professional advice would then be: "try and leverage as much existing code as possible". E.g. implement in terms of an existing container such as , or . This would automatically remove all the memory management issues from your consideration. In professional code, unless carefully documented why it would be absolutely necessary, I wouldn't expect to see raw or , and instead to see either and or memory managing containers like or . BTW, this is also how the Standard Library implements because it is a container adaptor and not a container. The precise class template is: 

Why write it yourself if you can use Boost.Range's . You can even adapt this to set the starting index to and get type behavior (called here). 

After looking in more detail to the assembler output, I think this is one of the very rare cases where the use of might actually be warranted (which is what the compiler is reducing the original code to): 

A number with prime factorisation (where are primes and their exponents) has a number of divisors equal to . A triangle number is equal to . These factors have no prime factors in common and only one of them has a factor of two. This means that the number of divisors of a triangle number can be factored in the number of the divisors of and . 

I think this problem screams out for Boost.MultiIndex. It allows to add multiple indices to a container. In your case, you seem to want both a and a interface. In Boost.MultiIndex, these index types are called and . A simple template definition would be 

I think you are right on track because your code has pretty much the same interface as as the Standard Library header . Just replace all your classes with , your to and to and you are all set: 

Your approach is not very idiomatic. It is very hard to read, and reason-about. Spotting mistakes is not easy. I will not even attempt it, as I think some major rewriting should be your first priority. I think your current approach of trying to solve the entire problem in one big function is a big part of the reason why you had to work so long on it! Of course, algorithms are hard, but you can use well-known building blocks to build larger ones. I would try to mimic the Standard Library / Boost as much as possible. This means using divide-and-conquer to split your problem up into manageable pieces, each of which are easy to reason about without knowing too much of the rest of the problem. 

Live Example. The implementation is a lot easier than your classes: it consists of a single class template 

I'd like to see a reproducible benchmark before being able to comment on whether a 10x improvement is really possible on . 

The parameter is a signed integer that contains the , and the is used to convert without loss of precision. You can also define your own types , or this way. As you can so from my code example, you don't have to convert types to prove equality, just use directly on the objects. is only necessary to print stuff in different units, not for computations. 

Note that the variadic constructor allows linear scaling of constructor delegation in the user-defined class template . One minor wart is that this constructor does require passing all parameters (but otherwise, different constructors have to be written). But if any of the traits variables evaluates to false, the corresponding parameter and call to the base constructor will be optimized away. And because also has a trivial default constructor, POD-ness of user-defined classes is preserved by inheriting from it. Obviously, over-use of inheritance has to be avoided, but the above design does avoid quite a lot of code duplication. Oh, and I haven't tested this with virtual functions, virtual base classes and what-not. I just use this for assembling value-semantic classes out of conditional building blocks. Question: what other design / usability issues could there be with the above code? 

Overall, I like your liberal use of C++11 style. One minor nitpick about the use of that occurs all over the place: 

how can I make my code more Pythonic? which other idioms / coding style should I apply? which other useful libraries (besides NumPy) could I have used for this exercise? 

the use of is superfluous here since anything defined in-class is implicitly inline, and furthermore, is only a compiler hint for actual inlining (the main use of is to prevent ODR violations in header files). 

It's a good exercise to implement the stack member functions , and in terms of the , and of the underlying container. It's still not entirely trivial, because you have to be careful about perfect forwarding and move semantics. The linked documentation should provide you with enough hints to comlete this. Note that does not provide an and neither does it provide iterators to view its elements. It does however have a protected member that gives access to the underlying container. You can then write an adaptor that uses the container iterators to show the underlying elements: 

Note that requires all 3 actions, the last 2 actions, and only the 3rd action. I was not happy with this code: while efficient in avoiding extra work, it seems overly repetitive. However, the following straightforward try at refactoring is a lot more concise but also less efficient as it computes all 3 predicates for all inputs: 

From these suggestions, it's easy to compose a general, flexible and almost certainly correct algorithm. Each step can be reasoned about in isolation. There is very little room for off-by-one errors. There is no unecessary copying of large vectors, just tuples of iterators. Regarding your question for test cases: I would start with some simple stuff. Sequences with 0, 1 or 2 elements. Sequences with only alternating elements. Sequences with no alternating elements, etc. 

In generic code, I sometimes want to conditionally add a data member to a class template. Writing separate template specializations scales as for conditional data members. Absent a static_if feature, I have found the following user-defined class templates and useful: 

So I came up with the idea of caching the predicate values in a and dispatch the various actions based on that: 

Exploiting the empty base optimization then allows users to write class templates that have optional data members (conditional on user-defined template variable traits and ) 

Note that the function takes its argument by-value, which allows also temporaries as arguments. As pointed out by @ChrisW in the comments, you could also use as argument but then you would need an extra copy in order to be able to sort. It works on strings of any length and for any character set. Live Example. 

The documentation of Boost.MultiIndex is one of the best of all the Boost libraries, so you should be able to work out how to iterate over this container, and how to insert/erase elements. The library will guarantee you amortized insertion/erasure, as well as bidirectional iteration and splicing and sorting. If you wonder how this is implemented, there is a special section about that in the docs. I think that this is much better than to build your own container. Writing proper containers (with correct complexity, exception safety, resource management and move semantics) is very hard. Leveraging high-quality libraries should be your first priority. BTW, here's a somewhat related in-depth discussion of various ways to write an LRU-cache, starting with using combinations of STL containers and ending with Boost.Bimap (which is a special case of Boost.MultIndex). It shows how many of the pointer manipulations of hand-written solutions are quite intricate to get correct and efficient. 

write functions that take an and return an . Don't use Pascal like procedures by modifying a reference argument. This makes your code harder to reason about. separate computation from I/O: an algorithm should ideally have no side effects, and be silent. If you want to query the result, just print that. 

Working example on the Ideone online compiler (factor of 1000 less iterations, apparently Python is way slower than even Java). Unfortunately, the algorithm works by randomly throwing dice, and the Java/Python random number generators give different sequences, and the dice game may not have a unique equilibrium anyway. This means I can't directly compare the outcomes. Questions: 

Live Example, using Clang 3.4 return-type-deduction in C++1y mode (also supported by gcc 4.9, and other compilers soon (use trailing return types for C++11 compilers) 

Project Euler problems typically don't benefit from micro-optimizations such as inlining functions or flushing standard output. The biggest speed gains often come from algorithmic improvements. Here there are two key mathematical facts that can make this computation tractable: