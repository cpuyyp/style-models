note that some areas are still a part of two groups. and width of area both group cover is exactly . In your case if boids move one pixel per simulation step you only need to share 2 pixel width area between each 2 group. and there is a small area which is a part of 4 groups. but in general this method is easier to implement and by far faster if implemented correctly. and by the way there is no reverse move this way, if some object can move it can move no more checking is required. 

as much as I can remember, there is no built-in threads in cocos2d. as you said everything is event driven but, events are queued, and run once at a time. so you don't need to worry about the thread safety at all, just keep in mind that some when you schedule two different events, they might not be run in same order as you scheduled them. but I think the priority option will solve that issue events with lower priority runs first. 

According, the value passed to timer function, is the one you provided when registering the timer as the third parameter. Read here for more information. It's mainly for the purpose of tagging different calls to timer functions, so that you can do different things based on tags. If you want to keep track of actual time passed since last frame, you've got to keep track of time yourself; With mechanisms like std::chrono::high_resolution_clock. 

if I remember correctly all global variables are guarantied to be initialized to zero before the application starts (correct me if I'm wrong) so you won't have such mentioned problem with this code. 

Compute delta_time Process input (aka. touch events, key events, ...) Update functions & actions call visit function on the running scene (in case of v3.x) do actual rendering stuff 

You only need a CCTMXLayer, there is no need for any thing else. but you'll need to initialize it properly. for that reason I suggest you use some TMX file generated with Tiled editor and then load it into your program. there is a GID value for each tile in TMXLayer and you can easily edit it. by changing that value the tile for that position will change. if you set a tile's GID to 0 TMXLayer will automatically delete tile at that position otherwise, it'll change(or create) the ccSprite instance at that position. 

Here is another thought, Although I'm not sure how good it will perform: The thing is, the Transform component is mandatory, but it doesn't really matter the internal class is, as long as it provides position, rotation and other details about an object's spacial properties. What I mean is, you can have to classes, both providing all the information necessary. But a class doesn't need to have both of those components. In fact those two (physics and transform) can not be present at a same time, but only one them should be attached to each entity. To make it even easier they might even share a base parent component class. 

the simplest form you can simulate it is to use two weights connected to each other with a spring, resembeling head and tail of the arrow. and you have to just give the following object a little more thrust that the heading one to cause the arrow move like a real one, it just needs some tuning before it get's well, but it'll create a realistic movement. you can also make some diffrences for other parameters of head and tail weights, for example tail object has more air friction than the head one. 

although it may need some changes before really used but i guess you can create some code like this. you can also use inheritance and use classes for each stage instead of the approach i suggested. other than these i think you have to develop a tool yourself. 

You can also simplify above equation by assuming charge of the ball is . this will only scale your the values you need to assign to each static charge. From this point you just need to update the ball velocity and position according to force applied. 

AFAIK people like scripting because it's easier, and it makes development cycle faster. But what about when games are shipped. No one expects shipped binaries to be changed, unless there is an update or a DLC. So why developers don't compile their script files before shipping? Potential benefits: 

this way you are using the delta time provided to you, it means object will move with the same speed no matter how many times update function is called in one second. it also should help your animation look smoother. 

now we need to make sure libRocket uses same window for it's rendering, after a little search in it's files I've found a file (address is based on googlecode) which contains window creation functions. there you'll see a function named . that is the main function responsible for creating a window. to make libRocket reuse our variable you have to remove/comment all the lines in that function except these : 

Color value basically consists of 4 single byte channel values, these 4 value represent R, G, B and transparency(A) of that color. An integer value is also a 4 byte value, so these two types are used interchangeably. Based on the name of the function you are using I'm guessing the R is packed as the byte with lowest value, and A is the highest value byte. so to convert a color into packed integer format that function is basically computing 

The only game I knew that I think may use machine-learning is Tekken 5: Dark Resurrection for psp. in that dojo mode game AI could learn how you play with each one of characters and it created a ghost of you playing that specific character. later you could fight with yourself or give your shadow to your friend and let him to fight against your shadow. 

Each of these ways has their own advantages and weaknesses. But I suggest you use one of existing gameengines, either cocos2d-x (if you are a coder by nature) or Unity (if you are a designer) 

i think the easiest way to solve your problem is to change your camera type from prespective to isometric, that will solve the problem you are facing, but if you want to realy render tour scene with perspective features you have to change your set position function, the whole idea is to find a position where a ray hits a plane right in front of the camera, you have to compute what ray is using x/y your physics engine (ray's starting point is your camera and it's direction is based on the x/y of your object) and the plane it hits is perpendicular to camera direction right in from of it. 

which one has more potential customers, easier API, and wider feature list? i'm going to develop implement one of those two for highscore recording in my game which ones gives more advantages? and by the way I might be going to port my game to android, so if you know any thing that can help me not to rewrite my code (for example a C++ wrapper for both of them) that would mean a greate plus for openfeint in my point of veiw. 

The default interval is 1/60s. Although you can set it manually using , it's not usually effective for intervals less than 1/60s simply because of vertical sync in case of desktop platforms, or hardware limits in case of mobile ones. For desktop platforms (specially windows that I've already tested) though you can disable vsync using 

Note that, in this scenario game server actually has no way of eavesdropping, even though the whole authentication is passing through it. for the same reason your ISP can't monitor what packets you send to Facebook, or are coming from facebook. 

assuming that path is created from a polyline, your isOut function can do more than just returning whether player is outside of the path or not. it's almost easy to determine which line your player passed when it moved outside, and then it's easy to calculate a vector perpendicular to crossed line and exact position where player went out of boundary. using these data you can create a new movement function which won't go out of path. another way is the code I'm posting here, it's a code we once used to solve slide problem in a game and it worked well enough. hope you can convert this code: 

This way you'll both see the ball everywhere even if no particles are drawn at that pixel(caused by the back ball picture), and you can always see the ball. And for blending method just use the normal function implemented by default. 

Another solution is to use a map 2x larger than what your are showing. each time you want to move players you move them twice so players always land on tiles with even value for both X and Y. again there will be some rare cases that will need more attention but most of possible cases are resolved (like the one you described) without thinking twice. 

from my point of view no! surely writing your own engine will help you a lot, but if you are new to programming and specially game development, you don't need what you need to implement! and besides, engines are written to provide useful features with minimum performance loss. as you say you are new to programming so you still don't know how to optimize critical sections of your code. so in general developing an engine is a good learning opportunity, but you need to know a lot of things to be able to start developing one! it's just like trying to learn programming with C++. Although you can do anything with C++ and almost all professional game developers get their jobs done using it (don't argue I said almost!), no one recommends it for the first language to learn, since a programmer without experience could break the whole thing easily without even noticing what was wrong! 

note that there is one extra condition where X is exactly zero, in that case sign function should return 0 since x doesn't have any sign! how to normalize a 2D Vector (or a vector in higher dimensions)? the basic idea is to create a vector which has a length of exactly 1 so the first step is to calculate length of current vector. 

if you are going to just create a prototype for your games you can use Esenthel Engine. it's basically designed for an mmorpg games, but it has reach framework for any kind of game you need to create. ofcourse you can expand your prototypes to full game using this engine but i'm not sure how the results will be. 

This was also my question for a long time, I'm not sure If it's the best practice to create puzzles but I've got an answer now. To make the story short just imagine a simple valid end game situation, then move step by step backward and get to an start point. Now to give more details: you want the puzzle to always be solvable, from gamers point of view it's not important if the puzzle has two or three solutions but to have at least one! Keeping that in mind you can start your design by making reverse valid moves. You said it's a game that you need to somehow move all the blocks off the gameboard. So for the first step imagine playing being at the edge of map, and there is no red blocks anywhere on the board. From that situation you start making reverse moves which are normal moves (reverse of another normal move), or pulling a block (which is reverse of pushing block) and pulling a block into the gameboard (which is obviously reverse for pushing that block out of scene). By this approach you know there is always at least one method to solve the puzzle, you can do undo all those steps you took to create the puzzle for solving it. As Hackworth suggested creating puzzles this way might generate very simple or non creative puzzles at first, but after making some puzzles you will little by little learn what type of moves will result in a good puzzle. It's exactly the same way a player would gain experience to solve harder puzzles after solving simple ones. 

I don't know if there are any good capturing program or not but there are two ways to minimize framedrop: one is to attach your pc vga output to another device (like dvdplayer or satelite receiver or any other device that can capture video) and use that as a capturing device. second one is something that i won't go with it myself and it's to get a copy of video buffer in your code back to cpu and then save it. it also slows your program but much less compared to capturing applications. 

As you suggested we can put a pointer of each of them into another, it's the most simple solution but might easily get out of control. You can also use singleton/multiton design, with this method you should define your GameEngine class as a singleton and each of those GameStates as a multiton. Though many of developers consider both singleton and multiton to be AntiPattern I prefer this kinda design. You can use global variables, hey are basically same thing as Singleton/multiton but they a slight difference in the fac that they don' limit the programmer no to create instances at will. 

you may restrict engine functionalities, by your wrapper. that's just possible if you don't want to copy all the features engine provide with exactly same structures. it always takes time to write something. both from programmers and computer. there are also many potential bugs you might introduce and whenever you need a new feature from engine you need to first write a wrapper to make that feature available in your code. it may decrease production speed alot. 

Now back to your problem, I assume you have some problem with syncing audio and video in your game. As kylotan suggested there should be something wrong with your delta time calculator. then again I guess you can somehow predict how much you update call going to last (for example if you are running your game at 60fps, you may assume each game cycle last around 0.016 seconds) and just play music with that much difference with your accual game time. 

I guess it really depend on what type of leafs you want to simulate. for each type go out and check how it's moving in the air. there is no need for an actual physical simulation just find a function that has an output similar to what the leaf moves. here are some sample function: 

textures are just a layer drawn on top of the object. which is technically called . most games usually use other maps such as , , , ... which makes objects rendering more realistic. and there are some applications like ZBrush which allow user to paint over 3D objects instead of working on a 2D texture. 

--Edit-- Just today I've started reading their code from the beginning. To understand what they've written you have to be a decent C and C++ programmer (although their code is well commented)! I mean you have to be a master of both languages since they are using structures from both! so if you are not confident enough about your programming skills don't even go near that code! that's the dirtiest code I've ever seen! (and I'm a dirty coder myself but they are something else!) I think now I can suggest you check supertux code. it's a platformer game (just like super mario) and so far their code seems really clean (I've checked milestone 1.3). they have some comments in that code but only for places that you might get confused.