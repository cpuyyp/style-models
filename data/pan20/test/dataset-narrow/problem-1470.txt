When dealing with MS-Word documents and other non-diffable objects, a revision control system that uses / or allows locking should be used. This precludes distributed revision control. For this use case Subversion (svn), is preferable to git or mercurial (hg). 

Software craftsmanship As professionals, we need a set of ethics (ethics is not the same as morality). Medics have ethics, even lawyers have ethics. They can be struck off from their profession if they do not stick to them. If we do not create our own, then they will be imposed on us (see talk by Uncle Bob Martin). In some ways it does not matter exactly what they are. You could have a class discussion. You could include those proposed by others. There are many points of view. A few contradict, but many do not. I have included those proposed by Uncle Bob et al. Agile manifesto We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value: 

Most of what I was going to say was covered by @Buffy. Also I have not tried this in the classroom yet. It is some ideas that I had, based on my industry experience. Pick and choose what seems right, and test it. Do it agile one requirement at a time. 

If you see a then you can cancel out the and the , it is in this context not a pointer, but I can drop the to make it a pointer. Where a variable doest not have a , there is no to drop, however I can add a . works as the opposite of a . is same as 

However It may be possible to teach a non-computerised revision control system. What to revision control The artefacts do not need to be source code. We often mix up revision-control with source-control. However revision control can be used for so much more. You can use revision control for every file in your home directory (I also revision control ). However to get the best value from it, you will need a good diff tool for each file type. Thus making Microsoft's Office documents not a good choice. Therefore it may be better to start with some other artefacts, that are not programs. Which tool. There are many revision control tools. Three of the most powerful/popular are git, mercurial, and subversion. The tool that you start with, will make a large difference to the learning. 

Use Russian dolls Russian dolls nest inside each other, much line block of code in almost all modern programming language (maybe all post “goto considered harmful” languages). Russian dolls nest like this , in programming we can also nest like this no nesting, this or this I have used Russian dolls to help to explain the idea of nesting. From $URL$ CC0 Public Domain 

What C++ can do that other languages can not. Myth C++ is a good, fast OO language. This is not true. Eiffel is as fast, safer, and more OO than Java. Fact C++ is the only language, I know of, where you can create a statically checked dimensions checker. That is a system, that checks at compile time, that your types are dimensionality correct. E.g. 

As well as those (what are sometime referred to as soft) skills. I would say that there are other skills that are needed to be a good programmer. Not all of these would I expect to see in a graduate. However I would expect to see some. 

I did it in $O(n)$ once, that was the day I learnt a lot about caching. It was hard, it took me a whole day. 

I have heard the argument that doing this properly would be do difficult for a beginner class. I agree. I would not try to fix this program. I would just present a different program. I have seen a lot of bad practice taught, that then needs to be untaught latter on. When I was a software engineer, it was often me un-teaching new recruits. This was not easy when they were not good at critical thinking, and saw what they were taught as truth. 

How I have personally used git, successfully. I mostly use mercurial. It is like git. It does much the same thing, but is much easier to use. It has a nice command line, and a nice GUI (tortoise hg). Mercurial has a git plug-in, that allows it to work with git repositories. If there is this git repository, that you want to work on, then you do a clone in mercurial, and now you have it in mercurial (just as you could have done a clone in git). You then work in mercurial, and can push/pull changes back to the upstream repository, or to a friends repository (just as you could have done in git). The only difference is the interface is easier to use. Disadvantages When you clone a git repository, you end up with a git repository and a mercurial repository on you local drive. Thus the size of the local repository is roughly double. Mercurial is not efficient at renames and moves. It does a copy and delete. This may have a fix sometime. 

Have some reasons why they should use the command line. Here are some of mine. Why I like the command line: Less typing How can this be I hear you ask. Well I login, reverse search (ctrl-r) or up arrow (⬆) for a command I typed last week and hit carriage return. The alternative is far more mouse clicks (and trying to remember). Show an example of you having to repeat the some actions on the GUI to do a repetitive task. Then show you doing it on the command line, using up arrow, and making a small change. Also show an example of you getting to the end of a work flow and realising that you have to go back to the start, and then having to repeat the work flow. (note this reflects bad GUI design, but the CLI is a way to avoid it.) So you were taking pictures of cats, but then you saw a dog at 11:10, and started taking pictures of dogs. So now you have a folder full of pictures, with names like “cat with a ball”, for an labrador puppy. So you need to rename 100 photos. (It was a long day. You took a lot of photos, and learnt that a dog is not a type of cat.) 

There are many. UML is only one organisations attempt at creating a collection. Some of UML is useful, some is in there because committee members had a product to sell, some is only sometimes useful. Some alternatives 

I don't seem to have a problem with low-level ones. Though I no-longer see a need to use low-level languages. As Eiffel, Go and maybe others can do their job better, and as fast. The least troubling of the High-level languages seems to be Eiffel, but this is OO. So we need a good non-OO high-level language to teach first. I teach python, but I don't like it as a teaching language (it has a few problems). Therefore High or Low? It depends, but avoid the treacherous middle. 

Link to what they have already learnt on the course. [I have made an assumption, that they have already done this.] John von Neumann, said it is all data. Data and code are data. We have already learnt to pass data, but what about this other data, the code. We should be able to pass that as well. How can we do it. They are delegate types. Look at things I can pass to you 

“Simber and the hiyeners enter stage left …” (from the lion king, a variant of hamlet) What type of object is this? It is a set of instructions. I can pass it around, and ask people to do what it says. 

It is impossible to say which is best, but here are some things to consider. Some factors: paper books vs e-books 

In addition: Static or dynamic If you teach not to declare types first, then that is what you will get. Assignments We often teach assignment early, this is crazy. In structure and interpretation of computer programming, they covered almost everything I know, and then started to apologise, because they were about to introduce assignment (mutation). As soon as you introduce assignment, you make is very hard to reason about how a program works. I have taught types when teaching functions. Functions take values (of a type), and return values (of a type). This in some ways looks like assignment, but is not. It is safer, and makes code easier to understand. 

An array is like a list of event handlers. But it is not like an event handler. Telling students stuff does not work well, but having them discover it does. The student has seen something in the description that is like an array, this is good they are making connections. Unfortunately (at you say) they may make the wrong connection. You are discussing a list/array of event handlers, the student thinks you are talking about event handlers. Therefore as @Buffy said, ask them to elaborate. Ask how it is like an array, and how it is not. You could also do an active learning activity: have a student be an event handler, another to be an event, a sheet of paper to be a button. Act this through. Then add another event-handler/student, then another. Where do they go? What is the data structure that the event-handlers are in. What do we have to do to trigger all of the events-handlers. [There is something else doing a ] 

I have had the same problems when teaching spreadsheets, and am anticipating it with web design. I was hoping to use the brackets editor. The start state would be. 

I read something on this site, that lead me to read about Bret Victor's learnable programming and direct manipulation. I was wondering if anyone has used any software like this. What software have we used? What effect did it have on teaching and learning? What is direct manipulation, also referred to as learnable programming Victor tells us that the techniques that we now use, are based on best practice from the days of paper and pen, teletypes. That we have not yet adapted to this new media and what it can do. That typing a program, and then immediately running it, is not immediate enough. Output should change as code changes, not wait for us to press run. We should be able to manipulate the output, to change the code. Not just manipulate the code, to change the output. An example: Here we see the programmer, manipulating a variable, by using a slider. We the the effect on the output. We see the effect over time. The programmer is trying to give the turtle the correct bounce, so that the jumping character will be able to get through the gap. The programmer no-longer had to do long calculations, or do guess/change/run cycles. Whey just slide the slider until they see what they want. see: