Scan the map for advantageous positions (high ground, bottlenecks, etc) either within a range or globally, depending on how smart/fast you want them to be. Compute the number of minimum turns required to reach that spot, and compare that number to the number of turns the player would have to use to get there. If the AI should decide to move, scan the immediate surroundings. If the terrain's obstacles are purely static(mountains, forest, etc), then find the quickest route around. If the obstacles are dynamic (other AI, or (I guess) player units), check if the AI is in the way, and if so, determine if it is about to move. If it is moving soon, wait it out, otherwise, go around. In order to move as a team, I would implement a 'squad' sort of class/array. Assign one squad to the front; if another is available, assign it to the rear; if another is available, assign it to the side closest to the nearest hostile. If a single unit is dispatched to reach the gates, dispatch a single unit (or two, if you want to smite the player) from the largest squad. 

Well since you spaghetti so kindly, I personally use an enumeration for which animation state the character is in. The states I use for a 2D platformer are simply RUN, IDLE, JUMP_RISE, and JUMP_FALL. Each animation state corresponds with a set of 8 sprites, which are loaded to my camera function, which changes what the player looks like on screen. Are you looking more specifically at 2D animations or 3D? Both function on essentially the same principles, but you may require a 3rd party program for 3D animations depending on your skill level. 

You can see, that you have some terrain textures and an alpha map. I handle the alpha map also as tiles, but they are half sized (terrain textures are 64x64, blend textures are 32x32), this means that every terrain can have up to four blend textures (northwest, northeast, southwest, southeast). Now basically what you do, when you have a transition is this: - Draw the ground texture (blends are always applied on the higher terrain types). - Draw the alpha map with ALPHA_MAP (this only renders the alpha channel) - Draw the second texture with ALPHA_BLEND (this uses the underlying alpha channel, we rendered out before as alpha for the tile). So basically this is the theory... But you need to do some things, that it works properly. What I do is following: 

Define your viewport (position and size of the viewport). If you have this, you can define your borders. When your viewport position defines the upper left corner of your screen its pretty easy to restrict the screen position. First of all you set the screen position to be centered on the player: 

I think I stumbled upon this link here on gamedev and I really found it enlighting. $URL$ It explains some basic methods of implementing tile based levels, but there are also some important parts about how certain mechanics work in 2d platformers. I think you should look into slopes, as they can solve many problems you come across in platformers. Good to know is, that most platformers don't even bother with implementing proper physics, but implement certain rules, that mimic some physical behavior (like gravity), but allow certain behaviors that wouldn't be allowed with proper physics (air control for example). 

While testing my player's jumpinig algorithm, I've come across two odd problems. 1) My player's hard-coded jump height is always much greater (roughly 1.5 times) than the in-game result, making me enter completely abstract numbers for the hard-coded value. 2) My player's jump height increases with lower FPS. At 60 FPS, the jump height was found to be 237, and at 30 FPS it was 269. This has me completely bumfuzzled. I've been using this article pretty heavily while implementing my jumping function which can be seen below. 

SDL2 is very capable of doing exactly what you ask. SDL2 is also more efficient and has much more utility. I highly recommend upgrading to SDL2 by following the instructions provided in the Migration Guide on SDL Wiki. EDIT: It took me a few days to migrate my project from SDL 1.2 to 2.0.3; most of the migration process was changing from SDL_Surface to SDL_Texture and figuring out how the new SDL_Renderer and SDL_Window types work together. 

You absolutely can combine them! Many 3D games contain an image for the characters body and one for the head, and some combine the two for a single texture for the entire a model. Here's an example of a whole head's texture: 

The angle of the feet is equal to the angle of the inclined surface. Since we conveniently have two points on that slope, we can find the angle of inclination (it's also possible to use two corners of the slope's triangular shape, but gradual slopes would become over complicated; for rolling hills, this is the best solution). Ultimately the slope will be H/P (assuming the heel of the bent leg is directly beneath the corresponding hip), or arctan(H/P) rad. Using cosines, one can easily find that H = (F+T) - (Fcosθ + Tcosφ). The angle of the foot becomes arctan((F(1-cosθ) + T(1-cosφ)) / P) PS: If you want to REALLY get into, you could also find the added width to P. PSS: The foot will only bend to far up, so keep that in mind before you try to climb an 80 degree slope. PSSS: People don't climb hills on their heels, but they do rest on them. Keeping the foot perfectly flat up the hill could somewhat accurately depict the player standing on the balls of their toes, and allowing the heel to sink to the ground while idling could make for some very realistic movement. 

Now you see, in the fourth row in the second column, there is a grass tile. Left of it is a water tile and on top and bottom of it are sand tiles. When we look at the rendering only for this tile, this is what happens: 

In the first grid you see the terrain configuration. W stands for water, S for sand and G for grass. The second grid shows, how the blend tiles are applied. Like I mentioned earlier, the width and height of the blend tiles is the half of the terrain tiles. Here now the first render action happens. The lowest terrain type is water, so we fill all the cells (and all adjacent cells) with the water tiles. So allthough the water tiles only fill the first column of our definition, we have also to fill the second column. Now we draw the next layer, but we only draw the tiles, that won't be blended. Water is a lower terrain then sand, so we do not need to expand to that side. But because the grass is higher, we have to fill the adjacent tiles with sand, where the grass blend will be rendered over. Now based on some patterns, we render the blending parts of the sand. (Now you see, why we need to also fill the adjacent tiles). Here we have repeated steps 4 and 5 (allthough step 4 wouldn't produce any output, as all grass tiles in this examples will contain a blend). 

Basically this should be what you are looking for... You have to keep some things in mind, for example you can leave out the upper bounds check, if the screen size in that dimension is bigger than the map size ( viewport.width > map.width ). Also, if you have your map width in tiles instead of pixel, you would have to multiply the map sizes with the tile size. If your screen position marks the middle of the screen, you would need to change some of the calculations a bit, but the basic idea is the same. 

Like countless other video games, I'd like to have scripted sequences in my game. Character 1 says something, the player replies, then a rock falls, that sorta stuff. I could find a way to do it, but I would like to use a common method, assuming there is one. My current thought is to have a separate file for each level of the game that contains all the possible scripted actions for that level. When the corresponding trigger is activated, the function is called. I think early Call of Duty games (up to CoD4) used something similar, but I'm not entirely sure. 

My question: Which of these two processes, if either, would be less of a burden to the cpu? If neither seem reasonable, what other alternatives are there? 

As a mobile gamer, I can say (personally) that some in-game adds don't bother me at all. For example: the game Jupiter Jump by Noodlecake Studios only shows ads after the first attempt (full screen) as well as at the main menu along the top. I think this is well-executed, as it doesn't overload the player after every attempt. Vector, by Nikku, is a little encumbering. After every attempt (roughly every minute) a full-screen ad is displayed. This not only annoys the player, but abruptly interrupts the flow and plot of the game. Placing your ads away from the main focus of the screen creates far less stress for the user, and carefully managing the frequency at which you display ads can also keep your players engaged and entertained while unknowingly supporting the developer. One thing to avoid at all costs is "pay $2 to get 50 coins!" If the user downloaded the game for free, odds are that he or she will steer clear of paying for anything, unless they become obsessed with the game (Candy Crush Saga). Also avoid using "sign up for Dish to receive 1000 XP" sort of deals. It's completely irrelevant to the user, and encouraging the user to sling his or her credit card information at one random company or another is borderline immoral. 

You should take a look at quad trees. Its a common datastructure to store spatial data in cells. When you do the collision testing, you simply test against the objects in the same cell... I use the same datastructure for rendering. I pass the rect that defines the viewport into a selection method of the tree and receive a list of cells. Now i just have to render all sprites from those nodes... When the object spans over multiple cells ,you can add it to both cells. Just make sure to remove the duplicates ,when you use the results from the selection method. I'm currently on my phone, so I have no code examples here ,but a quick google for quadtree should help. 

And we could also switch one of the sand tiles and the grass tile on the right to different terrain types, it would still produce correct results. 

Another solution often used to "hide" the game files is folder structure. Keep only your executables and maybe a readme in the main directory and move the game files into a sub folder "data". I don't think that it is very uncommon to do so. Many games I know store their content in such a way. 

If you look at the code, you can see that two things were implemented. The update method changes the position of the GameObject according to the defined velocity. And the render method first simply calls the render method of the base class and then checks, if it has to draw the building material. Some comments to this. The entities do not manage their state themselves (besides the position), but you would handle all game objects in the game loop and depending on the state you would change the fields of the entity, for example like this: 

Just a quick question about fine-tuning/optimization. If I'm making a 2D platformer with a parallax-scrolling background (meaning no two frames are the same) do I really need to clear my renderer for every iteration? The entire scene will be drawn-over anyways, so if I can get rid of one extra function every iteration, it could help to speed things up a little bit, though I realize that render-clearing is not a very expensive function. By the way, I'm using SDL2. 

I have no experience programming AI. However, I can offer you my naive strategy that might help you brainstorm a little. I know you said you'd prefer experienced individuals for this question, but this is an intimidating question to say the least. Right then. What I would do is implement a per-turn checklist/surveillance. Each AI unit, every turn, would: 

I would use a circle for the body and a single rectangle for the beak, but that's just my opinion. Overcomplicating your collision geometry can slow down your app though, you're practically doubling (or more) the number of characters on-screen. 

Personally, I use a spin on the first option you listed. When checking if A collides with B, however, a series of disqualifiers (or a singular disqualifier) can be used to reduce the computation required for each iteration of your collision checker. For example: 

I'm working on the base engine of my game right now, specifically converting a text file into a level on-screen. As a 2D platformer, each level has an array of rectangles that can be drawn to the screen. Obviously I don't want to draw all these bad boys to the screen every frame, as that would slow everything down. I've thought up two solutions to this problem myself: