I'm presuming here the last line is the actual command you've been trying; if not use whatever that is. This file may already exist if it is user . If so just rename it to save a backup copy and create a new one. The file should be created by the user, or else the ownership changed to match. I think execute permissions are required on this, so then: 

You won't see a big difference either way; GUI applications are actually not CPU intensive. Or at least, the GUI part of them is not; they may or may not be doing other things that are. To qualify that a bit further, if the application involves image processing or rendering special types of graphical documents (, etc.) to the screen, that's sort of an aspect of the GUI and that could be processor intensive. But most GUI applications don't do this. In other words, if what you are doing is a standard control interface -- buttons, text entries, menus, scrolling lists, etc. etc. -- its GUI aspect does not require significant CPU resources and choosing swing over python here or vice versa will not make any difference to performance. However, memory is a concern on the pi and GUI applications can use a lot of that. You might want to consider what other things you are most likely to be using at the same time. If those are java based, then java is a better choice because it will be loaded already; likewise with python. Note python has a much smaller footprint to start with. Also, you are probably using a desktop with a lot of GTK in it, so anything which uses those libraries will save memory too. I believe java swing does not, it uses its own stuff. I am sure there is a python GTK lib, however (that will share memory with the native ones used by most applications) -- but Tk(inter) will be separate again (although relatively small I think). Python and Java both have raspberry pi specific libraries for GPIO control -- although you don't actually have to use these, since the native sysfs GPIO interface (i.e. ) is language agnostic and drop dead simple to begin with. 

You'll find some examples if you search online but it mostly appears to be some basic stuff, e.g., this is from here (which is 3+ years old): 

These are for SysV compatibility, which traditionally has been the most widespread init system used on GNU/Linux since its inception. I believe SysV scripts also have a degree of compatibility with BSD init, used on other contemporary POSIX operating systems. While none of that is actually part of the POSIX specification, some commonplace cross-platform software targeting a particular (linux, BSD) side of the family make use of it. Although systemd has been around for about half a dozen years, it is only in the past 1-2 that it has become the predominant one used in the GNU/Linux world, after Debian gave up on SysV with version 8 and Ubuntu abandoned Upstart. On Fedora, which started using systemd as the default 5 years ago, there is very little left in but it does remain, together with a which notes: 

I think "accounting" for them is simple enough, it is arbitrary latency. If the units there are seconds, then that is a cause for consternation. If they are centiseconds or smaller, that's the nature of the beast on a multi-tasking OS. You're not going to be able to guarantee yourself zero-latency, although you may in practice be able to achieve close enough to it. You've clarified they're microseconds, in which case I'd say you should probably count yourself lucky as is. 

Nope, it will run at 1+ Mbaud both ways (I've tried 2 but not enough to say how reliable it is). However, the default clock is 3 Mhz, which is probably not enough to drive anything much over ~190 Kbaud (assuming the transmission rate is 1/16 the clock). Try adding: 

Here's a pic of the connections. There are lots of explanations of button circuits around. These use external pull-ups. In case it isn't obvious the button contacts connect numbered rows when depressed, not the top half of the board to the bottom. 

Which will run your app as the pi user instead (who is also technically not logged in). Since technically no one is logged in, even if the kiosk user kills X (e.g. via ) they will just be left at a login prompt. The how-to goes beyond that such that the service init script starts X (see NOTE below) in the foreground so that when it exits, the service script continues and runs . Remember that someone who has physical access to a (normal) machine can always circumvent whatever security you implement, so all you are really trying to do here is not make it too easy and to prevent nasty accidents. Also remember that since your boot service will be doing this in the foreground, no other services will run after it, so make sure it is the absolute last one. Very important! You could, in fact, use instead, since that is normally guaranteed to be last ;) That will save you some time. NOTE: Actually in the how-to it's another script, , from this section. Notice that's just one line which references the script shown in the section above (3.4). Just put a line like that in your boot script directly. Your (preliminary) xinitrc, as already described, will be much simpler. 

You will give up when you realize it isn't going to work out how you thought, and either try to bend the ones's you've already bend back so they might be usable with a cable or just give up on that too. You will give up after you bust one of the pins off the board, have to resolder it on (if you are lucky), and realize what an incredibly bad idea this was. 

This depends somewhat on which DE you are using. Raspbian by default uses LXDE, so if you search online for "LXDE change background" you will find some suggestions, such as right-clicking on the desktop. Something which tends to work universally, in my experience, is: 

A bit bigger would be wise, but no smaller. However, this does not take into account the resistance of the buzzer itself, which may in fact be too much for this to work at all.