Your eth0 has and wlan0 . Neither of these agrees with which you have attempted to set as static. (I will add my usual comment - there are better ways than using static.) It is unclear what network you are trying to ping from, but presumably it is on a different subnet. The fact that you have an address on implies the link is getting an address from somewhere, either it is connected or you have assigned it. You have presumably misconfigured something, and supplied insufficient information for anyone to debug. The kludge suggested, which you seem to have accepted, is just that - a kludge. Some of the other suggestions are just ways of avoiding the real problem, and will likely cause problems in future. I suggest you actually solve your real problem, or just re-install the OS and start again. 

Like most such issues, the answer is simple - just restore from your backup. If you do not have a backup your only option is a new install. If you want to recover your data, do a new install on a new SD Card, then mount the old in a SD Card reader and copy your data. 

It is quite a while, but I remember reading the mechanical specs for various USB connectors. The micro-usb was 10,000 insertions, which is better than others. I don't think these applied to the sockets, which are presumed to last longer. Whatever the actual number, I don't think you are likely to reach the limit. 

Many years ago I wrote software (on CP/M) for HP Plotters, which have a simple command structure. This is ASCII over RS232. You should be able to dig up documentation on (Hewlett-Packard Graphics Language). 

Even the rpi-update documentation now warns "Even on Raspbian you should only use this with a good reason. This gets you the latest bleeding edge kernel/firmware." 

You should not be using assuming you are running a recent Raspbian which uses . will attempt to convert a well structured script to a service, so it should still work. An alternative for this case is to use . You add commands to by editing with . E.g. I have in mine to run a program at boot. There is a good tutorial at $URL$ NOTE The first thing you should do (with ANY method) is run the program manually to ensure it actually works and the correct syntax. 

Now, obviously, I don't need on the B+ but why is still on the Pi3, and is it needed? NOTE I have recently put a on, because it seems to want to download about 1GB and crashes my s. 

The steps below install , the official Raspbian desktop environment included with the full version of Raspbian. 

All versions of Raspbian support WiFi. You do need a Pi with WiFi hardware (Pi3 or Pi Zero W) or an external WiFi dongle. 

You can set up WiFi this way, if you know what you are doing, but what you have posted seems confused. If you have a B+ set it up on that, then just copy the files to the A+. Why not try the simple way. 3 solutions are suggested in the link. Using the GUI is the simplest. $URL$ 

Firstly you should NOT edit but make changes in . If you don't want to use the serial console you can remove it by either means. You don't say which model Pi you are using. The Pi3 uses for Bluetooth and swaps the miniUART to the serial pins. You can use on an older Pi or on Pi3. In the latest software there should be a which selects the appropriate device. There appears to be some problems on the Pi3 with varying baudrate. I modified the by adding the following line at the end:- 

You are barking up the wrong tree. IS - this is in accordance with python.org standards. If you want Python3 the correct command i2 . There is no such file/directory as , is the included version I don't know why you would install Python3.6; Debian includes Python3.5 so this would already be installed, and there is little difference - See $URL$ The other part of your question is unanswerable without detail of your script, BUT using is not the most reliable method. This is a hangover from and does its best to convert/run scripts. 

First, I have been running multiple Pi and NEVER "have to reboot the Raspberry Pi via unplugging and replugging"; indeed they run for months, even with upgrades. will show OS and will display the original image installed (mine is 2017-08-16) although this has been updated; will show kernel version. You haven't specified how you configured networking, so it is difficult to comment on that. Apparent unresponsiveness for and other protocols in NOT due to the Pi, but often due to normal network "sleep", and often due to the client. It is usually possible to "wake up" after a short delay, may help. On my Mac sessions often appear unresponsive after the Mac has been to sleep, but I can establish a new connection immediately on a new terminal, indicatinfg the Pi is still there. There are settings to enable keep alive (this is a normal Linux option) if this is a concern. 

You can use a hub which back powers the Pi via the USB port, or you could connect to the +5v and Gnd on the P1 connector or even to the P5 Secondary GPIO. All of these methods bypass the polyfuse, which may or may not be of concern. Of course, you could just find a case which fits. 

I don't know why you want a fan, let alone one controlled by the Pi. You have a 33kΩ in series with the base. This will give ~0.1mA base current. Assuming a gain of 100, this would give a collector current of 10mA, woefully inadequate for most fans. Use a more realistic value 330Ω would be more suitable. You are also in danger of damaging the transistor, by operating it in linear mode, although at 10mA this is unlikely. With ANY inductive load you should also be using a diode to protect the transistor from back-emf. 

Your question is lacking detail - specifically WHAT you are ACTUALLY typing. The error suggests you are using Python2.7 and have manually installed (which should be included in Raspbian), but AFAIK the examples are intended for Python3. The "examples" strike me as POOR Programming practice Even if you are running examples from or there is NO REASON NOT to include a shebang at the start of the program. 

If you boot with your which contains you effectively disable . This would prevent the from running, because this depends on . You are trying to run 2 incompatible services. It MAY be possible to write a script which shuts down all the services not needed and start others, but you are on your own. It is going to be easier to just reboot. 

There are many ways to do this. As @Fred indicated, is one possibility. You can also use to transfer files from the terminal prompt. ( has installed). You could install on the Pi which lets you use Finder to access the Pi. Connect with (or the address). 

You mention "the different amount of current from two sources". This is a misconception common on this site. Power sources SHOULD provide 5±0.25V and often list a current. This is the MAXIMUM current that can be safely drawn without causing the voltage to drop below its rated voltage. (Of course, very many supplies do not actually meet their published ratings. You are attempting to run the Pi on a computer USB port. These are rated at 500mA, and should only supply this if negotiated by the device, which the Pi cannot through the µUSB port (because it has no data connection). Again many computers just supply 5V, without any control, but it is inadvisable to rely on this. You are running an old model B Pi. These actually run on a few hundred mA (the 2-2.5A quoted by @goobering relates to the newer Pi 2 & 3, and even they do not actually NEED anywhere near this) This model can run from a USB port - just. Even so it is likely to be unreliable, especially if you are trying to power WiFi. These models have very low USB current capabilities (100mA for the release 2 of the Model B, lower for the earlier models). 

I don't know what version of you are using, but I used to use a key with a passphrase, which the Mac ignored (or defaulted from keychain) when connecting to the Pi, (probably incorrectly) but this no longer worked in recent . I created a new set of keys, without passphrase, which I use only on my local network. I use totally separate keys for called and external networks. Sharing keys is little different from using identical passwords for many logins. 

I have a reasonably standard Raspbian installation on my Pi3, and a version on a B+ where I removed with to save space on a 8GiB card. (I have rarely used Wolfram, and don't need it on an old system.) I was checking card usage shows 

The Pi has a unique Serial Number. This should uniquely identify each Pi. The Ethernet MAC is related to this, and similarly unique. Any other solution, such as creating files or hostname involves storing something on the SD Card, so at best this identifies the SD Card. This may be what you want if you want to tie user data to the ID. Edit Based on your comment there are still many answers, depending on what you want to achieve. 

This has done the exact opposite - it has enabled the i2c, which is disabled by default. PS The i2c pins have on-board pull-up resistors.