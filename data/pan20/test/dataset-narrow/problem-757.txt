Unused Variables As it appears, your is not being used anywhere other than at but the value is never used for anything. That's two pointless lines if this truly is the case. Comments Your comments aren't the most readable (this could just be me). Try adding a space and starting with a capital letter. 

Final words I noticed you have a for your grid. One thing you could do is make it a jagged array (i.e. an array of arrays) this way you can make each point at its coordinate position (i.e. Point[x][y]) for quick and simplistic access conceptually. That said you have a working solution so unless you're having trouble conceptually keeping track of your current solution I wouldn't change it. I hope that you find this helpful. 

OOP Object-Orientation when done right can help make your code quite a bit more readable and intuitive. This is effectively how I structured my code when I did the exercise myself. Main 

This system allows the user to define property mappings between two objects and a filter. Then the user may call to get an . Example Setup 

In addition to the already existing answers I thought it be wise to add some things they may indirectly affect your application's performance. What I mean is these suggestions don't necessarily help your performance but they can make it a lot easier to understand and debug your program a lot easier (both you and others). This can allow you to evaluate the performance much easier and faster. Naming doesn't quite tell me anything about what it's purpose is other than determining if the state is 'happy'. Something like or is much more clear in its purpose. Which you already have a variable for so why not use it and subtract the final day before you print (or even after the loop). Hungarian Notation is quite unnecessary additionally you're only using it for two variables. is just as clear in its use and purpose as (as the 's' implies a collection) your functions and classes shouldn't be so long that you need such a naming scheme. Intuitive Try to keep your code as intuitive as possible so that others (or you 6+ months later) can understand it quickly. These suggestions might just be me but I think at the least they can demonstrate what I mean. The goal is to compare the plant to the one at its left. So why not start at the second and go until you've reached the end? Here is some pseudo-code to demonstrate/explain what I mean about intuitive code: 

Different remarks: You are mixing Java 8 style and classic Java style better would be to use one style either Java 8 Streams or classic "procedural" style. If you decide to Java 8 Style the whole thing could have been written something like (also not perfect) 

You are not really waiting for all threads to fininsh. If one of your threads run in an timeout you simply ignore it. You can fix this by stetting a flag that signals your thread to terminate. I've done this by adding a class which and extend and which have a flag that signals them to terminate as soon as possible. Your contains only one value which is overwritten by the Producer Loop via the method, nothing prevents this. The calls are useless because nobody actually waits for the There are a lot of issues in your code so I've decided to rewrite it in a way that actually works. It uses a Queue to transport the elements from the to the The notifies any waiting Consumer via about new Elements. The uses an Index to determine whether he should pull elements from the queue and increments the after he has taken the 10 elements from the queue. In the I give you an example how the in Java can be used, and a possible way how to deal with s. 

First of all it would be good to use the standard Java Conventions, i.e. method names start with a lower case letter. i.e. shold either be or simply . Also handle InterruptedException correctly. For details have a look at the book Java Concurrency in Practice In your case it does not make sense to catch the you can simply declare it as thrown. The ArrayList for the threads is not necessary, you have a fix number of Threads, you can replace it by an Array. 

In addition to Malachi's suggestion, Equivalent Conditions: The condition is equivalent to which is shorter and technically more efficient (though I'm fairly certain the compiler would optimize this). Guard Statements: A common way I clean up my code is to use guard-statements instead of if/else. They're not always possible but something like this could reduce nesting. Just be aware this doesn't work in every case (as it may make some situations more confusing) but when it does work it can make code a lot less of an eye-sore. 

Most of these suggestions are style-based, but I think they can be helpful to you either way. Code Consistency Your if-statements have a mix of inconsistencies. 

From this line we quickly see "Downloaded Applications Remove all". So does this really add any value to your code? It seems like that comment just adds clutter. Clutter & Variables used only Once You want to reduce your for-loop there's a few things you can do aside from the typical suggestions you're going to find (i.e. Modularize into functions). One of them being reducing the number of declarations you have (if conditions allow). For example, both and are only used once. If you know you are only ever going to use them once in this scope/context just remove the declaration and use the value where needed. Another quick note, I noticed you're declaring , , and towards the top but not using them until the bottom half of the for-loop. Why not just declare them right before you use them? That way it's obvious where they are being used. RuntimeDetails A key place you can reduce the amount of code in your for-loop is your instance of . appears to be getting its data from 3 core places: , , and .