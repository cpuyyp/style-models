A wild suggestion, count the number of in your output and use that to determine when to exit the recursion! Also, I'll implement the in one block statement instead of three ternary statements, the main reason being that I don't have to append empty . This may be just me though. 

Formatting Another useful advice for beginners is to standardize on the code formatting style. Currently, your code is already lengthy enough without the extra empty lines, and your bracing () is quite inconsistent. There are different schools of thoughts about 'paragraphing' code into nice-looking blocks with empty lines as separators, and the one I think is arguably more practical is if you have to resort to this, the method is just too long (like your method now). Favor smaller 'bite-size' methods that more expressively captures a processing 'step', rather than creating monolithic ones that do everything. As for braces, it's recommended not to skim on them, especially for beginners. This is so as they eliminate any chance of bugs, while enhancing readability at the same time. For example: 

Still, I will advise against comparing the result of with these three specific values, as the Javadoc only mentions the result can either be a negative integer, or positive integer. If you are ok with re-writing your unit tests, then simply calling the 's will be simpler and better understood. Asserting on the lists then becomes: 

And then use to determine their absolute positioning within the . Obtaining the relative positioning as your challenge requires is to simply subtract one value from the other. Also, this can be done as a method, so you do not need to instantiate the class to use . It's nice to have a custom class, but you can probably just rely on good ol' here. 

The is not immediately obvious from the problem statement, because that's really just adding the next 5 hours (are paid...) to the initial 36 hours. You should avoid the hard-coding and instead rely more on declaring suitable constants so that it's easier to update these values in the future. You can also avoid unnecessary subtractions and additions above the base hours to for the following reaons: 

Alternatively, if reading inside a method is slightly confusing, have a new method to do that instead... 

on the selected item for clarity In your current code, you do a -loop and compare that the selected item is the same object by reference with a very large -scope (, which is usually not recommended unless you are really sure of your object referencing) before switching on your 'original' array. This sort-of makes sense still in your simpler code example, but it can get messy easily when you scale up for bigger projects as you will have a lot more references to use and keep track. It is therefore easier and clearer to perform the on the selected item directly, such that you can even remove the encompassing and conditions. For example, I can reduce this: 

These nine variables can be replaced by a 'compact' 3x3 array. The main benefit of an array is that it makes looping much easier: 

can be better represented as . IMHO it's easier to comprehend. Similarly, and can be replaced with and respectively. 

You don't need that. :) You may want to pay attention to commented code (delete them as early as possible?) and also to redundant empty lines. 

First, there's the class that facilitates this already, so if you're not reinventing-the-wheel, then you may like to consider using that class. Other pointers: 

Other comments If you are on Java 7 and above, you should use on your instance for proper handling of its underlying I/O-based resource. A non-zero value for usually indicates 'abnormal termination'. Second, you should favor relying on a terminal condition of your to know when the game has ended: 

edit: One clarification regarding my final point above: I'm quoting the Javadocs from the classes primarily because you are using a currently for your "persistence". Even if you are going to replace it with a database back-end and JDBC APIs that do not necessarily return datatypes, it's worthwhile to consider what is the most suitable return value you need from your own APIs. Perhaps you discover that most of your use cases are just to check again whether the input object for and are persisted or not, and therefore the original implementation will still make sense (you'll want to document it properly too). Looking at your new changes... 

Everything is a Welcome to Java and object-oriented programming! You are doing something really strange in Java in your method (which really should be called or ): 

I have no major concern with setting the values of via the constructor. What is your concern with this anyway? My minor concerns are: 

You should validate the input here, as the user can enter anything other than a number that can handle. For example, you should re-prompt the user if the input contains entirely of spaces, or if a negative number is entered. String concatenation 

Method name I agree with you, does sound a bit odd for lists of non-numbers... perhaps or are arguably better names? Lambdas 'Single-shot' lambda definitions does not require the use of : 

Since you are already operating on a character array, perhaps you can consider converting to lower case letter as the final branch, i.e. 

Since the body of this method will only throw (most of the called methods) or (), I will suggest throwing these two specific types rather than a generic . First, other reviewers or developers will understand the exact nature of the possible s that can be thrown from this method. Second, should further changes in this method yield more checked s, you will get a compilation error first as a heads-up. 

The first character (what case to use) This can be implemented as a , i.e. converting a (boxed from a , which is safe) to another . The conversion when encountering the next character past a separator There are two possible approaches here: 

Do you mean users when creating a new must append another inside this method body, instead of the implementation itself knowing how to update the ? Are you referring to are the number of implementations that the users choose to in the when you mentioned 'all processor types', or everything loaded by the classloader (which I infer from your reflection solution)? 

And, if one is being extra pedantic with the question's language, we can replace , technically an array, with multiple calls: 

The suggestion above opens the possibility of treating cases differently from the usual . You may want to just swap the indices, or optionally return when both are equal. Alternative You can consider iterating through a of the input as such: 

And then your does some checks here and there for the current value (see: ) in order to derive the correct conversion. Assuming your approach in is largely sound, what you should have implemented in each value is the method (without the first method parameter, naturally), so that they can tell the common method how to perform the character replacement when required. wrapper methods Your methods are just wrapper methods, which means you can do without them as well. If you're concerned with using as the class prefix everywhere, you can do a , replacing the asterisk with the three methods you need. Reinventing the wheel Come and think of it, Guava's would be an almost-identical fit for your usage if you'll rather not be reinventing-the-wheel. With a helpful dose of Apache common-lang's for the "Title Case" formatting, you should then be good to go... edit: Lambdas Your code effectively needs to handle two scenarios: 

In this case, I flipped the clauses around since the code for handling invalid JSON data is a little shorter. And finally for your method: 

If a is not found, you can use your debug statement, else you can have the returned each and the given . methods On a final note, you may even want to reconsider the design of your methods for sending JMS messages. Assuming the only differences between them is a queue name, you can have just one method that takes in the queue name as a method argument, so that you don't have to manage similar code across many classes. 

Handling logic While I think it's helpful that the other answers are pointing you towards an -driven approach, for a beginner, I feel starting with basic comparison is... ok. I wouldn't change much here, but I'll suggest renaming your variable in to something like to stick to the convention you have followed elsewhere. On a related note to the previous section, since you shouldn't be checking for the as an operator here, you can safely drop the check. 

Constants in test class While it's generally a good idea to create constants to aid reusability, I think it's a bit overdone in your unit test class. Do you really need to tell you that's a price of ? Handling double values for maps' keys 

Since the output for a wrong guess is largely similar, you can also consider experimenting with the ternary operator to determine the you want to display. The minor downside to this is that implicitly, you have a nested statement instead of the one flow now. 

Java 8 stream-based processing Assuming you are on Java 8 and eager to learn about its new stream-based processing, this is a good candidate for adopting this approach. :) For starters, you need to understand: 

concatenation should be used for most cases, as the readability is the easiest. Besides, the Java Language Specifications and 's Javadoc mention that plain concatenation may be converted at compile-time to use a too. 

Just mentioning this for the sake of mentioning (see final point below), but you can probably get away with just this: 

You can think of it that the calculation logic is not baked into the payment calculator, and that the logic can be maintained separately. For example, a more complex implementation might be retrieving prices from a database, and the calculator does not need to deal with any database connections know-how. 

This is not a very optimal way of checking if a user from the file is in your object. For starters, will generate the representation every time, and you may run into false positives. For example, if the representation of a contains a comma, which is the delimiter used by : 

Consider parameterized testing? JUnit Here is how you can use JUnit 4's runner with your test cases so that you can get a slightly nicer output in Eclipse. The gotcha is that you need to annotate your test class with using the runner, and it looks like you can only 'parameterize' for one class constructor. 

Then, will only have four such method calls, which can make its readability much better. As for the enum, you may want to consider using instead of to avoid the auto-boxing. 

Reading here is quite misleading as it sounds like you will loop when the processing inside the code block is correct. One suggestion is to invert the meaning so that it better reflects what is being done here: 

The good Let's start with something (unfortunately) short: Making a class is a good start. Interfaces over implementations It's highly recommended to declare variables or method return types based on interfaces over implementations, as users of the variables/methods should not need to know how the object works, but what they can use it for. Simplifying logic You can use to simplify the seemingly complex-looking chains inside to: 

Do you really need to invoke when updating effects? Since the maximum number of elements you can have in your is bounded by the number of values (BTW, you may want to switch to an ), I think the overhead of doing a concurrent access on your is not required. Also the operation can be done using a method reference as well, in this case: 

methods is an unconventional method name, for consistency you may want to call it as , with the inverse meaning of course (i.e. ). Maps of objects and their classes Conveniently, if this is your only use case so far, you can also consider using Guava's to have the same functionality. 

The tests for an empty map or keys are to make it a requirement that lookup maps shouldn't be empty by definition, and to follow the recommendation from Guava. Implicitly, duplicate keys will also throw an courtesy of . 

This looks slightly odd, especially when is just, in your words, 'a neat class to look good'. If all you are doing is to implement , you can do it in the underlying classes too. Extending a class only to implement methods is a poor demonstration of inheritance. Implementation vs interface All Almost all your classes are declared by their implementations () instead of their interfaces (). It is usually recommended to use interfaces so that users of those variables only need to know they are dealing with a . This allows for substitution too, e.g. during testing or to thread-safe implementations if required. In addition, since Java 7, you can rely on the generic type infererence to shorten the declaration as such: 

I think this might be better handled in the method then, so that the method body of the (renamed) gets the difference in s from , and calls if there are differences. There is thus no special handling 'dangling' in the method. Miscellaneous 

You should make too though, to clearly indicate that they cannot be modified after instantiation. One thing to note for is that it always returns a new array, so for that reason, sometimes it may be recommended to also construct a lookup to avoid the extra arrays creation. Also, is it really OK to just return if an invalid security classification is specified here? Depending on your implementation, you may want to consider whether you should an here to have a slightly better modelling of such cases. How is used? In fact, can it be used in for a case-insensitive comparison? Finally, may seem like a mouthful, you can consider a shorter name like . The other thing to consider is that you don't really need to express that it's an this method is returning. 

is safe for comparing values as they are guaranteed to match the same instance within the same class-loader. Boolean logic A lot of your code 

And calculating is just ; One more minor suggestion: The usage of and seems to be repeated quite often, maybe refer to them as and ? The main body will look something like: 

I think @SharonBenAsher's answer is a good starting point for your actual question. I'll instead focus on a few other areas. :) Declare to the appropriate types, preferring interfaces over implementations 

Call to get an of 'characters'. Filter only for letters using , and then for consistency as well, so you may want to do all the normalization here instead of your method. Convert the to a using , so that we can do a to get our 'letter map'. 

Java/Java 8 tips is an unused class, and even if it is in used, class naming convention recommends the singular form rather than the plural. This is because you will have a instance or many instances, but a instance doesn't sound as right. The only pluralized class names that I can recall off-hand are for utilities classes, i.e. those that only provide a bunch of methods. Since Java 7, the recommended approach for reading from a source is , e.g. 

In this approach, the second filtering condition checks if the of the 'requires map' contains the same entry that will be removed from the entry in . The first filtering condition is required to ensure at least one of the value is a , per your question. Still, this assumes that all the entries' values will strictly adhere to the general contract of , i.e. there is not going to be a case of (since ). You should also consider using a more appropriately-typed class instead of the checked . Over here, lambdas do no deal with checked exceptions, so I have used as an example. edit Since you want to also log all duplicate keys before running the value checks, you can insert a step in between your (now two) filter steps: