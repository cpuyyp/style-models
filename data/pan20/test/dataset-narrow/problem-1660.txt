I am trying to use a transistor to switch a button on a remote control, by bypassing the remote control button for the collector and emitter of the transistor. I am running a program on the pi to turn the button on and off every 0.5 secs, by turning on one of the GPIO pins every 0.5 secs. I know this program works, because if I connect the output pin to an LED it turns on and off spot on 0.5 secs. But when I put that same pin onto the base of my transistor, it seems like the 0/low that I give out of the pin doesn't seem to register, either that or there is some sort of delay in the transistor switching off. If I use the 0.5 sec for both on and off, the remote light just stays on permanently, until I kill the program (upon which after a few seconds the remote light flickers on/off about 6 or 7 times but much quicker than half a second. I have NO idea why this is happening!!) I'm thinking of possibly putting a pull down resistor to try and help the 0/low output from the pin hit the transistor a little quicker and hopefully switch it off more instantly. Does this sound right? Is there possibly something obvious I'm overlooking? I'm quite new to the electronics side of this. I'm using a 2N3904 transistor. I've tried putting a pull down resistor (made from the 3 resistors I have lying around, in series) but the values are only totalling about 250 ohms so it's not having the same effect as it would if I put, say, a 10K resistor in. I've also tried switching the raspberry pi's own pull down resistor to on, with no effect (though I don't really know how to test if that's working or not) 

We have a case of a program that runs without error on some cameras (such as mine), but gives an error specifically with Raspberry Pi Camera Module V2. We can track this down starting with the dmesg error: 

Thus, you should expect very different performance (and bugs) with the two drivers. DWC stands for (Synopsys) DesignWare Core, for which there are multiple versions of the hardware IP and software (e.g. ). While you could delve into the dwc driver kernel code to truly rootcause the behavior with your Arduino Clone, it sounds like you're okay falling back to Scenario 1? Assuming the WiFi is always available. Edit, re: 

I'm having a problem similar to this one Solving “RTNETLINK answers: File exists” when running ifup My setup is basically 2 separate networks one via Ethernet and one WiFi. I want to have a simpless plug-and-play connection, if Ethernet is connected use it, if not, fall back to WiFi. It worked nicely with DHCP setup on both networks, but now I'm forced to use static IP with Ethernet and DHCP with WiFi, and now have to reboot every time I plug Ethernet back into RPI... Here's my network config: auto lo iface lo inet loopback 

In the context of USB, master vs slave mode is also referred to as host vs device (or peripheral) mode. In the device tree overlay the OTG port is set to "otg" by default. You could change that to "host" or "peripheral" with an alternate overlay, but not without rebooting. For your intent, you probably want to stay in "otg" mode then enable or disable gadget drivers as needed. For example: 

This can actually happen over time with innocent runs of or installing various packages that conflict rather indirectly. When it tells you there's a dependency like that "is not going to be installed", try to install it alongside, i.e.: 

If it is a local media center that will not stream multiple HD streams at the same time from harddrive, any modern hard drive will have enough speed for media center applications, so if cost is your consideration, go with HDD. Morover, your data transfer rates will be more constrained by USB2 speeds, which are generally slower than HDD, so SSD or SSD won't matter unless you figure out direct SATA connection, like with X300 extension board, but with that board I'm not sure you'll be able to pull real SATA2 performance to benefit from SSD speeds. BUT there's one very good point for SSD, even at slower speeds, there's NO moving parts. RPI does not have any moving/rotating parts like fans, so if you want silent operation for your media center, go with SSD, you can't get quieter that that. Plus HDD have more power requirements, so you can say SSDs are greener to operate. 

The default port 4711 is 0x1267 in hex, which gets stored as 0x67, 0x12, 0x00, 0x00 in little endian. Search for 67120000 in hexedit, change all four instances to 68120000, and save the modified binary. Then when you run: 

To invert the mouse Y, find the part of the library where it normally sends the deltaY value and invert it! 

That failing, in general when getting sound to work on an unfamiliar single-board computer it's often the process of going down this list 

Note I suggested putting both lines at the very top even prior to to be on the safe side. If desired to make the code prettier: I'm not sure if the statement can be moved down lower just prior to , but you can try and find out. refers to the Linux Open Sound System (OSS) where sound is sent via I/O writes to . As there's no immediate desire to play sound we could have tested any setting other than . was just the most vanilla one that came to mind. In the future if you wish to support sound in your Pygames via PulseAudio or one of the other drivers--and via the headphone jack or any other hardware--this understanding of SDL could come in handy. 

I have followed a couple of posts on here to turn off power management, but every morning I wake up after rebooting my pi the night before, my wifi has stopped working. By stopped working I mean I can't ssh onto it, nmap no longer sees the ip on the network, and on the actual machine pinging or curl/wget don't work (I can't remember the error off the top of my head) Can anyone help with either a) the logs I should be checking INCLUDING what to grep for, in order to tell if the wifi is being powered down b) any outputs I can add to this that will help narrow down the issue Thanks UPDATE 2 : When I came to try my pi today, the USB bluetooth keyboard wasn't registering anything. As I have a usb wifi dongle is it possible the USB ports are failing/powering down? UPDATE 1 : So last night I removed all my networking stuff in etc/network/interfaces and moved it to etc/dhcpcd.conf and etc/wpa_supplicant/wpa_supplicant.conf After a couple of hours the wifi stopped again. Below is the output from syslog from when I turned on the pi, till this morning, grepped to wlan0. I rebooted it around 10pm, I think, to change the static IP to .8 instead of .12 . To me I can't see anything that would mean it was dropped. 

The question that comes to mind is: why not use VNC? Perhaps you have OpenGL ES rendering, or maybe there is a reason the player on Windows must be VLC. It would be good to clarify. 

I can attest that the basic setup works out of the box on my Pi 3 with Raspbian 9 Stretch. You can get something up and running quickly even if the engine stutters and it renders at about 10 fps. From there, you can dramatically improve the experience via OptiFine, overclocking, or other tips that you'll find in those threads and related videos. I'm sure the OP became well-aware of this along his neverending quest, but hopefully the answer helps others who stumble upon this question. 

Now what happens, at boot everything works in any configuration of Eth0/wlan0 availability. But if I unplug Ethernet cable, WiFi successfully kicks in, but when I plug Ethernet back I'm stuck with no connection, ifconfig reports eth0 as Up and running with static IP address, but it is not actually connecting to internet. If I forcefully do ifdown, it fails saying eth0 is not configured (which is weird as ifconfig reports it in "Up" state with assigned IP address) and ifup eth0 fails with the same “RTNETLINK answers: File exists” error... Anyone has any ideas how to fix that for the case when one network is static and one DHCP? Removing gateway entry does not work, as in such case static IP won't work... and I don't really have gateway entry for wlan as it uses dhcp... 

Perhaps the most straightforward approach is to update to Raspbian 9 Stretch. It's based on gcc/g++ 6.3. 

For streaming V4L2 over ethernet, I recommend webrtc-streamer. VLC doesn't support WebRTC, but could you use a browser instead? 

(as roughly instructed in the thread that @0pendev linked) To your original point of potentially reduced RAM usage: from what I can tell it consistently uses 50 MB more RAM than (250 MB vs 200 MB), whether opened to its default search page or raspberrypi.stackexchange.com. It does sometimes drop by 50 MB if I Alt+Tab away, but the same can be said for ESR (Firefox 52).