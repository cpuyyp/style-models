Have you studied parsing? LR(k), Chomsky Normal Form, pumping lemmings, … any of that sound familiar? Lexing only, not parsing — OK, so you just want to classify tokens. BTW, have you looked at Boost.Spirit.lex? That would make quick work of it, if you just wanted a lexer. If you are doing this as an experience in itself, carry on! 

OK, here is a tricky one! Do not treat this as a “sink” parameter! That is only for when you know a new object needs to be created (e.g. in constructors), not for when an existing object is reused. You are forcing a full copy of complete with a block of memory, and deleting the memory block that already held. Regular assignment would reuse this existing block of memory, if it fit. I’ve seen a presentation with benchmarks, but I don’t recall who gave it now. 

There are a lot of these. Notice how the thing you peek always matches the parameter to the return value? What is the even doing? You need a function that returns the peeked word. In fact, all of this reads one char, switches on it, then peeks on the rest of the word. Why does it need to do it in two parts like that? You are just classifying the “word” a PUNCTUATOR. Make a list (static array, as discussed with keywords) and treat it in the same way. Just as there are keywords spelled with letters, these are a list of legal words spelled with non-letter/non-digit characters. The trick is you have to take the longest sequence that is a valid token. But use a table, not dozens of duplicated snippets of code. 

You are storing pointers to local (stack based) objects, which is correct in this example because the vector is in that same scope. But usually you will never do that in real code. More realistic code would be to write 

since that is what the program is for, essentially, I don't see what's wrong with making that a virtual function. Note that you can define them in different CPP files so the header doesn't need to know about the details of processing. But this is just a toy example, and I know from my own work that we do indeed get different things we want to do and isolate the different systems from each other. So, as your original question indicated, you want to use the Visitor pattern. Let’s start with how you want to use it, then go back and make it work. As explained before, you define your "overloaded" function for each type you want to handle. The details of what you want to do go in the function bodies, not shown. Each body gets the parameter of the correct type. 

You are passing the same object as and . You are doing the same, I see, with and . I think you don’t understand how member functions work, which is a more serious problem. Anyway, ignoring from now on, This should not be a member at all, but part of the program that uses the class. It should use conditionals rather than repetitive code. E.g. 

1) Don’t write the same code 4 times. 2) Don’t keep repeating the x,y ± i (three times) in each block. Here’s my take on it: 

Problems I’ve looked over the code in more detail, and I see what is the central idea: Your receiver object is not necessarily controlled directly by a shared_ptr, but may be used in any manner, such as a subobject or local object. So, a proxy is created which points back to this object, which is itself controlled by a shared_ptr. The destructor of the object drops the reference on the proxy which renders subsequent events able to detect that it is no longer there. However, this will not work. Consider: Receiver Object destructor is called. It goes on its merry way tearing down the Object, all the while the EventReceivable’s shared_ptr is still unchanged, so events processed on other threads or recursively will hit Receiver Object while it is in a bad state. The inherited EventReceivable is destroyed last, and it drops the reference count. Meanwhile, suppose that an even is still being executed on another thread. It is holding the reference count, so the EventReceiver is still alive, still pointing to the now defunct ReceiverObject which has had its memory reused for something else. Another event being processed, perhaps on a third thread or as a nested event to handle, sees the Event Receiver is still alive and proceeds to use the bad pointer. The point is that you cannot use a proxy lifetime manager stand-in like this; you must reflect and affect the actual lifetime of the underlying object! 

What are you doing with a ? I don’t know if it’s correct of advised yet, having only read to this point. But assuming you do indeed want a pointer to a primitive string info owned elsewhere, use a (⧺SL.str.3)or . At this point, I wonder if the struct can be nested inside . No big deal if it’s easier to use this way, as it’s still inside . rule of 5 ? Now, you have a member, so I wonder how you copy, move, or delete the object? You did not define any special member functions. 

for a plain struct, this would just work as an aggregate initializer. You need a constructor that takes three arguments (with defaults) to provide the same functionality. 

The canonocal way to write operator+ is to call . You shouldn't need to make it a since the values need to be accessible by public means (otherwise what good is the vector to anyone)? And again, use , rather than writing loops. 

constructor: Same notes as before. Use inline initializers in the class definition, and don’t even write a constructor. And when you do need a constructor, know the difference between initialization and assignment. For the destructor, I wondered why you even needed one. In the body I see you are instrumenting it — that’s indeed a reason to need one. 

I assume this is to learn how arithmetic works inside a CPU’s ALU on the bit level. That is an interesting idea, and in real life I recall implementing multiply on an 8-bit CPU and coming to understand how it works when figuring that out. 

You should break up the monolithic into smaller functions. It is clear that first you read the input, then you do the actual work. Write the function that does the real work isolated from any real I/O. It takes parameters and returns values. You can call that from test cases that means you don’t have to type the input yourself every time! And you can have a function to read the input in the manner needed, for the final deliverable. Meanwhile, the functions you write to load arrays from a file like that can be reused for the next problem. You can be sure it has no code tangled up with the old program — it is just for getting input. Your code seems complex since GCD itself is just a few lines. Is that what is? The name is odd if it returns GCD, not the count of something. No, that’s just one step as there is no loop. Point is, I have no idea from the names and complete lack of comments just what this code does or how it works. 

The Enigma machine did not have separate encrypt/decrypt modes. So I don’t know what you are doing with . 

Note the use of non-member functions for size, begin, end — this is best practice and will make the code suitable for generic-izing. They must be unqualified so the is necessary. Sorry if that’s a bit advanced for you at the moment; just remember the rules for now. 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. 

That is a symbol reserved for use by the implementation. Writing your this in a way that mimics what you see in the compiler-supplied headers is exactly wrong! For this and other reasons I suggest leaving that out completely and just use #pragma once. If you ever find a platform were this pragma is not supported, a script can add the one-time-include symbols automatically and correctly. 

First, put this inline in the class definition. Second, use modern syntax: uniform initialization. More advanced: The strings are “sink” values, so the most efficient thing is to pass them by value and then move into place. So, you get: 

The next token starts just after the delim; we don’t want to look at that character again. But here we see a boundary condition. If was the end of the string, this is an error. In fact, it signals the end of the loop! No more work needs to be done. So now I can go back and change the to an indefinite loop and write the test here. 

Knowing I was going to loop over this and stop when I got a match, I did not want to worry about special cases inside that loop if it’s before the first element or still not found at the last element. So I put precondition checks explicitly into the function. 

Instead of naked , you will use . Rather than creating it and then assigning to the members in a separate step, make the initialize to the desired values. So it becomes: 

You are definitly missing on your member functions. Writing good relational operators is a whole lesson and not the point here — this is probably fine for the class as it stands, but reviewers will wonder why you didn’t make it a non-member and supply all the relational and equality operators. Since the (partial) ordering exists specifically for your algorithm, you might want to make it a named function instead. Consider the future maintainer that writes a test using and then has to figure out why it didn’t compile, and of course documenting that less means East and is not a complete ordering. 

Should that be ? I see it is used in one place, but I can’t tell if that modifies its value. If this is indeed constant, make it just to make sure it produces the table at compile time with no overhead.