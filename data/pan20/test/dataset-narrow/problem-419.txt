The advantage here is can be anything as long as it shares the same API. OK, so now let's talk about ensuring only one DB connection exists at any given time. Since the DI dependencies are just anonymous functions, you can just use the static keyword inside of the dependency definition; however, Pimple makes this even easier by providing a method that does this for you. As per the documentation: 

I think this is fine for something as simple as a volume control; however, there are some limitations to at least be aware of: 

Since this is all the code you posted, I'm going to assume you're only using these functions in the place they're defined, so the later code would be best. It's more readable and doesn't include unnecessary identifiers. Your question is really about anonymous functions, not closures. To answer this question, you should ask yourself, "do I plan on using these functions elsewhere"? Since anonymous functions, by definition, are not bound to an identifier, they will be inaccessible everywhere except where they are defined. This is the version that I would recommend: 

While this may seem "decently normalized", it's not. As you said yourself, there will be a lot of (redundant) NULL values, but also, relationships will not be enforced correctly, as this schema allows for duplicate records for any combination of Post/Group/Link and Tag. For instance, you could have two tagmap records with the same and . Now, while you could add a compound key consisting of PostID, GroupID, LinkID, and TagID, then you have another problem: a single record can contain more than one (non-tag) Post/Group/Link relation. e.g. a tagmap record with = 1, = 1, AND = 1. This can lead to update anomalies. See Second normal form. A normalized solution would be to have three separate tag-relation tables as abuzittin gillifirca suggested: , , and . Doing so will eliminate all the redundant NULL values and allow you to enforce relations correctly. Having said that, I'm guessing you came up with this design, because you want to use a single query to fetch all entities assigned to one or more tags. You can still do this with multiple tag-relation tables like so: 

Mixin type emitter (Well, not sure that implementation really looks readable - I hardly understand IL. But it works for method delegation :) 

I would not personally put LoggingService implementation inside factory, as it reduces testability and usually needed to play some tricks with generics type parameters only. To have a predictable behavior according to your design it might look like: 

How do you handle ? It is really useful in many TPL or business scenarios, but handling is a real pain. I defined the following three extensions to help myself a little bit. They can be used this way: 

Nothing really interesting so far - we just defined equality logic for configurations to help detect changes. Here are some fake implementations to make test work: 

What do you use for refactoring away from exceptions while programming functional in C#? I defined this class to hold function outcome: 

definitely looks having a lot of responsibilities. Have you ever consider implementing here? It is an inverted IEnumerable, "push" instead of "pull", so it works really well for event sources and they filtering/handling in a time sensitive manner. Reactive Extensions (Rx) for .NET provides you with some kind of LINQ for observable sources. There is a free downloadable book Intoduction to Rx - you will just need a part of it to grasp the idea. 

Updated Here is a little bit of cleanup. Now you can get back reference to before blocking starts: is a non blocking call. It also works with and in the view. 

Defines a merge of JObject field content to object, creating one if missing. As shown, there are the following permutations of mapping declarations: 

And all the API with multiple overloads will come as two sets of extension methods – I really like this trick :) 

I am not well versed in coding node.js as I'd like to be (I can read and debug, but learning to program in it is still ongoing) and I did not see anything that said I could not present an answer using a compatible language, so I converted your code into SmartBASIC. If you were expecting node.js code, I will understand. I needed a quick way to show you several areas where you can improve on your own program, and suggestions that will smarten your program's AI. For yes, SIRI seems to be human like, it is not perfect. And it is harder to have a computer write something in one of the arts, whether a poem, lyrics or even a short story. I did notice one slight error. In the statement below, you have a period instead of a comma, which will get you strange errors (had been.will be): 

I experimented with several ideas, and several show promise. I incorporated them in my SmartBASIC program, which I commented thoroughly. Your dictionary is limited, but I found out that this is not always a bad thing. I experimented with nouns, verbs, adjectives and articles where I created several hundred in each, and while it was still hit or miss, it was more miss than yours hit. Quantity does not always equate to quality. One of the problems I noticed is when you want to use a color. Rarely does a color stand alone, nor does it always work with every word. A "white beard" is fine, but what is a "white crash?" But a white crash can be poetic if the theme is right. That later. So with colors, I created in my table colors with modifier tags. These are color words with a tag at the end so the program knows that another word is needed after a color word is used. Here is a sample DATA statement that you should be able to convert to a "VAR[" Table: 

DDD How often have you heard from your domain expert manually managing room booking in his/her Excel all those terms like , , ? I bet that never. This stuff does not belong to the domain, does not solve any business problems, and probably should not exist. Having names like that clearly indicates the problem - those words are not in the Ubiquitous Language. Domain logic is way too corrupted with technicalities. Sure, no database related code should be allowed in domain. P.S. It depends on the task, but I could probably load all the data in memory and run here easily. Design What is the Software Design? All the things helping you to keep your project maintainable and that you cannot change latter easily. What helps keep project maintainable? Placing dependencies in a way where volatile components depend on a minimum amount of stable abstractions using Dependency Inversion where necessary. There are too many concrete tech elements in your code to follow “minimum amount of stable abstractions” criteria to keep things maintainable, so design misses its goal here. P.S. It is not a responsibility of the Controller to decide on room/combined room booking priorities – it belongs to the business logic – to the place where you actually implement the logic – repository in your case, as you do not need DDD here at all. I would have the following models in the Core project without dependencies on anything else: 

P.S. Generally speaking, it makes sense to do not hold an intermediate state of you calculations (like trimmed string values) – just an original data + define functions/properties to process them. It makes your design more flexible. P.P.S. It might be useful to have class: 

There are a lot of parameters I would like to configure for my object, so having some kind of composition helpers is a big thing to simplify proper use of it. Let’s say that we have only 3 parameters for the sake of clarity (there are a way more, but amount of code in C# is overwhelming): 

People do this sort of thing all the time in the JavaScript (this.arguments) and Python world (*args); however, by removing type constraints from the parameter list, you have to be wary that you're always providing the types of parameters your function is expecting. If one of your parameters is supposed to be a string, and someone passes in an object, bad things may happen. Conversely, some very respectable projects use multi-line parameter lists. It's fine to have a lot of parameters, as long as they're all necessary, but it's always good to be skeptical. Long parameter lists is a good code smell – if you see them, the code may need refactoring, but not always. As far as the attributes of Box's, forget about programming for a second. Conceptually, what are the properties of a box? Can a box still be a box without a color, tileW, tileH, walkable, speedY, and speedX? Can a box still be a box if it doesn't know how to draw itself? If your answer is no to all of these, then your code is fine, and requiring parameters as a single collection/object vs. individual parameters is (arguably) a matter of preference. That being said, I would move the three lines to a separate method . It's best to only do construction in the constructor, and leave the rest – like rendering – to other methods. 

This will make sure that sure only one $db is ever created. Here's the source code from Pimple's method for demonstration purposes: 

Definitely separate your PHP from HTML as Alex suggested. You probably don't need to go the full MVC route for something so simple, but simply generating your PHP variables then outputing your HTML would make your code a lot more readable/manageable. I like your idea of generating a random string and checking it, but Flambino's right, it will never be reliable (by design) - also, imgur probably hates you ;) A simpler approach would be to consume imgur's RSS feed: $URL$ I was bored one morning, so I added something similar to the login page of one of my projects. It pulls one random image from lolcats' RSS feed and inserts it into the page. Here's the code that pulls the image: 

What you want to look at are the words with an "" in front of or at the end. The "" is my token that color is involved, and a modifier is needed. If the "" is before the word, then I need to add a color before it. If the "" is after the word, then it is a color word and it needs a modifier. I also created a table of colors only for the times I need to add a color to the front of a word. The word can be a noun or a verb. "White lightning," depending on how it is used, can be a noun or a verb. If you said "White lighning struck a tree," it is a noun. "Dear ole Fred, lay dead, when met by white lightning" could be considered a verb/adverb use. The second thing is the "+" modifier. In the same DATA statement, the word "voice+" means it needs a modifier after it. I created a specific table for this type of modifier. You will see in my code that since I used a random generator to start either with an article or verb, every word is in or converted to lowercase. I had to create another modifier, "@" that is placed in front of proper nouns or words that must be capitalized, no matter where in the sentence they appear. @moon and @sun are two examples in my DATA statements. The third thing that shows promise is to create files that you can read into your VAR tables, but with a twist. I am currently creating theme-based poems. So I created files with words that are used in a particular theme. For example, "hope" is one of the themes I am developing, so I am using everything from other poets to a thesaurus to even the Bible to gather as many words, Articles, Nouns, Verbs, Adjectives, and Modifiers that fit the theme of "hope" along with some generic words that would work. This is where you asked if it would be better to have .CSV instead of tables. It will add flexibility to what your computer program writes about. You would have a VAR table with just themes, and .CSV file names for each theme that holds your vocabulary for that theme. You would first randomly pick a theme, load your tables, then can randomly pick your words. By moving your tables out to .CSV files, you allow for many different types of dictionaries. And you can even get as complex as having a main theme and a sub-theme and load the appropriate dictionaries. Another improvement I demonstrated in my code is that sentence structure does not always have to be article-noun-verb-adjective. It doesn't even have to always be subject-noun-verb or noun-verb-subject. Try starting one of your lines with a verb instead of an article. Then you can use verb-noun-subject or even article-verb-noun-adjective. For example, "Stepping on Mike's foot felt great" shows how a verb can start a sentence. I mentioned subject. For now, you can use nouns, but you may want to eventually create another table with just items that are considered "subjects." "Science" is a subject. "A Dear John letter" can be a subject rather than a noun. A "Divorce" can also be a subject. I tried to keep to the same logic you used, but I wrote as vanilla a BASIC program as I possibly could so those with other dialects need to change very little. Like statement separator (!) or some of the statements for lower and upper-case. With minimal changes, I had this working in techBASIC. But Javascript, being a C-based language, there are enough similarities to BASIC that you should have no problems adapting the routines in my code below into your program. Not a plug, but incase there are those who never heard of SmartBASIC, it is an app (less than $5 in iTunes) that runs a pretty robust BASIC dialect on iPad and iPhones, and comes with the ability to create Xcode apps for distribution on iTunes. You also do not need access to the internet to run and test your programs. This code works when run in SmartBASIC and is not broken code. Here is it with the changes I made (commented): 

After a cursory glance at the character codes for these, it looks like the lowercase is 32 (decimal) higher than uppercase. e.g. 'é'.ord - 32 == 'É'.ord You could try something like this: 

Ah, the age old pragmatism vs. purism. While it sounds like you have a healthy amount of skepticism, I think this is actually one of the few instances where it's OK to use a global variable. The core of your problem is you need to share data (state) between two routes. A global variable is the simplest way of doing this if all you're doing is appending the number 4 each time. Here's some things to consider: 

Likely, just has a single default state, but if you ever want to construct this object yourself, you should consider return-/exporting the definition from your module, rather than returning an instance of it. A simple solution here is to simply return the result of . Use a template. In the future, you can use additional templates to support other platforms. e.g. start with a desktop template, later on create a mobile template, and choose the template dynamically at runtime based on the environment. 

I ended up using the decorator pattern. The report view and each graph object now implement a method. When the report view's is called, it iterates over each graph, calling the graph's . The latter method receives the report view as a parameter, and this provides access to convenience methods for creating/retrieving DOM elements for the graph to attach itself to. New report view: 

Since RequireJS invokes the module, it would be problematic to construct dynamically. There's no good way of creating more than one instance of your view – probably not a problem. The View is tightly bound to a specific DOM structure. This means it will require extra code to make your View responsive. e.g. a small volume control for mouses (desktop) and a big one for fingers (mobile). 

Intensive use of mutable static state always fights back. I would split it to three projects: School.dll 

While implementing things like repositories we often can see that reading and writing parts can be done totally independently. The same time client side will win from the single reference (who wants to inject two parameters instead of one in many places). What do you think about a little bit of IL magic? Let's say we have: 

What do you think about names chosen for the following library code identifiers? Would you name them differently? 

I would define API a little bit different. Let’s go with couple types: SizeUnit and DataSize, so they can be used as: 

What do you think about the following syntax for some very simple and intensively reusable validations? Does this: 

This type of functionality does not require whole document to be loaded in to the memory. It might be easily done as a set of improvements over which provide better scaling possibilities: 

What do you think about this file system manipulation helper? There is an utility class Folder which I can use to define directory structure of my app: 

There are a lot of numerical properties to be invoked many times with an expensive calculation. Let’s say for the sake of example, they expose a Factorial: 

But it mixes multiple version translation in a single piece of code and will look ugly after introducing of more versions. What is the best way to deal with versioning generally speaking then? I would prefer a single sectioned query to deal with all versions in a unified way instead of running stored procedure with multiple queries if possible. P.S. I just think that is a must feature here... 

I would not put dependency on singleton in this class – it means two responsibility for - format properties and orchestrate AD API. Let’s define this helper class to be more explicit on your validation scenarios: