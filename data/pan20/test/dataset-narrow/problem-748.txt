It would be easier to figure out what's going on by separating those things out from each other. It might also make your life easier if you ever want to do anything more complex with this data than just dumping it to XML. So let's just do a little rewrite. To start with, let's create a class to hold each of those elements. (Honestly seems like a confusing name to me, it seems like maybe or might be more descriptive, but let's just stick with .) 

Making a copy of an object has a benefit: safety from unexpected changes. It also has costs: it takes up more memory, uses more CPU cache, and adds pressure to the garbage collector. Making copies that won't be modified is a waste - you're paying the cost with no benefit. So you should only make a copy if you know that you'll need it. The only code that knows for sure that the parameter will be modified is the code that's going to modify it. So whoever is going to modify that parameter should make the copy. Otherwise you risk screwing up shared state, or making a bunch of unnecessary copies. So: Option #1 if the child object is going to modify the parameter, Option #2 if the caller is going to modify the parameter. If neither is going to modify it, then don't make useless copies. 

The important thing you want to enforce is that only the same local user can see the hello world. You're relying at least on the inability of any random user to 

Make yourself a "template" that you immediately convert into html (using innerHtml or whatever your framework has handy), then use the dom to fix up the few variable bits. You may use ids to locate the tags that need substitution, if you can guarantee they are unique. Otherwise use XPath. 

I'll criticise the general design of the function. can't accept general input, because that would produce invalid xml. It special-cases empty contents, which prevents it from being generally useful; there is no way to use it to get an empty tag (breaking a weak requirement of good APIs: making simple things possible). It only makes sense as a private part of a slightly larger program that produces valid xml, which you did not include. 

All over : Nice readable code, as an outstander, who doesn't know the things the other classes need to do I still understand what this class has to do. 

Personally I wouldn't do this. The reason why is when your field change name, your test fails because the field is hardcoded there and with refactoring this isn't persisted to the test. What should I do? Normally your is in the same package as your . When this is correct you could use a protected method. Example : 

The intendation is correct but always use braces for if's. A lot of mistakes with if's comes from this. Example : 

Or something like that. Let the method return the actionlistener, but in the creation of your actionlistener use also at least 2-3 methods. Edit : Your problem : Use instead of with your eventlistener. looks for multiple button clicks, so it will merge some events. 

So now we have a nice, clean list of the data you need to output. Basically we've handled the first and second bullets from my list, so all that's left is turning that into XML. There's probably a cleaner way of doing this than using s directly, but let's just stick with it for the moment. But again, let's stick all the logic in a nice clean function. 

Before even addressing the actual question, have you actually proven that database queries are harming your responsiveness? Since the queries are to local storage it's possible that they are fast enough to not require using asynchrony, particularly if they are simple queries or the database is small. Next, I notice you've assumed that the database itself is not threadsafe, i.e. that you must only allow access from one thread at a time. Are you sure that's actually true? Many (most?) database handle concurrency themselves, so you may be adding an unnecessary layer of synchronization. I looked around a bit, but could not find anything specifically documenting concurrent access to isolated storage databases. I would start by researching that, or possibly asking a question on StackOverflow. If the database does allow concurrent access then you just need to worry about update conflicts, which you could hopefully avoid in a single-user phone application. What I'm getting at here is that multi-threading and locking is hard. Don't do it unless you're sure you have a good reason to do it. If you really must to multi-threading, then the C# keyword is a good place to start. Unfortunately, your example probably will not work properly because each instance will have it's own lock object - so if you create more than one instance they could conflict with each other. You "Current Variant" actually gets this more right, because your is a static variable, so there is only a single instance of it across the system. However, as I understand it lets you use Linq statements against the database, which will not know anything about your lock and hence will not be synchronized. I think you'd have to create a separate application layer to wrap the and expose just the certain operations that your application needs. This is generally called the "Repository Pattern". Inside the repository you could create a single lock object, wrap a around all accesses to a , and use inside each of the repository methods to make them asynchronous. 

if - else if - else if ... When you see this, it's time to consider switch statements. I hope the is an enum, so you can refactor this to a switch. If it is a String, you need java 7 or higher to do switch on Strings. Code can be as followed : 

It's hard to say but if I get this with an interview, you will not pass. On the other hand, I'll find it good you come to here to learn. Number 1 is really red flags. Let's start with the review. 1. No with logic. I removed the comment lines to point it out. 

Default values This is a part I have to say. It's educated to me so I educate further but I'm not a fan of it. 

Pretty straightforward here. We could've written this more succinctly, probably even in a (really big) one liner, but this strikes a reasonable balance with clarity, I think. So, now we just have to put those two together... 

Admittedly it's a lot of lines, but they're very easy to understand. Also, the test method itself becomes dead simple. Since I'm on the topic of tooling, you might want to look into the TestDriven.NET Visual Studio plugin, which provides very nice "right-click -> run test" integration. 

Try running this with Explain Plan turned on. That should tell you what part of the query is taking the longest. Run and then your query. That will give you an idea if the I/O usage is high. If the above don't suggest improvement, check the overall DB for problems. Glenn Berry's SQL diagnostics queries are a good place to start. If you still can't figure it out, hire someone like Glenn to help you. Or start reading a lot of books on SQL Server optimization. 

I assume you are aware of Chrome Canary, which I gather is able to use binary deltas? I don't think it's pure Chromium though. Your code is pretty clean. You could be using argparse for parsing the command line, currently you are ignoring flags that don't match. You could wrap the exit call around main, like this: , and use / statements instead. You could replace with , or pick up some defaults from the registry, but that's not necessary unless you plan for a larger audience. You could also reduce the window Chromium is unavailable by unzipping somewhere else, then moving the directories, then clearing the previous one (but I don't think you can make it atomic without something like symlinks or hardlinks). 

We all know what you are trying to do. But what happens if is magically turned 10? You have a bug that will not correct by himself. Let's say we do the following : 

The next class is the calculations itself. Because the UC is so little it stands open for interpretation like what do I have to do with all negatifs? In mine solution, an array of all negatifs shall work and spit out an array with 1 number. There is also no details to do when more subArrays are found with the same highest sum so I just return 1 of them. 

This field could be because you set it in the constructor and there is no setter for setting this at a later point. LogFileFunctions.java Javadoc preffered