I find this very difficult to read without any logical line breaks or function types given. I.e., you should leave a blank line between definitions for different functions, and every top-level definition should be given a type signature. 

and depend on , let's start with the latter. doesn't mean much as a prefix to me, so I'm going to call this function , but that's a stylistic preference. Changing this function to use is straightforward. 

I wouldn't use that version, I think it's a little opaque with all of that inlined math. But I would definitely use this one. 

This is probably as far as I would take it having started out at your original version. There aren't any real further improvements that I can see, just matters of personal style. If I were to write this from scratch though I'd probably produce something that looked more like this. 

This also pushes the site of compiler errors from where you're calling the function to the body of the function you're calling if you forget to change all of your imports or implementations. It also makes it immediately clear whether a function is working on an individual row or the whole puzzle or what. 

As you can see, each rows start with the value and end with the value, which means it starts with columns and ends with column , and the maximum value is , which means it ends with row . Now I want to make it so the even rows are in one dimension, and the odd rows are in another. I can do that with . It can take some trial-and-error to get the reshape to work the way you want. I don't actually have a good conceptual way to do this, I just create a dummy example like this and try different things until I get the layout I want. In this case, we want to set the last dimension to have a shape of , the first to have the same shape as currently (), and we can let figure out the second dimension (although we know it should be ). 

Taking a look at the course materials, I think you've missed the point. Applicative.hs has you define before , and looking briefly through the suggested progression it appears as though things are ordered such that there is always a “clever” answer to be built out of the things you've previously implemented. That said, this question then gets both easier and harder. Easier because there is purpose built machinery to manipulate e.g. that weird non-Prelude type. Harder because this isn't really standard Haskell anymore since all of our usual functions and typeclasses have been replaced by their evil twins. I think the intended answer is that you map the predicate function over the list you're given, then use the function you defined earlier to switch to , then... I dunno. This is mirror world. Here's how you'd write this function given the types from regular old . 

Appendix † An inefficient but important implementation. Note that performance is O(n²) (consider e.g., ). 

For your class, the indexer probably should be read only. The and methods have checks. But this line: 

Heslacher's answer had a closing remark about not using in my method. I got a basic implementation working and performance went from 5 seconds down to 0.7. Great suggestion. I then tried to add the new code to Heslacher's answer but an unnamed editor (okay, I'll name the editor: Heslacher) said I should post it as my own answer. Basic Implemention: Requires: 

This answer would work across midnight across different dates and for DST transitions. Plus it shortens up the code. Shorter and simpler is easier to follow and maintain. 

How many points are we talking about that makes performance slow? If its a crazy amount, you could use a Range Partitioner and a Parallel.For. But I would suggest outputting as a rather than an array so that each parallel thread can merge the subset of points. I'd rather not get into details about in this answer though. One alternative is to check X or Y against the tolerance once: 

If you have learned and expressions, you can implement the operation by reducing on the minimum of two elements (if you are using python 3, you need ). This is basically the same as Danny's approach. 

Edit: OP asked my to explain how the slicing is working. I think the easiest way to explain is to walk through a toy example. Lets start with a 2D array. That I think makes it easy to follow what is going on: 

If you can use the built-in module, then is probably the easiest, but it probably not allowed. creates an iterable of the cartesion product of two sequences. Since you want it with both the element first and the element first, you need to do it twice: 

Since you are already using numpy, you can use numpy's function to read in all the data at once as numpy arrays from the start. This allows you to avoid having to worry about opening or closing files (this is done automatically), converting to numpy arrays, etc. Then it is a simple matter of converting the indexes to values. You can also vectorize the test data creation, using numpy's function to get a grid of corresponding X and Y coordinates. You can make the plotting better, in my opinion at least, by using to get a figure and axes object right at the beginning, then using those to do the plotting. So here is how I would do it: 

There are a couple of advantages doing it this way. For one, I have a timing mechanism in place. And two, whatever is particular about problem 7 is isolated into its own class. I don't just have a single method. I have 2 examples: and . Let's look at my class: 

The thing that screams "BEGINNER!" is the fact that you've placed everything in the Program class. Igor's opening remark touches upon this, but he doesn't do anything beyond giving it a mention. My remarks below may be used in conjunction with all the other answers. As written, your code is extremely rigid. What if you ever need a different height or width? Or node probability or interval fraction? Those 4 properties seem to define a very specific grid. This is achieved by creating a class with an appropriate name, perhaps Grid or GridMap or something else as long as it is a meaningful, clear name. You have 4 main properties (previously mentioned) that help describe the uniqueness of one grid over another. At a minimum, you would have a class defined as something like: 

I see two major way to simplify and speed this up. First, rather than copying to at every step of the loop, you can define to include from the beginning. Second, you can find all the nonzero, non-NaN values in a vectorized manner at the very beginning This reduces the time for me be about 1/2 for a large (~10000 row) random data set. 

A few things for the function: First, your code won't work when an item is an iterator and , since it will consume the first sub-item in the iterator, making the next loop skip the first item. A better approach would be to run the test, then check if has been defined. If it hasn't, then you can yield the item. I personally use a short-circuit to avoid nesting too deeply, but this again is personal preference. Second, you really shouldn't use here, you can just use an test to short-circuit. Third, this may be a personal thing, but I don't like explicitly testing if something is a . For example, if you don't want to flatten a , you probably don't want to flatten a , either. I prefer to duck-type for a -like object using , which tests for the method. This should really only be present on -like objects, although I admit it isn't perfect. Fourth, some of your other functions would be easier if you include an option to split strings. Fifth, just because an item has the method does not mean it is iterable. It may have something in the method that raises some except. So it is better to test if it raises an except if you try to make it iterable. For the function: I don't see the point of here. How would adding an empty iterable to anything do anything? Second, I would really put the string-handling function as an option. So perhaps if , then you can raise an error since the items cannot be combined. And I would use a more descriptive name ( is common). Third, again this won't work if any items are iterators, since it runs through them twice. There is no way around this other than to convert the items to a list or something like that. Fourth, I think a generator expression is easier to understand than a map. For : If you include the option I mentioned above to flatten strings, this becomes much simpler. You just pass that argument along to the function. So here are the resulting functions 

Short of following Heslacher's advice on a Timer, see RobH's comment regarding crossing dates. Then extend that thinking to any daylight saving transitions. You might say you are never going to run the app during the middle of the night, but in the future this app could be a service or a scheduled task that does run near midnight or 2 AM. For internal timings, one should always prefer over for 2 reasons: (1) its faster and (2) its not error prone to DST transitions. You may think in terms of just time for your XML, but you would be safer and using better practices if you passed an ISO 8601 compliant string. This is easy to do with .NET by using the Round-trip "O" Format Specifier. Strongly recommend you carefully read the link on Round-trip. This simplifies your coding while making the app less error prone. Assuming the variable is a time string as read from the XML, you no longer have to take a lot of steps to parse out pieces of it. Your XML would look like: 

You exclude words less than 5 characters when reading your vocabulary. I think it would be better to exclude them when creating the vocabulary, which reduces the number of elements in your vocabulary and avoids you needlessly looping over words that are too short. Considering there are only 26 letters, it may be more efficient to have a single dictionary with two character keys rather than nested dictionaries. This would reduce the number of dictionary lookups. You would need to time it to see if it helps or hurts, but one possible initial check would be to create a of each word in your dictionary, and a of at the beginning, and then use the subtraction operator to make sure all the letters in each word are present in the pattern. If not, you can skip doing a linear search on that word. But the act of creating each at the beginning may offset the benefit of the check. Sorting will hurt your performance. 

I see 2 little issues with method. First, you check for an invalid negative value but I think that a 0 value is equally invalid. So I would suggest this change: 

Since that AtBash Cipher is a simple reverse, you don't need both and . There is no reason for to be at the class level; it should instead be locally defined in both and . You may even consider doing away with having a class instance and instead make the class and its methods static. If you keep as a class instance, could be simplified to simply returning !!! You should be sure to set the input string to lower case in case someone enters "Hello". Something like: 

The comment clearly says the and must be the same day and merely checking does not help much. It could be today (Thursday) and Thursday a week ago. I think you would need to check 2 things: 1) and have the same , and 2) and have the same .