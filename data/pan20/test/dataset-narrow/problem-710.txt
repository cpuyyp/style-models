I would add rvalue reference support with moving of temporaries. seems to be too low precidence to be practical - you end up having to everything (as demonstrated above). % at least binds tightly. I do like . Better than my . Forwarding from the operator to the function lets you forget the function behind the operator entirely: -- very Haskell. N ary infix operators that defer application of allow to run as efficiently as possible. But doing that cleanly might be hard. Not sure what is intended to do above. For an interesting test case, implement (where that lambda is a placeholder for a functor) Block some copy and move ctors to prevent persistance, and friend the approriate operators. As noted, I allowed arbitrary binary operators (chosen when you ) to bracket the named operator: the precidence of the resulting named operator exactly matches the bracketing operators. So has precidence of and has precidence of . Of the 3 first use cases (lin alg, container append, then) for two of them the named operators where variants of existing operators, and matching their precidence seemed useful. 

but the as you can see, this gets rid of lots of brevity. On the other hand, this continues to be data-driven: having uniform code behavior, controlled by data, is often a boon to debugging. You can validate data easier than you can validate code! Less effort was put into optimizing the C++03 version than the C++11 version, but the hit may be minimal. 

I would get rid of the if-else statement in operator() of Rule, and replace it with a stored functor, or move the from operator() of Rule into StartsWith and make all of your checkers have the same signature. Suppose we go with moving into StartsWith. Then stores a , which you produce once at construction (possibly through a big if-else block, but you only run that block once). Then operator() on just calls that check on the input parameter. If I was to go further, I'd work on rule-factories. A rule-factory is a function that takes a MyVariant and produces a . Then register a rule factory for each enum entry. And now your class itself goes away -- a is just any that takes a and returns true or false. The end syntax looks like: 

now, the above doesn't have diagnostics in it. But I hope you get the idea -- don't use a class when a function will do. I might make a a pair of tests and error message s even, with the error message optional. This would give you diagnostics as well. Or the return value could be a pair of , where a true bool means "passed with a possible warning", and false means "failed with a descriptive error". But you might not want to go this far. :) ... If you lack C++11, this is a patch on the above: 

There are many problems with your code, as others have indicated. However, my guess is that you used features which the person reviewing your code was not familiar with. Quite often the person who determines if you are hired is not an active developer, but a development manager who used to be an active developer. They are less likely to keep up to speed with the latest features of the language. Showing you are using them to solve a problem will make your code look worse to this ex-developer; they will probably feel ego-challenged (I don't understand this, I am smart, thus this is bad code) by not understanding what your code does or how it solves a problem. In this case they are right; the code demonstrated is showing off your knowledge of Java features (which could be quite useful in more complex problems) which are not appropriate for this simple task. The parts that are not showing off are not well done; copy-pasta, hard coded constants, brittle tests, undiciplined library use, etc. (Other answers cover this better than I) Finally, apparently your code fails to compile in some "modern" compilers; that could have eliminated you before they even looked at your code! So if someone doesn't understand those features, the code looks like noise and is ego-bruising. If someone does, they'll say "ok", then look at the rest. More likely, they where looking for someone with the minimium competence that would solve their problem: if they are hiring someone to write Java to move controls around in a UI, they don't want someone who likes playing with Java8. Or they found a candiate already. Or they changed their mind about hiring because they got distracted. Or you where judged acceptable at Java, but you didn't list SQL on your resume, and there was another candidate who did and was also marked as acceptable in Java, and the HR noticed that SQL was required and elminated your resume from the pool. Or the application process was a fake, and they where just gathering FizzBuzz implementations to feed to a FizzBuzz plagarism detector. Or they where gathering FizzBuzz implementations that could avoid Fizzbuzz plagarism detectors to game some other application process. Or they are someone who gathers resumes and code in order to have a stable of people, then they find contracts and try to become middlemen; if they don't get the contracts, they discard the applicants and repeat. Quite often things happen that have nothing to do with your performance, and feedback is not provided that it was nothing to do with you. Or, it is something to do with you, and they lie and say it wasn't. In the future, the thing to keep in mind with FizzBuzz style tests is that they are looking to check if you can program at all. They aren't asking you to show off. The goal of the test is "can you write a simple solution to a simple problem", and to filter out people who cannot program at all. Make your code simple, non-challenging. Try to follow "best practices" in the most conservative way. 

The way you do it - you are reimplementing division and remainder from scratch with a loop. This is, well, useless. The way you're doing it right now is OK if you can't use the above (course restrictions?), which would have helped a lot in this case - you could have used it to get rid of the loop altogether, just looping over the allowed prices. What can be done for your code is moving out the part which reimplements division and remainder into functions and using them, but then there remains no difference between the way I do it and the way I suggest for you to do it here. (Note that the extraction into functions is necessary for reducing code duplication and extending your code to support more prices). Here is my take: 

Initialise a array of length equal to the number of required entries per line to all empty s. Copy in the array of the entries of the line just read into the array of empty s defined above, starting at the first index of each array, until the array of entries has been exhausted. Et voila! Entry padding for (somewhat) free! 

You have an unrolled loop, which is good for performance (especially because in Java the size of an is fixed to be 32 bits). However, you could consider turning it into a loop if this performance is not required, that would reduce code duplication. Which means that you could also try: 

Simple, succinct, and to the point. I'm absolutely sure your code is overcomplicated for its intended purpose, and functional programming is not just about pattern matching and recursion, it's about being able to create greater functionality from pre-existing functions. 

Looks \$O(N)\$ to me, making your total time complexity \$O(Nm)\$ worst case. The other guy has 2 separate loops, one \$O(m)\$ the next \$O(n)\$, for a total time complexity of \$O(m+n)\$ or \$O(max(n,m))\$. Take home message: Ditch the \$O(N)\$ array initializer, it's not worth it. Use 2 separate passes, like the other guy did. 

You'd retrieve the result with a dictionary lookup similar to . You'd simply do preceded by , where is the name of your dictionary variable. 

This version of rotates the passed array in-place, so you can just print out the elements in a loop later. For printing, hoping you are on JDK 5 or greater, use the for-each loop: 

The relevant JavaDocs are here: a. Files b. FileSystems c. FileSystem d. StandardCharsets e. Paths in If you aren't using Java 7 and above, the recommendation is to put all calls inside the statement after all the es (the "Ye Olde" way). For this, your IO streams should be declared outside the try-catch-finally block. It could look like this: 

For , an algorithm is to do it the normal, C (pointer-based way). Traverse the list maintaining references to 2 elements, the current element and it's previous element. At the element to be removed, set the field of the previous reference to refer to the element following the current element. This would work far better with loops than and . Again, imperative and functional don't really mix well in the same part of the program. Take a look here for a reasonable functional singly linked list in Scala. 

I left in the debugging print statements as I feel that they make for reasonable documentation. Side note: Please use functions and proper variable names, like the ones I introduced. Note: This has not been tested with the UVA Online Judge, only on my PC. PowerShell screenshot of timed run: 

Make your function parameter . Although C++ is call-by-value, making it explicitly and mutating a local copy of the variable is never a bad idea, and it does make your function contract that much clearer. On the performance side, since on any reasonable computer will have maximally 16 bytes (64 bits of 8 bytes is the case for all common architectures, except for probably some microcontrollers which will have less, even as less as 1 byte) (note that the upcoming RISCV architecture does have a native 16-byte (128-bit) integral data type, but the 64-bit one is the default), you can easily make this function a template, such that the computation of the byte vector can be done at compile time without much overhead and incur no runtime overhead. You can probably even pre-set the capacity of your utilising . Although I'm not sure if this suggestion will work in the constraints of your application. 

Here are a few suggestions to start off: Understanding the Base Number conversions The base number system should be irrelevant by the time you have a number as a primitive type. It only matters when you're converting strings to numbers and vice versa. JavaScript can't tell the difference between and ; in both cases the underlying number is the binary ... the other formats are just to make it human-readable. So is functionally equivalent to ... in both cases, you're saying here's the number 30 (or if you like), please give it to me in decimal format; thus the output is always the number . The same is true when you reverse it with : both and will evaluate to . The question to ask yourself is: "Under what circumstances would an octal primitive be passed to my function?" Since JavaScript itself doesn't distinguish between octal, decimal, and binary numbers when it handles them in code, the question doesn't make sense except insofar as someone's JavaScript code could explicitly pass as a parameter. In such a case, the error would not be in your function but in the logic of the author who types and expects it to be parsed as a decimal instead of the octal number that it is. Determining the Class of an Object It's tempting to use to determine the type underlying a variable (that's what you'd expect the operator to do, after all), but its output is not always consistent. For example, will return when the underlying class is actually . On top of this, the return values of the operation are not defined in the ECMAScript specification, and could thus be different in different JavaScript implementations. Yikes! The only thing for which you should use is checking for an undefined variable, using the syntax Instead of using to determine the class of an object use . Here's the syntax for that: where is your variable. The reason we call at the end is because the function call would otherwise return when all we care about is . Semicolon Best Practices While JavaScript requires semicolons, the JavaScript parser is pretty forgiving about them: if semicolons are missing, it'll try to extrapolate the correct semicolon placement and insert them as needed. However, it's a best practice to explicitly identify the ends of lines. This not only saves the parser some work, but prevents it from making mistakes that can change the behavior of your code. Since you already have your code in jsfiddle, go ahead and click the "JSHint" button in the nav bar. It will identify lines where you excluded semicolons (such as at the end of a variable assignment) or added unnecessary ones (such as at the end of a function declaration). 

I'm working on a page that shows groups of users. The following JavaScript function is used to show more details about a user (such as email and login) when you click on their name. But there's a twist: clicking on one of those pieces of information will highlight it to make it easier to copy. This is accomplished by adding an in-line onclick function to each span element containing the user info. 

Avoiding polluting the global namespace As pointed out in a comment, you can wrap the code in an immediately executing function expression (IIFE) to avoid polluting the global namespace. Variables declared within the scope of a function expression can only be accessed from within the expression and from functions that are also defined within the expression. 

Instead of requerying for that item and checking its values to set the Boolean flags, we can just set those flags earlier in the code, when we're first accessing the values of the list item (using the variable).