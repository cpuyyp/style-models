It is a common belief that $\mathbf{P}\subsetneq\mathbf{PSPACE}$, thus (most likely) there are problems that are "harder" for time than for space. But is there a problem in $\mathbf{P}$ with a poly-space lower bound (say for multi tape TM), i.e. is there a space-hard problem in $\mathbf{P}$? Similarly, is there a problem in $\mathbf{P}$ with a good non-deterministic time lower bound? Is there a problem in $\mathbf{NP}$ with poly-space lower bound? ... 

For the claim (in bold) about $C_3'$, it is enough to prove that a one-tape Turing machine $M$ with 3 states that always halts either accepts or rejects all strings from $\{1^n;n\in\mathbb{N}\backslash\{0\}\}$. Suppose that a string of the form $1^n$, $n\in\mathbb{N}\backslash\{0\}$, is given to $M$. There are three cases: 1) When $M$ reads 1, it accepts or rejects. 2) When $M$ reads 1, it moves the head to the left. If we want $M$ to halt on this input, it must accept, reject or move to the right on the blank symbol. Hence, it never visits the cell to the right of the initial cell of the tape. If it would, it would run forever on input 1. 3) When $M$ reads 1, it moves the head to the right. It follows that after $n$ steps, the content of the tape is $A^n$ where $A$ is some symbol from the tape alphabet and the head of $M$ is on the leftmost blank symbol to the right of the last $A$. If we want $M$ to halt on this input, it must accept, reject or move to the left on the blank symbol. As in case 2), the head of $M$ will now never visit the cell directly to the left of the rightmost $A$. If it would, then $M$ would run forever on input 1. It is clear that in all three cases $M$ accepts all strings from the set $\{1^n;n\in\mathbb{N}\backslash\{0\}\}$ or it rejects them all. 

Suppose I have regular languages $B \subseteq A$, with corresponding (known) minimal deterministic finite automata $M_A, M_B$. I would like to find another regular language $C$ such that $B = A \cap C$ that minimizes the size of $M_C$ (the minimal DFA corresponding to $C$). In general $M_C$ can be much smaller than $M_B$. e.g. if we let $B$ the set of strings in $A$ that have even length, $M_C$ can be a two-state machine, while $M_B$ may be about as complex (or more) as $M_A$. This feels like it should be an easy application of existing automaton minimization algorithms, but I'm not seeing it if so. What looked liked the obvious thing to try to do is to to try and distinguish strings using an analogue of the Myhill-Nerode theorem, with the distinguishing relationship being that $x, y$ are distinct if there is some $s$ such that $xs, ys \in A$ but $xs \in B \neq ys \in B$, but the problem is that the corresponding indistinguishability relation is no longer transitive (I think) - Given $a$ indistinguishable from $b$ indistinguishable from $c$, there might be $s$ such that $as, cs \in A$ with $as \in B \neq cs \in B$, but $bs \not\in A$, so $s$ cannot be used to distinguish $a$ from $c$. I think this arises from some genuine ambiguity in the problem - unlike normal DFA minimization, there's no reason to expect $M_C$ to be unique - two non-equivalent machines could represent languages $C \neq C'$ such that $A \cap C = A \cap C'$. It might be that those ambiguities don't matter and you can just resolve them arbitrarily, but I haven't been able to convince myself of that. The problem is at least "reasonably tractable", as the corresponding decision problem is in NP, because such an automaton has size at most $|M_B|$, and we can determine whether a given automaton is a solution by testing its equivalence with the intersection automaton with states $M_A \times M_B$, and testing equivalence is in $P$. There's almost certainly some nice transformation into SAT or ILP that I haven't worked through yet because I'm hoping for a better solution. Is this some well studied problem? Or can it be reduced to one? 

In this answer it is assumed that Turing machines have both-way infinite tapes. The claims do not hold for one-way infinite tapes. Let me first define the class of languages $C_3'$ as the class of all languages decidable by one-tape Turing machines with 3 states ($C_3$ was defined as the class of languages recognizable by one-tape Turing machines with 3 states). I introduced the class $C_3'$ because in my original answer, I unconsciously swaped the classes $C_3$ and $C_3'$ (I only considered the class $C_3'$). This answer is more a complement to @MarzioDeBiasi answers. He showed that the classes $C_3$ and $C_3'$ are not contained in CFL and thus contain quite interesting languages. However, as I will show in this post, each language $L$ in $C_3'$ has the property that the set $\{1^n;n\in\mathbb{N}\backslash\{0\}\}$ is either in $L$ or in its complement $L^C$. Thus $C_3'$ is also very restrictive, eg. it contains only trivial unary languages $\{\}$, $\{\varepsilon\}$, $\{1^n;n\in\mathbb{N}\}$ and $\{1^n;n\in\mathbb{N}\backslash\{0\}\}$. The class $C_3$ contains a bit more unary languages. However, it holds that if $L\in C_3$ and $1^n\in L$ for $n\geq 1$, then $1^m\in L$ for all $m\geq n$. A simple corollary is that not all regular languages are in $C_3$ nor in $C_3'$. Also the language $\{1\}$ is not in $C_3$ nor in $C_3'$. 

Let $f$ and $g$ be fully time-constructible functions (i.e. there exists a DTM that on input $1^n$ makes exactly $f(n)$ (resp. $g(n)$) steps) and let $f(n+1)=o(g(n))$. The nondeterministic time-hierarchy is many times (superficially) stated as $NTIME(f(n))\subsetneq NTIME(g(n))$. (proof: ask Google for nondeterministic time hierarchy). Well, the hierarchy actualy gives only $NTIME(g(n)) - NTIME(f(n))\neq\emptyset$. We would need e.g. $f(n)\leq g(n)$ for $NTIME(f(n))\subsetneq NTIME(g(n))$. For functions $f,g$ such that $f(n+1)=o(g(n))$, $f(n)\leq g(n)$ is very common. But strictly speaking, nondeterministic time hierarchy is many times stated superficially. To show that $NTIME(f(n))\subseteq NTIME(g(n))$ does not hold for all fully time-constructible $f,g$ s.t. $f(n+1)=o(g(n))$, define $$f(n)=\left\{\begin{array}{ll} n+1 & n \mbox{ odd}\\ (n+1)^3 & \mbox{else} \end{array} \right.$$ and $g(n)=f(n+1)^2$. It is easy to see that $f$ and $g$ are fully time constructible and $f(n+1)=o(g(n))$. From nondeterministic time hierarchy we know that there is some language $L\in NTIME((n+1)^3)-NTIME((n+1)^2)$ over $\{0,1\}$. Define $$L_1=\{0x_10x_2\ldots 0x_n;\ \ x_1x_2\ldots x_n\in L\}.$$ It follows that $L_1\in NTIME(f(n))$. It is easy to see that from $L_1\in NTIME(g(n))$ follows $L\in NTIME((n+1)^2)$, which is not true. Hence, $L_1\in NTIME(f(n))-NTIME(g(n))$. 

Appending is fairly cheap because the left-leaning property means that right subtrees are as small as possible. Iteration is relatively cheap because of the strong log(n) bound. I feel like there's a variant solution to this where we always keep the first element of the sequence on the Bin node instead of deep in the left-most leaf, but I haven't quite figured out the balancing act for that. Edit: actually it's easy. You just have to treat the key as part of the left tree and everything carries over - the invariant is now size left + 1 >= size right. It makes the join operation a bit more expensive when you have to rebalance but it's still only log n. The following is a minimal implementation of this modified form (it also ditches the size annotation because you don't need it on every node because the tree is left-leaning): 

Sorry, on writing this up and thinking about it a bit further I've come up with what is probably a good answer. Rubber ducks for the win. There turns out to be something that combines a lot of the good properties of the three ideas I already had, but is made vastly easier by the fact that we only need to append. The basic data structure is pretty close to that of a tree of bounded balance: 

create a new instances from an array of floating point weights. randomly sample, returning an item with probability proportionate to its weight. set the weight of a specific item to 0. 

I'm not going to accept this answer for now in the hope that there's a still better one (in particular I'd like cheaper appends), but this seems like a pretty good compromise data structure. 

The proof of the claim (in bold) about $C_3$ follows the same line as above. We take a one-tape 3-state Turing machine $M$ that accepts a string $1^n$ for some $n\geq 1$. Suppose $M$ is given an input $1^m$ for $m\geq n$. We have to prove that $M$ accepts this input. We have 3 cases: 1) When $M$ reads 1, it accepts. 2) When $M$ reads 1, it moves the head to the left. Because $M$ accepts the input $1^n$, it has to accept or move to the right on the blank symbol. Hence, it never visits the $n$th cell to the right of the initial cell. If it would, it would run forever on input $1^n$. 3) When $M$ reads 1, it moves the head to the right. It follows that after $m$ steps, the content of the tape is $A^m$ where $A$ is some symbol from the tape alphabet and the head of $M$ is on the leftmost blank symbol to the right of the last $A$. Because $M$ accepts the input $1^n$, it must accept or move to the left on the blank symbol. As in case 2), the head of $M$ will now never visit the $n$th cell to the left of the rightmost $A$. This is because on the input $1^n$, $M$ does not visit the cell directly left of the initial cell, because it contains the blank symbol and if it would read it, it would run forever. It is clear that in all three cases $M$ accepts all strings from the set $\{1^m;m\geq n\}$. 

I came along some quite natural NP-complete problems that seemingly require long witnesses. The problems, parameterized by integers $C$ and $D$ are as follows: Input: A one-tape TM $M$ Question: Is there some $n\in\mathbb{N}$, such that $M$ makes more than $Cn+D$ steps on some input of length $n$? Sometimes the complement of the problem is easier to state: Does a given one-tape TM $M$ run in time $Cn+D$, ie. does it make at most $Cn+D$ steps on all inputs of size $n$, for all $n$? The full result is presented here. Basically, it is shown that if we want to verify whether a one-tape TM runs in time $Cn+D$, we only need to verify this on inputs of length bounded by $q^{O(C)}$, where $q$ is the number of states of the input TM. So the witness would be the input of length $q^{O(C)}$ for which the time bound is violated. It is also shown in the reference that these problems are NP-complete for all $C\geq 2$ and $D\geq 1$. Now if the witness is an input that violates the running time, it has to be of length $q^{\Omega(C)}$ in general. And the input is of length $O(q^2)$. 

I am starting out in theoretical computer science. I have a model of computation based on observations of auto-associative memory in the brain. I believe (with little evidence) that I can do anything in this simple model. I understand the primary way of proving universality is to show that your model can simulate another universal model, especially a turing machine. I would like to request the following information: 

I have a problem in mind and I am sure this is likely an area of active research, but am at a loss as to the correct terminology and thus unable to find any reference literature. It is best explained by example: Say I have several objects, for example mahogany chairs. For each of these chairs I know a number of attributes about them such as their weight, texture, colour, age, etc. If you contact me inquiring about one of my chairs and tell me some incomplete information, e.g. "dark brown, 60's era chair" I want to decide optimally what further information (if any) do I require from you to identiy the chair of interest, i.e. what questions do I need to ask to obtain the required attribute information. Additionally, in the likely case that there are many questions I will need to ask you, how can I optimise the questions I ask you. Optimisation could mean minimising the expected number of quesitons I need to ask you, or asking questions I think you are most likely to be able to answer. So I would appreciate some information or references for this kind of problem. It's worth noting I am interested in implementing this computationally (hence posting here) as opposed to a purely abstract problem.