Usually, when you're making something that will be ported to different systems (whether a game for multiple consoles, or an app for various mobile devices), it's common to wrap your code so that anything that is specific to one system (rendering, event handling, etc) can be completely replaced without touching the code for the logic. SDL (and SFML) are examples of this sort of code, and there's other examples out there for various things. Now, if the only difference between the mobile and tablet version is texture sizes, then you could probably set up your code to use either a configurable texture size, or different build options. If there's multiple differences between the two, then it gets more complex. Of course, there's nothing wrong with focusing on one platform to start, and if your game does well/there's enough demand for it/you have free time, porting your game to a new platform once you make the gameplay solid for the initial version. 

The term is 'Freeware' (if the game was officially released for free by the company late in it's life), or 'public domain' if the copyright ran out. Copyrights last too long in the US, and no game has hit the 'automatic' lapse of copyright. There is also the term 'Abandonware', which usually means "the game/software is old and no longer being sold or supported". Many people think that abandonware can be distributed legally, but that is not true. Someone still owns the copyright on those games, though in many cases the exact owner is a mystery even to the owner. Wikipedia has a list of freeware games: $URL$ 

App development for Google+ looks to be similar to app development for Facebook. That is to say, you will likely be able to use any language or platform that allows the game to be played in a browser, and you will interface with the API via RESTful style requests (basically making an HTTP call to something like api.plus.google.com) My guess is that this will mostly translate to a lot of people using Flash, Unity, and HTML5/Javascript. To add more to this, since I can now check what various games are using: Angry Birds is using HTML5/Javascript (most likely the same one they're using for Google Chrome's app store). City of Wonder is using Flash. Those are the only games I really bothered looking at, but it's enough proof that multiple languages are possible. 

3d engines are usually designed around game objects being 3d models (polygons and textures). While it's certainly possible to make a flat plane and apply a texture to it, you're actively working against the engine when you do that. Additionally, many 3d engines lack the ability to deal with sprite sheets (all frames of animation on one texture), because they expect animation to act on the model (though rigging and other methods), not the texture. Again, there's ways around this, but again, you're actively working against the engine to accomplish this. Added complexity. As mentioned in Josh Petrie's answer, 3d is a huge bit more complex than 2d, mostly in math and scene management. Moving objects and handling 3d space is tough, and if this is one of your first games, it's just going to be all that much harder. The good news: Unity abstracts away some of these issues, though there's going to be some things you still have to handle (and much of the abstraction is, yet again, meant for 3d models, not 2d sprites) Most libraries that Unity comes with or that you can get for it are meant for 3d objects. This includes stuff like lighting, pathfinding, physics, etc. In the meantime, box2d will easily work with Flash, or XNA, or something (well, maybe). 

Conclusion There's a lot of cons, there's also a decent amount of pros. It's all going to depend on the sort of game you want to make, it's up to you to decide if it's worth it. Flash is still an extremely viable option, so there's nothing wrong with going with a 2d engine if that's what fits your game better. 

To expand on my comment, this is pretty much the perfect situation to use a Finite State Machine. You've got a set of different phases based on certain conditions, and each phase is handled in a different manner (at least, I'm assuming as much based on your description). The fact that some phases only occur once shouldn't make a huge difference. Switching between phases is easily handled, simply by changing the state. Each state handles one phase, and code is separated into nicely defined classes (or functions, if you implement it that way...) The only possible downside is, for the most part, you can only have one state active at once. It's also tricky (but not impossible) to dynamically add newly defined states, though it's entirely possible to switch between defined states (heck, it's designed for it). I'm not familiar enough with Ruby to know exactly how to implement a FSM, but it should be easy with any language that supports polymorphism. 

They have a Roadmap on their site with a list of what their plans are. However, people that have worked with the engine wouldn't know the business plan is anymore than the average Facebook user would know what the business plan is/was. It's unlikely that a random person making a game is going to know what the business plan of a new company is (unless it's obvious, like selling the software) That said, if I had to guess, it's likely that they will charge something for the iOS and android versions, and the "Stencyl Market" could easily be another source of revenue. If 10% of everything sold on the market goes to them, then hey, they've got a source of income. Edit: Turns out they have a very obvious business model. Lite and Pro versions, as described by this blog post. It seems like publishing anywhere will require the Pro version, which is $149/year. 

The 2d Zelda games likely had a set of points (basically a rectangle) that contained the 'max scroll' limits on the camera, and when Link walked to a different room, it would move the camera and change where those points were set. If you've already got bounds on the camera, then you can likely add these sort of room transitions without too much work. During transitions, disable player input and quickly move the camera in the direction you want, then return control to the player. Pointless extra trivia time: Link's Awakening (and likely the other 2d zelda games) contained only a few maps that contained many different rooms, along the overworld and caves and dungeons mixed together (there's examples of this out on the internet, but I can't seem to find them right now). I believe Link's Awakening in particular had 3 maps total, and many transitions would simply warp you to a different spot on the same map. 

Basically, you're not going to be able to force people to stick together after a game jam, but there's a few ways you can help. Some of these suggestions are for local jams, and some are for online only jams (and some are both) First, get the participants to exchange contact information (names, emails, phone numbers, social security numbers (not actually social security numbers)). This will at least allow people to look up their teammates in the future if they want to collaborate again. This is also pretty easy to do. Second, if it's a local Jam, organize game developer meetings in the future, so people can keep those connections fresh, and hopefully gain even more of them. Finally, if it's an online Jam, establishing a year-round presence through a website, forum, and/or chat room will help keep those connections alive. For instance, Ludum Dare has an IRC chat room that is active all through the year, though it becomes filled with tons of new people during each event. 

There's probably some other issues I haven't addressed, but those are the major ones that I see. Note that there are ways to make money from HTML5 games, but the route is different from a typical flash game. Chrome's app store is filled with HTML5 apps/games, many of which charge for extra levels or features. There's also hosting a game on your own server and having ads in the hopes of generating some income. 

While memory and CPU speeds have improved over the years, games are still often pushing the limits of hardware and software. If you're loading 100 such models, that's a savings of 4 megabytes of memory saved. In certain situations, it's worth it to save as much memory as possible. That might be enough for you to load another model, or enough to cram in a few more sound effects, or another song. For most AAA games, this sort of savings is vital to making things better than the competition. Of course, it's all game dependent, and for plenty of projects, not really worth it. But if you want to push the hardware as far as it'll go, you'll want to find ways to save as much memory as possible, so you have room to add more cool stuff. 

3d Acceleration. Graphics cards are a lot better at handling lots of objects in a scene than a CPU, and with Unity you can get that benefit really easily. This lets you display thousands of sprites on the screen, or include particle effects easily, or add in something fun like shaders to support cool effects like warping space and time to your will. Unity has many of these effects built in, which makes it really easy. Note that a lot of 2d engines use OpenGL or DirectX behind the scenes, and in many cases can be hardware accelerated, as well. Support for models. Remember that thing that was a problem earlier? Yeah, it can be a benefit, too. Depending on the game, being able to include rotating spheres or something cool like a 3d object in the background can be a benefit. You can also have a game made out of 3d, but simply forced into a 2d perspective, which can give you the option of rotating the world geometry without having to do tons of extra graphics to handle it. Learning 3d. Let's face it, lots of games are written in 3d, and if you learn how to use Unity, you'll be able to apply many of those skills to the next game which might require 3d. Additionally, a lot of artists coming out of school right now are being taught 3d modelling, so it's "easier" to find a 3d artist than a traditional 2d game artist (whether said artists are any good....) 

At the moment, there is no 'single development tool' that exports to Flash, Silverlight, and HTML5 (and Unity, and iOS, and Android, and whatever else you might want to export to). For the most part, this is due to Silverlight not being supported by various gamedev tools. (Unity, for instance, exports to Flash 11, and iOS, along with being a plugin of it's own) This is mostly due to Silverlight not really being viewed as a "game development" tool. It's not worth going into the reasons here, though. It is a good choice if you want to do Windows Phone 7 development, though. At the moment, Unity seems to be the platform to develop in for 3d web games, since it'll export to the new Flash 11 and iOS. It also supports C#, so it's somewhat .net developer friendly. Flash has become the main tool for 2d web games, and there's a few things like Flex and Flixel that let you develop in Flash without having to use the "normal" Flash software. HTML5 has it's own set of problems, mostly due to it being too slow or not supported enough. There's also the issue of monetizing an HTML5 game. The route most people take with Flash doesn't seem as feasible for HTML5, though we'll see what the future holds as technology changes.