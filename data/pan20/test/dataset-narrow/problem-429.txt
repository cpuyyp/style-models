Speed: it will always be slower than native HTML. Complexity: native HTML will always work (it might not validate, but it will display something). You have to extensively test your class, and still, you might overlook something. Usability: People know how HTML works, but they don't know your class, so they have to invest time in it. 

Comments You have some comments which don't tell the reader anything they didn't already know: , , . You can assume that the reader will be at least somewhat familiar with the language itself. What you should comment on is why you do things, and if it is unclear, what. Misc 

Approach The approach is interesting, but doesn't seem practical or actually useful. I think that you need more justification for this than simply stating that you want to use less if-statements. Especially since you essentially still have the if-structure, just with a different syntax: 

Security SQL Injection It's probably[*] secure, but it's not the right way to do it, see for example here why prepared statements are better than escaping. Sooner or later, you will mess up when escaping. Prepared statements are not difficult to use, and result in code that is more secure and more readable, there is really no good reason not to use them. 

These are open to reflected XSS (you can try it by inputting as username). I know that you have some validation, but validation is not the preferred method of handling XSS (and in this case it's not really working). You should always use right at the moment when you are echoing variables/inserting them into HTML. As to your validation: You check if there are tags in the input, and if there are, you display an error. But you still echo the payload! Also, even if you would not echo it if tags are present, an attacker could break out of existing tags via eg . All the other checks in are nice to have but should not be relied upon for primary security. Misc Your code seems safe from SQL injection, and you use bcrypt for password hashing, both of which are good. 

Just from a quick look at your code, I found a couple of issues. I didn't look at it in-depth, so there may be more. Security 

Prepare once - execute multiple times Prepared statements not only prevent SQL injection, but also enable you to only prepare a statement once, and then execute it multiple times with different values for increased performance: 

Structure Now, you sill have some duplication (session destroy and response code setting) which you may want to remove, for example by returning error codes or success messages from the function and only setting it once from the calling code. Your code also does a bit too much for my taste (db interaction, printing, retrieving user input, session management, etc). You could introduce functions such as , etc to structure your code. Misc 

Not really. You are using prepared statements as you should, and you are using the currently recommended hashing approach. Misc 

This isn't all that easy to read, and it is calculated every loop. If you rephrase your calculations like this: 

I don't know so I cannot say if it is secure. If it is this: MongoCursor::doQuery, I wouldn't use it. The documentation says this: It doesn't say why, but security concerns could be one reason. 

I like your code, it's mostly very readable and well structured. Your can be written a lot shorter by having multiple returns, and by using instead of : 

But that's not correct. As there are no comments in your code, I need to actually look at the code itself. Another problem with usability is that your methods do not accept parameters, but expect global variables to be set. But I have no idea what values have to be set, which again means that I have to look at your code to use the class. It would be better to pass these values to the methods, eg Another problem is naming: Your method doesn't just check if a user exists, it actually validates login credentials. So it should be called something like . Also, methods that check if something is true generally start with , so should be . Also, the user of your class shouldn't need to call explicitly. Why isn't doing it for me? doesn't seem to be usable without , and doesn't seem to provide that many benefits on it's own. I would probably make it a private method. Misc 

Echoing Your class should not echo, because it makes it very static and non-reusable. What if the calling class wants to handle it differently? It can't. Either handle these cases with a return, or throw an exception. Class size In my opinion, your class does too much (user model, handle sessions, register, delete, login, logout, etc). I would think about splitting some of this in different classes. Security: Cookies Important cookies should be , so that they cannot be read out via JavaScript. This limits the damage an XSS attack can do. Security: SQL injection Filtering is not the solution to SQL injection. Right now, it actually works fine, but what if your website grows larger, you get more developers on board, and then a user requests that they can be named "Jack Smith" or "super_awesome" or "Jack O'Rily"? As your filtering is very restrictive, a developer might "improve" it, or just remove it completely. And then you are in trouble. The way to prevent SQL injection is to use prepared statements always, everywhere, for all variable data. Security: XSS Same problem as above. Currently, you are save, but for how long? When echoing variable data, always protect against XSS. Security: Hashing is better than , but both are not ideal. If you still can migrate easily, use bcrypt. Inconsistent return values Sometimes, you use / as return values for success/failure, and sometimes / (sometimes these even mix in the same function). Try to be more consistent. Misc 

Yes, you are using prepared statements correctly. You didn't post all your updated code, so just remember to always use prepared statements and to never directly put any variables in the query. Returning early Your code is quite nested, which makes it difficult to read. If I want to know what happens in the else cases, I have to try to find the matching else, which can be difficult. If you return early / introduce guard clauses, you can avoid this: 

It is not safe, you are completely open to SQL Injection. You need to use prepared statements. Apart from that: 

This is a lot of code, so this is not a complete review, just a couple of points: Overall Program Structure Class Your class is a bit over 700 lines long. Without even looking at the code, it's a good guess that it does too much. What your class does: 

Functions Some of your functions do too much (see Naming). I would for example extract the filtering from the setting of the username. Another example is your constructor, which is very long and nested. I would at least extract the database check to its own function, as well as the cookie check. Reduce nesting In addition to extracting code to functions, you can also return early to reduce nesting. For example: 

(The second version is a bit more readable, while the first version might be faster, depending on the Java implementation) And then output the result in main: 

You then somehow have to string these components together, which is where the approaches to MVC differ a bit. 

It's not perfect, but I you get the idea. XSS You shouldn't write vulnerable code, even for academic work. It's bad practice, and it normalizes unsecure code; you get used to writing it, and other people get used to reading it. Always protect against XSS when echoing variable data, eg: 

Return Early If you extract the PHP code to a function, you can return early, and thus save a level of nesting: 

If you want to add error handling, each approach would have additional ifs. So you can see that you are not actually making it any easier to write code, but you are changing the well known mysqli API to your custom function, and you are making it impossible to write secure code, as prepared statements cannot be used with your function. So instead of your approach, you need to use prepared statements. If you still want to wrap mysqli, try to do it in a way that actually makes writing queries easier. Note though that the mysqli API is already pretty good, so it will not be that easy to improve upon it. Misc 

So no, this would not be secure. And there may very likely be more severe problems than the ones I described. But even those are enough to show that there are problems in the algorithm. [*] 

If you save and in local variables instead of accessing them repeatedly, it would also look a lot better. If you don't want to use the ternary operator, your if statements can be simplified like this: 

Personally, I would handle the value counting in on the fly, to avoid the trouble with the aces and the duplication in and (you could also avoid this by just calling twice in your constructor). You do the same conversion from list to array in a couple of other places as well. Eg this: 

No, this code isn't reusable. Currently, you cannot "execute queries" but execute SELECT queries with exactly one or two parameters. What if you need to add a third id? Or a fourth? Or have a query with no parameters? The easiest way to solve your problem is to just pass your array to : 

The Attack What you are basically talking about is DOM based XSS. But it's a self-XSS, so the only possible attack vector might be via ClickJacking (depending on the used browser). Still, it should be defended against, especially for usability reasons. Proper Defense Here is OWASPs guide on preventing DOM based XSS. Basically, you should first HTML encode the input, and then JavaScript encode. For your example, the second part doesn't seem necessary, just encoding , , and should be enough. Your Defense Well, your defense works. It could be simplified a bit though. There really doesn't seem to be a need to set , and I also do not see the need for (or am I missing something here? Browser compatibility maybe?). That would leave you with 

One approach would be to create a common superclass and extract the common elements of the function. As everything except the is the same, just pass that to the newly created common function: 

Security You are very likely open to SQL injection. You should never directly put variables into queries, and you really need to use prepared statements. You are also likely open to persistent XSS, which may or may not matter, depending on your application. Formatting 

Extract Code to Function and avoid goto First of all, I would extract this code to it's own function, and then I would use a while loop looking something like this: 

Yes. You didn't post your password_hash code, but you are using password_verify correctly, so if your code is working, everything is correct. 

Structure Generally, a method should do one thing. For example should add a play (although it's an odd method for a play class, as a play generally cannot own another play). But your method doesn't just add something, it actually retrieves user input, prints stuff, writes stuff to a file, and then calls a seemingly unrelated method, which asks for more user input and processes it in some way. It's also very unclear what your class is actually supposed to do. Looking at the fields, constructor, and getter/setter, it looks as if it holds the data for one play, but then it is also possible to add a play, which doesn't make sense. You should definitely try to separate the holding of the data from the parsing of user input. You should also try to better define the tasks and differences of and , and you should try to remove the confusing call structure (the functions call each other, which makes it difficult to follow the control flow of your program). Misc 

you can save all the null-checks. But as you pointed out in the comments, this approach somewhat limits the usability. An alternative to at least remove the duplicate checks is to extract the check to their own method: 

Structure Your structure is a lot better. There are a couple of things I would do differently, but generally it's good. 

Then it's just . The same way, you might want to put the building of the tag into a function. Naming 

These are just suggestions, you can improve on them. Comments and extracting Functions If you look at this code in a month, will you still understand it directly, without thinking about it? I don't think so. But there are ways to improve on this (in addition to better naming): I would either extract some code to its own functions (eg , , ), or at least add some comments to the loops to make your code a lot more readable. 

Hashing Let's start with the correct solution for hashing passwords: use bcrypt; PHP offers it with . It's secure, and it's really easy to use (it's just a simple function call, and it manages salts etc for you). What is wrong with your approach: 

Before working on performance, I would work on readability, code structure, and security. The first two - and surprisingly the third - can then help in later speeding up the code. Security You are vulnerable to second order SQL injection because you insert user-supplied data in your queries. You need to use prepared statements to defend against this. By using prepared statements, you can also prepare a query once, and then execute it multiple times with different data, thus speeding up the process. Structure Instead of structuring your code via comments, you should create functions. They will be easier to profile to find bottlenecks in your code, and you will get rid of some duplication. It will also reduce nesting and make your code generally easier to read. This will make it a lot easier to see what is actually happening, and where there may be bottlenecks. It will also get rid of your comments, as the function names will serve as documentation. This is especially helpful in your case, as your comments are sometimes wrong (such as saying that you are checking for the domain name when you are actually checking for the username, or that you are checking for the email when you are checking for the password). These wrong comments likely resulted from copy-pasted code, which is always a sign that you should extract the code to a function which you can reuse. Misc 

Structure It seems that there are a limited number of actions. I would suggest using an enum instead of a string. How you build your food isn't very clear when seeing a constructor call: 

Order of expressions in statement Your code would be more readable if you would be consistent with your ordering in the if clause. You have 

Naming Good variable, class and method names make it easier to review code, so I'm with Vogel612, why not make them better (although I think that in this case most of them are fine)? Comments 

There are more additions, but they do not seem to affect the basic principle. This means that an attacker can gain at least some information about the password by looking at the encrypted password. An encrypted will statistically have a smaller value than an encrypted . You can see this easily by adjusting the range from which random numbers are selected. Using for example , encrypting will result in this: , , , etc. You can see that is smaller than , is smaller than , or is smaller than . Making the random range larger makes this problem less sever, but it still exists. for example can reach values which other characters can never reach. So whenever you see , you know for sure that it's a . When you see you can be pretty sure that it's an , and so on. This makes brute-force attempts significantly easier for an attacker. Additionally, the size of the password is easily calculated given the encrypted password. This should not happen. Also, note the documentation of : I haven't looked at the decryption code in-depth, so I'm not sure if there are more weaknesses, but there very well might be (I'm not yet 100% convinced that the original password is even needed for decryption). Code 

Wrapping PDO: General Approach Generally, wrapping PDO without actually adding any functionality is not recommended. See for example here, or pretty much any answer on basic PDO wrapper classes. Because what happens is that you take a class with a pretty nice (and well known) interface, and then reduce the power of that interface (you can only perform , if you ever need a different fetch type, you would probably add a parameter/method to your script, if you follow my advice below, you will throw exceptions, etc; at some point, your script will be very close in use to PDO, just with different function names, and slightly limited functionality). Wrapping PDO: Swallowing Exceptions The biggest drawback of your solution is that you take perfectly fine exception and turn them into null returns. This has two downsides: It makes your calling code ugly (too many checks), and it makes it really hard to debug your code, as you just swallowed all the information, eg on why the database connection could not be established, or why the query returned nothing (is there nothing in the database, or is the query completely wrong? nobody knows now). Wrapping PDO: Error Reporting Another thing that's a real problem is that you are setting error reporting in this script. This is really something that needs to be controllable (for PDO as well as for PHP), because you want all the error reporting possible in development mode, but none of it in production. If you just set these values in various scripts, it will be really hard to control. Your Questions So I would definitely not recommend this approach, but if you want to go forward in this direction: