No effect on performance, but this seems weird. You have a column in that table named , but you are actually returning as . Why not just keep it as ? 

Also switched to the shorter object-oriented notation. Switched the order of the comparison to because this will throw a compile error if you leave off an where will silently change the value of and evaluate as false. Consistently using this order will therefore make it easier to catch that particular typo. You switch between having the on the same line and on a new line. Either is a valid style, but please pick one and stick with it. My preference is for on the same line, but both are common. Scaling My primary concern with this code is that it won't scale well. You have every user in the chat polling to see if there is new data. For ten users, this will probably work fine. For a thousand users, this seems like it would put considerable load on the database. Not so much from the queries as maintaining a thousand simultaneous database connections for twenty seconds. As a general rule, a callback is better than polling. You can generate the callback only when required whereas polling has to continually check. PHP is probably the wrong language for implementing a callback model though. You could add an additional layer between PHP and the database to fix this. PHP would call your service, which would then only call the database once (or not at all if the service also manages sending a chat message) rather than once per client. In that model, one database connection is sufficient regardless of the number of clients. You'd only need multiple database connections if there were multiple chat channels, and even then they could share. Some languages (e.g. Java) have connection pooling so as to share database resources transparently to the client. PHP seems the wrong language to manage something like this, as it is optimized for HTTP request/reply connections. PHP's not persistent, while this problem space is. This will probably work for a small scale application, but if it grows, you'll likely have to dump the current method and swap it out for something more robust. 

I got rid of the comments that just said the same thing as the code. I left the comment that explained why we were doing this uncommon thing. I changed the because you were doing the same thing in the as you would if it just fell out of the loop. Doing it this way means that we only have one statement to maintain. 

This gets more interesting if is called something else, e.g. . Then the caller may not even know that they have a . They just know that they have the normal methods. Factory Pattern There is a variant of the factory pattern that does work something like you specify, but it would normally have different types. E.g. 

The first thing that you can do will reduce the code written but slightly increase the number of images that you hide. Before the switch, hide all the images, like so: 

Note that the two size macros return while the function returns a . I don't know that there will ever be a bug as a result, but you should be aware of the implicit cast. If nothing else, note that you are casting a signed value to unsigned. I'm not crazy about the use of pointers here. It's not wrong. It's just that it leads to odd things like being outside the buffer. It also limits you in some places: 

What happens if there is no trailing in the URL string? You should explicitly check that you don't go past the end of the string. 

I'd call this a . Also, as a general rule, I prefer to only name collections in the plural. This is a scalar, so I would try to name it in the singular. I wouldn't use a comment here, as this isn't where it's used. 

If you don't have to use a linked list, then I wouldn't. You could use a balanced binary tree, which does a nice insertion sort. However, the balancing code requires some attention to get right. The simplest solution is just an array. If you have enough memory to hold a linked list, you should have enough for an array. 

You are using and . You should be using the logical-only operators ( and ). The latter versions short-circuit and don't process the second operand if they can determine the expression value from the first operand. You should almost always use them. It won't really matter here, as the second expressions are pretty simple. But there are some cases where using the short-circuit operators can improve performance. 

Again, the logic for an array is simpler. I don't have a C compiler installed at the moment, so apologies if I missed something. There's nothing magical about (which is an abbreviation of quicksort). There are other algorithms that will give the same sort time on an array. It's just the algorithm that's already implemented in standard C. Note that one reason why this works is that an is about the same size as a pointer. As a result, it's just as easy to swap two integers in an array as it is to swap around pointers in a linked list. If we were sorting larger structures, we might want to find a different way. I already mentioned balanced binary trees, which are good for maintaining a sorted list of structures. Another possibility would be an array of pointers to structures, which we could sort with again. We'd just need a different comparison function. 

If you can try to use the foreach form rather than the old C style loop. In this case, you only use in (which you use twice instead of saving the value the first time). 

Try to avoid naming things in the markup (HTML) by where they should be. Instead focus on naming what they are. For example, would be a bit better than , but would be even better. Then could become and could become . 

I'd call this for readability. Otherwise, one might guess that it reflects the overall indent rather than a value that changes over time. 

Any time that I see numbered variables, I want to replace them with a collection. Since we know that there will be no duplicate values, I'd use a . 

I'd call this instead to show that it returns a Boolean value. This also makes it read a little better in normal usage. 

There are bugs in your implementation. For the 3x3 case, try 1, 0, 2, 4, 3 and then call . Your program will return "X" as the winner because X has 1, 2, 3. It doesn't realize that 3 is a different row from 1 and 2. Checking with an invalid move makes the variable incorrect. Your check is incorrect, as you never check 0 (the first square in the diagonal) but do check 12 (outside the board). Note that I find this name confusing, as your is the one that runs from the top left to the bottom right. I would describe the other diagonal as the antidiagonal. 

This also allows you to be more consistent with the location of your comments, always starting them on a new line. A final reason is that there is a class of bug that comes from modifying a single statement else clause thinking that you are adding to the else when you are really doing something in the general case. I.e. forgetting to switch from the single statement version to the block version when the block version is needed. When it happens, this can be hard enough to debug to justify always using the block form. It's also worth noting that you can get rid of the entirely if you switch from to . Then you can simply always do an . This would also simplify the logic if you modify the with another clause later. Thus it is more robust in the face of modification. 

Unless you are doing something clever that I missed, you probably want to use the operator to indicate that you want this to be a list of the same type as the left side definition. You also want to declare this as almost always. You could also declare this as if you never assign a new list to it. Yes, you will still be able to it and elements to the list if you declare it final. You just won't be able to assign to the variable itself. 

So seems short for search algorithm. I tend to be against abbreviations, as they slow code reading more than they speed code writing. After school, you will find that you spend more time reading code (both yours and that of others) than you do writing code. But that's not actually the biggest concern that I have with that name. As a general rule, classes and objects should get noun names and methods should get verbs. This makes makes the code read more naturally. Search algorithm is an adjective followed by a noun, so I wouldn't use it as a method name. You could name the class , but I think that I might name it or . You can then name the method either (specific to this problem) or the more generic . Since you presumably don't have a standard to which to adhere, I'd probably go with . This isn't the optimal use case for something like .