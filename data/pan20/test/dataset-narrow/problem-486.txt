Try to match the country code. If none matches, falls back to default. Lookup the appropriate RegExp for that country code and attempt a match. If the match succeeds, attempt to verify the number with the appropriate function. 

Notice in particular that returns a coded string that includes the algorithm used and the salt. This means that you can store it straight into your database and not have to worry about salting and whatnot. 

Personally I don't think having one extra line per early return is much clutter. It doesn't seem like it'd take long to understand either. That said, if you really wanted to, you could reduce it to one line. You'll still have to assign a variable though. 

There aren't any loops, but the country test is expensive; I listed alternatives in a comment. Of note for the RegExp's: - In the original, Switzerland has three groupings, but only the second is used as the . To emulate this without grouping, I use a positive lookahead (). - I changed & according to their spec; since must be followed by 0...499 and by 500...999, I incorporated that into the match. 

This looks a lot better! Good job! Nitty-gritty stuff: better cleanup in the constructor You hava a lot of the following idiom in the constructor: 

the stl provides you with the super handy to deal with these situations, where you can in-place create and in-place delete object from safely. 

Don't use push_back on vectors, basically ever is almost always preferable. Slow removal Ideally, you'd want to store the observer list in an intrusive doubly-linked list, so that you can have O(1) removal. Unfortunately, this type of pattern is a bit of a blind spot in the STL, as there is no ideal container for it. (AFAIK, someone please correct me on this if I overlooked something). if you don't have access to something like , you can get around this by storing a in the Observer itself. You "could" manually set up the list, but it's rarely worth the trouble. Naming: Do not call a vector somethingList. "List" is loaded with meaning, and implies guarantees that your code does not provide, so it's misleading I would personally just use for the vector. RAII Since you attach the observer to the car in 's constructor, you should detach it in the destructor. Consider using instead of polymorphism for callbacks Consider how much more flexible your code would be if was a: . Specifically, once you start scaling usage of this pattern up, you will find yourself with classes inheriting from 4-5 different listener interfaces, which will lead you to realize that is an awkward name, and a bunch of different headaches. Here's a rough example to get you started: #include #include 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

Use maps to handle mappings instead of having constants for each individual ratio, you might as well have a single constant that holds both the ratios and their respective strings, as well as being able to map one to the other. Consider this: 

There's a few subtle advantages for the compiler, but the main one is that if you goof up and accidentally do something that changes the trie, the compiler will tell you. nitpick: is redundant here. The namespace of a class is private by default. Fun fact: that's the only difference between a and a . nitpick: redundant null-checking in your search function, when I read the last line: 

Don't use for_each when a range-based for works. is not best practice unless you are already manipulating a predicate. range-based-for is preferable: Like so: 

I have one big swooping recommendation that I feel you should address before tackling anything else: Mind your class invariants! When designing a class, ideally you want to ensure every single public member function handles correctly any possible valid state of the class, in conjunction with any possible passed argument. In your case, ask yourself: What happens if gets called before ? What happens if gets called twice in a row? What happens if is called after ? A good way to tackle that is to define what's known as a class invariant. First, jot down on paper a description of the legal internal states of the class. That's known as the class invariant. For example, you may want to have in your invariant definition, but would be even better, because it allows you to rely on that being true, so you don't have to constantly check. Second, for each public member function, make sure that the function's behavior is well defined for every possible invariant state, and that it leaves the class in an invariant state after it's done. Mind you, it doesn't mean that every public member function must "work", just that it doesn't explode, cause memory leaks, etc... Edit: There are some extreme exceptions to this, such as 's . But this is an exception, and the class' documentation makes it extremely clear that you enter no-mans land if you call that with an index outside of the bounds. 

You seem to overuse in your CSS. This is very bad, but I didn't change anything about this. Your script is extremely repetitive, too. I tried my hand at DRYing it and I got: 

That's not how the keyword works. creates an object using a constructor function, but your function does not behave like a constructor. This works only because will perform the function call, but you're really just doing . Also, rather than using for attributes, use . This holds for the rest of your code as well. 

You're looping through every possible permutation of three boolean values. This could be achieved by looping on booleans: 

Finally, your implementation of is linear when it could be constant. Observe that performing a union operation (on two disjoint sets) will decrease the number of disjoint sets by exactly one. Then, you could add a member (say, ) initialised to that you decrement in your function. 

In PHP 5.5+, the best practice is to use and . You can use it in your code like so. Notice that this obsoletes the column in your table. 

The following is a .wav file generator that I wrote briefly while (re)learning about audio sampling: 

I'm aware that not all op-codes have been implemented as I have only implemented the ones needed to get the 15 Chip8 games that I have copies of running. The code that I am most interested in having reviewed are the chip8.h and chip8.cpp files however I have included (the majority of) main.cpp for completeness. An update that I would like to work on would be to switch from using a statement to using function pointers but would like a hard review of the current working code before I begin with that. Thanks to this tutorial which I used to get started and for opcode . chip8.h 

Is there anything that I can do to improve my function? I'm especially interested in the use of storage types other than and what the advantages of doing so would be. It should also be noted that I do have an intention of doing something like this in a however, as this was quickly thrown together for the solution that's parked for the time being. I'm less interested in my method of solving Problem 16, however any comments on that would also be appreciated. 

† I say "probably" because although it's a CSS3 Candidate Recommendation, it's considered at-risk due to poor browser support. ‡ Strictly, your code will be assigning the handler to , but they'll do the same thing. 

Formatting I found this exceedingly difficult to read. The indentation in particular is inconsistent. I highly suspect that this is because your code contains mixed tabs and spaces. (StackExchange silently converts tabs into four spaces. If this is not the case, please ignore this section.) I don't want to start a holy war or anything, but there are three main camps here. 

If you're adamant about continuing with your approach, then instead of using and , consider using a salted hash involving the date. For illustrative purposes, I'm only using one round (since this type of thing doesn't need to be cryptographically secure). 

I agree with @ckuhn203 in that the first looks cleaner. I'm not too familiar with C# and its style, but in C I would definitely prefer using a loop: 

I just want to highlight your - chain. You should stick to one style. I understand that you want to put in a comment, but this should not cause you to uncuddle the . You can put the comment on the line after the instead. Also, this function needs to be documented. I've read it over twice and I can't understand why an item has to be to count as an item. It doesn't help that you didn't actually use the form ever. Anyway, I'd rewrite it a bit still: 

It sounds like what you want is a hard-enforced singleton. With an interface like the following, you can provide a hard guarantee that only a single instance of Controller will ever exist: 

This is meant to be used (amongst other things) in a dynamic texture atlas, i.e. it's meant to be long-lived and incrementally added to over time. Think full unicode font were needed glyphs are added on a per-demand basis. It employs the "Guillotine" approach to bin packing. 

And you could rebuild the class in a much simpler way around it, and it gets rid of iPoolable entirely! want a ? no problem! You are creating too many objects too soon. 

The second one is better because it works whether there is a null terminator or not. It also removes a call from the code, which is a O(N) operation. That's actually all I've got. Good job once again. 

Answering only your specific question here: "Efficiency" is really the wrong thing to be worrying about. For example, look at what your code generates when given to clang 5.0.0: $URL$ It looks like a bunch of gobbledigook, but what it means is that clang very heavily vectorized the code. This makes the code extremely fast for long chains, but not as fast as it could be when handling 1 or 2 digits. Performance is ALWAYS contextual and relative, and unless you know what context you are operating under, you can't really know wether it's efficient or not. 

Edit: Thanks to @ratchetfreak for pointing out a bug whereby I was overwriting elements of without storing the overwritten element elsewhere beforehand (essentially losing it). 

The reasons for these questions specifically is that I like concise code, writing it on few lines without having any too long. Code 

Will not come out as the numbers they represent but can be reconstructed later on. But sequences such as will come out as making it easier to account for multiplication of variables. Questions For the most part I'm quite happy with this code, a couple things that I'm interested in (alongside general review) are: 

On top of the comments provided by Billal BEGEURADJ, you also have the possibility of a stack recursion error in your code: calls calls calls calls calls calls And calls To fix this it may be worth making the game get started from outside of the class in a loop: 

I've recently started learning OpenGL and thought that a great way to start using it in its simplest form would be to create a Chip8 emulator using the keyboard callbacks and graphics that GLFW and OpenGL provide. As this question would be too large to request a review on my classes used with OpenGL and my Chip8 emulator, I'll keep it to just the Chip8. 

Apart from type erasure, there is nothing gained by inheritance that cannot be accomplished through composition. Composition is more flexible. Primarily because you don't run the risk of running into clashing namespaces, but also because diamond patterns are easier to work with. 

Another advantage is that it lets you get rid of entirely, and replace it with a nice lambda in . Nitpick: registerClass should invoke registerFactory. Since is just a specialization of registerFactory, it should invoke it instead of reimplementing it. This is preferable because having a single point of entry makes refactorings like adding logging or debug monitoring a lot less error-prone. Prefer instead of The semantics of type alisases are just a lot more legible that way. Wrong function definition for forwarding args If you want to use forwarding as you do, construct needs to be declared in a way to use universal references, like so: 

You don't need for anything, so you should just omit it entirely Redundant explicit void argument list in main declaration: should just be Style-wise: opinions: I don't like using unsigned Since unsigned generally reads like a qualifier (I know it's not, it just looks like one), I personally much prefer being explicit and using instead. non-style stuff, but important: don't use non-sized types with hard-coded sizeof() expectations. Your struct assumes that is 4, which is bad, you should be using to properly enforce that. Writing to an union field and reading from another one is illegal This is surprising to many people as using unions to perform type punning is such a common technique, but it is, in fact, undefined behavior. You are only allowed to read from the last field you wrote to. That means your function is not valid C++ at all. What's legal is reading and writing from a (or ) array obtained from ing the pointer of a standard layout object. In fact, it's the only legal way to do direct memory manipulation of an existing object. Edit: as requested, an implementation of using casting to array: 

This indicates that a few of your opcodes may be functioning incorrectly (although it could be a deeper issue), it might be worth running your emulator alongside another to see how they compare. 

Recently I've been doing some experimenting with RPN and the shunting-yard algorithm, in order to test these systems more appropriately I planned on writing a tokenizer and then using these tokens to check validity and eventually get some output. I also think that I could use this to work with some primitive programming language, such as making a CHIP-8 assembler. Function The intention is for my tokenizer to separate the input string into a list of the following: 

As part of a first year university course in computer architecture some time ago we were tasked with learning 8086 ASM. The final course work required creating a small animation of shapes moving around the screen changing colours and the like. As I would not expect anyone to review 720 lines of assembler I'm just going to provide my implementation of Bresenham's Line Algorithm. Note that this is not the entire program but a single macro from the working program. Also note that at the time of writing I had little to no experience with 8086 ASM (I still don't in fact), but I'm very interested in knowing how I did and how it could have been improved upon. If anyone is interested in reviewing the rest of the project as well (it can be done in small parts) then let me know.