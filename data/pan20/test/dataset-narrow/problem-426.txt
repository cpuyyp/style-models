Ok just as expected, just using different offsets depending on the class. So you can see where this is going, if you end up with 10 different classes then you will just get 30 instructions (instead of 3) whenever a function will need to lookup a property. Which is still much better than a hash table (100s of instructions?) lookup. Well no, turns out there is a limit of 4 different classes and then you go into megamorphic mode. So with this, we should see radically different code output if we use 5 or more different classes: 

Last Loop You have two conditions that only apply in the last loop. I would pull those out to after the loop: 

User-based salts are managed automatically for you, and it uses multiple rounds of hashing, slowing the process down, and thus increasing the resources an attacker needs to crack your hashes. You can still use a pepper with bcrypt if you want to. For more information about password hashing in general see here. Misc 

General Review Duplicate Code You have this check: twice. You could extract it to a function. Variable Declaration It is often best to define variables as close to where they are used as possible, so it might be better to declare and inside the loop. 

Define all your error types globally in some file for convenience, like the built-in errors are defined. Mixing promises and callbacks is a big anti-pattern, just think in promises and let .nodeify handle the mapping to callback equivalent at the end. 

So the same function body ran 15 times faster because the object passed to it always had the same class. It is also hard to predict if you will actually save memory if all those 10000 objects allocate a different class for instance. It is also complicated to really look at all the downsides but having optional properties is one of those things that it is easy to say is very bad. 

Use ternary operator In most situations, the ternary operator is not a good choice. But when conditionally assigning a value, it sometimes does make sense and simplifies the code: 

Copy Pasting If you are copy-pasting code, it is a sign that you should write it differently (your two loops are quite obviously copy pasted). Bug I'm pretty sure that here: 

I'm also a little worried about usability, as the user has to look up how to structure the routes array. I thought about adding a method, which would mean that the router could be used like this: 

In a good implementation you pay for a lot of functionality only if you are actually using that functionality - so a lot of functionality doesn't necessarily mean slow. In fact, more often than not, implementations with small amount of functionality are very sloppy and not fast. Consider underscore using a -statement. This slows down performance unspeakably but is done because it takes no effort from the implementer. Implementing variable referencing properly without using would take a lot more code. Overall an optimized library will always have a lot of more code than an unoptimized one. It's a simple physical law. 

i inspired of @MAG alternative solution, i re-implemented it in recursive way by providing template parameters. as following: 

Here my attempt solution, it works as expected, i have slightly change the input to make it interactive. All inputs are guaranteed to be valid and correct as well as the result. How can I improve it further. 

here is equal based on the if it was converted to string size. also, will be always equal . i don't think you need it here. use where it is possible you have few candidate for it like , and . also in for-range loop it is better to consider it for optimizing purpose like so, for since you going to use it often in your code, it will be nice if create std::string object for it. 

Ok so the situation is still pretty good but here we are relying on the fact that properties are in same order and that there are only 2 different classes. Let's do the same in different order so that V8 can't use the same instruction () for both objects: 

That actually looks a lot like code that loads properties from objects that are in hash table mode. Is it fast? Unfortunately jsperf is down now so you have to run it yourself with code here: 

Loading Config Data You are loading all config entries into an array, but you are only using . It would be more efficient to only load what you actually need. XSS You are not sanitizing your data with , so anyone creating frontend titles, product titles, or product descriptions will be able to execute arbitrary Javascript on the clients machines, and can thus steal cookies, log passwords, deface the website, etc. 

Readability and Usability Your function is indeed quite generic, which does give you a lot of power in your controller. But I would agree with you, that this is not necessarily a good thing. Just looking at your controller line, I would have no idea what it does, because it's impossible to know what all the NULL values stand for. Apart from it being hard to read, I would also think that this function is hard to use. I would have to look up the order of the parameters each time when I write a query. Need for Flexibility The first thing I would check is if your models actually need to be this flexible. Because that way, you do blow up your controller a bit, as it has to make the decision of what to actually extract. In your example, you don't actually need the limit, offset, or order_by, so if it's not needed elsewhere (and probably also not needed in the future), think about removing it. I'll just assume that you do indeed need the flexibility, but it's something to think about. Two Possible Alternatives I could think of two different ways to improve your code, one offering reduced flexibility, the other keeping the existing flexibility and increasing readability. Option 1 The first option is to write additional functions which access your function internally: 

Notice what happened here, V8 saw that we always pass the same class of object to the function and generated really tight code that assumes we will always get that class of object in the future as well. Now let's do: 

related jsperf $URL$ Well this is a really bad idea. Objects are always considered having different class if they don't have exactly the same set of properties in the same order. So a function that accepts these objects will in best case be polymorphic and in worst case megamorphic all the while you are thinking you are passing it same class of objects. This is fundamental to all JS engines although the specifics that follow focus on V8. Consider: 

I have created mini-opengl program that draw simple chess board on screen by using SFML windows model only. The program runs fine. The main purpose of this program is to keep it as simple as possible and it is not rely on any of OpenGL helper functions like or for converting coodinates. Also, it is not using any external library for loading textures. I would like to know how can I improve it? 

I wrote simple generic function to check if any STL container has an element. It seems work fine. I have tested it with VC++, GCC and Clang compilers. It works perfectly. How can I improve it further. 

Your Controller Your controller is fine. If you use a similar approach to the one outlined above, you would need to change it a bit, but generally, it would still perform the same task as now (get input, apply it to model and view). You should probably add a more generic instead of using an directly to separate the controller from the concrete GUI. It would probably only have one method: , which should return the desired move in some way (either create a move class, or just use an array). Misc