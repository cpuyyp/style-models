There is no telling how the database will optimize the query plan for this, but I would expect that the best query plan would involve applying the predicates to the tables before the union is done. Doing a UNION of multiple small result sets would be more efficient than doing a union on large sets and then filtering the results. The UNION operation requires a lot of scanning because UNION is also a DISTINCT process (you only have one record of each value in the result). So, two things. If you are sure that the values in in a column-pair will not also be in any of the other column-pairs, then you can replace the with the faster . If you are sure that a column-pair is unique, or empty, then you can avoid the DISTINCT process completely. I would write the query as: 

there's no need to record every draw you make in an ArrayList - it will grow large, and require garbage collection. You only need to count how many times you 'pull' each coupon. there is no need to number the coupons from minimum to maximum - you just need to know how many there are. You use values instead of primitives. You have too much code in your main method - the main method is hard for the compiler to optimize - it is only ever called once. 

Writing a useful function should be the first thing that comes to mind when you have a challenge like this. Functions can be reused, and they can make the logic simpler. In addition, a return value is easy to apply in a function, and you can return whenever the function value is determined. In this case, a function like which returns a conditional-friendly value (int 1 for OK, 0 for not OK). This function would check for invalid conditions, and return 0 when an invalid condition is found. If all checks pass, though, it returns 1. Your leap-year check is not accurate though. Your code is: 

That function removes the display logic from the action listener, and puts it in the class itself. Another trick in Java is that interfaces with a single method, like an are implicitly a functional interface. This allows instances of them to be declared in functional shorthand.... 

By using a counter, you greatly reduce the amount of memory churn in your map, and you can convert it easily to a reportable Long instance when you externalize the values. 

Now, in a change management/version-control system, your single change (moving the line ) has changed 3 lines of code, and it looks like you added three lines in the diff, making the change look more substantial than need be. Tracking changes is often the hardest part about maintaining code, and being able to separate substantial changes from clutter is hard. By placing braces appropriately when you first write the code, you make subsequent changes clutter-free. This is even more apparent in code like: 

Your code only works for small values of N. The algorighm is effective, but unfortunately your overflows are real. Factorial numbers get very big, very fast... I think it is around 12! that you run out of space in a 32-bit integer, and about 20! that your run out of space in a 64-bit long. You need to convert your logic to use BigInteger instead of Long for it to work at all. 

This can be easily done using a two-phase approach, one to shift values to the front that you want to keep, the other to sort the remainder. Note, for sorting, use the native functions in the libraries... in this case, It would also be much better to wrap this up in a function, taking 2 arguments, the number to put first, and the array to sort. 

it is a string of lower case letters with the removal of a single character, it will be a palindrome. there is a character to remove. 

You are not doing your tests 'appropriately', and this is part of your issue. there is no need for the 'supplier'. The supplier is an instance field, and, it's an extra level of abstraction that is unnecessary. JUnit has concepts at play that allows it to run tests in parallel. Having instance fields that are not part of the before/after sytsem can lead to problems. Instead of the supplier, you should have an abstract method, and your @Before method should be changed: 

I often create new accounts or virtual machines, and then have to load my SSH public key/signature in to the authorized keys on that account. That process can be tedious, so I created this script that pushes my authorization on the remote machine. So, typically when you ssh to a remote machine you have to enter your password, etc. To automate jobs, though, you often don't want to do that, and key-based authentication allows you to authenticate without the password. There are other ways to push keys around, but this makes it simple to fix things after the fact, or to initialize new accounts, etc. I am looking for a review of any and all aspects, including the way that SSH is set up, and so on. Here's an example transcript of what the script outputs: 

The other prompt allows you to simplify the other aspect of user input.... This is a summary of what my main method looks like, with the instance available: 

need to transform class A to class B. also need to transform class C to class B. JMapper can help. there are other classes that need transformations as well we should make a generic factory for it. we can also make the concept referencable as an interface, so things other than JMapper can do the mapping if necessary. 

Negative if Your main if-block would be better if done as a positive check, not a negative check. your code is: 

I think you may have a problem with initial state, and spurious wake-ups.... Consider the following You have multiple instances of a Runnable ( and for thread A and thread B), each of them does . The expectation is that they will be woken up in turn when the queue's method is called (wake up both and by calling twice). So, both threads are asleep, the queue contains and the atomic boolean is false (the 

Note: Using Java7 versions of Pattern matchers, it is also actually quite easy.... Consider this pattern, which stores the first-character as a pattern group, and then the "traditional" matching replacement loop: 

Finally, if it really was me, I would recommend that you consider ReentrantLocks and Conditions to manage the queue.... There's a good example (almost identical to this exact problem) of how to do it in the JavaDoc. 

The issue is almost certainly in the structure of your class, and it's memory efficiency. You should ensure that the and are stored as memory efficient structures. The instrType appears to be an , which is good, but just make sure that it is declared as an in the Trace class. The more likely problem is the size of the hexAddress String. You may not realise it but Strings are notorious for 'leaking' memory. In this case, you have a and you think you are just getting the hexString from it... but in reality, the hexString contains the entire line.... yeah, really. For example, look at the following code: 

This is much simpler code to read, and understand, than the previous version. The singleton can probably be improved slightly by removing the Config calls from the declaration, and putting them in the constructor. Similarly, calling the would be useful in the INSTANCE constructor too. The semaphore and channels should also be final.... A system like: 

Then, your "Calling" code (which appears to be a ) should also implement the interface ... something like: 

as the very first line. The rest of the script looks fine enough. The script has a duplicate declaration: 

Using the above system makes all the private fields immutable, which helps with concurrency. But, now that your code is also much easier to read, it is also apparent that there is a trick you can do that would simplify things a lot more..... What you want is just one Queue and a synchronized mechanism for pulling from, and returning to it. Some code will be easier to explain with than text. Note one more important thing, your method was doing too much, which made it very complicated. By extracting the 'get a channel' and 'return a channel' methods, the sendMessage becomes much simpler... You will need to extend this code to match your channel system, and logging, etc. The only thing that's real here is the single use of a synchronized. There is no other concurrency needed... (no semaphores, locks, or other tools): 

With the above code we calculate the 'weight' of the Branch, and we compare that to the capacity remaining in the knapsack. If we compare every combination with our knapsack we would find the solution, but not in the most efficient way. This does the Branch but nothing about Bounds. To compute the bounds there are a few solutions.... but, starting off with sorted items leads to the most efficient solutions.... so, sort your items in ascending order. Then, your Bounds solution becomes the simple addition of a couple of constraints: change: 

While your performance limits may be satisfied by producing your results as they are available, there are also other issues in your code which you should consider altering. First up, 1-liner solutions are convenient for saving some typing, but often make compromises that affect other aspects of your code. In your case, the 1-liner for reversing the number: