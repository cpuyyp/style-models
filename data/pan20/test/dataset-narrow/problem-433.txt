First of all, splitting the spliterator only makes sense, if both the remainder of the current spliterator and the returned spliterator still have work pending. In your case, this is (almost) not true, as you operate on the complete batches and the current spliterator at most returns its current batch after split. Thus, I'd replace the trySplit() with a simple return null. This also addresses any potential concurrency issues (which I have not looked into in depth.) Characteristics basically tell the caller the - for lack of a better word - characteristics of your spliterator. :-) I think for the batch approach you take, ORDERED, NONNULL, IMMUTABLE should be OK. Apart from that, for more direct utility, I'd rather take the approach not to iterate over the batches, but over their contents, i.e. create a Spliterator which gets initialized with the first ObjectListing batch and then transparently goes through the underlying collections element-wise and fetches the next batch as needed. This would eliminate the need to flatMap on the result stream and feel more natural for a streaming approach. (In fact, this sounds so useful that I'd like to have it :-)) 

And try to come up with code that operates on such a list. Note: Function is the standard function type with an integer as an input and a string as the output. No need to define your own interface. If you have achieved this, you can easily add another function to the list to check another value, and then you have achived something that might be considered dynamic. 

Additionally, I'd try to get rid of this mega-switch statement. Ideas depend a bit on your concrete data types, but I could imagine to create an enum with constants for your comparisons, which can generically operate on comparable types or the like. Then you could use reflection / bean introspection to read the requested value and compare generically. Something like: 

Apart from that I don't see much potential for time-saving. Curious to see the measurement after that change... :-) 

Both loops use exactly the same principle, just in an opposite direction. You might consider generalizing this by declaring the startingBracketType, the oppositeBracketType and the offset in variables, and modify the loop accordingly: 

Alas, what you would like to do is not possible. You could indeed play around with interceptors in a CDI container or with an AOP framework, and basically change the exception type at runtime. BUT there's one thing you will never get rid of: the static excption typing in the method declaration. Thus, even if you have 

The thing you need to do is commonly called "grouping", i.e. you iterate over a given dataset, take one property (the time in your case) and collect the entries with the same property in a useful structure. Fortunately, java (8+) already can do this for you by streaming through the map entries and grouping them all automagically: 

... which is exactly what you need from a data perspective. Using a further iteration over this map which uses the time as a key and the old map's entries as values to format the respective output should be quite trivial. BTW: to keep the order of the days, you should use a LinkedHashMap instead of a HashMap. 

(Please have a look at the API docs, there are also variants to explicitly set the character set $URL$ 

Basically, the only difference is, that one time you use the controller for something and the other time you don't. Not knowing what the controller does with the connection data makes it a bit difficult, but if it is equivalent to call controller.getConnectionData(connectionData); at the end of the process, I'd refactor like this: 

(or even better: make file a java.nio.files.Path in the first place) The same goes for the buffered writer and Files.newBufferedWriter() 

Reading the file: you declare the BufferedReader as an instance variable while it is only used locally. Don't do that: variables should always have the smallest scope possible. In addition, resources should normally be closed in the same scope that opens them (which brings me to the point that you never close the buffered reader.) Furthermore, you put the opening and reading in two different try-catch constructs. That makes no sense. If the first fails, you cannot expect the second to work. Thus, using "classic" code, you should put it together as a try-with-resources block, which automatically closes the opened resource, something like this: 

Edit 2 (to long for a comment): Disclaimer: this is from experience (> 20 yrs) and not from some ready-to-link standard text. Probably you will find something supporting these claims, probably you'll also find something saying exactly the opposite. Basically, you have to strategies on how you can cope with multi-action requests (like you have here). If requested actions "A" and "B": 

The first variant is what your code aims to do. Perform what is possible, and detail the result. I consider this the second-best solution for the following reasons: 

When you have this structure, you can simply check for each legal i and combination created. For counting, using a mutable integer object (which the base libraries lack) is the esiest thing, thus here I use an AtomicInteger to count: 

A few ideas: First of all, I think splitting your class into several classes is a good idea. As I admittedly do not fully grasp the business logic, this is more or less up to you, but basically have the session handling in an application scoped bean and inject that into the various other derived classes. Then, for easier maintenance of the various resulting handlers, I'd let the handler manage the decision whether to operate on a given message or not. You might inject an Instance of a common interface into the WebSocketServer to achieve this. Something like: 

Just picking out your factory problem (btw: all in all the code looks really good!): Basically, you pass the same values around from instantiation of your factory to all the sub-objects, which in turn use these values, which makes for long and unwieldy parameter lists. Two solutions come to mind: Classic: Create a parameter object, which holds all parameters, instantiate that object, and pass it around instead (see $URL$ JEE (preferred, this is 2017 after all ;-)): If you have the possibility to run in a CDI container (or maybe already do?), you can have various layers of factory object and automatically @Inject the constant parameters you need. If you have some kind of session handling, you can also inject that. Furthermore, with a CDI-container you can also cover the logging aspect with a logging interceptor so that your code does not have to care about that. Have a look at $URL$ for a starter, and a look at $URL$ for a reference implementation which can also work standalone. 

It depends. (As usual.) The recursive version is easier to read an maintain, and does the job fine for relatively small data sets. However, when the data set grows large, you create a new stack frame for each recursive call, which may lead to great stack memory usage up to stack overflow. Furthermore, this is comparatively slow. The second version uses constant stack size and puts all the real memory usage in the heap where it should be. Not using recursion, it is also bound to be faster (on a micro-level only). Thus, know the problem you solve: for small sets, write nice code and use your version, for big data sets, optimize by unrolling and use the second version. (BTW: in my university courses, it was generally recommended to use the second version for NP problems due to raw speed - albeit in C at that time.) 

The compiler will still require you to handle in the method call, as it cannot know that you will replace that exception at runtime. The only way I see to change this is: do not use checked exceptions at all. Do the local catch-and-rewap dance in all places where some library insists on checked exceptions, and only handle runtime exceptions in your code. Then you have all liberty you need. The pros-and-cons of replacing all checked with runtime exceptions are definitely beyond the scope of this question. Let's just say: it is a controverse subject... 

Style: Spaces around operators and a different brace style would be java standard as used by most of the rest of the world. See the code-snippets I posted. For your Queue implementation the feedback is exactly the same. 

Furthermore, you don't actually use the flag. Thus, if you intend to break out with the flag, you don't need to break; - if you want to use break, remove the flag and use while(true). Or even better: use some sensible border checking in the while loop so that you also can handle malformed input. 

The question for a "better" solution is bound to be quite opinion-based. As far as the actual code goes, I think you are quite close to the optimum. As for readability... well, Roland already shared his initial thoughts and I totally agree. This is bound to be a nightmare for the poor maintenance programmer. Thus: a suggestion which is nothing new, but just a little rearangement: 

If you are in for raw performance, try to avoid repeating potentially cost-intensive operations. In this case, you split the lines twice with the same parameter, which repeatedly applies a regular expression under the hood. Instead of 

First of all, nullbyte is exactly right about the use of a StringBuilder: using for Strings roughly equals under the hood and thus is a quite expensive operation. Then, your method to check whether a given charcter exists in the string after a given index is which again creates a superfluos string object via the substring-call. Instead, simply use to find the next index of ch after the given starting index (returns -1 for "not found"). Additionally, you might consider nullbyte's suggestion to hold the seen-or-not-seen status in a set, which also was my first intuition when reading the exercise. (Right now, you have runtime complexity of O(n^2) which you could reduce to O(n)). You only have to somehow come up with a method to revisit the first character, maybe by not using a set but by usign a map from character to number of occurrences or something like that. Naming: why ? This is not decoded in any way, this is just lowercase word. I can live with (or probably better encoded), but decodedString does not look right and does not give the reader any clue about the variable's contents. 

I recommend refactoring to 100% try-with-resources and no finally blocks. Good point: you close all closable resources including result sets and statements. You wouldn't believe how many people forget that. General setup Is there more than one implementation of IUser? If not, why do you need an interface? I'd simply delete IUser and recreate it via refactoring if I need a second implementation, not before. Static datasource with the singleton antipattern: BAD idea. See $URL$ $URL$ $URL$ just to share a few links. Better: inject this into the User class. If you don't want to go through the hassle of putting it all into a CDI container, pass it in as a constructor parameter. The Connection class itself: first of all, the name "Connection" collides with the JDBC Connection, I'd try to find another name. I guess the hardcoded database parameters are just for a quick and dirty setup. If not, these should come from an external source like a configuration file. After such a change, there's especially no more need to switch between different environments via code. 

Regardless of the java version you use, the business logic, which decides whether the object should be added and in which way, is placed in a non-OO programming paradigm. Instead of walking through other objects private parts, just add an appropriate method in the object itself and call that method: 

In addition to the answers already given, there's another problem with the Game class design. First of all, the constructor creates the Player and NPC by itself, which leads to tight coupling: you could not replace any of the parameters used in creation of the Beings without changing the game class. Better: let the Game take its participants from the outside: 

One more thing in addition to the other answers: nowadays I'd leave the construction of buffered readers and writers to the appropriate utility class, ie. instead of 

mdfst13 already gave some useful comments regarding the message digest, so I'd like to add something regarding : When you copy from a file path to a stream, there's no need to write this manually anymore. to the rescue: 

It is somewhat unfortunate for streaming when you base your program flow on exceptions. If you want to attempt the delivery deletion and branch on success-or-not, it would be much better to encapsulate this in a function, which returns a success indicator, e.g.: 

In java, you can just set the value at the given index using that index. Thus, starting out with the simpler update book (which uses the book object), this becomes: 

Some thoughts about your enum: First of all, your general approach is good. The very idea of putting the relation between days and the needed data into the enum is exactly what I'd do, too. But, alas, there are some not-so-good points: Enums should be immutable: You have a setDayNumber method in your enum (even public!), which could be used to mess up the whole structure of the enum. Instead, initialize the field in the constructor and make it final: 

Due to the comments below, I feel compelled to break my personal rule of not just posting code. Thus, here's a working (not thorougly tested) approach which uses the idea presented above. I hope that makes it clearer. (Note: succ == successor, that is the naming I learned at scool a long time ago...)