You can set up each group to contain states that work with states in such a way that they determine both what needs to be as well as what needs to be . It does however seem like a strange approach. Typically if you want to replace a node, you remove the old virtual machine altogether, and instantiate a new virtual machine for the new role. That way you make sure things are clean and don't risk arbitrary changes to have been made that might interfere with the new role. 

You're probably entering these URLs in this shorthand form in your web browser, and it's not guessing what you want correctly; it probably remembered from history that when you type "api.example.com" that it should use HTTPS, but for new URLs "api.example.com/whatever" it doesn't have history so it tries HTTP first. If you're using the same IP address for all of this, regardless of the fact that $URL$ is going to the process listening on the HTTPS port (443), $URL$ will still go to the process listening on the HTTP port (80). If you want to avoid this while keeping the same IP address, set up an api.example.com virtual host in the HTTP-only server that redirects every request it receives to HTTPS. To actually split them up the hard way, add a new IP address for api.example.com to the server and make the two HTTP(S) servers listen each on their own IP, and update DNS so api.example.com points to the new IP address. 

//Bridged Adapters//: This kind of bridging is the default for the Ubiquiti device I'm using. I didn't attempt to unbridge some of the adapters. I put the device into "router" mode, but it still has the adapters bridged. I'm not certain if I can change that. I think this is unrelated to the fundamental problem. ICMP Redirection This seems like what I need to get working. Thank you very much for all the advice. I cannot get inet_gateway to send the ICMP redirects. I believe the device is configured to send them, but its behavior suggests that it believes that it doesn't know it should be sending the redirects. Attempting a traceroute to station_d from station_a results in this: 

I'm trying to configure a router to forward traffic to another router on the same network (so that I don't have to configure static routes on each other machine on the network). Here's a simplistic diagram of the network. 

By default, nginx will honor the received from the backend for its own proxy cache, see e.g. $URL$ So it seems that the best solution would be to change your backend to stop emitting these headers in case of errors. If you really want to override those 500s in nginx, maybe use proxy_cache_valid with 500 and 0 as the parameters? It definitely means second-guessing the backend, so it could have unintended consequences either way. 

If you're just using a REST API, it will typically respond from the IP address that you contacted, otherwise the HTTP TCP connection wouldn't work. But if you're actually using a service that creates out-of-band TCP connections back to your original client IP, or some other IP, then the owners of that API need to expose the list of source IPs to you so you can whitelist them, there's really no better way around it. 

I would conclude that inet_gateway (Ubiquiti EdgeMax) does not know if should be sending ICMP redirects. 

Goal: I want to be able to contact station_d from station_a (without configuring a static route on station_a). I attempted to create a static route on inet_gateway, like . When that is in place, I can contact station_d from inet_gateway. However, I cannot contact station_d from station_a. Attempts to contact station_d get routed out to the Internet. It appears that inet_gateway doesn't know that it's supposed to route the traffic. The ping I send from station_a has the MAC address of inet_gateway in the ethernet header, but inet_gateway doesn't (appear to) forward the traffic to router_b. If I configure a static route on station_a (exactly like the one I made on inet_gateway), station_a can contact station_d. I don't want to have to maintain static routes like this on all the stations on the network, though. Is this kind of thing possible: to have a router "route" traffic through another router on the same network as the originator? Additional Information Here are the routing tables (IP addresses changed to match diagram and protect the innocent). The Internet traffic goes through 192.168.0.1/24. (inet_gateway) 

Unfortunately, this is where my practical, hands-on knowledge of how to set this up ends. I've never configured or ran any sort of standalone PPP server, aside from Worldgroup, which was just set up and go. It's also ancient history, thousands of dollars at the time for the configuration we had, and not a viable solution in your case. Odds are, the equipment there is speaking PPP, which Windows software exists to handle inbound connections for. Windows server editions almost certainly allow dial-in to with PPP and connection sharing. The biggest complication here is there's nothing in a dry pair telling the receiving computer to answer. This is also true if you insert voltage onto the line, nothing's setting the line 'high' to indicate an incoming ring. If dialing happens on a schedule, you can configure your answering server to just pick up the line every few minutes starting slightly before the scheduled connection time (or if they're in perfect time sync, I'd answer 10 seconds after the embedded system is set to dial). That said, a 486 could handle a dozen modems on Windows NT 3.51 back in 199x, so even if you are an all-Windows shop, Linux or other Unices are far better suited for this sort of task, and a $5 doorstop from Craigslist or Goodwill would handle this until the end of time, and would be the route I'd go. Required just-after-submitting edit: Even if you had to deploy this to every end-user site with this embedded system (I wrote the above with the thinking that all the embedded systems were in a shared location, which is wrong on re-reading), it'd be a phoneline-less solution that just requires a stand-alone additional piece of hardware acting as a glorified dialup-to-ethernet adapter. 

The current device attachment limits are described at $URL$ and for the currently most typical HVM instance types they include: 

So if the default config is a pool size of 20, out of a 100 connections total, this implies 5 distinct user/database pairs will have to each max out their pool size before they reach the overall limit. Conversely, if for example you're using pgbouncer to route to a single database via a single user, your effective connection limit is 20, not 100, so you have to set the pool size for that use case accordingly. YMMV. 

Here's a fairly simple Fail2ban configuration for PostgreSQL based on the HOWTO linked above but fine-tuned to actually work with Ubuntu packages, catch another error condition and skip over various debug messages to make it quicker: : 

There is an extended test mode, invoked with the command line option , which does this. For example: 

AT - Attention, prefixes any modem command. X3 - Sets modem to ignore dialtone. DT - dial with DTMF touch tones (DP would dial with pulse, like a rotary phone). 0 (zero) just sends the digit 0 as the chosen dial type, sometimes needed to actually pick up the line and do something, on some modems. 

All the receiving system needs to do is issue ATA (attention, Answer) to the modem to make it pick up and start trying to handshake. Then, it's just a matter of the connection being passed to a PPP-speaking service to relay the connection as needed. If you can get your equipment to dial into a plain line, and type ATA on an answering computer in a terminal program, get CONNECTED to display on both ends, and see text going back and forth over that connection, you would be able to leave the telephone company out of it entirely. When I was testing with dry lines and needed to have my connection picked up, I just configured my server to pick up the line with ATA in a loop, which will try to handshake with the dialing modem until the modem's timeout value (usually 60 seconds), drop the line and display a message (I THINK it was NO CARRIER, same as when you hung up, but I may be wrong - this WAS ages ago). 

You can set up a state which checks whether the home directory of the user is in the right place, and if not, executes some commands that move it there. Something like: 

When packets come in via interface X, and are responded to immediately by the same machine, then your source-based routing rule can catch the response because its source IP address will necessarily match the rule. When these packets are subsequently forwarded via interface Y to another IP, that first part of the communication will work. But as soon as the first response packet arrives from this other IP, it will enter the routing rule parser with its own source IP address, not this router's. It will then miss the source-based routing rules, and instead match the default lookup, which will be destination-based as usual. What you will need to do is to mark packets as they arrive on interface X, with this mark persisting across forwarding, and then match that mark in routing rules so a different outgoing routing table is used. 

Always Log CPU Usage for an Application "Name" During some phase of testing, I'd like to always monitor the CPU usage of my application. The application has a fixed name. I don't see a way in the GUI tools to accomplish this, since the Process class always wants a PID. Is there a way to create a data collector for any process with that name? It would be very convenient if I could leave it running all the time so that successive invocations of my app always get collected, including after restarting the OS. Clarification: I want to create the collector before the process ever runs, and I don't want to have to update it every time the process starts (which would be a requirement if I used the PID). I'm sure I could modify my app to create its own temporary data collector every time it starts. I like that idea much less than something external to the application doing the job. I could probably also create a service (or other style of long-running process) that looks for my app to start, then creates a data collector. The real question is: Does Windows have tools do to this job already? The best answer I'd like to see uses typical windows features and doesn't involve services or scripts I'd need to maintain. 

On your local DNS server, the one that your clients are directly asking, create a new DNS zone named and put whatever you need in it. Just make sure this DNS view is not exposed to the Internet. And that none of your internal users will ever actually want to see the real yourexample.com. :) If your clients are not using your local DNS servers, then either change them to use one, or do something fugly such as intercept all DNS traffic on your border gateway and transparently redirect it to your local DNS server. (Ugh.) 

At that point, if I wanted to destroy the snapshot, I first had to temporarily disable because of the bug described at $URL$ But even then, after seemingly successfully deactivating the nested LVM's volume group, the partition mapping for the nested PV, created by , somehow remained in use. The trick appeared to be that the device mapper kept an extra parent mapping using the old volume group name, like this in tree list: 

There are a few possible solutions to this, depending on just how picky the hardware in question is and how much control the embedded systems give you. My experience here comes from running a Worldgroup BBS on Windows for awhile, and from time working with TDD (as in Telecommunications Device for the Deaf)-compatible modems. I can help you on the hardware side, software-side's a little out of my league, but actually the easier part probably. A couple key concepts here: 

Other modems may require voltage on the line, which isn't difficult to do, but does raise the difficulty from "just plug it in" to "make a thing that provides voltage, and plug it in". I believe this thing (called a line simulator, for the purpose of Googling it) needs to put out 24V at about 24ma, but my electronics skills are hilariously rusty, and this link has all the details with the added advantage of not being my guesswork: $URL$ The modem dial string doesn't typically change here, but you may need to try something like "X3" in the init string to make the modem ignore dial tone state. For this, ATX3DT0 is a perfectly viable dial string if you can't change the actual init string, but can change the dial string instead.