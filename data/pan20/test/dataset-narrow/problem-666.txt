I don't care for empty quotes designating an empty string. It should be replaced with . It simply clarifies your intention and leaves no ambiguity that you perhaps forgot to put something in the quotes, or maybe even meant to put a space in there. Otherwise, I feel this is very simple and solid. 

Or forget all that and just use the newer SendMailAsync(MailMessage) method. Just be sure to await the result. 

And so on. With this method of creating new types of coloring schemes, you don't even have to open up the file. You just create a new child class and over ride . There is one more refactoring that should probably happen though. The "If style == alert then set background color" logic gets repeated in each and every one of these overrides. It could be simplified by extracting this logic into a protected method of your base class. 

Why do you have a method that returns itself as its base type? It should be up to the client code to cast this object, if necessary. I would remove that method. It's superfluous and "Ya Ain't Gonna Need It". 

Again, the names cousin... the names.... You have two subroutines here. One is named the other is named . I'm not even going to bother trying to figure out how they differ. You know, so you tell me by giving them descriptive names. Nevermind. I see exactly how they differ. They don't. 

You're not returning, so an would be more future proof here. It's not obvious whether or not you considered the other possible path of being less than zero. 

Yes. Yes. I know that it shouldn't ever be less than zero, but document that in the code by throwing an exception and leaving a comment saying that it shouldn't ever occur. This way, the maintainer will know that this possible (highly unlikely, but still possible) condition was considered. 

Please note that I do like that you're not using that Devil Between for your date logic. This is how I would write it: 

Either use the underscore convention or the keyword. Using both feels.. odd. However, that too is a style nit-pick and probably up for debate. Or maybe it's not as debatable as I thought. Right here is a case where using both obfuscated the code a bit. 

You inject the , but not the various repositories your requires. You should also be ctor injecting all of these dependencies, and using Ninject to bind them. If you can't inject it, you can't mock it, and right now you can't do either with your repositories. 

Then in the Getter/Setter, you'll transform the list into something bindable (personally, I like the ) and bind it to the datagrid. There's a great example of binding a list to a datatable and datagridview on dotnetpearls. So, we've gotten all of the from outside of the form and injected it in. Great, but what about all those pesky events? Well, we'll add some to the interface for the presenter to respond to. The will just delegate it's own events by raising 's events. For example, let's handle a selected record change. 

Now, I say this is naive only because we don't have to check each number up to . We only need to loop up to the square root of j. If j isn't divisible by a number less than or equal to its square root. It's prime. Go ahead. Go check. I'll wait. ... Pretty cool, eh? So, your inner loop would end up looking something like this. 

By doing so, you're tightly coupling the interface (not ) of your cache to its implementation details. I would prefer composition over inheritance. Then you could change out the underlying dictionary without affecting the client code. You're getting a lot of baggage along with the convenience. Look at how many interfaces and members you've just bound yourself to implementing forever. You might run into trouble if you decide to switch over to a ConcurrentDictionary, or some other mechanism entirely. I honestly imagine that your should look more like this. 

There's not much else to say. You generally write very readable code, so I won't bother with any nitpicks about style. 

First, we have no clue what this value is, other than it's some option of some kind. I recommend creating a well named function to retrieve this value. Secondly, the statement can be simplified by omitting . This is essentially what happens right now. 

This is an abuse of extension methods. is a class that you wrote. Extensions are for extending classes that we can't modify. There's no reason to write an extension method for a class that you have complete control over. should implement this directly. I'm going to risk some general hand waving here, but... In my mind, anything that's inheriting from or should be dead dumb simple. It should raise events and provide some properties that a separate class can set. Those properties are then wired into the actual UI for display. There's should be very little logic at this level of the application. That logic isn't easily testable when it's bound up in your UI. A more proper architecture would look something like this diagram. 

There's a small optimization to be had by only searching column D until there are no more values. Find the last used cell in the sheet and only search until you reach that cell. As it is, I think your code does many more iterations than it has to. 

A Bit About Regions Some people hate them. I'm not one of those people. I think that used correctly, they're a great thing. For example, I think this is a wonderful use of a Region. 

This is beautiful. It makes sense to group all of the different overloads together. This is a good use of regions. Unfortunately, you have some instances where it's not so good. Here, for example, you've wrapped a single method inside of a region. Why? What does this do for us other than clutter the code? 

I don't see anything wrong with the comparison in the example you showed. To me, at least, it looks like exactly what you need. I think that perhaps your issue with it comes from all of the repetition in your real code.