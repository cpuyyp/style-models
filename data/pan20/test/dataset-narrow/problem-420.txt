On the first match, when is a , will contain a reference to the . When we get to the loop, is now a reference too. Generally, when we iterate on a reference to a collection, the iterator emits references too. Indeed, is now a reference to a . Here, I wrote to match the dereferenced value (note that this doesn't necessarily copy or clone the whole ) because we bind values, which are cheap to copy, so we bind them by value, not by reference. Finally, let's simplify these nested matches. Let's look at first: 

If you were to take by mutable reference, rather than by value, then the original variable would indeed need to be declared as mutable. You could not invoke the function with only an immutable reference, because closures can't be invoked from an immutable borrow. If that's a problem, switch to instead. 

You don't do this in though. If you have a list of length 4, the call will look past the end of the list. That's a problem. One that's easily fixed by the same checks as above. You probably also want to validate the input for . You don't want a position as input, and neither do you want an input past the end of the list. 

However, in most cases, only one of the points of the simplex changes between iterations. So only one point needs to be re-evaluated. Conveniently, this re-evaluation is already done in the previous iteration: 

The second option above only works because you run the entire functionality of the class from within the method (which may or may not be bad form). When the new instance is created, the back and forth prompt is executed right away, so the moment it would go out of scope and get deleted (because it isn't assigned anywhere), is only after you are done with your input and output (and possibly been given anyother option to reset). 

Now, it's up to you to decide whether combining the two validations is worth the additional complexity or not! :) 

The parameter doesn't have to be a , it could be a slice instead (). However, if you had used a non- item type ( is ), then in order to return individual items from the input , you'd either have to the items or move them out of the (using ). You've implemented binary search by hand, but the Rust standard library provides a very flexible implementation via . 

Strings in Rust are encoded in UTF-8. Standard library functions operate on Unicode code points, so both the string and the separator can contain fancy characters. 

This is a bit confusing, since you're testing the date 8 days from now, but printing what the current day is. Why not just test if the starting day is from Monday to Friday, if that's what you mean: . Also, is True for values 2,3,4 and 5, but not for 6, which is probably not what you want. 

This means that you're iterating starting from the beginning again and again for every node in the list, i.e. doing \$O(n^2)\$ work, instead of \$O(n)\$ which would be enough for simply iterating over the list. The point of a linked list is that you don't need to know where the end is when you start walking it, and that you can hold valid pointers to the nodes in the middle and do something useful with them. Here, every operation starts from instead. For printing, I'd rather make a loop similar to when you count the nodes: 

You don't need to do that, since returns a , and is the maximum value. A condition such as would always be false. 

Additionally, considering the way you've written the prompt messages, it looks like there shouldn't be a newline after the prompt, so I suggest you change the that prints the prompt to a . Here's the revised code: 

Instead of having a mutable variable, I'd factor out the code that decides if a number is prime in a separate function. We can use early returns to avoid defining a mutable variable. 

Unfortunately, the way you've written , that's not true. The following test compiles fine, but invokes undefined behavior (which happens to manifest as the test passing on the Rust Playground): 

I changed the loop on purpose, I feel putting the test in the statement makes it more readable, since there is only one exit condition anyway. Also, you don't need a separate for , since does the test first. Always starting from head In addition to , the other functions you have, also always take the node. For this is obvious, and you might want an function too that can start from the head. But what about inserting in the middle, in an arbitrary point? The (theoretical) advantage of linked lists is that insertion is \$O(1)\$, and as above, always searching from the beginning thrashes that. So, in the least, you should add a function for inserting after a given node, something like 

When you move a value from one binding to another, the two bindings don't have to agree on mutability. It may sound strange, but it's valid to move from an immutable binding to a mutable binding. It's perfectly safe because in order to be able to move a value, there must not be any pointers to it, which ensures that you have exclusive access to the value. Therefore, you could write here instead of . The pattern is so frequent that Rust has a shorthand for it: the operator (and its predecessor, the macro). We could rewrite your program using the operator like this: 

You don't need to define the variable as mutable if you move it inside the loop and take advantage of the fact that and are expressions. 

This is a project I have been working on. This is one of my first experiences with Python and OOP as a whole. I have written a GUI that handles the inputs for these classes, but I will ask for a separate review for that, since the question would be rather bulky when including both. The goal of this program is to create standard SQL (SQL server) queries for everyday use. The rationale behind this is that we regularly need similar queries, and would like to prevent common mistakes in them. The focus on this question is on the Python code however. The information about the tables and their relation to each-other is provided by a JSON file, of which I have attached a mock-up version. The code consists of three parts: 

If you really need a , then you'd need to define as and write instead of . However, I would do this differently. I'd write a function to turn a into a slice of bytes (), which would encapsulate the only operation of the program. Then, we can use a simple loop on that slice to print each byte. 

Here, I'm using to convert the to an , because I'm too lazy to define an error type that unifies the parse error and our new out-of-range condition. Then I'm using to perform the range validation only if the parse succeeded. The closure returns if the value is in range, or if the value is out of range. Instead of using , we could also use the method provided by the crate. It takes a closure that returns a , and returns if the closures returned , or the original value otherwise.