Any help with this would be greatly appreciated. P.s - The base layer of tiles is rendering correctly just in case anyone was wondering, i just kept the entire base layer at tileID 0. *the plain grass tile you see in my output :) 

So i'm not quite sure exactly what "glow textures" are. For my implementation of a "lightning" effect, according to the comments on the article; $URL$ They guy uses "glow textures". To achieve the really cool effects on his beams. I'm trying to-do the same thing, except that i'm not 100% sure what a glow texture is, currently the texture i'm using produces this output *I'm also using a simple shader to adjust the color value the lightning is rendered at; $URL$ Which isn't very good, it has the shape of the lightning but it doesn't have the sorta "flare" of it. This is a screenshot of my current texture that i'm using: $URL$ So essentially what i'd like to ask is mainly what is a glow texture? And perhaps to see an example of one would be really appreicated. Edit: Taking the advice of kaoD, i'm now rendering the using Additive Blending, I've also got the Max Blending working, yet, still the bolt's do not produce the required effect that i'd like. Here's another video of them in action with the current code; $URL$ And here's specifically how i'm rendering them; 

Can that be done? Or is it only the "Asset" element that can have the Type definition? Currently this is what my new data layout looks like: $URL$ But currently, it seems to start reading it but i get this error by the first "Tile" Element. So the only difference i see between his & my layouts are that he has the Asset containing the List definition whereas i have "Animated_Tiles". So i'm unsure can any element can have the "Type=Blah" definition? 

There is always brute force solution if you find yourself stuck and speed is not priority (one-time generation). In you case simple BFS/DFS might suffice. Just pick a node of desired type(either land of water) and continue your search, finding all tiles of same type within the graph(terrain part). Continue while there are any nodes not visited. 

Yes it is possible. And it is called texture. Textures are not just pictures - it can be any kind of data*. Another option would per-vertex data - if you dont mind smooth border between (un)explored. Or just as other post suggested - pass it as per-tile uniform. * Ofcourse, you need to stay in reasonable array size, defined by maximum texture size. Also note that editing such texture would mean sending it all over again, which could be slow. 

Because of that, I suggest you use greedy/look ahead algorithm, finding not optimal solution but some "good" solution instead. For greedy you just always pick closest location, for look-ahead you look at the length of next one too (and if you looked more and more ahead, it would turn into near-bruteforce described above, so better to limit it). 

because the vector is normalized and, naturally, points upwards you just need to check its length in Y axis(or the "up" axis if you use different one). It will be 1.0 when perfectly up and -1.0 if perfectly upside down. This simple code will suffice - if you don't require exact angle, of-course(you can still compute the equivalent Y threshold value of angle should you require it). 

What I think you need is to create a object that will allow you to set up players position and orientation. Next, connect a object as a child of so it moves and rotates with your main object. Then connect a as the child of so it moves with , but can rotate in its own local space, so you can rotate a head. At the end connect a as a child of the and move it backward by some amount. This way a will be always at some distance from the , looking at it, regardless of the orientation. 

It's not a full answer, but it's too long for a comment... From your question I presume you want to use a LOD system (geomipmap approach) and you're creating your mesh by cube subdivision, so why not to think about a LOD during both stages - mesh creation and rendering? You start from just a 6 planes, so it's really easy to tell which sides are connected. Then, when you subdivide one of the planes you know which neighbors are at the all 4 edges. You can also store the newly created, internal edges. This way you can create a hierarchical, tree-like data, where you start from 6 quads and every quad have 4 child quads. Having such data you can easily iterate over all LOD levels. You can even store the mesh data precomputed for all LOD levels, or you can create them on the fly, depending on camera move. There are really many possibilities here, but I can't help you more as I don't know what data are you going to need for your algorithm to work. 

the size of one times number of s. Moreover, there is no need to keep incrementing the (also it should not be floating point type if you count integer number of elements) because you can get the element count directly from vector: 

I believe the solution is simple - mark vertices of the path as impassible and run regular Dijkstra for this input. If it fails to find a path you are sure they are on different sides. Edit: If your path does not split the graph into two components you can still use method described above with only difference - after finding the shortest route check whether it contains endpoints of the path. If it contains exactly one endpoint, you know the points lies on different sides (if it contains both of them, you know it went "the other way around", in example given in question it would take the bottom path, points still can be assumed on same side). 

You effectively answered your question: you want to move the boss towards the player Y, leaving X and Z unchanged. To do that, create new vector and give it X and Z from current position and Y from player position: 

This is the closest you can probably get - to use lambda expression as Action - as far as I know you cannot implement own scopes (code blocks). Upside of this solution is you dont need add new named function for each action. note: I did not checked syntax, if you see syntax error feel free to edit or comment the correction. 

I'm not sure it's your exact problem but I had similar issues. It looks like Blender doesn't generate coords by default. Even if you can render your object with texture in Blender - it doesn't mean you'll have in the exported mesh. You need to explicitly add some UV channel - I don't know Blender very well so you need to look for some tutorials for this (But it's very simple, if you know where to click). In 3D MAX, when you create a basic object and select you'll get the out of the box. There's also a simple way to verify if that's the case. When your mesh doesn't have an channel but it's used in the rendering, then your values will be set up to defaults - which means that some corner texel will be used as a texture for entire object. Now, if you move or change your texture, so texels on the corners will have different color - your mesh should also change the color during rendering. 

I think the simplest way is to divide your terrain into grid and manage which grid tiles to load/unload. Let's assume you want to have 3x3 grid all the time, with one center tile under your player, and one additional tile in each direction. Now, during every frame you check if your player has moved to another tile and if so, you load new tiles in the direction of movement and unload the tiles that are too far away. After this load/unload phase you'll still have a 3x3 grid centered over your player. I can't make you a fine picture of it now but here's some sketch: link This way you can manage quite big terrains but there're some problems you should know: Tiles connection You need to make sure that the shape of some tile at its edge is the same as the shape of its neighbor (the second tile that shares this edge) or you'll get holes in your terrain. It's quite easy if you use procedural data, like Perlin noise but it's very hard to model such meshes in 3D modelling application. Grid size and scale You can split your grid into 3x3 or even 10x10 tiles. Every tile can be few meters in size or i.e. 1km - all this depends on your specific needs. If you manage many small tiles your load/unload times will be smaller but you'll do it more often. Additionally, when you make game like a flight simulator you'll need different setup than for FPS. Deferred loading It's not a 'problem' but I've seen some interesting optimisation that I could share. It was in the Terrain Manager for the Ogre engine. It was also grid-based but much more complicated, with Quad-Trees, LOD, tile stitching, etc. The trick was done during load/unload phase, where instead of checking they checked then the Manager loaded only this one tile and returned control to the engine. In the next frame Manager did the same check and loaded 1 another tile. In this simple way you can split your loading into multiple frames, which lowers your FPS variations. 

There is a sweeping algorith for this with logarithmic complexity, precisely (n+k)log(n). The algorithm is described as follows: 

tip: automate the process by creating a function like see any "transformation composition" tutorial for detailed explanation. 

This way, level 50 swords can be anywhere between (low quality, low randomness), (lq, hr), (hq, hr) or (hq, lr), all equally likely. Or even all not equally likely(if you chose to use non-default distribution). 

I would pick any point on the shape* as starting value of extremes and iterate over all other points on shape testing whether they lie on left/right side of line from P to left/right extreme respectively, reassigning value if new extreme is found: 

The speed itself is correct. Because FPS = 1/dT. On tablet it is ~29.8FPS, and on xperia it is ~7.45 FPS. In 1 second the object travels updates count times pixels per update. That gives ~626px for tablet and ~640px on experia. The error above was caused by once in the process (="once per second"). If the position is stored as integer(rounded) the error will start to accumulate and keep growing each frame! There is also the that fact actual number of updates per second is integer: For example with given integer speed xperia with (constant) 7.45FPS can do either 7 or 8 updates giving you either 602 px or 688 px, likewise the tablet will give either 609px or 630px. If the FPS is not constant (which is not in practice) the results can be even worse. My suggestions: 

If I understand it right, you are asking how to extract bites of one bitmask and set it on the other, for example : 

In a typical shaders, no mater if it's a vertex or fragment one, you have somewhere a dot product between light direction and surface normal. Then you have a check if the result is less than , which means your surface has light at its 'back'. Now, if you compute instead of just you should get lighting on both sides of your geometry. 

If your objects are not animated I'd make just a transform animation between first and the second. When you want to change the objects you just play the animation and stop at the end. If you want to change back, you just play the same animation backwards, to . When you objects have their own animations it gets more tricky so in such case I'd make separate objects and replace one with another when transition animation ends. This way you wouldn't have to worry about too many animations at the same time, in the same object. According to different types of controls: Implement both in your game, so you can play as the ice cube and as the water (with selection at compile time for now). Then store somewhere your current player mode and in all your input methods like MouseMoved, KeyDown, etc. add a simple and select which of your controlling code to run. 

I'd consider a grid as a "base" type of tiles in any game. Such grid is simple to imagine and moves over this grid are simple to understand. It's also very simple to implement "under the hood". Those are few reasons why even the Chess game uses it :). Additionally, this grid helps you make "regular" levels, because and are natural directions here. So if you make, let's say a SimCity clone it's very easy to have perpendicular roads. The biggest disadvantage of grids is that they doesn't keep distances very well, because when you move by one tile in directions you basically move by one tile size, but when you move in directions like then you'll move by . It's not so big problem in computer games but it was a big flaw in board games. Because of this problem people tried to find some other way to divide 2D space, so the movements between tiles would be more similar to the real movement. It happens that the only possible way, better than squares is to use . grids are much better for strategy-like games because movements are more natural, but they are much harder to implement. They have also 3 main directions, where one of them may be OR but not both! So try to imagine a city with perpendicular roads built on a such grid... Personally, for a game like I wouldn't think much and used . In fact, I'd use squares in every game that is not a turn-based tactical game. But depending on your taste you need to choose your own. Maybe you'll want to make a one-of-its-kind, clone :) ? 

I would look at the problem differently: I would use navigation graph instead. I would "bend" the original navigation graph to your problem - each junction is a node(with 0 radius), and each edge stores its length and its direction. Player navigate on graph instead of in a world full of solid walls. Player can move each frame at desired speed along edge he is on if either "correct" direction button is pressed (note this could be generalize to support 8 or more directions). Another benefit is that generating such graph is trivial for uniform grid (any flood-type algorithm will do). 

first, you create appropriate mask by shifting single color mask to correct position (alternatively, because it is static value tied to source pixel format so you can pre-compute it), then you extract all bits of the color channel by and shift them to get the value . After that you shift the value to its correct position in BGRA8888 format and last you or it with zeroed BGRA8888 pixed . You can skip some shifting if you know the formats in advance and hardcode it. 

I am not aware of any social studies about this. But good rule for happy player is do not force them to do what they dont want to. As for tutorial type help, many games have a checkbox "stop showing tutorial tips" or something similar on the popup window, and option in game menu to re-enable it later. In Trine there was also an option to show puzzle hints after x minutes stuck on the puzzle.