This is one example of a place you could use another function. You can split that off into an function, perhaps, and call that by itself and get rid of the // structure at the beginning of , replacing it with something like this: 

Make a field for and only assign it once. Each time you use it, it reseeds itself so it will really be random. You are using the local clock to seed it here, so it will product the same value if you call it twice in a single second. 

I originally wrote this well before C# 6.0 came out, but if I were to re-write it today, I would use C# 6.0's string interpolation feature. This would allow me to replace: 

I'm not sure what is going to, or should, happen if neither the nor the statements execute. Should there be an statement in there? 

For your test method--use a unit testing framework and actually write a unit test. You basically have a test here that you have to explicitly call and examine the debug output (this test only works in debug mode!) to see if it passes. A unit test framework can be found by the Test Explorer in VS or R#'s equivalent, run by the framework, and gives a clear indication, along with potential error messages, of whether it passes. 

I really like how you use the HTML5 element instead of using the old style When people write CSS, they often format it slightly different, like this: 

Your code is a very neat as a general rule, but your style is a little off. C++ typically uses braces like this: 

In , you should just return the result directly from the switch. Don't assign a variable, then return at the end of the method. 

You can solve this problem in one of two ways - starting with , or changing your loop to use and intializing it to , like you currently do. This will have value be stored in the index of the array, so all values will be set to once all the numbers in the range of 1 - 99 have been entered. 

Of course, you might want to encapsulate above code in a function or even more versatile, a generator function and replace with . However, since you only have four different step-sizes of 1, 10, 100, and 1000 you can encode them manually and come up with an even simpler generator function as follows: 

Create a circulant 10 x 9 matrix where each row is a circular shift of . For each round or column, replace the self-match with a match against team and let team play against the self-matched team. 

While there are exactly 945 different ways to partition 10 teams into pairs and thus many more ways to generate a correct schedule, I could not come up with a simpler or more intuitive schedule. 

I recommend to follow this 'natural' structure and solve these two tasks independently. Generator functions are a great tool for untangling your seemingly interwoven code and pushing individual functionality into their own reusable, testable functions. They are especially useful when you are not interested in storing intermediate results but rather want to directly process (e.g. print) them: 

I recommend removing the inline event handlers from your HTML document for a cleaner separation of markup and logic / JavaScript similarly to how you separate markup and style / CSS. You can then add all event handlers with a few lines of code as follows: 

We can then replace the large string concatenation expression by leveraging one of those array's or method: 

I like your idea of counting character frequencies first. This allows you to count the required deletions in linear time. Your code is readable, but readability can be improved by more semantic naming and leveraging modern JavaScript language features. Naming: Regarding the variable names , , , , : Those identifiers mainly include type information (, ). But as a reader, I am more interested in the role of your variables instead of their type. So instead of I would prefer to read or even . And instead of I suggest the simpler . For-loops: First of all, you probably forgot to declare the local loop iterator in . Unfortunately, those omissions can introduce very hard to trace bugs as you now access and potentially share a global variable . Also, JavaScript arrays and strings implement the iterable protocoll. This means you can iterate over them using a simpler for-of loop: 

PEP8 Your code does not follow PEP8 standards. This is the recommended style guideline for Python, and most Python programmers follow it. 

Most people probably know what is. Also, your comment above could become a documentation comment. A doc comment is used to supply information to IntelliSense tools and can also be exported to other files if needed. These comments look like: 

It is a good idea to use consistent styles throughout your code. Right here, you use braces around a 1-line / block: 

In this block, you are catching the exception, then returning the exception to the user as a piece of data. A better way to do this would be to just not catch the exception and let the caller catch it: 

This makes fewer (by half) the lines of code to maintain, not counting braces. Also, notice how I put braces around my code to help prevent errors. Romoku also make very good points about renaming your variables to reflect what they are doing better. 

Nested ternary conditionals are ugly. Ternary conditionals nested three deep are ugly to the third power: 

Because the sole responsibility of is to create a list of strings, I would pass that parameter as an parameter to signify this. Then, instead of adding the values to the passed list, you create the list with the values and assign the new list to the passed list. 

Given the nature of the game, the odds of this happening are extremely low, but your algorithm does not seem to weight the squares to follow this pattern. Finally, once the board gets filled when playing with the keyboard, nothing happens. When you ask for a hint, it returns "undefined". Perhaps you should implement win/loss situations to cover this scenario. 

I'm not sure why you throw an unhandled exception in Main to make your program crash here when an error message and would suffice. On the other hand, why are you limiting the number of invalid input the user can enter at all? If I understand this correctly, they get 5 invalid inputs total, but otherwise they can input as many values as they want? Why make a limit at all? 

Especially the last two changes are subject to personal preferences - some prefer the declarative style, some stick to everywhere - it's your (team's) choice. 

That's it. I don't see how we can leverage any other built-in method to shorten above task. Using JavaScript's built-in gets us pretty far, but it is missing timezone offset and millisecond options and introduces unwanted separators: 

A function declaration is a bit simpler and more robust regarding hoisting compared to a function expression which assigns an anonymous function to a variable. Supplying as the first callback parameter on success is a bit quirky, either always supply the HTTP status or fail silently without calling the callback. If needed you can always introduce an error callback which might be called on , too. The parameter of xhr.open defaults to and can be removed Your function could be split into a generic function and a function which supplies the specific ad URL to the former. Your current callback requires knowledge about the specific JSON returned by your ad server. This logic should be part of your "rw-ads.js" library and e.g. become part of the new function. 

Also, it is not clear how strong the given assumptions are and whether or not violations of those assumptions can occur and should be dealt with. 

This is the resulting correct schedule with all swapped matches highlighted in red. This schedule is identical to the one you compute and pretty simple to generate: 

A better design would probably have the attributes on the colored buttons and not on hidden elements, introduce a mapping between pad and audio source and leverage the web audio API instead. Using shapes instead of heavily styled s for the UI might further simplify your markup. 

Let's build a schedule for 10 teams. I intuitively came up with the following circulant 10x10 matrix with entry denoting the opponent of team in round : 

Consider a class instead of 2D arrays Mathematical libraries implement matrices as a class. Internally, the class may use 2D arrays to store the data, but client code shouldn't depend on how that data is stored. A class can hide the implementation details from client code. Extend to non-square matrices In general, an \$N \times M\$ matrix \$A\$ can be multiplied with a matrix \$B\$ if \$B\$ is \$M \times P\$ (\$A\$ has \$M\$ columns and \$B\$ has \$M\$ rows, but otherwise the two matrices can have different dimensions). With a function template you can easily extend the multiplication function to support non-square matrices. Simply add the necessary template arguments and tweak the algorithm to use dimensions other than . Here's a demo: 

I'm still learning how to use the full power of C++11 and C++14 since I was using a pre-C++11 compiler for a long time, so are there any C++11 or C++14 features I forgot to use which would improve the code? I'm not very comfortable with move semantics yet. Are there some optimizations I've missed because of that? I've provided no functions to modify the internal data of the class (it is immutable). This simplifies the class design a bit (e.g. I don't have to check that at least one of the minimum/typical/maximum values are defined when modifying the instance -- I just have to delete the default constructor). However, in my usage it has occasionally been inconvenient to not be able to modify a instance after it's constructed (e.g. to acquire a instance with limits taken from another instance but clamped -- I have to copy it instead). Was my decision to make the class immutable a good one, or does it limit its usefulness? It would be nice to detect if the code is being compiled by a compiler that supports and use if so, or try to fall back on if not. Is there a way to do this without too much difficulty? 

Since the worst-case runtime complexity improved from quadratic to linear, we see major performance improvements. The runtime is dominated by read query maximum retrieval speed. 

It is not obvious to me why the arguments and are given as instance properties and defined within the constructor function. By doing so, you create a stateful object which is more difficult to understand and test than e.g. a simple 'pure' function. Also, by setting the flag, the semantics of your method are no longer compatible to the meaning of . How about two methods and ? The suffix indicates that the return value is a complex object containing index and value, comparable to e.g. or . Those established methods iterate or return arrays instead of objects, so you might want to consider following this established pattern, too. Instead of passing an flag and relying on instance properties and I suggest a method signature such as and passing (or not passing) a delta argument. I would replace the many for-loops with a single . You would then have to lookup and and return either one depending on the given flags. Don't forget to test for the corner case when and consider handling it appropriately. If you had to handle more than 20 values, I'd implement a binary search and - if the number of queries for a given array of values is large, built a binary search tree first. This would improve runtime complexity from linear to logarithmic. But for just up to 20 values, the built-in or even an explicit for-loop is surely faster. 

See also Is JavaScript a pass-by-reference or pass-by-value language? Now, if we look again at your implementation, we note that you already perform a regex test. We could perform a regex matching instead and get rid of all those redundant calls. I wrapped this new implementation in a documented function and ended up with: