Finally, you asked about the data format. Which data format works best really depends on how much data you have and what you plan to do with the data. For instance, I wrote a script a while ago that worked with a CSV file with five million entries, extracting around 48,000 of them. It took about two and half minutes to finish, but for the kind of batch use it was intended for, that was fine. I could just collect the results into a new file and use them. If you intend to do frequent lookups, it's hard to beat a relational database for speed. Python has built-in support for SQLite3, a lightweight relational database. A simpler option that avoids extra software is Python's module; see $URL$ If you intend to pass the data round over a network, JSON is a good choice, and you can store the JSON in SQLite or Postgres or MongoDB or numerous other places. There might be cases where XML is the best choice. It really all depends on what you want out of your data store. There are lots of cases where CSV files are perfectly fine; they have the advantage of being human-readable and very easy to parse, for instance. 

Here's a gist with the rest of the code, including the private helper methods. Although the current code is Java 7, I plan to switch to Java 8 in the near future, so suggestions for where I could make good use of Java 8 features is also welcome. 

Your code is written in a very Java-like style: your methods don't return values, but operate by mutating class instance variables. There's nothing wrong with this per se, but it does have some negative effects: 

I've assumed some parts were moved into helper functions. In particular, I'm envisioning as a single function which takes into account everything that affects the power, and the whole part that calculates the effect of the Enterprise's attack on the Klingons has gone into . I once again rearranged the code to return, essentially, a diff between the old state and the new state, which can be used to modify the global state at a higher level. I find this a bit cleaner and more purely functional than using directly inside the function. I just recently discovered the function myself. It's exactly the same as , except it automatically removes from the sequence, so you don't have to do . There's also to replace . At the very highest level, I recommend finding an alternate scheme for the game state. James Hague says "In a functional language, the worst thing you can do is create a large 'struct' containing all the data you think you might need for an entity", and argues why, in Purely Functional Retrogames Part 3. His performance argument is not totally applicable to Clojure, because of structural sharing and transients, which the compiler uses to minimize copying and allow some mutable state. His arguments about flexibility and clarity, though, are worth considering. Using a global game state is inflexible because I have to figure out before I write a single function how I'm going to store that state, since I have to bake how I access it into every function. With your current code, if you decided to change from using an atom to using a ref, or a record, or just a plain map, or a Java class, you'd have to go through and change every single to something else. The state access API I suggested (the and macros) helps this a little, because you can just change those macros. But using a global game state is also unclear, because seeing that a function takes the game state as an argument gives me no insight into what it's actually doing with the state and what parts of the state it really needs. When I see the call , I gain no insight from the arguments into what does, whereas I do get some insight from or . My first thought for how to represent data would be something with deftype or defrecord. These are lean, vaguely object-oriented structures which can be used much like maps, but can also implement protocols, which are sort of like interfaces in Java. I might have a record which holds essential state like energy and damage, and implements a protocol that contains various functions which calculate other pieces of state, like power, the raw damage its weapons can produce given the current state, and whether the ship is capable of going to warp in its current condition. The Enterprise would be a single record of the type. I might also have a record that implements the protocol and the protocol, which would create functions that only enemies need to have. That way, we have functions that take or instead of just . 

Not to be excessively negative, but the solution in the C# code is much cleaner than the one you implemented. No shame in that; it happens to all of us. But I assume you wanted some advice on making the code you have run faster, because if you just wanted to copy that C#, you easily could have. So that's the direction I'll go with the rest of the answer. It honestly puzzles me that this code is so much faster than yours. I would have expected the BigInteger math to be the really slow part, but this code does the same amount of BigInteger math as your original code. Your code does take quite a bit more memory, since it stores all the Fibonacci numbers it calculates, whereas this code only stores what it needs to calculate the next one, and uses an integer to count how many Fibonacci numbers it's seen so far. An array list is backed by an array, so actually accessing the items shouldn't be much slower than with a plain array, but there might be some kind of cache or memory allocation effect. With this code, the compiler can block out a single, static chunk of memory. In the original code, the that stores Fibonacci numbers keeps on expanding, so the backing array might have to be reallocated several times. Every time the array is reallocated, everything stored in it has to be moved over to the new storage space, which is pretty slow if you have a big list. If that turns out to be the problem, you can try passing the constructor a guess for big you think the list might get (the default size is ten). If I were you, I would profile the code and look for some issue like that. Dig into the implementation and see if it's spending a lot of time reallocating. Just see where the code is spending its time, and try to figure out why that's where it's spending its time. If you don't already have a profiler you like, Netbeans has a pretty good one built in, and I'm sure Eclipse and other Java IDEs also have them. If you profile and post some of your numbers, we can probably give you better help with diagnosing performance issues. EDIT: @ChrisHayes discovered why the code is so much slower: it's the call. I took the original code and just replaced the call with a check against a limit of \$10^999\$ as the C# code does. Still used the array list, still stored all the Fibonacci numbers. As Chris Hayes observed, this reduced the runtime from about 900ms to about 13ms. The author of this blog post also found that was quite slow. An answer on this page implies that BigIntegers are stored in a way that makes it easier to implement the method that lets you convert a BigInteger into other bases, like hexadecimal or ternary. One could apparently implement in a more specific way that makes it quick to convert into a base-10 string, but difficult or impossible to convert into strings in other bases, but the standard library implementers chose a representation which was more general, but slower to convert into a string. See the end of the answer for my final version of the code, including modifications I made to get rid of . [/EDIT] Aside from the performance issues, I had some readability issuesâ€”not that your code was unreadable, just that it was harder to read than it had to be, and that contributed a little to the confusion that we had over where the number 4872 was coming from. The biggest one is the variable . Unless you're working with coordinate axes, please don't call variables . The C# code gives the analogous variable the name , which is better, since you can tell it's probably some kind of counter. In general, that C# code is quite clean, so it's a good model to learn from, though I'd probably just go all the way and call it . could also work, since it's traditional to index the Fibonacci numbers with . (This is another reason why is confusing; if I'm reading a program about Fibonacci numbers, I can process or the like pretty easily, but is just strange.) I also found your use of the do-while loop with a boolean flag confusing. A or loop with a statement would have been better, but I think the best would be to let the do-while work for you, and write something like this: 

Overall your code looks pretty good. It would be nice if you broke your lines, though; they're very long right now, so I have to scroll horizontally to read them. You also mix naming conventions in a somewhat weird way with . It would be better to stick with one convention; you've chosen camel case, so or . is quite long, and the nesting gets pretty deep, so it might be good to try and break that out into separate functions. I'm not sure why , , , or have to be instance variables (which they are, if you write ). It looks like you're defining and using them within just one method, so they can be local variables. 

A program like this, that seems to be a command line utility, is probably better served by taking command line arguments than by interactively reading filenames. That's the next direction I'd go in. The simple way to do this is to read . If you've ever done bash, is the script name, just like , and are the positional arguments passed on the command line, just like , , etc.: 

which takes advantage of the fact that gets initialized before the loop condition is checked. The class has built-in constants for zero and one, since they're so common. So you can initialize your array list like this: 

Even if this function is only used once, the code inside is ugly enough that the call site will look nicer without it. The same is true for a lot of the calculations in the main of . You asked where macros might have been helpful, and I see one obvious place. You have the code and all over the place. You could write a helper function or macro to shorten that up, maybe something like this (as a function): 

would call with as the value of and as the value of . The more complex way to do this is to use the module from the standard library. If you're sticking with all positional arguments, then reading directly is probably fine. You can do something like