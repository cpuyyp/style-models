When run with a local network time server, can achieve accuracy of . When run over the public internet, dynamic and potentially asymmetric routing of packets contributes to a poorer estimate of network delays. However, you can expect accuracy of well under with most documentation claiming an accuracy of over the public internet. If you need better synchronization, without better accuracy, you may consider running a local NTP server to synchronize multiple raspberry pi relative to each other with better than synchronization (good for aligning sensor data) . If you need both accuracy and synchronization, you can run a Stratum 1 NTP server using GPS as the time source. 

The likelihood of physically damaging an SD card from hard power off is rather low and usually requires additional extenuating circumstances. What tends to happen is file system corruption if the power is pulled during an interaction with the card. Most file system operations are buffered by the kernel. The kernel schedules synchronization at convenient time, so there is a small chance of an ongoing file system operation at any time. When you are at the boot screen, the system is completely booted, any services you are using are already running, there is no logged in user, but most of the system functions are operating the same way they are at any other time. 

Details The utility and do not provide a system header, but inevitably they probably use standard linux ioctl calls through the (or, possibly, ) interface to configure the network interface but do not have their own API, possibly they interact through other kernel interfaces, its hard to tell from first look. You have two options that I see 

The most likely outcome is that you have a hard crash or lock due to bit errors (The likelihood of a register, gate, or sram node flipping of its own accord is proportional to the junction temperature) . As far as I can tell, There is no default mechanism for thermal shutdown enabled on the raspberry pi kernel beyond throttling. Since RPI lacks hardware shutdown, the effectiveness of any shutdown mechanism in preserving the CPU is limited. 

You can test you connected or not. Try , if it says 'unknown host' this time try (195.175.114.131 is www.nba.com actually) You should see output from ping command if your Pi connected. If its not connected, it says '' 

You can use DAAP protocol to listen music from your Pi while not in your local network. For Pi, you have to install "mt-daapd" daemon to your Pi distro. Then use ssh port forwarding to add security. With ssh forward your port (6689 by default daap) and use any Daap client such as iTunes, MPOD for iPhone etc. I have wrote a blog entry realted to this issue, but sorry it's in Turkish :) $URL$ 

You can find which HTTP server running on your Pi with in different ways. Because we interest with HTTP server, we looking for port 80. It's default port for web services but it can be change by administrators. with netstat command; 

Your RPi can't find correct 'boot device' when you plug your USB HDD. You can tell correct boot device name to Raspbmc installation via /etc/fstab file content like this. I'm using BerryBoot with 4 linux distributions installed on USB stick ant is my /etc/fstab content: proc /proc proc defaults 0 0 UUID=8208bc76-64af-4f8c-8fc0-96aa106f3dc2 / ext4 defaults,noatime 0 0 UUID="8E9420D19420BE19" /media/MAXTOR ntfs-3g defaults 0 0 UUID="D020C19620C183C6" /media/SAMSUNG ntfs-3g defaults 0 0 To find out UUID for devices use 'blkid' command. 

I am using a Python script and Dropbox to put pictures which taken by my RPi server to my dropbox account. So when RPi takes picture Dropbox sync it to my computer automatically. Also i am using a Pushbullet service call to inform me about taking a picture. (You need to login pushingbox.com and create a scenario for this.) You need 2 scripts; 1) dropbox_uploader $URL$ First, download then run dropbox_uploader to configure it. It will ask for your dropbox credentials and path for pictures. 2) shot-pushinbox-dropbox.py 

Use a Screw Terminals Bare wires can be robustly attached using screw terminals, there are many HATS and adapters that allow one to use screw terminals for connecting GPIO Pins on Raspberry PI 

Current Loop Analog Industrial Controls using control, is reliable for many Kilometers. And is the professional way of solving this control problem in the analog regime. Instead of using voltage you use current sources and sinks, which will compensate for any cabling resistance. The range is an industry standard and you will find many thousands of devices that support this signaling mode. 

Messing with SPI/I2C extenders for those distances is going to be an unreliable monster. Instead Consider the Following alternatives. Kelvin Sensing Using basic 4-wire (Kelvin) sensing you should be able to reliably measure a 0.01V in a 5V FullScale (1 Part per 500 aka ~9 Bits) with a remote differential ADC. This is likely sufficient for your application. The principle is that there is no current flowing on the wires going to the ADC's, no current = no voltage drop in the cable = no effect from the cable impedance. This is a reasonable assumption for cable impedances and slow signals (~1KHz) with software averaging. 

simulate this circuit – Schematic created using CircuitLab Logic Levels The reason this scheme works with devices is that I2C does not use , but is an open-drain bus. Which means So the pins will drive to for , but only "float" the line for , with the voltage set by the pull-up resistor attached to the bus. logic is generally sensitive to inputs, but this is not always the case, you should always verify with the datasheet of the touch screen, or test empirically. There is a very high probability it will be fine. The very first CMOS logic devices had high thresholds for 5V, they have been superseded, occasionally you find one in the wild. Most 5V CMOS input devices made in the last 20 years are sensitive enough to respond to inputs. Device Safety As a slave device there should be never be a condition where the touch screen drives the Bus HIGH, sometimes devices are wonky and terribly designed, so you may want to check. To protect the bus you can insert zener diodes that would clamp the voltage to 3.3V, as shown in the schematic. NOTE These diodes are required in the opposite configuration with a master with slave. Because, for example, there is a good chance that a arduino will drive the bus because of a software bug or mis-wiring and destroy a sensor. So in this case the zener clamps are critical to protect your devices. Translators Using BUS translators can be problematic with an open-drain bus. You have to be careful with selecting an appropriate device that is open-drain outputs and not active drive. There are translator and bus coupler IC's that are aware or have an open-drain topology, but they must be explicitly picked. uses a simple method to detect bus contention. Since and , "beats" . If two devices try to communicate on the bus at the exact same time, the first one who tries to write a to the bus while the other writes , will detect that the bus did not change ( wins in rochambeau) and stop transmitting. If a bus translator is driving and some device tries to use , this will cause a short circuit. If you absolutely have to bridge an isolation barrier, or communicate with multiple devices at different voltage level, you are better off using an i2c extender IC over a simplex active bus like SPI, which can be safely bridged with simple one-directional translators (even opto-isolators will work for low speeds) 

You can't run a program which need run on X via /etc/rc.local file. You should use LXDE autostart configuration. Commands globally executed are stored in the /etc/xdg/lxsession/{profile}/autostart file, and in addition, other commands can be locally specified in the ~/.config/lxsession/{profile}/autostart file. If both files are present, all the entries in both files will be executed. $URL$ • Create the folder /home/pi/.config/lxsession/LXDE • Put a file named autostart in this folder, specifying the full path of the file to be executed: e.g. python /home/pi/pirun.py • Make the autostart file executable by chmod +x /home/pi/.config/lxsession/LXDE/autostart 

You can do this with Apache Rewrite Module. By default Apache comes with rewrite module installed, if don't please do this. 

After doing that run /etc/init.d/networking restart command or reboot your Rpi. After setting up unplug Rpi from router than plug it into Windows7 wired ethernet. At this step you can try ping the Rpi from Windows7. If it pings everything is ready. 4) Bridge wired and wireless adapters in Windows7. 5) SSH into Rpi from Windows7 and test if Rpi connects to internet. 

You can try to use Wowza Media Server stream to Web/iOS/set-top-box clients. Your Pi just will encode video from raspicam and send to Wowza Server via RTMP as FLV container. This command will send Pi's camera stream to Wowza with some parameters and it should work without problem. 

On iPhone you can select any minidlna client app to install. I use that one $URL$ After installing the app on iPhone, be sure you're on same wireless network with DLNA server, search the network and find your DLNA server and media folders to view. 

Rpi can't get dynamic IP address from your Windows7 laptop, because there are no DHCP server running on Windows 7. You have to set static IP address on Rpi which is in same network with Windows7 laptop. Step by step instructions. 1) Connect your Windows7 laptop to network via wireless ethernet adapter. Note the IP address. (Let's say its 192.168.1.10) 2) Give a static IP address to Windows7 wired ethernet adapter. This IP address should be on different subnet than wireless adapter. (Let's say it should be 10.0.0.10) 3) If you haven't monitor or TV that connected to Rpi, you should connect Rpi to your router temporarily to set static IP address on it. Let's say it should be 10.0.0.20) 

Yes, that is part of the trade-off. Is it "stupid" and "pointless"? Well it depends on your requirements... A thread adds much more than just memory usage. Every time you have a context switch from one thread to another, that may be up to several milliseconds of wasted CPU time in the kernel to handle the context switch. In time sensitive applications this is much more crucial than memory. In any case, this 1MB usage is likely not true , I suspect you are misinterpreting shared memory or caching reporting. An empty pthread should much smaller than that. In either case this isn't that much, these threads make up your primary control/poll loop, they should be respected more... 

Yes, absolutely possible. However, it must be a switching mode DC-DC converter, linear regulators like the hearty have too much loss for this application 

If it were me I would start learning from the current version, unless you have a compelling reason not too - like a must have library written for python2. 

To experiment, you could replicate some of the stability of an by putting a Thermo-Electric Cooler (TEC aka Peltier Element) to keep the and the broadcom CPU at a constant temperature. In other words, eliminate the temperature issue by keeping the Raspberry PI at constant temperature. 

Designing Home Wiring with Boxes for a PLC is something an Electrician would understand and be able to do the work for you, perhaps even assist you in planning/designing. 

Continue to use fork, but use a more robust mechanism to guarantee that the external process has concluded. 

The Raspbian Approach is as follows, I would duplicate this approach. provides a resize script that uses (a command line utility) to resize the filesystem on boot. This script is located in 

I guess your image is OpenELEC as @Lawrence said that. OpenELEC uses squashfs compressed image filesystem so you can't edit without uncompressing. To uncompress it, convert your sd-card content into image with dd command in another computer which runs linux. 

If your network setup OK for those options, you can set up your SSH Tunnel with putty. (free ssh client) You can find a good information at link below about creating ssh tunnel to your home network. $URL$ Then, setup your Chrome extension, put your Rpi's public IP address and port that you forwarded as SOCKS proxy. You should able to connect through your home network with this setup. 

I am using Logitech Media Server (formerly SqueezePlug server) as a streaming server at my home. At my work laptop squeezeplug client installed. I believe that it's a better solution than DLNA. (I'm using DLNA to stream video to my TV by the way.) There is a installation document for Logitech Media Server: $URL$ Also; There are many solutions work as 'streaming server' to use on RPi. $URL$ $URL$ $URL$ 

Log outputs should give clue. Update: Since you're saying that it works with NFSv3 not NFSv4, you should do extra things to use NFSv4. Create a directory to share in /export folder. 

Use Berryboot[1]. It's a bootloader that can install more than one OS into an USB flash disk. Berryboot has a feature like VNC to boot screen this could be what you want. You can connect through VNC when RPi booting, at this screen you can choose into OS what you want to boot. I'm using Berryboot with 3 OS installed. PiBang[2] as desktop with GUI, Moebious as server, Xbian as media server. At the boot sequence i can choose what OS going to boot. [1] $URL$ [2] $URL$ [3] $URL$ [4] $URL$ 

In short, not simple. In the most reasonable scenario, besides USB of course, you would use a JM20330 PATA<->SATA converter chip and you would bit-bang the PATA interface via GPIO with reduced bandwidth (16 bit PATA) It's not possible to obtain the IC individually without contacting JMicron directly, but you may use an assembled converter card like this one on newegg 

For asynchronous or polling access, the better approach is to serialize your hardware access into a single thread for a given bus. This thread should run at relatively high priority and establish the "time-base" for your application control loop In pseudo-code 

I would start with the official Raspbian-Lite since it is already pretty much as stripped down as one could need, and works out of the box with the hardware. By Default You Get a fully functional, light weight linux for free (time, money, freedom) 

Create a custom adapter board or HAT Consider creating a custom board or hat that has the appropriate connector and routes the connections to correct GPIO pins. Alternative to a custom adapter cable. 

Thinking in terms of electron current will get you nowhere closer to understanding electronics. In the end, however, it really doesn't matter. Everything works out even if you reverse conventional current. In electronics current flows from positive to negative, this is a rule of thumb observed world-wide to keep everyone sane. You can reverse this if you like, it won't change anything in your analysis, but you will confuse everyone you ask for information. So, to answer your question, it doesn't matter what you consider "out" (source) and what is "in" (sink) in terms of current. A diode still needs a positive voltage across it for current to flow, conventional or otherwise. 

Then use my sample code. Any comments are welcome. I couldn't solve the 'device_id' problem in Mobileclient. 

After starting service, check your server is running at default port $URL$ You can set up media server from web interface. Then, install client application. You can find packages list at $URL$ Install application, then run squeezeslave, it will find your server. You can find more information about squeezeslave at $URL$ 

Look at this thread in raspberrypi.org : $URL$ In thread user 'pageauc' pointed a python script to detect motion. In the script, developer use difference in sensivity of image. Count the changed pixels then if bigger than threshold. Steps for checking; 

Use correct shebang[1] line in your script. Your php-cli executable path may differ, please find your your executable before editing. 

Configure hostapd config file which is /etc/hostapd/hostapd.conf Sample config should look like below. 

You may not install PPA's onto your Raspberry distribution because of those for prepared for Ubuntu. If you are sure those PPA's for your distribution, you have install some packages to avoid these errors. First of all; find the deb package which contains program/application/script that you cannot run. Then install the package. 

First of all you have to be sure your wireless adapter support master or AP mode to work as Ad-hoc. To check in linux you can use modinfo command. 

So, when i download a .torrent file into Raspberry, Transmission find the torrent in folder then download starts automatically. 2) JSON-RPC recipe: I use PERL script from $URL$ This PERL script watches a folder for .torrent files, then request Transmission's RPC interface and download starts. 

1a) If you bought SD card w/ OS installed inside, maybe you don't have to use cable or monitor. Just connect Pi to your router via ethernet cable, then find what ip address assigned to Pi, then connect via SSH. But if you want to use GUI desktop, you have 2 ways. i) Get a cable/converter/screen ii) Install x11vnc on Pi through SSH which explained above, then run x11vnc server on Pi. After running x11vnc service, you can get Pi's GUI screen through a VNC connection. 1b) Raspberry Pi has 2 different way to connect to screen/monitor/TV. HDMI and RCA, so if you have RCA cable and your screen/monitor/TV has RCA connector ($URL$ you can use it to connect. I have a setup with RCA cable to connect my old CRT TV. 2) What you need; * Raspberry Pi (Model B) * SD card (installed OS of course) * USB Keyboard * USB Mouse * RCA or HDMI cable to connect to screen/monitor/TV * Power supply (5v/1A) Optional; * Wi-fi adapter (choose known verified vendor/model : $URL$ * External powered USB Hub (in case you want connect more USB devices) Update: Of course you can use converters like DVI->HDMI. But think that, HDMI is digital, RCA is analog. I'm using a DVI-HDMI cable because my old LCD monitor uses DVI connection, but at work I'm using a HDMI->Display Port converter to connect my HP monitor with Display Port. Converters mostly works.