By looking at your code it appears to me that your basic problem is that , and are distinct boolean variables instead of an . If you just turned them all into an enum things would be a lot more simple, there would be no possibility of inconsistencies between their values, and you would not even have this multiple-choice issue. 

Version A is definitely better, as it employs a more familiar pattern to get the job done, and it makes use of bit of trivial code () to save you from duplication of non-trivial code. () I would trivialize the trivial code even more, by saying right before entering the loop, and as the last instruction of the loop. Note that even though this is two lines of code instead of one, its complexity is smaller, because it deals with constants, not with variables. I could perhaps give more advise if you explained what you mean by 'algorithm to position boxes in a grid'. A grid is generally thought of as a two-dimensional structure, but I only see operations in one dimension, on variables which are defined outside of the code fragment that you provided, so... what is this code trying to accomplish? 

The key difference is the computation of the vector inside the function. First, is restructured from a (n*rep)x2 matrix into an n x 2 x rep array (3 dimensional array). This gives the benefit of generating all the data at once, but also gives a data structure which more easily operates on each piece/repetition. The function from is then used to iterate over the 3rd dimension and operates on each n x 2 matrix separately. Advantages of using is the availability of progress bars simply as well as being able to split the processing into parallel processing with not much additional effort. Since the values for are returned rather than assigned, the calling semantics are slightly different: 

This change alone would probably speed up your code a lot. You could aslo pull the computation of outside the loop, but that will be a much smaller improvement. The sample of data you gave is too small to do any reasonable benchmarking on. 

I am assuming that the call to is not what is taking most of the time, so I'm not including that in my analysis. One thing that is slowing down your code is that you are assigning to every iteration of the loop (well, every iteration that is 0). That could be pulled out of the loop since it only needs to be done once. 

Another solution would be to properly filter your input. It is easier, and it is also more dangerous, because it is easy to miss something. For the example at hand, you need to parse the user input into a number, and then convert that number back to string in order to append it to your SQL string, as follows: 

You could, perhaps, derive RecursiveObject from FlatObject. In the degenerate case in which all objects belong to a single lineage (every object has one and only one child, except the last one) and you have lots of objects, then your recursive method will try to use an awful lot of stack space, possibly failing with a stack overflow exception. The way to correct this is by avoiding recursion and adding a stack data structure within your function, which then works in a loop. But of course you would not want to do that unless there is a very clear possibility of such a degenerate case ever occurring. 

This class has a well defined role and by keeping it intact you are satisfying the Single Responsibility Principle. So, I would leave it like that. Perhaps you might want to look into how you could refactor some common code out of each method and into a separate utility class, but that's all. 

I make a vector of all the indexes higher than , and use that most functions are vectorized. For example, with equal to 1, (and picking equal to 2) working the statements from inside out: 

If you really want to eliminate more duplicate calculations, you can assign outside both loops and outside the outer loop. 

The last simplification uses the fact that a function returns the last evaluated expression by default. I don't necessarily recommend doing that because with compactness comes a loss in being able to see what the computations are/mean. (To understand it, you must essentially reverse the steps and break out each transformation separately to see what it does and to figure out why.) Looking at it again, the conversion to numeric is not a necessary step to determine ; you can operate from directly: 

Further elimination of duplicate work would involve recognizing that higher order interactions, as you are determining them now, are repeating the intersections of the lower orders (that is first intersects and and then intersects that with , but the intersection of and was already determined). And "first" order interactions are just the arguments passed through (as they were simplified in the previous iteration). 

First of all, you are right, what you have there is not a builder class, but more like a factory class. Which is roughly equivalent to a static factory method. Now, the question of using constructors vs static factory methods is one over which there has been a lot of talk, and for the most part no conclusive, universally-applicable answers. (Just search for "c# constructor vs static factory method" and you will see.) However, specifically for your case, where both the constructed class and the code constructing it are private within another class, the advantages of "discoverability" and "recognizability" that the keyword has are not applicable, so I'd definitely go with a factory method or class. With regards to whether you should be using a factory class or a static factory method, I think that the factory class is fine. The overhead for the generation of an additional object which gets immediately discarded is negligible, (especially compared to the amount of work that the object will do,) and might even be optimized away by the compiler. On the other hand, having a factory class instead of a static factory method could turn out to be useful if in the future you decide to introduce some state into your builder. 

Second, you can call on each element of at the outset which eliminates the need to specify an value to (and thus reducing all the calculations by one call to ). It also shortens the arguments to since duplicates have already been eliminated. 

The vector has a added to the beginning and the end which is equivalent to adding a to the beginning and end of the baskets. This makes the first streak start at the beginning and the last streak stop at the end. is a vector of indexes of where the misses ("M" in , 0 in ) occur. The lengths of the streaks preceding them, then, is just the difference in successive indexes (minus 1, since you want to count the number of spaces between, which is one less than the difference of the positions). Now, since the intermediate results are just used once on the next statement, they can be rolled up. Here are successive versions of doing that: 

This last is important; if you don't know where the code is slow, you don't know where to apply effort to speed it up. My comments are that, if you have a function that is doing some work, all the information that it needs should generally be passed in as arguments. It took me a bit to figure out what and (after I overcame the cognitive dissonance of thinking was itself an error). 

There is a much, much, much easier way to do this. You can use real values for order, so when you want to move the row from position 16 to position 7 you give it an order value which is the average between the order values of rows 6 and 7. The precision of real numbers is huge, and I presume that the re-orderings of images in your database will be happening at human reaction speeds, so you probably won't run into precision problems during the remainder of the expected lifetime of the universe. But if you are really insecure about the possibility of precision problems, you can rectify your table every once in a while, by reading the rows sorted by their order, and writing them into a new table, re-assigning the order values by copying them from an integer identity field. Then you delete the old table and rename the new table to the old name. 

A much faster way to do if x is an integer is . A good name for the function might also be 'array_permutator'. 

If you cannot modify , then write two helper methods, one for getting and one for setting the value of the day member of : Each method has a and modifies the appropriate member of . Good luck and have fun. 

The first two lines together create a 0/1 vector corresponding to whether the value in was (1) or (0) (and uses the fact that it must be one or the other of those values). This can be done as one statement, using the fact that and become and when converted to numbers. 

As you did not provide example data, I was not able to benchmark these alternatives (nor, for that matter, even run them). 

The comments are good; I copy them here so this question has a "proper" answer, and add some my own: 

You can avoid appending to vectors (which can cause re-allocation of space and can considerably slow things down in principle; though in your case of only a length 10 vector that shouldn't be noticeable) if you allocate them to the needed size initially and then assign within them. 

That is, generate all the answers and guesses, check for each one (vectorized) which (staying or switching) would be a win, and then accumulate those results. The rest is just to put the data in the same format that your function already had. 

I'm not clear what you are asking about combing function; you can add an additional argument which is a character vector which then the code just has a series of if/elseif's checking that parameter to see which algorithm to use, if that is what you mean. 

I think you should add a numeric field indicating the order of a card relative to the other cards. You do not need to use it for anything other than sorting. Also, instead of taking the identifier of the enum value and doing uppercase and lowercase tricks with it in order to turn it into something presentable to the user, you should just store the name, too, as a separate string in the enum. So, it would look like this: (where 0 indicates lowest order for sorting.) Furthermore you can also add one more number, the 'weight' of a card, to use in calculations which determine whether a card beats another. In general, enums in java are very powerful, so powerful that you pretty much end up not having to use the switch statement with enums anymore, because you can include a big part of an enum's functionality within the enum itself. 

The best way to implement a public generic method for binary search is by invoking the method of . (Better yet, don't implement such a method at all, and call directly.) 

Normally it would disgust me, but you appear to have a valid reason to use it, which stems from the pre-existing disgusting situation that you have to cope with these data objects that use ints. The only thing I would ask is, why can these data objects not use enums? What is it about their auto-generation that precludes enums from being used? I do not think that enums receive any special handling at the IL level, they are handled just like primitive types are. 

So approximately 1/600 of the time. Or, since I didn't do proper benchmarking, say between 2 and 3 orders of magnitude quicker. 

If a streak must have at least one , how can you have a streak of 0? The example here (and the following example) are consistent with a definiton of streak of "the number of consecutive 's preceding each ." I'll continue with this interpretation so that it matches the existing code. Now to improvements to the code. The initialization of can be simplified because is the default numeric value, so the first line can be re-written as 

In your code, is not defined. Presumably it is some threshold value, since it is used in a comparison of absolute differences. First, reformat your code so that I can better determine what it is supposed to do: 

Your approach seems reasonable, but there are some simplifications you can make. First, your construction of is needlessly complex. This works just as well: 

Then determine what the algorithm is that you are trying to do: Looping over each element of the first column of z, skipping any missing values, compare that value to every other value to the end of column. If the current value and some subsequent value differ by more than some threshold (in absolute difference), set that subsequent value to NA. R is a vectorized language, so explicit loops are often not the most efficient way to perform an operation. Let's vectorize that inner while loop. 

is an awful name for a class. The name of a class should always be a noun. No exceptions. Read-only fields should be marked as read-only using the keyword. is an awful name for a function. It does not give any hints as to what it means by 'File Status', nor any hints as to what it means by 'Checking' it. Looking inside, I see that it performs operations that change the state of the system, so 'Check' is an awful choice of a name for what it does. When a function begins with 'Check' it is supposed to return and to perform absolutely nothing that would change any state anywhere at all. No exceptions. is not a good name for a function that checks whether a file is empty, because it may be confused with a function that actually empties the file. Call it instead, and make it a property, not a function. This is lame: 

As GregS pointed out, macro arguments need parentheses. does not really do what its name says, nor what the comment above it says, because when we say "whitespace" we don't only mean the space character. You need to use from to tell if a character is whitespace or not, and this applies to all places in the code that compare against the space character. The comment looks like it has been added after the fact, in order to describe what the code will actually do, rather than to specify a requirement for the code. I would suggest that you replace it with a comment saying , because if you ever decide to implement that function differently in the future, you don't want to have to do tricks in order to precisely emulate the bizarre functionality of the old version, do you? Obviously, will fail if it is ever given to parse some text containing a word larger than some buffer, and the way it is written precludes the possibility of ever having any control over this so as to prevent it from happening, because the size of the output buffer is not passed as a parameter. In the test code, you would have a failure if you used a word longer than 100 characters. You might say, "you gotta be kidding, who would ever write a word longer than 100 characters?" One answer is, my son did, when he was 1.5 years old, and got a hold of my computer while I was in the kitchen, and he typed his first word document by holding the z key down for a couple of minutes and watching the 'z's fly by on the screen. If Microsoft Word was using your code, it would have crashed. Another answer is that this is precisely the kind of stuff that buffer overrun exploits are made of: the hacker will intentionally give the kind of input that the programmer did not expect.