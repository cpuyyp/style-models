I have a Raspberry Pi that is going to be put in situations where the intended user (a person with an unfortunate bout of brain damage) can't be expected to repair the device. I was working with it one night; I accidentally shorted some GPIO pins and - probably corrupted the file system! It never got past again on boot. Now, for me, this is no big deal. But to the poor chap the device is intended for this kind of thing could be very unfortunate. For the sake of the file system, can/should one run with the SD card locked? Is there anything I should do to prepare the system for this? (This would also prevent the card from failing over the matter of a few weeks.) I have no preference for the operating system. Thanks! 

I need the raspberry Pi to respond to some buttons. I'm writing this in Pure C, using the wiringPi library. As such, I thought it prudent to use the utlitily to make sure my pins were sane before coding. Alas, they are not sane. I'll admit, I'm using a simple, resistor-free way of testing this - a few wires with open copper on the ends and crimped housing on the other: Easy Enough.... But alas, I CANNOT get any the GPIO pins to respond regardless of what I do. I can make at least one of the pins go from high to low (several of them were high by default when using , but under no circumstances can I make a low pin () go high()! I've had this working in the past - it shows identical behavior on both of my Raspberry Pis. I am trying the GPIO pins (pick a pin, any pin) and I have them connected to a ground pin. But only ever returns ! Despite this I can and logic states - this behaves exactly as expected, if my multimeter is to be believed. Could someone be so kind as to tell me what is wrong with my approach? Running Raspian, by the way. 

the web server. wrapper.cgi: this program is called as www-data by the web server it calls sudo or super. sudo or super with a configuration file that only allows www-data to call real.cgi real.cgi: This program writes to gpio after preforming final checks. Be very careful when writing this. 

I seriously doubt that you will be able to reverse the hdmi port and use it for input, but It would require at a minimum a different kernel, disabling the X server and the frame buffer and writing a custom driver, if it is possible. You may have some luck with the camera port, but I know very little about it. Vga would require high speed a/d circuitry. It would be a fun project but nothing quick. 

The longer the wire and the smaller the wire the more voltage you loose. That is a plain and simple fact. There are basically three ways to compensate for this: 

Feel free to change the geometry to what ever you want. You would just need to generate a .vnc/passwd file and adjust the path to match. If you don't want a local X server comment out or delete the :1 line. Other display managers will probably work, but the configuration would be different. 

Use of a password with sudo. This is hard to do, prone to mistakes and seldom provides any benefit. Allowing full permission to the web server. The www-data user only needs to run one script for this to work. It does not need full root access. This can be done easily with sudo. 

Insert card into Raspberry Pi Model B Boot the system Login via SSH Start iozone test run Halt the system and try with another SD card 

Update 6: The technical support of Kingston wrote me that the controllers of the tested Kingston cards (and most likely of the other cards) are optimized for files of size 4 kB. The exact controller implementation is confidential. The answer from Kingston is the best one I got. SanDisk never responded to my support request and I was unable to finde a contact from Sony, Samsung or Verbatim 

Some of the cards I tried several times to double check. There was just little variation. The phenomenon occur all the time except for the two Samsung cards and one Verbatim card. Update 4: At the moment I try to find a contact to a company which produces NAND flash clontrollers (Samsung, SanDisk, Toshiba...) in order to ask there for a definite answer. SanDisk has a forum. I asked there for an explanation. I also sent a request to the technical support department of Kingston. Update 5: The erase block size and allocation unit (segment) size are not responsible for the phenomenon. I tested the erase block size of all SD cards with the pritcsd.py tool fist in the internal card reader of a ThinkPad X240 notebook and finally with a Raspberry Pi Model B. For all cards the output is: . Also the segment size is equal for all tested SD cards. It is 4 MB. This information can be found in the file . It is quite extraordinary in my opinion that all these cards have the same erase block size and segment size. In the meantime I collected the product IDs/item numbers from the packagings of the tested cards. Here they are. 

I personally like sudo or super for this when combined with a traditional cgi, and security can be managed to minimize risk (this can be done securely). The main criticism of cgi for large scale projects is because it forks for every request it does not work well with large numbers of requests. This criticism does not apply in this case because the main limit of bandwidth to this cgi script is what is connected to the gpio pins, and forking allows the script to run in different security context then the web server. There are some common mistakes that should be avoided: 

MIDI (Musical Instrument Digital Interface) is a simplex serial protocol (that is only sends data one way. If my memory serves it uses a standard uart. My first thought would be fire up minicom open up the usb midi adaptor tty device and set it to n81 31250 baud, then just do an ascii transfer. the two issues Are that that is a nonstandard baud rate, and something in my mind wants to say even parity which would mean 7 data bit. Give her a try, It can't hurt. 

increase the source voltage: if you lose .4v over the wire increase your source voltage to 5.4 volts so that you get 5v at the point of use. You must measure your exact voltage loss. increase conductor diameter. decrease cable length. This is easy enough, if you use an ac extension power cord you can place the power supply close to the rpi. 

The overall performance got worse but the phenomenon still occurs. Partitions are aligned to 4 MB boundaries. File system is ext4 with 4 kB block size. The partition used for the tests starts is mmcblk0p2. 

Update 1: It is clear that the performance for random write especially for small record sizes is significantly lower compared with sequential write. The memory cells of NAND flash storage are grouped to pages and so called erase blocks. Typical page sizes are 4, 8 or 16 kB. Although it is possible for the controller to write single pages, the data cannot be overwritten without being erased first and an erase block is the smallest unit that a NAND flash storage can erase. The erase block size is typically between 128 kB and 2 MB. In modern SD cards, small numbers of erase blocks are combined into larger units of equal size which are called allocation groups or allocation units or segments. The usual segment size is 4 MB. Each write operation on the storage results in a read-modify-write operation for an entire segment. For instance on a SD card with 4 MB segment size, writing 4 kB of data to random locations results in a write amplification factor of 1024. The controllers of SD cards implement a translation layer. For any I/O operation, a translation from virtual to physical address is carried out by the controller. If data inside a segment shall be overwritten, the translation layer remaps the virtual address of the segment to another erased physical address. The old physical segment is marked dirty and queued for an erase. Later, when it is erased, it can be reused. The controllers of SD cards usually cache a single or more segments for increasing the performance of random write operations. If the SD cards stores a root file system, it is beneficial if the controller of the card can cache the segment(s) where the write operation(s) takes place, the segments, which store the metadata for the file system and (if available) the journal of the file system. Consequently, the random write performance of a SD card depends of the erase block size, the segment size and the number of segments, the controller caches. But this all does not explain why the random write performance with a record size of 8, 16, 32, 64 and 128 kB is slower as with 4 kB record size. Update 2 (answer to myaut): The screenshot of the table is my own work. Currently, I write an article/paper about clusters of single board computers because they are an interesting option for providing resources to student projects and researchers. In this context I also investigated the performance of the CPU, storage and network interface of a single node. I have purchased all tested SD cards. On one of the cards I installed (copied via dd) Raspian Wheezy (version 2014-06-20). After I configured the network settings and installed some additional packages (e.g. iozone), I copied the entire SD card to all other SD cards. Update 3 (answer to Gabriel Southern): The results are from single runs. The procedure was: 

Cron may not support backtick command expansion. put your commands in a script and run that from cron instead. much easier to debug. 

Not all modems can be used for dial in. Almost all landline modems will work fine for dial in, but with GSM modems you need to verify that it will work. The fast easy way to check is to verify that it will sind RING messages and supports the ATA. If the modem meets those requirements it will work (with suitable adaptors). Install mgetty and read its documentation for software details. If the modem does not support those features there is still a slim chance it will work, but it will be much harder to setup. The modem bobstro linked to may work, but it is designed for other use cases (it is designed for continuous internet connection) and probably will not work with mgetty. Unfortunately you will probably need to talk to a salesman to find the right modem for your use case. If this is noncommercial you may also want to look at HAM based radio modems. P.S. use ppp not slip. slip is better than nothing, but ppp is much easier to use. 

As rasbian and umbutu are both debian based, they have a lot in common, including typical apache configurations, so there are probably no problems following for one on another, other than the wisdom or lack thereof of the author. 

There are some USB hubs with active power management that when they are plugged into a computer try to negotiate power consumption with every device, so they cut out the power to every device to start plugin events. These hubs (which are otherwise very nice hubs and work fine for every other use) will not work to power the RPI and act as a hub for it at the same time. the two workarounds are to add a really big capacitor (or battery) to the RPI so that it will function through this power interruption, or to steel power from the hub's power supply instead of the hub. It would probably be easier to just use a cheaper hub.