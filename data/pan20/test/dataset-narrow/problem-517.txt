I've reviewed your code and i can comment on some things: I have a similar personal site and I can tell you there is not many things you can really cut in order to make the code more tidy without resorting to frameworks. Inevitably as this is a static website you will have duplication especially if you want to have those auto-prefixes. Colors I would like to criticize the use of colors in your website. In my opinion they look dated. Try to use a lighter blue color in the background or use a flat color scheme from adobe kuler. Links I cannot see any of your links because they have similar color with the background. If you plan ton becoming a great web designer you will have to pay attention to those things as they stand out. Buttons and Animations Don't use those 3d buttons they look horrible. Make them flat or at least with a smooth gradient and shadow and please disable the animations! Fonts Change the font to something more popular from Google fonts and not convert something from Font Squirrel. Also make them slightly bigger in size. Background Add section on the top of the site with a background image of something that you like similar with example some medium blog articles. Make sure its of good resolution and quality. If you can make it static when you scroll even better. Overall Overall I'm sure with a lot of work and passion you will become one great designer. You just have to keep strong attention to detail and make your own statement by showcasing your portfolio. Good luck! 

I've reviewed your code and I can make the following remarks: While I like the BEM methodology, its not a panacea especially following it to the letter. You must seek simplicity to your code even if that means not following some rules but compiling an pragmatic view of your problem. In that case you should not add classes if you do not have use cases or rules to apply. Your HTML can be simplified to: 

This should work, but I don't recommend it unless you have a lot more identical examples. You could move both the hash and the into helpers, but I think that amount of indirection doesn't make things any clearer. 

I found a solution I like better, which replaces the loop with a . Sequences work but look funny as fake data. 

Ruby uses SCREAMING_SNAKE_CASE for constants, which is what you are setting up, so I would call the variable . If you have a super long constant, and it's not created programmatically, then listing it a line at a time is clearest. Ruby will coerce into unless you treat it as a string. You can use the shorthand for arrays. So, the first couple lines should be: 

This doesn't directly answer your question, but I also recommend switching from integer actions to enums: $URL$ Interestingly, this should not require any changes to your database at all, but will provide a lot of convenience methods and make your intent more clear. I do recommend hard coding a hash of the integer to the symbol in your enum definition to avoid any ambiguity: $URL$ 

I generally like to be Rubocop-clean, but it seems like breaking up the first case statement will only make things harder to read. Any suggestions? 

ActiveRecord enums "are exposed through a class method with the pluralized attribute name", so I recommend the following code. However, I would highly recommend making the enums symbols instead of strings for compatibility. Also, enrollment is spelled with two l's. Note that you can control the capitalization of DPR using inflections. 

Finally, you should consider whether you want to be when no conditions match, and you might consider explicitly adding an to make that decision obvious. 

Sorry I don't have time to review the full program, but here's a much simpler replacement for the method. Note is a redundant if you're then going to be splitting on white space: 

[Rewritten] You want to avoid inject, as is O(n) and clearer. Monkey patching array makes the code clearer and is idiomatic Ruby. Methods that return a boolean should end in . Method names should be snake_case. Here you go: 

You can also consider using generators which are slightly more slower that the iterating method but have less memory requirements. Here is an example: 

This looks too esoteric and I had to search for the documentation for both and and after that I had to run your code to the browser with breakpoints to understand the internals etc. At some point I stopped because I thought it took me enough time already and its not worth it. Its clearly too complicated to read and to understand, not only now but also in 2 years time when you revisit your code and think what exactly did you meant to do. My point is that in the current state is un-maintainable. Anyway here is my take on this: 

I have reviewed your code and I can make the following remarks: FP concepts I understand that you want to solve the issue of matching objects to queries. If you pass an object and a query you should be able to check if the query satisfies all parts or no. However to be honest with you you try too much in the wrong direction. All that , , etc are very interesting and useful but in the average programmer they don't really mean anything for the problem you are trying to tackle. For example I was able to rewrite the code using lodash chain in 5 minutes and with better readability. I will post my code at the end but before that I'll comment a few things: : Why the name matcher? What does it matches? An object, an array? I think its too generic and confusing. And why does it accepts 2 parameters? Ideally it should accept only one at the time.It should have been like and now you would have more flexibility with naming. 

Note how the code speaks of its self and it doesn't have to exaggerate. Every name has a meaning with the right intent. A makes matchers and an returns a boolean by accepting a query and checking if its matches the query. Inside the we simply chain over the query and validate that either every query parameter matches the object or in case of a mismatch we return false and that's it. My point is that you should always have a birds eye view of your code and try to think of ways to make your work easier to handle. Search for alternatives and don't fall into the rabbit hole of applying things that they don't fit accurately. There is always a simpler method to do your job. Good luck with your FP endeavors. 

First, kudos on including specs to show what you're trying to achieve. Titleize already does most of what you want (and I presume you are running within Rails or otherwise using ActiveSupport since it's not in core Ruby). You just want to add downcasing of little_words that are not at the beginning of a sentence. A few notes: Variables should use an underscore to separate words and you want to use two space indents and single quotes. You should call your method something different than the built-in . I recommend running Rubocop to help learn Ruby style idioms. 

There's nothing magic about Rubocop, but it does encourage you think about what makes readable (as opposed to just correct) code. In this case, I think it is clearer to make the conditions explicit in the rating method as you've done rather than break them up into separate methods to pass Rubocop. Specifically, I would suggest this: 

In Ruby, it is almost never necessary to set a temporary variable to empty and iterate over an object, given the power of methods like map, reduce, find, all?, etc. I don't see the need to use since it doesn't change whether index will be present or not. It's unclear why you're checking for nil on the first sheet_activities (since you can't guarantee what will be first without sorting), but if you just want to return false when sheet_activities are nil, the above will already do so. Also note that Rubocop likes single quotes when you're not interpolating. 

Your second method is closer to idiomatic Ruby. In general, you should never need to initialize an array. is a nice alternative to . And, you can open String and add a new method. I would do: 

I would just factor out the flash error into a constant. Also, I believe the trailing period in your regex should be escaped, as you don't want to match any character. 

I moved the test into its own method to separate the logic. This still shows a Rubocop error of which you could fix by moving the nested iteration into its own method, but that struck me as more confusing than helpful. Note that creating the method allows us to use both and to break out of the loop at different levels. Also note the use of a guard clause.