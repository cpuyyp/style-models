That's much closer to the mathematical expectation. Now, about performance... your code is really slow. There's four prime reasons: 

As Ratchet Freak points out, your code uses an \$n\$ size stack to manage the reversal of the list, so it's \$O(n)\$ space complexity. The question is whether there's a better way too, though. First up, your comparison here is very dubious: 

The basic algorithm you use is logical, and well presented. The general style is standard, and I see no issues there. I believe the algorithm can be changed slightly to make the comparison code simpler, but the performance will still be comparable. I looked for edge cases I would have expected, specifically relating to large differences, but you appear to have covered that well. Unfortunately, your pair-counts for are all off. For example, your third test case: 

This way you resolve the loop faster. Note that your code has a bug in that it will set 0 * -1 to be INT_MIN... I have reproduced that bug.... it's a problem. You need to check whether one of your values is 0 before returning a sign bit. How does it work? We can agree that the product (binary, or decimal): is the same as (halve the first value, double the second - or 1 tenth the first * ten-times the second). We can also agree that is the same as Butting these logic steps together, we have: 

When you have complicated indexing, the flattene system can be more efficient. Additionally, the flattened matrix has interesting memory properties that often leads to better performance on High-Performing Computational clusters. Converting from one format to the other is relatively simple. 

Your solution requires that you create a new Vector for every combination. You are right that there is no better algorithm. The way you have it implemented though, is not as efficient as it should be. Float should be a primitive.... . Using a Float object instead of the primitive will require a lot more memory than you should need. The Java class is a synchronized implementation. Use of the Vector class is discouraged. If you need synchronization then use one of the classes. I would also use an array-of-primitives for the input population too): 

That code.... is horrible... really horrible. What you do is spin-loop with a CPU at 100% utilization until the sound finishes. You need to do some blocking (or sleeping) until the sound completes. I would rewrite that loop, and the something like (note, you will have to handle an InterruptedException somewhere): 

This is a great concept to work with. Creating an enum of comparators is a clever way to make it easy to manage the sort order of file collections. The name concerns me. I realize that is convenient, but enums are normally given a "noun" name. "Sort" is a verb - something you do, not a noun which is a "thing". I would call it , or even . Adding to it makes code more readable. Additionally, enum members are normally in all-uppercase and under-score separated.... so, instead of . Adding the "File" to be you no longer need to have as part of the enum names, so you will have: . I believe you have truncated some code from the enum. It does not compile without the override of the compare method. I'll just claim it is because of how you summarized things for this question. Now, about the functional aspects. I agree, the override is a mess, and can be sorted out quite easily. First up, what you want to do is pass a comparator in as the constructor for the enum, and then use that comparator as a tool in the compare function.... like this: 

Comments - in methods are only useful if they tell you something that is not immediately obvious when you read the code. Your code is immediately obvious, and thus the comments inside the method are completely redundant. I have a note a little later about your JavaDoc though.... Exceptions - In many ways the difference between when checked and unchecked exceptions are useful, is easy to determine: 

The Run method thus encapsulates all the sequencing logic. There's no need for an external struct. There's no need for an error channel, and the errors are indexed relative to the input functions (so you can associate an error to a function). Also, the function returns a boolean "OK" flag to be used in a similar way as other Go-like functions. The Use-Cases I tested were things like: 

Your code is using a case-sensitive match, and also, it is not very efficient. HTTP allows some headers to be present multiple times: 

Note that the first generic is a self-referential one, and has the pattern . This is how self referencing generics are done. The most important part about this declaration, is that it declares ourselves! Now, with that declaration, we can reuse the generic token in other parts of the declaration. For example, here: 

Normalization Database schemas should typically be normalized, and, it appears that this schema is reasonably well structured. I don't see any massive normalization problems, but I see some issues: 

Now, the first thing you do in your match method (well, the second thing), is trim the string. This is a relatively expensive operation because it makes a copy of the data, and a new String and array instance. It would be much simpler to just incorporate the white-space in to the pattern... add at the beginning and end. Similarly, you do not allow the value to start with, or end with, a single quote , so incorporate that in to your pattern too. Then you may as well make the null-check a condition on the return, ending up with the code: 

These small details are things you have to fix, and show a low attention to detail. Of course, a more advanced solution would be: 

it requires a 2D array with very specific dimensions, you can't use that function to print different size boards in the same program. It would be better to have a slice: 

Old question, two new answers so far each with some concerns.... Firstly, the original code has a significant bug, which should be pointed out: 

So, how have I "fixed" your dependencies? Here's the code I have. Note that it compiles with no warnings on any of the Generics: 

EDIT: Actually, the do-while loop may not be the best it needs to be bigger.... consider the following: 

That is enough of an answer, on it's own, but I would suggest you consider the following. It is a little flawed in the sense that it never generates a value with a 0 as the first character.... I was part way through the answer when I realized this, but thought you should consider the approach anyway: 

I would expect that your loop will run at 62.5 FPS based on the code you have.... but with some variation on timers and rounding-down, I would expect that to drop slightly to 61 FPS occasionally. This would reflect your results where you see between 61 and 62 FPS. Why? Because your code is full of integer-division, and you are losing precision everywhere. Consider the first statements in your code: 

In your code, what does this mean? It means the code is not great, and that you should find a way to accomplish this with communication instead. Further, there's no need for a in your code, a simpler would be better... For "Communication" in go, you need a go routine to communicate with. The go-routine is linked to the instance, and it's the only routine that knows the state, and the only go-routine that can change that state. Now, you just need to communicate state changes to/from that go-routine using channels. In code, it would look like: 

Defensive Programming I am concerned about two things in your code. The non-final run method alerted me to the fact that people can override its behaviour, but it's worse than that.... people who override your class can easily call the run method from the wrong thread. You need to ensure that the run method is in the right context before you create thread conflicts in ways you are supposed to be preventing! A simple: