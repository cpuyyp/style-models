No, this is not how it is meant to be done. The normal way of addressing in IPv6 is to use one /64 per (V)LAN / ethernet segment and number the devices within that /64. So if the network stretches across multiple racks then don't put the rack number in the subnet id, but somewhere in the last 64 bits. 

They are warning you because IPv4 and IPv6 are two different protocols that don't talk to each other. If you run your server on only IPv6 then it will only be reachable by users that also have IPv6. Unfortunately that is still the minority (unless you target Belgian users, almost 50% off the users there has IPv6). And as good as all users with IPv6 also still have IPv4. The problem is that because of the shortage of IPv4 addresses the ISPs can't give everybody their own IPv4 address anymore. This lowers the quality of their IPv4 connectivity. To make your server reachable in the most optimal way by everybody you need to provide both IPv4 and IPv6 side by side. That way users without IPv6 can still reach you over IPv4, and users that do have IPv6 don't need to go through the IPv4 mess. That way everybody wins, and the more services and websites support IPv6 the quicker the whole internet becomes independent of IPv4 and we can move on to an IPv6-only internet. But for now we still need both. 

Also note: You need those RA packets. DHCPv6 only provides information, and optionally addresses. It does not provide a default gateway. That is done using RA. The idea here is that routers usually have better information on routing and gateways than DHCP servers, with the added benefit that you can have multiple routers on one subnet acting as default gateways with clients load balancing between them etc. 

If you don't configure port forwarding then your NAT box will just drop the packets. If you configure port forwarding or a DMZ forwarding to an unused IP address then incoming packets will trigger ARP lookups on your LAN. Lots of wasted CPU cycles and lots of broadcast traffic on your LAN, and in the end the packets still get dropped... And if you ask this question you are probably not experienced enough to run a honeypot in a safe way, causing a major weakness in your network. You NEVER run a honeypot inside your real network. In short: don't 

A different setup would probably make more sense for IPv6. Putting multiple /64s on one layer-2 domain isn't very useful. Just one /64 has 2^64 addresses. You could let each server pick addresses from a subset of the /64 for example. If the /64 is for example then server 1 could use every address between and , etc. That way you could fit 65536 servers on a subnet with 16 million addresses per server. But that's still pretty much IPv4-thinking. What would probably be much more useful to your customers is if you provide a routed subnet per server so that they can more easily run things like docker and virtual machines inside their server. I would recommend at least a /56 per server. If you combine this with the addressing suggestion above you could route the prefix to the ::1 address of each server. So for server 1 above you could for example set static route to . Then you are really using IPv6: provide plenty addresses on the LAN and give a block of subnets to each customer for virtualisation etc. Much cleaner and more useful to your customers than messing with multiple /64s on one LAN. 

What you describe is called anycast, and common when deploying services like DNS. Because routing can change it is a bad idea for things that use longer sessions, but for short things a DNS query it is used a lot. 

You now have to configure a firewall policy on the router/firewall that allows all the traffic. An example: 

That depends on the ISP. Some ISPs use PPPoA or PPPoE where you log in using a username and password. In those cases it is easy to identify the customer. Some ISPs provide fibre to the home and use identifiers attached to the ethernet ports to identify the customer. I'm currently working on software to manage such identifiers for IPv6. And yes, cable modems are also identifiable by the ISP. How this identification affects address assignment again depends on the ISP. Some ISPs just assign you fixed/static addresses where your customer identification is linked to your IP addresses and other ISPs just let their DHCP servers assign some addresses to the customers and only use the customer identifier for logging and legal traceability requirements. 

Then if your router has IPv4 address you will get IPv6 prefix . The in the IPv4 prefix means that the first 8 bits are fixed. So when constructing the IPv6 prefix it will only use the last 24 (32 - 8) bits from the IPv4 address. These have binary value . When written in hexadecimal that is . This is appended to the IPv6 prefix, giving a (28 + 24). So will get value . Therefore the interface will get address and the interface will get something like (assuming MAC address ). It would be better to give the ethernet interface an address from a different subnet, like: 

First: What you describe is NAT, not firewalling. A firewall just filters what can go through, a NAT device changes addresses in packets. You almost answer the first question yourself. Yes, a NAT device needs to keep track of every session going through it. Most communication on the internet uses TCP or UDP. Both of these protocols use port numbers. A session is defined by source address, source port number, destination address and destination port number. The NAT device needs to maintain a mapping between which numbers on the inside correspond to which numbers on the outside. And then it has to match every packet to an entry in its mapping table and adjust the packet accordingly. This is also why NAT devices are less than optimal: a normal router is stateless. It doesn't need to keep track of what happened previously and it doesn't need to adjust the numbers and addresses in the packet. If a router fails another router can take over immediately. When a NAT device fails the device that takes over doesn't have the same mapping table and all sessions break and have to be re-established. Your second question is more complex. One option is to configure port forwarding in one of the NAT devices. Then you let A send a packet to the forwarded port on C. B will change the source address and port to one of its own. When the packet arrives at C it then adjusts the destination address and port so the packet is forwarded to D. Reply packets do exactly the same in the opposite direction. If there is no port forwarding then it gets more difficult. You need to have the assistance of an external server E. Both A and D have to initiate connections to E. Then E has to coordinate setting up the session between A and D. A and D both send outbound packets to trick B and C into adding entries to their mapping tables. Once those mappings are in place they can communicate directly. To summarise: the way things usually work is that for outbound packets you have a device that performs source NAT. It changes the source address and port of the internal device to one of its own. For inbound packets you have a device that performs destination NAT. It changes the destination address and port to what is in its mapping table. The mapping table is filled either by manual configuration, by a protocol that lets internal systems request a mapping (didn't talk about those, look up UPNP and PCP) or automatically when the NAT device creates an entry for an outbound packet.