Another pointer: I would recommend converting your attribute parameters to constants, I've found that it becomes unpleasant to change the name of a later, if you need to. I actually have a class that has each role string associated to a type, so that if I have to change the name from to , it's right there, and my code can still reference the constant. (You can also use the constants with XML-docs to make things more descriptive in the future.) 

This was inspired by a conversation in chat, that started with the discussion of C#7.0 tuples and out parameter declarations, which led to the idea that there is no 'good1' way to return an error state in C# without throwing an exception. Out of curiosity, I wondered what it would take to design a type that was transparent to the developer, but allowed them to safely return exceptions without having to unwind the stack. For those who don't know, when you / objects in C# (or VB.NET, F#, any .NET language follows the same requirements), the most expensive part tends to be the stack. Throwing an exception is cheap, but the exception and the stack has to unwind and reflect against itself to give you the information you need. This is by-design, of course. The language and framework designers wanted exceptions to mean that the program entered an 'exceptional state', that is, there is an issue that needs resolved. The problem is that some methods don't really need to throw an exception on error, they could, instead, just return a pass/fail and then fill an parameter. The other option is to return a , where is the return type. Of course, this doesn't give us the ability to return an , just pass/fail. Sometimes we may want to return what went wrong. So, alas, I get to the struct that I created today. By including conversions to and from and , it allows us to simply instead of throwing, creating a much cheaper management of error states. The only caveat to this approach from a usability standpoint, is that one does not simply define an implicit conversion from . This means that is invalid, but is, as well as . If the framework/language designers ever open up conversions from , then this struct would be completely transparent. 

Try to choose more effective variable names. Never abbreviate except for certain well-accepted abbreviates ( for , for , etc.): 

Instead of that, though, I have to make sure I only instance the parser if all the commands are specified. That's wrong. Right now this whole class is literally useless for me. If the argument doesn't exist in the passed args, you just error on it. There should be a valid state for each argument where it doesn't exist or doesn't get set, because if my command line program supports 50 switches and arguments, my users would be furious to have to type that many every time. Consider reworking the API to be a specialized collection, so that I can call and such on it. In fact, I'd consider implementing it like a , with the exception that and are implicitly. 

The suffix on the tells C# that I want that to be an unsigned long or . (Similar to the suffix indicating .) This allows the implicit type engine to appropriately determine what type that really is. The tells the compiler to increment both of those variables each time the loop iterates. 

You didn't define 'simplify', but let's consider fewer LoC. You don't really have many places (without a major structural rewrite) that you can reduce LoC. Your code is currently good and it's also concise. Everything (almost) follows SRP well, and it's easy to reason about for the most part. You could make things a bit easier to reason about by considering places where you use multiple compositions in opposite directions, such as . This isn't particularly hard to reason about, but it's not immediately obvious. We could consider a rewrite that makes it a bit more obvious: . Now that doesn't read to a human as simply, I can see why you wrote it the way you did, but if we follow the mantra of imagining the next maintainer is a psychopath with a sword who knows where you live, and has a very low breaking point, this probably isn't the best way to write it. 

I made everything one line as it's a simple expression, which should clearly indicate what it does, but you can feel free to break to , and to if you like. This allows you to change the target and tolerance easily, and also has the added bonus of being reusable, and testable. (How do you go about verifying that your current version works, for example?) You can define some simple tests: 

The interesting thing about this is that the operator allows you to just ignore this class altogether: 

You should always keep the first parameter on the same line as the method/assignment/etc. This keeps things in a logical format. It makes them easier to read in the future. 

I needed and for the next stage of a project I'm working on, so I developed them. I also needed to determine if two lines intersected, preferably as cheaply as possible. (Lots of physics calculations.) So, I built . Then I built , then . The intersection code is my favourite part, essentially it builds both lines in slope-intercept form (), then solves for , then plugs into the first line to get , and returns that point. For this method, I defined coincident lines as not intersecting. (Since they don't intersect at a single point, but instead an infinite number of points.) Once the point is found, determining if line-segments intersect is simple: just check if the point falls within the bounds of the rectangle of the line. (Why? We already know the point is on some location of the line, which means we only need to determine if it's falls in the range of our segment . I built the method to also check the since I named it .) 

While HTTPS is good and all, using AES to encrypt data between a server/client is not really a great idea. Encryption has the concept of a 'public key' and a 'private key', some algorithms use both, some only use one. In the case of AES, it uses one key: a private key. The names themselves should give things away, but I'll be explicit anyway: 

Our entire programme is now down to 29 lines with appropriate whitespace, and supports much more than your original did. (Your original was 44 lines.) 

What if I told you that not only could we make this generic (and generate the query dynamically), but we could solve that problem at the same time? I'm going to solve them one-at-a-time, but it won't be too difficult. First, we need two pieces of data. We need the table name and property name, assuming that they're not defined by the property name itself. (As it appears.) If you have access to the library, and the and namespaces, then this is significantly easer, otherwise you need to define the three attributes we're going to use. I'm going to use built-in's. First, we're going to define our keys on the object with the attribute, then we'll define the attribute, and the attribute. 

So you should get the point, go through the ASCII spec line-by-line and put a line for each record in the spec, then a label for each of those lines. For the ones you don't wish to implement yet, simply have a label or label that ignores the input. Once that's done we now know how to implement EBCDIC, just build an EBCDIC jump table. What you might not realize is that having 128 (because eventually you want to support all codes/keys, right?) statements will cause negative performance because is compared up to 128 times for each key press, that's a lot. So we build a jump table that might be more work to implement initially, but in the end we'll end up with a much easier to maintain setup, and performance will not degrade. When we call , it jumps to the label, then to the line identified by . Easy stuff. 

You should also look into the tag, and the tag. Your line indicates that it is to be HTML5 compliant, so it is acceptable to use those tags here. 

So what did we learn? We learned that benchmarking is hard, and that by the time we factor in all the candidates, we can finally come up with a result: inconclusive. Do note, my intention is not to be rude, it just seems that way because I got a little flustered after reading the following part of the question: 

You'll notice that the bitwise-operator method takes 12% of the time the method does. And in this situation it makes a great deal of sense. It's easier to reason how the , and variables are being filled with the bitwise-operators. It's not so obvious with the . Yes, this is obviously a worst-case environment, you will likely have other bottlenecks and JITer that will influence it, but this at least goes to show that there are other just as good solutions to the same problem. Personally, I've never touched the , I always do my own bitwise-arithmetic. To me, it's easier to read and more obvious. To you, it may not be. I wouldn't suggest going so far as to make a loop. I did just that, and it's actually slower. 

The names and are very non-descriptive. Consider naming the methods after the algorithm or based on what they do, as they're currently non-sensical. 

You could also consider (that is, if you have the ability to modify the webserver) using Data Contract to dynamically serialize and deserialize the data. The is very powerful. 

This keeps the LoC down, and increases maintainability. It uses short-circuiting, so if the left-hand side evaluates , the right-hand side will not even be hit. 

On a more important note: this is not encryption. Yes, you are using an AES Encryption library to process your data, but you have one, unfortunate issue that prevents this from being considered encryption. 

And finally, after discussion in the comments, I would recommend you build a class to represent the return of . Then, you should create an instance of that class instead of the , and add each instance to a . This will allow you to performance test with more relation to what would likely be the actual use-case. 

When building a calculator it's hard to effectively build something dynamic, you are always concerned about how things should relate (for example, how do we represent \$a+b+c\$, as \$(a + b) + c\$, as \$a + (b + c)\$, or some other way?), but it's often easiest if you consider each term and operation on it's own. Let's take \$+\$, for example, we should have two terms: a left and a right. But what is a term? A term can be any of the following: 

Process items in an array; Accept and process user input; Add user input to array; Print array information; Inform the caller we're going back to the main menu; 

Some of your variables could go for more appropriate/meaningful names. You should consider renaming the base Controls from to something that indicates what the is. 

Absolutely correct. Using an additional type for the colours (as I assume that's what you were using a for) will be slower, it's more method calls that have to be made. 

So that's one gone, and it was easy to do. Next, we want to eliminate methinks, because you don't use that after the algorithm runs, it's just state for the algorithm: 

My main concern is whether or not this is necessary. I have to split drawing code out of the main class, so that the Client and Server can reference this library. Obviously I'm interested in all suggestions, but of particular importance to me: 

On first glance this isn't bad, though I hate some of the naming. Let's look at some of it in particular to see what's going on: 

Obviously this is a lot of pseudo-code, but you should get the idea. Then, any time you need , you may or may not actually be reconnecting. Other than that: a lot of your code uses when will suffice. You also have moderately poor naming (, ), that's the biggest issue I see here. 

The final point to cover before tail-call recursion: currying. You don't see it, but you have two opportunities for currying that can remove a couple lambda's (): 

Why with a ? Because and are codependent: each one can affect the result of the other. So we want to take both into account idiomatically. 

Basically, the method on an (which an array is) allows us to transform the elements from to a with some complex logic. We can't (and don't need) to extend this to our version, as is already lazy. 

These tell me that we have two very distinct exceptional conditions: you already own the item, you don't have enough money for the item. In C# we have a very well-accepted manner of holding this type of information: . We can store all sorts of data in an exception, and then once we've done so we can it at the person who called it and say 'Here, you handle it!' To a naive or lazy programmer, this is as easy as . But we're not naive, and we're not lazy. We're going to do this appropriately. Now ing an at someone is not inappropriate (though it can be rude) if we expect them to it, but we shouldn't expect a method to an at us if we don't have enough money, should we? I think not. So we're going to, instead, the to the user in a more friendly format. In order to accomplish this, we're going to (ab)use the implementation. It's a pretty robust implementation (a lot of people far smarter than you or I came up with it) but it's also very easy to use. For those who don't know: resides within and was added as part of the Task Parallel Library (TPL). It's typically seen in / code, but it can be used out of that as well. So, we need to create our al states, for that I'm going to create two very simple objects: 

I know this is a lot to take in initially, I apologize for that, but I had a lot to cover. Hopefully it's helpful. :) 

Even though the exposed collection is a , exposed as a get-only property, I still managed to modify it through the underlying that supports it, via casting. This essentially says, "I know I assigned a to this, let me use it as such" and the compiler lets us get away with it. 

We're going to start with this block as it made me the least happy when I saw it. There are four glaring issues here: 

This is advantageous as you already did the comparisons twice, and it's clear that you don't want to accidentally trigger things. Only if it's value has actually changed do you want it to update. (At least, from what I can see.) Just as well, I think this is a bug: 

Each of them short-circuits as reasonable, to allow us to only enumerate what we have to. The short-circuit path is taken in the case that it's acceptable. A quick set of tests, with a pass/fail for each, is: 

Why? It's fast as hell. And this tends to make it more clear what position each value represents. There's no need to place them backwards as you have to with the Looking at this code, it's extremely easy to determine that each pair consists of the high-byte, followed by the low-byte. With the , the lowest byte must be followed by the subsequently higher bytes. Can it really be faster, with all those casts, shifting () and or's (), and the fact that Microsoft themselves wrote the ? You're damn right it can. Run the following programme: 

Then any object/method that needs a can just take an , which means you can supply different noise-types if you need to. (I do this very frequently with logging.) 

This is so that variables cannot unexpectedly be used in places where they should not, and so that they can be recycled when they fall out-of-scope immediately. It also means that you cannot accidentally use the value of them outside of the block they apply to. 

I think you can see where this is going, simply use LINQ in your method and bam, you've extracted the ugly switch statement and conditionals to a much cleaner (and more robust) alternative. Now if, for some reason, you want to add more rows/columns, it's trivial. 

This should be self-explanatory. It does the same thing as , used in conjunction with that attribute: 

There is usually a way to fix this. As stated earlier your current algorithm is inefficient. First: you keep this list but you don't use it for anything other than keeping a count of the number of elements to compare with the max. You could easily rewrite this algorithm to use a simple integer instead. 

The first thing I would do is spend a bit of time cleaning up your formatting. It's very hard to read as it stands. 

That will benchmark the method 10,000,000 times, and the method 10,000,000 times while verifying it always returns . 

So, I have another suggestion, to work on top of the suggestions by Heslacher: Eliminate the work. This is easily done with boolean operators (most specifically the shift operators).