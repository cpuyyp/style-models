I work for a company that has a multi-tenant database model that doesn't currently use database partitioning. The ideal end-state would be adding a new TenantID column to every existing table, including this new column as the first column in every primary key, and rewriting all existing SQL definitions to filter and equi-join on TenantID. However, with thousands of existing SQL modules, this is a resource intensive solution, outside of a complete rewrite of the entire database. So my new plan is to make this update in phases. Phase I will be keeping the existing database schema exactly as is, and creating aligned database partitions that use the existing SupplierID column (which is in nearly every table) as a proxy for TenantID. SupplierID already lines up well to what I want to do with TenantID. Existing suppliers are clustered into supplier groups, so a group of suppliers can be thought of as a single tenant. So my question is. If I do this, create aligned database partitions on the existing tables without changing any table schema or the definitions of any existing SQL modules, will I see any performance benefits? You can ask for additional information in the comments, and I will update the question to reflect them. But for starters there are many existing queries that filter on SupplierID, but few that equi-join on it. 

I apparently cannot figure out the key words to google search for what I want, so I need help finding out how to do this. I feel like this may be a duplicate, but I just cannot find this anywhere else. I would like to be able to easily save a bunch of create table/view/proc scripts to a file. The file has an easy-to-execute format that will drop and then re-create all of the objects, so it can be run on multiple databases. This format works well for me as I have to make changes to some objects during development, and then make the same changes on multiple other databases. I can just change the database and click execute. However, some of the scripts have A LOT of quotes in them, and it gets QUITE annoying to have to double/quad quote them every time I make a change or add a new object to the file. For instance... 

And so on until you've inserted all of your games. Please note that the exact syntax I've used is for the database platform I am most familiar with, but the underlying logic should be usable in any database platform. Also, as I write this I am struck by the idea that what you really want is to support a many-to-many relationship between game titles and platforms, since a platform can have many games and a game can be available on multiple platforms. That would take a little more work, but would be helpful for efficient storage and would give you the ability to easily determine which platform(s) a given game was available for without doing a text-match. So, at a high level you'd need another table. The existing Game table would not have a ConsoleID column. Instead there would be a new table, likely called Console_Game, that would include only ConsoleID and GameID as keys. Then the stored procedure would need to check for both the existence of ConsoleName, and the existence of GameName. Inserting into both tables as necessary, and then finally write a record to Console_Game to show that a given game is available on a given console. This will be more work upfront, but it is a more scalable solution than what you currently have. If this is for a job and not a hobby you should probably go that route. 

However, while only two states are pictured here, there could be 50 states. That part is done and looking good. The trouble I am having is to have the totals across all states at the bottom. At the very bottom of this post is a quick look at my parent report in SSRS design view, if that seems the best way to go. Below is an example source data table and my current query. The ordering doesn't really matter, it is just for ease of viewing. I am using a cross apply, but whether cross apply or pivot, it doesn't matter to me. 

I have a query that is working fantastically, except that I would like to force some records to appear. I am using SqlServer 2016, and this query will ultimately be used in a VIEW and used by SSRS 2016. If the desired behavior can be done in SSRS, or even changing to a PIVOT or some such, I am open to that option. I will put some DDL down below to mimic the example images shown. The data I am pulling from looks like the below: 

When you define the foreign keys you can include ON DELETE CASCADE to enforce the delete rule. As for problems in the design. One immediate issue I see is that you've defined the Identity columns as "Id". This design pattern almost always leads to trouble. What you want to use instead is an ID column name that includes the table name. For example, Id in the User table should be named UserID. 

I think the easiest solution for you would be to create a stored procedure that took @GameName and @ConsoleName. 

If you entered in a @ConsoleName that didn't already exist in the Console table, it would INSERT it there. Next the stored procedure would look up the ID for the console name you provided it, and INSERT a record into the Game table with @GameName and the @ConsoleID. Then you'd call that stored procedure for each Game you were planning to enter: 

I have a report that is "working" fine except for an issue. I have four dropdown list parameters where I am getting the values from queries. When I select a value from a dropdown list, it selects the next value below what I wanted to select, and "removes" the first value as an option. For instance, one of the dropdowns holds a list of payrolls. When getting the list from a query, it returns payrolls 1 through 121(or so), which is perfect. However, if I try to select any of the payrolls, say payroll 10, it will show me that I selected payroll 11, and the option to select payroll 1 will no longer be available. ALSO, possibly tied to the above, the report sometimes refreshes when I select "view report" and I have to try to choose the payroll again. These are not cascading parameters. The values are all derived from two queries where I am selecting a distinct list of employees for two of the parameters and a distinct list of payrolls for the other two. I am at a loss as to why this type of behavior is even possible. 

There are numerous restrictions to what can be an indexed view. In a data warehouse setting those restrictions will make it impossible for just about every standard star join view to be an indexed view. Which is really a shame, since despite what the comments say, [materialized] indexed views are magic! As for whether joining to the same table twice is an issue, it is not. In a data warehouse you'll often find yourself joining to time and date dimensions dozens of times. Also, I was interested to see that you made the primary key on the date dimension the date itself. In my last data warehouse we ended up needing to use an INT column as the primary key, because we needed to save indeterminate dates (like 2016/1/??) where all of the date parts were not known. Also, when writing your views, you should always check to verify whether a LEFT JOIN will have better performance than an INNER JOIN, even if they produce the same results. Back when our data warehouse was closer to a snowflake schema, the joins were into the hundreds, and many of the views did better with all LEFT JOINs as opposed to INNER JOINs where INNER JOINs were appropriate. 

This gives a good idea of what I want to do, but SSMS doesn't like it, saying , and I'll start working on sample data to help, but I wanted to get this out now in case someone knew what to do off the top of their heads without data. 

With tons of values in the Cross Apply, it just gets annoying. How can I easily export the definition of an object to have double/quad quotes? 

And here is the results I get in SSRS preview. Not ordered how I want at all :( As far as I can tell, SSRS should support ORDER BY in the dataset query. I also tried removing the ISNULL( ,1000), and the order by still didn't function as desired. Thoughts? 

I am going to suggest an alternate solution. Rather than trying to mock-up a database design in Visio, why don't you create the database design in the relational database? Once that is complete you can use software to create the database diagram from your actual database. Most relational databases have database diagrams built in, and if the built in diagrams don't fit your needs there are a variety of third-party alternatives, many of them free, or with trial periods. The advantages to this approach is that doing the actual design will help you think through your choices, and even if it doesn't end up being the final design, you can use the work as a starting point. 

1) Backups are typically compressed, they will be less than the size of your data and the size of your log. 2) If you run a database in full recovery model you need to back up your transaction logs or they will grow indefinitely. If you don't care about transaction log backups you should switch back to simple recovery.