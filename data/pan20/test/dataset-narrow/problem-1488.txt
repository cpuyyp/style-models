As with the human languages, there are multiple programming languages. To develop in a certain language you usually write (text) files containing the instructions (you could now mention how this looks in a programming language you like). These text files are read and executed by the computer. Depending on whether the language is low- or high-level, the computer might need additional software (the interpreter) to understand the language. Often, developers use so called IDEs which make development easier as they offer hepful features (for example, automatically creating instruction(s) you normally use a lot or immediately pointing out errors). 

In addition to the excellent definitions already provided, consider taking a slightly different approach or at least augmenting it a bit. This comes back to good pedagogy: I wouldn't give students definitions without context. Moreover, I would support whatever concept I want to get across, no matter how broad or narrow, with specific examples and implementations. To explain programming to someone who has no idea what it means, it is necessary to have short blocks of code at the ready. Explaining it in the abstract probably won't be too successful. Relatively straightforward ideas like printing "hello, world" or the even numbers from 1-100 or the sum of the integers 1-50 would show the bare minimum of logical and computational ability. Maybe even something relatively intuitive like bubble sort or linear search. From there, compiling the program - assuming a language like C or Java - would at least allow you to explain the notion of translation. I like to use the metaphor that computers "speak" binary, but I speak C (or Python or Java or...). I need to translate what I want to accomplish into the language that the computer can understand. You can explain compilers/interpreters as a kind of translator that understands both computer-speak and human-speak and knows how to take your thoughts and turn them into "words" that the computer can understand. (You can optionally include the idea of assembly and instruction sets, but again, that's probably beyond the scope of this conversation.) 

To sum up, the curriculum given by you sounds quite good to me. Except for the adjustments proposed above, I don't see much that needs to be changed. 

If you already use an IDE, this could be the right way for you: Git support in your IDE Many IDEs come bundled with Git support. Eclipse, for example, uses EGit for Git integration. The JetBrains IDEs also provide Git support. The text editor Atom can be extended with plugins (e.g. Git+) to provide Git support. All of those IDEs run on most common platforms (e.g. Linux, Mac, Windows) and look more or less the same there. This would mean you can use the Git client you know at home and at work if you use the same IDE at both places. Normally, the Git support integrates quite well with the programming workflow. The Git clients are often quite mighty, but always accessible using a comfortable GUI, which could help as there are no terminal commands to memorize. However, you should keep the Git concepts in mind - depending on the IDE, the built-in Git client will follow those concepts more or less closely. 

This now becomes a teachable moment on a number of levels: imperative v. functional languages, recursion v. iteration, "expense" of function calls on the stack. Students appreciate being shown the messy truth behind topics that are sometimes treated reductively and simplistically. Let them wade in the mire and see what they think about these debates. Have them analyze the arguments they mind on here; now they are thinking on much higher, more sophisticated level about program design. The key line that I take away from all of these is this one: "You almost never use recursion for performance reasons. you use recursion to make the problem more simple" (top answer to the first post I linked to). It's often times an exercise in thinking more so than programming. From a pragmatic perspective, discuss use cases for something like merge sort and quicksort (recursive) v. bubble sort (iterative). Throw in traversing tree structures as well. There is a time and a place for thinking recursively. Iteration is not always the best choice to make. Last, from an aesthetic perspective, based on my time studying SML, there is a beauty, an elegance, an aesthetic to a well-written recursive function. It's clean, clear, easy-to-understand. If part of code quality is its readability, then recursion has an aesthetic quality to it that a for-loop arguably does not. 

I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

1 After reading through your question another time, I guess I've misunderstood the question and you only asked for a solution for the first item in my list. I think I will nevertheless share my thoughts on both - maybe they can be helpful for you or any future visitor. 

I learned Racket using the material taught by the UW MOOC on Coursera Programming Languages, Part B, which is modeled after this UW course. Here are the relevant helpful documents, which do provide an introduction to the language along with quite advanced material which involves implementing a programming language within Racket: 

This is an activity we typically do when learning about algorithms at the beginning of the year, but it's fun and more advanced students will hopefully do a better job at it. Part One: One volunteer comes to the front of the class. She sees a simple drawing on a piece of paper of several shapes (triangle, square, circle in one example) next to each other with slight spaces in between them. Everyone else in class has merely a blank sheet. Her task is to get them to reproduce what only she sees. The catch is that everyone else in class has to think like a computer and make no assumptions. Saying "draw a circle" or "make a line" won't accomplish the task. (Side note: this could be a great way to differentiate imperative and declarative languages, but that's a separate topic.) Computers need to be told to put pen to paper, lift pen, etc. Part Two: A different volunteer comes to the front of the room. The task is reversed. Everyone else has a drawing in front of them, and they need to communicate with the volunteer to get her to draw it properly on the whiteboard in the front of the room. The same rules apply. Classic "bugs" that come up here are not instructing the student to take the cap off the pen and not having her lift her pen correctly to complete the drawing, which is typically a stick figure with a word bubble message. Both activities are engaging, and do give a number of opportunities to step in and talk about assumptions we as humans make and about abstractions that we may take for granted, like "draw a shape." I got this idea from my time taking CS50 and being trained to teach CS50 AP. You can see this activity demonstrated at Harvard here. Also, there's always the classic "Peanut Butter and Jelly Sandwich" activity although this one is hard to do at the last minute. Watch the CS50 at Yale demo here. 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

Why should you try to teach every interested student and assist them in reaching their different personal goals? I think you've already given the answer in your question: Because each of them is genuinely interested in learning something. In my opinion, one of the wonderful things about schools is that they are designed to be places where knowledge is spread. People who already know something about a topic (often these people are the teachers, but even this doesn't have to be the case every time) share their knowledge with people who want to gain knowledge about this topic (usually the students). In reality, this principle is sometimes hard to encounter: As there are usually a lot of required courses in most school systems, you'll always have students who aren't interested in learning something, but are just forced to attend. Still, as I want to focus on the idealism here, I think the reason why teachers should try to teach everyone who is interested is because teaching every interested person is the primary objective of a school. When discussing this question with some others, it might be good to reach a consensus on the level of the discussion: I could imagine that somebody argues with you about this question assuming you are talking about a given, realistic situation and wants to convince you that in certain situations it's (as you also already stated) just not possible or incredibly difficult to teach everybody. 

One of the most challenging concepts to instill in new CS students is 0-indexing (indeed, the pedagogy of this fact probably merits its own discussion). Another difficult topic -- although a slightly more advanced one -- is pointers. (I'm thinking particularly of programming in C.) With this question I'm wondering if part of the difficulty is the syntactic sugar in C that allows the following to be equivalent: 

From the perspective of MOOCs, a great place to start is MITx's 6.00.2x: Introduction to Computational Thinking and Data Science found on edX. It uses Python to introduce the study of data science and does not presume more than a beginner level of either Python or data science (although 6.00.1x, the first part of the course, is helpful for those who no experience whatsoever). The penultimate unit focuses on Machine Learning using the following outline: 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

It is clear to me that the Game of Life works for reaching both of those objectives, but I get a sense that I'm missing something more that I could use it for. Keep in mind that these students are relatively new to computer science and programming as high school students. Ultimately, what is the pedagogical value of Conway's Game of Life for a high school CS course? 

I am currently designing an intro to programming course for middle school students using Processing. In particular, I am using these two resources to focus the curriculum: Make's Getting Started with Processing: A Hands-On Introduction to Making Interactive Graphics Raspberry Pi Foundation's "Introduction to Processing" Resource Make's resource moves all the way from simple, one-line programs like to OOP, file IO, JSON, data visualization, etc. To supplement these resources, I am using videos from Daniel Shiffman's YouTube channel The Coding Train. Of particular value are his short coding challenges where he completes a programming task in the allotted time while talking through the design process. I find that Processing's power comes from its scale combined with its ease of entry. I can confidently say that students will be writing "real" code on day zero and getting instant results on something other than the command line. Plus, there's the satisfaction of starting to learn programming with a text-based language instead of something like Scratch which can feel restricting and elementary to some students. And, as Daniel Shiffman's videos show, there's really no stopping how far you can go with it. 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: