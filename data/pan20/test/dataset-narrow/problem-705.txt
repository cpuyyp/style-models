If you find that you have to do this a lot, you can abstract it into a custom filter, which you can then use in your selectors: 

While using a closure to prevent polluting the global namespace is a good idea, you shouldn't be passing in random data like that. The way you are doing it, you are forcing the reader to scroll to the bottom of the function call before reading the function body - that's just plain confusing for no good reason. Instead, declare the variables regularly within the closure, and assign their values right then and there. That way, it's much easier to read (and maintain), while still keeping the global namespace intact. 

No need for all that. Just use one bracket group, negate it (be prepending a ), and use the return value directly: 

If you want to, you could even build that original array dynamically, which will make this much easier to maintain: 

Your variable is declared without a , so that it's leaking into the global namespace. Don't do that. As it stands now, your isn't used anywhere in the code. I'll assume it's not applicable here. Instead of manually keeping of your iteration, use the % (Modulus) operator to calculate your rows. jQuery's method doesn't deal with code fragments the way you seem to think it does. actually appends a whole table, not just an opening tag (that's not even possible). Access to the DOM is not free. Every time you hit the DOM you incur some overhead. Try keeping DOM modification to a minimum. Unlike others, when dealing with a simple HTML construct such as this, I prefer to build my fragment from a concatenated string since it's much faster. 

to pre-allocate a vector of integers. Integers use less memory; you will also save time avoiding unnecessary conversions from integer to character. Second, is for regular expression matching. When you do , you are checking if contains an which is not the same as asking if is exactly . In your case, you want exact equality so having used in would have been more appropriate. Even better, there is the function. It is vectorized so you can avoid the loop and just do: 

If you were to add a at the top of your function, you would find that your function is called 25 times, once for each combination (pair) of pathways. So yes, despite having used , it is still essentially a big old loop you have under the hood... Here is how I would write a vectorized function so the heavy-lifting function (, or in my case, ) is only called once or twice: 

It returns a vector containing for each distinct value of . In the event that the data has no value for a given index, you could overwrite the output-ed with a so as to not affect the upcoming roll sums: 

The profiler showed that rbind-ing your 16.5k data.frames was the main culprit. Instead, I create a data.frame after dumping the list of sentences into a single vector. I am also able to compute the vector of corresponding filenames using the function . Untested: assuming was also computationally expensive, I used again to append the and . You could check by yourself if this is instead faster this way. I used the supposedly faster instead of Your is presumably a slow re-implementation of the function I replaced with the faster construct. Also with . and are slower because they try to simplify your output data. Where possible, I have avoided large duplications of your data, e.g. where you were using . Instead, I just appended column(s) to your existing data 

I built this very-basic lazy list (I'll add more methods as I need them). You provide it an array, a generator or any iterator. It creates a lazy list, which lets you run a pipeline of transformations in a lazy manner, meaning that they'll only be applied as you pull values out of the list. Here's the class: 

Very good question. I'm pretty sure this can't be done within the selector. However, instead of checking the every time it's clicked, the collection before applying the event listener: 

Use & . They're SO MUCH faster. Since you call every time you instantiate your plugin, you should probably move the call into your constructor instead. Public functions should be assigned to the prototype, so that we don't create a new function every time we create a new instance. Likewise, define a private function outside of the constructor, in the parent closure. Again, we don't want to have to re-create the same function over and over again. 

Sane Selectors - There's no need to add all those selectors by hand. Simply use an attribute selector to select all elements that start with a given string. Selector caching - If there's one thing you can do to your code to keep it fast, it's selector caching. $.each - We're using jQuery's helper to loop through the array, since it also supports older browsers ( is not supported in IE < 9). 

The method will traverse the DOM all the way up the chain. Rather use the method, which will stop at the first match: 

Here is an implementation of the ideas I had suggested in the comments: to store the output of so it is only called once, and to limit the expensive name comparisons to individuals that share the same initials. I hope it helps. 

First, let's point out that and do not require that the input be sorted so they should asymptotically (i.e as the input becomes large) perform way worse than your code if implemented properly. My main concern with your implementation would be that you are disregarding potential floating point errors. See for example that 

Instead of writing all the names in , you could get them from the file names. This would be particularly useful if you had many more employees: 

I think the author meant that at each time step the walker will walk in one of three random directions (x or y or z), not all three. Without making drastic changes to your code, you could replace this section: 

where is a super fast (internal C-compiled) function. Question 2 Is the argument handling OK? I wanted users of the function to be able supply either ppm or mz_tol, but not both. Am I using missing() correctly? There are two schools for this kind of situation: 

Next, we map each value of to the "group number" it belongs to (here, belong to group #1 then belong to group #2): 

Next, from a performance point of view, you are wasting a good amount of time and memory by creating and storing a new vector at each iteration. Instead, you could keep the same initial vector and only pass around start and end indices: 

P.S. is not very descriptive. You should consider coming up with a more intuitive naming convention. 

Please remember to always cache your selectors. To get the of an element, use instead of . There's no need to use two separate steps to first get the value, then set it. Instead, pass a function to , and return the new value you want. To convert a string to a number, just prefix it with the plus sign (e.g. will return the number ). It's safer, and more concise, than . When using CSS selectors, you should always strive to use the native CSS3 selectors, since they're much faster than jQuery's own custom selectors. and are not CSS3 selectors. In your case, you should use and , since they're native CSS3 selectors. Since IDs are unique per page, there's no reason to qualify an ID selector with the tag name (as you've done with ). Just use the ID on its own. Again, better performance. 

If you don't care about IE, you can check the property directly, which is much faster and much more reliable, since also contains any arbitrary data that might have been set (possibly by a plugin): 

Just keep in mind that this will query the DOM on every single !! Are you sure you can't somehow do this differently? 

Your code does not actually function the way you want it to. checks for the existence of that element, not whether its value is set. Your radio buttons don't have a attribute on them. They really should. You should cache your selectors. You're querying for a total of 7 times in your code, and an additional 4 times on every click. Instead of listening for every click inside , you should instead only listen for the event of the radio buttons. On page load, if there's a value in the input text field, all we have to do is check the correct radio button. The event listener will take care of the rest. 

Always write a function (with appropriate inputs and outputs) already returns a data.frame was not needed since is vectorized. This will be faster but it is probably a drop in the sea compared to plotting. The use of to add dependent columns interactively (no need to write over and over and your code is much more readable.) Make your code (especially the one you posted here) source the packages it requires. I had to look where was coming from Do not write code that throws warnings. Read the message carefully and find what the problem is. In this case, it was warning when trying to plot arrows outside the plotting area. Hence I added some margins and to the plotting area. Personal preference: put some space after commas and on each side of and binary operators. Also use linebreaks so your lines are never too long and add spaces to make things align when you get a chance. I have removed your comments because they were not using the R syntax (need and not ) but that's an easy fix. Yes, comments are good and having a lot of them was great. 

Since you seem focused on functional programming, the main suggestion I'll have is regarding the use of arguments. It is recommended functions use all their arguments (see how does not use ) and more importantly, that they only use variables that are either passed as arguments or defined inside their body (see how uses that is defined outside). Fixing for that and making other personal but minor changes, the final code would look like this: 

In addition, Crockford suggests that you put the calling parentheses inside the wrapping parenthesis. 

Don't use , even if you think that in this particular case it's safe. Even if it were, it's still slow, and not supported everywhere JS is. There's no point in using this function if you know that the path exists. The whole point is to try to fetch something through a deep path without an error. I think you can skip the console logging bit. It'd make sense to allow the user to provide a default value to be returned if the final path segment is not found. If you're doing this, you may as well support arrays too. 

jQuery's method can take a callback function - it'll be called for every element in the collection - and will use the returned value to set the element's html. You can use bracket notation to access the key in your , so that you can dynamically get to the key you want with the string in the brackets: 

To make all this easier on yourself, don't re-invent the wheel. Look into John Resig's tiny inheritance library: Simple JavaScript Inheritance. 

In the regex above, we're looking for any characters in the string that are not in the bracket group. If none are found, will return 0 (which when negated will result in ). If any of those characters are found, will be returned and negated to .