I built a light but fun AI project using the Twitter developer API and a simple Python program to bring my dog Maggie to Twitter. If you send a direct message to @maggielistens, you'll see what I mean. This program uses a version of an old program from the 60s called Eliza. It acts like a therapist by responding to your commments and questions. It uses regular expressions and text replacement to appear like a real person. It won't pass the Turing Test, but it's a fun way to get students interested in AI and programming. 

I briefly discuss spacing, braces, and general readability. Then I open Eclipse and demonstrate [Ctrl]+a, [Ctrl]+i. This instantly indents your code according to a default standard (which is configurable). Since there are so many concepts to cover in class and limited time, this is one shortcut we take. 

I believe something is lost when you simply copy and paste code. They say that to learn a definition of a word, you read it, say it, and write it. So I think typing code definitely adds value, especially when IDEs like Eclipse have autocomplete and syntax checking. Typing is a learning experience. Unless you are copying from a raw format, copy and paste could bring in invalid characters. For example, try copy and pasting "hello world" from Microsoft Word to your favorite code editor. You'll see invalid double-quote characters pasted. 

Do you allow students to submit "test corrections"? Meaning, do you allow them to take the questions they missed on a test, denote the correct answer in some way, and give them partial or full credit back if they then get the answer right? If so, why? If not, why not? I'm wondering, because I have a colleague who has ALWAYS allowed test corrections in her CS courses for half credit. I NEVER have. But this year, for some reason, I am getting a lot of lip from students like "What! No test corrections?! But Ms. Xxx always let us do test corrections!" I believe allowing test corrections (which is essentially a retake) does a disservice to the student because it allows them to be lazy. They don't do it right the first time. They don't study (or don't study as much as they should have) and depend upon "corrections" to make up for their laziness. My colleague believes allowing test corrections at least forces the student to "discover" correct answers to questions they may have never revisited otherwise, and that therefore they have another opportunity to learn. Am I being too hard? What do you think? 

If the system is object-oriented, you can use UML class diagrams to document the design. Eclipse has a plugin called ObjectAid that generates these diagrams from the source code (no additional work required). Students can generate professional documentation from their source code. There is jsdoc for JavaScript and javadoc for Java. These require specific comments and tags, but it's well worth it. Source code documentation is important for future development. For all types of diagrams, there's draw.io, Balsamiq, PowerPoint, Visio, and many more. A picture is worth a thousand words. 

It depends on the programming level of the students. In my case, students are just starting out with Java. I tell them to ignore the quirks and multiple ways of doing things (e.g., adding 1 to an int var). Find a way the works and go with it. Then discover the different ways as you progress with the language. These students are new to basic programming concepts and problem solving. Language syntax shouldn't stand in their way. 

This sounds like a question of vetting. Here are some things I do when evaluating Node.js libraries: 

Of note from other posts: Reading the answers to Techniques for encouraging pair programming and What advantages/disadvantages have you seen with Pair Programming in the classroom offers insight into the problem of encouraging students to actually "work" together, which can be part of the problem here. The real issue, however, isn't that the other students aren't willing to do the work, rather that the Lone Ranger just does all the work, usually before work begins, without the others even having the opportunity to work. Two other questions, Is it possible to ensure division of labor on a group assignment?, and Problematic student at a very high level, help with creating the environment and assignments to enable group work, and determining if someone has gone rogue and done all the work. Neither deals with preventing the Lone Ranger from repeating once the problem has been identified. 

Every career has "gotchas". There is something about every job that is undesirable. That's why it is called a "job". But students can make sure they are matched as well as possible - minimize the "gotchas", so to speak. I entered CS because I loved to write code. I stumbled into the field as a junior in college and immediately changed my educational course. I am thankful for that "accidental" encounter, but it wasn't an accident, I don't believe, that I loved computing as soon as I was exposed to it. My "desire" had been predicted. I remember taking a career assessment of some sort as a sophomore in high school. I remember the career assessment saying I was a good match for "computer science". I remember thinking "what the heck is that?" (this was prior to the PC revolution), and I remember immediately dismissing the results of my assessment. But the assessment was correct. I say all that to say this: students should be encouraged to use career and interest assessments in high school, maybe even repeatedly (once a year). A quick Google search reveals many free assessments, and my state's college foundation provides 7 of them for free in one place. Up until recently, the students at my high school had been required to do several of these assessments as sophomores. Unfortunately, with a change in management, that practice ceased. But I still have my students do them as part of my class. We all should, I think. Using assessments such as this at least helps students better understand themselves, and may prevent them from making a very bad career choice. Of course, sometimes the assessments will be downright wrong (I recently had a student, one of my very best programmers, who loves to write code, is good at it, and knows she wants to go into CS, have an assessment tell her she should be an artist; however, I don't believe it was entirely off track because her code is very creative and is an artistic outlet for her). But sometimes career and self-assessments will help a student think outside the box about what they want to "be". And that is a good thing. Another thing my school does is bring in professionals to share about their jobs. They speak briefly about their backgrounds, what they do, what they like about their jobs, and what they dislike about their jobs. They usually speak during lunch in a classroom. The kids eat their lunches while they speak. It is very informal and always well attended. The feedback from the students is always very positive. Our local CDC (career development coordinator) organizes these "Lunch and Learn" sessions, as we call them. We have 5-6 a year. These are tangible things you can "do" to help students get ideas about careers. Some students may still fall headlong into something that is not a good match for them, because of tunnel vision, or peer pressure, or parental wishes. But some of them will identify or reinforce what they love to do, and they will be willing to make the trade-off: you pay me to do what I love X% of the time, and I will put up with the 100-X% of the time I have to do stuff I don't necessarily like. 

It depends on the situation and your school's policy on academic integrity. At my school, it clearly states that authors may not knowingly permit other students to submit their work. You may want to ask your school to update its policy to include a clause like this. You will have to determine if authors know if other students submitted their work. The author could be a student in the current class or another class. The author could be a stranger online. In a previous class, I suspected that one student submitted another student's program. This was confirmed when I saw that the filename included the original student's first and last name. After discussing this with both students, I resolved it. I can't say that I follow a hard and fast rule. I think it depends on the situation (severity of the violation, actions of both parties, etc.). 

My biggest challenge each semester is keeping students engaged in class. It's obvious that most of them would rather be somewhere else. I don't know if it's the students, my lecture, or both. I wish I had the resources to present a lecture this way. I believe that generating interest is just as important as the content itself, because this builds a passion for CS that will fuel future learning. How do you make your CS lectures more interesting? 

I think this answer is a little different, please remand me if not - I provide an algorithm with my coding assignments, and I almost always have code I can point to in their notes or previous assignments that is exactly what they need to fill in the algorithm. First I give a general description of the problem: 

I'd like to introduce my students to Nodes and then require them to implement their own Linked Lists, Queues, and Stacks before showing them that their language (C#) provides implementations of these data structures. I suppose my motivation is that they will 1) understand better how these structures behave; 2) gain general language practice; and 3) appreciate libraries and be more motivated to search for an implementation before writing their own. Is my motivation valid? What are other reasons to ask them to implement these data structures? Is there any reason NOT to ask them to do this? Would I be wasting my and their time? 

In my experience, there are always students who are resistant to moving to more advanced constructs. They want to stay with what they already know. For example, when they are taught arrays, they continue to use individual variables when they are able. When introduced to the foreach loop, they continue to use bounded for loops. When they learn about functions, they resist modularizing their code. After working extensively with arrays, they don’t want to move to using built-in collection types that offer more flexibility and behavior. It is sometimes difficult to impress upon beginning programmers the usefulness of “new” constructs, because the exercises and programs they are capable of undertaking do not sufficiently demonstrate the power and usefulness of those constructs. What are ways to encourage beginning programmers to embrace more advanced constructs without penalizing them? I am looking for more "carrot-y" answers than "stick-y". 

Paired programming is very effective at work too. We use Skype for Business to share screens (i.e., editor/output windows) and communicate in real time. If you don't have Skype, you can use Slack. Add GitHub or Bitbucket to quickly share code, and you have a very collaborative environment. 

Recursion is sometimes difficult for students to grasp. It's important to understand the concept before implementing it in any programming language. My college professor said that recursion may not make sense today, next week, or next year. But one day it will come to you, maybe when you least expect it. I show this image to help students think recursively. Next, I'll start with a simple recursive program to calculate the factorial of a number. In class, I simulate recursive calls with pieces of paper. I start by writing fact(10) = 10 * fact(9) on a piece of paper. Then I write fact(9) on a new piece of paper and pass it to a student. The student adds to it by writing fact(9) = 9 * fact(8), writes fact(8) on a new piece of paper, and passes it to another student. This process continues until a student must calculate fact(1), which is simply 1. Then all the papers bubble back up to me, and I calculate the final answer. But even with these relatively simple examples, sometimes it takes time to understand recursion. More simple examples help. 

Fleshing out something I mentioned in a comment to another answer - a very simple thing I have done in the past is to set a timer for myself in class when I feel things have gone south, for whatever reason, to give myself time to regroup and possibly even change direction. Setting the timer forces me to admit that things are not going the way I expected (to myself AND my students) and focus on determining what to do next. It may just be three to five minutes - but do it, and make yourself sit down and actually think. You will be surprised at what you might come up with, either based on plans you already have for another day, or something you may have already covered that you need to reinforce. Our role is, yes, to teach students our content, but more importantly, it is to teach them to be lifelong learners. I can model that by learning alongside them, even with a subject I think I "know". I can also show them that I make mistakes and missteps - but that I will make a correction and keep going. 

In the software practicum that I teach, students develop new software for a real customer. My school has a standard software license agreement that the students, customer, and I must sign at the start of the semester. The agreement basically gives ownership to everyone involved. The software becomes, in a sense, open source. The agreement has two separate clauses. One gives more "ownership" to the customer. There is some flexibility; one past customer worked with the university to modify the agreement. Also, students could hire their own lawyers to represent them. But I have yet to see that happen. 

One analogy I use in my intro class is transportation. The Internet is the roads, bridges, and highways. The World Wide Web is the cars and trucks that travel along these routes, carrying cargo to/from different places. 

There are endless examples that illustrate selection. As you know, most useful programs have at least one selection statement. I've found that some students struggle with the concept, so I start small and pick examples that resonate with students, for example: