You might check to see if the triangles in each index variant are still listed in the same order (for instance, sometimes it's A0 B1 C2 D3, sometimes it's B0 C1 D2 A3, but always the same triangles come before and after each other in the index). If that's the case, you might be able to calibrate when you instantiate your gameobject by shooting a raycast at the triangle you want to treat as index 0 and noting the difference between 0 and its actual index. You could infer the index of other triangles from there. 

In short, what you're doing is moving around some reticles right in front of your camera to overlap invisible objects you put in the player's line of fire. If you don't want to have the reticles sitting in front of your main camera at the near clipping plane, which is usually pretty close, you can consider these options: 

Actually that is not that hard. As I don't know your complete design, I will just talk a bit more general. I assume, each block construct as an independent enitity. So in picture 2 as an example, you would have 3 entities. I also assume, that your design includes mass for each entity. If all this is correct then next will help you. As soon as 2 entities collide, determine the one with the bigger mass. This entitiy transforms into the parent entity of all other entities colliding. So now they all move no more independent, they are driven by the parent. The velocity break if 2 objects collide is a physics based calculation. After the collision just move the parent with it's break down velocity. When another collision is detected to the calculation again, but update the mass of the parent object to have the mass of all children too. 

You could, at runtime, assemble your children's colliders into one big collider that you add to the parent. In order for this to work the way I've done it below, the children would have to have Mesh Colliders, even if they were box-shaped: 

You never stop dragging the block; it simply appears to the user that the block has stopped dragging while it would intersect with an obstacle. 

It's difficult to detect collision without any rigidbodies involved, but since you're using cubes you may be able to use Bounds.Intersects. Each update, check if the dragged object's bounds intersect with any obstacles' bounds. If it does, then you could try this: 

It sounds like you've done a lot of math in 3D space to try and support this feature, taking into account the position of the ship and the camera, etc. But unless I'm missing something, I think there's an easier way. This should work whether you want the game to be in first-person or third-person view. 

It seems like you are missing to move the transformation of the player high enough. like on the picture I think the problem is, that you set a jump height according to the animation and not to the player without animation. So jump height looks fine when in crouch position, but when u turn of the animation, you will see, that the player model jumps way to less high. I think this is your problem. So just fix the jump height and all will be fine. As a side node, an animation should allways be applied only, when the actual movement is ok. So in your example, only when the player model jumps correctly to its complete transformation, then apply an animation for the whole duration of the jump. 

Most games are designed, that they predict something for a short period of time. So in our case, the server hasn't received the NKP package, so he predicts, the user is still jumping. This will happen for let's say 100ms. After that the server predicts that the user falls back to a default which in our case would be NKP. After some time, the server receives again packages of the client. Corresponding to the correct order, he now knows the correct state of the last package of the Client send. In our case still JKP. Now the server looks in his list and has 2 options: 

Make two reticle objects that look however you like. Make them children of the main camera. Place these reticles anywhere on the X and Y axes, but keep their positions on the Z axis right in front of the main camera, exactly at the near clipping plane. On the main camera or the Game Controller, write a Reticles Manager script. This script should watch the two empty game objects you placed in front of the ship and use Camera.WorldToScreenPoint to obtain their screen positions relative to the main camera. Once it has those positions, the Reticles Manager should move your two reticles to those two X and Y positions (keep the Z fixed at the near clipping plane). 

After that, it would be up to you to disable the Mesh Colliders in the child components, or not, as your program requires. See this documentation for more information: docs.unity3d.com/ScriptReference/MeshCollider-sharedMesh.html docs.unity3d.com/ScriptReference/Mesh.CombineMeshes.html 

To be honest, I can't even imagine a single scenario, where with well implemented client interpolation an input lag would be perceivable. Just to counter check - Client Interpolation summarized 2 Concepts meet up 1) The Interpolation itself - let the client live in the past (ae 100ms) 2) The client sends every data with a timestamp, and the server has to keep the data of all entities for some time (ae 500ms). Now for actions, that depend on other entities, like shooting, the server now can verify the position of the other entities via the timeline and the send timestamp of the client. With these 2 concepts merged together, you have a working, well implemented client interpolation. So first of, if your current implementation doesn't meet the mentioned requirements then change it. If you have both methods working fine, I will need more information to assist you in locating the problem. 

Decide how high some obstacle on the plane has to be in order to block your dragged object (where "high" means removed along whichever axis is appropriateâ€”I'd assume the one that points toward the camera). Each update, save the position of your raycast hit. Each update, before saving the position of the current raycast hit, check the position of the current raycast hit against the position of the previous raycast hit. If the difference >= blocking height, stop your moving object at the previous raycast hit position. 

Disable the Mesh Renderer for the dragged object to make it invisible (but continue to drag it). Drop a visible, placeholder object identical to the dragged one at the last position before bounds intersection (now it looks like the object stopped, but really you are still dragging the original). Each update, check to see if the bounds of the object you're still dragging intersect with an obstacle's bounds. When the dragged object's bounds no longer intersect with an obstacle's, delete/deactivate the placeholder object and re-enable the Mesh Renderer for the dragged object to make it visible again. 

Check if entity collides with another entity Check if the colliding entity is a "grounded" one If not grounded determine one as parent and set the rest as children If grounded free all children and do collision again for all If grounded and not children, set as children of grounded. If colliding with ground - free all children and set grounded 

For this to be handled correctly you need to design your network protocol to do something called "continuous transitions". Client send's all time packages to the server with a order. This way the server has always the last state of the client, regardless of lag or lost packages. Next step is you need to analyze the packages arrived. Back to your jump example. The user presses the jump button, and the client sends the following packages: NKP = No Key Pressed JKP = Jump Key Pressed [NKP] -> [JKP] -> [JKP] -> [JKP] -> [JKP] -> [JKP] -> [NKP] ... Each package has a order. So the server receives JKP and start's to update physics. Now the server doesn't receive packages of the client for any time. Now u have 2 possibilities