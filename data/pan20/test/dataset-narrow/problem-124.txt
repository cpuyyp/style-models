Yes. Option 1 is likely your best bet for simplicity's sake, but you can use the confederation method if you don't want to change the ASN. You can also do in the BGP config but this prepends an ASN of your choosing onto the path, rather than replace the ASN in the path, so updates from one router to the other would be dropped anyway. Unless there's a really good reason as to why you want to maintain the eBGP session, you can also migrate to an iBGP session vs eBGP. As @DanielDib has pointed out below, a third option (if you're running a version of IOS that supports it) is to use in conjunction with and to strip your ASN from the AS_PATH and send a different one: 

The best way to find out is to determine the version of IOS that your switch is running. will get you this information. Then look up the version of IOS using Cisco's Feature Navigator. You will be able to determine what exactly your version of code supports and what it does not. 

While I don't think it's as "robust" as H-QoS/giving percentages based on DSCP values and would probably require more configuration overhead, you could rate-limit outbound against L2 ACL's that reference a VLAN. Example: 

ETA: the rules may be superfluous, since one shouldn't be generated if the original is filtered by the ACL. I don't have a Brocade at hand to test. 

According to this document RVI's aren't supported on EX switches. Is your goal to transport the wholesale customers' stacked VLANs across your network? If so, I'm not sure that using RVI's would be what you'd want to do, since transport is usually the inherent goal in PB, rather than doing Layer3 termination for an S-TAG. You're probably going to want to go with PBB or MPLS/VPLS in order to transport the customer's S-TAG's - the latter two options would still need an MX (I'll defer to the more Juniper-proficient for other options - I believe mellowd has also recommended the M series). Again this is assuming that your goal is transporting your customers' QinQ traffic. 

EDIT: Just checked the literature - doesn't look like static LSP's are supported on MLX/XMR/CES/CER IronWare at least as of 5.2.0. :-/ My Brocade account rep also confirmed that LSP's signaled with RSVP or LDP are the only options and they have no plans to add support back in for static LSP's. Aside from the above, what you can do with RSVP is define a manual ERO for the signaled LSP to traverse, with a combination of or attributes. Example: 

You said you were running OSPF between all of these. Have you double checked that you have a full mesh of LSP's between your devices? (this is a requirement for vanilla VPLS). Have you configured and within on the ME3600's? I'm assuming that is actually representative of an LSP (I know the term "Pseudowire" has been thrown around in this question, but to me Pseudowire = L2VPN/EoMPLS/VLL). LSP's are only unidirectional, so it's possible that because of a lack of a full mesh of LSP's, the ME3600's can see the other's loopbacks in the routing table, the P routers may be interfering with the RSVP signaling/dropping things on the floor. 

Yes - this is commonly done over metro Ethernet circuits via an L2VPN solution (ie pseudo-wire or VLL) or can also be done with L3VPN services from a carrier - but this means that you need to participate in routing with your carrier - more often than not however this will require more complexity in your L3 domain; so rather than doing this, it is possible to run OSPF over a GRE tunnel, as @JeffMcAdams has mentioned. It's usually more desirable to utilize an L2VPN-based solution. 

(Fun fact: I used to work with the guy that originally wrote mtr in '97) If you check out the source on github, specifically in , there's this tidbit: 

Note that the above will need to be configured as an outbound filter on R3 for the eBGP session with AS1000. Using the well-known 'no export' community is likely going to be your best bet, along with being very judicious with your outbound announcements to AS1000 and AS6400. 

You can't. Any subnetting operation will always be based on a factor of two, because the binary number system is base 2. Therefore splitting up any network into specifically three equal sized parts won't ever be possible. You can however split up 192.168.53.0 into four equal-sized subnets: 

ipNetToPhysicalPhysAddress ipNetToPhysicalLastUpdated ipNetToPhysicalType ipNetToPhysicalState ipNetToPhysicalRowStatus 

Is the router taking full tables? If it is, I guess I wouldn't be surprised that it's taking a long time, seeing as how it has to resolve however many networks that represents a full table to an exit interface (RIB->FIB). Also remember that the 7200 is still a software based forwarding platform. You still have 3 more layers of CEF above you in terms of which ones are faster. If a large number of those adjacencies are punt adjacencies (an entry that would have to be punted to the next-level switching method) or glean adjacencies, this may also explain why it's taking a long time - and I'd imagine that a large number of them would be - again, still assuming it's a full table here. The number in parentheses is called the refcount, and represents the number of times that adjacency is pointed to by FIB entries. Edit: regarding canceling the command, try Ctrl+C (repeatedly) - sometimes this works for me for killing long-running commands. OTOH if I know the command will produce a lot of output, I'll set "terminal length" to something like "50", that way I have the option of killing the command by way of output pagination. 

As @ytti mentioned, you could configure eBGP multipath, or you could also configure 2x static defaults, each one with a next-hop of your upstream. Since they're both on the same router and all you're receiving from them is a default from each provider, it's fairly simple to set up. You also want to make sure you have CEF per-packet load balancing turned off if you're running Cisco (the default setting is disabled anyway). 

Every single address within those ranges will share a common leading bit(s). The moral of the story is, if you can remember what the leading bits are supposed to be (0 for class A, 10 for class B, 110 for class C) it's extremely simple to determine what "class" an address would have otherwise belonged in. Or, if decimal is easier: 

It's not appearing that way. You may want to redirect your query (either regarding the looking glass itself or the issues you're having that are prompting you to search for a looking glass) to the Telefonica NOC. 

It's important to note that PVST/PVST+ is Cisco proprietary. They do support one instance of STP per VLAN, and it is enabled by default. You can enable/disable STP on the following levels (taken from the NetIron config docs): 

You also need to consider console port security - ie making sure AAA is enabled on the console. If the ProCurve doesn't support AAA on the console port, then make sure the login password for the console line is strong (and maybe rotated every 90 days or so). 

Have a script that logs in to each one of your edge devices and grabs the MAC address tables off of them. You'll want to exclude trunk interfaces for this, but it would be trivial to create a hash (or dict for you python people) with the keys being the edge switches and the values being another hash that's basically "mac.addr -> interface". This will eliminate the need for you to chase down MACs on your edge switches, which is most of the legwork it seems. I can recommend using Perl's or Python's to make this happen (this assumes you have access to a *NIX box). Use SNMP to query this data, which will eliminate the need for a script to actually log in to switches and run commands. You're on your own to look up MIBs for the MAC address tables, but here's a Google search to get you started. If you're on Windows only, you can use SecureCRT or TeraTerm to set up macro's to "half-automate" this for you, but my experience with either of those is very limited, so YMMV. 

Obviously you can specify enable passwords for all 16 privilege levels if you so desire. My final point is that without an external AAA server, all of this is a giant pain in the ass. There are a multitude of open source TACACS+ implementations available that only have a cost of initial setup, but they make doing stuff like this somewhat trivial, and it's centralized, so if you have multiple routers you don't have to keep repeating the same command privilege jumprope on every device you manage. This is why AAA servers exist in the first place, so your requirement that you don't want to use one doesn't make a lot of sense. 

NAT is an option but it's going to be complicated, and overly so. IMO the better solution to accomplish this is with VPLS or L2TPv3. Contact your carrier to see if they can provide VPLS or other L2VPN services. 

Jens has a great technical answer (and got an upvote from me) but the other aspect is human readability, because as humans we were always intended to be the "things" that would need to understand these addresses at a higher layer of consciousness that machines do not possess. Conveying a 48-bit address in decimal would be less efficient than conveying a 32-bit address in decimal (in the context of human readability; everything is binary to a router/switch/whatever). For example, the number space that's able to be expressed by 32 bits lends itself nicely to carving that space up into evenly-sized chunks (the chunks here are bytes, or octets) of 8 bits each, and you have a maximum decimal "capacity" of 255 for each one of those chunks. This would naturally lead to representing those addresses in the dotted decimal format, because you won't ever have an octet that's longer than 3 decimal digits. A MAC address is different. Hexadecimal is more efficient here because you can express more with less, and you are again limiting the scope of the length of digits to compensate for the larger address space. There are 6 octets in a 48-bit address, and each hexadecimal digit is 4 bits; you won't have any octet in a 48-bit address be longer than two hexadecimal digits. 

The issue is that you're operating under the notion that each layer is in and of itself a separate, autonomous entity. Understand that IP is not the only packet delivery protocol in existence, it just happens to be the most common one. Also understand that these "layers" are simply abstraction tools - the take away is that each "layer" is dependent on the one beneath it for some functions, and the layers further down the stack can hand off certain duties (ie reliable data transmission) to the layers above them when appropriate to keep overhead low and performance high. Each lower layer encapsulates data sent from the layers above it on its way down to the wire, and the lower layers decapsulate the data on the way back up the stack to the application. The paper you linked about the data link layer even states that while its delivery mechanisms are intended to be reliable, they are still best effort, and there is an assumption made that higher layer protocols (ie TCP) will handle retransmission if necessary. 

The behavior of a router is to send packets to a destination based on the longest prefix match. This simply refers to the specificity of a route determined by it's mask length. It's exactly analogous to putting a letter you've written to your friend in Albuquerque, NM in the mailbox. If you just write "Albuquerque, NM 87111" as the destination address on the envelope (as opposed to "12338 Anyplace Street Albuquerque, NM 87111"), your letter will get to Albuquerque - if your local postal carrier decides to not yell at you, but using an accurate address will get your letter to the right place. Abstracting this concept to IP addresses and routes: if all three of these routes exist in a router's routing table, which one of these do you think a router would choose as the proper route to send packets to a destination, if the destination IP address is ? 

Revising answer/consolidating comments and taking another stab (disclaimer: my MPLS/VPLS experience is not on the Cisco platform). Trying to infer how your topology looks: 

You have multiple Linux solutions for first hop redundancy out of your LAN to the two routers (Quagga itself doesn't support VRRP but you can use Quagga in conjunction with any of these without any issues): 

Yes. Both of the OSI and TCP/IP models are pretty old at this stage, and the TCP/IP model was created more specifically to "operate" with the IP protocol suite (the TCP/IP model slightly predates the OSI model). The OSI model was created by the ISO (International organization) and TCP/IP model was created by the U.S. and is maintained by the IETF. Even if TCP/IP didn't turn out to be the predominant protocol suite used on the Internet as we know it, with things like Moore's law and increasingly complex applications/protocols that can span multiple layers, the OSI model is becoming somewhat obsolete. The reason why layers 7, 6 and 5 are all crammed into the Application layer in the TCP/IP model is that the folks that created the TCP/IP model believed that those responsibilities should be handled by the application itself, rather than within neatly laid out abstraction layers (thus helping to ease potential confusion that your question calls out). 

In response to your 2nd question, the answer is - it depends. If there is VLAN tagging between your two switches, then the L2 header would be modified with one or more VLAN tags on the connection between the two switches (however, this is not to say that any MAC addresses directly associated with the 2960s themselves would be involved in any kind of forwarding decision between the PCs - they wouldn't be). Assuming VLAN tagging is not being used in your example, then the answer would be no. Each switch would only know that there are multiple MAC addresses learned on each of its interfaces that have the connection to the other switch. The top 2960 would have a MAC address table with 4 entries, and those entires would be the PC MAC addresses. One PC MAC on each of those ports, and 2 PC MACs learned via the interface that the bottom 2960 connects to. Similarly, the bottom 2960 would also have a MAC address table with 4 entries. One per PC MAC that was directly connected to the switch, and another 2 PC MACs learned via the interconnected interface to the top switch. Edit: And for completeness, as Ron pointed out, the L2 header is not modified when the frames are not crossing an L3 boundary.