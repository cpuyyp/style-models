I'll point out that IPv4Networks can return their first address, using an index of . I'll further point out that an IPv4Address can be converted to an integer using . Thus, you can sort your CIDRs according to the first address in their range, and you can sort your IP addresses according to themselves. The two orders will be comparable. This means you can essentially "merge" your two lists by sorting them in order, then iterating over the two of them in parallel. This will be essentially O(n log n) + O(m log m) + O(n+m) time, where n = number of addresses, m = number of networks. 

In your function, can do everything you need. I'd suggest renaming the function to and just returning the generated grid. In your and functions, the parameter knows its own size - you don't need to pass that in. In , your and colors could be in a tuple. Then you could index the tuple by [0] or [1] (the value of the cell) to determine the color: 

That's a lot of letters to get 4 numbers into a list. You can, and should, do better! "How can I do this better," you ask? Well, post it on CodeReview of course! But also, consider how the Python class (and , and , and , and ...) is initialized. And how the Mutable Sequence Types are expected to work. Because your code is implementing a "mutable sequence type." So there's no reason that your code shouldn't work the same way. In fact, if you want other people to use your code, you should try to produce as few surprises as possible. Conforming to an existing interface is a good way to do that! Create an initializer that takes a sequence. 

We're back to the approach. You don't actually return in your checks. Your code is "falling off the end" and is vulnerable to whatever happens to be in the return register. (Probably the result of the last condition tested, but still...) You have written functions to do these checks, but you're missing one function. Instead of putting calls to in your main routine, why not write a function called and summarize the results? 

Implement a blind method. This method doesn't know anything about the other entity, but it does know it's own type: 

Instead of updating a global score, perform the addition if the answer check returns true. This doesn't make your code shorter, but it's good coding style (avoid global variables when not required): 

You wrote two answercheck functions, but you always use an statement to determine which function to call. Put that logic into a single answercheck function: 

In this design, your has-a collection of objects (or , or , or whatever) that are created while parsing the input file. The knows the starting tag either because it was the first in the file, or because it was explicitly specified in the file, or because it is a parameter to some method. The knows how to convert a tag into a by some kind of lookup: could be an array, could be a map, could be ... whatever you like. Finally, the knows how to print itself on an output by choosing links and telling the various pages to print themselves. I have suggested the as a constructor parameter, but you could certainly configure it separately, or pass it as a parameter to the method. (I don't recommend this.) The objects hold text, and they hold links to other objects using some kind of type, as mentioned above. They hold text labels to be used when choosing which link to follow. They know how to translate an input choice into a tag, although this may be a coupling flaw (you could refactor in an input-to-page-link translator, but for now a string to tag method seems easy). As a special case, the objects know if they are a valid END page. (If you wish to continue past an optional end, that seems doable without too much hassle.) Finally, the knows how to print its text on an output stream. 

The Python VM is a stack machine, so every opcode either takes something off the stack, puts something on the stack, or both. For example, the various ops put things onto the stack. The op calls a function (which is stored on the stack) with a number of arguments. And takes two arguments off the stack, multiplies them, and pushes the result back onto the stack. There's a couple of optimization opportunities here that are good "rules of thumb." You can take this knowledge and apply it to any Cpython code you need to speed up (note: Cpython). First, there's that at the front of the expression. That's fairly harmless, except that on the very next line you multiply by 6371.0, and you never do anything else with the variable - it's just a temp. So to squeeze out some performance, go ahead and move the to the next line. It turns out that the compiler will go ahead and do constant math in the same expression, so you can say and it will collapse that to a single constant. Second, note that there's this sequence of lookups all over the place: 

At this point, is a stack of generators that will only yield the rows you want. However, not a single one of them has been read! So you can just pass this in to your output code: 

Your collision detection routine is not needed, because pygame provides a collision detector for both rectangles and sprites. Just call whatever flavor of is most appropriate. You import windows-specific modules a few times. First, be aware that pygame has mouse support, so you don't need to call Windows for mouse information. Next, please make an effort to hide your windows-specific modules and code behind an interface. Ideally, make it conditional on the program actually running on windows. You can use the module for this. 

There's two things going on in there. The first, is called a slicing expression. It creates a "sub-list" of the list, with just the values in question. The second is the use of the built-in. Switching Faster Your second operation just changes values: 

For boolean variables, please evaluate the value directly rather than comparing it with or , like so: 

You return a list of chunks. But wait! Actually, you return a list of chunks ... backwards! You reverse the order of processing for no good reason. It's somewhat more convenient to you, in the sense that you can keep dividing by 1000 in the function. But it's not actually helpful for any other part of your code. All it does is require that somewhere, another piece of code has to reverse the order of whatever data it has. Here's a link to Ned Batchelder's Loop Like a Native presentation. Please watch it, even if you've seen it before, because it totally applies in this case! Instead of creating a list of 3-digit chunks and returning it (backwards!), why not create a generator? Furthermore, since a forward generator will have to know about powers of 1000, why not create a generator that will also deal with your powers-of-1000 labelling? You can kill two birds with one stone: 

In terms of implementation, and making it more efficient, I don't think the linked list adds any particular value. I would rather see you implement the stack using a built-in , which will improve both memory performance and speed. So far, you have implemented and iteration. Why iteration? I'm glad that it's destructive, but I don't understand why you felt you needed that. I would suggest that you look at Python's Common Sequence Operations to see which you can implement. If you choose not to make the stack transparent, that's okay, but it might limit applicability. A transparent stack should be able to support , , maybe indexing, etc. Likewise, have a look at the Mutable Sequence Types section and common operations. Also, check out the Abstract Base Classes for collections, and add whatever parent class(es) you implement. Keep in mind that Python is a "consenting adult language." There is not a great regard for private data and access control. Instead, the expectation is that you will implement as much as you can, and not be surprised if someone wants to peek. So, I'd suggest trying to build as transparent and well-integrated a class as possible: allow accessing items on the stack via notation, support things like and , and inherit from whatever ABCs you support. If your stack is iterable, make sure you implement an Iterable abc. (Or Sequence, or Collection, or ...) 

There are a few things you don't say that might be important. First, is it a requirement that the inputs be lists? Or coincidence? Must the return value be the same list, or must it be a different list? Is the function permitted or expected to modify the input list? Is it prohibited from doing so? I'd suggest you reset your expected inputs to be Iterables, rather than lists. It's more general. Similarly, let's assume that your function behaves much like and returns a totally different list, without modifying either of the inputs. You spend some time and effort to filter the non-sorted values away from the sorted values. You don't specify how large you expect either of the two inputs to be, but if they are very large this might be inefficient. I suggest you create a sort key that is a tuple, and use that to sort the non-sorted values to one end of the result: 

I don't know what this is trying to do, but by default the is going to remove an item from the matrix row (assuming the matrix is a list of lists, and not some other type). Since you are iterating over , and since you don't after doing the , it seems like there should be an IndexError when you try to access the last element in that row. Edit: Also, you spell "Hogya" differently in different places, although this doesn't seem to matter. 

(NOTE: A little searching provides this module: $URL$ - I don't know if it's right for your needs.) I'll further recommend that your audioscrobbler module should accept the API key as an external setting. Which means you need one more local module: 

You're right - there is a lot of duplication. Also, some organization is needed. Organize! Before you do anything else, get everything into a function of some kind. All those statements at module scope, move them into a setup function, write yourself a , and do the standard Python thing: 

Back in the day, even before the official C89 standard was released, people were asking "why the hell does strcat not return the end pointer?" I believe that the C standards committee, in a fit of pique, "doubled down" on their mistake and made a willful effort not to remedy it, simply because it would be admitting that they made a boneheaded error in the first place. It's been a sore spot ever since, and now they've switched to which doesn't return a pointer at all, which leaves the problem unresolved, and leaves as an unloved and underused function. Also pretty much from the get-go, there were libraries of string functions that provided an alternative version of that did the right thing and returned a pointer to the end of the string. Often, those functions were named or , with the meaning "return a pointer to the end." There were also and various functions. (IIRC, Borland provided them with their Turbo C++ compiler.) Considering that you know the size of the buffer, I'd suggest you simply write (or search for) a version of and and maintain your own count of characters remaining. I suppose you could maintain both pointer and count in static variables, and accept a destination to mean "use the previous values". You should read up on first, though, to understand the implications - in general that sort of code isn't thread-safe, interrupt-safe, etc. ( has nothing to do with but it's defined to have similar "use the last string" behavior, and usually comes with a bunch of caveats in the documentation.)