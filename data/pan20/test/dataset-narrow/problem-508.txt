should be guarded Currently, the instance if filled in via the Main thread. If the GUI (on the EDT or through the timer) later requests the instance, there is no guarantee they will see it, or they might see it in an inconsistent/incomplete state. This can be solved by either making volatile or, perhaps better, making a synchronized method. is on a best-effort basis It looks like this is the basis for a game or other graphically heavy application (judging from FPS). Swing (and its timers) may not give you the timing guarantees you'd need for things like game logic. Consider using a game loop with a Canvas and a BufferStrategy, disabling redraw requests, and taking over from there. Isn't the Timer good enough? I'm tempted to say, yes, it might be good enough, if the game logic is simple and not intense. Though you're no longer blocking the EDT with Thread.sleep (big win), the actions that the timer calls are still executed on the EDT. This makes handling GUI elements and fields much simpler (no sync needed), but heavier stuff may result in jitter. Worse: heavy stuff on the EDT may make your game loop jitter. In short: the timer is simpler and probably good enough. The game loop in a separate thread (say, your main thread) is more heavyweight but also more reliable and more likely to benefit from hardware acceleration. 

That leaves us with abilities. I'm not sure how 'complicated' abilities will be in your design, so I'm going to use mostly the same approach as before: 

Review isn't used. What is it for? The method is declared to return , but doesn't. Consider adding braces to all code blocks—including and . This will prevent errors from adding lines later. and could be replaced with (left-hand side) and (right-hand side), but that's a bit nitpicking. In order to implement returning 0 for equal elements, try using : 

Parsing is always a bit complicated/ugly in terms of code—a library like ANTLR can do some of the heavy lifting for you. But let's assume some level of reinventing-the-wheel for practice/exercise. Recommendations What follows are fairly broad recommendations based on the question: "If I were responsible for maintaining this code, what would I do?" 

Remove the packing by '#'; let the database worry about compressing results if it really has to. Split out the IP addresses so that you have a clean Id x PrimaryIP M:N relation. This will make querying on PrimaryIP easier. The CIDR will be a bit harder to fit into this. See if you can make an extra table that stores IP ranges per minimum and maximum possible IP address. For instance, 10.0.0.0/8 would be 10.0.0.0 -> 10.255.255.255 . This way, you won't have to store every possible address. Now that you have a more direct schema, you can make the database do some of the heavy lifting: 

In case of many, many catch clauses, consider using on a successful run, and in all other cases (though this is not a common code construct and merits a comment for future readers): 

Depending on your style and preferences, you could also make an abstract class and move the delta-limiting method there: 

The relevant classloader will handle loading the class and running its static initializers in a thread-safe manner the first time you call it. 

Reviewing Present Code This answer is focused on reviewing the code as given, with less focus on the design than the code itself. PatientType is a code letter, a short-hand; call it or or such. is convoluted, and it is not clear what 'value' means. Instead, try: 

The two main issues I see are not really code flow related. One is that you don't really have a protocol to communicate with your clients (as in, reporting success or failure, interpreting commands, et cetera). The other is that your server may be prone to stalling. Your serving loop looks like this: 

I don't really see an issue with having a generic name for a generic class. If your calculator class would've been called Utils, or your utility class Calculator, that would be an issue, but basically a namespace for utility methods? Utils is fine. That said, about that Utils: 

There is a possible performance issue in connecting and disconnecting from a database with each request. Setting up a connection can be expensive, so if these connections are not pooled/cached/reused on the driver level, you may want to look into libraries or techniques for JDBC connection pooling. (Also be sure to close connections you get from your driver. Database connections are external resources that can not be reliably handled by the garbage collectors, and need to be explicitly cleaned up.) As far as I can tell, you already have the driver you want; why work through DriverManager? Ask your driver for the connection: 

is immutable in Java, meaning any operations that result in different data will result in a different string. also (usually) creates a new string. The input ends up creating eleven new strings before returning its final, twelfth string! + = 

There doesn't seem to be a way to retrieve the from a . You've provided delegate methods, but if you change the interface, its extra methods will not be accessible unless you also change the class. Now, interfaces ideally don't change often, but it's something to keep in mind. 

Factories are an abstraction for how to obtain instances, as distinct from explicitly pooling, singletonning, or creating instances (through constructors) from client code. Exactly how far into this abstraction you want to go is a matter of debate and, in some cases, ridicule, but this base abstraction is what you need to keep in mind when designing them. Because factories are a means to an end, it's hard to tell whether your factory will be helpful without seeing your use case. What will your use of the pattern help you accomplish? (As a hunch, I'd recommend you to look into dependency injection.) 

L3 * L5 gives you an algorithmic time complexity approached by Θ(n²) (consider the case where no numbers are repeated). If the input is already sorted, you can find the top in a Θ(n) fashion: 

Depending on your needs, there are ways around this but, sadly, none of them will work automagically, and they may require some effort. Only you can decide what's warranted and what's overkill. From what I can see, you're building a GUI for chips or circuits. I imagine you want to provide a component that lists gates for your users, much like the component buttons in WindowBuilder or Matisse. Let's see how these solve the problem. Asking for directions WindowBuilder comes with the standard Swing and AWT components out of the box. Since these will be in pretty much any Java distribution, they can just add the components manually once. It's a bit tedious to do, but you only need to do it once (and maintain forever). What about components that aren't standard, like when your users make stuff of their own? Well, there are three main ways that jump out: