define the variables with interface types: this includes method arguments and return value. This will allow you to change concrete implementation with minimal changes. use short form if (without braces) judiciously. it makes the code less clear and is prone to errors. Some ppl will say do not use this at all. when I use it, I put the condition and action in the same line: 

and the mixin classes can be interfaces (they never get initialized) with matching setter method signatures and different annotations 

First of all, I do not understand how this may happen, since in you ask on unequality of user ids. anyway, at the very least, you should make a method like . 

(this is following the performance advice regarding processing of sinlge lines) and you wil have several implementations like 

I am not sure how many lines of code can be reduced but one thing is for sure: whenever you encounter a resource that can be closed, you should use Java try-with-resources feature (since java 7). Not only this feature saves you the operation (one line less!) but also ensures that the resource is properly closed by the end of the try block no matter if it ended successfully or not (the compiler adds a clause). in the current code, if an exception is thrown, the resource is not closed properly. I looked at the thrift javadoc and indeed from version 0.10.0, is auto-closeable. So the code on both methods should be 

If you have getter and setter methods, then the instance variables should be declared private. grouping the declarations of the variables (either at the top or bottom of the class) helps with readability (the reader doesn't have to search for the variable among all the methods) 

You can parameterize the @path annotation with regular expressions to specify one class/method that accepts multiple paths 

and there you have it: the enum and its counting implementation in one line. This will not always work. For example, with you need to keep state between invocations so you still need an instance of custom class. 

there is a useful example in this topic it shows how you can use a instance across methods, something that may be useful in your case. lastly, have a look at which seems to fit at least some of your requirements. if you are doind this asan exercise, then take a look at the class' source code and see hoe they dealt with thread safety issues. 

Do not use literals and constants in the code. Each literal should be defined as a static final variable. The reasons for this are 1) it gives the literal a name and meaning and 2) there is only one place where the literal value is specified, making it easier to modify the value. example: You do not have to initialize all instance variables in the constructor. Some of them may have default values. A new will always have zero attempts so why specify this value each time you create a new instance? The variable is declared as which is an Object and not the primitive type. This means that each time you assign a value or compare the variable to a value, there are additional actions that need to be done to access and modify the variable. It is more efficient to declare the variable as the primitive type. 

You are right in the concern about the concurrent access to FileWriter if only because you rely on this class to be thread safe. a quick google showed me this and it seems (on the surface) that this is not correct assumption. I would design This differently, although I do not know if the new design is faster: I would have the tasks only do the url look up. This is based on the assumption that this is the bottleneck in the whole process (seems reasonable to me...) So each task gets a url from the queue, does the lookup, gets the response string, parse into xml doc and put that into a separate xml-response-queue. the main method is responsible for listening to the xml-response-queue, doing the file writing and populating the url queue with child links. 

It is a question of how much will the project expand beyond what is described here. For instance, are you going to persist driver details and other data? if you are going to use a database, then you will probably want to use an Object-Relation-Mapping (ORM) framework, and they tend to expect Java Beans to work with. perhaps you will want to develop a web api that will send or receive such data in json format? json parsers/generators also prefer objects that follow Java Bean standard. for very simple, small, one-man projects it is probably ok to skip the boilerplate code of getters/setters. it is just that usually projects tend to grow and expand in time. another point that can and should be addressed now is the calculator: it feels wrong to me to create instances just to do fine calculation. if we make the analogy to windows calculator, it is like openning a new window each time you want to do a new calculation. the calculator is stateless: it takes arguments and produces a result. it does not carry any state between calculations. So I would make the method static and have it accept the two arguments. another issue is the calculation process itself. all the attributes of a fine are closely related to each other and come in mutually exclusive sets: the result is a textual description of the enum, the amount and points are also linked to it. I would make these values properties of the enum: 

Now, this puts the responsibility of creating complete valid s on the client class. If you want to be able to verify that the new s has all mandatory properties at the time of instance creation, you can utilize the Builder pattern and have the method validate that all properties were assigned: 

this is much better. you might consider breaking the above statement to two lines for further clarity. 3) String joining: Java 8 stream api can (and should) be used in almost all the places where a loop used to be. This is especially true with String-joining loops. For example, the entire loop that is used in the building of the SQL statement can be replaced by one line: 

Second, although the acronym stands for "comma separated values", parsers (and writers) usually accept any single character as argument for delimiter. this gives clients flexibility that sometimes is necessary. Imagine if an api produces files in the following format 

Java has a method. why is it better to use that than quering the size? because you might choose to replace with another Collection implementation, one that implements differently. in the method I would prefer to call 's method since it saves the doubt where adds the new item. 

why do you need two loops with the same loop condition and same break condition and some other identical lines of code ? and why did you put the exit condition as a separate statement? why not (by the way, there is nodefinition for ) The code also lacks documentation. a comment for each statement would explain a lot. the whole logic seems overly complex to me. the requirement can be easily fulfilled using one loop and simpler code 

The design needs overhaul. Specifically, the design of the class (and concept) Skills have properties and behaviors (=methods) that are related to the skill regardless of the caster. for example, each skill can be either casted on an enemy or on the caster himself. each skill has base power and mana consumption values, etc. Your code needs to clearly represent the properties and behaviors that define a skill regardless of the caster. You have in your game four types of Skills. if you have a finite set of values of the same type, the best way to represent this is using . So, if we make class an and remove the reference to , the design reflects the concept of Skill in the best way. For instance, initial values for the different skills are no longer defined in , but in , the "name" property is redundant and I found a new attribute that is related to this type: 

According to the numbers you provide, it just might be that you are trying to hold too mauch data in memory. Perhaps you need to persist the queue. There are many solutions for persisting a queue. Simply googling "java persistent queue" will give you many options. Another popular solution is to use some no-sql database as replacement for the queue. why no-sql and not rdbms? no-sql is better suited for high load apps and scales better with workload 

There is one problem that I see with your API and that is that the columns are referred by an int index instead of by name. Not only you have to remember the (arbitrary) position of the columns, but think what if you add or remove a column from one of your tables? considering that already holds a list of the column names (and does nothing with it except print it) it is trivial to change to receive a column name (or at the very least add an overloaded version). My next point is not an exact "Code Review" answer, However, I believe this is a "trying to invent the wheel" case. What you did here was develop a kind of an ORM (Object relational mapping) library that maps DB tables to of s. There is a small Apache library that does exactly that : Apache Commons DbUtils You can still have a class for the purpose of the type-safe 

this calculator is not very useful for the user since it cannot take any user input. test data, as well as "real" user input, should come as run time input. this may be from the command line, from an API call or from some kind of UI. havong the input specified at run time will allow you to modify the test data without need for recompile. if is applicable only for division, then perhaps the operator needs to determine which s to apply? another approach can be that each can say whether it is applicable for a given calculation? so I believe the order of validation procesing should be: first parse the String expression into an instance that holds operand/s and operator/s (that can perhaps be defined as enum?). then apply further "mathematical" validation. there should be a clear separation between the validation and calculation steps. This will make things clearer and also allow for modifications to one step without affecting the other. you should consider having the validators throw a custom exception. this is a perfect fit for that mechanism. Java even have some predefined exceptions that you cen reuse like and . the benefit of throwing java predefined exceptions is that they already have documentation and users of the calculator will be able to know what went wrong. other areas for separation of concerns can be output production, validator instantiation, etc. 

You don't need the if statement that is calculating . You can just make it the value that completes into : 

According to this, is a costly operation, which makes sense since the format has to be parsed (each time it is called). I would seek the help of some libraries like Apache StringUtils or Guava to do the necessary padding and then replace format with concatanation. Also, I did not analyze the code, but if the big list can be split and parallel processing applied to it (perhaps using fork-join DP) then that would provide a big boost 

name It took me some time to understand that this class represents a complete CSV line. In my eyes, translates to single cell. Why not or use the term from RDBMS or the term from old times' file processing 

properties: , may be rented to one for a time period. This relation is represented as and , class is responsible for maintaining its own rental status. it should be able to answer if it is available for rental for given period 

count occurrences for each day: create a that holds as key and of colors as value. the size of the list shows how many times the day appeared in the input. after iteration on input is complete we have the required information per day. now we iterate over the map entries and build the collections per count. instead of array of ints I would create a in order to collapse duplicate colors. 

Here are my comments: 1) Do Not Use Constants inside the code You specify the list of input choices in two places: the print instructions and switch statement. This is bad practice for (at least) three reasons: 

Java's low level thread synchronization mechanism (synchronized blocks, volatile variables, wait(), notify(), etc) were proven to be tricky for the human single threaded mindset. Threading hazards like deadlock, thread starvation, and race conditions, which result from incorrect use of low level thread synchronization, are also hard to detect and debug. To that end, Java 7 introduced several new features/classes in the package that allow developers to approach the thread synchronization domain from a high(er) level. is more flexible and gives more fine grain control over the scope of locking. it also performs better. The advice that I see around the web (including on Stack Overflow) is that should replace synchronized block in all new code. 

2) Modularity: the does all the work: the IO operation of reading the input file, parsing the JSON contents, and all the SQL processing. This means that any changes in the input or output will result in changes to this monolith class. this create the potential problem of side effects: when you replace the JSON with XML, you may introduce bugs in the SQL processing. For the sake of Modularity (and also clarity) you better break the monolith class into smaller classes that take care of one aspect of the problem domain. Readability 1) : The use of this class (may) have performance gains, but you pay for that in readability. big time (IMO). You should also know that the java compiler replaces plus sign string concatenation with in the bytecode. Only in very specific scenarios (frequent loops and such) it actually makes a different to explicitly use . I would say that as a rule of thumb, string concatenation should be done with plus sign unless you know you have a loop that iterates over thousands of items or is called hundreds of times. 2) but that is not enough. even if we replace with plus sign string concatenation, this statement 

Although you didn't share I assume it holds the Strings that were loaded from the file. So in fact you read all the file's contents into memory. Starting with Java 7, this can be achieved in one method call: 

I believe what you describe fits the producer-consumer pattern: A player who wishes to be matched is a consumer of another player from the lobby. when players join the lobby, it should produce them to consumers. Therefore I think a better data structure for your requirements is . The most advantageous feature is the blocking of consumers. this eliminates the need for the timer. you can have consumer wait forever for an item (another player) or have it timeout after a certain time. regarding rank, you can still use a with rank as key, and the queue as value. which brings up the question: in its current definition, the can hold only one game per rank? However, as long as the solution is confined within one JVM, you will have a scalability concern. To fix that, you will need to externalize the queue and use a messaging system (like RabbitMQ) and then rank becomes a topic where consumer register for. This is a much more complex solution but it has the potential to grow to social-network scale. One more comment regarding readability: