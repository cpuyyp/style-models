This code (which needs optimizing) will give you the maximum height you can go according to the x and z coordinates of the camera. 

The model file contains data about materials, in this case it looks like the diffuse color or texture. When you create a new object it doesn't contain the right colors and such, so you get white. See here: $URL$ $URL$ If you want to use the same texture, you can do this (I haven't tested though): 

In 3ds max, when you use the material on your model and change the the material doesn't actually have a texture, and so it doesn't use one even if you give it one later. Basically, here are the steps to make it work (sorry if you don't need such a specific list, but I'll make it usable by anyone): 

If your weapons only differ in some stats, you dont have to use any of this. Just put the stats in the base class and fill them accordingly to your wishes (boolean twoHandedness,int damage, String name, ....). 

you clutter your code with many sublclasses, that you obviously don't need you have to keep track of your depth of inheritance (?) if you change something in your weapon classification hierarchy I don't think there are many advantages to this approach 

It helps a lot in motivation if you get things running first before considering making them nice and smooth. The downside of this method is, that you will be coding more code that you'll put in the trash in the end. 4. Dont implement too much features parallel. Try to conentrate on <=3 features at once. So you have some place to switch to if you stall at one feature but not that much features that you are overwhelmed by the ammount of work to do. 

When you use in the class it only dispatches the mouse clicks that fall on the actual visual data inside that . If you use you can use the whole stage. 

The best I can say is to read some books about art, and practice using your art programs alot. Apart from that, if you aren't an artist, there isn't much you can do but hire someone else to create your graphics. :) Here is a website dedicated to giving good tutorials about cg: $URL$ 

As you said, billboarding a plasma sprite and using a bloom shader Creating a particle system and using a bloom shader (will look better than above, but takes more power) Both, which by looking at the picture, I'm inclined to believe is the method used in that game. It uses a main explosion sprite and then some particles with an additive bloom shader for sparks. 

Are you using 3D? Then you could just add slightly scaled versions of the same object wich are coloured in your halo colour and have 0.2 alpha. Then just render the real object after all these halo-objects 

There are many ways of reusing your classes this way. Want a cannon that is also a sword? Just put the two types together in a class and implement a supertype SwordWithCannon ;) (you can't do that with the first approach that easily) Less code You could even change the behaviour of the weapon during the game. So your Sword gets blunt, just change the swordType to "bluntSword" (or something similar) 

Aside from the fact that even loading a file with some data of this dimension shouldn't take minutes (could you post your loading and tile filling algorithm?) you should try to load only what is instantly needed by your game and load the rest while the player is playing your game. You could take your loading code and the fields that it fills and put it in an seperate thread that notifies the game if there is enough data ready for the player to start. I'm writing a small 2D RTS Engine in Java and I use 2DArrays (ArrayList>) while every Entity has its own z value (they wont change in my game). So it breaks 3 nested for loops down to 2 nested for loops. Even that approach isn't the most efficient way I think. 

Using this code, I get an exception because all of my s dispose for some reason. Is there a way to change the MultiSampling in the middle of the method? 

I'd say you're on the right track, you might want to look at this article: $URL$ It explains some basic collision avoidance and path-finding using the A* algorithm. Edit: If you really only need what the best way of propelling your objects in the right direction is, then you should use a force (say, MovementForce or something) pointing in the direction of the best path you found using the path-finding algorithm of your choice 

Perhaps you can have a class which contains read-only properties for each thing you want to perk. Then pass all the perks to your various classes in a whenever you need to. Inside the different classes of your game, you change each property that's relevant. 

Python is fine I think. Often LUA is also a good alternative if you want to add scripting capabilities to your programs. You could either use XML to describe the behaviour of your monsters, this would involve some coding in the actual game code because you'll save only the "name" or some attributes according to the behaviour (speed, type of weapon the monster uses, etc.) of the behaviour to use in your game code. If you use a Scriptengine (e.g. LUA) you could transfer this code out from your precompiled program to scriptfiles that are loaded during the runtime. To do this you have to expose the API of your "monsters" to the scriptengine. That allows you to call the methods of the monster-game code from the outside. 

Obviously this code can be optimized a lot as it becomes redundant after the first call. EDIT: Just to explain why the properties seem the same, once your code runs once the effects become the same, so if you're seeing anything but the first call the properties will be the same. 

Make the diffuse color of your material grey. Click the little box next to the diffuse channel to give it a map, and choose bitmap. Navigate to your initial texture. Choose it. UVW map your geometry, there are so many tutorials about this on the internet that it's pointless to put one here. Export it again, and, depending on the exporter, choose 'Copy textures to output' or the equivalent. 

Some times it is hard to determine who is the real actor. Why not saving the players tokens in the player itself so that each player has a reference to it's tokens (even if you only have one) then let the board roll a dice. The board itself (being a representation of the actual game rules) should be called to move a specific token (by players choice if there are more than one) with a specific dice roll. So in a monopoly style game it would be the only token a player has wich is moved forward for a given ammount of fields. In a Ludo game the player would chose wich token is is, that he wants to move and submit it to the board class. Why do I put the dice roll into the board? Because it depends on the boardgame itself what dice is it to use or if the actual player has to roll the dice more than once (because of special game rules (e.g. prison in monopoly) So your Player would actually be a class that holds every information about a player. Name, Points, Money, game tokens that belong to him etc. . While the board says whose turn it is and what options are open to that player. How you move your game tokens is up to the game rules. Is it important that a player cant cross specific fields without stopping, then you should have a method that moves that token only one field at a time to check if such a field has been crossed. If it isn't that important you could just say "move my game token for 4 fields in that direction". You could even go all the way down to writing a standard board game Interface that you can use to implement several different board games wich have a more or less linear game plan layout (monopoly, ludo, game of life).