Generally what you do is dangerous. More dangerous as you might expect. As soon as you have something odd like a line break in a package or import line, a double semicolon or multiple import statements in a line, the code will break. If your keywords ("package", "import", "Generated") are used somewhere inside the interface, it will break as well (note that these words could appear e.g. in comments). If you don't want to use a "real" Java parser, there are some things you can do to improve your code: If you don't find a closing semicolon for package or import, add the next line as long as you don't have one - or throw at least a meaningful error. You can also check if you have two semicolons in a package or import line. But I think the most important point is to break your loop in 4 parts in order to make your changes as "local" as possible. The first loop deals with the package, the second with the imports, the third with Generated and the fourth just adds the rest without changing. So your are safe that after a step is done, it can't do any harm to the following code. Another thing you could try is to preprocess the code with some formatter / pretty printer, which could get rid of some quirks. Before the code gets at least a little bit more secure, I wouldn't care about performance too much. Consider adding some JUnit tests (ask your colleagues for some "mean" input classes - you will be surprised which weird monsters they can imagine - and use the more realistic examples). 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

from (minus the case sensitivity discrepancy). Unless there are some good reasons not to do so, I'd stick to only one implementation and reuse it in both methods. 

How do you know the method you're looking for will always come up first on the list returned by ? If you only expect one, use . But indicates you consider the possibility that more than one method matches your given criteria. So, do we have some guarantee it would always be the first one in our way, or are we just "feeling lucky"? :) This looks pretty fragile to me. This is subjective of course, but I have to say that since this method is actually less functional than and the implementation is rather brittle, I would personally veto this extension in a peer review, since I don't believe whatever readability improvement it brings to the table justifies the trade-offs. I think this is a textbook example of what Jon Skeet calls evil code. It's not wrong as in "doesn't work", it's sort of clever, its "magic" can even have some appeal to it, but it's fundamentally unclear and dangerous. I highly recommend this talk: $URL$ If you really want such syntactic sugar, I'd ditch generics and reflection-based approach, and replace it with hardcoded extensions for , , - come on, it's not like there's dozens of use-cases anyway. Oh, and have them return a to distinguish between input actually converted to the default value, and not converted at all. Like so: 

Avoid dealing with BigDecimals at all costs - they are slow. I changed the formula to work with "twice the number", so my is actually 2*s. Further keep the numbers in the loop small by "modding" the intermediate results, too. Finally I tried to simplify the syntax and the initial conditions for a little bit. 

There is a serious flaw in your handling of the empty list. A user would expect that these definitions are equivalent, but they ain't: 

I'm trying to get a better grip on the new functional possibilities of Java 8. As an example, I took this very elegant Haskell snippet: 

I don't really understand why you use tuples when you have already a class for doing exactly such kind of math, namely . The code could be more functional by using immutable case classes for s (but it depends on the problem if this is the right thing to do): 

There are a few things, I'll expand on this over time. First, always write method and variable names in lowerCamelCase. Everything starting with an uppercase letter wil be considered a class or a constant by other programmers. Then, don't use mechanically getters and setters. E.g. consider 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

Now you can't call eg. . Other than removing the "m" prefix from the parameter name, I wouldn't also keep it named "activity". It's an class, not an (instance object) itself. I'd rename it to . 

There, I'll say it: it can't be done. C# doesn't allow identifiers to start with digits. All workarounds either won't meet all your requirements (eg. @radarbob's answer, while clever, doesn't let you narrow down numeric values to a predefined set of legal ones, which I understand to be your main goal) - or will get you on a ride that ends up back on square one (if you use a dictionary as @Malachi suggests, then the name of this dictionary will go upfront, and it still doesn't start with a digit). Underscore prefixes are as close as you can get. Abusing Unicode a bit might work to a degree: 

Your names could be improved, e.g. isn't a good name for a member variable. You could replace the by a multiset implementation, e.g. from Google Guava. Then you get for free. The (and its ) should be generified. Further, it seems to be plain wrong, as it never gives 0 as result of , but that is the expected outcome if two values are "equal" (whatever this means in the actual context). Without looking too deep in the code, it might even be that a simple priority queue could replace all the and stuff. The method is too long and should be split in logical parts. Probably it would be better to avoid static methods, but to create a instance which does most of the work. If you can use Java 7, try out the ARM block feature for your file access. For your question you used the tag "clean code", but it looks like you didn't read the book by Uncle Bob. Check it out! [Edit] Based on your clarification I would write the class as follows: 

We've cut on verbosity, but it's debatable to me whether it improves readability. It's harder to achieve the same thing for , although you could pull it through if you added a helper extension: 

Apart from using upper case for method names (as pointed out by @paritosh), I think it's a reasonable convention to use prefix for methods returning a boolean representing some state that may or may not be. Case in point: $URL$ Note this is a property, meaning you could indeed replace with a read-only property. Not that there's anything bad with leaving it like it is - properties are just more idiomatic in C#. Using a property kind of puts more emphasis on the fact that we're only checking on some state, and there's no side effects to that. (You can still implement a property in such a way that it causes side effects, it's just blatantly against the semantics of it). Last but not least, variables should be named with lower case in C#: 

I can't find much to critisize here. You could use (e.g. for ) and . I find it a little bit strange to have no graph type which holds both nodes and edges, just nodes and the weight function. It would be easy to get "out of sync" between nodes and weights in your demo (e.g. when making a copy-and-paste error). Edit Here is my take: DefaultKShortestPathFinder 

This might be a little bit over-the-top, but how about a more object oriented approach? Assume this little helper enum: 

Of course this code will fail if the types are not the expected ones, but at least it will fail early, and it is already inherently "dangerous" code. On the other hand, it's reasonable to expect that Hibernate doesn't mess it up out of the blue, once the types are correct. Note that supports keys (although IMHO this design decision is questionable). 

The company I work for is stuck with Java 8, and the Streams implementation in Java 8 is nice but somewhat rough around the edges. Here is a helper class I cobbled together, using various snippets from the interwebs. But this worries me a bit, because I don't understand some of the magic, and don't have the time to dive deeper into it. Of course I wrote tests, but it would be still reassuring to get some feedback.