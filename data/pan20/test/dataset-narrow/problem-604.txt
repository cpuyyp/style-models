For determining correctness of your implementation I recommend referring to an existing implementation such as Apache commons-lang or the newer commons-text: 

However, the "problem" specified in LeetCode does not use arrays which are very different from linked lists. If you convert the Java code it provides you would get the following: 

will return . will return . If you want both to return then replace the with in . Marking as is purely optional but it seems to me like a good fit. 

In my opinion, the main factor in preventing you from having a clean primary constructor is indeed the two paths to the super class (via or ) and having a super class define the property is in fact what also prevents you from making this a data class. I recommend making an or with no properties in its constructor. e.g.: 

which will avoid creating an intermediary list (small optimization in this case). Perhaps a minor issue but I personally prefer using "index" instead of "i" or "idx" to avoid any ambiguity. "idx" actually has several meanings. I find used with to often be more readable than combined with : 

You can still use a enum if you'd like but this function is very similar to so would seem to suffice. Every enum class has a function implementing (Enum Classes - Kotlin Programming Language). As such, would declare both and which seems confusing to me. I suggest defining superior and inferior check functions instead of but this may not be practical depending on how you are using : 

You're method is not transitive (e.g. and but . See Any.equals - stdlib - Kotlin Programming Language for more details on the requirements for . You might also consider using from for testing your own implementations of . If you define your own method instead of defining a custom, non-transitive implementation than your existing solution can become much simpler: 

This also prevents printing a trailing space. You don't need to re-read "dict.txt" as it doesn't change with each word. 

This isn't very convenient but thankfully Kotlin allows us to use reified type parameters to define an extension function to simplify this: 

Technically a "trunk" does not include the branches, etc. so "TrunkWidth" and "Trunk" are kind of confusing names for this. You might consider "LayerWidth" and "Layer". I see very little point to all these classes as they do not serve much purpose. A class with a single method to define its single behavior might as well be a method. If , , , etc. will be used by methods other than then it might make sense to have these as classes. If they are simply to build a string representation then I would drop them in favor of inline calculations (OOP does not mean that "every thing is a small object"; e.g. "height" and "width" may be attributes of objects but are not necessarily objects themselves). This entire collection of classes can be reduced to the following (assuming no other code is using , , etc.): 

Sometimes in Kotlin you don't have to declare temporary variables so that you can do something with a return value before returning it. e.g.: 

Using returns a new object but such isn't necessary in this case. You can use directly on the . You can reduce duplicated code by using classes and/or extension functions. e.g.: 

One disadvantage is that you can't easily construct a temporary with explicit initial values. If you need to do this you could consider a helper function analogous to . E.g. 

I don't think that your solution looks bad. I would probably use a temporary variable to make the line length a bit more readable. You could consider from the module. E.g. 

In addition to the other comments, I would also use a different naming convention for types and objects. For example, this looks unconventional. 

Otherwise I think I'd go with with a hash of subroutine references. It's easily readable and simple to update. 

Being a trivial POD-struct, most compilers will have little difficulty in eliding most of the implied copies. There is some argument that deserves to be a class as you have no setters for its members, but given that it has little behaviour and the behaviour it has can be provided by free functions I would keep it as a POD . Clients can choose to make a instance should they so choose. Also, I don't see any need to make take a reference to a . It can return by value for more readable code. 

It's just a convention but being able to easily spot names that denote types helps if you start to use more complex expressions. For example: 

Because either is technically acceptable, you are right that it is a style issue and simply a case of choosing a coding convention. However, I think that you have hit a very important point. So few other languages that use parentheses for functions allow a parameterless function call without parentheses that it can be very surprising for developers unfamiliar to perl. This point would sway me in favour of always using them and, indeed, I always do so out of habit because I use other languages a lot and it just comes naturally. 

The comment is really bad because it talks about whereas gets the value and gets the value . I think the comment needs a pair of parentheses if the code is doing what you meant. To be robust, you should check whether the parse worked. 

is almost always a bad idea. Even in small programs I would avoid it. Your algorithm for is just plain wrong. The area of a triangle is half the length of a side multiplied by the perpendicular distance from the third vertex to the base line, not the distance from the vertex to the mid-point of the base. (Think of a triangle with vertices at (-1,0), (1,0) and (1, 1). The area of this triangle should be 1, not sqrt(2).) Reviewing your class, the default constructor doesn't initialized the member variables. This may be acceptable for performance reasons - for example - if you deliberately want to be able to create large arrays of uninitialized but it's often safer to explicitly initialize all class members in a constructor. Having both getters and setters for and effectively makes them public data members. The only functionality that has is but this can be provided as a non-member function. Once you've done this your class provides no functionality that a simple doesn't. In addition, you can use aggregate initialization for a which can be useful. E.g. 

Unfortunately this can sometimes look a bit strange using , etc. but in Kotlin 1.1 you can use bound callable references: 

You might want to take a look at Delegates.observable - stdlib - Kotlin Programming Language which you may be able to reuse to improve and reduce your code. 

And you can even pre-compute the required capacity to avoid unnecessary array copying while building the string: 

If is never used then even itself can be eliminated and the tree string building logic can be placed in a single function: 

In some languages variable names like are common and expected but in Kotlin (and Java) I find it more common and expected to have variables names avoid abbreviations, use camel casing, etc. I recommend using instead of . You are returning a . This is fine but data classes are so much better and Kotlin makes it so easy to define and use them. I recommend creating your own type to return. e.g.: 

I wouldn't use or because it makes it appear that can be greater than which is not true. I recommend using . 

You can use the slightly shorter instead of . You can also move trailing lambda arguments out of parentheses: 

If however you actually need/want classes for tree components then I recommend making those components (or collections of those components) members of a class (e.g. a has ). 

Using as a function name seems very ambiguous. The method name used in the Java class from LeetCode seems more appropriate: (thereby specifying that the arguments, although not numbers themselves, represent numbers). You can remove the explicit type specification for if you add explicit type arguments to . I personally find this more readable and less verbose: 

"args" is more common and descriptive than "a" in a function signature "\n" is system-dependent; I recommend using instead can be used with a instead of first mapping an using a and then calling . e.g.: 

Kotlin already guarantees that and are not as you've used for their type instead of . As such, the statements are unnecessary. I do not believe you gain much from and . and read clearly and are read in constant time so the additional variables seem unnecessary to me. You can place the last lambda argument in a function call into parentheses as you have done but I personally find moving it out of the parentheses easier to read and more idiomatic: 

Personally I prefer "row/column" instead of "y/x". Thinking "y" before "x" is unnatural. You can always define your own methods too which can improve readability. e.g.: 

Instead of using you might check to see if the given product is greater than the currently known maximum product and then assign it if it is. This is minor but personally I prefer to avoid unnecessary assignments. I wouldn't worry about trying to do all of this in one pass. Each directional slice has different row/column bounds so I think four separate loops is the clearest/cleanest. You can remove some duplicated code when it comes to calculating the product and updating the maximum. 

If you are going to have classes for computed numbers than I find (like ) much more readable than for , , etc. Naming an instance of as simply "tree" is rather confusing, I recommend using type names (at least the end of them) at the end of instance names (e.g. "stageTreeWidth", "stageWidth", "treeWidth", or simply "width"). Kotlin has a neat function to simplify building strings with a repeated char sequence. e.g.: