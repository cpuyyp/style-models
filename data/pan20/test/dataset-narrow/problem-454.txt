But don't do this. This is simply re-inventing the operator. System dependency Your code uses all over the place. is not cross platform, and it is better to make the code as cross-platform as possible. You really don't need to use everywhere; people using a console don't expect their console to clear old messages. Furthermore, isn't necessary; the console waits whenever your program needs to obtain input. Switch In your main function, you have this: 

It's really nice to see that you are only ing what you need. You could sort the includes alphabetically, but that really doesn't matter. 

This is a big red flag for me. You are using to represent your numbers; use a class instead. Defining a class is quick and easy: 

At this point, you might realize that looks kind of ridiculous. Indeed, using the namespace brings out that you could name these functions better as and : 

These functions imply that there is some setup needed to actually use a . However, it is a good idea to have all setup be finished at the end of your constructor. These functions should be removed in favor of an extra constructor parameter of ; to import from file, you can have a free function: 

Compared to your code, this is much easier to understand, largely because there is much less code, as well as the fact that this style of doing something for each element of a parameter pack is pretty standard nowadays. I know you are concerned that this feels like a hack, but I assure you, it is not really. It's the easiest way to regain a parameter pack from a tuple-like type. Additionally, doing work with parameter packs tends to be more efficient than recursive functions (in terms of compile-time). That is not something to disregard casually. Furthermore, compilers have a pretty small limit for recursion compared to runtime recursion. On my version of gcc, it was 500. Yes, that's not a trivially small amount and it would work for most tuples you pass to your , but different compilers could choose different allowed recursion depths. Also, it's not inconceivable that I would want to have a , which would simply break with your version (you would probably want in this case, though). 

Again, avoid this C-ism. Don't use to indicate no arguments. Just write . Also, you don't need to from main; it's done automatically. 

Also, it's better to "code to the interface", meaning that rather than using , use ; most of the time, the rest of the code stays the same, but in the future, if you decide a different , such as , then all you have to do is change to : 

You could even define the function inline. To put it simply, "stringly typed" values should be avoided. 

The problem with this is that it leaks memory, although not in the traditional sense of leaking. Function variables live till the end of the program. So while and are only created when this code is first run, they only get destroyed at the end of your program even though you never use them later. This eats up memory the entire time. On the other hand, the amount of memory it eats up is pretty small and constant, so for almost all purposes, it shouldn't make too big of a difference. Even if you repeatedly called a function that had this code in it, the static variable would live and not be recreated. Just don't use this in a way that generates the lambda 100s of times, such as in intense template metaprogramming. 

On the other hand, if you do want the getter-setter mutable style, I personally find it easier to read if setters are . But this comes down to taste. 

This is only a mild improvement, and whether or not you call it an improvement is subjective. Your second function: 

We can separate these into their own components. This is only really worth it if you can foresee adding types to be a common feature, but especially if the "another function" you forward to should be selectable by the user (say, if you packaged these functions as member functions of an object): 

Code Review's April 2017 Community Challenge has us simulating a multi-way intersection. My emphasis was around safety (don't want cars crashing) and ease of use. I plan on adding "smart intersections" (can detect when a car is/isn't there and change the signals accordingly) and a GUI later on. The sample intersection: 

Due to my needing to use C libraries inside C++, I kept finding myself wanting to be able to ensure that the function got called, even if an exception got thrown. ensures that the function will be called at the end of scope. External documentation shows how to use it, and also clarifies that it is not allowed to have multiple calls on the same line (because is not always supported): utils.hpp 

If you want your code to be extremely extensible, there is another way. Notice how the new function I suggested still does multiple things: 

This does mean that your will have to change, but I find it much more readable to just keep an index/iterator separate from the for loop. Alternatively, I would loop by index. Iterator loops are just hard to read. On that note, though, you should write this: 

You don't need to copy the entire matrix. For an matrix, copying takes extra space. You can get by with space, or copying only a single row. The idea is to modify the matrix in place, using a single-dimensional array to hold the old values of the row you are working on. Then, you simply use that array when you get the old values for computing the new line. You will need another variable as well. Something like this (doesn't completely work and I don't recommend this code style; this is just to get the idea out there): 

Both and and look similar in some fonts, and you can avoid it by using a more descriptive name such as . About the memory leak, IIRC, the following code could leak (before C++17): 

If you wanted to let users specify their own distribution, you can make your function into a template function and take a function parameter to make the distribution: 

It seems that you are copying the idea of , where returns an error code if something went wrong, but there's no way for something to go wrong in these functions barring an exception, so just make these functions void: 

Once you have this, you can also extract it into a function (e.g. ). The second part is an algorithm known as "join". While there isn't one in the standard library, it's not too hard to write your own or find one online: 

This is bad. You almost never want to directly include a source file, only header files. Instead, write a Huffman.h file: 

There's no need to have a at the end of . For the specific case of the function, is implied at the end of the function. 

This name is inconsistent with your previous name of ; it should probably be named . Also, what does mean? It seems to suggest that this class holds a counter, but it is best if I don't need to know what it contains. It would be better to name it , or even since we know it is thread-safe. Then, you could call and on it. 

I actually recommend you take this as a parameter in the constructor (this is known as Dependency Injection). In doing so, should you want to debug by setting the Random to a seed, you could just call instead of having to modify this file (your main function may not always be in this file, and it is cleaner anyway). Furthermore, should you want to switch implementations away from the default, say to a Mersenne Twister, you'd simply pass in a and the implementation of wouldn't have to change. 

only has abstract methods. If it is not going to give any common implementation, I would recommend making it an instead of an , as that would allow implementations to extend a different class as well. Additionally, I would change to , similar to the identically named method in the class. What if you want to have a CAS system that computes using , but you want to reuse your code? 

I find this much more readable. By simply reading vertically, I can determine that the code does this: 

C++ doesn't supply a , so I decided to implement one. However, I was viewing this as more of a hash library than extensions to , so I placed it all under the namespace . This was my first time seriously using template meta-progamming. I tried to make my code work no matter the cv-ness of the variable, or whether it was an rvalue or an lvalue. I'm not sure on the efficiency of execution, but I believe the compiler can optimize it down to simple arithmetic on hash values. hash.h