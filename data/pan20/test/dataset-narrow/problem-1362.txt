Where is the "slope", or how fast your trajectory grows, and in your case is the of the starting point (0) - so we can ignore it. 1) for from , where in your case is . For speed variation you need another function that will give you . Most simple one is of course linear function , where is time (in half time, travel half distance etc). But you can have arbitrary function. Let's consider a more complex function: 2) , where from (one second) In you game loop to determine the position of the sprite, you simply need to get the from second function (t is the time elapsed from the start of movement) and calculate from the first function. If you use exactly these two functions, your circle will go very fast in the beginning and slow down until 0 speed at the end. Note that I've made a lot of simplifications like I don't consider that you can move from right to left etc. 

Some companies target to release their titles around Christmas. Other companies target E3. There's a lot of buzz around E3 and it is coming soon. So it might be actually a good time to release in summer. And of course, when people go on holiday nowadays, they take their iPhones to the beach and they might just need something to play when they are sunbathing. Edit: 

Don't try to do everything in one thread, don't let UI or waiting for another frame block the whole game. 

There is no built in functionality in AndEngine to create a scrollable text. You can render the text and make it scrollable yourself. But in your case it will be better if you utilize Android SDK and add a new "text layer" to your layout. Basically you want to design the layout in a way where the AndEngine will be rendered under another view (let's call it text view). You can then show or hide this text view as you please and use it to render text. You can use any kind of Android SDK GUI Elements there, including scrollable text. See for example this tutorial. 

This is a simple math. First you find the vector between those two points. Then create a vector (use vector pool) from it. Let's say your touch coordinates are [p1x, p1y] and the up coordinates are [p2x, p2y]: 

To understand this, you need to understand the basic architecture of any computer program. Typically you want split your application into tiers. One of the tiers should be the presentation tier and then you can have one or more tiers that take care of the rest, again usualy a logic tier and a data tier. Now everything that happens in the game is happening in the logic tier. Your logic takes a marine and calls that can look like this: 

First important aspect to consider is: Who are you writing the documentation for? Yourself, modders, map editors/campaign designers? And second, but equally most important: What is the purpose of it? What the documentation should contain in any case is: High-level overview Write a short abstract what is your game about. List what have you used, programming languages, libraries, versions. System requirements. Screenshots. If you write for someone who is going to extend your game in any way, describe how to install your game in a way they can use it/mod it. Describe what your API can do. Extension tutorials/guides If anyone is going to implement/extend anything in your game, write a typical example. Write a tutorial. How to create a map, how to write a simple extension. Make the tutorial easy enough for people to be able to try and complete in one easy sitting, but complete enough to show the capability of your system. This might be good for you as well, when you come to your game after some time. Write guides for typical tasks in your game. Architecture, Entities, Workflows Draft few diagrams, how are different tiers connected. List or draft a diagram of basic entities in your game, their relationships, how are they stored (DB, ... ). If you use any custom file format, document that as well. If you use XML, don't forget to attach a and explain its schema. Create pageflows and workflows of activities in your game. TODOs and knows issues If you know about anything that was left out, document it. Any errors that were not dealt with, write down possible workarounds. Detailed API documentation Generate one from comments at least, but your comments must be good. Make sure you document all public methods and classes. Pay special attention to any publically available API you have created typically used for scripting etc. Get someone to read it Someone who was not involved in making the game, but with sufficient technical level. If you are going to release the game with the technical document, get an editor and technical writer to proof read it. 

Is this achievable in OpenGL ES 2.0? I was trying to figure out the different modes of alpha blending, but without success. Also if anyone can tell me, how is this called, I can continue my search. 

This won't work if you set fixed rotation to true. You can use the following to set the rotation directly. 

And then when you switch your scenes by calling , your loop will just start rendering something else. can be a singleton class or simply a class with static reference to the scene. SceneManager concept (singleton): 

It all depends on what kind of game are you making and what is the target audience. Games like World of Warcraft would never work with heart system, because it is all about numbers. People dedicate their free time to discover health formulas etc. Console RPGs work best with hearts. Console games usually hide as much of the game mechanics from players as possible. So it's realy upto you: 

You want a game that will be simple, you mostly rely on the story. Hide most of mechanics from the player. Don't show hits as numbers, but simply one hit = one heart. You will probably not show the player any other stats neither. No strength/dexterity/intelligence. Just inventory. Items have no stats, maybe just special attacks etc. Your audience will be casual players, console players, younger children. Use hearts. You want a game for people who like D&D. You show them stats, you let them design the character by rolling dice/assigning points. Every item will have many stats, and no good player will be able to live without excel spreadsheet. Health bars or pure numbers. 

First of all, stop thinking in Human terms. If the player can pick alien race they can have 1 sex or more than 2 sexes! You can also mix races in cities/on planets. You can create tension between races that will have negative impacts. You can create societies where civics like "multi-species society" positively boost culture or science. Add bonuses to aboriginal races. Protection or peaceful incorporation of the aboriginal race should provide significat boost. You can make "first contact" rules for aboriginals and your planetary council can penalize players or even wage wars against those who break them. Let AI players break them and give the player a peacekeeping mission from the council that will provide some reward. And watch Star Trek: TOS, that will give you plenty of ideas. 

The and will give you relative position of touch inside the entity and then contains the absolute position on screen. You can use the local coordinates to correct the position. 

Load a texture to bitmap memory Define texture region in the texture Create transformation (scale, position, ...) Draw the Region from the texture memory to display 

It will remove the body from simulation. It should keep its position and rotation. It would no longer collide with anything. 

But something doesn't feel right about the scheme. Maybe it's the absence of color and using three shades of gray. Also it will be impossible to create gray and black "lights", "aura" and similar effects. 

I don't think there are any books, articles or papers on this topic. The best you can do is to get as many similar games as you can and play them. Find what works well, what doesn't. Use the variables you already have and experiment. I am doing the same with my game. I picked a couple of the most popular games using similar concepts. Having a couple of beta testers is good as well - just employ your family and friends. 

Also @Sean Middleditch has a good point with shapes. Just FYI, the colors were simulated for people with deuteranopia, protanopia and tritanopia (three color blidness variants) and they still look recognizable from each other, thanks to the color combinations. But I'd be very much interested how colorblind people classify those colors. 

Scaling just the entities won't work. One of the obvious reasons are that you won't scale the distances between them. What you need is a camera concept. I suppose you are making the game from the scratch, no engine. You will need to implement a position transformation that will happen for every entity just before it gets rendered. E.g. if your rectangular entity is 100x100 pixels big, center of you screen is at [0, 0] and the center of the entity is at [-50,-50] (top right corner of the entity is in the center of the screen) then before rendering with zoom factor 2, scale it to 200x200, and position it to [-100, -100]. Same with every other position and vector in the game. Note that this is a very naive approach. I believe modern 2D engines use 3D ortogonal projection. The 3D library (OpenGL, Direct X) and the hardware then take care of the scaling. 

You are asking for a concept of scenes inside one activity. This is as easy as creating an abstract scene or an interface that will have methods like and . Then in your engine or game-loop you simply render the current scene. How do you switch between scenes is upto you. You can have a governing class . So how is this gonna work? Scene concept: 

Google Play allows you to upload an alpha or beta version of your app and lets you choose a group of testers. The group can be a Google Group or Google+ Community. I highly recommend using social media to spread the word and involving (or hiring) interested people in beta testing. You can also hire people for few bucks on websites like Fiverr.com. Disclaimer: I am not affiliated with Fiverr, but I use it. 

this is perfectly normal, don't worry about it. AndEngine allocates touch events when needed. This should not happen all the time though. Make sure you are not "saving" the events into some array or something like that. You probably load your textures over and over again. It's impossible to tell, but I guess your activity is not destroyed (e.g. when you press home) and when you relaunch the game, textures are loaded again. This is probably a bug in your code :) 

If this is not possible, I was thinking maybe I can somehow render the monochromatic sprites (alpha = 1) to a texture and only then render this texture on screen. How can this be done in AndEngine? 

Well, half hearts, quarter hearts... Again, it depends on how do you calculate damage. One hit = one heart, then no need for health bar. 

You can add the sprites directly to the scene and set their z-index to higher value than the player. Then simply call and the trees will be in front. Also if you add the trees last, they will obstruct your player. More sophisticated version of this is to use a custom parallax layer that will be added with higher z-index and that would even create the 3D effect. 

Bundle Identifier - this is the main ID Bundle Display Name - this is displayed in iPhone App Name - this is probably the one in the iTunes/App Store 

What this means is that HTTP requests module in Adobe Air is an implementation of the HTTP protocol, which uses the same sockets and runs on top of TCP. If you create your own binary protocol using sockets, you can save some bandwidth. HTTP is a textual protocol that is very verbose and most of the time even human readable. That adds certain overhead that you can avoid. 

It is exactly as Khawar Raza says. When you connect a body with your physics engine and apply Modifier, the modifier will be active but at the same time the physics will override the change in update loop. It depends on what kind of movement do you need to do, but your options are: 

You can use Guillotine to slice the image along the guides or take a look at this plugin, which is used to make tiles out of an image - which is what you probably want. 

You also have to implement the in and pass the event to your scene to be able to handle touch events. This happens in separate thread, so it is not part of your loop. This should be enough to create skeleton one-activity-multiple-scene model. 

If you want to use more powerful scripting, you can add some scripting language support. One of the easiest is DeeLang. 

The whole canvas is skewed. I added four squares to the red rectangle. The skew causes the Y shift. Here's the code: 

When solving collisions, you have to use the if both ways, because it is not guaranteed player will be . If you want to stop the object from moving and rotating, simply call 

Your main body (paddle) 5 static bodies with no fixture. 4 "soft" distance joints with frequency > 0 and damping ratio > 0 1 "hard" distance joint 

I have several monochromatic sprites and I render them with alpha = 0.25 (all of them the same value). I want to "paint" with them, so when they overlap, the alpha won't be added. I am not sure if I can express myself properly in English - here is an image of what I want to achieve (background visibility is important). 

Is there anything in Box2D that could do this automatically? The MouseJoint does that nicely for position. I need it in AndEngine (Java, Android) port, but any Box2D solution is fine. EDIT: By automatically I mean having something I can add to the object "Paddle" without the need to change game loop. I want to encapsulate this functionality to the object itself. I already have an object Paddle that has its own UpdateHandler which is being called from the game loop. What would be much nicer is to attach some kind of "spring" joint to both left and right sides of the paddle that would automatically level the paddle. I will be exploring this option soon.