Ill put in my vote for the Darlington pair transistor, such as: 2n6043 or 2n6040, featuring no moving parts, high gain (2500) 8Amp, 60Volt, rating. (means its robust enough to handle all your load.) you can drive them with a Pi (Ive used them for 12 watt strobes) Cost: about 40 cents, maybe less. size: smaller than a Piface, and possibly smaller than a relay (I've seen some tiny relays) Also, you'll want a 10K ohm resistor in on the base lead. Oh, and it has a build in flyback diode. If you use a relay, make sure you put one of those in. I also can't tell if the PiFace has flyBack protection, although given its design, it should. (Flyback protection: allowing a path for a collapsing Electromagnetic field to discharge through) Heres a datasheet: $URL$ 

I was pleased to read about the addition of ARM support in the Opencv 3 change log, and decided to try installing OpenCV3.2 on my raspberry Pi. The installation appears to have been a success, and works with a USB web camera as one might expect. When I try to use the raspberry Pi camera however, it is less intuitive. I tried installing some separate APIs for supporting the raspberry pi camera, but this did not pan out. I have tested the camera using separate python libraries (piCamera), and it is operational. Im not exclusively looking for an OpenCV3 support library, but if anyone has done this type of thing and knows a library that has C++ support for the Raspberry Pi Camera, and works with opencv3, I would like to know. 

I made a couple videos of it miss behaving, and will attach those when I find a good resource to do that with. My LED is Common Anode (common V+), and I am using 470 ohm resistors on the 3.3V power supply pins. 

I switched to a common cathode LED and it works fine now. In my code, I notice that the Pins are set as OUTPUTS, but a default state, high or low is not set. The default setting, would be low, on outputs, so I should have specified HIGH for the pin setting. Alternatively, a common cathode LED also fixes the issue. 

I am using Raspbian Jessie, with my raspberry Pi 2, and 52" TV, and just updated. Now, after loading pixel, my screen size is about 32" and the resolution is lousy. I looked around in the pixel interface, but I cannot find where to adjust for screen size and resolution. please assist. 

I can't for the life of me figure out why the 'try' doesn't allow the edge_detection to register. Any ideas? EDIT: I've also just tried to take the main code chunk that runs under the main logic check, and created itself in its own function: 

Bingo, there it is. In the above example, it was port 22 I disconnected, and there it is in all it's glory, all by itself in argv[10]. I think I've done it, as messy as it may be. The above process will trip on ANY disconnection of the switch, but the Python script can filter out the noise and only look for port 17 of the switch. I think I'll trip an LED as well, so I have a visual alert, but at this juncture the only thing left to do is add a traphandle for the reverse (a reconnection). So as happy as I may be to have hacked my way through this, it does seem like a messy inelegant way of doing it. I'm open to suggestions on how to clean this up a bit. 

Run the physical disconnection again, and check the output of the python created text file: WOOT! Looks like whatever that package is, is an array of 16 chunks: 

The above installs everything I needed, (maybe even more than I needed, not sure) and the next step was to tweak the default snmptrapd.conf file in /etc/snmp/ 

I created the /usr/local/bin/snmp/snmpdisco.sh file with just the following in it, echoing the results to a text file so I could try to make sense of it: 

Now, maybe I can export the results from the bash script over to the python script instead, and parse through whatever is being sent, so I can at least sort of reverse engineer the capsule to see how I can grab that port number: Tail end of the snmpdisco.sh script: 

I have a basic system with a normally closed switch I need to monitor. If I run the program with the following setup, it works: 

The key to this whole process is that last line in the snmptrapd.conf file: the traphandle. Once I could see the OID that was being triggered from the connection/disconnection, I could add the capture to the conf file: (connection is ' OID: iso.1.3.6.1.6.3.1.1.5.4' disconnection is ' OID: iso.1.3.6.1.6.3.1.1.5.3') 

Then I re-ran from the command line the snmptrapd function, unplugged and replugged a few network cables on the switch to see what I'd get... if anything. Hopefully something. I DID! I got the following mess in the /var/log/snmptest.log file: 

You reset the variable every outer loop. So you are always timing from the start of reading to your selected sample. It makes sense that the value you get increases 

No, there is no reason to. is used by to track all computers you have ever logged in to, that way if the key of the remote server changes, ssh will complain that someone is trying to intercept your communication. There is at least one circumstance where it may be necessary, often on LAN you get a dynamic IP that changes day to day, if you have two pis and and then tomorrow they switch places, your laptop will complain that the key for has changed, even though it has simply moved. In this case you may simply delete the offending line in . It would also be necessary after a clean reinstall of the raspberry pi/remote server (sshd generates new keys during system install) 

When you interrupt the program, you lose unwritten data in the Userspace buffer, data already written to the kernel (ed) may be cached but won't be lost. However, if pull the power from your raspberry PI before performing an some data may be lost on reboot. Install a Signal handler If this is a program or script you have written yourself, you should install a , in order to "react" to the you have issued. You can install signal handler to and issue , and commands Signal Handlers can be used in all major programming languages and shell scripts. In the context of an application, your signal handler would issue the command or to any open streams/files followed by an per open file for good measure. In the context of a shell script, your signal handler should gracefully close the running process, and maybe a to make sure no data is lost on reboot. Other things to try 

Component Rework Rework is not trivial, for reattaching the original component you should follow rework procedures for leaded surface mount components, a good guide is available here 

DNS Lookups require a , e.g. When you do a simple name lookup e.g. , unless the name is defined in the file, it will not resolved. However, the setting ` adds one (or more) default domains to append to the dns lookup. Your router will usually have a default domain, for example , but this may be different so look at the configurations 

Full disclosure: I know next to nothing about snmp in a large sense. "just enough to be dangerous" so I left the log and net in the community. I could probably get away with just the execute for the WLDLifesnmp community, but it works so I left it. The most important part was finding the exact OID that was being tripped when that particular port on the switch disconnected. So I manually ran snmptrapd from the command line, just to watch what came through: 

ugh. this is not going to be easy to figure out which port is tripped. I only want to notify if it's port 17 on my switch, not the rest of them (the above is port 39 and 35, respectively).. I have to somehow figure out how to strip that info out, but I have no idea how to do that with bash scripting. (again, I know enough about bash scripting to be dangerous) Python, however, I like Python, so maybe I can export the results to a little Python script and see what sort of packaging is being used here. It sort of looks like it's somewhat of a JSON package or something, I could not find any documentation on what sort encapsulation the MIB is using under the hood. So... enter a tiny python3 script that should run through each chunk of $vars, and write the contents on a single line to a text file: 

However, if I wrap the same statement into a 'try/except' (in order to add the GPIO.cleanup() to the end). It doesn't trip when when the switch opens and the GPIO falls. 

check out tvservice it should give you information on the connection status of the HDMI. tvservice -n Will show you the name of the device connected. (by the way, why mode 2? That's only 480p) Otherwise, it could be totally unrelated to the Pi. Bad HDMI cable, wrong input on the TV... 

I've got a fun little problem that I have hacked together a solution for, but I'm thinking there's probably a more elegant way of going about it. (I also had one heck of a time googling any information on the hurdles I had to face, so while I'm looking for suggestions on cleaning this up, I also hope this may be of help to others who are trying to do the same sort of thing) My managed switch has quite a lot of capabilities, but what it doesn't have is the ability to email me when one of my network drops disconnects. (It's for a wildlife camera that I have a long ethernet cable to, and I want to know immediately if it is ever stolen or drops offline or whatever.) Of course, I immediately thought "Sounds like a Raspberry Pi project!" So I configured the switch to kick out an snmptrap packet to the IP Address of my Raspberry Pi, gave it a custom community ID of WLDLifesnmp, and just turned on the 'link down' notification in the management interface of the switch. On the Pi: 

It is a little confusing, your Raspberry Pi is however, it is being run in compatibility mode. This is determined by the OS. In particular, has a 64 bit architecture known as or , it also has an execution mode that is compatible with . Also known as or Because 32 bit architecture of is directly compatible with , and for other technical reasons I am likely overlooking, the operating system refers to the arch as If you need further convincing. Raspbian has a 64bit build. that will report . For more information about using the 64 bit architecture I will leave these links 

In short, Yes, they will work. Both repositories use the same upstream code to build their packages. That is, binaries from armbian will run on an raspbian. Your problem won't binary compatibility but dependency compatibility. Using a statically linked executable will resolve the dependency compatibility at the expense of binary size. 

and on External Process before threads are created Spawn a "forking thread" which does and , have all threads () the 'forking thread' Use , or other form of locking to restrict any resource handles provided by external ppp interface. 

Multiple Threads Edit If you are using multiple threads, you must guarantee that all resources that are provided by the external process are protected. You have a few options (Not All Inclusive) 

This looks like a part for a particular application/customer. If you don't need the independent references you may find others devices easier to use. You have a few options to pursue for prototype, but in the professional world you would use a microcontroller or ASIC that support SPI Dual Mode Interleave Channels Use the ADC at twice the sampling rate you were planning to, and use a (switch) to feed either or to the SPI Receiver. You can attach the MUX control to pins. Doing it in such a way, in software you would use for Channel A and for Channel B, sampling is done Shift Register (UART) You can use shift registers attached to and to clock in the sampled data and read out as parallel GPIO (28 bits - 2x14). In this scenario, is connected to Shift register and ADC, connected to shift registers. Your Controller only acts as a clock source and driver This will require making sure that SDO data is stable when you clock the shift register, otherwise you will miss bits. You may need to invert the clock signal to the shift register. This can be done in a way that does not slow down the throughput of the ADC. Independent Sampling Controller You can commandeer a pair of small micro-controllers to sample SPI Data for you, this is a fancier version of the UART Solution. Sampling controllers can do some basic pre-processing and data buffering as well. These sampling controllers could potentially be small 8-bit MCU's like the . If you can find a micro-controller that supports Dual SPI this would be a clean solution