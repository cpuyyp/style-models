Based on your comments it looks like your code is actually some sort of library used by different clients in different environments. If that's the case I would rather let clients define the batch size they want rather than writing tricks around memory management on your own. If you do need to manage the memory - I would suggest to reduce the frequency of calls, e.g. check it once per 1000 rows or so. Bear in mind that since your component is not the only one in the application it may turn out that application has already consumed 1GB of RAM thus causing you to reduce the batch size to minimum. 

It's hard to suggest good solution based on the information you've provided... Will the number of entities change over time? Can they "loose" SpriteComponent? Assuming that the number of entities is the same and only Z will slightly change you can cache the sorted list from previous run, and apply TimSort or Insertion sort (you would need to implement it yourselves or grab from Wikipedia) to nearly-sorted list. 

You've declared your function as , but what information does the returned convey? You're always returning , so no information is gleaned from the returned value. I'd suggest redeclaring your function to return and remove the statement. This goes for a few of your other functions that return . If you're always returning the same value of or , just remove the return statement and declare the function to return . Here's the list of such functions which I've changed below. 

It's easy to see that there's a lot of code duplication going on here. What might not be easy to see is a nice way of condensing it. One way to start is to see the similarities and where the lines of code differ. It appears you want to perform an action on each of the four directly neighboring cells and something separate for the center cell. A nested for loop could help tremendously. The only thing to consider here is ignoring the diagonal neighbors. The other piece of duplication shows up where you do one set of actions when the argument is one value, and an almost identical set of actions when the argument is the other value. The only place the repeated lines of code differ is at a single hard-coded value. If you just set a variable to be the correct value for either case, you don't have to repeat yourself. Something you may have not considered is trying to index the array past the boundaries. You should avoid it so you don't encounter errors. Simply add a check for this before indexing the array. I've split this check into a separate function because the boolean expression is quite lengthy on its own, let alone compounded with other boolean expressions. Another tip is to handle all the cases. If you use a , use a at the end. If you have an , use an at the end. Even if you just want to ignore the case that didn't match the other cases you do handle, you can just write a comment, log a message, or even throw an error. 

I'm afraid there is no such thing as general "proper" architecture. Relevant architecture is the one that enables/assists developers in implementing new functionality or adjusting your solution to new requirements. In your implementation I don't see the reason to define your own logging and repository/UoW patterns: 

It's better to use new asynchronous API since it provides more features for combining asynchronous tasks. Ideally , and should expose asynchronous API if a certain operation is not trivial, so (as you mentioned in comments you wrote them) I would implement asynchronous API for them first, e.g.: 

Operator overloads cannot be reused, you would have to reimplement them anyway. Both structures have references to each other which is not great. appears to add a very little value on top of . 

Alternative way (how most applications works) is to rely on a business logic inside client application to enforce business rules. It's much easier (and straightforward) to verify that your parent is of a valid type. Also, based on your table I think each type of "posts" should be different enough to store it in its own table. In that case the whole story of validating types is gone, and all the validation will be done by foreign keys. 

Maybe use some array methods like ? This will add up all the elements, starting with an initial sum of 0 (the second argument to ), then the sum is divided by the array's length to compute the mean. 

Your code grabs the from the then converts it to an , therefore treating a as an . The function you defined swaps the values in the s, effectively swapping the first bytes of your s (most likely the members). I'm not sure if this was intentional, but it certainly is pretty unintuitive and most likely unreliable. Instead, I would change your code to this, then redefine your function afterwards. 

This will swap s when passed addresses to s, a.k.a. s. Now your function will swap the members in the s correctly. 

You initialize and , then you reinitialize in the outer for loop, then do nothing with in the inner one. You don't need to write an initialization step in the for loop if you don't want to. 

I'm not sure if you need declaration in your interface... Do you have special use cases where is not enough? If I'm right and all you need is just method then you can go ahead and make method private, thus you'll make it an implementation specific that doesn't need to be tested separately, you'll test it by testing . If you do need method, then I would go with a different approach: since is just an additional feature on top of , you can remove it from interface and rewrite as an extension method like this: 

Now back to your original question - " can do everything a can do without having to reimplement every method": 

Update Since you are creating a , I would switch from event-based data handling to the structure that mimics IIS request handling via handlers: you can define an interface that allows customer to handle requests, and register a handler factory that can generate handler instance when you get a new client. That way you will call handler's method with payload and get response as a method result. Then you can serialise result and push it to the stream. Update 2 Example of how I would tackle this task. First of all we have a number of classes describing our interaction in a typed way: 

In that example, is 7, the duplicated number is 1, and the missing number is 6. So you get the formula . We can solve for by adding to both sides, leaving us with ! Let's do that. First, you can calculate the expected sum from that formula, . In your loop searching for the duplicate, you will need to keep a running total (and don't break early). After you find the sum of your list and identify the duplicate number, you can calculate the missing number using the formula we talked about in the above example, . Also, you don't need to record the frequency as an integer, you can just keep a list of booleans for numbers already seen. I've also taken the liberty of cleaning up the indentation issues and renaming some of the variables for the purpose of readability. Here is the solution: 

You pass an immediately invoked function expression (IIFE) to the push method, but this is totally unnecessary. You can execute the code above the push method and make things considerably more readable. Also, you redeclare the variable inside this IIFE and use it for something else, which is pretty confusing. It'd be better to use a different variable name. Time Complexity Your current algorithm is O(n2) because of the nested for loops. A more efficient algorithm would be to step through both arrays at the same time, adding the next smallest element to the merged array. This approach would be O(n), so an improvement! Changes Altogether, this is how I would restructure your existing code: 

I'll use the first option in my example as it requires less changes to my previous code: Business logic: 

You don't need to change anything as long as the code performs what you need. If you want to insert records to another table on every update (and not only in this place) you should probably take a look at triggers 

You're passing corresponding to UI thread so naturally the code will be safe to work with UI. I would recommend using to update/inform UI about changes in long-running task though, since you may want to separate computation logic from UI-related code. 

Nice task for brains :). First of all you should prepare your available list of words for faster search: extract all letters, sort them and order by descending length (so that you don't need to sort results later. Make sure to cache it somewhere as that would be the most time-consuming operation. I've written almost all, leaving you the method to compare 2 sorted character arrays :). 

I think it would be helpful to redefine your function like so below. I would strongly suggest including the function in your "LinkedList.c" file as well. It is going to do the same thing no matter what is in your , so why leave this implementation up to the user? Just define for yourself as a helper function. 

I've created a function that takes an integer greater than zero as an input and converts it into its corresponding Roman numeral. If you're not familiar with Roman numerals, you can read about it on Wikipedia. I've tested this code with some examples, so it should be working correctly. I'd be interested in hearing about any general improvements I could make on the code. Nitpicky details are fine as well; whatever you have to say I'm willing to hear, but I hope your answer is more substantial than that. I suppose my main concern is whether this is sufficiently efficient or if there is a way I could improve on that. Also, do you think I've used the correct data structure in this situation? I can't think of a better data structure for what I wanted to do, so that is why I chose arrays. 

But the main issue is that you're trying to do all the synchronisation yourselves instead of using support from the .NET framework. Your task is a typical producer/consumer problem where producers generate workload (request some work to be done on one of the threads), and consumers are the threads that execute that work. Producer and consumer communicate with each other via queue, and for multithreaded environment .NET offers . Since we need to wait for new items we'll use (with under the hood). 

will enumerate the enum every time you start iterating on, it, so it is better to capture the result in array. 

.NET already has a notion of in-process publish/subscribe, and (not that surprisingly) this functionality is covered by events... All you need to do is to wire up all your entities properly, and that's your actual challenge is. I would recommend using any of available IoC frameworks for that (I use Autofac at the moment). 

There is a shortcut you can take to find the missing number after you've found the duplicated number. You may have come across this fact before, where the sum of the numbers 1 to is . We can leverage this along with the duplicated number to find the missing number. If you add up every number in your list and subtract that from what the expected sum would be from 1 to , most of the terms will cancel, leaving you with . You can visualize that with an example: 

Here you throw a string. You can throw any value, but it's more helpful for debugging purposes if you throw an object. Just pass this string into the constructor to make your own error message. 

These are already available in your scope, so you do not need to reassign them to a local variable with the same name. 

This is a good first attempt, but you have a couple things wrong with it. If you look at the for loops, you'll see it's adding each element to the nav in the same level (rather than nest them inside each other), but then proceeds to move it to the correct place with the inner for loop. That's the second problem. You rebuild the nested element structure each time you iterate over the array. You should eliminate all this unnecessary work, and you can do it in all plain JavaScript without using jQuery. Edit: changed function to accept any number of elements as arguments to nest (e.g., ).