Although "gifted" is broad, it has been made far too clear that potential (implied by the student being gifted) is not enough. They need intrinsic motivation. This is fairly straightforward: The only way to make such an activity work is to get the student to be enthusiastic about some field of their choosing. Many gifted students have ADD\ADHD (Correlation, and not causality), which means that sitting with them to get them started is no easy task. But it can be done by appealing to their strengths. If they have shown special affinity or liking of some field or subject, or have been "always interested in ...", then one should start by suggesting that field or subject. If the student seems interested, one should proceed with explaining that research is a necessary part of the activity. From this point the student should be fairly independent, and the teacher should only be checking in from time to time. (obviously a deadline should be set...) 

I would go about detailing how much profit a white hacker can get, seeing as many security companies hire them as test attackers. If any of the kids are tempted be unethical things, then explain that far greater profit can be achieved with greater ease if one chooses to use their learning for good. So that's that (for any student saying "But I can make a lot of money from hacking") Now, appeal to their sentiment. Ask them how they'd feel if someone could simply type some stuff in some place, and then gain access to ALL their personal information. This includes but is most certainly not limited to: 

Fortunately, these are not the things most students think about (usually, they rename functions and variables / include comments). However, I am interested in improving this model or using something that already exists which would tackle these issues above as well - not only because I want to be able to detect plagiarism but also because I find this an interesting problem. In particular, I am thinking about a system that would actually parse the programs and compare the abstract syntax trees for similarities. Does any such system exist? 

In one of my answers I elaborated on the way we do language-tailored plagiarism checks on student submissions: 

Develop iteratively. Write a small part of the program; then test it. When you get an error, break the last piece added up in different pieces and test them one by one. In the future, write smaller parts of code. 

While this model has proven successful in the past, there are a few obvious ways to escape these plagiarism checks: 

One book I have enjoyed is The Little Book of Semaphores by A. Downey. It is free (in both senses of the word) and contains many problems with hints and solutions that can be used as starting points for small group projects (e.g., to implement such a solution in a modelling tool or to generalise it). I have only used the conceptual chapters, but the book also contains chapters on synchronisation in Python and C. 

The best answer to this is an honest one. "We don't know" But say that with a big smile on your face and enthusiasm in your voice. How you might use this is a big mystery. It might be it gives you an idea how the software that touches your life works under the covers so it's a little less scary. It might be part of your job gets automated and you teach a computer how to do the boring repetitive parts of it so you don't have to anymore. It might be you have a great idea some day and you use this stuff to not only make your life but my life better. It might be, that once you see how it works, making computers do what you tell them to do turns out to be fun! 

Do that, and rather than just explaining, you are showing them how this works, you are teaching them how to debug it themselves when they get confused by it. Now sure the multiline style isn't popular with for loops but the students certainly don't have to turn in code that looks like that. It's just a form to use while testing because our debugging tools aren't yet smart enough to highlight only the relevant parts of a line. I've changed the speed and rhythm I use as I click. That's no accident. I'm using that to emphasize the starting and ending parts of each iteration. Students should not only feel like they can predict this. They should feel like they can use the debugger to re-teach themselves this pattern quickly if they ever need to. Consider a cascading style that retains column position for those more visually oriented: 

I'm a TA for several Bachelor level functional programming courses at my university. In every edition we have problems with some students that have the idea that functional programming is useless, because the industry doesn't use it. The more nuanced students add that some functional programming techniques are useful in any language (they think of lambda expressions in Java, in Python, etc.) but that there is no point in learning pure functional programming as you cannot use it to build real-world applications (and if you can, nobody does it). These students usually tend to infect others and that can bring an unpleasant atmosphere. I have read Hughes' 1990 paper Why Functional Programming Matters, where he explains that people in arguing for FP often tend to show what it doesn't have (assignment, side effects, ...) instead of what it does have. However, the things he mentions that FP does have (higher level of abstraction through gluing functions, lazy evaluation and thus easier modularity) are hard to grasp for mid-Bachelor students. In the end of the course they should be able to understand those advantages when you talk them through it, but the problem is motivating them from the start. I know that most students will not end up as a functional programmer. But, learning one language means getting more proficient in others, and analogously for paradigms, so I think it is still helpful for them to study it. Yet when I explain this to the students the inevitable question is "why don't you teach us FP in a language that we can actually use later?". What can I use to show the usefulness of functional programming? Note: like many universities we don't use Haskell in all courses but a lesser known more academical functional programming language. This explains in part the complaints, however, we receive these complaints on Haskell courses as well. 

Can you tell if is about to be initialized, tested, or incremented here? Debugger highlighting is often useless for teaching or debugging the classic for loop. However, there is a way around that problem. The c style languages all have a feature that lets us work around this debugger limitation. Whitespace. Whitespace is meaningless in these languages. You can take advantage of that. So long as you're willing to explain that this: 

Now that's just the start of understanding loops. Writing correct, readable, efficient loops is a whole other issue that this answer hardly does justice to. A lot of bugs hide right here. Don't undersell how worthy this is of close study. 

I know I'm coming late to this party but this is a really good question and I think it deserves a really good treatment. The original loop, the one with the semicolons in it, is amazingly flexible, powerful, and confusing as all get out. It is seldom taught well, it is a very easy place for bugs to hide, and it is not going away. To master it you must learn the 1,   2, 4, 3,   2, 4, 3 pattern the OP mentioned. You must burn it into your soul. You must burn it into the souls of your students. The question is, how? The best way is to actually see it. To watch it happen. Unfortunately debugging tools often insist on highlighting the entire line. 

Of course, rule 1 is mostly helpful with absolute beginners; it slows down experienced programmers. But for those rule 2 still applies: work the problem down to a Minimal Working Example (MWE). That allows them to ask a concrete, well-scoped questions to their TA (or Stack Overflow). These two rules make sure that the student has a good idea of where in the code their problem is. And then, that part needs to be read very closely to spot syntax (or logic, ...) errors. This mantra needs to be repeated over and over again. In my experience, students tend to think top-down and start working on the main logic without first building the basic blocks. That makes it impossible to test the program until it is entirely finished. By then, syntax errors (or really any kind of error) are hard to find. The initial strategy to break up the main logic is good, but then they should take a step back, think about the basic building blocks they are going to need, develop those (when in pairs/groups, this is a good point to divide the work) and test them. It takes a lot of effort and experience from the TAs to encourage students to read these rules. Often, students come to me with a syntax error without first trying to break down the problem (rule 2). An experienced user of the language immediately sees the error. It is tempting, especially when the lab is busy, to just tell the student what he needs to change. However, that does not really help him any further. You need to actually take the time to sit with the student and perform rule 2 together, until the student spots the mistake himself. Then he will learn the art of debugging.