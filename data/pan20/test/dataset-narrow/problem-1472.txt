Details: Changes in Java 10 The changes landed in Java 10 are comparatively smaller (which makes sense -- Java 9 was released about two years after Java 8; Java 10 was released about 6 months after Java 9). You can find a full list of changes at the following two documents: 

Disclosure: I did variations of assignments 1, 2, and 3 for a data structures course I just finished teaching + made them multi-week partner projects. They went reasonably well, though #1 may have been a tad ambitious. 

Something I wasn't sure about when I was reading your post was if the problem is whether the issue is if students lack motivation or if they lack the ability to succeed in your course. If 30% of your students are consistently failing your course, then I genuinely do have to wonder if the latter is the case. If so, I'm not sure this is a problem you can easily fix within just within the context of your course. For example, I'm assuming the students are expected to complete a few pre-reqs before they can take your course. Why aren't those pre-reqs adequately preparing your students? Etc. If the students are genuinely under-prepared and have "given up" and are just going through the motions so they can graduate, then the best fix is probably to try and systematically repair your entire department. Perhaps that might mean finding more ways to add in support (especially in the intro courses), making sure students know where to find support, raising the bar on core classes... It could also be the case that the pre-reqs listed for your course aren't actually enough, and that you need to add another pre-req class or two to make sure your students are prepared. 

I often see students at levels varying from really bad to incredibly clever. The students in the middle of the scale fit to curriculum perfectly (as it is meant to be for them). The students at either end of the scale are more difficult to teach. Yet, it is clear that all students have another field/skill ( often not related to computers) which they are remarkably good in that field. For example one of the students has a musical understanding such as I have never seen (as an example of this, he can create piano adaptions for Green Day songs and says it was "easy"). These skills are neither a hindrance nor do they aid the students, but that doesn't have to be the case. For the students are not too good in Computer science, their "secondary" skill might be useful for aiding them. I have not been able to think of a good way to use their secondary skills to assist them in learning computer science. In what ways can these skills can be taken into account when dealing with such students (at either end of the scale)? (The students are in high school and know only the basics in java, such as primitive types, arrays, loops and ) 

When teaching Interfaces (in Java, for example), it is common to describe them as a contract. Which means that if a class implements an interface, it has to use the methods in the interface. As an example, the students are shown the following example: 

1There are many things to cover, but I'm referring to the basics, as this is a first lesson in the subject of multi-client servers. They have tackled single client servers, so it's not an intro lesson. 

The UI is often visually complex and intimidating for beginners. This is exacerbated in cases where your IDE unexpectedly changes appearance (for example, after running anything in Eclipse). Setting up new projects and running even a simple "hello world" program is often non-trivial (you have to pick between several different "project templates", need to adapt to working in this new folder layout, sometimes need to configure your IDE to point to your compiler or editor...) The IDE can sometimes be unexpectedly initially laggy. For example, IntelliJ will need to "index" your files/your standard library (with minimal visual cues that this process is taking place). This will cause functionality to be mysteriously laggy or missing for about a minute after first using your IDE. The IDE often introduces several new "metaphors" that need to be explained. (For example, Eclipse has this notion of a "workspace" -- it's not immediately obvious this is actually a folder on your filesystem). This problem is further exacerbated by the fact that a small minority of students don't seem to have a firm grasp of what a filesystem is (which is disconcerting). It's easy to accidentally screw up the appearance of your IDE. If you accidentally click a small button or drag-and-drop something by accident, you can remove an essential part of your view without an obvious way of getting it back. 

At that point, the students will (a) realize it's much easier to combine together arbitrary automata if we can liberally spam epsilons all over the place (and that combining DFAs is non-trivial) and so (b) realize they had better understand how NFAs work if they want to get their engine working. (Do or die, yeah?) A more lightweight lesson idea might be to have students build automata that are very obviously combinations of other automata -- you could have them build each individual subcomponent and ask them to combine them or something to emphasize the usefulness of epsilons. The hope is that they'll start using NFAs more frequently once you emphasize the advantages they have over DFAs. Other things that seem to help are: 

would create a function that gives the average of the comparison between a given string and and . I've tried to explain to a selection of students (as a Proof of Concept of my planned lesson, so only 4-5 students) that lambda expressions just make things look better but they think that it's a new way to do this. I am trying to explain that lambda expressions are simply a shortened way to write something a bit bigger. So my question is, how do I explain what lambda expressions exactly are, in such a way that shows the students how these expressions are interpreted by Java? 

Firstly, I believe that if the thought process is clear to you, then going through that process with your students, out loud, clearly and slowly, can help them understand what it is that you are trying to convey. Go through that process for a number of various examples, which show how you decide on a loop invariant in the varying situations (yes, that pun was intended). Whilst detailing every step in the thought process, you should elaborate on the things that are necessary for a loop invariant to be good. An example of what this means in the case of induction: There's the base case, and that should be relatively easy to understand. Then the hypothesis. From here the "oddities" begin. Go through the inductive step multiple times (it is a loop, after all ), and show them, explicitly, that the invariant really is invariant. A few inductive steps should make it clear how the invariant doesn't change. From there it would depend on how many befuddled faces are looking at the board. If a relatively large portion of the class didn't grasp it, then repeat (note: this is kind of a loop invariant. You always check the same thing) the inductive steps' explanation. This is also useful to show how the algorithm behaves, because essentially you are debugging it1, and so it shows how the invariant dictates the behavior. I've seen the measure of student understanding of complex concepts being mostly or and there isn't much middle ground. When it looks like most students are less shocked then you can go through the last inductive step ($n-1$) and show how the loop invariant is still true, but it becomes false after going through the last step. This shows how the invariant choice no less than defines the algorithm's behavior. 

One idea might be to borrow SQL-related exercises -- find problems asking the reader to come up with some sort of SQL query to find information, and rephrase the problem and ask students to come up with an equivalent query using only Java's functional interface and lambda expressions. (I wouldn't bother telling students these questions were originally about SQL). Translating basic SELECT queries would be pretty straightforward, I imagine -- implementing things like JOIN or GROUPBY would be a little trickier, I imagine. (You can do join by doing something like and group-by using . The API isn't as elegant as it could be here, but I suppose that's Java for you.). You can make it even trickier by asking them to translate the equivalent of nested queries or asking them to extract information from multiple lists at once (e.g. multiple 'tables'), instead of just one. Stepping away from data manipulation, something else you could do is to introduce students to GUI frameworks or webserver backends or anything else that's event-driven -- event handlers are one example of a place where lambdas and method references shine. My last idea is a bit of a stretch, but you could perhaps ask students to invent (or use) a mini-DSL involving lambda expressions in some way. This would be a bit more involved -- the exercise would be less about using Java's already existing interface, and more about writing their own. (It's a shame that Java doesn't have anything like C#'s extension methods, otherwise this would be much easier since you can trivially augment the existing API, which can be pretty handy). If you need ideas for DSLs, you can maybe take inspiration from functional languages like Haskell and how they use higher-level constructs like monads and functors to build quite interesting abstractions and simplify things like error handling. I wouldn't use the word "monad" or "functor" at any point though, and you'll probably need to be careful to avoid accidentally making your exercise more about manipulating generics instead of lambdas. 

These are the two biggest reasons to rely on document flow as opposed to positioning the elements yourself. But obviously, the student(s) are trying to solve a problem they have with the hammer they have. So, maybe instead of trying to convince them not to, show them how bad it performs under real world situations and provide some alternatives. Define the problem 

Explain the basics of PGP and Key based Cryptography - the "Art of the Problem" video linked elsewhere on the answers I agree is the definitive explanation of the Diffie-Hellman Key Exchange theory. This should be sufficient to work practically with encrypting /decrypting with PGP. Students create a set of keys: public key for sharing, private key for keeping. Students share their public keys in a place where everyone can see them and know who's is who's. This is where Keybase would be useful, but you could also just put them all in a public gist or paste bin. It is safe to share a public key. Students can now use the public keys to send messages to each other and publish the encrypted messages in another public place (same pastebin, eg) or via email. 

You mention that you are already using ES6, which suggests that package management and complication are not really barrier, though I would expect that many reading this problem are not setup to ensure node and npm are installed and/or may have access to git/ssh protocols for fetching dependencies or projects. So, the first thing I'd point out is that for some readers, compiling TypeScript could be a barrier that reduces is teaching value. The second and more relevant point is that JavaScript is dynamically typed language. There is value in tools like Flow and TypeScript, especially in production systems, but there is also a great amount of value learning how to program in a dynamic type system. If you're already teaching Java, there are few better choices to teach strategies, advantages and disadvantages to dynamically typed systems. Some students will prefer that type of programming over strictly typed languages. 

One common concern many independent learners of computer science and tech have is figuring out what they "don't know". More specifically, the concern is that since they've never been formally educated in CS, their knowledge might have "blind spots", which can cripple them when they start working on more complex projects or try and get a job. (For example, somebody who didn't know that data structures and algorithms were a thing will very likely struggle on most standard tech interviews). I interact with/help self-learners on a fairly regular basis, and am never quite sure what to tell them when this question comes up. One strategy, of course, is to simply give them a list of things they ought to know -- there are many articles that give a good overview of topics covered by a standard CS degree, for example (example 1, example 2). However, this strategy doesn't generalize well: once you move on to trying to learn about something not on some list, you're back at square one. The other strategy I try suggesting is to just read random highly-upvoted posts on StackOverflow and news aggregate sites like Hacker News -- I've personally found you tend to pick up a good awareness of different CS and tech topics almost by osmosis if you do this. However, this strategy is also flawed: it's a random and slow process, and isn't guaranteed to be comprehensive. (If a topic isn't trendy, it's likely you'll never stumble across it.) This brings me to my core question: what are some effective meta-strategies suitable for self-learners that help them identify gaps in their knowledge? I'm hoping for strategies that are either more generalizable or more systematic then the two I listed up above. 

I would go about detailing how much profit a white hacker can get, seeing as many security companies hire them as test attackers. If any of the kids are tempted be unethical things, then explain that far greater profit can be achieved with greater ease if one chooses to use their learning for good. So that's that (for any student saying "But I can make a lot of money from hacking") Now, appeal to their sentiment. Ask them how they'd feel if someone could simply type some stuff in some place, and then gain access to ALL their personal information. This includes but is most certainly not limited to: 

Before showing the correct way, ask if anyone can see what this program does. It would be difficult for most. Then show the best-practice version, and they'll see just how better it is. 

I think this an essential and main part of teaching programming and cs (and teaching in general). The ability to hold the answer and guide the student to it. What I do is try to follow the thought process of the student. When working with them to help them find the problem, I ask various questions (usually "what do you thing is causing this?" etc.) and by their answers it's possible to see what sentences would guide them to the solution. This method works great (that sound out of the sky but it's based on student feedback) as it allows the student to feel that they found it on their own. I find that they also learn to spot issues on their own afterwards. Additionally, it's worthwhile remembering that you are the instructor, and not the student. And that the project is a student's project, so keeping that in mind often helps with holding back from doing the work yourself. However when all else fails, showing the students how you might do it could be a last (last) resort. Just be sure to explain every step you're doing, so that the student understands. I cannot express enough how bad this last resort is. But if it gets to that, make sure you're not doing their work, but rather show them something similar