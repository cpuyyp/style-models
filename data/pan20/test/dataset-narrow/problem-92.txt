Gibberish means the port speed is wrong -- or flow control isn't setup correctly and it's overflowing. Nothing at all means the wiring is wrong. Don't assume Cisco and Juniper use the same pinouts. Of course, it could simply be DTE vs DCE (tx/rx swapped) Here's how I have a line configured to access a 2948G-L3: 

Obviously you aren't using a Cisco VPN client, as it monitors the route table and will remove your tampering immediately. Even if the routes stick, the ASA will ignore traffic that doesn't belong in the tunnel. There are two possibilities at play here: 

Then what you are seeing is exactly what you should see... STP killing the loop. Switch A & B are connected via their LACP trunk. And then an access switch is connected to BOTH Switch A and B. One of those two links will be (MUST BE) blocked. There may be a disconnect between the access and main switches, as the access switch is in the state on all ports. I've never seen a stack do that. 

This is a matter of DTE vs. DCE -- the role each endpoint takes. The NIC in your desktop is a "user terminal" (DTE). The switch it connects to is "communication equipment" (DCE). All this means is which pins are transmit vs. receive, such that a straight through cable from DTE to DCE works as expected. This is why a crossover cable is(was) required to connect two switches (DCE) or two hosts (DTE) together. "Auto" really didn't become popular (read: everywhere) until the era of gigabit ethernet. Gig-e uses all four pairs for both TX and RX, so the required logic for auto-mdix is already there. Prior to this, additional logic (read: additional costs) were required. 

Wifi (802.11) and WiMax (802.16) are not the same thing. Availability of WiMax USB devices will depend on the network operator. 

DHCP is a link-local protocol. (broadcast) For it to span networks (broadcast domains, the internet, etc.) there has to be a relay-agent. (or more than one) That agent listens for requests (unicast and broadcast) and transmits them on to some other server. In theory that server can be anywhere, but some (many?) DHCP servers aren't happy getting requests from non-local agents. (like the DHCP server in windows 2000) Also note, there is a maximum size for DHCP requests; each relay adds to the packet. I would recommend packet captures. (debug ip packet, with an ACL defined to catch dhcp) As your router(s) aren't a DHCP server or relay-agent, debug ip dhcp isn't going to get anywhere. 

This is a common issue when companies merge. The correct answer is to renumber one (or both) networks. However, in the short term, src and/or dst NAT can make each network appear to be a different range. There will have to be intermediary gear as one router cannot have two interfaces with overlapping subnets. [Update: one could use VRF to simulate multiple devices, but that's an Advanced Level technique.] 

Without monitor mode, there will be no access to non-traffic frames. Use a 3rd device (PC) that does support monitor mode to record radio traffic. 

Enterprise Networks - Enterprise networks basically are the most basic and common networks that exist, these networks have a simple topology, mainly consist of network switches, and router facing the internet connected to the ISP. The switches may vary from layer 2 or layer 3 switches and VLAN configured. Data Centers - Data Center networks are the second most complex networks, most big internet startups have their own data centers, i.e Google, Facebook. Data Centers have high end switches and routers for optimal speed and performance. In addition technologies such as VMWARE data center virtualization helps in maximizing performance and limiting the physical devices that runs in this network. ISP Networks - ISP networks are the most complex networks that exist, these networks operates in the WAN or the "internet". It is important to note that the largest WAN is the "internet" and it is a network of networks that is decentralized. 

In a typical enterprise network, the NAT router has inside and outside interfaces, the inside interface is connected to the LAN and the outside interface is connected to the ISP. Is the NAT router connected directly to the ISP router or it is connected to a T1 ISP circuit before it reaches the ISP backbone/core network? 

BGP is used for external and Internal routing between "internetworks", BGP is commonly used by ISPs and large organizations to route throught the internet using ASN (autonomous system number). External BGP is used by ISPs to communicate to another ISP or any organization that has a "Backbone". These types of routing occur outside the LAN, instead these routes materializes in a WAN or which is the internet. 

All IGP (Interior gateway protocols) routing protocols works at layer 3. External BGP works at layer 4, while internal works at layer 3. 

Physical Layer - Deals with hardware network devices, i.e laptops, mobile phones, desktops. Layer 1 is known to be a collision domain, Layer 1 PDU (protocol data unit is bits). Data/link layer - This layer concerns with layer 2 switches, broadcast domains, VLANS, STP, VTP. The protocol data unit of this layer is called frames. Network Layer - This is when routing occurs, most routing protocols works at this layer. This is also known as the IP layer, where VLANS communicate. The PDU for this layer is known as packets. Transport layer - Transport layer deals with TCP and UDP ports, these is where the packets from layers 3 are sent to their destination ports. It is important to remember that TCP is a connection-oriented protocol while UDP is connection-less oriented protocol (non guranteed delivery of data). The PDU for this layer is datagrams. Session layer - Session layer is where the packets are encapsulated from being decapsulated from layer 3. This layer deals with multiple server side programming languages where you can create software-based applications and convert them into -> The Presentation layer - This layer is about the client-side codes you see on your web browser, or when you do a right-click and view the source, these are mainly HTM/CSS/Javascript codes that allows you to view your -> The Application layer - This is where the GUI (Graphical user interface) translates the HTML/CSS codes from layer 6 to this layer. What you see on your web browser is the front end GUI. Layer 5,6,7 PDU is called message. 

Because the concepts defined by OSI model are useful for understanding real-world networks. OSI defines 7 layers, these layers (especially layer 5/Session and 6/Presentation) don't match well with the now dominant well-known telecom protocols (above and around IP) - the model should not be blamed for this. After all we can't say that the IP protocol stack is particularly well designed. The model defines a lot of very useful concepts, and distinctions to be made, in the analysis/understanding/design of any complex telecom system. For example: the notions of service and protocol; the notion of primitive (request, confirm, indication, response, signal); the notion of protocol entity and Service Access Point; the notion of connection vs. association; the notions of SDU (Service Data Unit), PDU (Protocol Data Unit), IDU (Interface Data Unit); etc. These concepts are extremely useful. Also, OSI model is still used heavily to define current protocols. For example ISO 11073-20601 and friends (Point-of-care medical device communication), used in medical devices (typically over Bluetooth) heavily use OSI modelling of Application Layer. Or the IEEE 802.xxx lower layer protocols (e.g. 802.15.4, radio protocol) - these use the ISO modelling of the lower layers. These protocols are recently designed and in use today. 

You may use the following protocol (inspired by PPP over Asynchronous Links RFC), with two special characters IDLE and ESC. You will need about 2 bytes of RAM at the Transmitter and 2 bytes at the Receiver to maintain state information (plus two more bytes for CRC computation). Payload data are arbitrary, from 0x00 to 0xFF. Say IDLE is 0x7E, ESC (for Escape) is 0x7D. IDLEs MAY be sent by Transmitter at any time when it has no payload data to Transmit. When Transmitter wants to send a frame/packet, it MUST send IDLE, then the escaped (see below) payload data, then IDLE. As IDLE should not appear in frame data, we define a second special character ESC that will be used by Transmitter when it wants to escape data. IDLE and ESC itself will be escaped, at a minimum. When the Transmitter wants to send payload byte: - 0x7E (IDLE), it transmits two bytes: ESC followed by (IDLE ^ 0x40) [IDLE XOR 0x40] - 0x7D (ESC), it transmits two bytes: ESC followed by (ESC ^ 0x40) - other byte, it transmits the byte unchanged. Alternatively this byte MAY be escaped by ESC followed by (byte ^ 0x40), provided that (byte ^ 0x40) does not result in IDLE or ESC. The escaping formula (byte ^ 0x40) is not magic, it can be replaced by another. The important thing if that the result of the escaping formula is never ESC or IDLE. From the Receiver point of view, any data received between two IDLE makes a frame/packet. Receiver has to unESCape these data in order to get the initial payload data. It is of course strongly advised to add a (2-byte) CRC at the end of the frame/packet, just before the closing IDLE. This CRC has also to be ESCaped. CRC can be computed on-the fly, on a byte-by-byte basis. I have implemented this kind of protocol (precisely: encapsulation) numerous times, it's very simple, reliable and efficient.