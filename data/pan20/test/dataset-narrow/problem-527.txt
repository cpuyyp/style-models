Originally, I began writing code to loop through my list and my list and then realised I was going to be writing duplicate code for every list of data and switched to having a and looping that and ended up having to use reflection. I was wondering if anyone can think of a way of achieving my goals without using reflection or having duplicate code for every type of model stored. I'll attach my current completed class below. I don't mind doing so much but it's the code: 

I am quite sure this code is okay, outside of the overhead induced by the run-time typing - my apologies if this makes it a bad fit. I am just hoping for a once-over review by someone more experienced to reassure me that this is a good design. 

Finally the compute function which drives the calculation, iterating over all candidate expressions until a match is found or there are no more possibilities 

The Problem Given a list of dependencies where the first item has a dependency on the second item, construct a dependency graph and then 'flatten' it into a single such that no item comes after one of its dependencies. Constraints I am trying to improve my functional programming/idiomatic F#, so I want to avoid mutability. My Solution 

This function that takes an (in the first case, a list of s) and produces a which is calculated by all the possible applications of a single arithmetic operator () to any/all pairs of expressions. 

I am implementing a multi-player game in C# and having seen all sorts of projects, from indie developers all the way to large studios struggle to patch networking into existing products in the past, have made the decision to get the networking aspect done first, and build the game on top of that. I've so far gotten to the stage where my server can accept clients asynchronously, but I have a strong feeling that I've implemented the threading very badly. I think it is possible that I am misunderstanding and/or misusing async/await and Tasks, but having read documentation and similar questions I think I will need practical experience to get my head wrapped around the correct usage of these. As a result, I am hoping that someone would be generous enough to look over my code and help push me onto the right track. I have excluded 'using' statements and the client code for the purposes of this question, however I can confirm the code does function correctly. I am not too concerned about issues such as naming, and the fact that I have a bit too much code logic in the Main function right now -- these will be modified and extracted to more appropriate locations respectively as the project progresses. I have denoted lines I am particularly concerned about with 

I have slightly simplified the function by merging the function into the resulting computation expression. I refrained from merging the function, as its functionality is distinct enough to warrant a separate function IMO. 

Once the root has been added to the graph, it is passed in to a recursive closure, , with two accumulators. is for tracking circular references; is for excluding repeated nodes. I don't know how necessary it is to have these two accumulators instead of just one but they do have separate responsibilities. 

The graph is transformed by the function from a into a . I am fairly happy with this function, it seems to be idiomatic F# to me. 

Additionally, my usage of any features in more recent C# iterations (C# 6 most notably) may not be up to scratch, so I'd appreciate any suggestions for making my code more condensed or 'modern' I apologise if this question doesn't fit perfectly here -- I was concerned it was a bit too specific and if it is, please comment and I'll try to open it up a bit. 

That's really bothering me. It just feels wrong and suboptimal and I'm sure I'm not thinking this through properly. Full code below: 

I'm not sure whether my distaste for reflection is justified or not, but it feels ucky that I'm using reflection here. I'm trying to make a very simple class which has a number of where with a load and save method. The load method should: 

The function takes a "root" node that I use to connect potentially disconnected subgraphs. I don't really like this, I feel like it shouldn't be necessary, but it seemed to fit the rest of the algorithm. 

Countdown is a British gameshow where contestants compete in word and number challenges. During the numbers round, six numbers are chosen semi-randomly and the task is to combine them using addition, subtraction, multiplication and division in order to reach a target number. For example, the numbers might be and the target . One winning solution is Below is some F# code that I wrote to try and improve my functional skills. The function accepts an and an and returns an which is the closest it could find to the target. 

You are repeating the same processes twice. First you scan over the string finding the length of the number. Second you scan over the string calculating the value of the number. There is no need to do that. Use one pass. 

Also is old and is known to be pretty bad. You should be using the new random number generator that was provided in C++11 to solve this specific problem. $URL$ Generating a pack of cards 

The correct way to do this is to use the RAII idiom. This means creating a class where the constructor allocates the resource and the destructor deallocates the resource. Since the destructor of an object is automatically called when an object goes out of scope (this includes when the stack is unwound by an exception being thrown) this makes resource allocation/deallocation exception safe. 

For every list, Open or create Sequentially load each file in the folder into memory by creating a new instance of and calling 

Adding a new message type does not require any modification elsewhere to be supported. Subscribing to an event is as easy as creating a method with the correct event class. There is practically no overhead for listening to a specific event - no need to instantiate a class, inherit some event-specific interface, register interest at run-time with a subscribe method, etc. As messages are represented by classes (like a MoveMessage), they can contain all the relevant data without needing to be cast or coerced. 

Finally, this clause seems overly complicated. I feel like there's probably some method on that I could use here. 

I also wasn't sure how to represent a circular reference without using an exception - perhaps a discriminated union with a case for circular references could be incorporated? 

Something else I don't like is the implementation of the closure - specifically that it uses a with two state objects: a sequence and a set of resolved parameters. This was the only way I could think of to iterate through a list of dependencies while passing in an updated set for each item and simultaneously preserving the order of the sequence returned. I realised that I don't need to pass the resolved set through the fold - instead I can just insert the previous results into the set (possibly inefficient?) 

I wanted to remove this very strong coupling which my components have (as a result of specifying exactly which component should receive the message), and transition towards an event / message system. As a result, I've written an implementation which seems ideal, however it uses run-time dynamic typing which has me concerned that there may be a better way to achieve my goals. 

Exhaustive set of event properties which components can subscribe to manually - adds extra code overhead to each message type, which I'd like to avoid Dictionary from event Type to handler in each component - have to subscribe at run-time, which feels undesirable. Switching dynamically inside a non-overloaded handler - more viable than it sounds since most components will not listen to more than a few message types, but still has unpleasant code overhead