In this example, I've shown the format as an in-line . It can be done as an expression, also. Given your ranges, the overall function is this. 

This can't work unless you stipulate a specific size for the partition and do not grow it. You can't discard any value from the input sequence or you won't get the actual maximum. The fact that you're popping a value means that you may be discarding a proper part of the solution subset. Consider a slightly contrived example where X = 0.25. The initial state is to process 1/X items (4 in this case) of which 1 is maximum and 3 are discarded. The values were 100, 99, 98 and 97. You keep 100 as the 25% maximum and discard 99, 98, 97. (You could try to keep all 4 or even the first 25 values. It doesn't matter how many you keep initially, the logic problem will still arise as soon as you pop a value. I think the contrived example makes the logic flaw easier to see.) At some point, you've seen 7 values. The maxima subset has 1 value (100); the remaining values (99, 98, 96, 95, 94 and 93) have been discarded as not part of the maxima set. You get value 8, it's 92. You need to append this to the top set. Yet, sadly, you discarded a value larger than this. When you get to value 12, you again need to expand the maxima subset. However, you will have discarded values that may be larger than the 12th value in the sequence. You cannot do a from the maxima subset unless you can prove the value being popped must be less than all future values which may arrive. 

This is a pretty radical rethinking of your algorithm, so it's not a proper code review. Assembling a string with separators is simpler in Python. For your example of ","-separated strings, always think of doing it this way. 

Perhaps you're looking for something such as this. You had lots of repetition in your code, and so I basically applied the DRY rules to your code. It could still use a lot of work and I'm sure there's other approaches, but this might help you kickstart the process! Another way to possibly help improve your code would be to separate the logic, database access, and your s. You've probably heard of frameworks and such, and you might want to start looking into your options. It will keep your code separated, and while maybe not shorter, it will be much neater! 

In my opinion, no your class is not clearly documented and easily understandable. Here are the main reasons I find this code... dirty: 

General Instead of having your function convert string values to numbers, throw an error if, for example . only accepts a float value, so I think you should follow their convention. Also, this will allow you to remove (or, above, you could check for only). This if-condition doesn't have an else, so when poor input is entered, the user could potentially not get any response at all -- terrible for debugging! Performance is checked two times, you can reduce that to none since will automatically return false if there is nothing (or throw an error is there's no argument). 

I suggest you use someone else's maintained and secure code. They'll often have proper error handling too. Almost every PHP framework has one, and there's a dozen on GitHub. It's too hard to specify one, so I suggets you do your research. Question 4: Yes. Avoid s. Give yourself room to expand with a config file or a config class. Preferably the file, and then a class to interpret the data the file holds. Again, dependency injection. 

Avoid trying to build a "mutable tuple" as a fixed-length list. Either use immutable named tuples or a proper class. 

The statement can be removed, also, since it's really two generators. But that's being really fussy about performance. 

Do not use a database for this. Use files. A single file with one tweet per line showing User Name, Tweet Text and whatever other information you have. You need to sort the file by user. Use the OS-level program, don't write your own. Once the tweets are sorted by user, you simply read and count. 

You still have the calculations. You're just giving them names and keeping them separate. Giving them separate names makes them more reusable, easier to test and easier to find. The most important thing here is to avoid creating a (nearly) useless class who's only job is to contain a bunch of functions. Your code uses no instance variables and simply uses another function that happens to be in the class. Both of these could be method functions. There's no reason -- in Python -- to create a class unless you have instance variables and a change in state of some kind. [In Java, you must often create "all-static" classes because there's no other place to put stateless math like this.] You can simply put these functions into a simple module and avoid the class definitions. 

These aren't "utility" functions. They appear to be central to your app. There are rarely "utility" functions in any app. What we used to call "utility" functions are almost always part of a standard library. 

It's (often) slightly faster in Python to avoid the statement. After measuring that with , you should rename the variable . That's a poor name. 

A few. Sorry it seems boring, but there's not much better you can do. The biggest change might be to make this into a generator function, which may be a tiny bit neater. 

Your code looks fairly good. It's nice and easy to comprehend, and it's to the point. It is also something that's been done before, so luckily you can look at others' code and compare/contrast. I'd like to suggest looking at the FIG standard autoloader. It comes from this PHP FIG Autoloader standards page, which is an excellent resource when determining what looks "good." Also, you may want to take a look at other, maintained autoloaders, such as the Aura Autoloader. If you choose not to use it, it could still give you hints on how to expand/improve your current code. 

Separate your classes into different files, and keep the HTML out of the PHP. Mixing the two makings things a hell-of a lot harder to read! 

Where are you getting and ? Same with and . It's okay to add those in your question next time (just without the actual values!) :) In you first you have a typo. The assignment to should really be . I'm not sure why you didn't receive an error for that. This 

Database Does this class do something extrodinary that PDO doesn't do? I just can't find the point behind this, as it's basically a replica of PDO with less functionality. Anyways... 

This may sound harsh, I meant to be friendly though :) It's bad/unsafe/vulnerable. This type of situation comes around a lot, which is sort of understandable. However, what is your class really doing? It's essentially pointless to make this class. You've basically just put a class in a class without doing anything different! So actually what you've done is make things less secure. You mentioned a "more dangerous" option of preparing the query. That would be a false assumption. Preparing queries are one of the largest features of the PDO and MySQLi interfaces. They're far from dangerous if used correctly. It's hard to tell if what you're really doing is "secure" because the actual SQL handling functions you've left out. Now that that's out of the way... To improve your coding, you can: 

Your use of the dictionary seems to be a way to allow the numbers to arrive out-of-order. Rather than sort them, you seem to be trying to use a dictionary (and associated hashing) to maximize efficiency. This doesn't really work out perfectly, since you wind up doing sequential searches for a given value. Hashing a low:high range (a dictionary key:value pair) to avoid a search doesn't help much. Only they key gets hashed. It does help in the case where you're extending a range at the low end. But for extending a range at the high end, you have to resort to searches of the dictionary values. What you're really creating is a collection of "partitions". Each partition is bounded by a low and high value. Rather than a dictionary, you can also use a trivial tuple of (low, high). To be most Pythonic, the (low,high) pair includes the low, but does not include the high. It's a "half-open interval". Here's a version using a simple of tuples, relying on hashes instead of bisection. A binary search (using the module) may perform well, also. It would slightly simplify adjacent range merging, since the two ranges would actually be adjacent. However, this leads to a cost in restructuring the sequence. You start with an empty set of partitions, the first number creates a trivial partition of just that number. Each next number can lead to one of three things. 

Don't reuse to be the index of the loop. It's confusing. It violates the meaning of start. The lengthy parameter parsing is good, but can be made more clear. Don't waste time on checking for or . Just use the statement. 

There's no real way to speed up the brute-force enumeration of all possible 3-letter passwords. Perhaps you could use the dictionary. There's a finite list of 3-letter English words. They may be slightly more common. Also, if you google for "most common passwords", some kind of 3-letter version of that list could be tried before anything else.