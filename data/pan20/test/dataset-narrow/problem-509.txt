The code you supplied is actually the code you use. That the code is actually doing what you expect it to do in the first place. 

You should make consistent use of spaces, e.g. you have vs - generally sprinkling a few spaces around makes the code easier to read. can be simplified to . I'd classifiy the implementation for as broken - if you pass in an index which is out of range then will be and you invoke undefined behaviour (most likely you will trigger an access violation). In you duplicate the code from In you do a check whether index is valid however the implementation is questionable. You should throw an exception instead of writing to - this way you can leave the user of your data structure to deal with invalid input. Similar - instead of writing to it should accept a callback function which gets called for every entry. This way the caller can do whatever suits best. The method names should match those of standard containers so people familiar with them will bve immediately familiar with your data structure, so like instead of , or instead of . Next step would be to add iterator support. 

looks like a C++-ism. In C# you have value types () and reference types (). is a class and thus passing it by doesn't gain you anything unless you want to replace the list object with a different one. If anything should create the list, fill it and then return it. could be better named like . As @rolfl pointed out you don't actually need to store all the numbers - you can just generate them as a sequence with an enumerator and then do your processing on the resulting sequence: 

To add my 2ct worth: What you have started to implement is the Active Record pattern. We have used it in a Winforms/WPF application and ended up changing it to a Repository pattern due to the fact that it was annoying to unit test and we started having session scoping issues (but those were probably a result of bad application of the AR pattern rather than a problem with the AR pattern itself). In the end we found the Repository pattern much easier to deal with and unit test. It also keeps your model classes like very simple which makes it easier for serialization. 

1) I would rename in your iterator to to make it consistent with and also to express in name what the comment says (get current item). 2) I don't like how the and implementations introduce a state in the list for the current position. It intermingles data representation with iteration. Also both and contain methods regarding a current position so they are no longer clearly separated. Have a look at C++ iterators. They remove the iteration concern completely from the list (by keeping the iteration state in the iterator and not in the list) yet allow you to do what you want: insert an element at a specific position (). 

It would be nice to be able to pass an instead of having to make sure implements . It could default to . This provides you with a lot more flexibility in terms of which types can be used as keys. can return . So if you try to access a non-existing key you will get a which is typically not very meaningful. The indexer should protect against that and throw a instead. Related to the previous point you may want to consider implementing a method similar to what other data structure implementations in the .NET framework provide. Regarding the validation code: I don't think the validation code should live in the data structure. What I'd do is to make implement with the enumerator doing a in-order traversal, but instead of yielding the node it yields a with the data. This way you can write the validation code as a unit test. The one is a bit more tricky. Need to think about that one. 

is not a particularly good name for the interface as it represents a source of data rather than the data itself. Therefor seems more appropriate. The interface is a bit ambiguous - which method am I supposed to use or ? Why use one or the other? Could I call both multiple times and interchangeably? As of now it doesn't really provide enough value to warrant it's existence. You'd be better of having accept a and let the calling code deal with how to wrap it around the source. Consider passing the as part of the constructor for the - it's an integral part of its validation logic. In the validator when the reader throws an exception because there was a problem reading from the stream for example then you catch those as validation errors which I'd consider technically wrong. Your validator should catch validation errors - i.e. anything that has to do with invalid XML. Everything else should not be of its concern. So don't catch - be more specific. 

In the end copying complex examples from MSDN is not always a good idea from a design point of view as their examples are trying to show the usage of methods rather than convey good design. 

You will have to change your to accept a start index and a count which defines for how many items it is responsible: 

There is nothing inherently wrong with having multiple using statements. It keeps the lifetime of objects to the minimum which is not a bad thing to do. Another point is that I'd possibly re-factor the error raising: You always prepare the error message with the same parameters except for the actual message. This could easily be encapsulated in a little helper function. So the refactored code could look like this: 

Consider dealing with error cases first to reduce nesting. This makes the code easier to read when there are multiple levels. E.g.: 

All that being said I'd say: Yes you want that backend API. Apparently the whole system expects a certain kind of workflow and providing a structure which an implementer can fill in will make it much easier for them and probably reduce bugs.