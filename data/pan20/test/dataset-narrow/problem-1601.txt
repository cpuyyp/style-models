No, you cannot run Windows 10 IOT Enterprise. As is, the IOT flavor of enterprise is just a headless optimized version of the desktop version. The enterprise version still requires an x86 processor. The RPi has an ARM processor which is fundamentally incompatible with your goals. 

The details on how to setup either of these is out of the scope of this site, but you should be able to find a tutorial for either fairly easily on Google. 

On the Seafile download page there is a link to download a "Seafile Terminal Client" and it's listed for "Generic Linux". Download, and extract the 32-bit option. Since it's written in bash/python, you don't need to compile it. It doesn't appear that the standard client is supported on the RPi, and I can't find an available source download either. Farther down there's an RPi server edition, but nothing on the site mentions an RPi client. Edit: After a little more searching, I managed to find the source download for the client on github. The README at the bottom of the page describes what prereqs to install and how to compile and install the software. Just installing Qt on the RPi will take a long time, let alone compiling that software. I'd recommend sticking to the terminal client if possible. If it's not, be prepared to wait. 

(emphasis mine) I missed the part about USB cameras. Yes, you can process multiple cameras through a USB interface. The link in the comments is a good example of how to use openCV. I'd also recommend their own website's documentation 

The difference between the class 4 and class 10 would be extremely obvious on the original RPi, and even more so on the RPi 2. Even if you're using a read only filesystem, the boot time will be dramatically shorter. 

are what you're after. Edit: As our wonderful moderator, Steve, has pointed out, there is a security concern when downloading files from a random person's dropbox. The poster states that he's simply using his dropbox as a mirror since the files have a tendency to disappear. On the forum linked (which is the official foundation forum), it has been well received, and no concerns have been raised. Install at your own discretion. 

It seems like you may not really understand what a cluster is or how it operates. There's nothing magic about a cluster. You don't get to just plug multiple RPis together and get Voltron. Clusters are a group of computers working together through software. Generally speaking, the master takes very large task, splits it into multiple smaller tasks and distributes it to each machine. This can give you a huge performance gain in specific circumstances, but there are requirements for such a thing to be worthwhile. 

A common problem for this is that the file is missing from the new user's home directory. Try copying that file from the pi user's home directory to that of the new user. Edit: As prograde mentioned in the comments, it appears some versions have moved the file to 

As the others have mentioned in the comments, you're thinking of your problem from far too high of a level. Being able to call in a language like python actually goes through several layers of abstraction before it actually hits the display. A Broad Look at Character Printing 

Put the new, higher capacity microSD card in the converter. Insert the converter (containing the microSD card into your laptop) Open the terminal* on your laptop and run the following command: . Again, need to replace X with the device number of your SD card. Eject the converter and remove the microSD card from the computer. 

You're not properly disconnecting the device. In fact, you're not disconnecting the device at all. Your FireFly device is connected to your RPi, not your Python application. Your script is reading a serial port on our device, and then closing it. This is a very similar concept to opening a file. If you have code that opens a file, writes to it, and then closes it. 

This seems to be a problem with older (read: slower) SD cards. If I recall correctly, the creator had significant problems with cards that were lower than class 6. You may be able to fix the issue by running on the card (requires admin rights). If that doesn't work, you'll probably need to buy a different SD card. At the very least I'd try a different card reader. 

I don't see any documentation on the RPi 2's max GPU setting. It appears that the max memory split is 448MB for the 512MB RPi. My guess is that since the RPi 2 doesn't currently allow for the max ram to be used by default, they also haven't upped that limit yet. My suggestion is to try and set it at 448, and wait for more news. source 

If truly need USB 3 speeds, the RPi is likely not a good platform for you to use. At this time, I have not seen any development boards in the RPi's price range that truly utilize USB 3. The Minnowboard Max has a USB 3 port, but it's a significant jump in price. 

Apt-Get You can often remove a good bit of junk by removing old package dependencies and junk produced by apt-get. 

Currently, RPi support is non existent. Problem 1 They advertise that they can run on Android devices. This means that at some level their is support for the ARM processor, but my guess is that the RPi 3 is not powerful enough to run it well. Problem 2 Linux and Mac are currently not supported operating systems. 

That answer depends a little based on which model of Pi you have (1 or 2). On Unix systems, the load is an indicator of how many processes are trying to use the CPU. To use the standard example, think of the load as a que of cars sitting at a toll booth. Your operator can handle n cars per time slot. At < 1.0, you are under your max capacity and cars can go through as soon as they reach the booth. If the load is > 1.0, then you're going to have a line of cars at the que. That means that the ones at the back will have to wait until the ones at the front are done. If you have a single core processor (aka the Raspberry Pi 1) you generally want the load to be less than 1.0. With multicore processors (aka the Raspberry Pi 2), your max target load is multiplied by the number of cores (4x in this case). So anything under 4.0 is optimal. The original raspberry pi is pretty slow, and a lot of what Kodi asks is fairly intense. You're not going to harm the Raspberry Pi by having a load over 1.0, but it won't be as snappy as you want. Over clocking the Pi might help, but I wouldn't worry about it too much if it isn't causing issues. 

No. FM output by the RPi is not harmful to humans. FM is nonionizing radiation and studies haven't found to find any harmful links between FM exposure and cancer, though that's a popular myth. The FCC's safe exposure limits are far, far below anything you could possibly be working with. 

Now, since you don't have a display driver, that's essentially what your code needs to do. You'll need to define what something like "A" looks like in the terms of lit up dots on your screen. This is a difficult process to get right, but it's certainly not impossible. You'll spend a lot of time with your display's datasheet, and you might want to spend some time looking at how existing libraries have solved some of these problems. 

I forgot to mention that you also need to consider the fact that the OS has buffers in addition to your file. Look into the module. Specifically, calling at the end of your loop should help to make sure that the OS is writing to the disk when you want it to. 

It is not possible to set the device hostname through . A full list of commands can be found on the Raspberry Pi Foundation's website. An Alternative: You mention that you're creating a custom image. In this case, I believe the best practice would be to write the assigned hostname to during the card creation process. It does require a reboot (assuming the RPi is currently running), but so does changing anything in . If you really want to get around the restart thing, it's possible, but can cause some issues. The hostname can be temporarily changed by the command . Once that's set, restart the network service with . Now, if you run you should see your new hostname as active. This change is not permanent. When you restart the device it will go back to whatever is stored in . 

It is the exact same chip that's in the RPi 1, just clocked faster. The foundation mentions that in a video on the product's announcement page. Look at about 1:15 mark. 

The main things that I would consider are: 1) Is cost an issue? The Raspberry Pi is cheaper, but the beaglebone black comes with a power cord and onboard storage. Unless you have an adequate power cord and sd card lying around, the Raspberry Pi will cost about the same. 2) As far as ease of setup goes... Both can run full versions of linux. At the very least, you have a compete graphical interface for all setup purposes, so I'd say their setup effort is about equal. 3) Is speed an issue? The raspberry pi's ethernet is slightly more powerful, and with overclocking (built in support) the raspberry pi's CPU is comparable to the beaglebone black's. For just a torrent box, I honestly don't think either is really better, than the other. They're so close, just pick whichever you like better. 

The source code is available on the website you listed. You should be able to install the pre-requisite software, (gcc-avr, avrdude, avr-libc, and avr-evtd) and then compile the source code. While entirely possible, this will probably take a long time. If you're using an RPi 2, make sure to take advantage of the multiple cores by using instead of . Even so, compilation will take a long time; be prepared to wait. 

As I mentioned the other questions are off-topic, I'll stick with answering the fourth question you posted. The RPi can be used as a network attached RAID storage device, but there are a few things to consider Power: At this point, the RPi 2 and 3 are usually able to power a single external hard drive without issue. You need to pick a lower powered drive, and a decent power supply for the RPi, but it can be done. That being said, the RPi will probably be unstable with 2 external hard drives attached, I doubt more than that would work at all. You're going to need an externally powered USB hub for this to work. Throughput: The RPi's USB bandwidth is shared between all four USB ports and the ethernet controller. If you're trying to write to multiple hard drives from across the network, this is a huge performance hit. This can be alleviated somewhat by using an RPi 3 and connecting via Wifi, but I wouldn't consider that a preferred option for a NAS device. In contrast, an actual NAS device will deal with SATA/SAS connections, which will give you much better performance. Magic: Okay, so nothing is actually magic, but there's a lot of things built into a dedicated NAS box that you're just not going to get in an RPi. Things like hot swapping, and the user interface are a big plus provided by the commercial solutions. You can get some free software that has similar features, but you're just not going to get the hardware level control from it like you would expect in a full sized NAS. Hardware vs Software: The processor in an RPi 3 is more powerful than what you'd find in the more inexpensive consumer grade NAS devices. That being said, a lot of that horsepower will be dedicated to the fact that it's doing a lot of work through USB (network and attached storage). Additionally, your device redundancy will be handled through software. There's no way around that. A proper NAS device will have the redundancy writing system built into the actual hardware of the device. They don't need as much horsepower simply because it has better purpose dedicated hardware. Benefits of the RPi: While it's not the best plan for a NAS, if you want the device to do multiple things, there's certainly room for the RPi to shine. Unlike a NAS, the RPi is a full linux computer, with a wide range of I/O connectivity. It could simultaneously host a webpage, or other project of yours that doesn't require the RPi to continually move. I've always thought it would be cool to put a temperature/smoke sensors on an RPi and have it do an emergency off site backup if it detected a fire. Plus, learning is fun!