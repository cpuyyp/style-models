You should read the Javadocs for Slicks TrueTypeFont. It has a Method to get the width of a particular String. To draw perfectly centered it is then simply 

As you see on the right, a lot of faces share their vertices and each vertex uses the same UV. The more vertices your model has, the more vertices you can (probably) share, but, it will (almost) never work to have the exact same amount of shared vertex+UV pairs as you have unique vertices. 

This heavily depends, but in most cases you send a mixture of both. In your example-game, a 'playerJumped' wouldn't be enough because latency matters. Every single nanosecond could change the outcome heavily, so that a 1ns-to-late-jump changes the position of the player 20 seconds a lot. Thats not what you want, so you'd send 'i jumped in frame 30' or something like this. In a fixed-timestep game this would be enough to get the same result on every client. Updates every frame are in this case not needed because every client can calculate your position and would have the same outcome. 

If this still doesn't work, try passing as vertices and as indices and step through it with the debugger. 

No, you don't need to. And this would even be wrong, w is for positions and for directions. When you want to multiply the vertex with a usually you convert it to a on the fly with . 

You can easily see, that in the top image, every number is really odd and i actually need a lot of additional code to calculate everything correctly (OpenGL-position -> heightmap-pixel and heightmap-pixel -> OpenGL-position). In the bottom image however, i am missing height-values for the right and the bottom row of vertices. I thought i could just use +1 pixel for every heightmap, this would solve this problem but i am sure it will introduce problems at other ends. How would you guys handle this? 

More or less. It does not have to act to input from players. Since it is a entity, things like take damage and so on are already working out of the box. It might do something special if someone casts spell xyz or it just has a set of possible actions and chooses one at random every once in a while. This depends on how you'd like the boss to act and react. 

No, you don't need to port forward the client. If the server runs on a home computer (behind a NAT) then yes, you need to port-forward the server or check out how udp-hole-punching works but if the server runs on a real server (a server you rent with a public ip-address) then it should work out of the box. Note though, the client, which is probably behind a nat, needs to send the first (and possibly a few more) UDP-packets to the server before the server can reach the client. Another thing to note: It doesn't matter on which port the client listens for UDP-packets (and on which port it sends), the server has to send it's packets back to the port which the receiving packets contain as sender-port, which is not necessarily the port the client listens on! For example: The client listens on port 5555 and therefore sends its packets from port 5555. The server also listens on port 5555 and sends its packets from port 5555. The client now sends a packet to the server to port 5555 but the server sees the packet coming from client_ip:45671. The server now needs to answer to port client_ip:45671, not to client_ip:5555 even though the client listens on port 5555! 

No, you can just ignore the fact that this happens. All you care is your normal coordinate system, everything else will be handled by your multiplication with your perspective matrix and by OpenGL itself. 

As stated in the comments, drawing points is as simple as drawing instead of , you'll need one vertex instead of three of course. Now to your non-structured input: Of course it is structured. It may not be in the format OpenGL expects, but it definitely has some sort of structure, some format you're able to parse. In case of a text-format containing lines of three integers, you have to first parse those lines to get your three integers in binary format since ASCII (and other charsets) means nothing to the computer. After this, i recommend converting it to floats. Since OpenGL expects the data in one contiguous stream of data (at least if you don't do any advanced things with glVertexAttribPointer) you need to one float after the other, 4 bytes each, 3 floats per vertex -> 12 bytes per vertex tightly packed without empty space between them. TLDR: Since you already know how to draw triangles or a cube (which itself is just built out of multiple triangles), you already know how the data looks OpenGL-expects and how to draw. So all you need to do now is convert your input data to the same format and draw your . 

If the indices start counting from 1, like the -format does it, you have to subtract 1 from every index. 

You can, however, not if you'r vertices use distinct UV's for each side. Your example is, well, not the best. To use indexed VBOs, you need a few more vertices. For example, take a look at this Picture (found in google): 

You're setting the position to the difference between the initial mousedown and the actual position. In this case, what you get is the expected result. What you rather should do is calculate the delta between the actual and the last mouse position and add this delta to the position: 

Sure it is. The Server is the decision-maker, the client is the one to nicely "show" the decisions the server made by drawing graphics. 

In this case you have to decide what to do. In most cases, this is done automatically for you because your sorting is based upon , , or where you definitely get an answer, either true or false, so it really depends which type of comparison you use. For example 

In your first run, you're taking , and , in your second run you're taking , and , see where the problem is? And i don't get why you're using , this makes no sense. 

You're wrong. OpenGL uses a right-handed coordinate-system where is right, is up and is into the camera, therefore is forwards. 

As stated in the comments, the real problem here is, that i need to calculate OpenGL-position -> heightmap-position and OpenGL-range -> heightmap-range fairly often to draw on the heightmap and the math gets really hard to handle with the mapping as seen in the top-image. 

I don't understand exactly what you mean with your last sentence, i hope i got it correct. Yes, thats a fixed timestep. 30hz means 30 updates per second, which gives us a timestep of 1/30 = 33.3 milliseconds per frame. The servers frequency doesn't really matter to better perform with latency issues, what matters is how you extrapolate and how you handle late-pakets. But, the frequency matters when you have a lot of players. The server might not be able to calculate 10000 * 60hz updates per second, but it might be able to calculate 10000 * 30hz. In a few cases you don't even need a frequency. With this I mean: you don't have a running game-loop in your server, but just handle the incoming packets and distribute them to the other clients. But this - again - depends on the game you write. 

I am building my world-editor for my game. I've noticed, that, no matter how i implement the heightmap, i'll end up with dumb odd numbers in calculations. For example, lets take a HeightMap of 4x4 which covers a area of 2x2 OpenGL-Units. Thats a small image which shows the problem. The black lines and numbers represent units in OpenGL, the red lines and numbers repesent pixel/values on my heightmap. 

Let me quick explain my actual setup: I use 2 Threads, one for networking and one for the main-loop (input, update, render). I have two synchronized queues, one for mainthread->networking and one for networking->mainthread. When a chunk of bytes arrives, the network-thread decodes a paket. The network-code knows, what each paket is and what it does. It now creates a functor to change the coordinates of an entity, to spawn a new one, or something else. It emplaces this functor in the queue and the main-tread executes every tick all the functors in the queue. This kinda works for now, but i think i have to change this completely. I might split up some parts of the main-thread, input for example, and stick it in another thread. Also, i might want to add support for plugins written in lua, python or some other language, and i don't want the main-thread to get stuck when the plugin decides to run a long-running task. This would mean, eventually the main thread has to handle a decent number of queues, one for every thread plus one extra for the other direction (thread->main). Also, at the moment, the networking needs to have all the pointers to the data-structures it wants to control (For example, it has a ptr to the entitymanager stored, so it can create a functor to spawn a new entity in the entitymanager), thats kinda weird. Are there common techniques to synchronize threads better? Especially since i have to provide a lot more control over the gamestate and still need to synchronize the other threads with the main-thread, i don't really see a better approach other then the functor-queue, so i hope for some suggestions. 

Apart from that, it is highly unlikely that you'll ever hit exactly 0.0 with floating-point arithmetic, unless you set it yourself, of course. 

Your problem is, you're applying all waypoints in the same frame, which makes the character appear at the last waypoint directly, without moving at all. What you have to do is take on waypoint per frame and move only this one step. Or, better yet, move a bit in direction of the first waypoint, then, if you're near enough, discard the first waypoint. Pseudo-Code: 

One more word about #1: If you're concerned about latency, don't be. Really, 4 characters spamming spells plus one boss is really so little, thats not even worth thinking about. Lets say your packet is 20 bytes and your cast takes half a second, thats 2 casts per second, per player plus the boss, so 10 casts per second so 200 incoming bytes for the clients and 800 bytes outgoing for the server per second. And if your server somehow batches state-updates, you could get away with far far less. 

The server does not really emit the action to the boss the same way as it is emitting this event to the other players, since the boss itself is serverside, so no networking between server<->boss involved. But yes, it works like this. But this emitting the action is not only done while boss-fighting, it is done everytime and everywhere when more than one player is in the same area, since all other players want to see what this one player does, everything. Walking, jumping, casting, .... And they want to see what other NPC-Characters do, so 4 players and one entity is really not much. 

No, control has the server. You could say, server itself plays the role of a client for its NPC's but the input doesn't come from a keyboard and a mouse, but from AI-Scripts, Waypoints, and so on. Your Client will only be controlling your own character, other clients control their characters and everything else is controlled by the server. 

You're mixing terms and techniques here, a 2D-Texture has no z-dimension. What you actually want for your normal-mapping is to fetch the texel from the image using the usual 2D texture-coordinates and use these color-values as a normal-vector. 

(i hope you don't count this as "a bunch") Another way would be to calculate the angle which would involve a arctan and that should be a lot slower than my approach. 

If you want a velocity of 800, you actually don't want x and y to add up to 800, you wan't the vectors length to be 800. If you already have the correct direction, you could normalize the vector, which would then be a unit-vector (length 1) and multiply this unit-vector by any scalar (number) you want to get the length you need, for example: