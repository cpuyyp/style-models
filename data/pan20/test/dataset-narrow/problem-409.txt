I have to apologize, I have changed my review as I wrote this due to some details I overlooked as I was writing. Thank you mjolka for pointing out my mistake. For multiple collections, the new implementations will always be a win over the aggregation. In the aggregated approach, each sub-instersection needs to be determined for every collection. In our new implementations, only a single set intersection needs to be maintained. The new implementations will not beat out the aggregate method in the single collection case however, because the aggregate will simply pass the collection through as the result untouched. The new implementations will always do some bit of processing. However again, I feel that if set semantics were preserved, this difference will probably be cancelled out anyway. 

It would be better to store your value as an integer as that is the "true" value that you're interested in. It's value is normalized using C semantics (i.e., if , otherwise as opposed to if , otherwise). That would feel more natural to me but it's up to you. I'd be careful with the operator overloading. Don't do it just because you can, do it because it makes sense. I'd stop at implementing casting operators from the type explicitly (since that's the only way to get at the value), use the constructors otherwise. And make only one of them an implicit cast, otherwise you will run into ambiguity errors if you use this a lot in your code. Consider implementing the interface and other appropriate overrides. If you intend to use this in your code, this could be invaluable. Consider implementing the interface explicitly. If you intend to use this type as you would any other in your code, you probably wouldn't want to see the serialization methods all the time. Otherwise if you are only using this for serialization, implement it implicitly. 

Consider this, suppose you wanted to get the control and invoke some method on it but didn't necessarily want to declare a variable for it. Well a "pre-casted" return type will be much better than casting yourself. Which would you prefer? 

Any time you have multiple independent boolean variables representing a state, consider using a bitfield through the use of an enum with the applied. That way you don't need to maintain multiple variables to represent a single state. 

Sequence Also, just because ruby is awesome, here is an iterator that generates a sequence of Fibonacci numbers for additional functional programming tricks. 

The name for this type of parsing is called the shunting yard algorithm. Your code itself seems fine, as long as you don't intend to support strings with curly braces, e.g. . The biggest issue I see is that it's not very ruby-like in the naming or formatting. I've made brief attempt at cleaning it up a little below. 

Copying the array You are over-complicating the array copy. will copy the objects of the array (but not the object's objects). Using it on array of objects might be problematical, but an array of ints will be fine. 

Some Notes The RunWorkerCompleted event may run on the background thread (or you may get errors about it) and we don't want that. First, any updates to the UI, like updating the progress after a block is written, have to happen on the main UI thread. Secondly, we don't want multiple threads trying to write to the output file at the same time. There is a simple trick to get the RunWorkCompleted event to run on the main UI thread. 

For each word you process, get the unique/distinct list of characters (for example, by throwing it into a set). When checking for matches, you will now be checking against a much smaller list of corpas, which should speed things up a little 

Theoretical Code Evaluation Let's do some math to see how many operations you are doing. I'm going to use as my variable for whatever value you assigned to You have a loop that for every multiple of , it does modulus tests. For , the correct answer is 2520, so we can calculate that you code did For the correct answer is 360360, which is also the same number of operations performed. This doesn't seem too bad. However you are also calling every iteration. If you look at the source code for this, it loops through every value in the hash. This means that in the first iteration, the hash has one value and this is one operation. In the second iteration hash has two values (requiring two operations) but now we've done a total of three operations between the first and second iteration. In the third iteration there are three operations which makes for a combined total of 6 operations. After the fourth iteration we've done a total of 10 operations. This is a series of the sum of natural numbers and the formula for it is: 

On a side note, I would move the null and positive id checks into your "checkId" method. In fact, I think in this case, these checks are redundant and unnecessary. You're just checking if an id is in an existing list that you're maintaining. If it's , it's unlikely it will exist in the list (if you are preventing arbitrary values from being added). An id outside of the range of expected values will just not be in the list in the first place and therefore is unneeded as well. But, if you must perform these checks, do it within the method instead. 

And to a lesser degree, a call to with parameters should be printed a single line at a time. The newline characters sprinkled in the format string makes it less clear how many lines this will print out. Do this: 

Then you could map these board states to the appropriate game state. Just make sure you map out every valid combination if you plan on using a dictionary. 

There are many improvements to be made. If you think of the months as indexes, it will simplify everything. You shouldn't have to loop n times just to figure out what the n'th month is after January, a simple addition should be enough. By doing this, this will allow you to remove many of the redundant operations that you currently have. First let's start with the extensions: 

This looks a lot cleaner to me. Should also showcase how much more helpful it is when you give more descriptive names to your variables. 

You could also condense the conditions a bit if you recognize that values of are considered and non-zero is . You're testing if they're equal to so you could just write it as 

You could make it a little bit more useful if you added some supporting factory methods to create the arguments. That way you don't have to use the constructor and its somewhat awkward syntax (having to supply the types). 

I hope you'd say the generic version is better. With a cast, you are required to wrap in parentheses due to the lower precedence. If you have the opportunity to return the most appropriate type (statically or generically), try to make it happen. Having to perform a cast on the result of a method call is a sign of a problem nowadays IMHO. It's almost as bad as returning type . Casting is ugly. This is one of the reasons I'd imagine why there are extension methods on existing objects that does something similar. and come to mind which allows you to read or write a column in a data row. 

I think you can add functionality to to make the common ancestor search more ruby like. (I can add a search by value later, if you want.) I've added a parent member that is set automatically, and I've added and enumerators to enable easy traversal up or down the tree. Note: Thinking about it, the search function needs a little more work in case node 2 is higher in the tree than node 1, but I am out of time right now. Let me know what you think. Testing indicates that this is not an issue. 

Function Wrapping Here is an alternative implementation, just for contrast with the other solutions. It needs a little work to be more robust, but the concept is clear. This version wraps the target method with a new method that checks the arguments. If all are nil then the default value is returned, otherwise the arguments are passed to the inner method. This approach's benefits include being purely functional and not being limited to just mapping; it could be used on any method. The disadvantage is that usage is somewhat ugly and not as ruby-like as one might wish. 

The reason is that transform is a instance method of , which is why you need to convert back into an image before calling it. There are a couple of way this can be handled. I've chosen to make a static method that only works on arrays. The instance methods and call the static method as needed 

If you can't do that, when you start the new thread, try setting the thread priority to low or tweaking other related settings. 

Set Unions Looking at your code, when you loop through the attrs, you are breaking after you find the first key that is in and in and in the passed . This is also known as the of the arrays. As such you can simplify the inner loop with: 

Additional Thoughts As janos mentioned, your program has several usability issues. While I've cleaned it up some a little and added better input validation, there is still a lot to be desired. Making the user enter coordinates, especially without adding row and column headers is hard on the user. It would be better to either add headers, or even better, add a guide with numbers and letters off to the side. For example: