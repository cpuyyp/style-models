When – and why – should one be used over the other. Sometimes: element.value = "Fred"; works and sometimes element.innerHTML = "Fred"; works how come? 

There are things I much prefer in Outlook Express to Windows Live Mail: one of those things is the ability to create a Mail Rule whilst viewing a message. You would simply do so andthe new rule would be created with the dialog box and all of its options/values filled in appropriately. Am I simply missing this or did this ability simply not make the cut? Ross 

How can I increase the font size for Windows Live Mail under Windows 8? I've tried everything I can think of! 

I recently used Defraggler to consolidate my free space areas on my D: drive preparatory to using Disk Manager to break my drive into two areas, one as my "data area" for Windows 7 (normally on my C: drive) and to experiment around with Windows 8. The Defraggler program works so well I ran it on my C: drive and I ended up with a lot of free space both on my C: drive and my D: drive. I was very happy. And then I woke up the next day and I've got virtually no free space left, something like 8 MB on my C: drive and about 3 GB on my D: drive. I then ran Wintree (which gives a nifty graphical representation of disk usage) and found I had a large page file and a large hiberfil. So I temporarily turned off hibernate and reduced the page file size to 2000megabytes and then rebooted so that both would take effect. It had no effect on the C: drive or the D: drive. That makes no sense to me. What caused the free space on each drive to disappear, why doesn't the page file size being reduced and the hibernate file being turned off free up disk space to either the C: or the D: drive? Would it make sense to delete the two files in question and, if so, how do I go about doing that? Safe mode? Thanks. Ross 

There's a lot of layers to this. And importantly, many of them are interchangeable. For example, you can have a coax-cable network, an ethernet, or a Wi-Fi down at the physical level. HTTP works on top of all of those, but each of them has a slightly different handling of the payload being sent around. HTTP works on top of another protocol, called TCP, which in turn more or less runs on top of yet another protocol, called IP (nowadays mostly in two variants - IPv4 and IPv6). So the HTTP server registers an IP address (like , or most often "any"), along with a TCP port ( being the default for HTTP, but in general anything from to ), with the operating system. Now, the HTTP server tells the OS to ping it when data (or another message) comes. The OS knows when that happens, because the network interface card driver tells it that. And the NIC driver is told by the NIC itself, which actually has its own software to interpret the electrical signals on the network cable (or the wireless signals in the air etc., you get the idea). Side note: If you want to know more about how the NIC can initiate communication with the driver / OS, you might want to lookup some basic info on hardware interrupts - basically, whatever the CPU is currently doing is stopped, and the program flow switches to an interrupt handler routine - an extremely simple piece of code that takes care of notifying the system, and then immediately returns control back to the original thing the CPU was doing. In fact, it might answer you a lot of questions about the inner workings of the OS and the computer itself - like how an operating system can "steal" CPU from running applications and shuffle the CPU resources between different applications running at the same time, even if they do not coöperate. Back to business: In your manual telephone analogy, imagine that your phone doesn't actually ring. To know if you're having a phone call attempt, you'll have to look at the screen periodically and check. To make this easier to manage for the HTTP server (since there's already quite a few layers who do that periodical check), you can actually block on the check attempt. So instead of checking, seeing there's nothing there and checking again, you basically keep looking at the screen all the time. However, you've basically got a whole separate system for handling this (in your case, the hearing center, which checks the air vibrations for useful information, the ring), so it doesn't actually require your attention (CPU time). This is further improved by techniques that allow you to monitor many connections at once (IOCP). This gets closer and closer to the phone ring system - you have a room with ten thousand phones, but you only care about those that are ringing at the moment, the others aren't taking any of your attention. 

With a lot of traveling to various hotels with free Wi-Fi I have collected a number of sites in the system tray when I clicked on the network icon. I doubt highly that I will return to these hotels and so the various sites will not be needed again. How do I remove the sites – where are they even stored? I went browsing through the registry and could not find them. (Were talking about 25-35 sites I want to blow away) any ideas/suggestions? Thank you. Ross 

after running Netflix for the first time I am unable to listen to two of my favorite stations: $URL$ and $URL$ – although Internet Explorer has no problem playing either of those two radio stations. Firefox has no problem, however, playing Netflix – the sound comes through like a champ. Any suggestions? (I have downloaded a new Firefox and have downloaded a new Flash player – no difference, the same problem) 

When listening to a radio station, such as $URL$ sometimes after a while I get a modal error box with a "Stream Playback Error"allowing only an OK response. What causes this and how can I fix/repair it? Ross 

I ran an SFC on my system and it tells me that there were some "Integrity Violations" and to see the log file for more details. So I was able to open it up in Notepad, but I have no idea what I'm looking at. Anybody have an idea? Ross 

If you don't feel too bad about some guessing, let me offer an explanation. And I don't mean "someone set the value to nonsense", that's obviously always possible :) Unix time usually uses the number of seconds since 1970. Windows, on the other hand, uses 1601 as its starting year. So if we assume (and that's a big assumption!) that the problem is wrong conversion between the two times, we can imagine that the date that was supposed to be represented is actually sometime in 2011 (1970 + 41), which got incorrectly converted to 1640 (1601 + 41). EDIT: Actually, I made a mistake in the Windows starting year. It's possible that the actual creation time was in 2010, or that there was another error involved (off-by-one errors are pretty common in software :D). Given that this year happens to be another of the tracking dates associated with the file in question, I think it's a pretty plausible explanation :) 

First, this has nothing to do with RAM, really. We're talking about address space here - even if you only have 16 MiB of memory, you still have the full 32 bits of address space on a 32-bit CPU. This already answers your first question, really - at the time this was designed, real world PCs had nowhere near the full 4 GiB of memory; they were more in the range of 1-16 MiB of memory. The address space was, for all intents and purposes, free. Now, why 0xFFFFFFF0 exactly? The CPU doesn't know how much of the BIOS there is. Some BIOSes may only take a few kilobytes, while others may take full megabytes of memory - and I'm not even getting into the various optional RAMs. The CPU must be hardwired to some address to start on - there's noöne to configure the CPU. But this is only a mapping of the address space - the address is mapped directly into the BIOS ROM chip (yes, this means you don't get access to the full 4 GiB of RAM at this point if you do have that many - but that isn't anything special, many devices require their own range in address space). On a 32-bit CPU, this address gives you full 16 bytes to do the very basic initialization - which is enough to setup your segments and, if needed, address mode (remember, x86 boots in 16-bit real mode - the address space isn't flat) and do a jump to the real boot "procedure". At this point, you don't use RAM at all - it's all just mapped ROM. In fact, RAM isn't even ready to be used at this point - that's one of the jobs of the BIOS POST! Now, you might be thinking - how does a 16-bit real mode access the address 0xFFFFFFF0? Sure, there's segments, so you have 20-bit address space, but that still isn't good enough. Well, there's a trick to it - the 12 high bits of the address are set until you execute your first long jump, giving you access to the high address space (while rejecting access to anything lower than 0xFFF00000 - until you execute a long jump). All this are the things that are mostly hidden from programmers (not to mention users) on modern operating systems. You usually don't have any access to anything so low level - some things are already beyond salvage (you can't switch CPU modes willy-nilly), some are exclusively handled by the OS kernel. So a nicer view comes from old-school coding on MS DOS. Another typical example of device memory being directly mapped to address space is direct access to video memory. For example, if you wanted to write text to the display fast, you wrote directly to address (plus offset - in 80x25 text mode, this meant if my memory serves me right - two bytes per character, line by line). If you wanted to draw pixel-by-pixel, you used a graphics mode and the start address of (typically, 320x200 at 8 bits per pixel). Doing anything high-performance usually meant diving into device manuals, to figure out how to access them directly. This survives to this day - it's just hidden. On Windows, you can see the memory addresses mapped to devices in the Device manager - just open properties of something like your network card, go to the Resources tab - all the Memory Range items are mappings from device memory to your main address space. And on 32-bit, you'll see that most of those devices are mapped above the 2 GiB (later 3 GiB) mark - again, to minimize conflicts with user-useable memory, though this is not really an issue with virtual memory (applications don't get anywhere near the real, hardware address space - they have their own virtualized chunk of memory, which might be mapped to RAM, ROM, devices or the page file, for example). As for the stack, well, it should help to understand that by default, stack grows from the top. So if you do a , the new stack pointer will be at - in other words, you're not trying to write to the BIOS init address :) Which of course means that the BIOS init routines can use the stack safely, before remapping it somewhere more useful. In old-school programming, before paging became the de facto default, the stack usually started on the end of RAM, and "stack overflow" happened when you started overwriting your application memory. Memory protection changed a lot of this, but in general, it maintains backwards compatibility as much as possible - note how even the most modern x86-64 CPU can still boot MS DOS 5 - or how Windows can still run many DOS applications that have no idea about paging. 

I have been a happy user of AutoHotKey for over a year. Not a problem. Ever. Until about two weeks ago. Sometimes after I run it, it doesn't function at all. No error message or anything it just doesn't work. When that occurs I run it again. Sometimes that fixes the problem, sometimes it doesn't. Here's the script that I use: Ins::^numpadadd Del::^numpadsub So when you hit the insert it gives a control plus, likewise when you hit the delete key it gives a control minus; basically to enlarge or decrease the stuff displayed on the screen. The even funkier problem: when this problem manifests itself hitting the control key with the plus or minus works as expected. No software has been installed or uninstalled nor have any substantial updates been made. Does anyone have any idea of what the problem may be and how to fix it? Thanks! Ross 

I have an external hard drive, attached to a USB port, that used to format to about 700 gigs. I use Acronis to make nightly backups of my C: drive, my system drive. Suddenly my log file showed that there wasn't enough room on the USB drive to make a copy – I make a copy that replaces last night's copy. It has worked flawlessly for at least two or three years. When I went to reformat the drive it reformats but only to 41 GB! I tried using Manage Disks and it, too, only allows for a reformat to 41 GB. what is wrong and how do I fix it? Thanks. Ross