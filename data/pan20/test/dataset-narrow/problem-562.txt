The .aspx portion is very simple. DatabaseChecker.aspx simply has a button to begin the process, and it has Processing embedded as an iframe. The result looks like this: 

As you can see, my web application is broken up into different layers which makes organization a breeze. But, I feel that currently I'm not utilizing the power of layers --- the logic layer does nothing at all but just forward the calls to the DB layer. I think part of my problem is that I simply don't know what I CAN do that is useful. Currently my system works and my goals are achieved. Some people might say, "then what's the problem?" And while that makes me happy (it means I've done my job with some degree of success, horray), I want to know more advanced techniques. In the article I originally linked to above, it uses the example of checking roles in the logic layer. In my case, I don't need to do that. We're checking roles pretty much on every action the user takes at the page level. If I can't figure out something else useful to do at the logic layer, I am thinking about cutting out the logic layer all together, since all it does is forward calls anyway. This would eliminate some .cs files and make it even easier to navigate/maintain. Ideas, thoughts? What can I do better? What has worked for you? Are there any things related to layered web applications that you know now that you wish you knew when you first started? 

I like to use something very similar to what is here referred to as Roy Osherove's test naming convention, the difference being the order of the parts: 

Apart from what's already been said you should consider your test suite a bit more (I'm assuming you're using NUnit in pretty recent version). Apply DRY to the tests You have two more or less identical lines in all tests: 

Declare the calculator instance as a field in the fixture instead, and initialize in a method. There's also the duplication of . In this specific case I might go as far as to get rid of entirely: 

Now this is something I've looked into, and while I have a "working" solution, I don't like it. Background: Through our intranet website, we want to run a process that copies a file from another machine, unzips it, and then analyzes the content. As the file is large, this takes some time (usually around 5-6 minutes). Rather than have the user just hit a Button and pray that they get a success message in 5-6 minutes, we want to show the progress via updates to a TextBox. What I've learned so far: This isn't as simple as putting everything into an UpdatePanel and updating it at various steps in the process. Seems like it would be, but it's not. I looked into threading as well, but I couldn't get it working. That is to say, I got the process to run on a separate thread, but while it was running, the interface wouldn't update. It would queue up everything, and then display it all at once, once the process finished. As I'm still relatively new, the possibility that I was just doing something wrong is high. What I have (which works, I guess...): Two .aspx pages, DatabaseChecker.aspx and Processing.aspx DatabaseChecker.aspx: 

This avoids the higher coupling (inheritance) between the dictionary and its subclass, which is there only to help with initializing the dictionary. 

The above interface hides the details while allowing polymorphism; you could e.g. keep the "vtable" implementation (but hidden) and provide different init-functions. I really don't follow all that macro voodoo but having a mutable shared state - the "pointer to current class" - seems susceptible to race conditions. 

Remove unneeded attributes You don't need to use the attribute. Marking individual methods with or one of the attributes is sufficient. Also, using when is present is redundant. Here's an excerpt from the refactored, and somewhat reformatted, tests: 

First off, let me say that this article pretty much changed how I program, for the better. Until I read this article, I was a spaghetti programming master --- if there were awards for crappiest, least organized, and impossible to read programming, I would have been world champion. But that article taught me to utilize classes (mind-blowing, I know), rather than just copy/paste the same logic around to the necessary pages. With that in mind, I modeled my application (described below) on the examples found in that article. I highly recommend that article for anyone else who's looking to make the jump from newb coding via facerolling on the keyboard to newb coding with some thought behind it. I've been simultaneously building upon and maintaining this web application for a year now, and I feel that while the layered approach has helped me to stay more organized, I'm not utilizing very much (if any) extra power from having layers. In my web application Project, I have a folder I created called Classes. The structure looks like this: 

I would actually avoid the attempt to mimic C++ syntax. It makes things more complex and exposes unnecessary details. For me it would be equally object-oriented with the following C interface: 

I would actually recommend you to use the (Constructor) Builder pattern if you are only doing this for easier object initialization: 

Try reading the code out loud for yourself for each of the samples above. Further adding a few line breaks to the latest version makes it a bit easier to visually separate what you're testing from the expected result, but that's a very personal opinion. See refactored example below. Don't use SUT literally As others have already said, don't use as a variable name. Sure, you might know the context and be familiar with the acronym but I still consider to be more expressive than . One circumstance where you could use e.g. as a variable name is where you have a very generic test suite that can be reused for many implementations. However, even then I would strongly suggest that you name the variable referring to the SUT according to what kind of capabilities being tested within that specific suite. A short example: 

The TextBox1 in Processing.aspx is where the progress update goes. Now let me just point out the dirty trick and the part I don't like right now. In Processing.aspx, there is a meta tag to refresh the page once per second. How it works (summary): When the process starts, a Session variable called ["Running"] is set to true. When the process ends, Session["Running"] is set to false. And since Processing.aspx refreshes once per second, what happens is it saves the current contents of TextBox1.Text to another Session variable called ["TextBoxContent"]. And then the Page_Load method for Processing.aspx fills the TextBox back up with the previous content, and adds a period. So the output will begin simply looking like "Process Starting", but after 10 seconds it will look like "Process Starting.........." (one period per second). How it works (details): The process begins in DatabaseChecker.aspx's Execute button: 

The main reason for this reordering of the parts is readability of the test names; I think it reads more naturally when in this order. Try comparing these two variations of naming the same test by reading their names out loud: 

There nothing wrong with the code per se. I'd still prefer to have the error return statement inside the catch block to keep it close to where the condition is detected. I would also move the success return statement to the end of the method: 

Start with writing unit and/or feature tests that capture the current behaviour. Then begin refactoring while making sure that the tests pass all the time. If you are not an experienced developer "refactoring" might be a bit vague; I'd then suggest to simply start with removing duplication in whatever form there is. Aleksi had a couple of examples of extracting methods. Start there. As you move stuff to methods you will soon see that there are different categories of methods that are used together. This is an indication that these should be moved to a separate classes to encapsulate that behaviour. Then read about the SOLID principles and continue from there. Practice, practice, practice and think about what you are doing at all times. Good luck! 

Once again, very abbreviated here. I am aware of auto-implemented properties in C#, I just chose to manually implement them. Upon Object instantiation, I set everything to null. It is easier to check for null than to check for "empty" or "zero" values, in my opinion. This way when it comes time to validate an object before saving it to a database, it's very black and white --- if any field that does not allow nulls in the database is found to be null, throw an error, else continue on to save. Next up, here's what a Manager (Logic) class looks like: