I should start by saying that the game is quite interesting, and for a beginner the code is good, but of course there is plenty of room for improvement. Small details You have many small things that may a bit odd or unnecessary even, such as: 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

Refactoring When you see yourself doing the same thing many times, it is time to think again and try to refactor that part because there certainly is a better way. You have very few code that represents repeated logic, but lets take a look at the function: 

I'm not going to go deep into variables and functions names since @Blindman67 already covered them. But i still can't help but mention them again. They are far more important than they look, and you haven't picked them properly. Take your time picking them, it's definitely worth it. 

Which makes it super compact and easy to read. Objects One downside of the way you have your code structured is that you have multiple global variables. This creates difficulties in managing state and also opens the possibility of colliding with already existing global variables. Those may either be from the object or even some other plugin/library that gets included up top. All the game logic can be moved into one or multiple objects/classes, which helps you separating it from the presentation in the page. Sure you can consider this a bit too much for a such a simple game but it's definitely a way to improve especially if you want to keep adding features. As a first step you could consider the following approach: 

Note how i used instead of . With ES6 you now have both and as other ways of declaring variables. In this case i know i don't want to change or , and with it will give me an error if i accidentally change them. This builds on writing defensive code that gives you errors sooner rather than later. The itself can also be shortened with an Arrow Function: 

As pointed out by @Zeta in the comments if the color to be inverted is a gray very close to the middle, the inversion will generate a similar color which may not be easy to read. You can try to avoid this by manually checking the difference of all channels to their inverted versions, and if all of them are bellow a certain threshold generate a different color. A simple approach to this would be to generate black if all channels are closer to white and white otherwise. There are also some libraries/micro-libraries that generate colors and their complementary versions with other approaches, such as using HSL. These may be interesting for you to take a look. Here are some of them for reference: 

I'm not trying to be too critical of your variable naming but I do have to be for completionism and for other future Robot Framework users looking for how to write readable code. Because (it appears) that you're using the Python version of Robot Framework, I'd say it's good practice to keep to the Python convention of naming variables, which is for local variables or for global variables and index variables in loops. Also, shorter, more descriptive variable names are perfectly acceptable for this size of program. Re-written for that, your variables should be , , , , , and . Mechanically, I'm assuming it works fine as-written, but there's a few optimization problems. First, having a custom keyword for a single action is usually redundant (unless you want to simplify a repeated action with a lot of parameters to a single word for readability), so you could re-write your For loop as follows (using the re-formatted variables): 

That makes the keyword unnecessary, making your code easier to maintain. Finally, as another good practice, Selenium2Library is outdated. You'll need to download it separately, but ExtendedSelenium2Library is more robust, contains more keywords, and includes code to deal with Angular applications. The final code after formatting and optimization looks like this (I also took some liberties on comments that are either unnecessary or too wordy for what they describe): 

I'm implementing things in Robot Framework that it does not support by default, including nestable For Loops and, now, While Loops. I'm looking for readability, algorithm, methodology, and/or performance suggestions. The While Loop is not as advanced as the For loop is yet. I'm eventually looking to implement nesting the While Loop and breaking it on a command, but at present it will take any Robot Framework variable (assuming it's an integer) and loop until it reaches the specified breaking point. The custom keyword Increment plays the part of a line of internal code incrementing the value by a specified number. At present, Increment only supports and with any integer, but I can easily make it support and for more advanced increments. The following code works, but as (still) a relative novice in Python I don't know all the tricks that could be used to optimize this loop structure and logic. The general idea, for those who have not read my other two RobotNest posts, is to allow the user to write nestable For and While loops in Robot Framework. My basic methodology is as follows: 

The function actually parses the coeficients for each degree term. I won't dive too deep in to this one, but i'll start saying that you do a lot of . And many of them are almost identical, being not only inefficient as well as confusing. Consider this one for example: 

When we look closely to we can see that the code is barely the same, except for the very final returned root. So this leans towards repeated logic and creates all sort of problems. In this case it also makes your code less efficient because you repeat some part of calculations. Better would be to restructure your to return an array with both roots. 

There is a similar question that you may want to take a look at for some extra insight, even thought it doesn't have the contrasting color feature: JavaScript Random Color Generator Now lets get to the review. Naming 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

While the whole code would now be longer, as you would have to manage both the page visual elements as well as the logic itself, it would also be more modular, organized and easier to maintain or add functionalities. It would still be necessary for some other function to call the game functions and update the corresponding page elements depending on the game state. A more modern way of doing what i did above is using ES6 classes: 

Don't need to be separated in such a simple statement, regardless whether you use destructuring or not. You can directly do: 

Both first blocks have the exact value you are looking for and will always be an empty because there is nothing to the left. Thus it won't affect the result at all. So you can drop the altogether, and adjust the appropriately. Personally i feel you must rethink your logic a bit on this one. Restating @Blindman67, you should take spaces into consideration to make the structure less rigid. On a simpler level you can strip down the spaces before parsing: 

Given one of the main highlights of Robot Framework is readability, I'll show my suggestions to improve that first and then go into my mechanical suggestions. First, good readability practice in Robot Framework is to line up your cells by tabs (or sets of four characters depending on your IDE) and capitalize each word of your keyword uses. So, your code as sent would look like this. 

This methodology seems very inefficient to me. By the end of the program, I've looped through my list of keywords once statically and around 4 or 5 for every iteration of the loop itself. This is why I'm looking for algorithm suggestions. In addition, I'd like to get away from using to delineate lines, but unless I figure out how the compiler takes Robot Framework's code and says "this is what it equates to in Python", that probably won't be happening. Here's my code as it currently stands: 

Language: Python 2.7.13, Robot Framework 3.0.2 (Python 2.7.13 on win32) Dependencies: BuiltIn Library, ExtendedSelenium2Library 

A common feature of basic loops is the functionality, allowing the user to specify break points for their loop to stop. I've been creating a keyword to enable nesting loops in Robot Framework. This Nestable For Loop for Robot Framework includes the functionality. The basic code for a nestable Robot Framework For Loop is located here. This is a strict upgrade, in that it includes the functionality in the form of the keyword . requires a single argument: a Boolean expression written in a string. includes two methods to work with this kind of expression: and . returns True if the expression is a Boolean string (including unsupported Boolean expressions), and returns if the expression would logically evaluate to . Because the nature of this code is to be nestable, I need it to be as fast and efficient as possible, so I'm looking for performance and algorithm-based suggestions. 

I don't currently have the code available to me, so I don't feel comfortable investigating the dictionary or sub-functions, but that's the result of the small optimizations suggested. It already looks much cleaner and shorter, at least on the bottom half. EDIT: After more editing, I've transferred everything over to an array-style implementation, further shortened some of the logic, and divided the code into sub-methods. Still interested in any further optimization suggestions anyone might have.