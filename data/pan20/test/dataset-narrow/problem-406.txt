First of all, your given sample features zero-padded 2-digit months and milliseconds which you currently don't reproduce. The mentioned 'smell' is probably caused by 

Filtering your operands with leads to strange effects such as returning for inputs with a zero such as and returning for input . Parsing: Instead of I recommend using the unary plus operator which is "the fastest and preferred way of converting something into a number" according to MDN. To split an expression into operands and operator, I recommend using robust regular expressions. A regular expression makes it much easier to understand which input strings will be accepted as valid and which input strings will be rejected. Implementation: First, the available operations are declared. Then, the input is parsed. For valid input, the result of the operation is returned. For invalid (non-matching) input, is returned: 

Unfortunately this can sometimes look a bit strange using , etc. but in Kotlin 1.1 you can use bound callable references: 

You can still use a enum if you'd like but this function is very similar to so would seem to suffice. Every enum class has a function implementing (Enum Classes - Kotlin Programming Language). As such, would declare both and which seems confusing to me. I suggest defining superior and inferior check functions instead of but this may not be practical depending on how you are using : 

which will avoid creating an intermediary list (small optimization in this case). Perhaps a minor issue but I personally prefer using "index" instead of "i" or "idx" to avoid any ambiguity. "idx" actually has several meanings. I find used with to often be more readable than combined with : 

Now, it is much easier to see that the inner loop is actually just checking the existence of an element within an array. You can use the faster built-in method instead: 

Enhancements: You might want to listen to the "blur" event and deactivate the dropdown when its focus is transferred to an outside element. 

As already pointed out, you need a more sophisticated approach to testing runtime performance of runtime-optimized code produced by modern JavaScript engines. I compared the performance of your datastructure against the built-in as well as plain objects on the well-known performance testing playground jsperf.com based on the benchmark.js library and got the following results on Firefox 53 / Ubuntu: 

Now, we re-introduce the matches against team wherever a team would have to play against itself (the red squares). We also have to fix the opponents of team to reflect these changes. This practically means that for each round we swap with where denotes the self-matched team (the red square): 

I wouldn't use or because it makes it appear that can be greater than which is not true. I recommend using . 

If however you actually need/want classes for tree components then I recommend making those components (or collections of those components) members of a class (e.g. a has ). 

In some languages variable names like are common and expected but in Kotlin (and Java) I find it more common and expected to have variables names avoid abbreviations, use camel casing, etc. I recommend using instead of . You are returning a . This is fine but data classes are so much better and Kotlin makes it so easy to define and use them. I recommend creating your own type to return. e.g.: 

Sometimes in Kotlin you don't have to declare temporary variables so that you can do something with a return value before returning it. e.g.: 

This allows you to replace with the more readable . Default properties: There is a pretty common technique used to handle default values of object properties. Replace 

Style Your code is pretty readable already. But you mix and . I prefer consistent style. Also, you use a function expression instead of a function declaration - there are subtle differences, but it's mostly a matter of personal preference. To me, the function declaration seems simpler. Runtime complexity Your main issue is performing full array searches via (in linear time) within the inner loop. By using an alternative data structure such as a simple object , a or a which complete such lookups much faster (in constant time), your performance will improve drastically for large inputs. You can also get rid of the final by mapping numbers to their indices. This doesn't improve theoretical runtime complexity, but still improves performance. The same holds for breaking out of the loop early as soon as a solution is found. Implementation 

However, the "problem" specified in LeetCode does not use arrays which are very different from linked lists. If you convert the Java code it provides you would get the following: 

In my opinion, the main factor in preventing you from having a clean primary constructor is indeed the two paths to the super class (via or ) and having a super class define the property is in fact what also prevents you from making this a data class. I recommend making an or with no properties in its constructor. e.g.: 

For determining correctness of your implementation I recommend referring to an existing implementation such as Apache commons-lang or the newer commons-text: 

Personally I prefer "row/column" instead of "y/x". Thinking "y" before "x" is unnatural. You can always define your own methods too which can improve readability. e.g.: 

Since the best-case runtime complexity did not change, we only see minor performance improvements. The runtime is dominated by parsing speed. Worst case - input queries repeated 

Your solution is a bit wasteful by generating and testing all integers in the desired range while you actually only need a handful of them. A big improvement in terms of performance is to avoid modulo arithmetic and increase the step-size tenfold whenever you finished iterating a sub-range 1-9, 10-99, 100-999 and so on: 

You asked what happens when you don't initialize in the loop body? Initially you create a single array instance . Then, during each loop iteration, you modify the content of this array and push it onto . So in the end, each index of contains a reference to the same array, similar to this: 

Using returns a new object but such isn't necessary in this case. You can use directly on the . You can reduce duplicated code by using classes and/or extension functions. e.g.: 

If you are going to have classes for computed numbers than I find (like ) much more readable than for , , etc. Naming an instance of as simply "tree" is rather confusing, I recommend using type names (at least the end of them) at the end of instance names (e.g. "stageTreeWidth", "stageWidth", "treeWidth", or simply "width"). Kotlin has a neat function to simplify building strings with a repeated char sequence. e.g.: 

"args" is more common and descriptive than "a" in a function signature "\n" is system-dependent; I recommend using instead can be used with a instead of first mapping an using a and then calling . e.g.: 

Style Instead of I suggest the more self-documenting as the length can never be negative. Also, don't needlessly mix vs. for strings. Specification Right now you are returning a distance of when there is no path and a distance of if equals . I suggest following the common definition of path length and return and instead. You might also want to pass the alphabet as a parameter instead of having a hard-coded 'magic' constant in your function. It can easily be computed from your dictionary as . Also, you currently allow any word for while must be part of the dictionary. I recommend allowing non-dictionary words in both cases for consistency. Performance Your main performance bottleneck is the function. If you keep track of a set of open words which you haven't visited yet, you can replace that function call with a simple . Set lookup time is constant and thus much faster than iterating the whole array. You then have to pass the set to . The map is no longer needed. Another performance drain is performing string splitting via in the inner loop of . You can push that to the outer loop. Also, you currently treat as a special 'shortcut' case. You could generalize this to . Sample code Applying all those modifications to your code yields: 

And you can even pre-compute the required capacity to avoid unnecessary array copying while building the string: 

Kotlin already guarantees that and are not as you've used for their type instead of . As such, the statements are unnecessary. I do not believe you gain much from and . and read clearly and are read in constant time so the additional variables seem unnecessary to me. You can place the last lambda argument in a function call into parentheses as you have done but I personally find moving it out of the parentheses easier to read and more idiomatic: 

Technically a "trunk" does not include the branches, etc. so "TrunkWidth" and "Trunk" are kind of confusing names for this. You might consider "LayerWidth" and "Layer". I see very little point to all these classes as they do not serve much purpose. A class with a single method to define its single behavior might as well be a method. If , , , etc. will be used by methods other than then it might make sense to have these as classes. If they are simply to build a string representation then I would drop them in favor of inline calculations (OOP does not mean that "every thing is a small object"; e.g. "height" and "width" may be attributes of objects but are not necessarily objects themselves). This entire collection of classes can be reduced to the following (assuming no other code is using , , etc.): 

A function declaration is a bit simpler and more robust regarding hoisting compared to a function expression which assigns an anonymous function to a variable. Supplying as the first callback parameter on success is a bit quirky, either always supply the HTTP status or fail silently without calling the callback. If needed you can always introduce an error callback which might be called on , too. The parameter of xhr.open defaults to and can be removed Your function could be split into a generic function and a function which supplies the specific ad URL to the former. Your current callback requires knowledge about the specific JSON returned by your ad server. This logic should be part of your "rw-ads.js" library and e.g. become part of the new function. 

However, unless your will have additional properties later on, a simple instead of a class will do the job just fine. Instance properties and side effects: Within your calculate method, you create new instance properties such as , and holding the result of the calculation. This is called a side effect. Pure functions without such side effects are easier to understand and debug. Also, those property names are not very descriptive. Consistency: For different inputs, the values of and the return values of are inconsistent: