If your 2811 is providing the phone services for your Cisco IP Phones at this site, finding the IP Address of the 2811 is relatively easy: 

Unfortunately, Cisco has not given us a precise, one-line way to remove a single object or object-group. This is something that may come in time as the ASA code continues to mature and the ASA's themselves get more CPU resources. The original ASA line was pathetically underpowered in the CPU department. Your 5505, for example, was first released in 2006 and has a ! An intelligent, recursive search through the configuration to remove an object or object-group would require CPU resources that just weren't there when the software was being written. Especially not if they had to come at the cost of processing traffic. I work daily on ASAs with thousands of objects and and tens of thousands of ACL lines, and I wish for this feature every day. For now we're left with a manual search process, similar to what I demonstrate below. This process can certainly be automated in Python, for example, however I give the manual process to illustrate the logic involved. 

First and foremost, I must indicate that I am mostly active on the IT Security StackExchange website. Since this current website may reach a different public I find it wiser to tell that, while I adopt the point of view of a potential attacker, all information in this post is given only for educational purposes, in particular in order to understand the concrete threats that are affecting networks beyond myths and oversimplified discourses. I do not encourage nor do I approve the use of the methods described below on any unauthorized network (and I really mean it: if you want to learn get GNS3, that's what this whole thread is about :) !). Sorry for the length of this answer, but despite my researches I did not manage to find any satisfying resource on the web on this topic. Most "proof-of-concepts" are biased either by stopping at the CAM table being filled step and assuming but never really demonstrating the switch reaction, or by using some artificial tricks like clearing the switch MAC table before flooding. My goal here is to provide concrete steps suitable both for simulated and real environments, focusing on the issues related to GNS3 virtualization and common wrong approaches, and most importantly to provide sufficient background information to understand why things are the way they are. 

Notes: This testing was done with the following configuration, so your milage might vary with a different terminal emulator, different router, etc: 

Have you taken a look at the OID in the RFC1213-MIB? (OID number 1.3.6.1.2.1.4.21) I utilize this to pull the routing table out of several devices. It is referenced by RFC 1213 which, on page 33, gives the following information: 

EDIT: Clarifying the below solution description per @fredpbaker's comments. I see two solutions, which both involve connecting your MPLS providers into a core layer at one location (although two would be better for redundancy purposes, and is what is diagrammed below). This would allow your existing network equipment to connect the sites from each provider. At all other locations/sites, the MPLS provider would be irrelevant. They could be connected to Provider A or Provider B (or both), and traffic would flow between them. First, you could redistribute BGP into your existing IGP and allow your equipment to route the traffic transiting between each provider: 

Understanding what you can really expect As explained in the introduction, a lot of literature explains this attack as "making the switch behave like a hub". While a good overview for the layman, this oversimplified description is wrong from a technical point of view. To understand I will recall how a switches works under normal circumstances, what's the algorithm behind them, to ensure we are all on the same page: 

I will now take each of these point individually. Knowing where difference with real gears lies For performance reasons, a lot of switch things are actually not part of the IOS code but are implemented in hardware. This includes the ARL, or Address Resolution Logic, which provides all the methods to add, remove and lookup entries in the MAC address table. Therefore, for the NM-16ESW module to work in GNS3, Dynamips had to reimplement all these normally hardware provided services, or at least push this far enough to allow an unmodified IOS to run on it correctly. The sad thing is indeed that this is unfinished work, as stated in this module's source code header: 

The short answer is, your proposed additional fiber in the diagram will not gain you any real advantage for VLAN 3. All traffic from Packaging or Fiberglass, destined to the server in Shipping on VLAN 3, will still traverse the Core. (Presuming that you have already properly tuned your Spanning Tree settings to make the Core switch stack the root bridge.) This is due to the Dell 5500 series switches only supporting regular 802.1D Spanning Tree and 802.1w Rapid Spanning Tree. What this means, is that in your entire switched domain in the diagram, there is only one Spanning Tree for all VLANs. 

Edit to respond to your comments, @phenetas: First, as alluded to in my response, I was assuming your OS was Linux in my answer so I recommended using . If you're serious about learning more about penetrating 802.11 networks, I'd recommend looking into a linux distro such as Kali Linux, which is designed for exactly that purpose. (Use this power only for good please; with great power comes great responsibility, etc, etc.) However, if you're insistent on using MAC OSX, you have other options as well to put the NIC into monitor mode (including just using Wireshark instead of TCPDump). Some Googling around for MAC OSX monitor mode should help you there. Finally, I would look into reading more about IP Broadcasts and mDNS (Multicast DNS) as that is what you're seeing initially from the other devices. These are not "intercepted" packets, this IS traffic destined to your device, that is why TCPDump is displaying the packets. 

This flag is re-enabled whenever the switch receives a new packet from the corresponding MAC address, keeping active addresses in the table. You will have to take this behavior into account in order to design a successful CAM overflow attack: 

Now, let's see how a switch works when the CAM overflow condition has been triggered and he did fallback into the so-called "hub" mode... Actually all of this is just nonsense: there is no hub mode and the CAM overflow triggered strictly nothing. The switch just continues to work as it always did: 

also relies on some brute-force strategy by sending its malicious packets as fast as the attacker's device and the network allow. This cause several issues: 

So you're warned: as stated in ≈Åukasz's answer forget about QoS and expect some oddities. Hopefully here we are not dealing with QoS but with CAM overflow, and except the final bug (of which the correction should be included in some future GNS3 release, I hope) there are two main oddities which are of concern to us: one is affecting the MAC address table size and the other the MAC address aging process. First difference: the MAC address table size tops at 8189 entries This was the main topic of your question but is in fact a non-issue. The CAM overflow attack exploits the fact that a switch is not able to add any new entry to its CAM table, and therefore fallbacks into "behaving like a hub" (as it is often described, I'll come back on this later). Most probably due to a minor bug, it seems that the MAC table is considered full at 8189 entries instead of 8192. However, full still means full: the ARL will still fail to store any supplementary entry and the CAM overflow attack will still be successful. Second difference: the setting is not honored By default, MAC entries should remain the MAC address table for at least 5 minutes (=300 seconds), as defined by the setting: 

I have been having complaints of a "slow connection" from several new remote sites. The sites are connected via an MPLS L3VPN service into Cisco 2921's, and we are using Cisco GET-VPN to encrypt the traffic between our locations. All locations have either 100Mbps or 1Gbps circuits, so speed should not be an issue. However, upon conducting iperf tests from one location to a known working location, I found that my bandwidth tops out around 85Mbps. Further investigation on the 2921's gives many occurrences of the following error message in the logs: 

With all of that said, it really sounds like (based on your previous question and this one) that you're taking some stabs in the dark. I HIGHLY recommend checking out Jeremy Ciora's book from Cisco Press: "CCNA Voice 640-461 Official Cert Guide". It will help guide you through many of the questions you might have about Cisco IP telephony, and IP telephony in general. I've given it to several folks over the years, and it has helped them greatly. 

After you do that, you will be able to test and repeat MAC overflow attacks in GNS3 with router-based switches in a stable and predictable manner. Here are two final notes: 

The switch receives an incoming packet on a some port, The switch then checks if the source MAC address is already stored in the MAC address table. If it isn't and there is a free slot, it records this new MAC address associated to its incoming port (and by the way if the address is already present but associated to another port, it will update the record with the new port). This is also the occasion to reset the aging timer associated to this entry, no matter if it is new or not. The switch then checks if the destination MAC address is already stored in the MAC address table. If it is, then this is all good and the switch outputs the packet on the interface associated to the matching CAM table entry. If it isn't, the switch will output the packet on all interfaces except the incoming one (all interfaces belonging to the same VLAN + trunk ports as long as this VLAN is not pruned).