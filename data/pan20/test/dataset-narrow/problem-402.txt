These aren't questions, I guess. See this whole answer. Overall, you did pretty good; I question some of your methods and program behavior, but if you wrote this to learn then it is fine. I might be a bit harsh here and there; that's so that you can learn, rather than that I say everything is fine when in fact it is not. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

I think you should work on splitting things up into even smaller functions. Especially the parts in where you start getting into the HTML. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

Reuse your functions where you can; like that you allow code to be read at a semantic level, rather than a syntactical level. Logical reasoning likes to work with semantics and not bother so much with the syntax. In this case, you can reuse : 

You have here, in a single iteration, 2 to 3 summations of . Some languages will cache these values. Some languages will not. I'd get in the habit of summing them once, then doing what you must. 

Validating whether is null is not needed since you're just setting to otherwise anyway. I also feel this function should be split in three: One function for nodes. One function for determining from and one function for determining from . This will get rid of the deep nesting of statements you have here and make it easier to understand your code. 

I don't know what does, but I have the feeling this check () is redundant. If you don't allow 0 then explicitly decline that value with . Duplication You have a lot of . I'd create a separate function that takes the arguments. Then I'd create separate functions for the constants to be wrapped in, so you get things like this: 

Because there's no indentation level by variable assignment. Magic numbers should be a constant with a name that describes its meaning. Something like or . Or even ... but that might be less descriptive than the other names. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

There is a possible infinite wait: First, instantiate a new OnboardCamera. Then (whilst is false), call . Start a new thread where you call on the camera. resolves before this newly started thread because that's how threading is likely to resolve (continue to run current thread is more likely than swapping). Next, the thread from the grabber starts. is false, so the grabber stops. Next, the function calling thread starts and calls . It gains a lock, ups a counter and gets stuck in the loop forever. ... More simplified, it goes wrong whenever you call and then try to grab two pictures. You KNOW after the first picture that the grabber has stopped, so when another picture is requested, you should signal that there will not be another picture ever. 

It might even be better to make occurances go up by 3 at a time, but this seems like a dirty hack, and in a long function like this, it's probably better to focus on readability where you can. 

If you return a value, the function execution stops, so there's no need to use an else, you can just make a guard clause that returns upon the condition. There's also no need to set if you're not going to use it, so you ought to move it down a bit... 

You declare a , but then you don't use it until a good 30 lines later. Additionally, you keep redefining as , where it was previously an event. My compiler gives warning messages for this sort of thing. When you're concerned about the robustness of your code, I recommend you take some time to look at each and every warning that pops up for that bit of code. Automated code checking is there to help you, not to be whiny and annoying that you didn't color between the lines. 

How about using some form of collection, then iterating over it to call the property, and if it's empty, setting focus and breaking the loop? The algorithm would be like this: (pseudo code) 

Possible improvements are assigning the strings to separate constants, and perhaps storing in a local store to reduce a double double array access for each for-loop iteration to a double single array access (the for loop accesses and , by storing locally, you reduce the accesses to and instead). 

It'd be nice if I didn't need a whole lot of boilerplate to define an enumeration. If I must write boilerplate, then I'd prefer to write such boilerplate once - adding values should be easy. Same goes for removing values. With that in mind, I have managed to create the following... Base class 

It's the result of using a flag argument. Maybe you can't get around the use of a flag argument. Maybe you can. In the situations where you can't, try to make the flag argument a clear point of separation. In this case, make a separate function so that the existence of the flag argument is easier to spot. Maybe in later refactorings you can spot some cases where you don't need the flag argument and can directly call the function you would have acccessed via the flag argument. Also, if you can somehow iterate over , is there anything stopping you from using ? 

does not throw , so you can move this statement out of the try-catch. If it DID throw exceptions and you caught them, 

The code looks mostly fine to me. If you feel that the code isn't as clean as it should be, or just want it to pass the metric, what you could do is split it into functions: 

The turn keeping, you could perhaps keep in Main. But as I said before, pattern could be a separate class. Additionally, the graphical display is something that could be offloaded to some other class. Presumably, you could even go so far as to make main just handle the obtaining of , and then creating a new instance and passing it a stage instance. Then you can have a class like handle the model related part - the patterns, the turn keeping, etc. A class like could be responsible for the graphical display and the blinking. Bonus points: This would also make it easier to implement a proper reset, rather than just making all the buttons vanish. 

The rest of all the declarations should be moved to be after this check. I'd even be inclined to make the last check, this part 

That's the really quick way without thinking. There might be better ways, but this is what I come up with in 2 minutes. After testing, you'll find out that it doesn't have a 0 prefix for hours 1 through 9. They show up as "9:45". You could either add a check for that, like so: 

The last issue in your code I see is that is being defined as a checked throw everywhere. It's leaking. I'd recommend that you catch it in the Oven for now. Later, you'll want to move baking a pizza to a separate thread, so that the PizzaBaker can take and work on multiple orders whilst waiting for the Pizza's that are in the oven. 

Wow, look how short it is! But it's 3 numbers today, it's 10 tomorrow. As an alternative, how about an array? 

You could use some blank lines in your code. reads as a wall of text, and without semantic breaks ("paragraphs"), it's hard to see at a glance what's going on. Additionally, you'll find that blank lines show how a function would be split up into other functions. Let's take a look at your code: 

It's a classify function that takes a set of integers and if they're not all positive or they don't make a triangle then it's regarded as an invalid triangle. Then you have an implicit else that works with a "valid" triangle. It's basically begging for this addition: 

Yeah, that'd work. Now we got rid of . I didn't touch your comments. Chances are they don't make sense anymore. I'll be honest, I don't understand the algorithm, and I didn't test this code. All I did was analyse the code statically and rearrange statements. Maybe if you analyse the code you can come up with a more understandable description of the algorithm?