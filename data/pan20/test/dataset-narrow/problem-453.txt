I am not sure if this is what you meant with your call because you only check for errors. But a nonexistent file does not return an error code. But from the context I think a check with is_regular_file() is a reasonable check to make. Theoretically there is also a Networking TS which should be tested by example implementation in the compilers like the Filesystem TS but I could not find any compiler implementing it. With this TS your network code could be simplified as well, but this is for another day. The final code 

First of all, I really liked your C++ code and even though I am not a professional I think there are some points to consider. To the future! It is 2016 so I would say we can safely use C++11 today (at least if you are not held back by embedded, an ancient compiler, etc.). There being at least three major compilers with C++11 support this shoud not be a problem. I went through your code from top to bottom and the first thing was . It is good but we do not need it because there is std::thread 

The call to returns a std::future which gives a way to retrieve the return value of our operation. Moreover, it enables you to join the operation, if you want that or not. Because the destructor automatically joins the operation if it is not finished we have to keep the s around. One might want to clean these up, but this is left as an exercise for the reader ;) Going experimental Huh C++11/C++14 is not enough? How about the Filesystem TS which will someday (might be C++17) be in the standard. Nevertheless there are implementations in gcc (5.x+ I guess) and VS (2015) (clang says no work started) which you can use with . It has a clean and portable API to work with filesystems, even though I only used it in one place I think it is more descriptive. 

Something I want to add to the other answers. Normally in finance money is saved in cents, etc., i.e. an integer. 

While I was at it I changed to a std::unique_ptr. I saw you used std::auto_ptr, do not use it, it is deprecated and will be removed in C++17. unique_ptr is not copy-constructible/-assignable therefore we have to move it into in and out of it in . A more drastic change is the wait logic. I could have used in a while loop but there is an overload of wait() which takes a predicate to check if waiting is over and it fits this perfectly. In your I created the using std::make_uniqe() which is the highly recommended way to create s. While I was at it I made it static because it removes the need to instantiate . Destroy all the things! Wait what?! Even though I wanted to show you all these neat ways which simplify your code in the end I deleted all your thread code and most of my changes because there is a simpler solution to your problem. You know that IO takes time and blocks so you thought of a way to make it asynchronous. The common approach, as you did, is to implement some kind of threadpool logic with workers and creators. But there is an alternative, std::async. It encapsulates the asynchronous logic and is required to act like if it was a . Most implementations problably use a threadpool so it is exactly what you did, just less work for you. I removed and changed (not being a thread anymore) 

A should not have access to the database. It should be a dumb 'entity' with setters, getters and a constructor to make the required object a valid one. You should take a look at the Repository and Data Mapper patterns. The point is, the object you want to save should not know how it is saved - meaning that you can change where you want to save it's data in the future without touching the underlying entity. 

You need to decide on the Domain Objects that represent concepts in your current model. A object should encapsulate the data to do with a route. If you look at Symfony's Route you'll see that it is simply an object with some properties, getters and setters, and that's about it (apart from a few select helper functions). This is also known as an Entity, the end object that you get back. So, now you know that you want to get back some entities ( in phpdoc), you should: 

Somewhere in the , it would call to actually make a object. Don't expect the user to remember to call followed by . If one can't be run before the other, then it looks like you're trying to implement the builder creational pattern (which is for optional parameters). Your method should return a object. In the context of routing itself, you'll likely want something called a Resolver. That is, something you pass a to, and it instantiates the thing you are routing to. In an 'MVC' framework, you have a - so you would create a , call and that would contain the logic to decide what controller to create based on the contents of the object (so it'd do things like etc. It looks like you're trying to design some generic router, but it is doing too many things. Focus on making the following seperately: 

Separate the actions out that you want to do, contextually, and you'll achieve better SoC. Also, you shouldn't be accessing any superglobals () within this class, you should pass them in instead. This means that during testing you fake (or 'mock') the data you pass in with relative ease and test that your object still functions as you expect over different scenarios. 

So, all in all, a lot of refactoring to be done here. Well done for using and prepared statements though. 

For an example implementation of this, check out Doctrine ORM. The Repository is the the object that uses a data mapper to save data to the relevant data source. Change the data source, the repository object-api (how you save / retrieve data) stays the same, but how the data is saved changes. Pretty basic concept but really powerful, and not just limited to ORMs or PHP, either. Imagine entities in JavaScript with a data mapper for local/session storage, for example. The data mapper would have get, update, delete (etc) methods, and the repository would call the underlying data mapper (relying on an interface) to actually perform the saving / retrieving of data, which you can swap out at any time. Also, our vote needs to have it's own (unique, primary key) completely separate from every other attribute so it can be uniquely identified. Aside from that, all lowercase, underscores for spaces and prepared statements is a good thing. I'm not going to write your code for you, but effectively, you need to take a look at doing the following: