This is presuming the LCD is attached by DSI ribbon cable. That should also rotate the touch coordinates too. 1 = 90° 2 = 180° 3 = 270° $URL$ 

I'd suggest a USB to LAN adapter (very cheap on eBay) and set static IP addresses on both devices. Or the hotspot method mentioned above. Or - use a smartphone with hotspot, Fing (to scan for the R-Pi IP and scan running services) and JuiceSSH (for the SSH bit) 

Keep it simple and prove your project is worth the effort of a UPS. Just add a momentary switch to short a couple of GPIOs that triggers a shutdown. The Pi will power up when the car is started next time. Be wary your supply is only delivered after the engine has started, to prevent a dip during the ignition process. Create a script: 

If you haven't already changed the default password and disconnected from the Internet, start there. If the scrot captures continue check /etc/rc.local for odd entries. 

Then select Interfaces > SSH Enable SSH and reboot. Use a LAN scanner on your phone (Fing) to locate the IP and check the services that are running. 

Set up a pihole and don't use either of the ISP DNS servers, while blocking ads, malware and telemetry. This can then also be used to protect other devices in your network. 

You also have to change the last line for the root file system in /etc/fstab to contain a 1, like this: 

It all depends on the amount of data you are prepared to loose. If you cannot afford to loose anything, it will require that you find a way to connect your PI directly to the battery (with a fuse of course), so that it is not turned off when the ignition is turned off. Then again, a typical car battery would have around 80 Ah and the PI will consume between 500-1200 mA (depending on if it is a model A or B), so that will probably drain your car battery in between 2 and 6 days, so I don't think you will find this acceptable. If you still cannot afford to loose data you might be able to design some kind of custom hardware where you can control the power supply from the PI and also monitor the state of the ignition. If the ignition is turned off, you flush your data to the SD-card, shutdown the OS and then as last step turn off the power supply. The power supply also needs to be turned on when the ignition is turned on, to let the PI start again. This is all doable, but quite a large project. However, if you find it acceptable to loose some data at shutdown, I would design the daemon that saves the GPS data periodically to a file in such a way that it executes an fsync call after each write (to flush the data to the SD-card). If you do this every few seconds (and are also using the default journaling ext4 file system) this would probably mean that you will only loose the last few seconds at each power loss. Please keep in mind that Raspbian (at least my installation) did not come with an fsck of the root file system at boot time. You have to do the following to enable it at every mount: 

I would get rid of all this and just use a ULN2001 or ULN2003, whichever you happen to have around. Then you can drive seven solenoids (but watch out for total current!) A convenient, although not as cheap as ordering from Mouse or DigiKey, source of ULN2003 is the various "stepper motor driver" boards sold on ebay or aliexpress. You also get four convenient LEDs :) 

There is no magic in the image file. It's simply a bit-for-bit copy of a chunk of the sd card. What you want to do is figure out exactly where the second partition ends, and copy from the device file representing the whole card (in this case: . Now, look at how your partitions are laid out: in your case, it's partition 1 followed by partition 2. Right click on sdb2, and select information. Note the last sector. It will be some number around 8 million (a "sector" is 512 bytes, you have four gigs, that makes eight million sectors). Let's say the number is 7666777. That's the last useful sector you care about. Since the first sector is sector 0, there will be a total of 7666778 sectors that you want to copy. So do something like: 

If you are only interested in limiting the data rate for the purpose of reducing network utilization (as opposed, for example, for needing to force g mode rather than n mode because of radio spectrum considerations), the proper way to do it is is at the network layer. The term you are looking for is "traffic shaping", and a quick search revealed this as a reasonably easy-to-follow example. $URL$ Doing traffic-shaping this way allows you much finer control than the selection of the various WiFi modes provides. 

Just an idea. I don't know if this is your problem, but it is worth a try. There are known cases of corruption of the filesystem when overclocking with the new "turbo mode". The theory is that the timings for the communications with the SD-card is coming out too short due to the BogoMips value being produced at the slowest clock rate. Read more about it here: $URL$ If you are experiencing these problems you will have errors in /var/log/messages, but since your filesystem is most likely corrupted, you are not able to inspect this file, so the first step would be to try to repair it from another Linux machine. However, if the file system is heavily corrupted, it might not be possible to fix it at all. If that is the case you have to start all over again with a new image. If you manage to sort it out. There is a new setting for /boot/config.txt called initial_turbo that enables the full clock rate for the given number of seconds after boot and this will make the BogoMips value come out right. initial_turbo=60 So after you have run rpi-update, you can add it to config.txt, reboot and your SD-card will probably work from now on. 

The zip is compressed to 158.86 MB, but the image file inside is intended to be written to a SD-card that is at least 2 GB large, therefore it has this size. You can write it to a larger card, but then you have to resize the main partition afterwards (if you want to use all of your card). The image file is indeed sparse, since the filesystems inside the image are not 100% filled with data.