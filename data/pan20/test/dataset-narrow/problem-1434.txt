By using the same pixel representation that the potential APIs with those your game engine will have to interact you save having to do expensive format conversions later. 

I thinks this is the same bug I found when experimenting with MonoGame to decide if I will use C#/MonoGame rather than C++/Various Libraries. I suggest the following work around: try to change the resolution more than once. The property AllowUserResizing must be set to true before doing the change of resolution. And you must call ApplyChanges(). All of this came from the bug report. I made a ResolutionChanger class that automates all that. The class has an update() method that should be called each frame. This update method will check the current resolution to see if it is the same as the last requested resolution, if it is not the same, the change is assumed as failed and the class will continue trying to change the resolution until it see that the current resolution is the same as the requested resolution. Note that I had some success with this approach but I observed that some times the game starts with the default resolution, switch to full screen and back to windowed fixs it but I don't remember now if that worked 100% of the time. I don't know if this will work for you, but you can try. How to use (in your main game class extending Game): In the constructor create a ResolutionChanger instance: 

I'm reading about efficient Frustum culling algorithms. I found an article about a smart method that first use the Frustum AABB (Axis Aligned Bounding Box) to eliminate most of the scene before check again against the actual frustum representing the camera. I didn't do any performance test yet, but maybe somebody else did and can answer this question. Let's say I'm using an Octree to quickly check again the camera bounding box. But I do not want to do a second pass again the camera planes. If I simply render everything so far, isn't that actually faster than do the second pass? Assume object geometry is loaded into VRAM using hardware vertex buffers. 

Vector from Platform to Player. If you do not want to use an structure/class to represent vectors, then another option is to use separate variables for x and y elements: 

Implement a QuadTree was indeed a good idea. Scene culling and collision detection will be more efficient with a QuadTree. Your only option is to learn a sorting algorithm or get a library that implement one. I don't know a javascript library that meets this condition. First you select the visible sprites. This will be fast thanks to the quad tree. This is the scene culling. Second, you will have an array of sprites in any z-order. Then you apply a sorting algorithm to efficiently sort the array from the lower z value to the higher one. Third, now you have the same array but with all sprites ordered by their z position. Render all sprite in the array. Sorting algorithms reference: $URL$ Play all animations and choose which one to implement. I remember have used Quick3 in the past for a QuadTree. It may be the case that you don't want to pay the time cost of learn an algorithm at this stage of your project. In my opinion it won't take so much time and will be good later. But if you still want to avoid the sorting algorithms for now, do brute force as a temporary solution: When you are inserting the sprites into the array, for each new sprite, increase the array size by 1, iterate through the entire array, compare the arriving sprite z with each of the other sprites. Remember that the array is sorted from the beginning because all sprites where inserted using this method. When you find the first sprite with a higher z-order, move that sprite and all sprites next to that one by 1 to the end of the array. Then insert the arriving sprite where the first sprite with higher z-order was. Note: that is very inefficient. It only will work to make possible to see the game graphics correctly drawn for now, but you probably cannot publish your game until you implement a more efficient method. If all scenes of the game are so simple that this method is enough maybe the quad tree was not needed in the first place. As you are using a quad tree, then you expect your scenes to reach considerable complexity, and sorting algorithms will be needed too. 

Are you sure your resolution is right and supported by both your graphics card and your monitor? To me it sounds like that's not the case. What happens if you pick 1024x768? You can't just pick any (fullscreen) resolution you want and expect it to work. If you need such an odd resolution for whatever reason, use transformations to properly scale the output. Some cards might be able to still properly transform/scale this through drivers. E.g. Nvidia cards got a setting for upscaling (whether it's done by the monitor or graphics card). If it's done by the card, I think it will accept pretty much any resolution (which doesn't mean you should do it). 

Looks perfectly fine to me (ignoring some jumping back/forth). To actually get the feeling of weight impulse isn't enough. You'll have to implement friction to slow things down based on their weight. Without friction you won't feel weight once an object is in motion (i.e. after applying an impulse). 

The whole process also varies slightly based on the actual drawing technology you're using (e.g. Canvas vs. OpenGL ES). In either way, you should only draw to one big screen. Don't try to draw everything into its own canvas element or anything like that. 

But how is input handled? Your client will send your position to the server "I moved there.". The server will verify this update (e.g. should you be able to move there that fast?) and if it's valid move you (or rejecting your update, resulting in "rubber banding"). So yes, your fixed interval approach will most likely work and be enough. But even if you want to send input and handle movement on both sides, keep in mind that you don't have to send "button is still pressed". Instead, send one event when the button is pressed and another once the button is released. 

Most games (I guess all you listed) combine both approaches to reduce the amount of data to process and render. Using one huge model is very costly, because you'll always have to draw everything (or do lots of culling calculations). Due to this, the probably most often used approach is drawing the raw map using one or more heightmaps (to improve performance, you'd most likely split this into "cells"). In addition, these cells are decorated with more detailed and modeled objects, such as rocks, cliffs, bridges, houses, etc. When drawing, you can then restrict yourself to only draw the heightmap of the current (or neighboring) cells as well as all their objects. Recent and popular examples would be games such as Skyrim or Far Cry 3. This approach will be less attractive if you plan on doing things like indoor maps. Brush based drawing, e.g. as done by Valve's Source engine are more suited for something like this. Overall they'll still do the same thing: Use the rough drawing (brushes here) to create the map, objects to decorate it. So in short: Always try to get your general map layout done with some simple method. Keep this simple, because this will be fast and allow you to cull other elements (e.g. using depth buffers, cell hierarchy, etc.). Then add the details. 

Why 256 (probably indexed) colors? The GIMP can create and edit (and convert to other formats) such images. You may decide to store sprites like 256 colors, 1 Byte per pixel, bitmaps to save storage, but that does not mean you need to work with them during game execution. Just get a library that understand the format and load them and apply any required pixel format conversion to get the same format as the current screen configuration. Having the assets in that format does not imply that you are forced to leave them as they are once loaded. 

@rolen123 answer is correct. I wish to introduce a data structure, QuadTree, to the formula. As you said, sorting a vector of thousands of entities every time you are about to render is slow. But if QuadTree is introduced things change. Implement QuadTree is not so difficult. Implement a QuadTree to only update entities that are moving is a bit more challenging but can be done, mine does. Most implementations in internet simple destroy the whole QuadTree and recreate it when something moved, that won't work for a fast paced game. I have a QuadTree.selectRect(x, y, with, height) method that let me obtain all entities inside the specified rectangle, entities have a z property but they are returned in any order. Then I run Quick Sort in the returned array. Then I render the entities starting at the one with the less z value. Hint: if an entity rectangle does not fit entirely in a node do not make multiple adjacent nodes reference the same entity, move the entity up to a bigger node is better. Sorting before rendering may sound like overkill but even 3D engines do some kind of sorting and games perform OK. 

Game B, 2.5D Render, sprites are ordered by the z value of its position vector. In this example positive z is down and negative z is up. z-axis and y-axis are parallel but z is scaled by a factor of 0.5 of y. So if the visible area is from 10y to -10y, in the same area we have from 20z to -20z. Objects with a greater z will be drawn latter, so they will be seen as being in front of objects with lower z. Shadow of player character looks weird because shadows are in a superior layer than the floor, but in an inferior layer that all the other objects, so the player character shadow never is on top of the cube. 

In resume: in 2.5D an sprite is either in front or behind another sprite. In 3D, a mesh is made of triangles, but triangle is not the minimal unit when testing for depth, you can have pixel precision. Of course, camera rotation in 2.5D is impossible as assets were created for a fixed camera angle, while in 3D is natural, if the angles of the camera are restricted by design in a 3D game is another subject. 

However, if it's about some grid, you might just want to draw the grid on your own using draw calls. Just make sure you only draw to the visible area of the screen (not everything that might be visible in some way). You could also cache these drawing calls to a texture. Using primitives (like lines) rather than textures has the advantage that you can make it more dynamically, like hiding fine grid lines based on zoom level or possibly even animate them (like flashing some important/active gridline). 

In theory, yes, practically it's very, very unlikely (or simply too expensive). You'd most likely have to pay the initial license owner, since other licensees might not be allowed to sub-license anything. We're typically not lawyers here and you should ask such questions a real lawyer if you're serious about something. Personal opinion: Screw the idea. :) Create your own IP/game world/setting. That way you're in full control, people might call it a knock-off, yet you'd have far more freedom. If your game idea doesn't work without the Pokemon label on it, it's most likely not good enough anyway to interest anyone in playing it. 

What you're describing is procedural generation (of some kind of universe in this example). This is actually rather trivial to do. Basically you'll just have to calculate everything on basis of your coordinates. This can either be done by simple math or by using the coordinates as the seed for your random number generator. In your example, you want 20 % of your universe to contain something. So all you have to do is something like this: 

Split the building into more basic forms (walls, platforms, etc.) and also create a bounding box for the whole building. So, unless your tested object collides with the bounding box, you ignore everything being inside. Depending on the complexity you can group this even further, e.g. by building, by floor, by room, etc. Once you're sure you're indeed colliding with something small, like a char or table, you can check the actual faces of the object to determine collisions. This way you can ensure lots of details (like windows or gaps you can shoot through) while still keeping the overall complexity of most comparisons low. 

This will essentially get you the exact same structure you've outlined in your image, with the slight difference that the bright green rectangle will be shorter by two boxes (as the blue and dark green ones take the first/last box). 

In this example, would be sorted by priority (and possibly distance). would be the time allowed per frame (leaving some room for final processing of the scene). As an alternative, you could just adjust your level of detail or drawing distance based on the framerate, i.e. the higher the framerate, the further you draw your scene: