The fundamental problem is that Bash only supports integer arithmetic. You can work around this by using a tool which supports floating point, which conveniently Awk does. (I would also factor out the useless and note that is similarly useless.) 

I ran into this on a host where a Nagios job was scheduled to check Openmanage. It would manifest as a large number of stale semaphores owned by Nagios. I put in a nightly job to find the stale ones by simply taking two listings 10 minutes apart; anything present in both listings is assumed to be stale. (Adjust for your circumstances, obviously.) 

If your mailboxes are directories, you can list all of them in a single delivery action. Then it all becomes as simple as 

but more idiomatically and elegantly, you can use a single question mark to examine the exit code of an external command: 

The more conditions and the more specific conditions you can put in to guard this, the smaller the risk that this can be exploited. I would still be extremely hesitant to put this on a production server. If you can put in a condition to only allow a handful of very specific commands (no , no , no , no , no or or obviously) then mmmaybe. Here is a variation which allows for just one particular command: 

If your mailbox is , Postfix will deliver , , etc to this mailbox with the part after the as the extension. As far as the MTA is concerned, the extension is simply ignored. You can basically invent new unique mail addresses on the fly by creating new extension parts on a whim whenever you need to share your email address. In Postfix, the extension separator is configurable. Out of the box, it is unset, though Debian ships a canned Postfix configuration where it is set to a plus character, which is also the character used e.g. by Sendmail; Qmail uses a dash. Eli the Bearded used to publish an email addressing FAQ about this; it's long abandoned, and obsolescent in some parts, but you can still find it archived on faqs.org. 

The cron job syntax is restricted to only so you cannot use Bashisms like . Fortunately, the fix is easy -- just replace it with . Similarly, needs to be replaced with (just a dot). Of course, the scripts you source mustn't use Bash syntax either if you intend to use them from . Probably the easiest fix is to migrate these things to your script (or create a wrapper script for Cron to run). Because inside your script, you can use if you like, provided of course that the shebang line is correctly (adjust the path if you have to) rather than . If you don't like that for some reason, you can inline Bash in your file by specifying it explicitly: 

It's not clear what you want the single left brace to match; the way it's now, it's a syntax error. I'll assume you simply want it to match literally. 

Furthermore, the assignment is not a valid command; you have to refactor the variable assignment to be outside the recipe: 

If you want to use this in a shell conditional, make Awk return a zero exit code on success, non-zero on failure: 

If there is no header, the assignment should end up empty, and the message should be forwarded with whatever envelope sender your Postfix generates. 

If you still can't get this to work, updating your question with a similar transcript whould be most helpful. Further troubleshooting tips can be found e.g. at $URL$ Once you are satisfied that your code works, maybe you'll want to prefer over which leaves the now rather useless in the headers. (Your prose description says but the code says . It is obviously easy to change if your code was wrong.) The Webmin stuff is truly atrocious but apparently it's not your own code. Somebody should supply the Webmin folks with a hint that Procmail contains a regex engine, so calling to compare two strings is really, really inefficient and generally horrendous. 

etc for 6001, 6002. This presupposes that you have a limited number of these, or if you need to handle each case from 00 to 99, perhaps generate the recipes with a simple script. 

These examples demonstrate how to capture something into with the special regex operator and we rather whimsically pipe the incoming message to a command which will simply ignore its standard input (we basically run it for the side effects). This will incidentally cause Procmail to regard the message as delivered; add a flag to avoid that (). Many Procmail examples allow for arbitrary whitespace after the colon etc but since these messages will presumably be machine-generated, that's an unnecessary complication here. This will not cope correctly with MIME RFC2047-encoded headers; if you require that, you will need to add a decoding step (Perl one-liner?) 

Assuming these emails are really regular, so that the first in the body always contains the address you want to extract, try something like this: 

The older system had Bash v3 I believe. In , I get different behavior, albeit still not the behavior I expect (and the option is called instead of ): 

Now, Procmail will open with the message as standard input, and assume that the script takes care of processing it (delivering it, and/or parsing and then discarding it). Add a flag if you want Procmail to also save to : 

I am unable to reproduce your problem, and you are not posting any diagnostics, but I can suggest a different recipe which might avoid a couple of possible error conditions. There is no reason to repeat the conditions inside the braces -- if you are inside the braces, you know it matched. The convention to hard-code the path to seems clunky (and you fail to do that in one of the places where you call it) but if Procmail gets invoked with a really wonky that could be a reason you see failure when you don't specify fully the path . Anyway, you want to avoid external processes as far as possible. Procmail can extract the Subject: header into and then you just need a single invocation for the entire recipe to succeed. 

The Awk script examines each variable name, and only prints it if it matches the pattern. What you have inside the loop is the variable's name, not its value. In Bash, you can use to interpolate it; in POSIX , I imagine you would have to resort to , or modify the loop to directly loop over values instead of variable names. This will still somewhat suck if you have multi-line variables, but the probability for a false positive is rather low. (Less so if you switch to looping over values.) 

This is easy enough to do if you use Procmail as the LDA. Here is a Procmail recipe to pass the message to two different scripts, then deliver it to SPAM. (Deliver to instead if you don't want to keep it; or equivalently, remove the flag from the last recipe.) 

To "place incoming mail into [a] specific folder depending on some set of rules" is precisely what Procmail does out of the box, but I guess you are looking for something like this: 

Here's what I have done. I have a set-up where a lot of messages tend to be delivered roughly at the same time; for a series of experiments I run SA on messages which are copied to a temporary spool and then delivered by a cron job every five minutes. would keep on printing "maybe you should increase the max-children parameter" and I had it raised up to 40 at one point, but I had the server consuming all its swap space and crashing. Now I have implemented a different regime where delivery is governed by a Procmail lock file. Because it was simple to do, I just use the last digit of the process ID, and run with 10 children. I'm not at all sure this is optimal, but it has already helped avoid the insane load peaks I wouled experience from time to time. 

The context in which Procmail runs is when you are in the middle of receiving a new message. Inside your you typically don't know yet where the message you are delivering will be stored, because deciding that is now the job of Procmail. Once it has made the decision, it can be made to perform additional actions; but your requirement to zip a folder seems out of place for this kind of logic. I imagine you don't want to zip and send the whole folder every time one new message is added to it...? A more natural implementation would be a periodic cron job. Decide how often it needs to run (hourly? nightly?) and have it erase the messages it successfully zips and sends. If there are no messages in the folder since the previous run, obviously don't zip or send anything. If indeed you do want to use Procmail for this after all, the logic looks something like 

This is slightly tricky because not all messages are MIME messages, and not all MIME messages are multipart messages. The following is thus probably a bit too simplistic, but works in my limited tests. 

You should be able to see and in the emails sent by when things go wrong. Examining the error output is really important for troubleshooting. Of course, if you have the standard on Ubuntu, it will bail out immediately if you try to source it from a noninteractive script. Maybe better then to put the settings you want in a noninteractive use in another file (maybe which will be read by by default)? 

... but I actually like the former, more readable alternative. If you can somehow refactor the command line to read standard input and write to standard output, this could be made more elegant, at least so as to avoid the separate variable, and possibly even be refactored into just a one-liner. 

You can put in the same commands in both variants (newline or semicolon separated) though proper quoting is slightly harder in the first case (not in the second! Though I added quotes around to prevent the shell from interpolating variables etc in the here document; if you need the shell to do that, you'll need to revert that change).