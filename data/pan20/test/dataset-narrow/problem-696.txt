There are a few things I see in here that I would suggest could be different. I don't like that the logic for determining whether a cell is a sink is on both and . In fact, both classes have the method called ... My preference would be to move the logic on to the Cell, which already knows how to calculate it's neighbours.... and then the Rainfall class can just call: 

Seriously, what is that? ;-) With perl it's often best to put required arguments first, and then use magic to handle the input files. In other words, put the column width first, and then the input files... The magic is powerful, it will read all the files given on the commandline, or, read the STDIN if no files are given. By shifting the column width off the you can let the magic do its thing. is another nice trick, it removes any trailing newlines, if any. The lines can be printed with brute-force substrings in a while loop then. I would write your code as: 

Your code is inverted. The code I am seeing here would appear to belong in the class that you have referenced as , whatever that class is, is likely where this code belongs. You should mark all those variables/fields as private, and discover what you need to do in order to put the code where it belongs. The following should all be private fields: 

If your question is 'When should I override the default toString() method and use create my own?' then there is one set of answers. If your question is 'when should I call the method (implicitly like or explicitly)?' then there is a different set of answers. So, when should you override the ? From the Javadoc for Object: 

Algorithm THis is where I see the biggest problem, and it's not because you've made a mess, but because I think you've missed the point. If the problem is: "... to calculate the entry of a Pascalâ€™s triangle with a given row and column recursively" then that is not what you have done. You have calculated all entries and stored them in an array, then indexed the values you need. Sure, some parts are recursive, but I expect that the point is to not have the arrays at all. Consider the triangle: 

Your implementation is not quite correct. It is subtle, but what you have is a type of bubble sort in that you do not insert the new value, rather you 'slide' the value in to place. An insertion sort can be thought of as a 'hole'. You shift all the 'bigger' values to the right by one space, and create a hole at the point where the value should be inserted. Then you insert the value in to the hole. There should not be a concept of a 'swap' in an insertion sort. You start at the first unsorted value, and then if the previous values are smaller, you move them up one, until you have the space at the right spot. Then you put the value there. The example code makes this 'obvious' (but not really), in that it always compares against and not . It also has only a single 'assignment' to the array for each time in the loop. Your swap routine does two assignments on each loop. So, No, your implementation of an insertion sort is not quite correct. It is a correct sort, but not a 'text-book' insertion sort since it slides, rather than inserts the value. 

Firstly, is the use of a cursor an overkill here? Probably. If your database transaction log is small, though, it may be better to break your updates in to batches that fit. A single large update may fail, and roll back, if there's not enough space to log it as a single operation. Your cursor breaks it doen to a sinlge record each time, and there's plenty of space for that, though. Ask your DBA, or just try it... if you are uncertain. Is there a simpler way to do what I'm doing in SQL? SQL is a set-based language. If you have a set-based way of thinking about it, then my suggestions are 'simpler'. Certainly, it is more concise. Could the script go terribly wrong? Yes.... it could. Take a backup first, and verify everything! I have limited SQL experience, how does it look? Any standards that I'm not following? Your conventions, for what you are doing, are reasonably good. There's very little in the way of 'standards' for SQL style... consistency is the key factor to look for. 

Why do you need the function? To measure the distance (in miles) between two points? Then you want to select all points of a certain type and order them by distance from a given origin. With a CTE (common table expression) you can simplify things a lot too. But, the real issue, is that you should use the functions already available in the geography datatype: STDistance. This STDistance function returns the 'LineString' distance, which is 0.25% accurate to the geodesic distance. Additionally, this is better than the 0.5% accuracy of the Haversine distance. So, by the sounds of it, you have horribly overcomplicated this process. Consider this (SQLFiddle example here too): 

because I cannot figure it out. Code Style All static-final fields should have CAPITAL names. The static field should be: 

can't throw an exception. If it did, everything else in Java would be broken too. the try/finally block suggests you are protecting the lock somehow, but it is just fluff. Having pointed out those issues, consider the alternative.... Now, what exactly is wrong with a standard pattern? Consider this: 

Apart from the other comments about how to calculate the input, I would also suggest that your main method is buggy, and not very 'pretty'. One the the tricks in programming that Java programmers seem to forget, is the do-while loop (note, C programmers use this all the time, and Java programmers do all sorts of crazy things to avoid it ...! ). Consider the an altered main method 

I would actually restructure that loop to make it more apparent how the indexing is done... I would have: 

in the normal course of events, every get, remove, and put requires a 'readlock' to be held for that operation. This significantly reduces the amount of concurrency available for the store. Actually, now that I look at it, the implementation uses a ReadWriteLock, but there is a bug, and even the 'write-lock' is a , so there is no effective exclusion from the process. If the lock was implemented right though, it would still require a full lock when the 'replay' was performed. even when the system is not having a snapshot taken, the overhead is required to conditionally manage the data load. Using a Strategy Pattern we can improve that, by having one simple strategy that is used most of the time, and then a more complicated strategy that is only used when performing snapshots. Using the mechanism of ConcurrentHashMap is overly complicated, and has resulted in the degradation of generic typing to raw types, and is a problem. 

in the above system, the first thread to 'set' the cached value will have it's instance used by every other thread. It is possible that multiple threads may be initializing their values at the same time, but they will all defer back to the winning-thread instance if they don't win. Once the instance is set, all threads will use that instance and there will be only fast atomic locking. 

Now the duplicate functionality is clearly available, and conveniently included in the interface. The implementations now also get to choose how deep the clone should be - which is probably a detail of control that is useful to include in the class, not as parameters to some Cloner instance. Factory methods I have removed two of your factory methods. I find factory methods to be an anti-pattern unless subclassing is prohibited (i.e. if the class is final). For example, in your class you have: 

The static synchronized method means that only one thread in the whole JVM can be scheduling jobs at any one time. Is there even a need to synchronize it at all? The only external fields are the and the input parameters. The is already safe, and the input parameters are presumed to be unique for each caller... right? If the input parameters ( especially) are used for two separate calls to you have a problem, because one set of tasks will be overwriting the data in another set, and you may end up with concurrent modifications, and even ArrayIndexOutOfBounds exceptions 

That function takes an input function and the test data as an argument, and returns the String summary as a result. You would use this function like it's used in the main method.... 

General Notes I had to look at your code quite hard before I figured out what it does. Despite having variable names and method names that are descriptive, I still found it hard to 'get it'. Comments describing that the array is essentially a ring-buffer, and that the Counter is only used in the Stream, etc. Threading and concurrency - don't mix systems Your class uses two distinct strategies for thread management, synchronization, and atomics. In general, whenever you see a mix of strategies in a single class, it is a warning that something is not right. The Java memory management required for thread-safe concurrency is relatively complicated (though not as complicated as other systems). The two strategies you use affect the model in ways that may not be obvious, and mixing them makes it even harder. Additionally, the two models use different lock points, so you seldom get the exclusive thread accesses you need when you mix them. Use just one system in any one class. In this case, synchronization is the right choice. The atomic classes are useful when you do not have multi-stage operations that need to be thread-safe. Your code needs to increment counters, and add messages at the same time, and that requires at least two related operations in a single locked sequence, so synchronization is your friend for this. Concurrency Bugs Your code is not thread safe. Consider this method: