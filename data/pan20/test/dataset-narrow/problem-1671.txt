The reasoning behind the JS popup is, those can trip up generally simplistic written brute force scripts. Then redirect the page to drop session and go to another page for added complication for any automated hack attempts. Additionally you could lock out all IPs but specific ones to allow connections: 

I would think some existing UPS units designed specifically for the pi would be a far better approach. Some can allow for additional battery for longer life. I think if I remember correct, some can initiate a shut down on low battery as well. On top of this, I found a nifty design idea for something that may work. Raspberry Pi UPS Quoted from this link is the part I want to convey here: 

Effectively you would power a small router or something that provides a external connection (from the same power source) that can cause a drop in LAN connectivity on the pi if it is shut off. It would have to be something that has a lower tolerance for power drops than the pi so it shuts off first. Then on the pi you have it ping that LAN and if it does not show connected it does a 'shutdown now' Granted this would reduce battery life considerably, but it is a non-GPIO/hack to achieve what you are looking for. 

Set the piece in place and use a paper clip to hold it, then use a heat gun on low air setting to solder it in. It will take some time to get it to the right heat and do not bump the unit at all during and for 5 mins after. Flat level stable surface and try to keep the heat off the rest of the board as much as you can. Also since it is near the SD slot where there is likely plastic in it, use some form of shield on the side of that to deflect heat from the slot. To answer the other question, it is likely a capacitor if it boots fine. I don't have a zero nor know where the schematics are off hand. But running it without the capacitor can be dangerous to the stability of the unit. Depending on what circuit it is for, you could "spike" voltage or have a voltage drop which depending on tolerances could fry other components. 

The only way a windows .exe will run on anything linux including the pi is through wine. I am not sure if there is a pi compile of wine as I would never try it. For a .jar these are java scripts. Again not sure if pi has a JRE (java runtime environment) as I would not have a reason to attempt or research this. The .dmg was already answered. You may want to look into linux basics guides and such on files and programs. Then look at specific platforms/architectures. The pi IS a linux box, but on arm not x86 intel. 

Boot to recovery with a working internet connection. It should show in the list. If you don't have a internet connection on instal it seems to hang as the win install bits try to authorize your Microsoft account for the install. 

I tried Ubuntu 16 once, nothing worked well at all. Slow as you state, the packages that installed were not up to our project standards we have (example mysql was impossible to remote into). Various bugs elsewhere too. Symlinks failed to work correctly. Set a link and it was like running down a tunnel that wrapped back on itself. So far Raspbian runs very smooth and impressed with it's performance as a dev and server platform. I doubt Ubuntu 16 has the needed kernel compiles for the rpi. So it is bound to run horrible regardless unless you compile it yourself and find everything you need. That said, in short, you are not alone and that performance is normally experienced by many. However, I would seriously avoid clocking it up to boost performance on an OS that is not very compatible with it. You will be looking to replace it sooner than later. 

Have a look at htpasswd from apache: htpasswd The steps to create this can be quite confusing, but in the end you can lock out ANY endpoint url/directory on your server with a user/password prompt. Key notes from this link in case the link changes: 

Analyze your running processes with htop or top. Figure out what is installed that you don't need running and disable or remove the packages (not for the feint of heart or linux beginner). Don't start the gui. Disable all logging or send logs to dev/null Make sure the PSU is supplying ample power as others have stated. You can overclock, but I wouldn't do this without good cooling and heat sinks. Externally power any addons. Then you should have as high performance as I could advise. 

I also personally recommend using php pages and wrapping generated html in echo or return blocks. Thereby not exposing any function code to the browser. Like so (ultra simplistic example, showing only the result of $bar, but not how it was assigned.): 

Radioshack sells a VOM that has a serial port and a API to interact with the meter. You could get a "premade" device such as this if it has a customizable API. Then just code a pi interface to it. edit: requested link RadioShack 22-812 

Beyond this, for brute force you could have a sql database logging connection attempts from the remote machine by IP and time stamp, blocking repeated attempts within a set time frame.. You would generate a sql entry based on these variables: 

A function that generates a sql log query if desired called loginlog() Then use some php to fire off the check: This is just an example.. 

The big thing to watch about any PSU you attempt to use for the RPI is the dead/no load voltage. As @goldilocks stated, I have seen a few PSU questions asked and I also think it is on topic (all-be-it loosely) to find the best PSU that won't fry our rpi. What you will want to do if you buy any PSU is leave the 5v end unplugged. Before plugging the PSU into the wall, connect a volt meter to the 5v side. If you have a volt meter that is quick to read and has a auto "hold" feature for the highest detected reading that would be best. Otherwise watch the meter and plug the PSU into the wall and look for a spike initially and a holding voltage that goes past the tolerances of the pi. Many wall unit PSU's will spike. Thereby fry or weaken your rpi. 

Just connect the Arduino a mostfet or power-transitor, to the 9V battery. Have the Pi control whether or not the arduino gets 9V by connecting a GPIO pin to the Gate/Base of the mostfet/transitor. You could put the arduino into sleepmode, but that's kind of pointless, as the voltage regulation, leds, and other stuff on the UNO board use as much power as the ATMega328 itself. PS also add a pull down resistor to the gate, so it isn't floating while the pi is booting up, shut-down or powered down. That way the arduino will always be off in those cases. 

The ws2801 will indeed still use power, even when all leds are set to zero. Relay is the safest as it isolates the power of the led-strip from the pi. You'd need a very beefy transistor to switch 1A of (max-)current. Transistors also have a voltage drop, so the WS2801 will get a lower voltage. Not sure if it likes that. (Sidenote: If the transitor has a voltage drop of 0.6V; then if 1A of current is passing through, the transistor will convert 0.6W of power into heat. Which will make it quite hot without any heatsink) A better alternative to transistors, in this case, would be to use a MOSFET. You could use a optocoupler to switch the GATE of the MOSFET. But it quite safe without. PS did you remember add a (flyback) diode to the relay? 

Couldn't you just print the command to tty1, and then run the command from ssh, and forward the output to tty1. That way the end result would be about the same. Except maybe missing the pi@raspberrypi ~ $ in front on the command, but you could just fake that by also printing that. 

Some hub backfeed power to the Pi. Either buy a hub that is verified to work, or open the usb cable and snip the 5V line, preventing backfeed. Make sure you have 2 usb cabled between the hub and the Pi as illustrated below. One for power from the hub to the Pi. One for data from the pi to the hub. 

I've hooked up an LDR to a pi's GPIO and ground pin directly. I set up the internal pull-up resistor on the broadcom chip. This created essentially a voltage divider, that would make the pin would read low if a led shined on it, and high is not. Since you only need a yes/no answer there is no need to measure the time to charge a cap, just like analog-to-digital converters do. You just need the voltage to be either above or below the tripping point of the GPIO for either state of the led. The tripping point for the gpio seems to be around 1.2v ($URL$ So under normal lighting condition the voltage should be above 1.2v. When the led is shining on the LDR, the voltage should be above 1.2v. Just note that in my setup I've taped the LDR to the led with black tape, so the LDR is in complete darkness. You probably have to have some external pull-up resister that better matches the resistance of the LDR. Some variable resistor (pot) would be a cheap and handy way to calibrate. My sample test script for reading the gpio pin. 

Your current situation could indeed create a short between two row pins. (the keyboard might have some resistors inside, but I think that is unlikely). A software only solution might be to set the GPIO pins back to inputs, when you don't use them, instead of setting them to 3.3 volt. The diode solution will also work. The GPIO pins need at least around 2.6V to register a HIGH. So 0.6V is no problem. Resistors will also work. Note that you calculate the voltage incorrectly on the voltage divider. Since the internal pull-up is something like 10kOhm, the resulting voltage will be more like 0.2V. Downside to the resistor solution is that if you press multiple button in the same column, none will register. 

The default python library already supports DMA PWM on all pins. See $URL$ for documentation. edit RPi.GPIO doesn't use DMA. I just checked the source code. 

By default the pins are inputs and therefor floating (except the I2C and UART pins). Why not flip the required value? You just enable the internal pull-up on the pin on the Mega, and have it wait till the pin goes low (). Once the Pi is booted, have it set the pin to output, and LOW. No extra resistors needed. 

Unmount the drive. Create a folder inside . Make this folder readonly. Next mount the diver and again create the folder . Edit your script to have it write the the folder . If the drive isn't mounted the script can't write to the folder. However, if it is mounted, it can. It might even work without creating the subfoldeer, and just making the folder (on the SD) readonly. But I'm not sure in mounting overrides these permissions. You'd have to check yourself. Also make sure you script doesn't fail, if it can't write. 

At $32,- I'd just try, and see if it works. Camera's that are designed for those kinds of conditions will probably cost into the hundreds if not thousands of dollars. You could try putting the board into an enclosure, and force cool outside air though it with some tubing and a fan of sorts. Also be aware of air-humidity. 

You shouldn't do that (chown). Apache is running under a different user, for a purpose. You don't want a webserver that is accessible by the whole world to have access to all files. That is in case the program has some vulnerability that can be exploited. You as a user must add permissions to files the server is allow to read, and most importantly which files it's allowed to write to. To give read access you use . Most of the time this isn't needed, since this is a default permission. To give write access to a file or folder you use .