Standard C# naming convention for methods is . Following standard naming conventions makes the code look more familiar to other C# developers (which might be important as you plan to open source it) You are potentially wasting some cycles here by calling again even though you just did it and have the result stored in : 

Avoid throwing generic - be specific. In and it would probably make more sense to throw an . You should try to bail early. Right now in and you perform a bunch of operations just to potentially reject the post later. Something like this would seem to make more sense: 

Your decoration structure seems to be the wrong way round. From your description the header is the outermost layer, then comes layer 2 and then 3. Yet the way you construct your layers it is the other way around, this is especially obvious where you name the constructor parameter as and pass something in which should be an outer layer. So should be the innermost layer: 

I don't like repeated calls like this . should be called once and stored in a local variable. You will run into trouble when writing unit tests. Right now you have no way of mocking out the database access which forces you to run against a real MySql database which tends to make unit testing a pain in the backside. Create an interface for against which all your business logic should work and inject it into the classes responsible for creating the database queries. Then during unit testing you can pass in a mock-implementation which simply checks that the methods are preparing the statements correctly without having to run a query against an actual database. 

Answering whether or not this implementation is correct would require to know what the specification of the problem is. Now assuming the spec is: 

As mentioned by Scott in his comment to your question you should use to retrieve an item as it will block until one is available. You might want to consider providing some sort of "object resetter" action which gets called whenever you have retrieved an item from the pool which puts the item into a clean initial state automatically. 

I'm not sure if it will make your query faster but here is my take on it: If I read the code correctly you want to create orders for all gift transactions related to gift ids which are not covered by an order yet. 

You have a method which I assume provides a prime number between the two bounds provided. Yet you do not use it and call directly in . You should either get rid of the wrapper method or use it consistently. Braces are used inconsistently: 

I'd change the id checking code around a bit to avoid some redundant checks by first sanitizing the input: 

I assume is some kind of way to print debug/info/tracing messages. If so then this is not a good name for the function. Better would or similar (depending on the exact purpose). There is this magic method called everywhere but it doesn't seem to follow any particular pattern. Seems suspicious to me. 

The standard naming convention in C# for local variables and parameters is . An underscore prefix is usually used for private class fields. You repeat the code so the the background color three times - this should be extracted into a separate method. This will perform an integer division: 

@Teresa has already provided some good hints on how to improve the performance by using a better data structure so I'll concentrate on general things: 

Update: Actually I just noticed that your implementation is leaking memory: nodes get -ed but never deleted. Which comes back to my first point :) Also you're copying the and elements around a few times when you probably could just move them but I don't do enough day-to-day modern C++ to provide a correct answer on the spot right now. I'll leave that to someone else. 

is a graph and should therefore be named . It can be used for many other things not just for cycle detection. is a bit of an oxymoron: DAG means Directed Acyclic Graph which by definition contains no cycles. The class should probably just be named (which is possible if you name your data structure properly). should be named - this will make it clear just by reading the method name of what the return value represents. 

Given that is a fairly light weight class I don't quite see the point of lazy initialization for the static instance. Why not simply use a static initializer and a readonly field 

There is a bunch of helper macros defined (like , , etc.) which you sometimes use sometimes not. This is inconsistent. If they are meant for the user of the list then see the point above: the user should not know about these kind of internals anyway. 

A reasonably experienced developer can read this code and understand what it is doing in about 5sec. You have turned this four-liner into a mess of disjoint statements which take about 10 times longer to read through and understand what the code is doing. You also run into the same problem as you do with commenting every statement: You write the code twice. Once for the compiler to execute and once for the developer/log file to read/record. Admittedly with detailed logging you can run into similar issues. You also said you don't want tracing while in fact at least your example code boils down to exactly that. So using an AOP framework might be the better alternative in your case. 

removes the need for and makes it a bit cleaner. In general your error logging is a bit adventurous. Sometimes you obtain the file pointer to the error log in which case you usually close it (but it's kinda ugly having to remember this) and sometimes you just log a string in which case you don't close the file pointer. You should be able to just do it with one function: 

The and methods are identical (unless I missed something). Not sure if this is a bug or intended behaviour but if it is intended then this should be extracted into a separate method so it can be called from both actions. From my experience it is very rarely required to use the enumerator interface directly, like you do in your methods. Those can be rewritten to: 

Either you're sure it's a then use a direct cast or you're not sure then use plus a check. The way it stands you might get a which is usually not very helpful (since technically this could be thrown in a lot of different places). With a direct cast you get at least an which tells you a lot more about what may have caused it. should not have to deal with a collection but should just deal with an individual title - it should not concern itself with the requirement that you want to do this for a whole collection of strings. It can also be condensed with the use of LINQ: 

You should only use single letter variable names for loop variables. Parameters and other local variables should have more descriptive names. For example when I first quickly glanced over the code I saw this and thought "Strange, why is he passing in two nodes?" associating that has a similar meaning to . I had to look again before I realized that is actually a map. Using names like or would result in easier readability. does not print the tree and should therefor not be named such. It collects all nodes on the same level. Better name might have been apparently expects that the elements to be inserted are in order. You swallow the error case by simply returning a . You should throw an exception instead to make it clear to the caller that this is invalid input. You represent a binary tree by a reference to a node which happens to be the root. However if the caller accidentally replaces it with a reference to a different node memory leaks because some part of the tree is now lost. You should encapsulate the tree in a class like which handles the construction of the tree in the constructor or through a factory method and handles the deletion of the nodes in it's destructor. This way the user can pass around an instance of the tree and not even care about how you store the data internally which facilitates encapsulation (although in a templated class this becomes somewhat a moot point). It would also result in more idiomatic C++ by creating an object through a constructor and destroying an object via a destructor rather than calling a delete function. 

And at the end of the method. Returning out of a block will execute the clause. Using more descriptive variable names instead of , or would make the code nicer to read. It's just a good habit to get into even for short programs. There are exceptions for single letter variable names like loop counters (, , ) and coordinates (, , ) but they do not apply in your case. This might just be an exercise but command line based grep implementations for Windows do exist (and are pretty much part of the standard toolset for *nix systems) and already solve this problem (looking for a pattern in the output of a program). The Java documentation states: 

The main issue I can see is that you have duplicated your statements mapping styles to colors about a gazillion times. This is not very maintainable. Imagine you add a new - you now have to add this to a lot of places and hope you didn't miss anything. As far as I can see there are two types of mappings: One for and one for - you should have two dedicated methods which translate the into the colors you require and then call these two methods in the appropriate places. I would also consider making the an rather than a as there seem to be fixed values. At least define public string constants for the different default names - this way someone could just use those constants and doesn't have to remember the correct name to put in. There are other code duplications as well which you should try to avoid and extract into common methods. 

which you could pull up into the clause as well. I'd also extract the condition into a private method like and utilize to get all members of all components. With all of that the method can be refactored to: 

I like that you are treating your rationals as immutable by returning new rationals from all your operations. Your naming conventions are a bit unusual. In most C like languages (C, C++, C#, Java) local variables and parameters are . Specifically in C method names tend to be or . You are using the mathematical terms and for the parameters of you construction function however you use and for the properties of you type which seems a bit unusual - why not stick to the mathematical terms? When someone passes in a which is you just have a in there. 

I suggest you create a list object which holds , and possibly of the list and all your methods should operate on an object of that list type rather than nodes. Something along these lines: 

This way any user of you data structure doesn't know anything about the internals which in turn makes it easy to change the implementation without affecting anything else. Typedefing the struct in the header but only defining it in the implementation file is called an opaque type - a type where the consumer of the header does not know anything about the internals of it. 

Changing the input file seems dodgy to me. The Unix way would be to write the "encrypted" output to . This way the user can choose what to do with it (redirect to another file or to another program for example). 

I think the implementation is too leaky - it should not expose how the blocking internals are achieved since if if decide do change this you might have to change a whole lot of application code which violates the open-closed-principle (the O part of SOLID). This can be easily fixed by making the class and using of the . I think the more idiomatic way to start a new task is to use . I would rename it into since that what it is. Since you're talking about long running operations you may want to add a method of canceling the task. It might be useful to add a capacity for the intermediate blocking collection as well to provide better control of how much data is cached. 

Also is actually constant for a given image so it should be computed once before the loop. Not sure why you are obtaining the properties of the image as pointers rather than copying the values directly into local variable. This should save you a bunch of loads in the loop below. So instead of 

So all of a sudden when using double because on floating point adding a small value to a very large value just results in the very same large value. Conclusion: Using would give you a larger range than double. 

In the methods and do not modify the object state so you should consider making them (i.e. ). I'm not 100% convinced of the property. It basically just reflects the current position of the object in the depth-list and you are writing a fair amount of boiler plate code to keep it that way. This increases the complexity of the class somewhat. I'd revisit the concept and check if I can't get by without it. 

In accordance with the rules of code review I'll ignore your request and just concentrate on the review of the code. 

The usage of the structure is closer to a than a so the better fitting data structure should be used. It makes the code a clearer to read. In theory it could save some memory as it does not need to store values (which are not needed anyway) associated with the key. The code can be slightly optimized (only one key lookup instead of two): 

The .NET library team had the same problem you did. Before generics where introduced classes like were provided which would operate on and thus box value types like allowing it to actually return if the key was not present. After generics where introduced this was not an option for classes like . The solution to this was to have throw a and to implement a method which provides the value through the out parameter and return or depending on whether the key is present or not. You might want to implement an iterator for your list. This will let you use LINQ for a great many constructs usually resulting in more concise code. Something like this: