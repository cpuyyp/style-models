Note: This is not HTTP or anything based on it. Here we are using that allows us to return control to the main function (trying to avoid using the term thread). The object does all the work. When you call control is transferred to the . When the code in worker invokes the call to returns. The difference is that the next time is called control returns to the point where it previously , so to the lambda it looks like the call to just returned. This allows us to wrap the into a lambda and pass it to the object so that when a read/write would block we actually yield back to the main routine. This is designed to test that on large requests that a read will not block and return to the main event loop and potentially get data from another socket while it waits. ProtocolSimpleStreamNisse.h 

Your comment: //init's Vector with all 0's ( O(2n) with this init, and the for loop below..) A valid concern. I actually fixed this problem above. But in situations where that is not possible. Then I would have added another constructor that took two Vectors and added their content. I would just made the constructor private so that only the could use it. 

So I wrote 6 characters. But I managed to read 10 characters. What were the last 4 characters? Circular Buffer Once you have linked the two buffers correctly. You could get more from the buffer by making it circular. That means as you get to the end of the write buffer you can circle around and start writing at the beginning again if you have been reading from the buffer and there is space. Inheriting from the buffer 

This does nothing. This object is going to be destroyed. Therefore these variables do not exist after the destructor exists. So little point in playing with their values just before destruction. Don't manually call the destructor 

The main reason there is no accidental conversion (type safety is one of the keys to using C++ correctly). 

I will go to the cliche of saying I don't see any benefit of using this over std::vector (and I do see lots of negatives: Two of the big ones are ease of use and efficiency (Both contradicting your own design goals)). 

The destructor for that object is also called. This allows you free resources for non trivial resources (say T was a ) not calling the destructor means you are effectively retaining a reference to an object that could be freed. It is perfectly valid to manually call the destructor of an object (In fact this is very normal when pared with placement new operation). 

You don't update current (so it points at the deleted node). You allow the sentinel to be deleted. If you delete the last node the easy insertion/deletion breaks down. 

When the object goes out of scope the destructor is called. This will close the file which will flush the content of the buffers first. 

This is not the elapsed time. The tv_usec loops every second so you need to this to tv_sec to get the actual time value. 

Inside the function all similarity to an array has disappeared. It has decayed into a pointer. By using the array like syntax you might catch people out that want to treat it as an array (which is a real maintenance issue). If this code is C then just pass as a pointer. If this code is C++ then pass as a reference to an array, or use a container type and pass by reference (I prefer the container option as you can template it). In quick pre-condition checks at the head of a function like this. There is no need for the part. 

That way you don't copy the parameter just make a copy into the new object. Also you may want to look at the opertunity of moving the object into the node. 

Luckily this is not the case here. The second lock. Is inside a lambda function. Thus not in the same context as the original lock. We are pushing a piece of work into the queue. When this piece of work is executed by a child thread it needs to alter the state of the current object (multiple threads altering state must be done inside a mutal exclusion zone and thus a lock is required). 

Sure you have to add the prefix . But that's better than haing broken code. Read: Why is “using namespace std” considered bad practice? The reason it is and not is so that it is not a big burden to use the prefix. Add some constructors This is way to verbose: 

I find your code a bit dense and hard to read overall. Your identifier names are compound words but all lower case. 

I can. You are tightly binding your control flow logic. This makes it hard to introduce new steps or alter the logic. Following the logic in this code is even worse. It is the perfect example of spaghetti. If it works fine then great. But try following the logic when something breaks. This becomes a maintenance nightmare. 

The problem with this is that some files are huge. You don't want to read the whole thing into memory like that. So you could define a reasonable size buffer and read chunks at a time. 

So you are constructing a Vector object then using the copy constructor to copy the temporary vector into your new vector v. Luckily for you the compiler is allowed to optimzie that heavily and you probably only get one vector construction. But I would change the declaration to 

Declare local variables as close to the first point of use as possible (and initialize them at the same time. 

As long as you are not using an ancient compiler (a C++03) then you can use emplace rather than push. 

Normally when you provide access to members (which is usually a bad idea as it break encapsulation) you return it by reference. You can do it two ways by const reference or normal reference (or usually both). 

Of course in C you don't want to have too many return points from a function (as at each return point you need to close all open resources and tidy up. So in C (unlike C++) I find my code looking like this: 

Global mutable state is the bane of many problems in program. But especially testing. It is best to pass objects to functions (by reference) and manipulate them or even better to just manipulate the object by calling the member functions. I would have created a class called that had the array of and objects. Then your functions below become methods than manipulate the object. cout!!! 

No. You should have the option of having a checked access. But in most use cases you have already checked the range. Thus forcing a check on each accesses becomes superfluous. Standard use case might look like this: 

This will melt your processor. You should never do a busy wait. Not only will this melt your processor it will waste a CPU doing nothing when it can be actively given to some other task to do something useful. Suspend the thread until you have work for it to do. Look up . This is dangerous. If the thread has not completed this will throw an exception. So before you call this you must call . That should be made explicit or called from inside itself to make sure the thread has finished. 

You can take this a step further by abstract the container type by allowing the user to pass in iterators. 

No I don't think that is idiomatic python (though I am not the perfect person to answer the question). I think it is more idiomatic to split the string (into an array). Then use the parts of the array to build the result. There also seems to be a bug in your for short paths: 

The rules for a leading underscore are non trivial and most people don't know them. So even if you do most other people will get confused and panicky. The case where you use them it is not required anyway: 

This way also does not suffer from the number limitation. But adds the limitation of only compressing ranges upto characters at a time. Code Review This seems like an expensive way of counting the number of characters needed for a number. 

One assumes that is -1. Personally I don't see a point in hiding this value inside a variable it makes the code harder to read. The documentation says connect returns -1 on an error. 

No don't do that its dangerous. Looking at your code you avoid the pitfall of slicing (because you use references). But all to often a downcast results in the object being sliced and you now no longer have any-type of Saw. Your problems are caused because you expose the internal implementation of the object via getter(s) (don't do this it breaks encapsulation). 

All it does is flush the output buffer. Which has already been flushed (because cin/cout are tied by magic that makes sure the user can read the question before answering). You want to read three numbers divided by a slash? 

OK. So you try. But this is a very dangerous interface. There is no way to guarantee that the array and the array are at least size. 

Virtual Destructors If a class has virtual methods then you should have a virtual destructor. The compiler will warn you about this if you turn up the warning level. Override When you override virtual methods you should add to the method declaration. The compiler will warn you about this if you turn up the warning level. Code Review Prefer to use the range based for when looping over a container. 

Placement of '*' and '&' In C++ the '*' and '&' are part of the type information and usually belong beside the type not the variable. This is the opposite of normal behavior for C. 

You are converting this every time!!!!! You should convert it once when you read it in. Conversion is really expensive. (I mean the calls ) Don't manually flush the stream 

Also you are performing a bunch of uneeded copies. Capture these values by reference rather than value; 

Your usage of the condition variable will probably work but is a-typical. This is what you basically have: 

Code Review You do steps (1) and (2) outside the function. You pass the strings by value thus causing a copy of each string. In main you use standard algorithms to loop over the strings but in you use a manual loop. You could simply have done a string comparison at that point. 

Passing RAW pointers around is not common in C++ (unlike C). Normally you wrap a pointer inside a smart pointer object to indicate ownership semantics (and thus who is responsible for deleting the object). 

This has a couple of benefits. Calling the destructor is not required. You are moving the actual data to the other object. Thus means the destructor of the other object will correctly handle destruction. This also potentially allows for re-use. If the is in some other context and you the object could be re-used this can help in optimizations. If it can not be-reused it will correctly be deleted. You remove the pesimizing check for . You don't have a conversion too bool. 

But what about the copy assignment operator. This seems to be missing and will lead to exactly the same issue as not deleting the copy constructor. Sure. 

Your edit makes your code look like C not C++. Any style where you have init() doStuff() fin() is a case for where a RAII could be good: 

OK. Personal opinio: . Best way to break your objects encapsulation ever invented. Also it tightly couples your class to always providing this interface in the future as somebody will use it and then you will have to maintain it. 

I believe that makes it a lot easier to read. Don't put inline where it is not needed. The keyword plays absolutely no role in code inlining. Don't use it for that. It only plays a role in the one definition rule so you need it if a function is defined in a header file that is included into multiple compilation units. 

Here I would have used std::endl just to force a flush. Because the std::cin and std::cout are bound together with magic it does not really matter though. Initializing the random number generator should be done once in the application. So do it just after main() starts. There is no need to cast the result to unsigned. A lot of people think 0 is good here I still like using the macro NULL (the problem with NULL is that on crappy compilers it is not defined correctly for C++). To me the NULL conveys more information in that it is supposed to be a pointer not the number 0. Though with C++11 I am trying to use nullptr. Using this technique for generating a random value will get a lot of fanatics complaining.