For junior candidates, the best people I've seen usually come out of game development focus institutions (Guildhall, Digipen, that kind of thing), or have done work experience type stuff on their own (mods, solo projects). A Computer Science degree doesn't really prepare anybody for the practical matters of programming games. In my experience, going to those kinds of schools is going to be more of a detriment than anything else. Getting into an MIT or the like might show something of value, and might put you higher up on the resume-responding priority than somebody who went somewhere else, but any good hiring process is going to weed out people who program like mathematicians (i.e. poorly). On top of that, game programming is historically lower paying than other software engineering positions, so getting a really expensive degree really isn't worth it. The benefit of going to those prestigious colleges is not the value of the degree itself, but the connections you make with smart and wealthy people. If you're not using that to your advantage, then you're kind of wasting the whole point. 

Scripting languages for game logic is a very good example of the software architecture pattern Alternate Hard and Soft Layers. There's a good discussion on that site (and others I'm sure) on the benefits of doing so. 

Both and affect the same variable. So calling both in the same frame the way you are isn't going to work. What you want to do is change your mouse input code to take into account the current y and z values of your position. So do the translate part, and then for setting the x value, do something like this: 

One easy/semi-hacky solution is to not use hitboxes but instead do a pixel test for you given sprite. Basically you set up some alpha threshold and if the alpha value of a given pixel closest to the area you need to test against is greater than that, you've collided with it. A better approach I've used in the past is to just set up an array of points per tile (in your case, per frame) that signifies where the edges are. You generate line segments out of that and do arbitrary n-gon testing for your collision. Barring that, you'll probably have to write your own solution to save out exactly what you're suggesting, i.e. bounding volume type x with properties y at location z for sprite w. It heavily depends on what your specific needs are. 

Your user is as interested in as few options as possible. Show them what they should care about and nothing more. Ideally there would be as few clicks as possible to get into the game. So arguably, if you're supporting the ability to load a game, you might want to put "new game" and "load game" as separate buttons on the main screen instead of a generic "play" button that takes you to a sub menu as there's less input to get where you need to go at the cost of more buttons. 

I also follow the "strong ownership" train of thought. I like to clearly delineate that "this class owns this member" when its appropriate. I rarely use . If I do, I make liberal use of whenever I can so I can treat it like a handle to the object instead of increasing the reference count. I use all over the place. It shows obvious ownership. The only reason I don't just make objects like that a member is because you can forward declare them if they're in a scoped_ptr. If I need a list of objects, I use . It's more efficient and has fewer side effects than using . I think you might not be able to forward declare the type in the ptr_vector (it's been a while), but the semantics of it make it worth it in my opinion. Basically if you remove an object from the list it gets deleted automatically. This also shows obvious ownership. If I need reference to something, I try to make it a reference instead of a naked pointer. Sometimes this isn't practical (i.e. any time you need a reference after the object is constructed). Either way, references show obviously that you don't own the object, and if you're following shared pointer semantics everywhere else then naked pointers generally don't cause any additional confusion (especially if you follow a "no manual deletes" rule). With this method, one iPhone game I worked on was able to only have a single call, and that was in the Obj-C to C++ bridge I wrote. Generally I'm of the opinion that memory management is too important to leave to humans. If you can automate deletion, you should. If the overhead from shared_ptr is too expensive at run time (assuming you turned off threading support, etc), you probably should be using something else (i.e. a bucket pattern) to get your dynamic allocations down. 

For non-indie games, how much polish is usually a matter of time and money. You have a budget, release window, and so on, and you usually just find the highest priority things (hopefully from the user's perspective, but sometimes from the other internal forces like IP holders and the like) to do first. Eventually you have to cut your losses and ship. But for you, I would probably frame the question a different way. Assuming you haven't released yet, the amount of polish is more an effect of when you're proud enough of the product to put it in front of people. 

It seems like the only real "solution" to this is to make PvP an opt-in experience only. Something similar to PvE servers in WoW combined with level-capped Arenas. 

Because floating point numbers are represented as fraction + exponent + sign, and you only have a fixed amount of bits for the fraction part. $URL$ As you get larger and larger numbers, you simply do not have the bits to represent the smaller portions. 

Sometimes "strangling the creative process is necessary", if the creative process is so out of control that it's preventing you from shipping a game. PM (project management) is one of those things that, if things are going smoothly, you hardly notice that it's there. It's primary goal is to keep the team focused on what the real goal is. Some things in the PM toolbox can actually help the creative process. The idea of short sprints to a "shippable product" can put you in the quick iteration mindset. Daily standups are useful as a communication tool. But it's all about how you apply it and where. The relative importance of PM depends on the project and the team. Sometimes it doesn't add anything. Sometimes it's the difference between success and failure. 

Well first off I'm assuming you're doing a kind of "trace" like described here: $URL$ So for a given frame you have a certain amount of velocity you want to account for. For the sake of argument let's say you want to slide along surfaces instead of bouncing off of them. So let's say the user is pushing their point (or circle, if you want to give yourself a little more wiggle room with penetration testing) along a surface. You might have a certain amount of movement until you hit the wall. So place the object at the earliest intersection point you detect (but slightly offset in the opposite direction to avoid the floating point errors you mentioned). Then in the same frame figure out the desired velocity (in our case we'd do a sliding effect by taking the remaining component of the velocity vector that's parallel to the hit surface). In the same frame you'd attempt to move the user's point along this updated velocity vector, doing collision detections along the way. Iterating the collisions, if you will. You'll probably have to set some maximum number of per-frame collisions so that you don't get into some kind of near-infinite-loop situation. This number is usually pretty small, like 5 or so.