What I would do is to create a table with the stock_id (that can be the alphanumeric code or a integer), the timestamp of the measurement and the current value. That is your entry data, 3 columns. From that point you can add columns for calculations (the difference absolute or percent) with the previous value. Having all in the same table will simplify the model and ease your queries. Try to create a date (not timestamp) column and create a partition by it. It may lighten a bit the access to the table as long as you set it in your queries. 

The basic question I ask to myself or the user when I gather the requirements in order to create a model and solve your doubt is "How much information do we want to keep about this now and if it is possible to foresee, in the future?" If it is incidental information and you will not need to store much about it apart from the name, maybe you can keep it as an attribute of the corresponding entity. If you need to store specifically related information that, otherwise you would need to denormalize it heavily to be stored, then maybe better create a separated dimensional table with all the related information and then keep just the foreign key. Anyway, as you ask for the case of a SCD, in either case you can historicize your table no matter if you are storing the information as an attribute or as a FK of a proper dimensional table. So for me the necessity of storing such changes wouldn't play any role in the decision making of having it as an attribute or a dimension. 

As you cannot use the vendor name as identifier, since it may be duplicated (as it happens with the name of a person), you need a true identifier to be set upon creation. When someone identifies themselves in your system, they cannot identify by their name, since it is not enough to uniquely identify them. Thus you don't have any other option than assigning them any proper id when you create the record on your vendors table and identify them by that id. For this purpose you can create an ad-hoc column (filled in its most simple approach with an auto incremental series), or use a contact email, Tax identifier or any other key that you know is unique, instead of the name. 

Another benefit of the relational approach is that the performance of the system can be managed to a great extent at the physical level without impacting the logical database schema used by applications to work with the data. With the relational approach you can focus on the correct logical schema first and then in most cases let the DBA implement a correct physical design and infrastructure to best support the read heavy workload. This is not the case in navigational systems where the programmer must specify the access paths directly in programs. 

Fabian Pascal recently blogged on the definition of first normal form. Also, his Practical Database Foundation Series includes a treatment of normalization and 1NF. If one purchases the entire series two additional papers are included that specifically address what is and what is not 1NF, the former paper written by CJ Date. I will make an attempt to summarize the key points with regard to your question. For a table to be in 1NF, and thus be a relational table (R-table), certain rules must be followed in its design and population to ensure the table can acquire the properties of a mathematical relation. The rules summarized are: 

I would create a distinct emails table and use a surrogate key to instantiate the reference of the email address to the person and to the user. The model would look like this: 

These rules imply that each employee has a role that requires they work either only for a bureau, an office, or a division, or requires they work for a given bureau and many offices, or an office and many divisions, or a division, and that only employees who work for a division but are not division staff run projects. The schema shown however asserts only that employees work for a division in any given role and that any of them can run a project. Changes are needed to bring the schema into line with rules. The simplest way to address the business rules is to add tables to associate employees to offices and bureaus in addition to divisions. Each employee would then be associated to each organization level in which they work. Employees working only at a bureau, or office, or division would only be associated to that level. Employees working at a bureau who also work at many offices would be associated to the bureau in that associative table and then also associated to the many offices by that associative table. Note this approach only addresses where each employee actually works and not the rules as to which roles can work at which organizational levels. To address the rules more discovery and modeling is required and is beyond the scope of this answer. Secondly, the business rules imply that an employee has a single role - say a CIO or office manager or division chief - and not a role per associated location. The schema can be brought into agreement with this rule, if correct, by making the role table a parent of the employee table such that each employee is assigned a single role. Now this implication may or may not be true. Perhaps an employee can have only a single role at a moment in time, but many over time. In this case temporal columns are also required. Perhaps an employee really can have many roles at the same time at different organization levels, in which case the role would not be determined by the employee. Ultimately, more clarity is needed on the full scope of the business rules by having the subject matter expert review the model and determine if it represents accurately the rules by which they operate. It is vital to fully understand and document the functional dependencies and natural keys in order to arrive at the correct logical design. Right now the diagram does not show any natural keys so even if the functional dependencies were presented it would not be possible to determine if the logical design is in agreement with them. Finally, the diagram shows that each parent entity is optional and I doubt that is really the case. A business SME can determine under what circumstances the parent occurrence is optional, and for each of those circumstances more work is needed to determine why the parent occurrence is optional and resolve it so it is no longer optional. I hope these points help in improving the design to meet all the informational objectives. 

You don't specify if you want to count the number of rows in the step_count or summing it. I've assumed that it contains a previously calculated count and thus I've used the SUM function. It would work the same with a count() instead a sum(). If you need to add the high_fives as a general total (at member level, instead of at activity type level, you need to do an outer query. Try this. This will not work in SQL Fiddle as MySQL does not support full outer joins, but it should work in Teradata. 

Why do you have two separated tables? Your model is faulty by design. You don't need in this case two different tables. Just create one table for user accounts and a different one for user account type. 

I'll make an assumption first. A real world person could have more than one user in your system? If a real world person (persons table) can have (and should have) only one user, why do you allow a one to many relationship between those two tables? Or I've misunderstood your model or I would create in the Logical Data Model only one table for users AND persons with all the information related to that person, including the email address. If you want to store two different email addresses you can use two different columns, as far as you don't intent to store an unlimited number of email addresses (like it happens with the delivery addresses you can have associated to your profile in online shops). I would use a user_login NOT NULL column (what you call John user, which has to be an email address used for validation upon signing up) and another column email_contact (what you call John person), with an additional flag for allowance to be contacted or not. Anyway you may want to validate this second email as well. Beside this, you can maintain a person_to_person relationship table for the dates and use it as an indicator to control if a person in publicly available or not and display its profile or not in the application layer. 

Fabian Pascal's Practical Database Foundation Series (as referenced above). The remaining paper's in this series provide a concise and easy to understand introduction to the various parts of logical database design. Fabian's gift is his ability to distill very complex topics correctly into language the rest of us can understand. Toon Koppelaars and Lex deHaan's Applied Mathematics for Database Professionals. This wonderful book lays out a sound methodology for logical database design rooted in set theory and logic. It presents the fundamentals and then also presents how to apply them to create a fully functional database in Oracle. CJ Date's Relational Theory for Computing Professionals. CJ Date's body of work is enormous and one can benefit from any and all of it. This particular book is a recent (2013) revision superseding earlier works that really lays out the basics of the relational database model. 

This design is preferable to a single table with a recursive association as it cleanly separates what are really two entity types - nodes and links. In our case, the products are the nodes, and the product components are the links. While the network design is a common structure, querying it is problematic as when completely filled it is a recursive structure of varying depth. Industrial strength DBMS' such as Oracle and SQL Server have special language elements (Oracle's CONNECT BY and SQL Server's recursive CTE) to aid in making the query declarative. Given you are using File Maker Pro, which I know little about, you may not have such language constructs to help and may have to write procedure code to traverse the network. This issue can be eased however if the network turns out to be of fixed depth - say every product has either no components, or one level of components. Here are some references with regard to network structures in database design: 

Background I am working on the database design for an application that tracks information about database development projects at my company. The project management office (PMO) assigns a psued-number to each project based on if the project's cost is counted toward merger integration or not. To illustrate, the number assigned will either start with INT (for a project contributing to merger integration) or NINT (for a project not contributing to merger integration). Then a sequential number is assigned. For example, INT175 would be 175'th project identified contributing to merger integration. An additional wrinkle is the PMO sometimes wants to create multiple projects with the same number as they are "related". So for example there could be an INT175a project, an INT175b project, and so on. While the PMO considers this number to be the identifier for a project, in the database I will only use the column as an alternate unique key both to ensure duplicate projects are not created and as a search key for users. I want to implement a check constraint on that column to ensure only a valid number matching the rules I gave above can be entered. What I've Tried - Regular Expressions My first thought was to use a regular expression. In Oracle, my target DBMS, we have the REGEX_LIKE function that can be used. I researched the documentation (here, here, here, here, and here ) on regular expressions and found the options to be dizzying! For whatever reason my brain gets tangled up trying to take the list of all the various pattern matching options and apply it to my specific example. I'm one of those people who work best with examples. Unfortunately, I haven't found many examples out there. What I have found have either been too simple, or so complex I couldn't grasp them. What I have tried thus far is something like this: