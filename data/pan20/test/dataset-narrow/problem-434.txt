I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

This should reduce the amount of time the spends resizing itself. This reduces the runtime by about for - so has little effect. These sort of micro-optimisations should always be tested using benchmarks to see if the additional code complexity warrants their addition. A few comments on the code: Use of You use sometimes to delimit references that won't change: 

Scope It is generally good practice to scope variables in the minimum possible scope. I don't like this: 

The has no idea that we've won - it carries on and still emits that we lost. is a busy wait, so causes one CPU to "spin" while it's checking the time leaving it unavailable for anything else. 

I have some code that calculates the "sentiment" of a Tweet. The task starts with an AFINN file, that is a tab-separated list of around 2500 key-value pairs. I read this into a using the following function: 

So now you can easily add new "transformations" to the list. In order to transform an to the correct in Scala we would simple use as is also a collection. No such luck in Java. I came up with this thing, it's a little ugly but I think it's clear: 

For simplicity's sake, I will only demonstrate operations at the head of the list; the tail is symmetric. 

We are relying on the compiler to inline the necessary bits. This means that the definition of the helper methods should be in the header file, to avoid the overhead of function calls. 

Unfortunately, the C++ standard library does not allow one to pass an existing buffer to a string (sigh) and is generally pretty lacking in raw buffers (sigh), so you'll have to roll your own. I would do so in two steps: an abstract base class which exposes a way to write bytes in slices and a ready-made implementation based on + size + capacity (not , because it zeroes the memory when resizing...). The second is an issue for extension, and performance. In order to format their own types, users are encouraged to "pre-format" their own types into strings, which will result in needless temporary allocations. There is unfortunately no simple way to solve this issue, it's a fundamental limitation of -based solution. It will be up to the users of the solution to decide whether the cost of temporary allocations is worth bearing, or not, on a per-call-site basis. 

Note that by default a does not allocate memory for the previous and next nodes. That's because the previous and next fields are supposed to refer to existing nodes, not new ones! Moving on: we need to be able to set the previous/next fields! We do so by passing around: 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

And yet you continue with your program knowing that it cannot possibly work. Either throw an exception (which will be reported to the user, and be ugly) or simply to exit and terminate the program: 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

Set everything to as you don't know if anything is a composite. This isn't really required as in Java is by default. Starting with to , if , loop over for while in increments of and set . You now have an where anything that is () is a prime. 

What do you notice about the pairs 1. <-> 5. and 2. <-> 4.? There is a simpler solution to this problem than brute force... 

Typedefs as an alternative to new types As others have mentioned, single letter variables are a detriment to readability. One way to help this is of course to add new types. As Corbin mentioned, adding a class or struct to hold just two ints can be a bit overkill (personally I don't mind). I'm not sure if this is considered good practice, but what I do in these situations is to create an alias: 

Some editors may even help you by showing the type of the alias, rather than the underlying type. Extracting code to functions to improve singularity of purpose Finally, as has been mentioned before, it's helpful to extract each level of nesting into a little function. Not only is it easier on the eye, you can give each extracted piece of code it's own name. That helps to reason about what each step in an algorithm is doing as well. For example the first for loop is really just initializing a big old vector. I would move that whole loop into a function called or something and then move the second big loop into a function called or something a little snappier. And then maybe even have it return a new list or perhaps update its input and extract the printing section () to a different function as well. I know that its not quite as compact and also slightly (but not in a big OhO sort of way) inefficient, but it separates each section of code into what is logically doing. Some pseudo code to illustrate: 

So we create a to communicate between the clock and the main . We place a sleep in the clock thread that sleeps for seconds, if the thread is interrupted before waking, it simply exits. This is much more efficient than your busy wait as it doesn't tie up an entire CPU core for absolutely no reason. Never busy wait! We can now modify the game loop to: 

never create a in a loop, and always close resources. never write this is ugly and error prone ( also compiles). you only need to check once; after reading user input. 

Using Caliper this method has a runtime of around for . I have done a few experiments with speeding up the code. For example, using the Prime number theorem we know that there are approximately prime numbers between and . Using this information we can create the used for storing the primes to almost the right size: 

This way they are outside of the running code and clearly constants. Similarly should (almost) always by an instance or class variable as having more than one is (almost) never useful. Use for outputting formatted messages: 

I don't like this. I think if you are going to down the route of using then use it for all references that won't change, that includes: 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread. 

One hard cold truth is that C-Strings cannot be fixed: not knowing the size of the buffer (either inbound or outbound) is a recipe for failure, and the band-aids (, , ...) are just attempting to patch the symptoms. Another hard cold truth is that is broken by design as it is non-portable (16 bits on Windows and 32 bits on Unix). Therefore you should not use it at all and instead rely on explicitly sized types and . 

Note: ideally, a variant or would be the most expressive return, in a pinch just mimicks your current interface, and if not including boost matters, just returning an empty on failure should work just fine... also then you lose the distinction between empty and failure. Note: the type-freak in me would like to point out that using a different type for a raw buffer and the validated buffer would not be amiss either; a simple wrapper containing a for a result would help here. It would ensure that business logic supposed to be executed on a validated file cannot accidentally take a raw one instead. 

And then, this class can easily implement safe copy! Last note: may not be as costly as you think it is, if you are avoiding it for performance reason, measure first... A rough example (untested!) of a safer alternative to C-String: 

Essentially we take each and we it that gives us a . I then you the method to append all present instances to a . If the `StringBuilder is empty simply append the current integer too. An alternative, not sure if it's better, is: 

You're close to a sieve, but you're missing some points. First and foremost your is incorrect - this should step though the range in steps of ; this very fact precludes the use of a . The usual approach uses a , on which you carry out the following steps: 

Here we do the to get the , we then out and to a . We then use the (often overlooked) to first the resulting and then to return if the joined is empty. The main work now becomes as simple as: 

The other comments cover the code quite well, I have a few points to add. First, obviously this is a critical error: 

it's recursive - Java doesn't handle tail optimisation and recursion is slow It makes a rather large number of copies - copies the underlying it's very long 

This leads to fewer string concatenation problems and is easier to read. Here is where the problems really start: 

But (and this is a big one for style) you should only use one type. You have got one type in some places and the other type in other places. Set a preferred style in your IDE and stick to it. Also, if using Egyptian brackets (the first style) please leave a space between the statement and the opening bracket. Comments Comments like this: 

Clearly lay out requirements Code answers a requirement. It may be clear in your head, but it is not clear to us. It may be clear now, but it will not be months from now. Therefore, before coding, you need to define requirements, and then use these requirements to inform your choices. In this case, there are two sets of requirements: 

Now that we have the helper methods, we will also alter the set of constants: checking a single constant is faster than checking individual ones, and having a pre-calculated "total" length is risky in the face of change. So here we go: 

The use of gives us raw storage of suitable size and alignment: this obviates the need for default constructors of ! The use of allows us to offer the best possible Exception Guarantee with little code. 

The last step however is not, in terms of algorithmic complexity, as efficient as it could be. We are iterating over until finding one which equals . Since is sorted, a simple would be more algorithmically palatable; although in practice, for small numbers, linear iteration might be faster. Result 

The design is sound. Despite what naysayers may express, there are a few overwhelming advantages that your solution based on venerable and C-variadics arguments has over and C++ variadics: 

Exception Safety Your container is not exception safe. The first difficulty of writing a container in C++ is handling the memory when everything goes well. Other answers already address this point so I won't reiterate it. The second difficulty of writing a container in C++ is handling the memory when the user is being adversarial. It is possible, in C++, to throw an exception: 

Others have covered bad practices here, I am just going to demonstrate a Java 8 solution to the problem - as Java 8 is the current version of Java; I believe this is what should be written in modern Java: 

So whilst I have a lot of tweet data, I only need a list of integers. This is obviously much smaller. I want to be able to stream the data from the file and convert each line to its sentiment value in the most efficient way possible. Here's what I came up with: 

I'm happy with this code - it's pretty clear and I'm not worried about its speed and memory usage as the file is small. Using the created I now need to process many tweets. Lets say I have 1GB of then in JSON format - from the live stream. What I need to do is: 

As runs in a separate , we need to consider visibility and atomicity of any variables used to communicate. So an seems the natural choice: 

read a tweet file, with a JSON tweet on each line parse each tweet to a using extract the field from the tweet - giving the content of the tweet for each word in the content, check it if has a sentiment for each sentiment word in the tweet, calculate it's value (from the AFINN ) and sum across the tweet store that number 

Loops and Enumerators Loops should generally be avoided in ruby. The one exception is maybe a / loop. A loop should be avoided since it has different scoping rules from using an enumerator + block. Instead, try to use enumerators. They are shorter, simpler, safer (extra scope, usually hide loop counters, reduce mutable state, often remove the need for conditionals), and more explicit (e.g. what does this code do ). Stlye Guide The community style guide is an excellent guide. It doesn't just tell you what to do, but also why. And despite the name, it isn't merely about style either. You'll want to read it. The style guide comes with a great gem that does a lot of checking automatically (but do read the guide): Rubocop 

I always find that the literals , and are code smells in ruby. This is because ruby expressions are always implicitly truthy or falsey and either or not . This means that the expression can almost always be written more succinctly and more efficiently as just (the exception being when you really need and not just truthy). Game I found this rather complex to read. A first suggestion would be to use attributes. That will get rid of all those signs :). In you are calling . But start screen has nothing to do with initializing. It is already running the game. Why not move it to the method? Should all methods be ? What methods do you want clients to call? You are setting up the player defaults in start_screen, only to then potentially change them later. Why not set them once and only once? The method is a predicate, so should be named . The method is not a predicate, so should be named or perhaps something else like . I like the name of the method , but should it be responsible for drawing the board and checking the result as well? You might be better of using a plain old instead of a case statement in Example code Here are some mostly complete examples. I feel that there is more room to move stuff around, but they should indicate the things I touched upon. I feel that the example class still has to much conditions and to much raw data.