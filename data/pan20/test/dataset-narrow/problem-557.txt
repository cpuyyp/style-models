Now given a Count - say - we have to find the corresponding number. In the table given above, if the input was the output should be . 

There have been suggestions that for Swing we should use something like for making the UI visible. So instead of using 

I made a implementation using pattern in . I was wondering if this could be improved. I have states - , , , , and . A has the task of looping through events which would cause a change in . The itself is a , where one of the input is from the user via Command line whereas another input is using . 

For e.g. Consider the number - , I first get all the decbinary representations of ( to positions) i.e. 5 and prepend (the value at position). The numbers formed are . Then I reduce to and get all combinations for - , then is reduced to and all combinations of are - . Thus finally, all the combinations of are - . 

I have written some basic implementation of a Minimum Spanning Tree using a indexed minimum priority queue. For the implementation of the Priority Queue I used Sedgewick's Tutorials. However, it seems that I am passing a lot of arrays around for the priority queue. Here, is my code snippet. Could someone point out the obvious faults and also suggest a better abstraction for the priority queue. (Since Sedgewick's Tutorials were in Java, I translated them to C and I think that my implementation is not good.) 

I was going through this tutorial for Pretty Printing a binary search tree and decided to implement my own version. Here is my implementation. This version works only for trees that are complete binary tree. I would like to know what all optimisations can be done (errors present can be removed) in the code. 

I have moved some code around (I didn't have enough time to fork your repository, will do that later), so that it appears cleaner. Here is an example how you can abstract repeating code into new methods. 

Then, you have a bunch of linked-list functions which operate on pointers, and use an macro to get back from the to the enclosing structure. Not to say that this is better, but it's arguably a more type-safe way to get 'generic' linked lists in C. Both approaches are valid, though (and yours is more 'classic'). Const correctness I would generally say that things should be whenever possible, because it makes programs easier to reason about. I generally encounter the opposite problem to the one you're describing, though: something is conceptually const, but for incidental implementation reasons it needs to be mutable. DLL naming Well, 'dll' isn't the clearest name, because of the conceptual collision with Windows libraries. It probably isn't a big deal unless you're writing software on Windows and using dlls. I would be tempted to just call this module "list", or "ll", though. The only real constraint on the include guard macro is that it not collide with any other names in your program. I suspect that is probably fine. (Obviously, if you have some style guide or standard, that probably specifies a convention). Implementation This is pretty nice code overall. If I were feeling picky: 

Producing sample output on STDOUT, according to a command-line "count" parameter (this is not nice code, it's just here for reproducibility). Obviously, the performance of the filtering algorithm will depend not only on the number of sets, but also on the number of possible different names from which the sets are drawn, and the size of the sets. Smaller numbers of names make some approaches pathological; larger sets create more work for most approaches. Original program Your original program did not run as-is---it seemed to rely on a few parameters provided elsewhere, and a particular directory structure. So I modified it a little to accept a filename as its first argument, and output to STDOUT for easy testing. I also moved around the manipulation of the variable, as that seemed to either have the wrong indentation or be in the wrong place. 

Factory basics If we talking about MVC then we have an object oriented system which contains a lot of objects. Factory methods and classes mainly exists to help instantiate other orbjects. Look at your code; is your factory do what it have to? No. Your factory only loading a file in a strict way, you need a class loader as Wouter J suggested. Learn how PHP namespaces work ControllerFactory If you have a class loader then you can build a real ControllerFactory. What should it do? Get the controller name (namespace + controller name, not file becouse the actual controller is a class!) from the input parameters (route data) handling all namespace and naming issues (for example not only in your controllers "folder" (namespace) can contain controllers). If we have the controller (full name and the class exists) then we have to instantiate it. A ControllerFactory can handle some kind of dependency injection container to allow controller classes to have parametered constructors. If there is no DI container available, then the instantiation can be really simple: new $namespacedName() The ControllerFactory it self should not be static becouse it will be hard to test, the implementation could not be replaced if it would required and we could not pass anything to it's constructor (it wouldn't have a ctor). Ofcourse it can have static methods to set the default ControllerFactory, like: 

Helpful thing can be to create a static method to get all type, and another one to parse the type from a value. Whith these things a $participant->getRight() could return an instance of Mask so the switch can be removed. 

The idei is to create segments in the defined range and pick one value from them randomly with taking the segments also randomly. No overlapping will happen and also works with negative values. 

You can derive from the model class without any problem your attributes will get applied in you view model also (not every but for exmple the validation attributes will). I also recmommend to have copy constructors becouse they can help you a lot. Beside this my opinion is that no need to worry about display/display format attributes in you model classes it doesn't feel an incorrect way and it helps to keep things clear if you have a lot of derived classes. 

Improved version of original program To start with, I just applied some polish to the original program, maintaining the approach and spirit of the algorithm while tidying up the code. Starting immediately after the line: 

Static methods on RPNStack It is odd to write a class like with all static methods and fields; effectively, you have a single global stack, for no particularly good reason. The obvious thing to do would be to make all of those methods and fields instance methods/fields, and then create an instance of within . Output It isn't clear to me why would not be working for you where does; however, you aren't closing or flushing the file, and it may be the case that some subtle difference is causing the file to be flushed in one case and not in the other. I would expect that if you close your at the end of your program, it will work fine. Recognising symbols The obvious and lightweight way to recognise a small set of symbols like this would be to use a statement. If you have Java 7+ (which you really should) you can just use strings directly as labels; otherwise, you'd have to switch on characters (which would still work for your simple language). For a more complex language, you could consider a map from symbols to actions. Error There are kinds of errors which won't be caught by your . But I don't think you need to worry too much about those. The only bit of error handling I would consider adding is that it's possible for the user to enter an expression which causes a divide by zero error. As your program stands, this will throw an and terminate the program. I would suggest either catching the and recovering with an error message, or validating the operands you're passing to the division operator. Minor nitpicking 

Bug: Check in is always true is a statically-allocated array. It will never be a null pointer, so this condition will always be true (high compiler warning levels should catch this). Usability issue: There are lots of platforms which are not windows or linux; exploding on those platforms because you can't work out what the path separator should be seems excessive. I would suggest wrapping that whole block in something like ; that way, you can define the macro using a compiler flag, and you don't have to care that you can't auto-detect this. If you were going to do that, I'd also suggest renaming to , as it has a kind of global scope (it's also a clearer name). Portability issue: only works on windows Strictly, I think that backslashes appearing in paths is undefined behaviour in some C standards. It certainly doesn't work right on Linux. On most platforms, should work if the file exists. If you were feeling really fussy about portability, you might also want to make it possible to get reasonable behaviour on systems which: 

Hide and seek The first method is shorter but is that a good thing? Compared to the second one it hides a few thing internally which can be either good or bad and i would say bad. To me this method looks like a core application logic which has to be crystal clear so i think you shold not prefer the shorter version. But wait The second one still has some coding issues but nothing catastrophe. I have changed it in some parts, lets see: 

No this is an ugly way to do it. extract() (PHP4 stuff in 2012/2013?) The problem with exract() is that it's creating variables ionto the global hyperspace (oh God, why) where can exist (in localy also!) any other variable and can have name collisions and can overwrite the old values. Beside this you are losing the control over your code and it will be hard to maintain (debug, fix also) and to extend. load_view() Not always returns a value: in PHP this is okay but in general programming it's a bad habit. I do one thing in a case and in another one i do a complete different stuff in same function? And why am i in a function? How about a non-static class method where i know everything in my small environment? Here is a small example of an idea: View class 

The output buffer handling is never part of the view it self. There have to be some kind of ViewEngine which can handle this thing. One thing one responsibility. The problem with the example is that is's missing a whole lat infrastucture! In my MVC expiriment i have Controller, ControllerBuilder, ActionInvoker, abstract ActionResult, ViewResult a lot of other stuff what is necessary to get thing done. In my default IView implementation i have a Model "property" beside the ViewData, i can map a lot helper like Html or Url and any other and just then comes the others: RenderPartial(), RenderSection(), Section(), SectionStart(), SectionEnd(), Layout(); these are pointing to my current IViewEngine implementation which is handling all these stuff.