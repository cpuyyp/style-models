Other engines use one shader for all objects (or rather the engines decides what shader to use dependent on the parameters, the capabilities of the GPU and other factors such as distance), in which case a material would look more like this: 

The ".dae" format is the Collada format. A format specifically developed as exchange format. It's not recommended to use it for games, because the data is not setup in a way it could be easily used, also Collada has a absolutly huge overhead. Google Sketch Up isn't a suitable for making game assets either. The geometry it generates is not optimized enough for games and it doesn't give the "artist" control about that eater. Neither were made with games or other low level applications in mind. Well, about Collada, its XML, so you should be able to load the parts you need from it with a simple XML reader. More in-depth informations about Collada can be found at the official website: $URL$ 

You may want to try to optimize it, copying data should be relatively lightweight. Some things you can do: 

The approach with the intersection check is right, however the way you are iterating over the entities/cells is very inefficient. Also you won't need to do the check every frame for every entity as only a few will move fast enough to cross multiple. If you have a regular grid you can calculate the position in this grid by a simple division, then you just need to check that tile and the tiles around it, not every tile: 

It's always a question of which niche you want to target. Every niche has different needs. Since your game is multiplayer already it would make sense to add a online option. There are a lot of people who want to play games together but don't have the time or money to meet regularly in real life. By having a multiplayer only game you have to be local for you are limiting yourself to a reeaaly small niche, probably too small to make a decent amount of money with. Well... unless you are going for a true "social" experience... e.g. a party game. That is a completely different niche already, where the people have little use for a online mode. For a single player game it would just be a waste of time, people will pay for it because it gives a good single player experience, not because it has a tacked on multiplayer part. Don't waste your time with implementing a feature just because it would be "cool to have", it should be a vital component of your game. People won't buy your game just because it has feature X, but because it delivers a good experience. 

No, a array is the most efficient way of storing a tile map. There might be a few structures which require a little less memory but only at the expense of much higher costs for loading and accessing the data. 

If you use specialized formats such as PNG and OGG you won't need the compression of ZIP. PNG, OGG and other already compressed formats won't get much smaller by compressing them again as ZIP. 100MB of PNGs compressed are still ~100MB. Scripts, Configuration files and other text based formats benefit greatly from compression, however, typically they are tiny in comparison, they don't store that much data. If your game is 100MB, then the text-files maybe make 1MB of the whole game, even if you can make them 100KB through compression then you only won 900KB, less than 1%, hardly worth the effort. You might even want to use the file system directly instead of using a virtual, zip based file system. It would make patching very easy: you can just swap out any files you modified. 

Basic rule of thumb is: Don't artificially handicap the player. It is each players own decision if they want to invest into better hardware so they can play the game better. You wouldn't limit the framerate to 30 so that people with better GPU have no advantage over people with a bad GPU due to more fluid gameplay, you wouldn't limit the update rate of the input so that people who invested in better mouses or keyboards would have no advantage. It's not your role as game designer to play the judge for those who like to play competitively with sub-optimal hardware. The games you mentioned do nothing, and as far as I know there are no games who do such a thing. There maybe a few games who make the amount of displayed content independent from the resolution, but most likely out of reasons of artistic control not because of the idea of fairness. If the limited amount of visible information is important for the gameplay, you might want to apply techniques like "Fog of War". 

What needs some consideration however is when you are going to load the next map. Given that the maps are not especially big, the thing that actually will take the longest is waiting for the server to deliver the map. The actual loading will only take a few milliseconds. But this waiting can be done asynchronous, it doesn't have to block the flow of the game. So the best thing is not loading the data when needed but before. The player is in one map, now load all the adjacent maps. Player moves in the next map, load all adjacent maps again, etc., etc. The player won't even notice that your game is loading in the background. This way you can also create a illusion of a border less world by also drawing the adjacent maps too, in that case you need to load not only the adjacent maps but also those adjacent of those, though. 

Send the changes, not the data itself. Maps, items, monsters and players should be submitted once while loading, and then only send updates, like "player Z has moved to tile X, Y" or "tile X, Y has become water" or "monster Z shouted" 

Calculate the time needed to reach the target point. Calculate at what position the planet will be at the calculated time. Move towards the calculated point. Repeat 

You can give every turn a fixed time length, for example say 5 seconds, then every player has 5 seconds to react. 

Basically you have two components per coordinate, the position and the velocity. Now every frame the gravity is applied to the y-velocity and checked for collision, in which case the y-velocity is zeroed (= not moving in y direction). Moving left and right is done the same way, just that it isn't affected by gravity. 

There is a bunch of free music at OpenGameArt, and by free I mean completely free. However the best option might be to get a actual musician into your team, having music tailored towards your game is a big plus to the feel of the game. And unless you ask a experienced professional it shouldn't be more costly than "buying" existing music. 

There simply is no reason why you would want threads. Threads have two use-cases: performance and asynchronity. The performance isn't a problem and there is no reason to do it asynchronous. Threads aren't to be taken lightly and don't simplify anything. Splitscreen multiplayer only requires you to code a few things: a camera for each player, input managment for each player and On-Screen-Effects for each player seperate. Also the AI or other gameplay elements need to be aware that there are multiple players. This is trivial in comparison to what it would take to write a threaded solution. 

However, sometimes you get don't get around ratios like 1:3.5632, in this case a truly pixel perfect line is not possible. A common approach is alternating between different length line segments and this will also be the case in Bresenham. 

Everthing else really depends a lot on the kind of game the engine is made for. Particle effects might be useful for a action game, but maybe not so much for a strategy game. Same for physics. Some games work best with tile maps, while others may work better with some kind of polygon landscape or a landscape made of decals. Story heavy games need a proper way for handling cutscenes. A jump and run engine would need the functionality to handle slopes. etc. etc. 

For 2D Graphics you can use the Painter's Algorithm, or alternatively the Reverse Painter's Algorithm. Means you have to draw the pupil first, then the face. The face will be drawn over the pupil this way. For 3D Graphics that's not sufficient, you need to give everything a Z-Coordinate and activate Depth Testing. 

In the case of a video game it is a optimal reward since the cost per digital download, for you, the developer, is nearly 0. This should be your basic reward, everything above should just be extras for those who want to fund you more. Some viable extras would be: 

Simple, when it runs slowly. (Or consumes a lot of memory.) Premature Optimization is optimizing things without reason, e.g. before you run into any problems because of the performance. For example when you optimize your path-finding algorithm just because it can be faster, not because you noticed that your path-finding takes up a too large part of your CPU time. That's just bad because optimization is a trade off, when you code you should code for maximum readability and maintainability, not for tiny performance benefits. Highly optimized code is usually hard to understand and thus hard to maintain. Make a goal what kind of hardware you want to support and test your game on that hardware. Does it run at full speed? Then it's okay, keep on coding. If not profile it, check what parts are making it slow and optimize those parts. 

About 2D-Performance First some general advice: 2D isn't demanding for current hardware, even largely unoptimized code will work. That doesn't mean you should Intermediate Mode though, atleast make sure you don't change states when unnecessary (for example don't bind a new texture with glBindTexture when the same texture is already bound, a if check on the CPU is tons faster than a glBindTexture-call) and not to use something so totally wrong and stupid as glVertex (even glDrawArrays will be way faster, and isn't any more difficult to use, it's not very "modern" though). With those two very simple rules the frame time should be atleast down to 10ms (100 fps). Now to get even more speed the next logical step is batching, e.g. bundling as many draw calls into one, for this you should consider implementing texture atlases, so you can minimize the amount of texture binds and thus increase the amount of rectangles you can draw with one call to a large amount. If you now aren't down to about 2ms (500fps) you are doing something wrong :)