here is what I did: I focused on the statements since it seems they are almost identical. it turns out they differ in one letter in the resource name. So it makes sense to create a method that recevies this letter. There is also duplication in the clauses, so I replaced the with an that separates clause from the rest: 

Note: the posted code does not specify how and which are mentioned in the statement are declared. note that these will have to be final in order to be included in a lambda expression. 

instance variables and never get initialized and are never used. input file is never closed. some variables are declared out of the scope they should be. For instance in is declared outside the loop but is initialized and used only inside it. It will be more efficient to read the entire input file to memory. Java 7 has methods that do just that and that returns of s according to the input lines so you already know where new line was in input There is no exception handling. to have throw the exception is not good practice for exception handling. 

those variables: not only do they seem redundant, they actually breach thread safety. variables are used when you actually want the variable to be accessed by multiple threads (for example, when you want one thread to set a boolean and then have another read that variable). as far as I could detect, the two variables can be replaced by local ones. those calls: they are mostly redundant. the method is only useful if a client thread has called . that is usually the case if the queue is empty and a client wants to block until a new item has ben added. if the list is not empty, the client usually pops an item and goes about processing it. so you need to understand when clients will want to wait for an event to happen and get notified about it. Secondly, calling only makes sense if you release the lock immediately after the notification. calling in a loop without releasing the lock will not do anything. as an exercise, this solution will work. However, it is not efficient. synchronizing all the methods mean that any access to the queue will prevent all other access. for example, if one thread calls it has locked the entire queue. you may think that is such a small method, but what if the thread just entered the wethod and got a context switch from the OS. it can wait for 2-3 milliseconds before releasing the lock (and that is a long time in the computation universe). so in order to be more efficient, you need better granularity on the scope of the locking. For example, set a boolean if the queue is in the process of being modified and only at these times lock the reading methods. and you can get more efficient with more sophisticated (and complex) mechanisms (like locking only part of the queue this is being modified etc) ALL_CAPITAL names in Java (and other languages), are used for constant variables, not for those that hold state. (i.e. recevied from arguments). even if they are immutable. 

naming convention for Java variables is camel-case, meaning they should start with lowercase letter (I am referring to the argument) 

First of all, a bug fix: the properties of that are to be shared with the sub classes should be defined as protected and if they are to be accessed by client classes, they need to be public (or have public getter methods) now for the answer: you can (and should) have separate setter method for each property. this will allow to create concrete instances and then assign any number of properties after constructor is finished. 

holds list of s holds list of s is able to identify by its or + This relation is represented as and is helper class that holds + and is implements is able to identify by its or (putting aside for the moment that multiple users can have the same name) This relation is represented as and class is responsible for maintaining lists of s and s. that includes adding and removing items fron those lists (maintaining the maps) so here is the flow of renting a book: 

so I took these differences as arguments to the new method which contains the similar part of the if statement with the arguments specified in the correct places. I also beautified the code a little: no need for parenthesis in condition and broke down the two outer if statements, allowing for an construct. The end result is below 

Regarding complexity, I admit this is not my expertise. However, I do not see any signs of exponential iteration on the data structure. Your algorithm may improve upon the performance of classic bubble sort, but complexity is about scaling: comparing the performance of the same algorithm on input that is increasing in size. I'd say complexity here is the same as classic bubble sort, which is O(n^2) Note: a more robust and extensible design will say that you need to decouple the data structure from the sorting algorithm (much like the Java Collections framework) so that you can apply your improved algorithm not only to array of integers. But I think that is an "advanced" topic that requires deeper study of advanced OO principles. 

Design As was mentioned in the bugs section, the design of the ATM requires that you create a new ATM instance for every customer. In order to fix this, let us imagine how a real ATM probably works: One ATM machine can serve customers from multiple banks. When a customer enters the card and a PIN number, the ATM identifies the bank and sends these details to it. The Bank holds the list of its customers and is responsible for authenticating them. After the authentication process is over, the ATM will get a instance. The ATM will use this instance to do the balance queries and modifications. At the end of the process, when the customer gets his/her credit card back, the ATM machine should send the object back to the bank so it can update its internal records. Translating this into OO design. We have the following Classes: a class much like the one you have. a class that holds a (or any other collection/data structure) of s. The exposes a and methods. the also does the authentication. the ATM class gets a (or any other collection/data structure) of s in the constructor and should be able to identify the bank from the customer's account number. We can say that the first two digits are the bank ID. this design is both robust and modular. It allows each bank to do their own book keeping, customer authorization etc. If this looks like an overkill, then You can say that the ATM handles customers from one bank (make sure to mention this in a comment so it is known that you didn't omit this considearion). In this case, an ATM should maintain the customers list (probably get the list in the constructor). Best Practices 

this if statement surely does not do what is intended of it. Moreover, it is redundant because you already ask on equality of the acct and pin. so in the clause you know that at least one of these fields is not the correct value. You never set the variable to . The instance variable of the is never used beyond the constructor. The instance variable is declared private. This means that each of the two ATM classes has its own private variable. Not that I understand what is it for, because - Your list of customers never gets populated. In fact, in the current state, an instance of an ATM machine can handle just one customer. The list is also names which is misleading. at the very least it should be something like The two variables that are shared between the two ATM classes (the list and the boolean) are declared in the default "package private" accessor. Altough it will work (they can be accessed and modified by the two ATM classes) this means that classes that are not ATM but are in the same package can accessed these variables too. The variables should be declared in order for them to be shared only by the ATM hierarchy tree. The nested if statements in are redundant. Perhaps the comment was an attempt for an explanation but it is neither clear nor correct. The exercise stated that the withdrawal and deposit limits are per day. This is not addressed in the solution. 

Basically, its good. Here are my (small) comments 1) in you can replace the loop with 2) I would make an enum. This has two benefits: 

since you requested to focus on effeciency only, I will do just that, although there is a lot to be said about the quality of the code. first of all, why do you split the line on white space only? what if there is a tab between the words? you should use the predefined class which includes all white space characters (incl' tab, new line, and more) secondly, you do the split into an array, then add the items one-by-one into a list and then search the list using why not use the loop on the array to compare its items to and just increase a counter? this saves the loop inside (for sure there is one) and also does not require to load all words of a file into memory EDIT following the comment below: if you need to update the file, there is still no reason to load the words into list. for one, in the list you lose the separation to lines so you will write just one line to the new file? second, why not read one line, process it (either count or make a new modified line) and write the modified line to the output? (modifying a file inline is not recomended!) regarind code quality, you process a single file separate from processing directory. but processing directory is processing single files in that directory so why not put processing of single file in a separate method and then you can call it for process a single file or in a loop for files in the directory 

This design also greatly simplifies the code for deciding what to cast (hint: oyu can get to an enum instance from its String name using ) now what about maxLevel? is it the same for all skill types or different? Moving on: in your game, every has the same set of skills. that's fine. but every develops differently and this should be reflected by individual Skill instances together with the attributes that can modify a basic `Skill' 

3.2) input to only accepts file name in . this is too limited for two reasons: First, consider the case of a client that already constructed a instance and now has to convert that to a for you. The bigger issue is the case where the client already opened the file. also, the client may wish to have control over the lifecycle of the file. This is of course true for file load and write. at the very least you should provide overloaded constructor that accepts and one that acepts (and in this case do not close it). You may ask why and not . well, you can have overloaded constructors for both. but I think an is enough. You can open a from an . is used in more cases than . For example, a common usage is to open one from an HTTP request. 

there seems to be logical falacy: what if returns false but no exception is thrown? there is no else clause there, and would return no virus found. instead of returning , why doesn't re-throw the exception? that way, it can also return a String of a virus name (or whatever is produced from ) instead of passing the String, make it public. then any class can refer to it as better still, make an enum out of the constant. that way, you can add values to the enum (like ...) 

When I encounter similar cases, I use the Apache Commons Lang library. It has a class with all sorts of useful String utilities. For null-safe check if a String is not all whitespaces, you can use the following: 

then, instead of returning the exception message, throw the custom exception. the return value is freed to return more rich data from the scan (if possible): 

the operator in startX index (adding and substracting 1) the team compared against - it is the opposite team of 

this way, a string that is longer than 1 letter will pass the condition without any examination of contents. 

I do not understand why you have and variables. they seem to serve the same purpose of variables in the super class. You do realize that s does not override s ? 

while it is convinient to use , under the hood, the method will perform all the steps that are required to match an input to a regular expression, including compiling the pattern. since this line is performed inside a loop that reads a (possibly big) input file, you may have a performance issue here. A better approach would be to create a Pattern instance via the factory method and then use a over the input. an even better approach (in terms of performance) would be to ask if a regular expression is required. yuo are testing whether the string is a single letter. This can be replaced by quering the String's length and then quering the contents of the (only) character. Something like 

the quality of the code is indeed not very good. The first and foremost reason is that all the algorithm is coded in one, long, winding, spaghetti-smelling piece of code. in addition, the variable names a non descriptive and there is shortage of comments. Start by breaking up this code into logical pieces: , , (you will need to figure out the args) The three methods should be broken down further. furthermore, You need to use methods in order to give meaning to technical pieces of code. For instance this line 

MySQL version 8 supports common table expression. If you want to differentiate between the three sub queries, use a column containing literal: 

the File handlers ( and ) are defined outside of the block, are opened at the beginning inside the block are closed in the clause.