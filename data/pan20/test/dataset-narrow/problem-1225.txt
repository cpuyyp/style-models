Of course, these examples alone merely suggest that "an" is acceptable. This list does not show that "an" is necessarily standard or preferred nor does it show that "a" is unacceptable. 

Shoudai, Takayoshi. "The lexicographically first topological order problem is NLOG-complete." Information processing letters 33.3 (1989): 121-124. 

We leave as an exercise to the reader to prove that this procedure reconstructs a spanning tree $T'$ with the same weight as $T$. (Outline: each edge added in step 3 preserves acyclicity and no components of $T\setminus S$ can remain separated). These necessary and sufficient criteria naturally suggest a poly-time algorithm for determining if $G$ has a valid $k$-AVE set. First, construct a MST $T$. For each $e\in T$, we compute the cut-set $C_e$ and the set of minimum weight edges in $C_e$, $M_e$. If for some $e$, $|M_e| \leq k$, then we can simply take any $S \supseteq M_e$ as our valid $k$-AVE set. Otherwise, if all $M_e$ sets are larger than size $k$, we conclude that $G$ has no $k$-AVE set. 

Start at $u_1$. Visit each neighbor of $u_1$, returning to $u_1$ after each visit. I.e., if the neighbors of $u_1$ are $u_{n_1}, u_{n_2}, \ldots, u_{n_d}$, we have the following sequence: $u_1, u_{n_1}, u_1, u_{n_2}, u_1, \dots, u_1, u_{n_d}, u_1$. Travel to $u_2$. Visit each neighbor of $u_2$. etc... 

Some of the work on sensitivity vs. block sensitivity has been aimed at examining functions with as large a gap as possible between $s(f)$ and $bs(f)$ in order to resolve the conjecture that $bs(f)$ is only polynomially larger than $s(f)$. What about the opposite direction? What is known about functions where $s(f) = bs(f)$? Trivially, constant functions have $0=s(f)=bs(f)$. Also trivially, any function with $s(f) = n$ also has $s(f) = bs(f)$. It is non-trivial but not too hard to show that any monotone function also satisfies this equality. Are there any other nice classes of functions that have $s(f) = bs(f)$? A complete characterization would be ideal. What if we further strengthen the requirements to $s^0(f) = bs^0(f)$ and $s^1(f) = bs^1(f)$? The motivation for this question is simply to get some intuition for how sensitivity relates to block sensitivity. Definitions Let $f:\{0,1\}^n\rightarrow \{0,1\}$ be a Boolean function on $n$-bit words. For $x \in \{0,1\}$ and $A \subseteq \{0,1,\ldots,n\}$, let $x^A$ denote the $n$-bit word obtained from $x$ by flipping the bits specified by $A$. In the case that $A = \{i\}$, we will simply denote this as $x^i$. We define the sensitivity of $f$ at $x$ as $s(f,x) = \# \{ i | f(x^i) \neq f(x)\}$. In other words, it is the number of bits in $x$ that we can flip in order to flip the output of $f$. We define the sensitivity of $f$ as $s(f) = \text{max}_x s(f,x)$. We define the block sensitivity of $f$ at $x$ (denoted $bs(f,x)$) as the maximum $k$ such that there are disjoint subsets $B_1, B_2, \ldots, B_k$ of $\{1,2,\ldots, n\}$ such that $f(x^{B_i}) \neq f(x)$. We define the block sensitivity of $f$ as $bs(f) = \text{max}_x bs(f,x)$. Finally, we define the 0-sensitivity of $f$ as $s^0(f) = \text{max} \{ s(f,x) | f(x) = 0 \}$. We similarly define 1-sensitivity, 0-block sensitivity, and 1-block sensitivity , denoted $s^1(f)$, $bs^0(f)$, and $bs^1(f)$, respectively. 

I think we can show that Problem 2 is tractable by showing the following: 1) the set of paths in G is a regular language, 2) the set of $NODESEQ$s has a compact description as a regular language. Problem 2 is thus reduced to checking if the intersection of two regular languages is non-empty. Some preliminaries: Let $|V| = n$. Let $k$ be the length of $SEQ$. We will change terminology from the question a bit and define $NODESEQ$ to be the set of all strings of length $k$ over $V$ that result from a relaxed node assignment (both valid and invalid). Let $P$ be the set of paths (both simple and non-simple) in $G$ beginning at the source node and ending at the sink node. Considering $P$ to be a set of strings over $V$, it should be evident that $P$ is a regular language accepted by a finite automaton (FA) with $O(n)$ states. Next, we define the following: given a sequence of variables $SEQ$, let $NODESEQ(x_i = v_j)$ be the set of strings over $V$ obtained by substituting $v_j \in V$ for the variable $x_i$ in $SEQ$ and allowing all other variables to be free. For example, if $SEQ = (x_1,x_2,x_3,x_4,x_2,x_3,x_5)$, $NODESEQ(x_2 = v_3)$ can be represented by the regular expression "$. v_{3} . . v_{3} . .$" (the dots represent any element of $V$). Now, we make two crucial observations: 1) Each $NODESEQ(x_i = v_j)$ can be recognized by an FA with $O(k)$ states and 2) $NODESEQ = \cap_{i=1}^m \cup_{j=1}^n NODESEQ(x_i = v_j)$. Recall that if $L_1$ and $L_2$ are regular languages recognized by FAs with $n_1$ and $n_2$ states, respectively, then $L_1 \cup L_2$ and $L_1 \cap L_2$ can be recognized by an FA with $O(n_1 + n_2)$ states. Thus, we conclude that $NODESEQ$ can be recognized by an FA with $O(kmn)$ states. Finally, we note that a valid relaxed node assignment exists if and only if $P \cap NODESEQ$ is non-empty. Since we can build an FA for $P \cap NODESEQ$ with $O(kmn) + O(n) = O(kmn)$ states, I would call this problem tractable. I would also note that the source and sink don't appear to play a material role in this problem. The construction of $P$ as a regular language is pretty much the same without enforcing the source/sink constraint. 

Problem: I am looking for an algorithm which finds all vertices that are adjacent to exterior region of a planar graph(For a planar graph, any region=face can be considered as the exterior region /face). Attempt: Using the planarity check algorithm, an algorithm can be constructed with polynomial bound. Questions: My questions are- 

Are there any literature /algorithms regarding the problem? Can the problem have a log-space time algorithm (without using planarity check algorithm)? 

Notation: Let $X = (V,E)$ be graph, $e = (v_1, v_2) $ an edge of $X$. The vertex set $V_k$ be the set of vertices of distance $k$ from $e$, and let $h$ be the height of $X$. According to definition of $V_k$, $V= V_0 \cup V_1 \dots V_h$ and $V_{(h+1)}= \emptyset$. Let, subset $E_k$ of edges of $X(0 \leq k \leq h)$ is defined as- $E_k = \{ (u,w) | u \in V_k, w \in V_ k \cup V_{(k+1)} \}.$ The subgraph $X_i$ is defined as- $X_k= (V_0 \cup V_1 \dots \cup V_k, E_0 \cup E_1 \dots E_{(k-1)} \}$ For example, $X_2 =\{ (V_0 \cup V_1 \cup V_2, E_0 \cup E_1)\}$ $Aut_e(X)$ is the automorphism group of graph $X$ where $e$ is fixed. If $B$ is a generating set of $Aut_e(X_k)$ , we write $\langle B \rangle = Aut_e(X_k)$, for example, it is clear that $Aut_e(X_0)=\langle(v_1,v_2)\rangle$ where $ (v_1,v_2)$ is a permutation of vertices $v_1, v_2$ of $X$. Principle Constructing generating set of automorphism group of $X$ is a GI (graph isomorphism) complete problem [1]. So, if we can compute generating set of automorphism group of $X$ (which has bounded valance in polynomial time), we can solve GI in polynomial time. So, we wish to determine $Aut_e(X)$. Technique: We will construct $X_0, X_1..... X_h$. For each, $X_k$ we will construct $Aut_e(X_{(k)})$ Note that, a permutation of $Aut_e(X_{(k) })$may be extended to an automorphism of $Aut_e(X_{(k+1)})$. So, generators of $Aut_e(X_{(k+1)})$ can be obtained from generators for $Aut_e(X_{k})$. To construct generator, structure-type of $E_k$ is manipulated. The structure-type of $E_k$ can be divided into finite classes. For example, in the trivalent case, there are only six type (only five of those cases can actually occur). We will classify the edges in $E_k$ into types and will group them into families . This helps to create a number of unique labels. For a fixed valence, the number of labels is small. At this point, we use the concept of setwise-stabilizers to find permutations which acts on particular label. In the process, we find the generator of $Aut_e(X_{(k) })$. Then, we use the generator of$Aut_e(X_{(k) })$ to find the generator of $Aut_e(X_{(k+1) })$, as stated earlier. Proceeding in this manner, we obtain, $Aut_e(X)$ . 

$G, H$ are strongly regular graphs with parameter $(n, r, \lambda, \mu)$ where $\lambda$ is constant. Here, $n$ is the number of total vertices. Each graph is $r$ regular. Every two adjacent vertices of $G$ and $H$ have $\lambda$ common neighbours. Every two non-adjacent vertices of $G$ and $H$ have $\mu$ common neighbours. What is the computational complexity of Graph Isomorphism Algorithm of Strongly Regular Graph where $\lambda$ is constant? 

Motivation: Trying to find the outer cycle of a planar graph quickly to reduce the complexity of Hamiltonian circuit problem. 

Feel free to down-vote, but please leave a comment if you have anything technical to say, Thanks for your patience. 

The computational complexity of of finding $P$ is polynomial in $\beta$. We construct the generating set of automorphism group of $H$ using $\beta_k$, for all $k$. As we know, constructing generating set of automorphism group of $H$ is a GI complete problem [1]. So, we try to construct the generating set of $Aut(H)$ . The technique used in the paper [2] by E. Luks can used here. Notation: From now on, $G, H$ are adjacency matrices of graphs $G, H$ respectively. $H_k, G_k$ are blocks or sub-matrices of matrix $H, G$ respectively. The adjacency matrix of graph $H_k \cup H_e$ is $M_{(k,e)}$ where $M_{(k,e)} =\left( \begin{array}{ccc} H_e & R_{k,e} \\ R_{k,e}^{T} & H_k\\ \end{array} \right) $, where, $R_{k,e}$ is the non symmetric sub-matrix of adjacency matrix $H$. Here, $R_{k,e}$ represents edges between $H_k, H_e$. Similarly, $S_{k,e}$ represents edges between $G_k, G_e$. $$H = \begin{bmatrix} H_{(x)} & R_{(x, x-1)} & R_{(x,x-2)} & \dots & \dots & R_{(x,1)} \\ R_{(x,x-1)} & H_{(x-1)} & R_{(x-1,x-2)} & \dots & \dots & R_{(x-1,1)} \\ \vdots & \vdots & \vdots & \ddots & \ddots & \vdots \\ R_{(x,1)} & R_{(x-1,1)} & R_{(x-2,1)} & \dots & \dots &H_{1} \end{bmatrix}$$ For simplicity, we assume $\beta \leq n^{3}$. The outline of the algorithm to construct generating set: At $1^{st}$ iteration - Step 1. Construct all possible direct product $(\pi_1 \times \pi_2)$ where $\pi_1 \in \beta_1$ and $ \pi_2 \in \beta_2$. There are $| \beta_1 | \times | \beta_2| < n^{9}$ direct products (permutations). All these permutations (direct products) form set $\gamma_1$. Each element of $\gamma_1$ is a permutation that acts on graph $H_1 \cup H_2$. Step 2. Construct/find - $\alpha_1 =\{ \pi \in \gamma_1 | (M_{(1,2)}^{\pi}= M_{(1,2)}) \land ( R_{1,2}^{\pi} = S_{1,2}) \land (H_1^{\pi} = G_1) \land (H_2^{\pi} = G_2) \}$ $\alpha_1$ is the set of automorphisms of matrix $M_{(1,2)}$. $|\alpha_1| < n^{9}$.There are two possible cases- Case 1: If $|\alpha_1| =1$, then for each $\pi_1 \in \beta_1$, there is only one permutation $\pi_2 \in \beta_2$. So, there could be maximum $n^{2}$ permutations in $\gamma_1$ but only one permutation could be included in $\alpha_1$. Case 2: If $|\alpha_1| >1$, we would be able to construct a generating set $\mathcal{S}_1$ of an automorphism group of $Aut(M_{(1,2)})$ Note, that if $\exists \pi_a \in Aut(H)$ such that it acts on vertices of $H_1 \cup H_2$, then $ \pi_a \in \langle \mathcal{S}_1 \rangle =Aut(M_{(1,2)})$. So, when we construct direct product of $\mathcal{S}_1$ and another set, $\pi_a$ can be found in the resulting generating set. See Theorem 7, on page 31 of [3].The theorem showed how to obtain the automorphism group of an arbitrary graph from the intersection of a specific permutation group with a direct product of symmetric groups. Step 3. Now, we construct the generating set $\mathcal{S}_1$ from $\alpha_1$. This construction of generating set can be done in polynomial time (see [3], page 40, theorem 9). From [4], we find that $|\mathcal{S}_1| \leq log(n!)$ . $\mathcal{S}_1$ is the generating set of automorphism of $H_1 \cup H_2$ . Step 4. We start $2^{nd}$ iteration, for $\beta_3, \mathcal{S}_1$ (instead of $\beta_2$), $ M_{(2,3)}$ where $M_{(2,3)} =\left( \begin{array}{ccc} H_3 & R_{2,3} \\ R_{2,3}^{T} & H_2 \\ \end{array} \right) $. We find $\gamma_2, \alpha_2$ repeating steps $1,2$ and construct $\mathcal{S}_2$ (repeating step $3$) which is the generating set of automorphism of graph $H_1 \cup H_2 \cup H_3$. Note that, $|\mathcal{S}_2| \leq log(n!)$ . Step 5. We keep repeating above four processes, until we find the set $\mathcal{S}_{(x-1)} $ which is the generating set of automorphism of graph $H_1 \cup H_2 \cup H_3 \dots \cup H_x=H $. Note that, $|\mathcal{S}_{(x-1)}|\leq log(n!)$, since $ \langle \mathcal{S}_{(x-1)} \rangle= Aut(H) \leq S_n$. Detecting Isomorphism: We repeat the process of construction of $\mathcal{S}_{(x-1)}$ for graph $G$ and obtain set $\mathcal{R}_{(x-1)}$. I assumed, that the oracle that gave $\beta_k$, would provide permutation sets for $G$ also. Once we generate generating sets of $G, H$, we can decide isomorphism betwen them [1]. References: [1]Mathon, Rudolf. ,A note on the graph isomorphism counting problem, Inform. Process. Lett. 8 (1979), no. 3, 131–132. [2] Luks , Eugene M. , Isomorphism of graphs of bounded valence can be tested in polynomial time, Journal of Computer and System Sciences, Volume 25, Issue 1, (1982), Pages 42-65. [3]Hoffmann, Christoph M. ,Group-Theoretic Algorithms and Graph Isomorphism. [4] Miller, Gary L. ,On the $n^{\log_2(n)}$ Isomorphism Technique.