Radioshack sells a VOM that has a serial port and a API to interact with the meter. You could get a "premade" device such as this if it has a customizable API. Then just code a pi interface to it. edit: requested link RadioShack 22-812 

Effectively you would power a small router or something that provides a external connection (from the same power source) that can cause a drop in LAN connectivity on the pi if it is shut off. It would have to be something that has a lower tolerance for power drops than the pi so it shuts off first. Then on the pi you have it ping that LAN and if it does not show connected it does a 'shutdown now' Granted this would reduce battery life considerably, but it is a non-GPIO/hack to achieve what you are looking for. 

Boot to recovery with a working internet connection. It should show in the list. If you don't have a internet connection on instal it seems to hang as the win install bits try to authorize your Microsoft account for the install. 

Have a look at htpasswd from apache: htpasswd The steps to create this can be quite confusing, but in the end you can lock out ANY endpoint url/directory on your server with a user/password prompt. Key notes from this link in case the link changes: 

The only way a windows .exe will run on anything linux including the pi is through wine. I am not sure if there is a pi compile of wine as I would never try it. For a .jar these are java scripts. Again not sure if pi has a JRE (java runtime environment) as I would not have a reason to attempt or research this. The .dmg was already answered. You may want to look into linux basics guides and such on files and programs. Then look at specific platforms/architectures. The pi IS a linux box, but on arm not x86 intel. 

If you are primarily a Python programmer then of course the Python library makes sense, but I suspect it is pretty slow, for example to continuously toggle an output pin, relative to how fast this could be done with native code on the ARM chip, especially running single threaded. Most conventional interfacing to the GPIOs is done by reading and writing values to their file mapping at . This is the "normal" Linux way of interacting with devices, by representing them as objects in the file system that can be opened, read, written, and closed, for example by using POSIX functions. This has the advantage of making a unified interface for everyone using the OS, and need not require root access. I presume that Python and other libraries use this method under the hood. The downside is that there is a lot of code overhead to do a simple thing like setting a GPIO pin high. The library that you reference bypasses all this by directly reading and writing to the hardware GPIO registers that control the pin functions. To do this within Linux requires first that some initialization code opens and gets pointers to the internal memory for the BCM 2835 device registers. This can only be done by root, so it's not so convenient on a multiuser machine. The advantage however is that changes to pin state require just a line or two of C code and so access is very fast. But note that Linux is not a real time operating system and so there is no guarantee that the code won't get constantly interrupted because of the normal multitasking process. So you still won't be able to, for example output a high frequency square wave by programmatically writing 1s and 0s without considerable timing jitter, because the CPU might be required to frequently go off and spend a few milliseconds doing some other task. The various hardware timer modules should instead be used for producing accurately timed waveforms. Another potential down side is that using direct access bypasses the OS. This means that the states of the pins are not being correctly reflected in the file system representation, and this could potentially screw with any other processes that try to access devices the conventional way. So the advantage of the low level C library is speed, but it requires root privilege and makes changes that the OS is blind to, potentially causing problems with other code that tries to access the ports. 

The reasoning behind the JS popup is, those can trip up generally simplistic written brute force scripts. Then redirect the page to drop session and go to another page for added complication for any automated hack attempts. Additionally you could lock out all IPs but specific ones to allow connections: 

I would think some existing UPS units designed specifically for the pi would be a far better approach. Some can allow for additional battery for longer life. I think if I remember correct, some can initiate a shut down on low battery as well. On top of this, I found a nifty design idea for something that may work. Raspberry Pi UPS Quoted from this link is the part I want to convey here: 

I also personally recommend using php pages and wrapping generated html in echo or return blocks. Thereby not exposing any function code to the browser. Like so (ultra simplistic example, showing only the result of $bar, but not how it was assigned.): 

Beyond this, for brute force you could have a sql database logging connection attempts from the remote machine by IP and time stamp, blocking repeated attempts within a set time frame.. You would generate a sql entry based on these variables: 

Set the piece in place and use a paper clip to hold it, then use a heat gun on low air setting to solder it in. It will take some time to get it to the right heat and do not bump the unit at all during and for 5 mins after. Flat level stable surface and try to keep the heat off the rest of the board as much as you can. Also since it is near the SD slot where there is likely plastic in it, use some form of shield on the side of that to deflect heat from the slot. To answer the other question, it is likely a capacitor if it boots fine. I don't have a zero nor know where the schematics are off hand. But running it without the capacitor can be dangerous to the stability of the unit. Depending on what circuit it is for, you could "spike" voltage or have a voltage drop which depending on tolerances could fry other components. 

Using python on the PI this is petty easy. I didn't test this code but check out this page as a reference $URL$ 

Also use the to see more of what is happening and to check if any slow software format conversion filters are being auto inserted. To be honest it sounds like a CPU bottleneck because the option that works best for you is to encode the audio and then after that encode the video and stream with the pre-processed audio. Your first two scenarios have the CPU doing both things at the same time. To reduce video encoding load you should look towards reduced frame rate, reduced frame size, lower bitrate, and any other speed setting optimizations on the encoder. 

The main priority is to determine where the bottleneck applies. It could be with computational load or with excessive total bitstream rate. It would first be a good idea to eliminate the video, especially as you're doing nothing obvious to set its bitrate or framerate. You only have for the video options. You don't say anything about testsrc. All the video data in the RTMP multiplexed stream needs to be sent over your internet connection in a timely manner and data rate will have a big effect on the quality of your stream playback so you probably need to tune your video encoder. You can find the full list of video encoding options using . Try running ffmpeg without the audio, and then without the video while monitoring the CPU usage and final bitrate to see if either is excessive. Since you want an RTMP stream you should do this by replacing video or audio with a small black frame or with silence so you always have both audio and video in the multiplexed stream. For example to reduce video load, use options like: 

I tried Ubuntu 16 once, nothing worked well at all. Slow as you state, the packages that installed were not up to our project standards we have (example mysql was impossible to remote into). Various bugs elsewhere too. Symlinks failed to work correctly. Set a link and it was like running down a tunnel that wrapped back on itself. So far Raspbian runs very smooth and impressed with it's performance as a dev and server platform. I doubt Ubuntu 16 has the needed kernel compiles for the rpi. So it is bound to run horrible regardless unless you compile it yourself and find everything you need. That said, in short, you are not alone and that performance is normally experienced by many. However, I would seriously avoid clocking it up to boost performance on an OS that is not very compatible with it. You will be looking to replace it sooner than later. 

A function that generates a sql log query if desired called loginlog() Then use some php to fire off the check: This is just an example.. 

Analyze your running processes with htop or top. Figure out what is installed that you don't need running and disable or remove the packages (not for the feint of heart or linux beginner). Don't start the gui. Disable all logging or send logs to dev/null Make sure the PSU is supplying ample power as others have stated. You can overclock, but I wouldn't do this without good cooling and heat sinks. Externally power any addons. Then you should have as high performance as I could advise.