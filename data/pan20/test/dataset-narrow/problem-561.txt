Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

Space efficiency: Currently you are storing 50% of all values, this can be reduced to 33% quite easily by not storing any multiples of . (Excluding additional values is possible but complicates the calculation between value and index, you might have to check until which point excluding values is advantaguous.) Sidenote: You reduced the space consumption by the factor 2*8=16, not 64, compared to an implementation that uses a (at least for the OracleJVM). Performance: You are iterating over each bit, I would use to process the bits in blocks of 32 bits. You might want to use multiple threads to sieve, a simple implementation could use multiple threads to strike of multiples of different starting values. (For comparison: my quite similar implementation that skips multiples of (and uses instead of ) is around 25% (singlethreaded)/60% (multithreaded) faster than your current implementation.) Implementation: You don't need the variable as it is equivalent to . Your current implementation may overflow for larger sieve sizes. I would iterate over the indices rather than over the values to avoid converting while striking values off. Possible implementation (the resulting array should be encapsulated in a class that provides methods to operate on the sieved values): 

For O(1) performance you could precompute the factorials for values up to 12 (all factorials in int range). 

Currently each future processes elements (increasing the increases the total workload ()). Instead you want to divide the workload between each of the futures: 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

Besides that could (and should) be a local variable. The spacing between operators is inconsistent, you should add whitespace around the operators (except for unary operators) to improve readability. 

Minor changes As @coderodde already stated, there is not much to improve, nonetheless a few minor things: You can reduce the scope of the variables (which has always the same value as k prior entering the inner loop) and to the inner/outer loop. can be written as . Your inner loop starts at but only uses , you can start the loop at to avoid the subtraction. Depending on how s should be handled, you could use to throw a NPE if elements are present. If s are permitted, I would prefer that the string is added to the resulting array rather than a reference. You could start and at and use the (in theory) more efficient preincrement operator instead of the postincrement operator. Possible implementation (not using preincrement for and as I think it makes the code more difficult to read): 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

As previously mentioned by @GregBurghardt, just because you can doesn't mean you should. All of his reasoning holds true, and code readability should be your primary concern when writing code. Code shortness is one of the methods you achieve this, but if the code becomes too dense it is actually detrimental to the readability. Which, in turn, will lead to more problems with bugs and inefficient coding(!). I recommend doing it in the following manner. It will keep the repeated code to a minimum, while still ensuring that there are no warning/notices about missing variables or erroneous data. Plus it's very clear what the code does, and easier to understand why. (Comments can/should be added to further clarify why.) 

There are several points which can be improved, and by the style of your code I'm assuming that you are using this project to learn OOP..? First off, your questions: a) Since you are not outputting anything to the browser, or anything but an SQL server, this code has very few possible attack vectors. You are using prepared statements, which means that you have correctly protected yourself against SQL-injections. That is, as long as you've ensured that the strings are indeed valid UTF-8, before sending them over to the DB server. This is especially important if these strings comes from a browser, and not the code itself. b) Only two, really. Always set the timezone, and make sure it's set to the same timezone everywhere (and every time) you create a new time/date object. The timezone can/should be changed after creation, if it's necessary to change it. c) You seem to have taken the appropriate steps, at least in the code posted above. I've found a site listing the general steps for UTF-8 support in PHP scripts, which might be useful for you. That said, here are some points that could be improved in the code posted: 

First off I'd change the line retrieving the DB variables, from your $my_env array(?). I would rather implement a DB connection factory here, or even a singleton if it's a small enough project. (Or to learn singletons.) You've set the timezone using the old date_*() functions, which aren't really recommended any more. I strongly recommend looking into DateTime class family for date-time related needs. Even though you've set the timezone, the code you've posted doesn't actually use it. You've used SQL's NOW() function instead, which uses the DBMS' timezone. This can be an issue if the PHP code and the database server are using different timezones, and you're later on using PHP to manipulate/compare timestamps. You don't need to close the cursor, unset variables or anything like that. PHP normally does a perfectly good job of cleaning up afterwards, and it might even be detrimental to prematurely doing "cleanup". Normally this is only done when you have a specific use-case which requires you to clean up early. You have what is essentially three return values, to communicate whether or not the query succeeded. You only need one, which should be either "0" for not OK, or the ID for OK. Any error messages or such should be added to an error log, by a dedicated function for this. This one ties to the above, as the code should really be made into a function/method. This will allow you to maintain the code a lot easier, and make things quite a bit more flexible. The try-catch block encompasses a lot more code than it needs to, which makes it a bit harder to follow the control-flow than necessary. One should only encompass the functions that actually can throw exceptions, if one doesn't just let them bubble up to a layer which can handle them in the proper location in the code-flow. The connection class you have seems to have nothing to do with neither databases or connections to do, in fact it doesn't seem to following the OOP principles either. A method that simply takes input and returns output, without altering or depending upon the state of the object, isn't OOP. It just normal procedural programming, which is better done with pure functions. ;) 

The implementation 'does not count' as it overloads the method and does not override it. You can use generics to specify the expected parameter type. If you can change the interface: 

(I would initialize with a ternary operator instead.) Types As the values of , and are always in the range , you can use instead of for these variables, arithmetic is likely to be faster than arithmetic. Alternative implementation The remaining range is quite small -> you could cache the results for every number in the range to avoid calculating the sum on each invocation. 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

In the array version you can use post/pre increment and pre decrement (most likely no difference in terms of performance but shorter and in my opinion better readable). 

MyWord Your / implementation is not conform with the specification of - equal objects can currently return different hash codes. The implementation of should return the hash code of instead of . The constructor performs no argument checks -> it is possible to create i.e. an instance with , which will lead to s thrown by the method. The method could return . Alternative implementation A priority queue is not a good data structure to determine the frequencies as you have to iterate the queue for each input element. You can use a to convert the input array to the frequencies with complexity (plus additional to sort the resulting frequencies, or to create a heap). Using the stream api this could be written as: 

If you cannot/do not want to change the interface, you can use an intermediate abstract class to have the forwarding method only once for all implementations 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

Alternative implementation Your current implementation supports arrays with a maximum length of 30, you could provide a method to support arrays with up to 64 elements (or a larger datatype than to support way larger input arrays). 

Current implementation You can reduce the variable scope of your static variables by accepting the array input as parameter and returning the queue. You are currently iterating the queue three times if the queue contains the word (, iterator loop, ), this can be reduced to one iteration by only using the iterator. 

In my opinion returning an is the best option as the method requires ints, anything else would imply additional conversions. 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

This implementation still feels like a literal translation of the for-loop approach. Streams offer options to improve readability, i.e. the inner loop can be flattened: 

Palindrome Function You don't need this function at all because we know that if the string is not a palindrome, it is only off by one character. We were able to figure out the index of this character just by moving and Anyway, since the function returns a boolean, it should be named 

Now you can have a static interface to your class and still be able to limit the scope of your variables. 

I would also say that the user should have no idea about . A practical reason for this is that I, as a lowly stack user, have no idea what the most efficient is. The OO reason for this is that this is a detail that I do not need to care about. All I need to know about a stack is that it is a FILO container. I would expect it to have push, peek, and pop functionality. I don't care if it is implemented as a dynamic array, or a linked-list, or whatever. 

Forgive me, I've never written a word of PHP, and all of this under the assumption of possible. Making it's own scope would be a first good start. 

jQuery has , which seems to be what you are looking for: $URL$ Otherwise, if you don't want to use jQuery at all, you can make a for loop: 

As a side, your if statement isn't doing anything because both cases assign the value to configOptions. 

As general advise about naming, the words you are using to describe what is happening are good hints at what names the functions/class should be. For example, you use Doubly Linked List in the title of this post, and you use the word "popped" as output to the remove functions. 

I'll just say it, I don't like singletons. Rather than create static member variables, I would create static class functions: 

Flow The and s inside the while loop make me feel the loop is doing too much. I would say that the loop should be for moving and and then put the logic outside of it: 

assigns last to temp, which may be null. If the list is empty, you will call on null. Otherwise, it is a pretty well made list. I would change the names of your functions/class. 

The stack should be an incomplete type to the user. This is going to allow you to hide all of the implementation details of the stack. Right now, it is possible for the user of your stack to change the variables contained within the struct. 

Again, forgive me for not knowing any PHP. You may even consider making 'active' it's own scope as well, what good is it for an admin not to be able to find inactive and restricted movies? I would probably make the pagination it's own scope as well. 

Result The problem states that all strings that are not already palindromes are only off by one character. Our loop moved and such that if , then the string is a palindrome. It has also moved these indices such that if the string is not a palindrome, one of them is 'pointing' to the character that needs to be removed. To figure out which index is correct, I chose to compare the character pointed to by to the character pointed to by .