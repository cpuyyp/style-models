Not really much you can do about the aesthetics of Python's indent style. Perhaps you can do as such: 

Notice that your original answer does not catch nor raise an error when encountering a string val. I've reworked your code to this: 

To use, simply instantiate and echo output. Here, we do a regular state name, with no selected state: 

Note that we now import the package. We also changed the types of and to so that we may pass any type in. We then use the to glean the reflection of the value in the . We then glean the type with , and use a case to fall into our inner code if its a slice (can add more cases to extend this). In our inner code, we get the value of the argument, and store it in . We then iterate over the length of , and compare to at the index declared as an with and check for truthiness. If its true, we exit with a true and the index. Running the main function with both a slice of strings and a slice of integers, as follows, works: 

(Note that you don't actually need here, but I prefer to use it as a good practice for the case that I'm writing code where I don't deal with random access iterators.) This is the best solution I could come up with. If you have any improvements, be free to beat me to it. 

[Note: Java makes no guarantees about the time and space complexity of methods. Thus, could, in theory, also have a much worse time and space complexity if not implemented well. I assumed that it runs in O(n) (which is the best case) when matching on a single char only. This fact, of course, makes the second approach even worse.] 

should be the first modifier in most cases. Things like are bad because most people are used to thinking of it as an which is also , in contrast to a which is also (i.e. the first level of categorization is usually , then ). Leave a space between and the corresponding angle brackets/quotation marks. The fact that has a "meanings" comment hints you at the fact that you should probably choose better names for your variables. Usually, typing a few more characters is not going to hurt your coding performance very much (especially not in times of auto completion!) and will make you code much more readable. As a reviewer, I do not want to switch back to to look up the meaning of a variable every time I encounter one. should probably take its parameter by reference, because you are not actually doing any modifications to the object. You should rethink your approach on ownership. Currently, does not own its children, which means that they have to be owned by something else. That means that your whole design structure is not self-sufficient; you always need some kind of class that maintains a vector of all current , to which each of your s only holds a reference. You also need to make sure that none of the objects expire before your , or else you will run into undefined behavior. Also, if any of your are moved, you will need to update their reference accordingly in their , which is cumbersome at best and invokes undefined behavior at worst if you make a mistake. Thus, I suggest you to change the relationship into an owning one, and possible give out references or pointers to other users (also, you still need to face the issue of relocation and thus invalidation, which is why you will probably need another layer of indirection (i.e. a vector of )) If you want to begin your class definitions with the public members, I would recommend you to use instead, since all members of are implicitly public unless marked otherwise (still, this is very much a question of personal style) Use the correct integer types. For example, it appears that can never be lower than 0, so it should at the very least be . However, for variables denoting a length, is generally more appropriate (especially since you assign it the length of a string, which is also of type ). 

After that, I added a call to on the call so that all input is shunted to an integer. After that, we initialize our class to an variable. Then, instead of having multiple definitions for , , , and - we ask if the choice is in a list, define i/r/v/w. This lessens the amount of duplicated code: 

I just put this together, so I haven't tested it or anything, there might be bugs and someone else PLEASE come along and improve upon it, but I think this might be a good starting point to answering this question: OOP version of OP's code: 

I would really really recommend you go through and clean the code up - refactor refactor refactor, use best practices and as @peterhil said - read through the links and keep the HTML presentation away from PHP and JS and CSS. 

As N.B. mentioned in their comment - why are you implementing a method if we already have lazy loading via autoloading? I've even written a class that you can simply attach and not have to worry about loading your classes. Now, there are better autoloaders out there - like Symphony's ClassLoader/autoload.php. Anyways, here's your code, with my LazyLoader class handling the loading of methods (untested code). /LazyLoader.php 

You queue is nearly useless Harsh words. Why do I say something like this? The answer is: You only offer two methods to access elements. While this is conforming to the most basic definition of a queue, it's not very useful in everyday programming. At the very least, you should add an iterator interface, which would also allow your queue to interact with most standard algorithms and increase usability by a huge margin. Also, you should add some type definitions to conform to the standard's container library requirements. Some other things 

Don't use because it can introduce subtle bugs. Writing will probably not kill you, so keep your hands away from . One is enough. You don't need to prefix all your members with this, write it once and then just declare all members. This blunder is commonly made by people coming from Java or related languages, but in C++ public, private and apply to all following declarations until a different access specifier is encountered. The constructor should take a instead of an as a parameter, because you are passing whether to reset or not. Whether-relations are almost always expressed through . This 

There's a few glaring issues with your code. Namely your lack of consistent styling. Secondly, you're not doing certain things correctly (iterating over an array rather than imploding it). As this is a code review, I will not be touching on the correctness of the algorithm. Below you'll find two pieces of code - one which I've commented and corrected, and a second which I've removed my comments and old code. With comments: 

Also, instead of perhaps consider using . Perhaps someone with more experience with Nginx confs will follow up with a way to store certain bits and pieces in variables or will offer a better solution than mine (I for one would love to know a better way of doing things) 

I wrote a Player package in Go. It builds correctly, but I would love a review on what I did and did not do "the Go way". I'm new to coding in the language, although I've gotten about halfway through Ivo Balbaert's "The Way To Go". The code consists of a struct and a bunch of setters and getters for the struct. 

Putting all of this (and some bits of supporting code) together, a reworked version of your program could look something like this: 

Recently, I have gotten around implementing the rainfall challenge (which was the designated community challenge of August 2016) for practice purposes and would like to have some hints and improvements for my code. The implementation is in c++, and it is (in my opinion) quite lengthy, so please bear with me. The project is split into two files: , which contains a general class which stores elements in a normal (= one dimensional) vector while adding functionality for treating the vector as a two dimensional array. The other file, , contains the actual logic and code for the solution. The idea of this solution is to iterate over each tile of the map and tracking to which sink the water flows to (or to a tile of which it is known to what basin it belongs), keeping track of the amount of tracked tiles in the process. Although I did not actively optimize for speed, any hints on possible performance increases are very much appreciated (however, as I said above, all other hints and improvements are naturally welcome as well). 

Ok, this is your form.php code - what the users browse to. I've dropped in comments within the code - and also notice the addition of on . This will contain the PHP code at the bottom. 

Well - speed. The one liner mixture of , and is multiple times faster than the for-loop. Not to mention that it creates less work for the GC. I ran the two pieces of code above and this was the output: 

While we may have the overhead of instantiating a new object, etc - we save on a possible database call. Additionally, we no longer do multiple checks, but rather do one check for abbreviation preference and assume the non-abbreviated by default, as well as keeping it non-abbreviated sort by default. EDIT Since OP indicated that I was incorrect in my assumption that they were storing this data in a database, I've modified my above Class into a function which does the same thing: 

I would suggest using the system provided function over the custom memoization technique, so your code would look like 

There are some things to be said about your C version as well, but since you explicitly asked about the C++ version (and also because my C-knowledge is not that great), I will leave those for somebody else to comment on. General Hints and Tips 

Here are some more things that bother me a little (adding to what yuri already wrote in their answer): Design Ugh, globals Globals are bad. They introduce hidden state that the execution of your functions depends on, are difficult to track, are prone to the static initialization fiasco and so on and so forth. Instead of making a global that is accessed from in the shadows, add a dictionary parameter to . This will also make accomplishing point 3, localization, much, much easier, as you can then pass different dictionaries for different languages. Other tips and tricks 

You are passing by value where a pass by would be much more appropriate since you don't modify the string. Prefer early return over putting your whole code inside an if-else construct. To my mind, at least, 

is not a good practice, because it can make your code harder to read if you are using a lot of standard functionality and introduce hard-to-spot name resolution problems. While that is less likely to be an issue in short programs, I still advise you to not use it (creating good habits is worth a lot in the long run!). Don't do too much on a single line! In particular, don't , because, on the one hand, you are likely to forget an initializer or a part of a type here and, in the worst case, end up with undefined behavior, and, on the other hand, it is just hard to read for everybody not familiar with your code (such as I). Please split that line up into multiple definitions and declarations. Also, ... Initialize and use variables as locally as possible. This not only prevents scope pollution, but also increases the readability of your code. As a reviewer, I don't want to (and even cannot) keep a mental map on more than a handful of variables, especially if I have to remember them through large blocks of code where they don't even appear once. To my understanding at least, the term decimal implies floating point numbers, not just integers. Please think about clarifying, e.g. by writing "decimal integers" or something alike. Your code does (probably) unexpected thing for numbers smaller than 0. Since you take input as an and also do virtually no error checking, you could end up with the user inputting a negative number, for which your code will output 0 for the binary and 0 for the decimal representation. If you don't want to accept negative numbers at all, should be unsigned. If you do, change your implementation to work correctly for those. Either way, you should do input verification on the numbers (or non-numbers) you get. Don't use . If you want a newline, simply write . The reason is that does more than the name suggests. In particular it writes a and flushes the underlying buffer which is very rarely what you want or need to do because it seldom yields any benefits and can decrease performance. Order your includes. In general, alphabetic ordering is expected to enable fast header verification for people reading your code. Write meaningful comments. In particular, follow the DRY principle in comments as well as code, which means that , for example, should go without the comment because it only repeats what the code does. Instead, try to us comments to give reasons as to why you're doing something, and don't overuse them because you've read somewhere that "the more comments, the better". Usefulness and clarity are key. is not exactly what I would call a good variable name. Most of your other names are good, but this one identifier is definitely not. How about something along the lines of instead? If you have access to anything , use in place of because is fragile and convertible to a lot of things that are not actually pointers. 

Additionally, you should use the context manager, which takes care of file closing and error handling for you. Also, you should avoid using strings all over the place and store the filename in a variable. You should also avoid setting unnecessary variables (like ). Additionally, use Python's string multiplication abilities ('-' * 40 will print 40 '-'). Your script would now look like: 

If you are creating a database wrapper, why not make a lib out of the wrapper and stick it into a directory that other modules/classes can import? So, your class would be in a directory structure like this: 

After that, I changed how you output the block of text from a bunch of print statements, to 1 multiline print statement: 

Give this a try and post the results - it integrates PHPBenchTime laps and get_memory_usage() with your script. 

The advantages are that you have a dict with the weekend/weekday times, so you only need one generic return statement. The magic/hardcoded string in the further shortened version is a no-no though. Furthermore, you could extend the function to allow for custom times to be passed in, as such: