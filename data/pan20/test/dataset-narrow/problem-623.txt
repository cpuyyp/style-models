It look like the first link on every page of the site is the same (e.g. the link on a logo) and the children processes are simply printing this (correctly) so it looks like incorrect behavior, but isn't. 

This depends on a few things (keep reading). Not necessarily. This is a question of optimization. You could fetch a vote's book by using Chapter as an intermediary (), but this would obviously require sequential trips to the database - one to get the vote, followed by one to get the chapter, and finally one to get the book. Do you plan on fetching a book for a vote frequently? If so, save some resources and stick with what you've got. From a dependency standpoint, this seems counterintuitive, but since a chapter cannot exist without a book (can it?), I would say this is fine and simply a matter of preference. This always seems awkward to me as well, so maybe someone else can provide more info. You can, again, this is a question of optimization and convenience. When you have questions like this, ask yourself, "will I really need this?". If the answer is no, or you're unsure, leave it out; you can always add it later if your needs change (the relations are setup correctly to do the joins, right?). See above. I would provide a Chapter.getVotesSum() and/or Book.getVotesSum(). These methods would include GQL queries to aggregate the appropriate rows from the votes table into a sum. 

The core of your question is whether or not you should use setters ($tpl->setSomeParam()) or a simple array to bind template parameters. While using an array my not seem very OO, it's actually a pretty effective way of decoupling your data from your templates. As you've discovered, having to add a new setter to your layout manager every time you add a new parameter to one of your templates means the layout manager is tightly coupled to all of your templates – not good. This is pretty common practice these days. Twig, Underscore.js, and many others do the same thing. 

Doing so would change how you bind your events and render your HTML, so I'm leaving it at this just to give you the general idea. 

Move the PDO object to a constructor argument (see below) so you're not violating the Law of Demeter (see #1 and 2 here) Remove altogether and simply return the result from the method in which it's built. Break this into smaller, more meaningful methods based on responsibility (see #4 below) Create and methods with optional parameters 

Continuing on Peter Kiss's answer, the keyword is indeed hard to test, but you don't have to worry about it when it's in a dependency container. If you use Inversion of Control and have your objects ask for a DB connection, rather than getting one, you don't have to worry about using singletons or static class properties – you just let the dependency layer manage connections, and this can be done with a simple static variable inside a closure (see below). This answer is verbose, because I'm going to assume ignorance and try to explain Dependency Injection in as simple terms as possible (I still haven't found a concise explanation of DI). Afterwards, I'll explain how you can use DI to ensure no more than one DB connection is created. You need to create a very generic container object to contain dependencies. At runtime, you insert these dependencies into this container (typically before you do anything else). Then, you pass this container to the constructor of any object with a dependency. The object then retrieves the dependency it needs from the container. This allows the dependent object to be completely ignorant of how the dependency was constructed: e.g. a database object could have been constructed from PDO rather than MySQLi (though you'd want them to share the same API). This aids in making your code much easier to test by keeping object graph construction and application logic separate. If you're using PHP 5.3+, I'd recommend looking into PIMPLE. Here's how you'd set things up. 

In general, using the "new" keyword in any class is bad practice, because you're creating an implicit dependency. Instead, you should follow the "ask, don't look" design philosophy and require that the database object be passed to the class, rather than letting the class fetch it. Dependency injection is a common solve to this problem, and I'd recommend looking at how PIMPLE is used. Here's a good article: "Dependency Injection with Pimple". Many people, like deceze, will deride you (rightfully so) for doing things like this, because it's one of the easiest (and probably most common) things you can do to kill the possibility of testing your code. If you were to write a unit test for this model, you'd have a database object being constructed with each test. Since the whole point of unit tests is to run code in isolation (to verify the tested code's accuracy), it would be impossible to test this model without a database. On that note, the JavaScript guru, Misko Hevery, published a really superb article on writing testable code: "Top 10 things which make your code hard to test". While this is specifically in the context of code testing, it's also very good general programming information. 

Looks pretty good to me. Regarding , definitely don't put this in its own statement, because if there's a problem with the earlier code, the connection might not get closed. I know you're not using Python 3, but ss an alternative, you might consider using the statement and let Python handle the closing for you. See $URL$ (end of section) and $URL$ Your code might look like this: 

The keyword in a class definition A method and attribute for data created by single method A very long, ambiguous method: Two mostly-different SQL statements separated by an 

I find it's good to get into the habit of using to open resources so don't have to worry about forgetting to close the connection. 

Use CSS classes elements that share the same animations. This way you can just fetch all the elements that need to be animated with a single . e.g. Instead of using jQuery's animation methods, use CSS transitions. This will make your code simpler, and you know you're using the browser's native animation rendering. 

Not bad. Regarding your concerns that toPretty.json is visible from outside object-scope, people typically get around this by using the Module Pattern. 

More on resources: For instance, if you store 1KB every time the / route is loaded and get 1M visitors a month, you'd be up to 1GB of memory just for global_list in around 1 month. 1KB is a lot of data, and you probably don't need all of this information to do your calculation in /test. Instead, you could aggregate the data by using global_list as a running total for the full set of data stored elsewhere (a database or filesystem). If you're doing more than simply presenting a count of records in /test, and you need whole (or partial) records, then you can do pagination. Let's say you're presenting a list of the records in global_list. In this case, /test could simply return the first 10 records by default, but allow the user to see more pages by providing a page parameter. So if the user wants to see records 31-40, they could request /test?page=4 

This started as a small set of objects that transformed data, rendered the graphs with D3.js, and managed the layout all in the same object. The graphs can be removed by the user, and they resize based on screen width and the layout adapts to smaller screen sizes. I've decided to convert each type of graph to a subview and use a parent view to manage the layout of these subviews. This allows me to centralize the code that inserts the graphs into the DOM based on width, platform, etc. The subviews are all built from a single, large set of homogenous data. I have a single object that constructs these views based on available data then stores the subviews in a collection object (to be persisted when the report is saved). This collection of subviews is then passed to the layout manager for rendering. Subviews are only constructed if the data is available. The thought here is separating object graph construction from the rest of the business logic will make it easier to write unit tests – a requirement moving forward. I'm having trouble finding a good way to place the subviews on the page. Currently, they're all in a single collection, but they need to be placed in different places based on what kind of graph it is and which set of data the graph is for. e.g. for each of 1-3 "properties", a graph of growth for the month needs to go at the top of the first page and middle of third, while a single graph of top referrers needs to be drawn only on the last page. The most obvious solution would be to simply iterate over all of the subviews and using a giant switch statement, but I think "giant switch statement" and then immediately think "refactor" and "use polymorphism". One of the ideas I had were to index the subview collection and create a map to lookup the DOM insertion code based on the index, but this is only a stone throw from a giant switch statement, and I'm essentially coupling my layout manager to the subview builder. Another idea was to check the subview instance name in the layout manager, then insert the graph into the appropriate place in the DOM based on this value; however, this would still require a big switch statement. Is there a good solution to this problem, or is my design flawed? Here's how the page is initialized (in a Twig template):