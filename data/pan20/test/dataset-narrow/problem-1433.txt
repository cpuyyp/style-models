I'm assuming you're using the Flash IDE? If your file isn't an Actionscript class, just use the statement. Eg. on frame 2, write: 

I'd look into a physics engine like Box2D or Nape. These engines come with several different joints you can use to animate lots of different stuff. Here's an example of the different joints/constraints possible. On the Box2D (for Flash) homepage you'll also find a Ragdoll example which probably comes really close to what you're trying to achieve. Maybe you could take the ragdoll-example code as a starting point for your own modifications? 

I don't know about the exact ratio but I think about 50% (or even more) of all AAA titles run on OpenGL. Just the console games (without X-Box) make up for a lot of games. Or take Blizzard as an example (Starcraft2, WoW, Diablo3). All of their games run on both PC and Mac and therefore use OpenGL too. AFAIK Blizzard uses custom developed engines for their games. 

On iOS there are two different units of measurement. Points and Pixels. On older devices a point is equal to a pixel. On new devices, there are two pixels for each point, both vertically and horizontally (so totally 4 pixels per point). An iPhone 3 has pixels and points. Whereas an iPhone 4 has pixels and points! The important bit here is that the number of points remain the same for old and new devices. So I'm assuming you're working with pixel sizes instead of point sizes here. When you define a rectangle to be on a new device, then this is in points, not pixels. Which in turn results in a pixel rectangle, which is of course double the size of your image. Your image of size is actually points in size (on an iPhone 4). I don't know how you retrieve your rectangle sizes. If they are hard-coded, just always use the one for the low-res device. If you're measuring them at runtime, always use methods like instead of . Summary: Work with points instead of pixels, as points remain the same across iPhone 1 - 4. 

The movement of your ball varies from platform to platform because you're not using the delta-time at all for your movement calculation. First of all you should convert your ticks to seconds in your update loop and then call the functions with the delta-time in seconds.. otherwise you'll have to convert to seconds in every function. All your speed definitions should be in units per second. Eg. would be if your ball should move at a rate of 100 units (pixels) per second. Then a simple method could look like this: 

As you can see, there are lots of different ways to create textures, but there's usually a lot of work (and skill) involved in creating good textures. Since the textures also have to match the style/mood of your game, they should be crafted for your game. 

You can tweak the resulting "alpha" by changing the threshold parameter. And since this is ImageMagick, you can also easily batch convert lots of sprites. 

The people over at $URL$ did some testing on how somebody could be uniquely identified by several values that can be gathered from almost any browser. The results are astounding and you could use a similar approach (maybe combined with other measures) to identify and track your users. 

PHP is still relevant for browser games. There are tons of companies (Gameforge, Funzio, Goodgame Studios, etc.) that use PHP for their online games. I think PHP and Java are most widely used, but learning something like Node.js and Python can be beneficial as well. It really depends on what you want to focus on. Learn new technologies/a new programming language, or create a game with the tools you already know? As others suggested, you could improve your game-client by using technologies like HTML5 and JavaScript. For the backend you can still use PHP. That might give you enough new stuff to learn while you can still benefit from your PHP programming skills. 

Personally, I would just store the vertices (vectors) that make out the slope of the terrain in a separate data-structure, because reading them out from the box2d bodies can be cumbersome. To find and given a desired item-position , you would iterate through the hill-vertices (assuming they are ordered from left to right) and stop whenever is bigger than . Then will be and will be . 

Which would be the grid you want to perform your vehicle path-finding on. Update: Updated above with some more information. Also this would actually work for different shaped vehicles but will get computationally expensive with a huge map and a large kernel (the smaller the kernel, the better). 

You might also consider comparing the metrics on a site like ohloh.net, eg. Irrlicht on ohloh and Ogre on ohloh Some of the above points might be less or more relevant to the decision you have to make. Then stick to the engine that matches your needs as closely as possible. If both engines are a viable option, throw a coin :) 

If you don't want all the benefits (and bloat?) of a 3D Engine, why not use GLUT? I think SceneManagers and the like actually add to the user-friendliness of a 3D Engine as opposed to making things more complicated. You can do very basic rendering (no textures, no shaders) with all of the 3D Engines you mentioned. Some of them even have a modular (Plugin) architecture so that you can actually strip out all things you (currently) don't need. IMHO there's no such thing as a beginner friendly 3D Engine or even a beginner-friendly framework/library. You'll always have to learn and get used to a software-package first. It seems to me like you're trying to skip that step :) 

Get some dirt and grass textures. The one I'm using in my example are from this freetexture set. Open a dirt texture in Photoshop. Select all Ctrl-A and copy Ctrl-C. Then select from the Menu. Name your Pattern "Dirt". Do the same for the Grass texture, name it "Grass". Create a new Layer in Photoshop and apply the and Effect to your layer. Select the "Dirt" pattern for the overlay and the "Grass" pattern for your Stroke (see images below). Paint with any brush on your layer... instead of having a boring single color, it should render as a landscape, thanks to the layer effects. The beauty of this is, that you can freely add/remove parts of your landscape by using regular drawing tools like the brush or eraser. (optional) Draw a gradient from dark blue (top) to light blue (bottom) on the background layer for your sky (you could also use layer-effects for that). (optional) Add some more layer-effects like a gradient and drop-shadow to your "landscape" layer in order to achieve a better look. 

I'm facing exactly the same problem as you in a project now. The way I decided to tackle it is by having a "ColliderComponent" which holds the body from the physics engine. The bodys are defined externally (shape definitions which are loaded at runtime) and then added to the physics-world and to the game-entities they belong to. I'm using Box2D where you can attach a "collision-listener" that will get notified by the collision. Since I add a pointer to my "ColliderComponent" to the bodys user-data, I can get my two ColliderComponents that were part of the collision. So the thing that happens when a collision occurs is the following: The ColliderComponents which were part of the collision will send a message out to their owner-object (the game-entity) which in turn will broadcast that message to all its components. Every component can then react to that message, so your "health-component" could remove 5 points from health, etc. 

As you can see, it starts at on the right of the circle and goes counter-clockwise around the circle until it hits . So if your sprite isn't pointing to the right with a rotation of 0, you might have to add some constant. Eg. if your sprite is pointing up, you have to add to the calculated angle. Also, instead of adding and subtracting from the angle, I'd rather choose some fraction of PI instead. Eg. equals 2 degrees of rotation per update. 

There are several things off with your code: Don't access the shared object from your screen, unless you can ensure that the object will be instantiated whenever you run . And most likely, this isn't the case. A clean solution would be to implement a getter that instantiates the object on demand. Eg. 

Calculating collisions by using the geometry of the game-model can be really costly in terms of CPU usage (performance). Even more so when you're dealing with detailed polygon models. To speed calculations up, collision detection is usually done in two phases: 

Flash is actually pretty good at handling "frustum culling". You should use the property for this: $URL$ If you plan to use a Image for your world map, you should be aware of the Bitmap-size limitations of the Flash player. If you target player 9, the limits are 2880x2880 pixels. Player 10 and up can handle images with a pixel sum of max. 4095^2 pixels (see: $URL$ If you think your map might exceed these limits, I think it would be a good idea to implement some tiling on your own. Update: Here's an article that explains a bit better: $URL$ 

It's a decision made by the developers/publishers. In markets where a price-tag is an obstacle (eg. Apps), a lot of developers choose to go with a free-to-play game and get their revenue from ads or in-app purchases. This business-model is also very common in browser-games. I'm not aware of any browser game that you actually buy before you can play it. That being said, it's not a matter of how "good" a game is that makes it fall into the category of free-to-play or pay in advance. As with everything else you want to sell, you'll have to study your target market/audience and find the appropriate way to sell your game. Also you'll have to decide whether or not you want to release a demo (or light) version of your game and a paid version, or if you want to just ship one version which is free-to-play and has in-app purchases. 

You could always upscale your graphics with a nearest neighbor interpolation to keep the pixel-style. When you do this, only scale by integer amounts, eg. 2x, 3x etc. The problem with this is that you'll have to create upscaled versions for regular- and retina-displays. Personally I would rather keep the original artwork and scale it on the device (eg. via OpenGL). The advantage of this approach is that it uses less texture memory (you can pack a lot of sprites into a 1024x1024 or 2048x2048 atlas) and will also produce a smaller app size. To achieve the desired scaling, you could either scale your by the desired factor or use the property of the layer and set the eye position to a closer value. To achieve a pixel-look even with scaled textures you should set the texture scale-mode to . There's a shortcut function for that, called . Eg. 

I guess you probably know about the Facebook API Documentation. Other than that you can find various snippets and examples via Google but a lot of them still target the old Facebook API. Personally I found the API-Docs and the code-examples to be sufficient to get started, but this might vary depending on the programming-language you're going to use. Typically you would create a server application that provides the leaderboard and live-updates to your client apps. The server-app uses the Facebook API to get user data from Facebook. To get user data (like friends etc.) the user needs to grant your application permission to that data. You can find more information about authentication here: $URL$ Update: These links might also help you getting started. They target the iPhone, but should give you an overview nevertheless: Using the FB Graph API, Getting the users profile