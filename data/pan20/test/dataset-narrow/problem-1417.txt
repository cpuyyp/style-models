I have a lot of minuses on this question, but I tried to use reference counting on my entities and components, and now I like this approach very very much. So if someone is interested, I stopped on using reference counting on these objects. I used this approach a bit and see now a lot of benefits and hope in future there won't be problems. 

visually this rotations are equal, but when I get angles 2) from quaternion and increment them it starts rotating in oposite direction, next frame rotation is again as 1), so there is infinite loop at this rotation (some kind of black hole;-)). What can it be? Something wrong with math? 

I want to show user shot power in standart way (the more user holds finger on the screen the stronger is shot) 

You must use texture coordinates instead of resizing, like draw only part of the whole texture. I don't know how it works in libgdx but it's common to use this approach. Another approach is to use texture atlas, you have in memory e.g 1024x1024 and then when you load your image you load it to atlas rectangle. 

Instead of using tilemaps you can use general objects transformations. Like: house01 x:151 y:150 angle:30. Also you can generate your map on the fly. In storing map as bitmap you use 32bits per pixel for example, and in the simpliest tilemap only 8bits(ASCII char). And using bitmap for map generation it's just a way for storing data. Anyway your engine will interpret data as required, so your idea is right about save/load tilemap. 

With your Physics you subscribe to changes of your Transform component. So when transform position changed directly you Physical part also moves. And after physics simulation you can directly change Transform->position from Physics, because entities which have Physics will always have Transform. What about direct moving of objects without physical simulation, you can use Kinematic bodies most of engines provides their support. Or you can directly write your position+=velocity in any your script. Or create some BasicPhysics component and then just adjust properties. 

4. String IDs The heaviest memory footprint of this list for multiple reasons. I do generally advise against using string values as IDs if at all possible unless you fully understand the inner workings of strings and how to make optimal use of them. String values do provide the largest possible range of values and most flexibility. Names can be randomly generated, strategically assigned, and can be made very meaningful. One attractive use-case could be fully qualified names i.e.: (Player.SomeGuy, or Creature.Humanoid.SomeBadGuy, etc). That is an attractive feature with a lot of possibility. Due to the way strings are handled in the .NET framework (via the string intern table), the way you implement and manage these IDs is really what will decide how good or bad it performs. String equality comparison can be relatively fast if handled properly but many things such as size, storage methods, etc become factors. Explicitly choosing the comparison type will be in your best interest when comparing string values. I prefer case-sensitive ordinal comparison personally but some may wish to be culture-sensitive in certain scenarios. This will be a design choice based on your requirements. Generating string ID values could get tricky if required to be done automatically and of course, thread safety will something you will have to accommodate in your implementation. 

Given the options in your question, separate timers would be the best approach. I'm not sure what your implementation of the "timers" is but you can get a major performance increase and simplify things by using a different approach. Rather than using timers (as in stop-watch type timing) you could use time stamps that represent the expiration of a cooldown and to determine if the cd has expired, you would check against the time from the physics engine during physics engine ticks or update calls. This way you aren't managing a whole bunch of individual timers and are simply maintaining a series of time values to represent the timer end times. Would this work for your scenario? 

3. GUID IDs GUID values are 128-bit so they're a bit larger than 32-bit integers so their memory footprint is a bit bigger in comparison. As for uniqueness, this will give you complete and utter uniqueness for each ID created. Someones bound to chime in that GUIDs are not guaranteed to be unique as per definition, but this is only true over the context of an insanely huge timeframe, well beyond the lifetime of anygame, or developer for that matter. Plain and simple, these will be unique for your requirements, even across machines. Another benefit to GUID IDs is that you will not have to worry about thread safety during creation. Yet another bonus of GUID IDs is that they can be created in-place within the constructor of the type if desired. Doing this means that the Entity Manager is not burdened with managing ID generation and no unnecessary overhead is incurred during from locking, etc. Performing comparison of GUID values is obviously slower than comparing integer values but it's still surprisingly fast and shouldn't be an issue in most, if any systems. Ordering these may be a major burden however but there shouldn't be any need for ordering if being used for the proper purpose (i.e.: Instance IDs). On that note though, I would suggest that anywhere you need to store these outside of the object themselves where searching must be performed against other IDs (object maps, etc) they should be stored in a dictionary. Storing in an array or a list will be absolutely horrible performance do to the search algorithm used where as in a dictionary, due to the internal structuring and search algorithm used, will be blazing fast regardless of the 128-bit size. I should also not that the equality comparison of GUID values in .NET is actually even faster for GUIDs that are not equal than those that are equal. It may seem scary at first when thinking of GUID comparisons as when we view the human-readable form it looks like a big, messy string, but internally it is a sequence of various integral types and is treated as such when comparing values against others. 

BasicEffect is shader program. So it is resource it must be single( to save memory etc). And parameters are passed same as in function. 

Where is the best place to show this icon on touch screen(when I use mouse it's better to show it at the mouse position): 

I want to make my body fly at constant speed, how to make it fly at constant speed before and after collision? I set restitution of my body to 1.0 but after some direct and powerful collisions my objects begins to slow, I want it to fly same speed as before. I heard this can be done by setting liner damping of the object, I think it can prevent only from fast flying objects not slow. Thanks in advance. Edit* I can simply modify velocity of the object every frame, is it a solution? 

You can use factory method or you can use array of objects prototype pattern (prototypes or templates, how to name them your choice) from which you create objects just copying and instantiating if required. I've seen only this two ways of problem solution, if someone suggest another one I'll be glad to see them (possibly they are better) 

When I started to develop my game engine, I created StateManager and BaseState class, but further I found it extremly unpractical, and removed state management completely. Now I simply use SceneManager loading, unloading scenes. Main problem was transition between states. Now, I just use substates inside scene and that's all 

So you have to take care about constant physics step. Sometimes for example it can be called 2 times per rendering frame. You wrote: 

I have Transform component storing it's rotation as Quaternion. Transform has set/getEulerAngles (rotation order oy, ox, oz). I want to rotate object in any direction but while testing I get jumping(glitch) objects stop rotating at specific angles. Euler angles in problem frames: 1) oy 0 ox -90 oz 0 - previous frame. 2) oy 180 ox -90 oz 180 - next frame after incrementing angle of the object. my increment looks like: 

1. 32-bit Signed Integer IDs By far the most lightweight ID type. Comparisons are fast and are easily orderable (if required). They're light enough for being passed around in function calls when needed without taking a noticeable performance hit. Signed 32-bit integers provide a wide enough range of possible values for most gaming needs. If used for static (unchanging) IDs, this should be fine as I cant think of a single game that uses anywhere near 2.1 billion different types of entities! If using for instance IDs, again you should be fine as 2.1 billion+ possible ID values is an enormous amount. The only time this may become a consideration is if you are talking about an online game and the game server stays up without restarts for a very very long time, in which case you'll have to monitor this and see how long you can go without needing to reset the count (by restarting the server) to avoid overflowing. The one thing to be cautious of if using 32-bit signed integers is thread-safety. Do not assume that just because a type is static that it's threadsafe or you will be bound for problems. To successfully use an incremental 32-bit integer design, you must also implement a properly designed locking system to ensure thread safety. Due to this, you also have to be aware of any overhead involved in repeated locking as if designed poorly, this cause a big performance hit. 

A little late to the party here but thought I'd add a few suggestions and reasoning behind each which should be considered when considering these or other suggested answers mentioned in this thread. I've faced the same question and the answer always seems to be to decide which trade-offs best suit my particular situation. My suggestions are based on c# design choices, however the reasoning is pretty much transferable to any language you'll be developing games in. 

This is entirely subjective to the design requirements of your game but, generally speaking, usually most systems use an event-based system where objects register for events. It allows for a pretty flexible system where you can design anything from HID input to timers to trigger events. If you would like to see a pretty strong example of how this can be done in a managed language, check out the source code for the Delta Engine. It's in c# but c# is incredibly easy to interpret in a java sense. Delta Engine Source code