Iterating over pairs of consecutive elements is a common task that has a fairly standard recipe, , given in the documentation for the itertools module. You can use the implementation from the more-itertools package if you want. This also lets you get rid of the / block (which probably didn't affect runtime much, but it helps code clarity). Python has a built-in function, , to find the maximum value of an iterable. If you use it, then the nuts and bolts of the loop as well as the compare-and-store-if-greater process get handled internally by the interpreter, which should be faster than doing them manually in pure Python. Repeatedly accessing an attribute of an object, namely the method , is slower than accessing it once and storing it locally as a new variable. 

If it's faster to avoid computing a substring in your replacement, you might think of doing the same thing when you're finding the suffixes in the first place. In other words, instead of calculating all the suffixes of a string in , just make a list of tuples to represent the suffixes. Then whenever you need to actually compare two suffixes, instead of taking a substring of the original string, you just start comparing characters at the required indices. There are two problems with this in practice: first, Python isn't well suited to iterating from an arbitrary point in the middle of a string. In a language like C, where strings are character pointers, this would work out quite well, because you can jump into the middle of the string by advancing a pointer. But in Python, iterating from the middle of a string requires you to either start from the beginning and just skip the first several characters, or bypass the whole iteration mechanism and use a loop with an integer index to access characters inside the string by their indices (which typically involves more Python code that is relatively inefficient). And besides, the other reason is you need to create the substrings anyway to sort them. If you try to do it so that you use the substrings as comparison keys without actually storing them, the program spends a lot of time converting between a substring and its index. 

I leave it to you to figure out the best way to put / blocks around this code. Actually, the way I've done it here has a problem dealing with the case where is zero (this would happen if you include constants or zero-argument functions in the list of operators). To get around that, you can use the following: 

I have no idea what's in the code (well, I could look, but I'll leave that as an exercise), but it's clearly heavily optimized for this kind of task. It's another 25% faster than my best version of your program: 

OK then: since your concern is speed, let's track our progress with actual timing data. The first step is to run the code through the Python profiler. With the addition of a bit of driver code that just calls 10000 times, I get the following results: 

For complicated sequences of code, you have to make a subjective judgement about where to use variables and where not to in order to make the code as clear as possible. But in this case, I think most programmers would agree that the variables are fairly unnecessary. Let output formatting be controlled by the formatting routines Evaluating an RPN expression doesn't include formatting - in particular, deciding whether the result is an integer or not is a separate task from just getting the result in the first place. So at the end of , just return a . When you print it, instead of you can do 

So at a minimum, I'd suggest wrapping all your code (except for the function) in a function. It's good to separate the input/output from the calculation. So the loop in the middle should probably be broken out into its own function. You should give it a name that clearly identifies what it does, like . Don't declare and all the way at the beginning of the code. Wait until you need them. In fact, if you're breaking out the loop into its own function, you should put those variables in the function itself. Have the function return the number of solutions and number of duplicates, because that's all you need. is not a great name. That function actually checks whether two numbers and their difference contain all the digits from 1 to 9 a specified number of times. So give it a name that reflects that. You can expand on the name by using a doc comment. Similarly, and aren't very conventional names, although in this case because you're just running a mathematical algorithm, there aren't much better choices. It's common to use and in this case, since the numbers are integers, or and if they were floats. And it probably makes more sense to pass the number of times each digit should appear as the argument, not the number of digits in each of the original numbers, because that way it's a lot easier to understand what the code does. is another name that doesn't make any sense. That variable actually holds entries representing the solutions you've found, so why not name it accordingly? Get rid of variables you don't use anywhere, specifically . It's conventional to use as the return value to indicate that a function doesn't have any meaningful result to return, so I'd suggest using that instead of . Nothing wrong with , but it's a bit strange to have a function returning either a boolean or a string depending on the result of a calculation. Don't pass around more variables than you need to, unless it helps performance. In this case you don't need to return both the number of successes and the list of successes. You can find the number of successes by taking the length of the list. The calculation of maxes and mins probably belongs as part of the solution-finding function. That helps you avoid passing around more variables than you need to; with this change you only need to pass one argument, the number of digits. 

If different parts of this expression could raise the same type of error, then that would be a good reason to break it down, so that you could tell exactly where a given error comes from. But that's not an issue here. You'll only ever get s for one reason. Same goes for the float-parsing part: 

If you think about it, you don't even really need the common prefix itself, except for the one string you actually return from . You only need its length, so you can decide which substring is the longest. So instead of using a function that finds the full common prefix, just write one that will give you its length. You store the length, along with one of the strings, and at the end of , use the length to trim the stored string. 

It's a lot easier to understand your code if you put things in functions. Conventionally, a Python script has a function that does everything, and it's invoked with 

Instead of chopping off the whole end of the list, as in the previous method, this one pops off the last elements one at a time. 

Do tokenization the easy way Your input strings consist of tokens (numbers, operators, functions) separated by whitespace, right? There's a built-in method to split a whitespace-separated string: . You don't need to bother with a buffer, or with iterating through the string's characters. 

Not much of a change. Actually, using is slower here, so let's discard that change. Time now to take a closer look at . 

you see that it goes through some preliminary steps relating to the fact that it needs to handle a list of potentially several paths. You only ever have two strings to compare, so you can skip that - and in fact, if you look back at the profiling data, you'll see that these calls to and do take up a significant amount of time. Therefore, it makes sense to implement your own version of without the and calls. 

and it will automatically strip trailing zeros as needed. Of course, this does display large numbers in scientific notation (); if that's a problem, then you might have to do your own formatting. Use descriptive variable names Your list doesn't actually contain tokens; it contains operators, and could be generalized to contain functions. So I'd suggest naming it or some such thing. Allowing arbitrary numbers of arguments This is really more about adding a feature than reviewing your existing code, but I might as well point you in the right direction. All you have to do is store the number of arguments a function or operator requires, in addition to the code that actually evaluates the operator. For example, 

Mostly, this is a matter of convention, but also, it's handy to have a function that can be run from another Python script that will just do everything. Organizing the driver code The process of evaluating an RPN expression is something that makes a lot of sense to put as its own function. That's a self-contained task you could easily want to reuse elsewhere. So I would suggest making a function which does exactly that. You can then use this function in your main loop as follows: 

Then, when you invoke an operator, instead of hard-coding two arguments like you did or like I did above, 

Don't overuse variables You don't really have to save and and separately; you only use them once each. 

I'll start with , since you wrote that code and it'll be easier to work through. The algorithm you use is to go through each pair of consecutive strings in the sorted suffix array, find the common prefix, and save that prefix only if it's longer than any common prefix already found. I can suggest a few improvements: 

The most important column is the second one, , marking the total amount of time consumed by each function (but not the functions it calls). The largest entries in that column are for the function and the function, so those are the spots you should focus on optimizing. To keep track of our progress, I coupled your class with the following driver program which prints the execution time for 10000 runs: 

All told, the changes you need to make to the code to use indices everywhere wind up hurting, not helping. Here's the timing result: 

At this point, you can spend a lot of time making little tweaks to try to squeeze some extra performance out of the program, but I don't think there are any major performance gains left. It's already something like 40% faster than the original, which is not bad. Of course, as dawg wrote in a comment, you can accomplish this task using Python's standard module . 

Evaluating This new function is going to do mostly the same thing as your function currently does, except that instead of prompting using , it will take a string argument, and instead of printing the result, it will it. Let me pick on a few things in that function, though. Let the stack just be a stack 

Speed issues Since you indicated an interest in speeding up the program, the first thing to do is set a benchmark for how fast it runs. You can do this using the module's function: 

I'm not quite sure what you're asking for, but I was bored so I typed this up anyway. Hopefully it helps. ;-) Working from the outside in: Invocation 

Most of the time is spent in (my renamed version of your function), and after that in , so you'll want to focus your optimization efforts on those parts of the code. There are basically two approaches you can take: 

The only real purpose of is to make it so that you get a instead of an when a function or operator doesn't have enough arguments. But I don't think it makes sense to do that. See, is just a stack. (Well, a list that is serving as a stack.) It knows nothing of numbers or arguments or calculators and really has no business raising a . The code in is the thing that knows it is a calculator. That's where you should be raising s. So instead of using , just watch for s during the evaluation, catch them, and raise a in the handling code. As a side effect you won't need anymore; you can just dispense with it entirely. 

For another perspective in addition to the existing answers, here are my thoughts. I've made a github repository which goes through each of the changes I made step by step. I've linked to the corresponding commit for each of the points that follow. (There are a few relatively minor commits in the repository that I left out of this answer.) Code clarity issues 

But I don't see any major disadvantage to the way you're doing it. It's just that other programmers will probably find it kind of odd. 

can time arbitrary expressions, so I don't see a good use case for what you're doing here. In fact, it could be considered bad practice in the sense that timing information, which is normally in the same category as debugging code, shouldn't be built into your program or function or whatever. You should be able to add that on "outside", only if needed. That's what allows you to do. Of course, sometimes it is actually useful to include timing information as part of your program. Even in that case, it seems like overkill to use a lambda function. A simpler way would be