So what would happen if a user input a negative number? This would definitely give you output, but is it valid or even usable? Overall, your code is alright. But try to avoid uneccessary spaces or excessive blank lines, it results in code that is tedious to scroll through as the program becomes longer. Try to implement the DRY Principle as often as you can, it will result in elegant code that maximizes re-usability. Putting my suggestions together and leaving some work for yourself, is the code below: 

As a side note, look at how much easier it is to read! Think about what it would be like to read your code from someone else's perspective; would you think it's cluttered? Confusing? In your , this can be broken up into methods based on shape (unless you decide to create a class for each shape). This helps in maintainability also and builds on what I stated above. 

An easy way to detect a cycle is through the implementation of a disjoint set structure, sometimes called a Union-Find structure. You start with a source node and attempt to add a node to that set. If your Find() call for the source node and the other node returns the same root node, then a cycle world result if the nodes are unioned. UPDATE: You could implement a topological sort, arranging the nodes with edges going from left to right. A topological sort can only be completed successfully if and only if the graph is a Directed Acyclic Graph. So, if the algorithm detects any cycles, it will stop. The runtime is O(|V| + |E|), which is better than DFS, in the case that repetition occurs during traversal. Topological Sorting 

You have accessors (the and methods). These methods allow us to retrieve data from our private members of the class instances safely, without revealing how they are implemented. This is known as encapsulation, a very important topic on programming to understand. This is where having a properly implemented copy constructor can show its' worth, due to the fact that you can now create copies easily without exposing references/implementations of the member variables. Typically, accessors are paired with mutators, which conversely, allow us to alter the members of a class instance in a predictable and controlled way. As pointed out by cbjobar in the comments, the use of mutators changes a class instance from immutable to mutable; the data values can now be modified after instantiation. 

I have been working on a script that automatically checks on the state of 2 services that I require to be running 24/7 on a server that I manage. The script works as I need, but I would really like to optimize it if possible. Specifically, I find that I want a way to reduce the need to type the command: 

Any other feedback is greatly appreciated, I am new to bash scripting and trying to find the best way to get this to be as optimal as possible! 

First thing that catches my eye.. Where are the comments?! I mean if you write good code, you don't have to write a lot of comments. But you literally have almost no useful comments in your code. What are you doing here? 

Room_Carpet Class Once again, the class is designed pretty well, but the copy constructor is not implemented. 

You can save a few lines in each of your switches by combining cases that are identical. You can save 10% on car insurance by switching to Geico. For example... 

Native sessions can handle arrays and objects. Yours will apparently convert everything to a string. I would before inserting and after retrieving. Use a boolean (or a zero/one) for the property. In your method use if...else rather than 2 ifs. the query parameters are coming directly from PHP, so prepared statements probably aren't necessary, you may be able to improve efficiency by swapping them for s. (speaking for the queries that only require a session id, inserting session data obviously needs to be prepared.) 

Seems like you've figured this out yourself already, but I'll state it for you to make it clear... The idea behind functional programming is mainly to make things easier to read and maintain (by being "declarative"). Usually/often this is done at the expense of performance. For example, it's a whole lot faster to iterate thru an array with a for loop than with the method. Project Euler (or anything involving large numbers or heavy processing) is probably not a good place to practice functional programming with Javascript. That said, this problem in particular doesn't justify the use of more than one function anyway. Your algorithm is overly complicated. 

(For some reason the markdown parser didn't want to format this as code unless i also formatted it as a quote.) 

TL,DR The biggest problem I see with your question is your use of the word "better," as if that's an objective term that means the same thing in every context. Faster !== better. Assuming you're the one maintaining the code, the best one is always whichever one works and whichever one you like the most. Synopsis First, let me mention jsperf - a site that was built for javascript performance testing. If you insist on testing server-side code on the client side, you should really use this instead of building your own, for many reasons, the main one being: because it's easier. But to get the most accurate results, you really should test in the environment it will be run in (on the server side). It is good to know how to write your own benchmarks, but if you do, you should make sure your benchmark code has the smallest footprint possible so as not to affect the results. Among other things, every time you concat a string with the computer has to load the entire string into memory. It is better to put your string parts in an array and then join the array at the end. As Blindman67 noted in the comments, benchmarking Javascript is tricky and generally unreliable. There are simply too many variables (different JS engines, other things running on the computer, etc). 

Superglobals I cloned your repo and it looks like you've already taken my advice about passing in the superglobals instead of using them directly from your methods. Formatting I would have also commented on the formatting but you've also significantly improved that since posting the question. Cheers! Commenting The next good habit to get into is commenting, which s just as important as formatting and entirely lacking in this project. You should always put a short comment above every method explaining what it does, what parameters it takes and what it returns so you (and people maintaining the code in the future) don't have to read the code to figure out what it does. I see you're using NetBeans. I Like NB too. NB makes documenting your PHP and JS classes and functions very easy. I looked and I could not find any good documentation because I cannot remember what it's called, so I'll just explain the features as best I can. Auto-commenting Pro Tip Netbeans will actually do most of the work for you - place the cursor on the empty line just above the start of the function and type and hit the enter key. Netbeans will create the rest of the comment including the parameters and the return type (if there is one). This is what Netbeans generated for your loginAction method. 

You can remove two if-statements altogether if you think about it! Also, you don't even need your first edge-case if you do this: 

Here is my updated code per the suggestions given in Joe Wallis' answer. I have changed the main loop in the method, eliminating the if/else statements. I have also added additional methods to aid in easily retrieving data later form a separate module that is used. 

The biggest problem in your code is that you have literally everything in one method. This is a BIG maintainability concern and makes your code really difficult to reuse and debug if something ends up going wrong. Break your code up into many small methods, this way if something breaks, or you find a bug, you know exactly where to look for the fix. 

Your overall code is good, I do agree with Wenqin that a more class-oriented approach to the shapes could prove beneficial to the structure of the program. Anyways, onto the review. You are right about the use of your statements in the beginning. This can be handled in a much easier way if you just make a to store this and call it from a single statement. That way if you make changes later, it's easier to maintain and it's definitely easier to reuse. 

Input validation You do this for your statement, but not really anywhere else. While this doesn't make a huge impact on this particular program, it could on another one you write and you need to get into the habit of checking anything that you receive as input from the end-user. Here is a simple example of what I mean: 

Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

You have this copy constructor in your class, which is confusing because your class is mutable. Typically, we only need a copy constructor if an object is immutable. If you wish to keep the copy constructor, remove the setter and getter and change the copy constructor to this: 

If this method doesn't actually do anything, it shouldn't be in the code. I would say that having copy constructors can be very helpful... If the method is properly implemented. The point of a copy constructor is that you can pass an object, which is already instantiated, to another object of the same type to instantiate it. The benefit to this is that you don't have to worry about passing a bunch of values to the object manually. You literally create the copy of the object with the values that it contains. 

You never do anything to modify , yet at the end of the method you return ? Some comments would go a good way in explaining that a bit. 

I have an AngularJS function that is used to determine which associative array variable is to have data pushed into it. I would love to be able to remove the switch case entirely if possible but haven't been able to envision a way to do that! My overall goal is to both improve performance, but more importantly reduce the overall number of lines if possible I also considered perhaps some type of variable interpolation, but that seemed like an investment with little return on my effort. The directive is called in my HTML like this: 

Other, similar libraries don't require you to pass everything to the constructor. What if you want to send an email to more than one person? You should be able to call more than once. For now, I would suggest getting rid of the constructor entirely, and calling the setters manually as needed. After all, if you're planning on doing the entire operation in one call then you might as well write a function instead of a class. If you're going to implement setter methods then you should make your properties private or protected so they can't be changed manually by whoever is using your class. Usually, the setters are implemented so you can validate input before setting them, for example, 

This is taking so long because Google is geocoding each of your locations one by one. Geocoding takes a lot of time as the world is a very big place and you have a lot of locations. You can save some load time by geocoding in advance and passing in the latitude and the longitude in place of the location name. So for example, instead of 

Anyway, you're on the right track, but make sure you read the manual to see what other cool stuff you could be doing. 

When you create the methods inside the constructor then those methods are duplicated in memory for every object created. When you use the prototype those methods only need to be defined once. If you want to write code that feels like a class then use an actual class. (JS has those now). Aside from that, don't store you data in the function that creates the list. Pass the data into the constructor or create method. 

Personally I would avoid using either or in this case. They're slower and harder to read, and I would certainly avoid that looping thing. 

Caveats is somewhat picky about syntax. If your markup is not valid this will not work well as is. This means your example code will not work unless you correct the syntax first. While it would be trivial to write a function to make the required corrections in your example code, that is beyond the scope of the question. 

Edit: In this case, if your IDs are integers, you don't need to escape them or use prepared statements. Just check if they are integers first with . If you know they're integers then you know they're safe. Generally though, prepared statements are the way to go. 

Your current code gives you a bunch of booleans, duplicates a lot of code and does unnecessary computations.. You should aim to get the time of day itself rather than a bunch of booleans. 

Once you make these changes your JS only needs a single element from the DOM: the stylesheet. As long as you put the script immediately below the stylesheet you don't need to wait for the DOM to load. Here's the re-write: 

You can use and to do the same thing "declaratively", but in my opinion that's just a stupid buzzword and yours is more readable.. 

This is a really cool snippet! I like that you were able to avoid using . After a quick glance I only have a few minor suggestions. Separate the logic from the interface. You separated them to some degree in that you have the event handlers attached manually after constructing the calculator (even though the event handler is defined in the calculator constructor). I would instead make 2 constructors, a constructor that can take an expression and evaluate it, and a constructor that sets up the interface and the event handlers. That way you will be able to use that sweet calculator code in other projects, or extend it for use with a more advanced calculator. Clear the results of the previous equation before moving the current one to the top row. I believe that is fixed by fixing the typo in your function where you do instead of is not necessary. You're using variable instead of just using in several places. In fact I don't see any places where is needed at all, just stick with and leave alone. Consider taking advantage of . Using to assign methods makes us feel like we're writing classes so it feels natural, but JS doesn't have classes*, so embrace the prototype. *ES6 actually does have classes.