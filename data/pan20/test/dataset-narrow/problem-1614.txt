I'm having fun with one side being an http server hith LAMP (or close) and then have a python script on the rp making requests against the server using python-requests. Simple enough. 

In order to set up a modem-like connection with a GSM USB dongle, you could use wvdial. It's simple enough. It's cli-based so no GUI, just in case. There are plenty of simple examples out there with a basic configuration so you don't have to start from scratch 

From what I can read around, hostname -I will show up addresses and a single host can have multiple IP addresses set up (normally it's one IP address per interface but it's very flexible so you can have multiple IP addresses in a single interface, for example). And what do they mean? Not much, only that a single host con be connected to more than one network at a given moment in time. Think of a router, they could have a plethora of addresses set up. 

Are you running a updated kernel? Have you run apt update && apt dist-upgrade? From what I can gather on a quick search, that part of the code from the driver with that error message has been removed. Here's the patch: $URL$ Not completely sure it's the patch, but anyway. And I just checked on kernel code and it's gone: $URL$ I'd say update and see if it gets solved. 

I can't for the life of me figure out why the 'try' doesn't allow the edge_detection to register. Any ideas? EDIT: I've also just tried to take the main code chunk that runs under the main logic check, and created itself in its own function: 

Run the physical disconnection again, and check the output of the python created text file: WOOT! Looks like whatever that package is, is an array of 16 chunks: 

Full disclosure: I know next to nothing about snmp in a large sense. "just enough to be dangerous" so I left the log and net in the community. I could probably get away with just the execute for the WLDLifesnmp community, but it works so I left it. The most important part was finding the exact OID that was being tripped when that particular port on the switch disconnected. So I manually ran snmptrapd from the command line, just to watch what came through: 

Then I re-ran from the command line the snmptrapd function, unplugged and replugged a few network cables on the switch to see what I'd get... if anything. Hopefully something. I DID! I got the following mess in the /var/log/snmptest.log file: 

check out tvservice it should give you information on the connection status of the HDMI. tvservice -n Will show you the name of the device connected. (by the way, why mode 2? That's only 480p) Otherwise, it could be totally unrelated to the Pi. Bad HDMI cable, wrong input on the TV... 

As @jsotola adviced, you could run it later in the boot process.... or you can write your script to keep on trying to open the port over and over again till it's available (with a certain delay of a few seconds between attempts so that you don't go into a tight loop). Addendum: Apparently the tip that was followed was to start the script from rc.local... this is my full comment, just in case: 

I've been struggling since yesterday trying to configure a wwan interface that I get when I plug in a huawei modem into my rpi. This is what I have on /etc/network/interfaces but it just doesn't work (I'm in Costa Rica and the SIM provider is Movistar): 

I'm testing openvpn to restart if it fails for whatever reason. I edited the file /lib/systemd/system/openvpn.service (with vi straight, just in case) and set the Type to simple, added Restart=always and RestartSec=60. Then ran systemctl daemon-reload and then started my openvpn service (systemctl start openvpn@blahconfig.service) which makes it start. Then I forcefully kill openvpn process with kill and it remains as dead, no intent to restart it. What should I try next? 

The first routing rule when vpn is working is sending traffic to a lot of IPs through the VPN (0.0.0.0/1). 

actually, .bashrc won't work to start something on boot. You might try running stuff on /etc/rc.local, that will print output to what you see during boot time. But in order to work "right" your script has to either finish or it has to go into the background. If it hangs forever without letting execution continue, boot sequence won't finish. Addendum: Real question was related to user login time, not boot time. The answer is to use ~/.profile. 

then inside the fn_runmain() put the same try/except block as above. EXACT same result. The function fn_runmain runs properly without the try/except inside it, but does not when I add the try/except. 

I've got a fun little problem that I have hacked together a solution for, but I'm thinking there's probably a more elegant way of going about it. (I also had one heck of a time googling any information on the hurdles I had to face, so while I'm looking for suggestions on cleaning this up, I also hope this may be of help to others who are trying to do the same sort of thing) My managed switch has quite a lot of capabilities, but what it doesn't have is the ability to email me when one of my network drops disconnects. (It's for a wildlife camera that I have a long ethernet cable to, and I want to know immediately if it is ever stolen or drops offline or whatever.) Of course, I immediately thought "Sounds like a Raspberry Pi project!" So I configured the switch to kick out an snmptrap packet to the IP Address of my Raspberry Pi, gave it a custom community ID of WLDLifesnmp, and just turned on the 'link down' notification in the management interface of the switch. On the Pi: 

I have a basic system with a normally closed switch I need to monitor. If I run the program with the following setup, it works: 

I would say as a general principle: if the set up is going to be that tricky with this system that is going to be remotely located, why make it more difficult with one additional variable (the presence/absence of a dhcp service somewhere). Just set up the rpi with a static address on a private network (say... inside segment 192.168.197.x/24) so that when you are in front of it you can set up your mac to have another address on the same segment and voila! You can both see each other. But, just in case, it would help up a lot if you told us how each of the network interfaces of the rpi will be used (wireless? wired? will you use a GSM device for it to connect to internet, perhaps? you will be working with it remotely, do you have a vpn setup so that you can see each other?). Networking is tricky stuff. 

Just as a test, I'm able to send SMSs by echoing into /dev/ttyUSB2 and reading from it so it's not like I don't have access to provider's network or that the device is locked down. If I try to go down and dirty and echo a ATD or ATDT command into /dev/ttyUSB2, I get a NO CARRIER reply from the modem and so trying to run wvdial against /dev/ttyUSB2 fails miserably as well, just as I expected. Modem is Huawei E303C (taken from sending ATI command to modem): 

The above installs everything I needed, (maybe even more than I needed, not sure) and the next step was to tweak the default snmptrapd.conf file in /etc/snmp/ 

However, if I wrap the same statement into a 'try/except' (in order to add the GPIO.cleanup() to the end). It doesn't trip when when the switch opens and the GPIO falls. 

ugh. this is not going to be easy to figure out which port is tripped. I only want to notify if it's port 17 on my switch, not the rest of them (the above is port 39 and 35, respectively).. I have to somehow figure out how to strip that info out, but I have no idea how to do that with bash scripting. (again, I know enough about bash scripting to be dangerous) Python, however, I like Python, so maybe I can export the results to a little Python script and see what sort of packaging is being used here. It sort of looks like it's somewhat of a JSON package or something, I could not find any documentation on what sort encapsulation the MIB is using under the hood. So... enter a tiny python3 script that should run through each chunk of $vars, and write the contents on a single line to a text file: 

The key to this whole process is that last line in the snmptrapd.conf file: the traphandle. Once I could see the OID that was being triggered from the connection/disconnection, I could add the capture to the conf file: (connection is ' OID: iso.1.3.6.1.6.3.1.1.5.4' disconnection is ' OID: iso.1.3.6.1.6.3.1.1.5.3') 

instead of trying the GUI-based distros for raspberry pi I think you should try the ones that are based on terminal and then install the x server (or wayland... not sure of which one is supported on raspberry) plus the dependencies to start your application. You could write a script that does two things (this would have worked a few years ago with X server.... would have to give it a test these days to see if it still holds water): 

Talking about X server, you have to make sure than X is configured to accept tcp connections and that should be enough. If it's wayland, I'm not sure of how exactly it would work but it should be something similar. Then you could set up this script to be started with systemd on boot, which is a whole different topic. 

Do you have, by any chance, physical access to the computer? If that's the case, shut it down, put the sd card on a computer (I mean, like a laptop or a desktop or a server, you get the idea), mount the / partition of the sd card (/dev/mmcblk0p2, probably) and edit the profile file so that it doesn't work when you start the terminal (or add a & at the end so that it goes into the background). Another possibility: Did you happen to set up a different user on that board? If that's the case, try to log in with that other user, then sudo kill the process (hoping the user is a sudoer).