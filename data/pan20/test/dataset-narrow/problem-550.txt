But the case you are trying to optimize is rare (at best) and this causes the normal case to be worsened (failed branch predication can be very costly). As result I tend to not bother and just use the standard swap technique 

It may give up the core for another thread (temporarily). But it will come back just as quickly to check for more work. So I am not convinced this actually buys you anything. I would use a condition variable and block threads on it while there is no work. Then you know they are not taking up any cycles when there is no work. When creating the work package. 

All points by @Edvard are good. Here are a couple more. Encapsulation All your functions mutate a structure. So why not just make this methods on your class? 

Separation of concerns Your code should be divided into parts that do business logic and those that do resource management. These two parts of the code should be separated otherwise things become very complicated quickly. In your code you are doing both in the main loop. You are doing the calculations and performing all the memory management in the same place. Your code has (the business logic) intertwined with the resource management. This is bad design. 

So there is no need to add it yourself. It is become standard that when main can return no other value than that the is omitted to indicate that the application can never fail. So when I see a at then end I generally look around for the other situations where it can fail. So if there are potentially failure situations and you exit early with an then add a and then end otherwise don't bother. 

This makes reading the code very hard. The current best practice is called self documenting code. This is where you use variables names to explain what you are doing thus making the code self documenting without the need for extra variables. Also don't declare the variables at the top of the function declare them at the point where they are about to be used. This becomes more important when you start using complex objects that have constructors but is a good habit to get into with all variables. Code Review Stop doing this. 

I like it. Its called programing (where the code uses data to define its structure). This is usually considered best practice. 

Now we have a conundrum. As I am passing an object (but not expecting ownership to be transferred). But the other is dynamically creating objects. So I have both types of pointer on the queue. So when the destructor is called how do we tell which objects should be deleted? So if we look at the destructor: 

You should look up the rule of three and implement it. Move Semantics. This is 2017. Move semantics have been around since 2011. You should definitely be thinking about how your objects are moved. Currently your classes can only be copied. You should expand the rule of three to the rule of five on your code. Distance calculator is half of dykstra Your distance calculator is basically a simplification of dykstra. I did not read it thouroughly to make sure it works in all situations but I would check out "dykstra Algorithm" you will find many references on the web. Visitor Pattern Your and look like they probably work. Though I would look up the visitor pattern. It allows a more generic traversal of the graph and allows arbitrary actions to be taken at each node. Code Review Don't use 

Unfortunately this fails if you use the else part of the if statement: The trailing semi-colon (on type 3) marks the end of the thus else is not syntactically allowed. At least this gives you a compilation error unlike above. But Type 2 still works as expected. 

Or you could use a memory mapped file: Its been a while since I did this. Here are some instructions. $URL$ 

The other thing I would change is to put it into the SP_ESTIMATE_NODE class. The only time you use this is for sorting in a priority queue. So it is easier to define the priority queue if the class already intrinsicly knows how to sort itself. 

The issue here is that with any readers the writers are never going to get accesses (or are unlikely to get access), they will constantly be stuck waiting for a very quiet time. Even when you have a writer that releases the lock you get a random chance that another writer will get the lock. 

Out parameters are hard to spot and maintian. Also its not very expensive to return a vector (there is no copy the compiler will elide it (assuming you enabled optimization)). Check out RVO and NRVO. Also in C++11 and C++14 move semantics kick in and even if you can't optimize it with RVO or NRVO then it will be moved back to the calling function rather copied. Standard functions A lot of this work made trivial by the standard functions and some lambda's 

I would probably use a that's because parameters in the URL allow multiple values and their order is significant. 

Argg. Poop. I just realized you were consistent. But just emphasis why I hate this style. Members: Having a hard time spotting your class members. You need to make those more abvious (and put them at the top). so I can validate that your constructor actually correctly initializes all members. DRY your code The code in these two function looks nearly identical. You should try and put common code into a single location. So when you fix a bug you only have to fix a bug in one place (not in multiple places). 

Declaration when needed. Put your variable declarations as close to the point of use as you can. This way you don't need to look for their type very far (it is where the code is). They only get constructed when you need them (and destroyed as soon as possible) so preventing excessive use of space and not costing anything if you don't need them. 

If we look at the GetLock. I would not passes pointers as parameters. This means people can accidentally pass a and thus cause your code to break. Always pass by reference if you have to have parameter there. 

Does this really have any meaning for a tree? The nth child in this tree. What about the next tree down. Seems like a very strange interface. 

Obviously not an experienced C++ programmer. You are using a C style. Fail. I'll move onto the next candidate here. Pointers should always be managed. Use a smart pointer (make sure you pick the appropriate one). Also you are pushing the pointers into a non managed container. 

This should be a hint that fromLine is the wrong type. Since it is measuring a size and will never by less than 0 this is an indication that the correct type for the type is unsigned int (or probably size_t). 

There is no need declare these as static (unless you want to get the address or something) so just use enum: 

General Structure: Indentation. Be consistent. It makes the code really hard to read when this is all over the place. Also add a layer of indentation after every block opens and remove it when the block closes . Memory Management You should not be using new/delete. Most of the time automatic variables are preferred. And when you want dynamically created objects generates code that is as quick as using raw pointers (if you can measure the difference I would be highly surprised (especially since 99% of the time they compile down to the same code). 

Personally I don't see the point in havin output() and operator<< I would just combine them into and make it a friend (also declare it in the class). 

Major problem: You are breaking the rule of three(five). Your class contains a RAW pointer. This means you need to override Copy Constructor/Assignment operator/Destructor. You missed the assignment operator. 

Because of the default implementation of these methods a class that "Owns" a pointer will not work as you expect. Note: Owns means that the destructor will delete it. But the general rule is if you define the destructor or any of the above operators you must define them all. If we look at your current implementation: 

Here the external user is serializing the class. But has no idea what is inside the class. This makes this code impossibly brittle to change. It will almost certainly break over time. What you should do is ask the object to serialize itself to the stream. The object understands itself and its members. So it can optimally serialize itself to the stream. 

Design Review You have decided that the managed object can potentially be (when the object being managed is . Personally I would (consider) always having a managed object. That will make the rest of your code simpler to write (I like simpler code) as there will never be a nullobject Of course the other side of the argument is that allowing a managed object allows better resource management. I have not done the mathsso I have not come to a conclusion but that may be worth doing and putting into a comment in the code. Code Review Namespace You should put all your code in its own namespace. This also helps in making your include guards unique. Prefer include guards This pragma is not supported by all compilers. 

Thats not a good interface for C++. Once the constructor is finished the object should be in a usable state. I would have a helper struct that has all the objects you need that can be filled out manually. Then a constructor that takes that helper object or a full URI. 

Now when you have the year (vintage) you have the count in the same object (better spacial locality). Is this not simply the size of ? 

Now a piece on a board can fill in the cBoard without the user of the piece actually knowing what the piece is: 

Return by const reference Since you have a set of canned responses. You can create all your strings once and return by const reference. This will avoid a copy. 

Using pointers like this (RAW pointers) is also discouraged as it very dangerous. If an exception occurs you will leak the pointer. You also have to keep track of the object and remember to call delete on it, which is error prone (as shown by a decades worth of C code). So we usually use wrappers to make sure the delete is called automatically. 

The requirement is that the object that was moved is left in a valid state (Though indeterminate). I am not convinced this is valid state. If I call methods on this object it should not cause bad things to happen (though I should not expect to know what could happen). Currently: 

Const correctness. Const correctness is really hard to add in afterwords (believe me). So best to start with your classes with it already in place. So any method that does not mutate the state of the object should be marked 

For the is is unnecessary; as they are held in the tuple by reference. So here does not buy you much (apart from me scratching my head for 10 minutes :-) On the other hand it does seem correct to pass by r-value reference, but because you don't use they are decaying into references when you pass them to the constructor (I could be wrong on this last point (still getting my head around this new fangled stuff). 

Technically the above does not test for existence. It tests if you can open AND read it. So the code is wrong based on the comments (and its name). Boost provides a cross platform API for file system access . I have a problem with the following. As depending on the state of the file system it returns different things. 

Remove unused code Timer is defined but is not really used. You can remove all references and the code will work just as well. 

Read all the user input find the maximum value. Generate the factorials for all values upto the max Note: Saving them as you go: Print the factorial values by looking up the result you generated in 2. 

When you use this constructor. You should also insert a sentinel. So the list always has a sentinel value no matter how it is created. Then you can just add the value as normal. 

Sure I don't mind a function. But the standard seems to have gone to using . Also this is really just a convenience function. All it should do is return the internal URL.