Algorithmic time complexity, as we commonly understand it, is a measure of how an algorithm scales in terms of its input. We're usually interested in asymptotic complexity, meaning we want to see how it performs in the generalized, large-scale cases. It is the answer to the question: "What if we make it bigger?" How you calculate is fairly straightforward: you figure out the number of steps your algorithm needs compared to your input size, and you crib out the scalars: Θ(4n² + 25n + 842) = Θ(n²) ; Θ(28n * 6 log (18n)) = Θ(n log n) ... with the understanding that, as approaches very large numbers, all scalars become insignificant. (This isn't entirely accurate, but it's good enough for envelope-and-fingers calculations.) Here is a line-per-line of your code: 

Indeed, there is—good catch! We can speed up the duplicate counting by using a instead, mapping a name to the number of times we've found it. (This is essentially a multi-set, but our standard libaries don't carry such a data structure, so we 'fake' it.) Our printing code will look quite different, though: 

Note: ObjectOutputStream.close() closes the underlying stream, which will close the socket's outputstream. It's not an issue here because the socket is closed immediately thereafter anyway, but you may want to flush rather than close in some circumstances, or to slip a close-ignoring filter in between. Subtle trouble has a potential issue in its nested loop: 

EDIT Also, consider adding new line characters after each print, for readable output. Code with the above suggestions: 

Instead of this, I initially had a call to , which will supposedly be nicely optimized for the specific hardware. The problem with that though, is that both parameters of strcpy() are pointers and my requirement is that I should be able to call "in place". In the special case where the user passes a string with no initial characters matching , I would end up with something equal to which invokes undefined behavior, as it violates the contract with . In order to dodge that bug, I rolled out my own . The above issue is my main concern which I would like some feedback on. 

Additionally, and this is important, I wish to be able to use the function "in place". That is, is potentially pointing at the very same address as . 

Program design The main issues with your program is the overall design. I would recommend to study object-oriented programming on beginner level before even picking up C++, or any other programming language. 

When programming in general, C in particular, the most important quality is quite often program performance. As in execution speed and memory use. It is therefore very important to actually know what makes an efficient program and what makes an inefficient program. Inefficient == bad. Some examples of inefficient programming: 

Modifiers All methods declared in an interface are automatically and . Some people prefer putting one or both in anyway, but most seem to prefer that they simply be left out: → Group related concepts The Hero interface is a good start, but it has a lot of methods to implement, and that's going to become tiresome when you need to make changes (I'm really lazy in these things). So let's see whether we can extract some lumps and crops. For example, you have pairs of closely related getters: and . We can regroup these in a class (or interface) of their own: 

General Remarks The code checks incoming parameters, and throws an IllegalArgumentException when they are out of bounds (except ; see later). This is a good thing. It would be even better if you could include the faulty indices in the error message so that I don't have to pop out the debugger. ;-) The class seems to work with 1-based indices rather than 0-based, the latter being more common in Java[1]. As you commented about this within your code (but not in your public documentation), you've felt there's a mismatch; it may be better to use 0-based indices for consistency with the rest of the JDK. You're going through hoops to work with arrays in the public interface while using streams and collections behind the scenes. Consider returning lists instead of arrays, or maybe even streams if you're so inclined. Constructors Character encodings are important, too important to force the default encoding on your users, for any definition of 'default encoding'. Many of the classes and methods deprecated in were so because they assumed about encodings, which I've seen lead to subtle but no less spectacular breakage.[2] Allow/force your users to specify the encoding. If they make it be this fangled default encoding, then on their heads be it. (A simular argument could be made for .) For your class, it doesn't matter how it gets its stream of strings, as long as it gets it. Make this clear in your constructor: 

In this case, if the last index of the character at position is indeed , that means we have found our unique character. 

First things first: Generics Your is missing it. And I suppose your custom classes are all missing it too. That explains why you are -ing warnings. I'm not sure if the root cause is because you are retro-fitting some older < Java 1.5 implementations or not, but for type safety please use generics. :) Some other pointers: 

Using Java 8, there are arguably shorter ways of creating your parameterized statement by using on streams: 

Computation logic aside, this seems like a long-winded way of solving, saving and returning the created . For starters, calling multiple times will override the class variable every time, is this the desired approach? If one instance can generate multiple s, then perhaps it will be better for to made as a in-method variable, and have it passed around. However, if there should only be one per instance, then you need to check that you are not re-creating a every time is called. The following two steps, and seem to depend on the assumption that must be referenced already. Again, you may want to consider whether you want to make a method argument for them. It might be clearer from the method signatures, but if you more comfortable with ensuring is properly instantiated as a class variable, then that works too. It is also not clear-cut to grasp what exactly is going on in these few lines. If I were to read them literally (bearing in mind this is skipping the randomizing + generating blank cells, which sounds odd too): 

I'll only address C programming issues in this answer, not the algorithm itself. Program design and programming practice 

Overall, the program is fairly well-written and clear. One particular good thing is that you have grasped the concept of private encapsulation in C, by placing the static keyword in all the right places. You also use const correctness for your function parameters. All of that is excellent program design, so keep using it! Below are my comments regarding various issues in the code: Bugs found: 

There exists no reason why you need to use pointer-to-pointer here. It is slow and needlessly complex - a complexity that caused a memory leak bug. Simply do . Alternatively use a variable length array (VLA). If you for reasons unknown must use dynamic memory allocation, then do so on a proper 2D array and not some fragmented look-up table. See Correctly allocating multi-dimensional arrays for examples of how to do this - it is likely that your book or teacher is teaching you bad habits here. 

( please note that naming a variable "str_cat" is very bad practice, I just couldn't resist sneaking in a C programming joke :) )