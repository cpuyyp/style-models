From a first pass over - all you are doing are if else without any throw or inspection as to what possible errors that the PDO might be tossing out. Thats bad because on production servers - I would assume that you won't be turning on error/warning reporting but will be logging them. Also as @Alex L mentioned - you are missing a IF statement that checks if $pdo == null then throw exception. However its better with a try/catch 

I will extend mulquin's short post. Sanitizing your POST will enable you to make sure there are no SQL injection. Since you are using PDO - you should use prepare() function reather than exec(). exec doesn't escape your query. (as shown in the link provided by mulquin) Furthermore - you are not checking if the email is indeed an email or not what happens if its not a real email address (ie the format is not john@doe.com) - you will be storing gebrish at this point. So a bit of validation so that not only spammers won't just enter anything. 

If you are working in PHP use a framework that has MVC such as Laravel(up and coming and popular), Symphony, Yii, Codeigniter(defunct), etc. Each of them will enable you to use some reuse mechanism. Laravel itself uses a template PHP called blade. There are several other template mechanism such as Twig that enables you to template your views to even add more granular way and cleaner. If its a single file system that you must what you are doing is fine because you are using require_once it enables you to call other files and you can modify that file and it will reflect any other files that references it. 

Too many variables - the majority of the time the need to hold onto the DB's credential inside the object is not necessary - it should be part of your configuration of the APP and invoked as such then passed inside to the DB object to initialize the connection - once that is done you don't need this info. If you change information then a new object should be created. Why? because image you do need to connect to two different DB (one for user, one for tracking as an example) - if you store your credential your stuck to this. Also as I can see from your constructor - your not even passing your credentials to it - its fixed from a global stand point. The majority of your class is just a smaller typing of what is already presented ie: query, then bind, then execute. Its a rehash of the system's PDO. Another flaw is your Single() function - it has the command - what happens if your query returns more than one result and you want to iterate it one at a time - you can't re-execute the query to grab the second row. fetch()'s purpose is to go fetch and iterate through the rows one by one. You can argue that you can use resultSet() to grab all then foreach but if you are returning 10K rows you will be in a heap of trouble. Next - lets touch a bit of the tracking class. One flaw is the getInstance. Singleton are bad for maintainability because you can't make more than one object of it and its hard to test it. Ideally - since all your functions are relying on the database - you should have passed it (aka injected) is part of your constructor and then call your functions which uses the DB. Its not like you will instantly use a different DB within the function because you are tightly coupled from it. Basically: your Track class is your repository, and your PDO is redundant because its just shorthanding the coding. thats my first pass through of your code. 

Large Array There is multiple optimizations you could do, but only 1 that really makes sense here: Bin it. You don't need it. You pre-compute a lot of information that you reuse exactly once and that you can compute on-the-fly. There is no benefit in having this. In fact, you are making it worse by reading the once and then reading the array version of it, which is 40+ times bigger. Not cool :D The short version of it is that is wrapping python s which store 5-tupels worth 40 byte per entry. takes to represent in this format, whereas you can instead stick to a single character worth 1 byte and look-up the value as well as compute using the predecesor (which you know). This will save 40(!) times the disk/memory space (down to after optimization). Here is a version that uses , but saves only a character (worth 1 byte) instead of the tupel (40 byte): $URL$ I've also added as dependency and refactored your code (a lot) because I couldn't make heads and tails of it. Here is an even shorter version that no longer needs : $URL$ I also removed the timing comments, because that can be done more efficiently with or another profiler of your choice. In this scenario, I felt like the prints obstructed the code a lot; now it's easier to read. If a blinking cursor with no output irritates you, feel free to add more prints (at the cost of readability and a tiny bit of runtime). 

First of all, this is not a Python issue. Rather this is an issue of the implementation itself. I agree with @Gareth Rees . You should always provide a minimally working example of the code. This is true for StackOverflow and especially true for CodeReview. In that respect all we can review is the little snipped you provide under the assumption that the functions you don't provide do certain things. The first thing that you can cut is the block. It enters iff the last element of is in and what it does is it adds the last element of to ; in other words: nothing. As a side effect you do pop the last element and since you do it in both cases it is better allocated above the . It looks like will return an iterable thing containing all rank 1 neighbors of . If you don't do any caching, is incredibly slow! Loosely speaking that's for the naive implementation and for the one given in the blog post you mention. To make matters worse, you do this for every friend of a word exactly one (since you prune duplicates). So what your running is which in the very crudest worst case can be (!); although this case is only relevant for theoretical considerations. Here is a list of things you can do: 

should not have public constructor since it is only used in specific place with specific purpose. You can also consider just straight up using as your "builder". 

Note, that in neither of those approaches parent is responsible for actually rendering children. You are having so much trouble updating your parent precisely because you've neglected this principle. 

I am pretty sure you don't need to move cursor, if you call instead of . You are using both floats and doubles in your calculations. You should probably use one or the other. is unnecessary. I think it would make more sense for to take actual points as input instead of "delta"-s. Meaning you should move: 

I am not sure where your input/output classes are coming from, but they feel really outdated. This is definetely NOT how you want to design a C# application. If you absolutely must return a state of operation - use method return value for that. And use or enums for that, not strings. But it is not something to build your application around when you are using an OOP language. 

I am not sure that making your class static is the best way to go. In my experience in such cases its almost always better to make a non-static class and then to either inject its instance or initialize some field. 

Some of those methods should probably be refactored into members (or extension methods) of class, but its hard to tell, without knowing the details. 

What should happen? Well, it's hard to tell. First guess that comes to mind: there are now two different presenters with different views and different viewmodels. Second guess: there is a single presenter, and each call of method simply replaces the of a view. But both of those guesses are incorrect, and I would have never guessed correctly what actually happens. 

You should probably remove the constructors you don't actually use. Otherwise they look fine. What does not look fine is the way you use exceptions. Exceptions are... "exceptional". They signal that something really bad happened: an invalid state or an error in the workflow which your class can't handle. Exceptions should NOT be used as part of your regular workflow, especially not if you catch those exceptions straight away with an empty catch statements (which are bad enough on their own). In those situations use instead. Here is a quote from MSDN: 

There is a lot more you could do to the rest of the code, but that is out of scope for this question. 

Here is a faster version (around per batch). Its essentially refactored for readability and often in vectorized code, more readability / code beauty makes code run faster: 

At this point we could start to tackle the loop, but it would start to get very micro optimized. One might consider aggregating the results in prob and then using and outside the loop, but that only nets like so it's more of a personal preference thing. 

next we can get rid of and instead sample a array of uniformly distributed random numbers and threshold them. This also allows us to vectorize the for loop and stay in numpy even longer (0.786 seconds): 

Assuming is an okay thing to do you don't want to check after ing an element but rather before you insert it. It saves you the overhead of appending and popping visited nodes which can be quite substantial. Further, should be a (as stated in @Alex 's comment). It could also be a good idea to use an actual queue object, be that (for FIFO / LIFO) or a . The latter will slightly reduce performance (insert from O(1) to O(log(queue_size))), but offers a lot of added flexibility and easy scalability to graph search. Setting the priority to: is DFS, is BFS, (or ) is Dijkstra's search, is greedy search, is A*. I think that's a really cool property. 

Here is my list of thoughts (in random order). Since you don't specify any particular goal I am reviewing mainly for "relative beauty" of the code: 

Unfortunately, you didn't specify your Python version. In 3.X there is the flag. Hence you could refactor this to You could also get access to (there are implementations for 2.7 on pip). This would allow dealing with paths in a pythonic way, because you can now do things like: rather then and have python deal with the os specific bits (symlinks, correct slashes, ...) 

There are a lot of debug prints in your code snippet. I will mark them with a if I can't see any use for the end user. I would opt for removing them. 

Again a debug statement. There is not much use of informing the user that a query has been executed. He cares for the side effect of this, i.e. if there have been the correct rows returned 

Also, you should normally override equality methods if you implement . If returns , should not return . 

There is a in my application which I want to close automatically after a certain delay. And I want to have an attached behaviour which I could turn on/off and use with other popups. Google came out empty, so I implemented it myself: 

I'm not a fan of your usage example. The line looks really fishy to me. It looks like something, that should not happen in my imaginary web store, like some kind of error, which I probably want to catch and debug. However class hides this potentioal error completely and my application keeps working as if nothing has happened. Now, if is for some reason a valid value, then I guess its fine. Overall, class looks OK to me, even though I am having troubles coming up with a sceanrio, where I would find it useful. You could probably group public methods together though, it makes class easier to read. Also I think you are overusing operator. To the point where method's body becomes really hard to read. is fine when your function is a short one-liner (i.e. ). But you should probably use braces, when it is not (i.e your method). 

Only if I answer "no" to all of those questions I write a comment. In your case I would say, that there are places, where you clearly can extract a method. For example, this: 

To answer your question: those solutions are identical performance-wise. There is no "magic" in or methods: they do the same thing you do in your first solution - compare the two values using operator. There is no significant performance cost for a method call or for an extra assignment - those operations are so cheap, that you won't solve any real-life performance issue with this kind of optimization. If you will become obsessed with those small things - it will have a negative effect on your code quality. So, instead of asking, which is faster, you should ask yourself which is more clean, readable and OOP-ish. I would go with second solution. If you want to really speed things up - you should first identify the real problem. In your example - it is the number of iterations, not the number of assignments. So the faster solution would probably involve multi-threading and iterating through different parts of your array simultaneously.