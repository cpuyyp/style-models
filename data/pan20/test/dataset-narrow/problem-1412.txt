I can't help you exactly with code because I'm not sure where all your variables are coming from. If you provide some context to this code, I can help more specifically. In the meantime, take a look at this picture: 

Databases are designed to handle vast amounts of data. There are many types, with different ideas behind them; but in general they are for A LOT of data. Because of this, databases do require at least some complicated set up and a fair amount of knowledge. However, they are not what you need right now. If you are saving the data of just one player locally, there is no need for a database. There are plenty of other solutions out there that will work fine and not require extensive set up. Here is a good tutorial for Unity: $URL$ 

As Editor code goes, this is pretty straight forward, so don't worry. I would do it as a context menu for the component. 

In unity, a vector is implemented as a struct as opposed to a class. One thing this means is that you can not change individual values in a vector by assigning directly as you have done. You need to replace the entire vector with a new one. So: 

Runs just in Objective-C and not in Swift. Does anyone know how to convert it to a SCNMaterial, or alternatively to use another way to apply a bump map in a SCNMaterial? 

I'm trying to draw an Earth, as I've found the textures in this site: $URL$ I loaded the diffuse, specular and bump maps: 

But I know there are more, I just can't find a resource that mentions all the built-in variables. Also, some of these variables are passed by three.js classes, I need to distinguish the built-in variables from the ones which are created by the class. Does someone have a list? 

It is practically equal to a lambert shader! I tried a lot of parameters combination, but I never get a shiny teapot like it should be. I also debugged the shader, and it seems like the specular component is zero in many parts of the teapot. I tried to add an if that makes look red all the areas where the specular component is zero, that's the result: 

Where I set m to 0.5 and F0 to 2.0. But I think it's wrong because I'm getting a black area where there should be the specular light: 

If you know how far you want the sprite to travel, and you know the angle. You can calculate the x and y distances using the formulas from the picture. Hope this helps! 

You aren't over complicating it at all. This is a great way to think about a game. It keeps the game flexible for any changes you want to add in the future (say a stats screen). The first place I would look is using the Strategy Pattern: Wikipedia Determine what input triggers you would need and add them to an abstract interface. Then, implement the interface for each game state. Keep track of what your current state is and forward any of those input triggers to the current state to handle what ever it is you want to handle. 

In C#, having an instance (non-static) method in a class does not copy the instructions for each object created from that class. Static or not, the data that represents the instructions only exist in one place. The member variables, or state, of each of the instantiated objects do get their own space in memory. When you write a non-static method on a class, the compiler adds a first parameter to that method which is the location of memory where the specific instance's state is stored. In general, but no where near always: If you need a method on a class to access the state of an object, make it a non-static method. If you need a method that does something without needing state, make it static. 

Which seems very strange to me, I've seen other images of Ashkhmin-Shirley implementations on the web, and they aren't similar. This is an example: 

All the tutorials that I've found online speak about using Metal alone, without any other supporting library. But I don't understand if it's possible to create a SceneKit game and then use a Metal layer just to make some optimizations. 

I am following this guide: $URL$ Trying to create a tiled map that also supports multiple layers. The guide says that a way is to use depth buffer, and says to: 1) Create the z-buffer and a 2D projection; 2) For every layer in the tiled map, set the cc_vertexz attribute; 3) Enable alpha test and set the sprite alpha func. The first question is: if I use a tiled maps with multiple layers, are also the point 1 and 3 needed? I am fine with the first two points, but as for the third point I don't know how to do that. I should subclass CCSprite and override the draw method, but the problem is that when I create a tiled map there are already sprites on it, so the instances don't belong to the subclass I created. How I go around this? 

In those two sentences, the nouns are "player", "skill", and "condition". If you already have the player object, then you need to create skill and condition. Then, you need to have player possess a set of skills and a skill posses a set of conditions. Let's start with conditions: 

At this point, there are two things to solve for, v0, and t. This makes sense, you can throw a baseball right at your friend or way up high and still have it land at your friends location, even though it will take longer. So, I took this and created the following two classes that have the desired effect. 

Then, you can make any condition you want, let's say the one that checks if the player has a shield: 

and then, I assumed the target position would be relative to the start position, so p0 drops out. Rearraging to find v0, I got: 

Here is some example code to expand on my comment above. A true multi threaded solution would be faster than this, but susceptible to many more problems and edge cases. Unity's model for concurrency is coroutines, and thus using them aligns your code with what is expected in the unity space. Unless you have a real need for ultra fast file processing, this solution should work. 

I have a texture loaded in three.js, then passed to the shaders. In the vertex shader I compute the normal, and I save into a variable the uv vector. 

I already checked and it seems like all the uniforms and varying are passed in the right way, I pass P and N from the vertex shader. The variables are: 

I'm trying to implement the Schlick shading model in the fragment shader. I took the formulas from Karsten Schwenk's "a survey of shading models for real-time rendering": 

But I get a result similar to a lambertian surface or Oren-Nayar model, where the specular component is absent: 

I am writing an article on WebGL and three.js, I'm trying to search all the built-in variables available in the vertex and fragment shader. I've found many sites mentioning some, for example: Vertex Shader 

I checked many times the formulas and the implementation, and it seems like I've done all correctly. What's the problem? 

I implemented the Strauss model with the metalness, transparency and smoothness parameters, taking the formulas from the book "Programming vertex geometry and pixel shaders", this is how I implemented it: 

Finally, you need to add a list of skills in the player object and provide a way for that class to choose and use one of those skills to attack another player. Hope this helps! 

Edit to address comment If you want to keep the same position in the jump as the target moves, then you are no longer talking about a step-wise physics solution, at least not while the jump is happening. It is easily achieved, however, with a coroutine to handle the jump. 

This will create a copy of the current game object and point the next stop to this one. The last line will make sure that the new object gets focus in the editor. Hope it helps! 

I changed the multiplier to 10 here, because 50 seemed too fast, but you could make it 50 still if you wanted. Hope this helps. 

Then, in the inspector panel, you can right click on the rails component and select "Copy and Point." 

This ended up being simpler than I expected. Here is the process I followed so you can follow a similar process in the future: I started writing the basic physics 101 equations with some values in 2d space because it's easier to think about: 

I want one like this !! Maybe I am using wrong values of phi and other values? Or there's something wrong in the formula? 

Which I believe is incorrect. I guess I'm not applying correctly the explicit definition, but I don't know where's the mistake, I would like to know what I'm doing wrong. 

And I believe it's correct. Now since I need to draw it with a variable number of points, I'm trying to apply the explicit definition: 

light{Specular | Diffuse | Ambient} : 0xffffff (converted to a rgba vector of course); materialAmbient: 0x543807 ; materialDiffuse: 0xc6901d; materialSpecular: 0xfdefce; materialShininess: 27.8974. 

First of all I don't understand why there's H and H'. Isn't the halfway vector unique for both layers? It says that just p,r and F vary from layer to layer. But the fragment is the same, so I don't understand how to compute H'; I also don't understand, for how it may seem banal, what does [F D] mean. Is that just a plain multiplication? I don't understand why it uses the bracket square syntax; To compute D' should I replace p with p' and r with r' ? 

Great Question! In general, you should start with your high level objects and then think about what they do. So, I'm not sure about your specific use case, but I'll assume it is the following: 

I've tried both pure approaches in the past and, not surprisingly, I've found a hybrid approach is best. I tend to create a lot of custom components for individual entities and use a FSM when I need to change a lot of entities at once. Almost always, the FSM really only cares about one common aspect of the collection of entities. For example, if the components are locked or not, or if they are in their start position, or some heighten state position. So, mostly, the FSM is implemented by adding an abstraction to each of the custom components that handles that aspect and then using the abstraction in the FSM. In the door example, I would build a custom component that handles the door logic. Imagine the size of it (tiny), and it will do exactly what you want. Now imagine some generic component that will work for your door as well as a toaster. This case is certainly more complicated than the first component and probably doesn't do what you want and is impossible to change.