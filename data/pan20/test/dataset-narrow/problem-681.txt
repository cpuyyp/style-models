Enum Conversions It's not clear why the enum and the enum are created. The implementation in syslog.h is pretty clear. If you absolutely have to convert from the macros in syslog.h then you might consider using std::map which is another of the C++ container types. The std::map container class can be used to map integers to strings, integers to other integers, and integers to functions. It can also map other things to each other. The values in syslog.h have been designed so that a single byte or word can be used to test if they are enabled or not. This is a space saving feature that one needs when doing embedded programming. 

@chux and @coderodde did a good job of covering the issues. The function free() is being used correctly and it is deleting the memory. The list in the implementation can't be sorted, because the nodes can't be inserted in the middle of the list. The implementation needs a general function and a general function. The functions currently in the implementation handle the edge cases or special cases, they don't handle all cases of insertion or deletion. Inserting into the middle or deleting from the middle requires more interesting logic that will keep the linked list intact. 

While the compiler will correctly optimize the previous statement, someone reading or modifying the code may wonder why the code was written this way, especially someone unfamiliar with C macros. When optimizing C use registers as much as possible rather than normal variables, this makes the code smaller, and registers are faster than normal variables. To make the code more portable perhaps the use of typeof can be changed to . You are probably aware that typeof is a compiler extension and not defined by all C compilers. 

One possible solution would be to create a function that calls and then tests the return value, this would apply the DRY principle (Don't Repeat Yourself). 

Exit There should never be a call to in a library. If for example this code was included in a daemon or some other part of an operating system you would be shutting down the system without meaning to. The best you could do here is to require that a command is used in the linking program and do a from the assert function. This allows the calling program to clean up and perform the correct actions in this case. A library will never know what other actions are necessary. Incorrect Usage of Header Files Header files should generally not have executable functions in them. Part of the reason is that if multiple files include the header then at link time the linker will complain about multiple definitions of the functions. You seem to have worked around the multiple definition problem with complex #ifdef statements. It would be much simpler to have both a utl.h and and a utl.c. The utl.c file contains the executable functions and the utl.h file contains the function prototypes. This is a very common practice and could be considered a standard. This would also remove the requirement for most of the header files included by this header file. If you are creating a library that may be used by multiple programs you should probably turn utl.c into either an archive library (libmylog.a) or a dynamically linked library (libmylog.so or libmylog.dll based on the operating system). 

Programs should always clean up after themselves, there is no code to close all files at the end of the program. In the , the owners_ID array should be long rather than int. These lines give warnings when I compile the program, there is no guarantee that and will be the same size on all platforms. The type int can be as few as 16 bits and as large as the word size gets. If the mismatch continues use an explicit cast from long to int 

A collision is when 2 different functions have the same name, the same argument types and a similar functionality (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionality of a class such as std::vector or std::stack. Namespaces allow these constructs to be overridden. The use of the programming statement: 

Slow Compiling Two possible reasons, one is that the macros are hiding the fact that there is at least another 160 lines of code in the header file, and you may have independently rediscovered why Microsoft C++ and especially MFC have pre compiled headers. The compiler has to do a lot of work and substitution for template. You may want to allow the user to use the templates in the C++ source files for only the types they actually need rather than including the macro usage in the header file. 

I do this even for single statements because if the code needs to be updated by adding a statement to a block it is easier for anyone to see where the line of code should be inserted. This was also required as part of a coding standard at a company where I worked. Empty Clauses in IF/ELSE In the function shannon() the code contains: 

Separate the Implementation From the Test If this to be implemented as a library, it would be better to put the functions into another C source file and provide a header file. This would allow for hiding the implementation from the users. It might also be better to move the initialization of the heap and other variables into an initialization function in the C source file. This all would prevent user access of MYHEAP. Control the Output of Rand() When I ran this on my MacBook Pro running El Capitan nothing was ever allocated because ALL the values returned from were greater than 2000000. You might want to limit the values returned to be under 2500000. 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and stackoverflow question. Don't mix printf() with std::cout It would be better to choose just one output method, either printf() or std::cout. In this case since you are using it might be better to stick with printf(). Generally in C++ printf() is ignored in favor of std::cout. The output to std::cout can also be formatted. You may be able to use an errno.h that gives you the correct string and use std::cout rather than . 

Use Meaningful Variable and Function Names The code contains and in a number of places. These are not meaningful names. The names should indicate what the variables are, so that if you or someone else needs to change the code 2 years in the future it is an easy task rather than having to go through all the code to see what needs to be changed. Another exmaple of this is the function , which could be renamed file_size(). A third example is the array . Other than array if doubles it is not clear what this array is used for. Inconsistent Coding Style In a professional setting where multiple people may have to maintain the code it is best to be as consistent as possible. The else clauses almost always have }` but the if statements do not. This is true whether or not the block contains multiple statement or not. You should choose one way or the other. In the loops the is immediately under the , but in the clauses it is indented. Choose one or the other. The most common usage is how you do the for loops. This is partially a matter of choice, I use on all control statements: 

This number can also be derived by which also might be more meaningful. Use Common Library Functions When Possible The code contains this line 

Just pass in the lock, the address and the value to a function. Code quality is sometimes measured in errors per lines of code. The less code there is, the less the possible number of errors or bugs. Possible Performance Optimization The use of may be slowing the program down. It might be better to use '\n' in most cases. flushes the output buffer. Flushing the output buffer consumes time and is generally not necessary. Portability This may not matter in your particular use case. Because of the choice of functions the code uses, this code can't port easily to other computers. The address constants may differ on other systems as well. 

Complex Functions It might be easier to understand, debug and modify the function if it was broken up into sub-functions following the Single Responsibility Principle mentioned above. 

This problem is a lot simpler than you think it is. The printf() isn't saving that much time because the printf() is only executing once per program run. Where the code should be saving time is in the calculating loop. First it should only be using stream input and output, the code does not need to do the conversion from string to int, this will be handled by stream input and stream output. This will speed up the algorithm a lot. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. Don't Ignore Compiler Warning and Error Messages It is unclear whether the code was ever actually compiled and tested, and it is clear that it was never compiled without DEBUG defined. I have compiled this using Visual Studio 2013 on Windows 10 Pro and XCode running on El Capitan. In both cases it doesn't compile because the function declaration in the header file is wrong. 

A good way to reduce the amount of code in the program is to create a function that copies the data from one structure to another. That would would reduce the amount of code in the program by almost 30 lines. Writing it in a function also makes it much easier to write and debug, since it only needs to be debugged once. Use Symbolic Constants Versus Numeric Constants In the code there are raw numbers for the first names size, last name size, neptun code size and subject size. It might be better to use symbolic constants rather than raw numbers. An Example: 

One thought about the above code, it might be good to create an array of tuples called Wall and have the addWall() function use the array to create the wall. The main() function The main() function is fine in this program, however, if the program was more complex all the main() function should do is 

Since x, h and n are loop variants, it would be better to delcare them where their values are assigned: