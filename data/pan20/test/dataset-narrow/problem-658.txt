And then the rest of the code is contained within the clause. The branch never escapes, so you don't need the else. You can simply do: 

I would tend to use either properties on both sides, or fields on both sides. Primarily because if the property is changed to do anything other than return the field you could end up with different results when comparing and . Construction Order Again, this is probably personal taste, but I'd finish constructing the class before updating the internal state: 

Timing Each time you use your class, you go back to the filesystem. You might want to do this, but it means that there is a possibility that the files shown to the user won't be the same ones that were copied (if new files are modified). You could cache the retrieved list of files instead so that the same files are shown to the user as are copied. Putting it together Using the above suggestions, your Program class becomes: 

Assuming I'm correct, then it looks like you have a potential bug in your loop code. At the end of it you have a line that checks the current and if it's not 1,2 or 3 it calls . 

You don't have an else condition for this check, and if this condition is triggered, it means that isn't pointing at the end of the queue and you've got something very wrong with your collection. Either remove the check, since it can't happen, or throw an exception when it does, don't just pretend everything is all right. 

Comments Comments should tell the reader why you're doing something, not what you're doing. Comments like this are redundant: 

Nested ifs and input1, input2... If you look at the following code, you'll notice it checks the value of is '1', then fetches a new value into . However, you then check for '3', which it can't be because we know it's '1'. The check may belong somewhere else, or you may be checking when you should be checking . 

Giving up control of the running thread could be achieve using (although this isn't particularly efficient) and you may want to pair it with . For flags, you probably want to look at either and/or variables. 

This isn't a full review, just a couple of points: Help Text You have a method , not included in your code. I'm assuming that it returns a formatted help text that tells the user how to run the program. To get this output currently you need to know the command line arguments for help. Rather than having the user guess until they get it right, why not have this as the default behaviour if the args can't be parsed correctly? Stdout/Stderr You've got several methods that refer to and (, ). This may be OK if you only ever intend to run the application from the command line. If however, there is a chance that you might want it in a library, or to put a GUI in front of it then decoupling it now may be worthwhile. Putting a wrapper around / something like or would minimally change the code, allow the output method to be easily changed in one position. 

You close the , leave a blank line then put the else. It makes the feel detached. Pointers What are you getting from storing pointers in your , rather than instances of . Since you return copies anyway from your method, it feels like you've just added extra handling requirements for little to no benefit? If you want to save duplication then storing and returning a instead might be more efficient. Hidden Behaviour I'm not sure that having behave differently depending on whether or not you pass it an empty string is a great idea. If I pass in "/someFolder" then the folder is read. If I pass it in again, "/someFolder", then the folder is read again (so any new files would be noticed for example). If instead for the second call I had passed in "" then the original folder contents would have been returned. If this is desired behaviour, then I'd at least put a comment in the header / documentation because it's not what I would expect. 

Summary This is obviously a personal opinion, but I don't really like the interface you've defined for your list. By defining your methods in terms of a , you're making the caller responsible for constructing Nodes. It seems like Node should be an implementation detail of your list. Otherwise, since the caller has complete access to the Node they can iterate the list and modify it without the class being called at all. I'd define the interface in terms of the Data that is to be stored, currently this is an , so you would have something like this: 

If your CPU is rising to 75% and staying there (not bouncing up and down), then it suggest that your script is spinning and not hitting any of your sleep statements. There's a few things that may be worth looking into. 

If either of these isn't true and the remove thread actually blocks on these variables, it is because the thread is blocked on an empty queue that it expected to have an item (which seems like a bug). It will wait an indeterminate amount of time during which it isn't going to service other queues that might have items in them. 

There's a lot going on there for a single line. It's a lot easier to read spread across multiple lines: 

Why both having the second argument if you're not going to check it, it's just extra typing... Wildcards It's not really clear from the spec, however the built in 'find' command supports wildcards. Your current implementation doesn't appear to (you're only doing an exact match). 

childtype This gives me a compiler warning because not all paths return a value. In reality, this shouldn't be triggered, since the parent should have a child pointer, however you should make this explicit in the code. There's no need for the else, if you're not the left child, you must be the right, or something is wrong: 

Also, if you've only got two cases as in this case it should be an statement, not a switch. ID On the surface of it, I'd expect the ID to be unique, however you don't ensure this. It's possible to get multiple records with the same ID. Is this by design? Because it feels like a bug. malloc You don't need to cast the return from . Sometimes you don, sometimes you don't. Be consistent, it makes your code easier to read and generally err on the side of not introducing unnecessary code (so don't do the cast) like this: 

Both tests simply verify that an instance of is returned. Really you should be looking what the method does and testing for that if possible. It seems like for some indexes it returns a new whilst for others it returns . What's the differences between these two returned objects? Are the methods being called public or private? It could be that testing that calling from your test returns that same instance as calling for certain indexes is a sensible test. Or maybe it's calling with a known index always returns an expected list of capabilities. You've said modifying production code to make it more testable and using mocking is a no-no. How are other classes within the system tested? This should be a good indicator of the level of testing expected for your project. 

This isn't really what you're looking for, just some general feedback on your code. I find the code quite difficult to follow, resolving some of the issues below to help with readability might make it more likely that you will get feedback that aimed at your algorithm. Naming Your names seem overly concise. A few extra letters won't make any difference to the speed of your application, but make it a lot more readable. Variables in are ,,,,,,,,,t2. Without looking at the context, these names are meaningless. Your method is similarly nondescript. Perhaps might be more appropriate? Consistent expecatations In main, you reuse the variable name for both an and an . Switching variable types like this makes your code harder to follow than necessary and illustrates that you could benefit from more meaningful names. Indentation Your indentation is all over the place. This makes it difficult to read. Sometimes you have indentations next to each nesting level, sometimes you don't. If it looks like this in your development environment, you should fix it. If it doesn't, then you need to check the preview when adding code to questions. Usually copying the whole thing from your IDE, selecting it and clicking the icon will format the code correctly. Consider this: 

}// comments You don't typically see many comments on closing braces indicating why the brace was opened, it just adds clutter to the code. They can be useful where you have large blocks of nested code, however as I've said above this is often an indication that you need to break your code up more. loops can be your friend Your case statements again, have a lot of duplication in them. This is because you've created an if/else chain for each letter in the word. This structure could be replaced with a for loop (pseudocode): 

Tabs Vs Spaces Your code formatting isn't consistent. Looking at your code, this appears to be because you're using both tabs and spaces for white space. Which is why you end up with code that looks like this (notice the printf doesn't line up with the exit): 

Another example is , of what? perhaps? Naming is hard, however if you get it right it makes your programs a lot more expressive. Unused variables If you change your plan for your program, don't forget to clean up after yourself. For example in , you're declaring two variables that you're not using ( and ). Expressive names Consider how much easier this would be to read with more expressive names and meaningful constants: 

These lines essentially output a menu of options to the player (subsequent lines fetch the input and decide what to do). This is a prime candidate for extracting a method to perform a common task. For example a method which displayed the menu and returned the selected option. You may want to consider using an instead of an int to indicate the selected option. This will make the code easier to read. You've then got two lines that you use to display the current state of a fight. This: 

One letter variables One letter iterators are ok, however when you start getting multiple iterators in the same method it may be worth giving them proper names so that it's more obvious what's going on. This is far from transparent: 

However you also need to consider each node in the list. You can either have delete it's , or you can put a loop in to delete all the items in the list from the tail backwards. Usually you would also implement this in a public function like or so that the whole list can be easily emptied. For example, something like this would clear up the list: 

Since gate_Leave returns an int and is often (always?) used to return values this is probably costing you extra instructions (although it might not as the function is inline, depending on how clever your compiler is). Indentation and Labels Labels are quite important in assembly. I'd consider adding indentation so that they are easier to find, a lot like you would indent the contents of a loop. 

Auto Properties If you're not really doing anything in your properties, other than passing values back and forth to a backing field, you should consider using auto properties instead. 

Listen/Read Thread It looks like you're only expecting a single client (your listen thread doesn't contain a loop to accept more than a single connection). Rather than spinning up another thread to perform the receive functionality, you might as well be doing it in the same thread that you performed the listen on. Listen Management Your listen code doesn't check the state of the Server before calling start. If you click it twice, it seems likely that this is going to cause a problem. Exception Handling You don't have any exception handling around your read/write calls. TCP can be a bit of a pain at times, depending upon how the connection has been shutdown it may throw various exceptions rather than just returning 0 from the read call. It's also worth remembering that since you're accessing the socket from multiple threads it can change state between your is call and your operation. 

IComparable The way you've implemented is confusing and couples its implementation to its expected usage. is supposed to return one of three values, to indicate <,==,> the item being compared to. Currently yours only returns 2 values, it's either the same (0), or it's less than. This is confusing because it means that the result of: 

Globals Your tree seems to be built around a global parameter . This effectively limits you to only having one tree in your application at a time. Collections are quite common, so this seems like a restriction that will cause issues in the future. Example usage As an extension of defining the API for your code, it would be helpful in future to include an example of how to use your code. I had a stab at creating a list... It looked like maybe the way to start was with the method. This accepts two parameters a and a value to add. From what I can tell, the first time you call this, it ignores the , assuming that you want to create a new list using the global pointer, so you can pass node as NULL. The second you call it however it uses node so if you pass it as NULL it crashes. This is somewhat inconsistent. With that in mind, your public api should perform some kind of validation to make sure it's being called correctly. Some example calls: