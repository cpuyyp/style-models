Ok, this is a range to value issue, and in this case you have very few ranges, but I still would prefer to see the use of a "map". Assuming percentage is an int, you could do something like this: 

This isn't really "classes" it is one class for the entire game and every aspect of it, and a function that drives it. There are 8 winning "lines" on the board which, if they all hold the same value and are not empty, is a win to the player whose value occupies each position in the line. Make a line into a class. That class can check its status. Each cell could be a class and from the cell would be able to find all the lines it is contained in. That could be a method and generated "on the fly" or could be cached within each cell. Thus when the user plays into a cell you'd only need to check the lines within it to see if they have played a winning move. Only the one who last played can have made a winning move. There are 4 lines for the middle cell, 3 for a corner and only 2 for an edge. 

Of course fmod is potentially less efficient than converting your value to an int once then using % to check for mod. 

Firstly, as this is meant to be for code reviews, I will immediately point out that you are putting everything into main and you really should put the algorithm into its own function. Your main can look at its argument list and possibly support having the parameters in there. For simplistic terms you can use them if they are there and prompt if not. For an implementation of the function, it can be a simple free-function. There is no need to use a class for it. 

Make the collection type templated. Keep the queuing / threading logic in a non-templated base class so that it did not need to be exposed in the header file (unlikely the templated collection it was protecting which did). 

The first thing that meets my eye is all this C-style casting, and in particular you are casting long to pointers and back. Why is the code not typesafe? If you want a pointer use a pointer. If you want a number use a number. Your node class. Well it's "struct" but that just means the members are all public. It doesn't mean you can't put the logic within the class itself - how they are created, how they manage their data, etc. Actually there were other things that caught my eye first like using namespace std; Get rid of that. 

This was posted just a short while ago on StackOverflow.com Firstly, if this is legacy code that has existed in production for a long time, then even if you can make it semantically better, you have to really weigh up the gains against the losses. Changing code is a cost, can introduce bugs even when the new code appears to be a lot better, and has to be justified. That the existing code uses a lot of arrays does not mean it has any bugs, nor would the "improvements" give you better performance in any way. However, on the basis of giving this code a review I will do so. Basically, start off by getting rid of all the arrays and calls to new[] and delete[] and use std::string (which is used there in one place so it is obviously known to the programmer). Ensure your IniPersistInf class is const-correct so takes if it takes a string that it only reads, it uses or rather than . in appears to be for writing into, so for this one you might use . In such a case, to get the pointer out of it, use when you pass it to the methods. 

However this is rather annoying. So there are 2 ways we can fix it. Either change the predicate in the map to sort downward. Or simply make our keys negative. We are hiding the implementation so it doesn't matter. 

Of course it doesn't have to "derive", but separate concerns of the collection type and the locking logic. The other thing I have always implemented in this kind of collection is multi_push and multi_pop whereby a producer can add more than one item in a single locking action, and a consumer can similarly clear all the data to process rather than pull them off in ones. 

You have asked for a "review" but really asked whether your deleter is safe or not. Whilst the deleter looks to be technically not an issue as you can go from your pointer type to void* and back and should get to where you started, it doesn't look right to create your variant through in which you are not storing any type-info so how exactly do you get the values out as the values? Variants in C++: Yes I have seen loads of implementations. I have made my own too. Even boost contains two. We would need to know really more context of what types you might store, and how you need to extract them. The reason there are so many is that often you are going to have lots of them, carrying lots of data about, and they need to work efficiently for your own situation. 

I don't actually understand the problem or what the algorithm is you are using to solve it. I would say use streams rather than scanf / printf. I doubt it is the I/O that is making it slow. More likely to be the algorithm. 

That the tree is modified is not an issue for me. Your function takes the tree by non-const reference, and if you want to keep the original you can always "store" the original. That you read from a file is not an issue either. The algorithm has been separated from the way that data was read in. I would probably have gone around creating some nice OO DAG and then use depth-first or breadth-first search. But then mine would be more generic for DAGs in general. Either way, in my solution I would return the path itself as well as the result, something yours does not do. 

It's not really the place here to teach the user the full detail of what is. I will summarise to say firstly that it is one of the main collection classes in the standard library, and is mostly used as an associative array, that is, a unique key on which you look up and find its associated value. Used that way, the key either exists or it doesn't. However there are occasions where you are not interested in exact key values but ranges, and you can take advantage of the fact that is a sorted container on its keys and that you can use and to find the points where your "key" belongs even if it is not actually in the container. (The only difference between lower_bound and upper_bound is when the key does exist). The fact that it returns an iterator, which can either point to one of the elements or one past the last one. And that it is logarithmic in its lookup. For this instance where you have just 5 keys the performance doesn't really matter, but it's useful to know in general as part of your general education. That you can use it to solve this particular kind of problem in C++ is useful. Some languages only use hash-table lookup for associative containers, which can be faster when it is only an exist/not exist situation but not useful for ranges at all. 

You are taking a copy of the inner map, modifying it, then putting it back. That could well be inefficient. You could take the inner map by reference then modify it. However you can actually make use of the fact that inserts if it does not find the element. As that is the behaviour here you can do what you did in 2 lines: 

On a style issue, one does not commonly use an upper case letter as a variable. You also have ID as a variable but elsewhere your variables begin with a lower case letter. You should be consistent throughout in your style, and ideally adopt what is the most common style for C++ programmers (which is generally agreed to be beginning with a lower-case. Some prefer camel-case and some under-score delimited). You could also decide instead of nested maps, to have a single map with a key consisting of . This might be slightly more efficient as copying maps around could be expensive. It would mean however that you could not as easily search for all the elements from ID. 

Thus for 2, you mark 4 and up. For 3, start with 9 and all the powers and also 3 multiplied by all odd numbers. You "mark" a number with the prime currently being used. So if a number if marked with the current one you use it anyway. For example, you have marked 15 with a "3" but you still use it for now 3*15 = 45. The numbers you have "marked" then get removed from a "list" so that the next iteration only runs through unmarked numbers. Once you have done this you have all primes from 2 to N. (Note: this is Eratosthenes's algorithm, that you suggested you might want to use). For your huge primes, you have a smaller list of numbers to test against. For the actual code itself, I do not like the class being called "PrimeNumber" and then having a vector of its "factors". Because a prime number doesn't have factors other than 1 and itself. So it isn't actually a prime number and it's a misnomer. I would typedef the and not put in the header file. Also make the code const-correct.