"Input" represents the source of information. In your case it is the keyboard input "Output" represents where any information or result will be published "Calculator" represents... what should I say... the "main"-method puts it all together in a sequence 

General First I appreciate your approach and exercing OOP as it is the most natural way to put reality into a model and final into a program. I already noticed this question at an earlier state. As I am thinking this is going into the wrong direction I want to butt in. Listener Pattern Your listener pattern is not implemented in the standard way (TankStatusListener). Your WaterTank should have add(TankStatusListener) and remove(TankStatusListener) methods to manage objects that are interested in status changes of your WaterTank. The listeners should NOT given as a parameter(getWater(.., TankStatusListener)). The listeners that are added to the WaterTank should be notified after the status change. It should look like this: 

Derive a Caching enabled ChildProxy from the "Child" and intercept the getParent()-method to check for a cached Parent-Object. If you would have a JPA-Layer you may not need this because OR-Mapper often have their own caching mechanisms that are sufficient for most usecases. 

One other thing: the abstract Composant-class is irrelevant to the abstract factory in your case as far as I see. Furthermore it will bind you to a set of methods that "Menus" and "Bouttons" have in common. This would hinder you to configure special properties of "Bouttons" and "Menus". The two types may of course stay derived from Composant. I thought about it a little bit when the use of parameters in the factory pattern may be appropriate. In the following example (in pseudo code) a LabelField or a LabelArea is returned which depends on the size of the given text. 

And so on until you have only short methods with speaking names. This makes the code easier to read and understand. 

by an Enum which would add typesafety and also helps your IDE to detect e.g. if a state is not handled in your statement. 

You need to check if each letter occurs the name number of times in both strings. One method would be to sort the letters and compare the lists of letters for equality. Here is my approach: 

REMARK If there is any rule for the distribution of the intervals, you might be able to calculate the correct interval (or at least calculate a good guess and search from there). 

In my point of view you cannot implement and any clearer or simpler. In the method I would somehow separate the values and also not print two times and not at all. Here is my suggestion: 

I think this method is not that long that you really need to refactor it, but you could do something like 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

But only profiling will tell you if / how much speed improvement that brings. Also you should always profile before trying to optimize. See were the bottleneck is. 

If a number can not be divided by 2 it can also not be divided by any even number. So you can check2 and than only the odd numbers. you can make a list of all little prime numbers and check these and from the point where you have not the primes, try all odd numbers you can stop checking at sqrt(n) but that is quite expensive to calculate. Not so good, but still halves the work, stop at . 

As you are dealing with whole numbers and remainders do not use floating point numbers. It's inaccurate and furthermore confusing because others may think that the result may be not a whole number. As the solutions will get very high very fast consider to use BigInteger During calculation make sure your divisions will always be without rest Avoid return statements within the loop. Programmers have to search for breaking conditions through the code if you do not provide them in the loop header. Beside readability unexpected return, break or continue statements cause serious problems when extending the code or applying refactorings like "extract method". Use lazy evaluation of boolean operators (&& instead of &). In complex evaluations you give other developers the chance to count on the evaluation and produce side effects. Separate responsibilities. Currently two algorithms are fighting against each other. One is providing a factor and the other is using the factor to try a calculation. But maybe the second algorithm is not satisfied by the factor what is evaluated during calculation. This should be modelled explicitly. 

The main problem of your solution is that your methods have temporal dependencies. Your are manipulating the "purchase" variable on in total different states of the object without checking if it is allowed. What if someone calls the method to calculate the tax twice beforw you even have a purchase? My suggestion without providing code but providing a strategy: Try to keep your object inner state consistent whatever the call order is.... OR If your structure may be inconsistent do not encapsulate behaviour on it. Let it be a simple Value object. This will be a more functional approach. 

a and b (alpha, beta and c missing) a and c (alpha, beta and b missing) a and alpha (beta, b and c missing) a and beta (alpha, b and c missing) 

If possible I would try to avoid a method like . If someone manages to manipulate the this becomes a classical injection problem. If you do not need the flexibility to make any kind of db requests, use prepared statements for specific requests which only get some parameters. 

calculate distance to each polygon surrounding circle and eliminate all polygons which are too far away to be a match Entity: performs a loop through all not eleminated polygons. Polygon Loop: loops through ALL vertices of the polygon in the current iteration. Vertex Loop: if the distance between the entity and the current vertex is lower than the distance between the entity and the previous vertex, save the current vertex and the ID of the polygon the vertex belongs to. Once all loops are finished, take the nearest polygon/vertex and get the vertex of the polygon to the left and right of the nearest vertex. Check the left and right vertices to see which is closest to the nearest vertex. Doing so, finds the nearest line of collision to the entity. 

This algorithm is far from optimal runtime O(n*logn), but I have chosen it because of its simplicity. For an Efficient algorithm see the comment of @corsiKa for a quite simple O(n) algorithm. 

To see where the bottleneck is, you need to profile your code! Here something which may be a little improvement: replace: 

You can also unroll the - loop, by copying the inner body 2 more times. If you can manage to change the mask_function: 

to a method passing 1330 or -25 as a parameter and reuse it instead of having nearly exactly the same code twice. 2. You can extract 

I have never written any Lua code before, but a short view in a tutorial at $URL$ let me come up with this: Extract a method which returns 3 values: 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

Decoupling receiver from sender. The WordTextField does not need to know if the action was initiated by a button. It could have been anything that triggers the model change. Decoupling UI from Model, so you do not bind yourself to a specific UI technology anymore. Throw away Swing and use JavaFX. This will also work. If you do not see any necessity to change your UI technology it remains decoupled code. The model will be testable without any visuals. 

According to Wiki "a god object is an object that knows too much or does too much". The general problem I have with this is: What means "too much"? Your question is about searching an absolute statement as we already know we can only find absolute statements within very restricted areas (and that's what they all have in common) that are not related to reality. As soon as we deal with real world applications we have to deal with uncertainty. That is because we derive OO models from reality as we perceive it. And this can be error prone. To escape this dilemma in computer science some principles are discovered that lead to a step by step improvement of source code. They are called S.O.L.I.D. principles. If you violate a principle your source code becomes worse. So the target is to violate the principles as less as possible. So easy as I say it: The violation of these principles is an identification problem that sometimes becomes very very difficult. In the case of the so called "God class" the "S" of these principles is addressed: The single responsibility principle (SRP). It says that one code fragment (module, class, method) should only have one responsibility. BTW this is applicable to other programming paradigms as well. A "God class" seems to have at least more than one responsibility. That can be said for sure. Anything else is popular speech if someone says "God class". So working with SRP your code will improved step by step by identifying violations of this principle and eliminate them. That is by consolidating redundant responsibility and vice versa by separating different responsibilities. But the whole thing only works if you identify the violation. And that's the core. To identify a violation you look for indicators: 

You could extract the content of inner loops to methods with speaking names. E.g. You could introduce a method like 

to a method passing true or false as a parameter and reuse it instead of having nearly exactly the same code twice. 

It is a matter of taste, so there is no 'better'. But more common seams to be because often the conventions of JavaBean are used. If you work in a team, I would discuss the naming conventions to use with them. 

So binary search should be faster, if comparison is the main factor, for n > 4. If n is constant (its seams 64 in your case) you can even hard-code the binary search to avoid the overhead of a loop. (that is also possible for linear search.) As an example how to hard-code a binary search: [for a array with 8 entries] Code will get quite long for 64 entries, but it will be fast. If your intervallBoundary array is intervals[0..7]: 

If shape and number of polygons do not change (or at least not often), I would add an extra step (the new first step) to your algorithm. Calculate the center and radius of the smallest surrounding circle for each polygon. This way you can calculate in a minimal and maximal distance of all vertices from the given position in one run without iterating through them. If the minimum distance for a polygon is greater than the maximum of an other polygon, no vertex of that polygon can be the nearest => we can ignore this polygon. Than proceed like you did before. 

I think you can improve the 'Inverse rotor pass' a lot by hard-code the inverted rotors instead of searching the inverse function every time. Your is never below so you could try to replace