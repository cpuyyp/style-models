You are calling on a source basically retrieving the whole collection with all the properties and only later you are taking just the two fields. If you want to reduce time and space - try taking only what's needed from the underlying source, but also it greatly depends on the typo of source you are using underneath. Consider dropping the LINQ at all. LINQ is great and compact but it has it's 'dark side' in term of hidden allocations. Also think abount some old-hasioned ways like 'paging'? For the dropdown that might not be the best way - but maybe it is. If for most cases only the top 20 repair issues are accessed then here's your optimization - and for few cases user would need to load more items to the list - that might be ok. 

and similarly in the second place. Also some checks for input length might be good to do. You should also comment more your code. I strongly believe the code should be self documented but not on such low level as asm :) So comment more. GIST 

I would write an extension method to do parsing of input string. so it should not be inside your query method. I have declared a class named SearchCriteria to encapsulate all data member you want t o query. 

once this is done you can further refactor your if else clause in a strategy pattern , so you will need a factory which will return class will handle the Archive rule or mirror rule inside a different class and your FileActionService will contain only processing logic 

you dont need this whole code in this way , rather create a logger class and put this whole line of code there. Pass only dynamic parameter. Once you are able to cleanup , pattern can be applied easily 

Here are few comments 1) Try to encapsulate the piece which is subject to change. your code is dependent upon amount which can be withdrawn so rather one by one division you can create a list which will consist of that piece only. 2) Use for loop in case of repeating logic. (See below) 3) Prefer Writing Extension method 

Compare Your compare method is kinda strange. You do not iterate at all and you don't use any opcodes that would do that for you. It works only when you have one-char secret. Not so cool :) I would write it like this 

The actual string starts on index 2 and before that you have max string length, and bytes read. Also there's no at the end. You have to put it there. 

A bit of explanation. This macro will do all the work that is required to check if a specific flag is set (specified as operand op1) and if so print the message specified by operand op2. We need to specify also our label as local so that there is no label duplication when macro is placed in code multiple times. We also keep the flags to be restored after printing. Having this we can simplify the code a bit to basically this: 

2) Always dispose the connection In above code your opening connection and closing it, but this can lead into connection leak in case of errors. Please wrap your code into using statement or try clause like this 

okay first of all, you need to use buffered stream to read data from the file, there is no need to write data once in file as it might hung altogether. so I would suggest that read the file line by line , parse it and then write to file. 

Just continuation to @Malachi an here is a generic version of ExecuteScalar, so it is good so you dont have to cast it again in code. 

Please separate out your code into at least two classes 1) Fetching data class 2) UI binding stuff class 4)inline SQL vs Stored Procedure Stored Procedure is good as your code lies at one place in db but creating Stored Procedure for one line of SQL is not a good idea. If your logic is going to be complex and big ,Use a Stored procedure other wise inline sql. PS: I have created a gist named SQLHelper class for you to abstract out the sql connection and command things, $URL$ 

What we do here is just divide the number in by 10 and print the values stored in (result - only if >0) and the - reminder. Printing the hints On fourth attempt you are putting the character to be printed in . It should be in . You don't also have to use different registers so just: 

as in the will be the number of characters not the ascii representation of that number. If we could restrict ourselves to maximum 9 characters that would be easy. Just add 48(dec) to the and you get the value. Since your secret is limited to 21 characters we could go with a simple method for printing. 

which is just . So let's call it like that and make sure a requirement that when calling it we have dx 

You have a bit of code duplication that could and should be removed to avoid mistakes. FASM supports macros that you can use to remove duplicated parts. One can define a macro: 

Well code look good, any changes will be just a over thinking. one thing I want to make here is to specify variable for that calculation.this will make a bit readable ( not a very big point though) 

Have you considered using views:- -views gives you an explicit way to reduce the complexity of code. so your whole line of code will drop to only few lines. you can replace each subquery with the same view name (or named common table expression as Phrancis metioned) then the optimizer knows it's the same thing and can either cache the result or restructure the execution path so much better than inner query 

Well I have changed your code a bit to make it cleaner.It is recommended to have a uniform interface for methods, so now you have two methods in FamilyExpense class is addExpense and another is getExpense rather explicitly calling each method. I am not sure why you have used getFamilyId and setFamilyId. 

You have a bit of code duplication that could be extracted and consolidated. But first with some error fixes (at least the code did not compile on my TASM). Compilation issues 

is defined twice. First as a string ( and the second time as a label. I would rename the first one to and use it in 

Buffered input I don't know why you chose buffered input as your method of entering the hint, but in case of this command the data has a specific format. 

Other things that might be good to fix You have the same loop for scanning the characters. Why not enclose it as another proc and just use in those two places? You can make assumption that for example will point to the buffer that has to be filled. Also in this scanning you could handle for example backspace character and delete the characters. 

Without the actual model and some numbers (how long does it take to execute/ how much 'space' it takes?) might be hard to optimize, but what I can tell is that you call quite a lot in such short method. When you do call it you basically iterate over a source (is it DB source? in memory source? other?) and grab it to the memory of your process. Try reducing the number of calls - it will improve your performance. Take a look at this fragment: 

by using this you have only a reference of interface will be there in viewmodel . but not the whole view itself 

This is overall comments on above code 1) Encapsulate what is repeating In your method you are opening sql connection, adding parameter and executing it one by one. Rather doing this please extract out it into one method. 

toggleRows should not take a checkbox id but a show variable to show/hide the row by doing so you can call this method from any where. 

Rest code looks okay. just wondering why you just not cache the data for a predefined interval rather that doing this.I am not sure which kind of application you are working on. 

I would create two extension method , ToApplicationData and ToAddress and will define mapping over there. it will sorten you code and much better readablity. you can break this methods too if you want.