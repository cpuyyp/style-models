Storing maps as tiles is useful for allowing you to re-use assets and re-designing the map. Realistically though it doesn't really offer much benefit to the player. Plus, you're then re-drawing every single tile each time. Here's what I would do: Store the whole map as one big array. There's no point having maps and submaps, as well as potentially sub-sub-maps (if you're entering buildings, for instance). You're loading it all anyway and this keeps everything nice and simple. Render the map all at once. Have an off-screen canvas that you render the map to and then use this in your game. This page shows you how to do it with a simple javascript function: 

What do you get if you try and swap the order you draw them in? Transparent pixels still create depth buffer entries. If you're drawing the back one after the first it's not processing the pixels behind the front image, making it look like there's no alpha. For reference, take a look at the Painter's alogrithm. 

This will give you a unit vector in the direction of from your left example, going counter-clockwise. If this sounds complicated, think of it as a clock hand that starts at 3 and goes counter-clockwise as the angle increases, and reaches back to 3 at 2*PI radians, or 360 degrees. To get extra-fancy, multiply these by a 'speed' value to get a velocity vector: 

which, when you put these into ctx.setTransform (along with the translation X and Y in the last two parameters) yields the correct result: jsfiddle.net/3ugzy/1/ But only works if the tile is centred at the origin. This is because if not, the offset from the origin also gets factored in to the transform and it goes slightly wonky. Hope that massive example helps! Sorry about the lack of hyperlinks, but I've kept the important ones in and de-linked the others to keep the spam police happy. 

This example probably still needs some tweaking to make it just like you want, but it should get you started. 

Your pathfinding should return a list of way points to reach your objective for each unit. Since you are making a turn based game, I am assuming that the unit movement is like a chess piece. It is either on "this" tile or "that tile, and not in between. If this is the case you might end up with the scenario where a units movements runs out in the middle of the next tile. For example, if you have a unit with a movement of 5 and it needs to travel across 3 tiles each with a movement cost of 2. Clearly the unit has traveled across the first 2 tiles, but what about the third tile? Is the unit stopped on the third tile with 1 point left to go, or since the unit doesn't have enough movement left to traverse the third tile, it is stopped on the second tile and the remaining movement point goes unused. Now what happens if the units movement is 4 and it has to travel across the same 3 tiles. Where does it sit at the end of its turn? Is it on the second tile, or the third? These are game design decisions. Does a unit have to move the full cost to be considered on that tile? Or is the unit considered on a tile if it has spent any movement points in that tile. Also, are all movement points spent each turn, or if the unit can not spend the full cost of movement on the next tile, then the remaining movement points are dumped and the turn ends? If you are allowing a unit to spend all movement points, you can have a variable like which holds the movement units spent on a tile at the end of a turn. So, back to your question, your pathfinding should give you a list of way points, in your case, one tile, after another, leading to the objective. At the start, pull the first way point, after traveling through it, pull the next way point from the list. Do this until you have exhausted your movement points for that unit. Then on the next turn resume where you left off. 

thanks for your time! I'm really new to LibGDX (and Java itself). Which approach should I use to render my different game parts? I want to show a background, the main character, a bunch of enemies and an HUD. The playable area will be bigger than the screen so the camera has to move following the main character (top view). Also everything has to be procedurally generated. For example, I have the code to generate the map (background) but I don't know how to render it if it's in another class (not the core entry point one). I can think of calling a custom background.draw() method from my main.render() class and pass a batch to draw onto but probably there are better ways. I've tried to use Stages (scene2D) aswell but I can't get my camera to move (are they mostly made for UI?). I'd like to be pointed towards the best solution performance-wise since it's gonna be called every frame :P 

I would like to know what is the best way to implement collision avoidance and eventually pathfinding in a LibGDX 2D top view game. Think of "Binding of Isaac". I use a sort of tilemap to place the obstacles (squares), taken from an ASCII map, but I'd prefer to keep the movements free from it. (Enemies shouldn't move from tile to tile but freely) Since the target is mobile I can't use heavy algorithms. I'm not particularly concearned about enemies getting stuck on weird shapes (such as 'U') since it kind of makes sense (they are white globules, not particularly smart :P) but I still want them to be a challenge. I've taken into consideration Steering Behaviors and the LibGDX-AI framework but I can't find good documentation, I can aswell code it by myself in case. ANOTHER QUESTION Just to know, which kind of algorithm is used in the Binding of Isaac? It perfectly suits my needs 

To make the tile set look good, a basic rule needs to be followed. That is each tile must tile seamlessly with all the tiles it can connect to. Some examples: tiles E, and J must tile with themselves in all directions. Also, the top of tile E must be seamless to the bottom of tiles B, M, and N, while the top of J must be seamless to the bottom of G, H, and I. Tile A's top edge should be seamless to the bottom of J, G H, and I. Tile A's Right edge should be seamless to the left edge of B and C. Tile A's bottom edge should be seamless to the top of D, and G. And finally, tile A's left edge should be seamless to C, F, I, and J. Tile B's left edge should tile with the right edge of A, B, and M. Tile B's right edge should be seamless to the left edge of B, C, and N. Etc, etc, etc. As you can see this is a long tedious list to write out, but at this point I think you can figure the rest out. Creating multiple sets like this you can make some intricate maps. You can have a dirt/grass, and a grass/water tile sets. If you use the same grass tile in both set, you can go from dirt to grass to water seamlessly. This same approach can be used to construct building exteriors, fences, caverns, and mazes. 

You can change the price at any time, or make it free if you like. Also, you have the option of uploading your app under a different name. This is done often as demo/pro versions, where one is free and the other is paid. 

The vector between A and B is B - A. The magnitude of this vector is the distance between these points. If point A is traveling along this vector then it has reached point B when the magnitude is 0 and it passes B when the vector components change signs (positive to negative, or negative to positive) as compared to the original B - A vector. For example, in 2D A = (3,4) B = (4, 6) B-A = (1, 2)