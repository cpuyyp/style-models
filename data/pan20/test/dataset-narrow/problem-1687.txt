To answer your last question about using instead of to create an image file to be used by Etcher, the answer is yes and no. Let me start at the beginning. I have not used Etcher, I have used the Pi to create its own bootable clone/backup sd card from the running system. From this sd card or stick the , , , , type of commands can be safely used by Etcher to create an image file. The setup takes some effort, but it is easy after the setup. I apologize for the mistakes in my previous answer, I will try to correct them. SETUP - From your addition information I see that you are running Raspbian and Recalbox and I think NOOBS was installed. I have downloaded and installed NOOBS on a used reformatted sd card, unzipped it in place, shutdown/power off, inserted in system sd slot, inserted a new sd card in a USB adaptor, powered up, selected Raspbian and Recalbox, and configured with raspi-config. I copied from my old system card, /etc/hostname, /etc/hosts, /etc/ssh/, and /home/pi/.ssh/ and rebooted. PARTITIONS - The sd (serial disk, sda) card/stick/key/HD has sectors which hold data. Partitions (primary, extended and logical; sda1, sda2, sda5) divides the sectors into groups to hold filesystems. The logical subdivides the extended. Some useful commands are , , , , ... for partition information. 

I think that I have just learned an answer to your question, "Additionally, are there any other facilities for doing what I'm trying to do". On the Pi or Linux type of system, download the image (zip) file. Unzip it, if Raspbian there will be a file. Run . The output should be like: 

Yes, just as a point of reference, I have a SIIG serial adapter (based on FTDI's FT232BM chip) that works fine. Check out: 

Generally, yes. In Android, the question about whether or not an LCD will work, and what you'll have to do to set it up, is really a Linux question. Do you have drivers for the LCD? If you have drivers, and can build them into your kernel, and configure them correctly, they will in general expose an interface to /dev/fb. Android will automatically find that interface and use it as your display. 

An approach that potentially requires less wiring is a keypad matrix. It essentially looks like this: $URL$ You then would "scan" the rows by only enabling one row at a time, and reading the column to see which keys in that row are pressed. You'll only need enough GPIOs to make ROWS * COLS > 84. In this case, 9 and 10 would work, which means 19 GPIOs (the Pi has 26 available on the header). 

If you are looking for something extremely simple, consider using netcat (this is similar to the ssh approach, but likely a little faster). netcat is including in Raspbian by default. On the "server" RasPi (the one that will be setting a GPIO, assuming GPIO4): 

In general, no - GPIOs don't have a variable voltage output. If they did, we'd call them a DAC. As suggested by xPino, you might be able to use a PWM pin - but I suspect that the backlight pin on the LCD is going to have higher current requirements than can be provided by a GPIO (or PWM) pin on the Broadcom. You'll have to look at the LCD datasheet to find out. 

After testing, my solution would be to have two loops inside of a forever loop. the first inside loop would be to do a ping on a range of ip addresses, multiple times, that would be possible for my phone. My router has reserved the first 19 ip address and I may have about a half dozen address that DHCP will assign, including my phone, starting at address 192.168.0.20. I will ping a dozen ip address once, in background mode, wait one second for response, and throw the results away as junk. I will wait eight seconds on the arp table, and run the command, grep the mac address for the ip address. The router and phone will keep this same ip address unless something unusual happens. The arp table will remain in the Pi, but will change states from , , and from pings and time. The second inside loop will ping and check the arp table every five minutes to determine if the phone is at home. With three ping 'FAILED' in a row, the phone is not at home. One 'REACHABLE', when phone is not at home, will make the phone return home (do something). There are checks to validate the ip address and return to the first inside loop if corrections are required. 

CLONE/COPY DATA INTO FILESYSTEMS - Raspbian will mount extra filesystems on with owner and will create errors with the command. By making new mount points and mounting the filesystems there, errors will not be created. The command will not cross filesystems, so , , , etc (system generated filesystems) and mounted filesystems (, etc) will not be cloned/copied. It is best to not have other jobs running on the system during this section. 

You can use PHP to do this. Program it in such a way that you can send GET requests to the webpage (i.e. ), then it forwards your character to the Arduino. Of course, I assume you have already worked out the Raspberry Pi to Arduino communication step already, since your question merely asks 'how can I send characters to my web server?' 

In this case, is your temperature in Celsius multiplied by 1000, i.e. . Sometimes, the top line will read instead of , in that case just wait a little while (10 seconds or so) and run again. I use a Python program to poll this file every 5 minutes which serves as a home temperature monitoring system. I believe the OS reads the device every 10 seconds or so. 

To elaborate a little bit and provide a possible solution to the issue - you could use a transistor with the collector attached to the 3v3 outlet of the Pi, the emitter attached to your sensing GPIO and the base attached to your sensor. That way, the sensor will trigger the transistor 'on' with 0.042V, allowing current to flow from the 3v3 to the GPIO and producing the desired result 

It's unclear from your picture whether you are using the 5v0 or the 3v3 pin for the power rail of your breadboard. If you are using the 3v3 then it is highly unlikely that you have fried your pin. To move forward with our debugging, let's assume you haven't fried your pin. It looks like you have wired the temperature sensor up correctly with the resistor across the +ve input and data pin. I am unfamiliar with the breakout board that you are using but I have a hunch you hooked the data pin to the wrong port - there is only one pin on the Pi which can read a DS18B20 and that is the GCLK pin (GPIO 4 / physical pin 7). Once you have it wired up correctly you can debug from a terminal window. First run these from the Linux shell: 

I have had good results with the WD PiDrive Cable $URL$ It will not connect to all hard drives as it has a funny connector. It is a Y type cable that your power supply cable plugs into it and it powers the Hard Drive and the PI in parallel with the USB cable also. 

Understand how NOOBS works is the key to using the hard disk. is a FAT (FAT16) partition for NOOBS to boot first. In my case is the Raspbian boot partition, also FAT (FAT32), that is booted second to load the root partition on the hard disk. The is the installed root for Raspbian that I copied to the hard disk and changed the file where , which is the partition on the hard disk. All of the different OS boot partitions are of type FAT. NOOBS makes all the root partitions of type Linux (ext4), check with command. You could format the hard disk in many different ways to fit your needs. To share data with the different OS, make a data partition on the hard disk, make filesystem () - if /dev/sda1 is the data partition just created, and mount it in each OS /etc/fstab. You may wish to see How can I backup my whole SD to an img file usable with Etcher to restore later? for more ideas. 

I am using Raspbian and command allows from a ssh terminal keyboard session to run a command like and display a picture in the monitor connected via HDMI port on the Raspberry Pi. 

Its reasonably likely that you blew the fuse. The Raspberry Pi has a polyfuse, which will "blow" if you draw too much power from the Pi. A quirk of polyfuses is that they can take a long time to reset. Set your Pi aside, and try using it again in a few hours, or tomorrow even. Google "Raspberry Pi polyfuse" for more info. 

Generally, most likely causes for not booting are issue with SD card or issue with power supply. If you have an extra SD card, try imaging it with Raspbian. If it boots, you'll know the issue is with you current SD card. 

If you are using matplotlib, then you are using Python, correct? If so, then for FFTs, you'll likely want to look at scipy or numpy. For generating WAV files, Python includes a library called wave that can generate wave files from raw samples. 

Use it to convert images as needed directly to the framebuffer. Depends on your framebuffer (which you can details on in /sys/class/graphics). Lets say the framebuffer was 640x480, and color depth 8:8:8. Then you could use a single command line something like (untested): 

Another datapoint, if its useful. I regularly shutdown via ssh, but I run ssh from the command line (not via Putty). The following shuts down my Pi and powers off (HDMI out becomes disabled, but always on Power LED stays on). Note: this is on Raspbian, and I ran uname to show you my version. The commands below were run remotely from my Macbook. 

I use my Pi as a NAS and it works great. I have a 2TB powered external HDD where I store my HD movies. I installed Samba for filesharing. Streaming over LAN is incredibly quick, does not stutter at all. Over WiFi though you would definitely run into problems. My setup cost me £35 for the Pi and another £70 for the 2TB disk bringing the total to £105, cheaper than any other NAS solution I could find at the time. I have been using this system for about 6 months and it hasn't given me any problems so far (aside from the occasional SD card corruption that tends to happen with Raspberry Pis) 

You need to configure port forwarding on your internet router. I believe the default TightVNC one is 5901, though your config may be different. If you are unsure on what port forwarding is, see this $URL$ Then you can use your external IP $URL$ and the port to connect to your VNC server. 

The Pi uses 5W just for itself (5V and 1A). Therefore you need more amps to power a keyboard as well. Use and this hopefully will solve your problem. 

To clarify chuda's answer: You can get a 5V relay board to control bigger currents using the Pi. The Pi does not have enough to power that many LEDs, but you can use a mains adapter. If you splice the wires and connect them to a relay board, you can control mains using the Pi without damaging it. See this YouTube video, he gives a good explanation $URL$