First, you can use to extract key-value pairs from the original string. This can be done by passing as a delimiter to : 

This function is immune to memory leaks since it doesn't perform any explicit allocations and is guaranteed to give you the desired "50/50 chance" ( won't do the trick). The only catch is the dreaded specialization, but in this example, it's not going to do any harm. 

Notice that you don't have to perform any checks on the stream this way. Once will reach the end of the stream it will set the on it, so the loop condition will evaluate to on next iteration. Next, use can use to find an index of the occurrence of the character in strings filled by : 

But that's not everything. The 's arguments are either copied or moved, they are never passed by reference. Thus, despite , you might end up copying your arguments. To void this issue, consider using perfect forwarding (as well as ditching ): 

This code will corretly handle bidirectional iterators as well since inherits from . And code duplication can be avoided by incaplusating common logic in separate functions. Viola! Now you have only one pass. 

Turns out this point is invalid. Your is called twice in case of regular allocation. First time, by destructor of your string: . Second time, explicitly: As you can guess, this leaves you with undefined behavior. Older (and more common) versions of gcc and clang (4.9 and 3.6, for example) will not compile your code, since older versions of and don't use . You have to explicitly define implementations of optional allocator requirements if you want portability. 

and call it with the tolerance squared and you'll get the same result in almost half the time. Note that your special function is not used anymore and can now be removed. Also note that I changed the order in which the list is populated in the last three lines. This adds the indices in order and allows you to remove the sorting step in line 83 which should also save you some time. 

Note that the algorithm only ever compares distances never using their actual value. This means that you can speed up your algorithm significantly by directly comparing the squares of the distances instead. This works because the function is monotonic and thus if and only if . This allows to change your function to this: 

is a managed resource so you don't need any of that or hogwash. Simply call once you are done using it and call it a day (after all that's what the statement does too). Only implement the interface if you really need to move the disposing responsibility to the user of the class (you probably don't) and if you do your method should simply be 

is of type . That means that you enumerate the whole enumerable every time you call and inside the loop! You could cast the enumerable to something like an array or a list and use or instead of (as Frank suggested). But since you are only using the loop variable to access elements of the enumerable in order you could as well just use foreach: 

Notice that you can omit the second argument of , since it has the default value of . This value is very huge (in fact, it equals to the maximum value that can be represented by a size type of ), but never reads past the end of line, so everything will be good. Tie all this together and you'll get a small and readable solution: 

Starting from C++11 the most canonical way to generate any kind of pseudo-random sequence in through the standard library pseudo-random generation facilities. Like this: 

In your example, you have two passes over the list - works in linear time unless it operates on random access iterators. A naive way to fix this is to calculate the number of elements inside your loop and check it afterwards. But this way you'll pessimize performance for random access iterators. To avoid this pessimization you can examine the of you at compile time and decide whether you're going to call or count your elements in a loop. The simplest way to do this is in C++14 is by tag dispatching. Here is an example: 

Another thing worth considering is the exception safety of . Since you're invoking it in a destructor, you're risking facing if it throws. A small block will fix it. Also, as of now, seems redundant. And yes, even with all these fixes, the semantics of seems rather unpleasant compared to more traditional scope guards. At least to me. Edit: full code - $URL$ 

(You don't even need to check the reference for first since you initialize it from the constructor so it should never be null and if it is you have a bug that needs to be fixed rather than swallowed.) All that disposing boilerplate code is only needed if your class holds a reference to an unmanaged resource and in that case managing(!) that unmanaged resource should be the sole responsibility of the class. Never should your class reference multiple unmanaged resources and never ever should it reference both managed and unmanaged resources. 

This should already give you a significant speed up. The next thing to try is caching everything that won't change between calls to . For example, if the number of bodies doesn't change store the result of in a field and reuse it 

If the masses of the bodies are constant you can cache the product of their masses and the gravitational constant in the constructor too. 

The first thing striking my eye is that you are taking the square of a vectors magnitude/length. Most frameworks offer a property to get the squared length directly (sqrMagnitude in the case of unity). The reason that this property exists is that calculating the length of a vector involves taking a square root and if you need that squared you can skip both taking the square root and the squaring. 

inside the loop. is of type so calling on that would fall back to (as Anthony Pegram already mentioned in the comments). However, the query turns that into an so will indeed iterate the whole enumerable in every iteration of the loop! Instead keep track of the remaining allowances by decrementing the dictionary (or a copy if you need to keep it). Something like this (untested): 

Have I sacrificed too much readability in the function? Are s meant to be (ab)used like that? What should I be returning in the case (if both directories exist)? Is the use of global in and ok? How can I handle the different ways a user might use the script in the best possible way? Not quite happy about the statements in the . 

For this task, I wrote some Python which I am calling from the . The Python script is humbly called and I have also set an environment variable for it called . 

My final comment has to do with the use of instead of . Is there a reason you do it like that? Instead of having the while statements which you have to evaluate in every loop you can just fetch all results and process them in a less "expensive" for loop like that: 

If you are only interested in getting the 18th url from the initial one and then the 18th again there is no reason to go through all of them and count iterations and so on. You can simply access it directly using the indexes. On this computer i do not have BeautifulSoup installed but try this: 

In the case of "get_xyz_from_csv_file" it seems you are getting the same thing twice with the list and dict representation. You can just build one of the two and jump to the other when you need to with a list comprehension statement but i will leave that for now.