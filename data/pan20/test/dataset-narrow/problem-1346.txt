What you want to do is determine how much the two AABBs overlap and then move them apart based on that amount. You already have an method. If you tweak that to return the amount that the AABBs overlap (on each axis) then you can just move your player back by that amount. That assumes that what you're colliding with doesn't need to be pushed back either. If that IS the case then you'll have to move both AABBs back by some ratio of the overlapping value. You can probably just get away with moving both AABBs back by half of the overlapping value but a more generic solution would be to move them back based on their speed so a faster object moves back more than a slower object. 

My assumption based on my experiences with shader reflection in DX11 is that it's mapped by name. If you check out the DX11 shader reflection API you'll see that there is a struct that you can rip from the shader. Notice the LPCSTR for the name of the variable. OpenGL also handles variable mapping by name. Of course the best way to find out is to try it yourself! Try repositioning your constructors and see if it affects your cbuffer buffering. $URL$ 

In case we started with an interior tile, it should yield a distinctly smaller bounding box, because the loop tiles have to be sandwiched in between both bounding boxes. 

The initial starting tile for the flood fill could be any tile within the which is a free tile. Maybe picking one randomly is the best approach. If I would know before that the interior is smaller than the exterior, I would start around the center of mass of the loop points which is in the interior for many areas (counter example: C shaped area), otherwise on the border of the . But I have no idea how to estimate this. Final remarks Normaly I would say a simple walk starting from some tile and keeping a list of visited tiles would be sufficient to detect a cycle, but that screen boundary condition might yield a more complicated graph, so you should be on the safe side with a graph algorithm. Below is an example where the interior is not connected, on the other hand the cycle detection should find two loops in that case, one should get discarded. 

3.5mm support would probably be easier if you want something to work out of the box by default. Android is a very mature platform at this point and it has plenty of other applications besides just a Phone operating system. The OS has a fairly well documented USB api: $URL$ which can probably be used to get the USB functionality you want. However this may not work out of the box, I honestly couldn't tell you which devices do and do not work out of the box. If you want to end up interpreting frequencies from a device over USB you may end up having to write some sort of driver or wrapper. Note that you may want or need to use a USB OTG cable or adapter to go from micro USB to full USB. 

The call is a bit more complicated but it seems the orthographic view is setup properly, the look at view is also correct. I have verified that the matrices that are generated by my math functions work. 

2. Handling the screen border case The screen border consists of those imaginary tiles which would form a one tile wide rim around the screen of visible tiles. According to your specification part of the screen border would form an implicit part of a closed loop. Just to detect a closed loop, it would be sufficient to extend the graph to a graph by honoring the connection via this rule: 

Thus tiles at (0,0) and (1,0) would be part of a closed loop, together with the "border tiles" (-1,0), (-1,-1), (0, -1), (1, -1). 3. The inner part of a looped area I would go into a similiar direction to what user Arthur Wulf White suggested: Limiting the set of tiles we have to examine by the bounding box of the loop tiles. Then using a flood fill to select all tiles within the bounding box which are either exterior or interior to the closed loop. It can only be one of those two cases. Which one we have to find out afterwards. Extending the bounding box by one tile in each direction would be a good idea as well, yielding the , so we just end up with one connected set of exterior points, in case we started the flood fill with an exterior tile. Once we have the flood fill area, we would calculate its bounding box as well, the . In case we started with an exterior tile, it should be identical to the extended loop bounding box. 

How you CAN test this is a bit roundabout. You'll need to compile your C++ based game for Android with the Android NDK (native development kit). From there you should be able to run the app on an Android Emulator on your computer or a push the app to a device for testing. 

It's best to model a component system off of something like Unity or Unreal which is proven to work unless you have a reason for doing something experimental. 

If you want to aim for a real class, I would recommend C++ if that's how you want to organize your project. However C is still totally appropriate for OpenGL. If I'm not mistaken a totally appropriate C way of doing something class-like would be: 

The solution that works best for you might be some combination of the solutions I've proposed, or even none of them! With problems like this there isn't always a #1 top solution so pick one that fits your project the best. 

First bit is to get a model of the pyramid's bottom rectangle R. Define u = b - a = (b1 - a1, b2 - a2, b3 - a3) v = c - a = (c1 - a1, c2 - a2, c3 - a3) If the bottom is really flat then the equation d = u + v should hold (otherwise vector d is ignored). The rectangle R is defined by R = { y | y = a + α u + β v ∧ 0 ≤ α ≤ 1 ∧ 0 ≤ β ≤ 1 } To test for the whole pyramid, one can scale R along a, meaning moving the rectangle along the vector a, giving a scaled rectangle R'. u' = f (b - a) v' = f (c - a) x' = x - f a with 0 ≤ f ≤ 1. This leads to the equation (x - f a) = f α u + f β v -a = α u + β v + t (-x) y = A^-1 b with A = (u; v; -x), b = -a and y = (α, β, 1/f).