This is one of the standard examples for algorithmic complexity. This algorithm is very easy to understand since it matches the mathematical definition well, but performs miserably since it's trying to calculate a number that grows exponentially by adding 0s and 1s together. The key observation is that to calculate, say, , it has to recursively calculate and . Then to calculate , it has to calculate again, which is completely wasteful. There are several things we can do to go faster: 

Some of the emptiness is coming from the two interfaces that I think are unnecessary. Rather than having and as interfaces, simply have specify and have specify : 

White Space to make it easier to read: Add white space between operators so they stick out (and we don't have to squint to read your code) 

Putting it all in one function does not reduce readability. But the huge template type names do bother me slightly. Template names are usually short (because they are not real type). 

Both sides of the are exactly the same. Remove all the ones that have only happened once by removing the whole else block! Ohh. I see it now. The extra on the end of . Yea. If this were a million dollar project maybe I would go to the extra effort of pluralization. But I would do it simpler. 

I have a PR implementing multithreaded naive Monte-Carlo integration here. My requirements for the class are the following: 

Unfortunately, the imposition of these requirements has left me dissatisfied with the design and look of the code: 

It should support progress reporting, ETA, and graceful cancellation. It should handle finite and infinite intervals. It should allow restarts, and changing of error goal in flight. 

Yuck. Generally, it is bad form to take STL containers as arguments, as the bounds require. Any suggestions for replacement? Perhaps the template parameter is redundant, and can be replaced by the return type of the function? 

As you can see some of the spots in the center bottom of the triangle are being hit many many times by recursion when you only want to hit each location once. Thus an iterative solution is probably better. You are using a 2D array to represent the triangle which requires two de-references (which can be inefficient (but without measuring I am not convinced this is a major issue)). Rather than do that use a 1-D array given the number of rows n you can quickly compute the number of elements in the triangle as and thus re-size the array in one statement. Element access for a child of m is and (note the calculation of row(m) does not need to be done each time you can keep track of this as you increment m). 

Your program should just create a , create a with that, and stick it in a and show it. Then play around with layouts to get something you like. 

If you wanted a interface, it would indeed be empty, at least right now. That's okay though. Maybe you're planning on adding more 2D-specific methods later and know you'll need that layer in the hierarchy. Maybe you just want to tag things as being 2D--that's called a marker interface and the built-in library uses a few, such as RandomAccess and Serializable. 

I assume and are Apache Commons? If so, it would be helpful for us for you to link to their online documentation/source. The first thing to do when optimizing is to make sure you're optimizing the right thing. You might find ways to shave off a bit of running time in this method, but if this method is only responsible for 1% of the total running time then that's not very good use of your effort. The thing that strikes me is all of the safety for weird conditions. I can pretty much guarantee you that your calls are the slowest things. Maybe upstream code should be ensuring that the is of the correct form to begin with, the strings are trimmed, and there are no double spaces. 

Prefer not to use instead of . It has no major benefits and can slow code down dramatically. If you want to guarantee a flush print the whole structure first then use instad of the last '\n'. 

It makes no difference for integer types. But when using other types (iterators) the default implementation for increment usually makes the prefix version more efficient. So when it makes no difference to your code prefer the prefix version. This allows the types of your objects to be changed without having to update the code and it will still be the most efficient version. Prefer to If you know that your access to an array will always be in bounds then prefer as it performs no accesses checks and is thus quicker. Note: throwing an exception that is not caught inside a thread will cause the application to terminate. Throwing an exception inside an async will catch the exception and transfer it to the future object allowing the main thread to detect it. Don't know why you are using r-value reference here 

I feel the classification of the limits as finite, half-infinite, and infinite is an unnatural hack. Is this necessary? Each thread needs to accumulate a variance, and average, and a number of calls. These must be atomic so they can be reduced by the master thread without a race condition. However, a vector of atomics cannot be resized, so I used a map, which, though not a catastrophe, seems suboptimal. Is there a workaround? I'm using (say) , which seems to have widespread compiler support, but won't have official status until C++20. A workaround is to use a mutex, but a mutex is a disaster for performance. What should be done? I'm taking the function by , but should it be forwarded ? Or should it provide two constructors? I tried many random number generators, and the Mersenne twister seems to be the only one that doesn't contract 'weird seed' and reliably 'does the right thing'. However, it returns a 64-bit integer, which must be remapped into the open interval ]0, 1[ (or else it'll hit singularities on the boundary). Using was too slow, so I use , which is always <1 and >0 in double precision. In float precision, it gets rounded to 1 or 0 quite frequently, so I've added the following hack: 

The pthreads library is a C-Library and thus only understands the C ABI. It has no concept of the C++ ABI and thus can not call C++ functions and definitely can not call class methods. This just happens to work on some systems as you are getting lucky that that the ABI for static member methods is the same as the C-ABI. Best to just make a C-function so that you are guaranteed for it to work. This C function can call your static member in a valid fashion. 

Neither of those are safe assumptions. Also those are the wrong types. If you don't know the type you can use 

Looking Forward Right now, it's difficult to reuse because it spews output to the console. I get that you want to see what it's doing, but once it's working you should take that out. The sort function should only be responsible for sorting; the user of the function (in this case, the method) can decide what to do with the results (e.g., print them). If you want to be able to debug it in the future, then put it behind a debugging flag: 

It should be possible to make more efficient, but as it's written I think it's pretty clear and I had no problem deciphering it, which is good. A more optimized version would likely be much harder to understand, so I would say only worry about it if it becomes a problem. is suspicious but I think I see why you did that. My main comment is that by making everything static, you can only ever have one shortener, and using it is kind of weird. You have to initialize it by changing static fields and calling static methods in a specific order. It would be better to make a proper class, so you could create multiple shorteners with different mapping files, and also clean up the interface. As a user of this utility, I would want to write: 

I'm trying to lighten the code review load for the maintainers of boost.math, and I was hoping you guys could help me out. I have a pull request which implements tanh-sinh quadrature, which is provably optimal for integrands in Hardy spaces. Here's my code: 

For those of you interested in performance, I have used google benchmark to measure the runtime, which is reproduced below: 

It is a class and not a function. This is a bit confusing; I worry that people will not recognize that the constructor is doing some one-time calculations to make integrations faster. It takes a long time to compile. I generated the abscissas and weights to 100 digits, and then they must be lexically cast to their correct type. I could keep fewer levels of abscissas and weights in the .hpp, but then the runtime would longer for complex integrands. For integrands in Hardy spaces, the number of correct digits always doubles on each refinement. However, we want to do just the right amount of work to deliver the requested accuracy, which is almost always overshot. 

Why not make the first parameter a stream. That way if it is already in a file you pass a file stream. If it is already a string you pass a stringstream. You are not checking for errors. So we can assume that each line has been validated and is known to be correctly formed. So rather than reading a line at a time. Just parse the values you want. 

When you see this pattern. You should be thinking of using RAII. This will make sure your resources are cleaned up correctly in all situations (including when exceptions are thrown) are the function returns early (aka ).