You are right on with a one to many relationship from Person to Account, not a one to one relationship. You are also correct you want deletes of a person to cascade to ensure that when a person is deleted the associated accounts are deleted with it. In your drawing you have, under the Account table: 

The Account would not be null. Instead, there just wouldn't be a row in Account for that Person as they hold no accounts. Now if you write an outer join of Person to Account then yes, for those persons with no accounts the columns from the account, which is the null supplying side, will be null. 

Yes. AB in AB --> C really means A and B functionally determine C. And, which is the truth functional operator of conjunction, is associative. Section 4 of the linked article presents the algebraic properties of conjunction. Therefore A and B is equivalent to B and A. 

This is a great question! You have a great start on the ERD because you took notes on how the world of the Tutoring Center works. You are right in that all of these entities are related. The difficult part is in developing a sound model of what those relationships are. Before you get into relationships though, you first want to uncover if any of the entities are really the same thing. In this case, employee, teacher, director, and section manager are really the same thing - a person working for the tutoring center. So I would say you really have a single entity there - Employee. Now that employee may be a contract worker or be a full time employee. The other words - teacher, director - identify roles those employees play. In one of the sentences from your notes you identify the employee, but the role is really say analyst. The employee analyzes the section's data. The best way to handle these employee roles is to realize that each employee is really holding a position in the tutoring center. Each position would be of a given position type, and in this case those types are Teacher, Director, Analyst, and Manager. Now that you've identified the entity types, you begin to look for the relationships. For example, your question "where students didn't actually contact the teacher but they will be taught by the teacher so do you establish a many to one relationship between these two entities?" Absolutely there is a relationship because the student is related to the teacher through the class. But there a subtle distinction here that will cause you to introduce more entity types to properly model what is going on. A thing type is distinct from a thing. We know we have a student and we know we have a class. But really, there is the kind of class - say "Into to Math" - and the offering of that class on a given date and time. This is a very common modeling pattern you will find everywhere. In fact you have already seen it with the position type - a kind of job an employee can do, and the position - where an employee is performing that position type at a moment in time. There are two ways to handle this from a naming standpoint. The first is to use the words class type and class. The second is to come up with words whose natural meaning is associated with a type or an instance. In this case I like the word course to represent the kind of class being offered, and the word offering to represent the scheduling of a teaching team to actually deliver that course to students. So while it isn't in the notes directly, I would say that since each section is broken down by academic area, each section likely offers one or more courses, and each offering may be taught by many teachers, and many teachers may teach one offering. This now leads into your second question: "I ended up with many to many relationships and I don't know what kind of associate entity I should add between them." If your ERD is a pure conceptual model with no attributes being shown, then you don't need to add an associative entity. You can use the Many to Many relationship to represent this. Only when you add the attributes do you need to resolve M to M relationships with associative entities so they may hold the attributes. But, if the relationship itself will then be associated to new entities, you have to introduce the associative entity. That is the case with offering, as we realize that a student must register for an offering that is being taught cooperatively by many teachers. Registration becomes an associative entity to show a student registers for one or more offerings, and an offering can be registered by one or more students. It isn't the case though with the cooperative teaching, as we can simply show a M to M between offering and teacher as there are no further associations. Then, when you add attributes (even if there are none there are still the foreign keys), you would add an associative entity perhaps called instruction team member. We say member as in ER modeling each entity type is always named for a single occurrence - exactly as you have done. I bring this up only because its very easy to think you are naming an occurrence but have really named the set - in this case to call the associative entity instruction team. To finish up, you note that a class may offer a test at the end. I would say the relationship you have is actually 1 to M from class to test, as I would suspect each course has its own test type that it uses that is only for that course and no other. Now if we needed to show that students in the class actually take the test and make a grade on it, then we again have test type and test, where test is a particular student taking the test on a given date and making a given grade. Along these lines, you note that a student submits an evaluation. This is modeled by showing that for a registration, which is a student taking a given offering, an evaluation is performed. Here is an example ERD I prepared to answer this using the Oracle Data Modeler which is a great free tool you can download that uses what I consider to be the best notation for conceptual models - Barker-Ellis notation. 

Distinct un-ordered rows Uniquely named un-ordered columns Single Value Columns (SVCs) No missing column values 

In this example, we identify a party which can either be a person or an organization. This is based on a single, fundamental, unchanging characteristic - if the entity is a single individual or a group of individuals. A person can make a donation. An organization can make a donation. A person can vote. An organization can never vote. These things never change. With respect to voting, it may seem to make sense to sub-type the Person based on if they are a voter or non voter. But being a voter or a non voter has nothing whatever to do with who the person is. Instead, it has everything to do with the district in which they live. Therefore, we model a district entity type which may be the home of one or more persons. Likewise, a person must be residing in one and only one district. This approach solves the need to know who have made donations and the need to know who is and who is not a voter via naturally occurring information - where the person resides - instead of information we invented by declaring them a voter or a non voter - or both. With respect to a person being both a voter or non-voter, that is mis-leading. They could be both over time, but could never be both at a moment in time. Therefore you must decide if you care about the history of their residence or not. If you do, then you would instead create an entity type - say residence - to associate the person to the district in which they reside for the period of time they resided there. I suspect you don't care however, and thus you would simply update the person's information to show their new district. Either way, the approach is more intuitive than using sub-typing. This is why I prefer the barker-ellis approach of limiting super and sub-typing to only fundamental classifications. Handling Missing Information One thing does remain however where specialization makes sense. You say you have additional information to store about a person if they live in your district and can thus vote for or against you. In the approach I have given that information would be characteristics of a person regardless of where they live. You are just choosing not to collect it if they don't live in your district, and to collect it if they do. Therefore, for persons not living in your district, this information will be missing. There are two approaches to this. First, you could simply include those attributes for the person and leave them missing. In mySQL you would make the columns NULLABLE. That approach is simple, but if you ever want to write a query where you use one of those attributes as a predicate you now have to deal with the complexities of three value logic (3VL), and the fact that SQL does not implement its 3VL consistently. If instead you want to avoid 3VL, you can use specialization to create an additional entity type to hold the extra information only when it is known. A row is placed there only for those persons for whom you've collected the data. Now this doesn't avoid NULLs altogether as you must deal with outer joins, but you can avoid nulls if you chose to via coalesce. Naming the Specialization I would not call the new specialization entity type voter. It is pure coincidence that at this moment you aren't collecting the additional information because you only need that information for persons living in your district who can vote for you. What if in the future you do want to collect that information for other reasons? What if you happen to know that information anyway for someone who doesn't live in your district and don't want to just toss it away? What will you do if someone for whom you have collected the information moves out of your district? Do you want to delete that good information you collected? If you do, what if they move back? You will have to collect it again! Instead, I would call the table something slightly different like voter profile. This denotes the information pertains to the person as a voter, and that information absolutely describes additional things about them regardless of whether or not they live in your district. Conclusion I hope this approach gives you some additional food for though. To learn more about the barker-ellis approach to business modeling you can check out David Hay's Enterprise Model Patterns, and also Richard Barker's CASE*Method Entity Relationship Modelling. With respect to missing information, I would recommend you check out Fabian Pascal's paper "The Final Null in the Coffin," part of his excellent Practical Database Foundation Series, and also Date and Darwen's The Third Manifesto site where they have some great resources on various approaches to handling missing information without nulls.