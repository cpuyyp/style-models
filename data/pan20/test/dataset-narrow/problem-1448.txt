You might want to "just calculate" the answer but I'm sure that you'll find it insufficient once you've got it because of the highly interactive nature of your "free fall" physics. Consider using a different approach: Searching. Here is how it's done for Super Mario AI: $URL$ Searching possible pathes to get from A to B allows for unlimited interactivity in mid-air while still being computationally efficient. 

Look out for Nintendo DS titles. They tend to use the stylus for game mechanics similar to yours. There are rhythm games like Elite Beat Agents employing something similar to your attack/defend game mechanics but based on music. Elite Beat Agents is actually quite challenging but fun to play. I'd also recommend playing The World Ends with You! It's an action RPG with very similar combat mechanics. It's also quite innovative and unique. Regarding crippling the player (controls) I'd always advise not to. I haven't seen a single game where not-being-in-control due to darkness, staggering, impairing effects, etc. was adding fun. Realism != Fun != Immersion. 

It seems you are using non-power of 2 texture dimensions and mipmapping which calls for trouble because the minifying interpolation has incomplete information along the edges. Prefer to manually expand all textures to power of 2 before loading. Use the desired color for those padding pixels. If you have many small textures of arbitrary dimension it might also be a good idea to create a single power of 2 texture atlas. 

Note the and instead of and . The difference is the preserved perpendicularity of z on the plane if is moved away from the origin. I guess you wanted to do that through but that doesn't suffice. Also note that I normalized . This will result in orthonormal XYZ on both planes and and means that scale is preserved. If the triangles and are not similar (i.e. one is stretched) then but . Don't normalize anything if you want to preserve stretching. 

OpenGL mixes camera and model transformations which is highly unintuitive at first (GL_MODELVIEW). Read the tutorials at the end on my answer to better understand things. 

You can check for talent dependencies programatically by querying the complete talent table, and building a linked tree. You can also do that with SQL but it will require either recursive subselects or lots of queries. Better do it in your code. If there are multiple dependencies, like for example depends on AND use two tables to represent the dependency graph: 

You are ignoring the players current position, which is why it only works once because the initial position is (0,0,0). Use instead. 

No and yes. No, only one model is used. Yes, there is a way to ignore certain parts of a model. Actually it is quite simple: You don't animate them. And when you have two animations that don't overlap in "parts affected" it is trivial to combine them (i.e. running them at the same time). Technically the "ignore" part of the animation matrix is the identity matrix and multiplying both animation matrixes produces the desired combined animation. 

But be aware: Getting started on CUDA is easy, getting started on physics simulation is a good bit harder, but combining both is quite a challenge! 

In my opinion it is perfectly fine to model the behavior with a FSM. Oftentimes we create inferior models with cluttered if-statements like suggested in the comments. But the FSM is not the problem. To me it seems like you are experiencing jittering movement because your AI ship is always just at the border between "too far" and "close enough". Think about widening this border by using too different radii. One for getting a bit closer than absolutely necessary (r1=50m) and one for "oh I'm no longer close enough" (r2=80m). Where r1 < r2 and r2 = your original radius. Go to state once you are within r1 and only go back to when you are within r2 no longer. In the meantime fire at the player and dodge bullets. 

this fixed the 1st problem, but it will always make the enemies come out in the same order (1st one is faster, and last one is the last to come) i hope i explained it right thank you and have a great day 

Am making an android game with unity and i want to add an in-game purchase feature, i looked around and all the suggestion lead to non-free plugins (mainly prime31 plugin) but in the current moment i cannot afford to invest in some of these plugins, does anyone of you have a free solution for this "problem" ? thank you 

So am trying to create a make-up game and i need to have a basic drawing solution, and so far i have made a good progress with the help of the DepthMask solution My approach was like this : suppose we want to edit the eyelash color (texture) 1-in the beginning there is an eyelash object at a layer named old 2-after choosing the new color that we will draw with, a new game object is created under the first eyelash, which mean it's invisible for the moment 3-then when we start drawing, we are actually creating little circles above the old eye lash, these circles contain the depthMask shader which effect the old eyeLash and give the impression that we are drawing with the new color So far, everything is going great, my problem is that i cannot use this approach to use a 3rd color, suppose the player want to create an eyelash with mixed color, how can i do that with the previous solution ? or is it impossible to do ? EDIT: I already thought about adding new layers with each new color, and it works, but since unity is limited to 31 layers, this solution can never be a good one. I really hope someone can answer this, and if you know a better way to do it then please don't hesitate to tell me. EDIT2: After a couple of hours, i've reached a pretty cool result, and i think that this can be the good way to reach my goal, this script allow to replace a specific pixel in a material texture with another chosen texture (target texture must be in the same size, and readable) 

For the multi language support, you are looking for something called localization , it's a common process used almost in every software development that have more than a single language, here is a special tutorial for How to: Create a Localized Game on XNA . For the multi resolution issue, as Homer_Simpson said (lol), you cannot use resolutions above 800x480 on windows phone with XNA, and in case you moved to MonoGame, as far as i know, there is no magic trick to make such a thing, you have to build it yourself, game engines like unity3D use something called "Virtual Resolution" (World scale and position in unity), the whole principle is about using your own resolution for the whole development, and then scale all the objects based on the target resolution, i myself always use percentage to scale and set positions, specially for GUI cause even unity3D use current screen resolution when it comes to gui,so my suggestion would be to make the whole game in 1 resolution, then calculate the percentage of each object size and position relative to your resolution, 

Now i think that the problem will only be, "how to know which pixel i should replace based on mouse position over the object ?" Thank you very much and have a great day. 

The problem that am facing is that i don't want the "enemies" to get out from holes at the same time, not even in a different close times, so i want to keep a minimum interval between each enemy and in the same time i want too keep the feeling of randomization, currently am making it like this : 

not a mathematician here but you could divide this problem in 4 distinct sections, like the quarters of a circle. Then, by checking which direction is closer to the edge, move along that path. ex: (2,-1) the (+,-) sing informs us that it`s located in the top right quadrant. then, we know that the edgemost closest hex is 3,-1 but you can deduce by using the max x value at y=0 or the max y value at x=0 and then substract your current position to see where the closest edge lies. then, we can see that there's some very easy rules to follow the edge counter clockwise if taken into quarter cases. for example: Case 1(top right) if you're on the edge (x cannot go higher) move up along the y axis. if y cannot get higher, lower x until you reach (0, max y) which would be the top most coordinate and from there, move into quadrant 4 (-,-). just my 2 cents, as i said, not a mathematician. 

I am working on a 3D sandbox mmo with destructible terrain, using Java and LWJGL. I looked at most options to achieve this and found that dual contouring would probably be the best option for me. I've read about every paper i could find on the internet about how to implement such a thing and, since i have a very basic experience in game/3d/complex programming, I've had quite a hard time. but I think I've found the solution i was looking for and would like to check with some more experienced programmer if my solution seems right and if I really successfully wrapped my mind around some of those pesky terms that were haunting my nights for the last few months; Edit: I will try and add some more precise detail as to what i already do here in bold so, first of all, I've created an object called voxel when I say object, i refer the the user side's way of handling the data received from the server. I already compress the data as to have it fit a byte or a short and use bitwise operations. Voxels are loaded once from the server then stored to memory unless the server returns a change to that voxel (not sending entire chunks for a small change), a voxel knows it's type and it's "integrity" (in this case, how much that stone voxel has been mined for example. I think it refers the the volume i often read about?). Those voxels "will" be created from a pre generated world map for a persistent world. Yes, the world will have overhangs and most of all, tunnels players can mine. then i got a chunk, composed of at most 32x32x32 voxels. A chunk knows it's world position and has a 3D array of voxels passed from the server when first loaded to memory, then the client/server only updates the voxels that have changed since the last update. A chunk also knows it's neighbors (if such neighbors have been loaded into memory, or creates a default chunk of 32x32x32 air voxels) To find the surface, inside a chunk, i check every voxel from the bottom,left,near (I think it is the right order to fit with the way OpenGL read it's coordinates?) to the top,right,far. each time, i take the current voxels and all it's 7 neighbors in a cube shape and check whether their is a type change from solid to air in any of them, indicating a surface running through that cube. If there's a type change, i compare every edges to see if there's a type change and if so, place the entersection of that edge using and average of both corners integrity. doing so for all 12 edges allows me to average all the planes to a single point inside that cube and create a vertex and store it in an array. The point where I'm confused is this: what should i do next? I think I should check along one edge that displays a type change to find the 3 other cubes that has the same edge and find their vertices. Since i know what direction the ground is (comparing the type change along the edge axis) I can deduce the front and back of the quad. taking 3 of those 4 vertices should allow me to get a normal from their dot product and from there, go around that normal CCW and send those vertices to the GPU for the rendering phase. I guess the real question here is: How do I get the right order of vertices to form triangles that OpenGL can draw correctly from that large collection of vertices generated while finding the surface? In theory, in my mind, it makes sense! but I find it so much simpler than all those papers I've found, that i fear I've missed the boat completely! I get lost when it comes to Isosurface (I guess here, the formula they're talking about would be the average of integrity along any type change?) and hermite data (here, should i read voxel collection instead?) and most maths are slightly beyond my understanding yet (working on it tho and I progressed quite a bit) please, can you help me out here and guide me a bit?