I figured out my problem myself, and found it was due to a very simple mistake: I added a red pixel to the top left corner of one texture, and discovered it was the only one being rendered. I got the idea from this thread. It's because I forgot to cast the image width to a float, so when divided by 16, it would yield zero. 

I've been playing around with VBOs as of late (mostly because my game necessitates it), and I've found the need to add new vertices to a VBO, but not necessarily at the end. The game in question is a Terraria port, and when a player updates the world, the VBO needs to be updated. Up until now, I've been using glBufferData() to update the array, but it's time I switch to glBufferSubdata() or glMapBuffer() I'd like to be able to update a certain "chunk" of the world when a block in it is modified, but this could potentially result in adding more or less vertices than are already in the appropriate memory section. If a player places a "block," more memory would need to be allocated, resulting in any proceeding vertices being shifted over x indices. My only thought would be to allocate enough memory for each chunk to be completely filled with blocks, but I haven't yet found a way to do that. Would anyone be able to point me in the right direction? EDIT: To clarify, pushing new VBO data to the graphics card (which is what causes the lag spike) takes 11-12ms the first couple of times, and 1-4 every time after. This also raises the question: why does the graphics card seemingly need to be "broken in?" In other words, why is there such a huge delay at first? 

(Note: values is a list which is later converted to an array.) Then comes my code for rendering the VBO: 

Yes there are benefits in entity complexity, yada yada yada, but the real benefit of an entity component system comes not from the ease of creating new entities, or the ease of changing entire sub-systems; it comes from the ability to leverage cache-effecient algorithms. With components, for example, your physics code only needs to know about the object's position, velocity, and collision volume. It doesn't care about the model being displayed, or that it happens to be tinted green, and it doesn't have to waste space in the cache for the entire entity. Unfortunately, these benefits aren't nearly as great in C#. Short answer : Yes, but don't half-ass it. Make your components data-only, and enforce this rigorously. Define behavior in separate modules that update all like components at once, and separate disparate data into separate components as much as possible. For reference, $URL$ 

It looks like you're drawing your skysphere after your HUD. You should draw the skysphere after drawing the world (the depth buffer will save you a lot of overdraw), and draw the hud last. 

To do this in XNA, you will need to use a shader. You will need to render your scene to a texture (Or, render just the portion the cursor covers), and then draw the cursor using that texture and a shader that inverts the color. Unless you've already got a deferred renderer, this will probably be more hassle than it's worth. If you do, you can use the existing depth/color buffers, and re-shade the pixels covered by the cursor in your color-inverting shader. 

This will call the action passed in for every block coordinate that intersects the ray. You should be able to figure out how to make it choose the block closest to the camera. Another solution is to use a raycasting algorithm, but I'll let someone else write that one up. 

Sprite batch is implemented with 'camera-facing polygons with Z set to zero'. IIRC it even has rotation, and if it doesn't, you can supply your own transformation matrix. Your choices are equivalent. Ask yourself how much work you want to do duplicating spritebatch instead. 

Define a list of values that might influence achievements (e.g. Highscore, Highest-Completed-Level, Number-Of-Hours-Player, Cash-Earned) Every time one of these values changes have the "owner" of the value (e.g. the "Player-Class" for "Cash-Earned") send a valueChanged( value_id, new_value ) event which is routed to the AchievementManager. The AchievementManager checks his list of conditions (for incomplete achievements depending on that value) and updates the achievements (sending an event if needed). 

For the last few projects I have leaned more towards an MVC style approach. At first we weren't sure if this would work, but it worked perfectly. Model The data objects. Just the pure data. No behaviour, no rendering. Data manager. Just handling "lists" of data objects. (Can also be enhanced to support pooling.) View We call them renderers. For every data object type there is a renderer. When called with a manager it will render all objects in that list. Controller Same as the renderers, but controls the behaviour. Example The ShipManager has a list of Ships. The ShipController will move the Ships according to their state. The ShipRenderer will render the Ships according to their state. Why This way the view and the logic are strictly seperated. It makes porting to a new platform pretty easy. Optimizing the data layout inside the XxxManager is also very easy. 

As Byte56 said: "never trust the client", but: Never trusting the client comes at a price: Having all games being played on the server will increase your infrastructure cost a lot. Assuming most of the players won't cheat and the top highscore will settle after a little time and stop changing a lot there is a middle way. Record the games (on the client). (Depending on the game type that might be super easy (e.g. chess) or a little complicated (e.g. a multiplayer FPS), but it's always doable.) When a player finishes a game just submit the score. If the score is within a certain range at the top (e.g. top 1% or top 5) request the recorded data from the player and replay that game on the server. If the scores match, accept the score. This way you don't need any additional server side resources for most of the plays, but can ensure the top scores are valid. 

In all of your examples, there is a terrible problem. The health component needs to know about every component type that might need to respond to the entity dieing. Therefore, none of your scenarios are appropriate. Your entity has a health component. It has an animation component. Neither depend on or know about the other. They communicate through a messaging system. When the health component detects that the entity has 'died', it sends an 'I died' message. It is the responsibility of the animation component to respond to this message by playing the appropriate animation. The health component doesn't send the message directly to the animation component. Maybe it broadcasts it to every component in that entity, maybe to the entire system; maybe the animation component needs to let the messaging system know that it's interested in 'I died' messages. There are many ways to implement the messaging system. However you implement it, the point is that the health component and the animation component never need to know or care if the other is present, and adding new components will never require modifying existing ones to send them appropriate messages. 

If it's in the vertex shader's input structure the shader needs it in the vertex stream, whether you use it or not. XNA is enforcing that. You're implementing optional texturing improperly. If you do it this way, you'll need to supply texture coordinates always. Also, branching is still to be avoided. Instead, have two techniques, referencing two different vertex shaders, with two different input structures. One input structure has texture coordinates, the other does not. Then, choose the correct technique for drawing. You don't need to have a 'texture enabled' constant in your shader at all. 

If the entire model uses only one texture, theoretically you can set that texture and draw the model's vertex buffer and index buffer in one call, since the entire model is stored in a single vertex and index buffer. Except, when you load the model the indexes for various mesh parts will not be relative the vertex buffer as a whole, but rather the mesh part's vertex offset, making that impossible for no good reason. So to draw the entire model in one draw call you will have to create a new index buffer with corrected indexes. 

After having used display lists for my programs since I started learning OpenGL, I've finally decided to switch to VBOs after experiencing a considerable amount of lag when I started work on a new game. I've nearly finished with my transition, but I'm still having a bit of trouble with rendering the textures to the screen. The way I'm working it is this: I have several sprites of the same dimensions for each type of "block" in the game (it's a Terraria port) which are loaded into the game via a convenience method, then after they're all loaded, they're compiled into a virtual texture atlas via Graphics2D, converted to a Slick texture, and their relative coordinates are saved to a HashMap. However, when it comes time to grab the textures out of the HashMap and render them, the game simply doesn't. Here's part of my code for adding a block to the VBO (this is executed 4 times per block, once for each corner): 

The blocks are properly rendered with the correct lighting, but they lack any sort of texture. Any suggestions as to how to get the code working? I apologize if the answer is obvious, but I still consider myself a bit of an OpenGL noob, especially in the area of VBOs. One last thing; I should mention that I'm not using any shaders in my current game. EDIT: I seem to be a bit mistaken. Upon experimenting with the code by manually setting all texture coords, I discovered that the game simply converts the texture to a uniform color by averaging the RGB value of all pixels. I didn't recognize this before because the color of most blocks is grey. I recall having this problem before with display lists, but that was quite a while ago, and so I don't remember how I resolved it. SECOND EDIT: Screenshots of the expected and actual result, respectively: $URL$ $URL$ 

Larger is always better, but: Inconsistent framerate can lead to motion sickness. (We had an internal tester throw up when his framerate jumped between 20 and 60 for 10 seconds.) 

Don't forget the load/save/reset edge-cases, but that's it. My current implementation has around 70 lines of code, not including the "Achievement.config to achievement.cfg" converter. The configuration currently looks like this: 

The converter is actually a little smarter, extending "10K" to "10000", warning about duplicates, detecting of conditions are conflicting, etc. Sidenotes: You could use an enum for the achievement and value id, but I prefer CRC32s, since you don't have to update a list for new values and still get the benefit of numeric keys and even can map them back to the original name in debug builds. (But ids are a completely different topic ;) ) The system once had a quite complexe boolean logic for conditions, but in the end all we ever used was "and", so we removed it. 

(Trying to avoid the "don't use an asset manager"-discussion here, since I consider it offtopic.) A key/value map is a very usable approach. We have one ResourceManager implementation where Factories for different Resource types can register. The "getResource" method uses templates to find the correct Factory for the wanted resourcetype and returns a specific ResourceHandle (again using the template to return a SpecificResourceHandle). The resources are refcounted by the ResourceManager (inside the ResourceHandle) and released when they are not needed anymore. The first addon we wrote was the "reload(XYZ)" method, which allows us to change resources from outside the running engine without changing any code or reloading the game. (This is essential when artists work on consoles ;) ) Most of the time we have only on instance of the ResourceManager, but sometimes we create a new instance just for a level or a map. This way we can just call "shutdown" on the levelResourceManager and ensure nothing is leaking. (brief) example