In this case, since these values are so tightly tied together, you could have one method to set both values: 

In this code, I have not added your check, but that can easily be added into , although you could then rename it to or something. Going the extra mile Having this method, it is very easy to add support for some very crazy neighbor styles. This might not fit your game, but using crazy neighbor styles can transform a concept into an entirely different game. For example, take Minesweeper Flags (where the objective is to find the mines and not avoid them). 

As far as I can see, there is no functionality that you would lose out on if you would go this way instead. 

This will generate 4 * 1, 4 * 2 and 4 * 3, respectively. Adjusting the number of signs leave us with: 

Side note: If you are using JavaFX 8, you have the possibility to define an in your FXML for your buttons, this will be associated with a method of that name in your controller. See also $URL$ 

So you see, your first item now has the same weight as the second item. This was not intended. The correct way would be to use which will randomize a number from 0 to 8 (inclusive), and then iterating and adding to again and comparing with , now let's see the distribution: 

There we go, much better. Or an array to make it configurable As an alternative to the math operation, if you want to configure the details: 

I must say that I'm not an expert in Objective-C. I have used it though so I will review what I can and hope that others will fill in for the rest. First of all, to address your questions about variables and properties. Here's how I think about it: 

However, if either or fails, you're screwed and won't be able to restore the list. Using is a bad idea IMO as that reads through to the object. So if you clear your list, your unmodifiableList will be empty. 

Expanding a bit on what the first answer mentioned: There are no Quiz, Question etc. classes. Your current code has this data: 

Catching all s is a very bad ideaTM, as there are plenty of throwables that are not meant to be caught. This includes OutOfMemoryError and StackOverflowError which are among the worst, but then also some s which indicate a logic error in your code, including: 

This line is excessively long and contains a lot of different instructions, in my opinion this is unnecessarily confusing. By splitting it up I consider it easier to read and understand. It can easily be split up to the following: 

Generally when using 2D grids, I find a method to be extremly useful. In Minesweeper, I prefer a method rather than a check, as checking if it is a bomb is a common thing to do, and if you want to change to be a matrix of , then it's much easier to perform that change (although then you should make a method in ) 

Hexadecimal values are often showed in lower-case, personally I like that better because it makes it easier to separate the characters (a-f) from the digits (0-9). If you still want to use upper-case characters though, use this: 

Some strings are actually included in Android by default, such as and , use them when possible. When you want the negative button to just close the dialog, you can actually pass as the . 

Possible improvement: Catch (or use a regex in advance to make sure that it is a number, but that might a bit over your head right now). 

The whole thing is kinda weird though, I can't really see a particular use-case for this kind of method. 

By making it it seems like you are in the "singleton mindset". Avoid this. This has no business being either public or static. Imagine if some code somewhere at some point would call - That could break a lot. This field is also a big memory leak. You are only adding tasks to it, you are not removing any tasks. Extending for no reason You are extending the class, but all methods and fields in that class are . Extending it has no real effect besides giving you quick-access to the methods and variables, by not having to write each time. This is a bad reason for extending a class. getTask Your method, although it is not used, suggests that you are using the wrong data-structure. You could use a which will make the lookup much more efficient (from \$O(n)\$ to \$O(1)\$). As you are dealing with multi-threading, better make it a ConcurrentMap as well. You should however ask yourself if you really need this in the first place. Are we working? Are we working? Are we, are we, are we? This code: 

This will cause 2x NullPointerException. There is no most frequent item. There is no most frequent count. I would expect to return 0 in this case, and I'd probably make return . Either way, it is an edge-case that I don't think you have considered. It's up to you how you will handle it :) 

Close Scanner Scanners should be closed when they have been used. at the end of your program will take care of that. 

According to whom? If you think it's easy to understand, it's probably because you're the one who have written it. It's easy to understand your own code when you just wrote it. Now, I have to admit that the code is quite understandable, yes. There are however some things you can change to improve the understandability. Some things have been covered by 200_success already, but there's one more important one: Naming. 

This is a quite easy fix. All you need to do is to extract a method. Both snippets have the same input: Both snippets have the same output: Both snippets can throw the same exception: Put this method somewhere: 

There are two significantly different ways I can think of to rewrite your code. The first is to put and together by letting one case 'fall through', and then using the ternary operator with in the code to see if we should invert or not. 

The call to is not the responsibility of the fragment. You are violating 'Tell, don't ask'. Big time. Instead you should read up on Communicating with Other fragments 

Also, use an extra indentation step (one tab / four spaces) after each and go back one indentation step after each . Applying this, your code will look like: 

The class contains absolutely no abstract methods. There is no reason for it to be abstract. There is also no reason for the classes and to be separate classes from . There is no reason to extend the class at all. Remove the classes and and skip the part of . And by the way, the correct English spelling is . 

A variable named sounds like it's supposed to count the number of items in the entire array. That's not what your variable is doing. A common name for simple iterator variables is (and then for an inner loop). As long as you're not dealing with two-dimensional arrays, using the names and is OK. If you want to elaborate more on the names, you could name them something like and . 

In start checking if it's divisible by two, then start check 3 and increase by two on each step. So instead of checking 2,3,4,5,6... you check 2,3,5,7,9,11,13,15... You only need to check numbers up to sqrt(number) in your method 

It is better to declare your variables as , and instantiate with to allow other implementations of . Like this: 

Missing flexibility You provide some ways of altering the text, but you do not provide a way to change this: 

General advice Prefer to declare variables by interfaces and not implementations. You don't need to specify that you use and return an , specifying is enough. So the first lines would be: 

Naming and interface should instead be , there's no need to keep in the name, there's no need to restrict the interface to only enums either. Your questions Reflection? Yes, this line of code is using reflection: 

If you would use Java 8, you could use the interface and lambdas. You could also make the whole ActionListener things a lot smoother by using Java method references. (I love Java 8!) The current class names , etc sounds like they , but they don't (and they shouldn't so that's good). Better names would be adding at the end, however, if you are unable to use Java 8, you can create a common class like this: 

Even though doesn't provide any methods to check for divisibility directly, it does provide a method to make the into a , and as we all know, doubles do support the operator. Other slight modifications: 

This will apply to as well. You will still need one for each kind of primitive though (boolean, short, int, long, float, double, did I miss anything?) As for your other method... 

You don't need to declare the variable as you're not using it any more in the method. The compiler should give you an unused variable warning here. 

Speed Looping over each and every tile in the game is a bit slow. You might want to consider keeping track of the zones that actually have some content on them. You can do this by using a , or perhaps even , or if there are generally a lot of empty tiles, perhaps would be enough. You might want to consider splitting your world data structure so that general tile data is kept as a two-dimensional array, and objects that do something are kept in a . 

So here you have a repeating loop that does more or less absolutely nothing as fast as it can. As you already know how long you should wait, use instead. 

(Now I see that toto2 has provided more or less the exact same answer) The important part of generics is that they provide flexibility in what type of data your class uses. If you want to make a KDTree of Points, you can use , but in another project you might want to use a KDTree of Cards, so you have . Then someday you might want to have a list of KDTrees of Points, so you get . 

Again, you're using a copying-approach. To check for whether or not an object fulfills a criteria, you don't need to copy it, modify it, and check if it fulfills another criteria. Copying it and modifying it makes it slower and uses more memory. Instead, let's use a method: 

But the fact is, this is slightly dangerous. Although your class is immutable, this is not. Imagine the following code: 

However, an even better way to do it would be to use the Jackson library which can parse the JSON into a Java object. I can highly recommend this library, I have used it in multiple projects (also for an Android application) and it works great! Take a look at Jackson in five minutes to understand the basics of using that library. 

When doing animations, it is helpful if you know the platform you are doing them on. I have to say that Swing is not the most helpful platform to do animations on. There are a couple of tutorials out there for how to do it. What I am mostly noticing in your code is that you don't seem to call or anything like it anywhere, which makes me a bit surprised that this actually works at all. If you are developing with Java 8, I think you would benefit from using JavaFX which has better support for animations. If you are interested in developing games with Java, I would strongly recommend using the framework LibGDX. 

This is an interesting problem! You kept our chatroom quite occupied with discussing this question for quite a while :) Your approach is interesting but it has one big flaw: You're starting from the wrong direction! Instead of starting from a and b, start from c and d. Ask yourself this question: What are the ways to reach that number? Consider this problem: (I will use the notation ) 

Speed Improvement Currently you're saving the result of one calculation into your array, and while that's a good start you are missing out on some values you can use. Let's take the example of . The sequence is: The only result you are storing from this operation is . But you have also found out that has the value , has the value , has the value and so on... Your algorithm would increase significantly in speed if you were also storing these intermediate values. 

Isn't that more readable? At least it is to me. Variable names You are using way too many variable names with only one letter. I suggest renaming them like this: 

About your primary question: I'd definitely go with whenever I have the possibility to do so. As you can pass on an array to a varargs parameter, but not varargs to an array parameter, varargs is the better option IMO. Other comments Naming 

One step to clean it up would be to use a String array of all the values you want, and then loop through that array. 

It looks like your MVC-approach is fine. Your model does not directly know about the view or the controller, which is the most important part. About SOLID, let's see... first of all, do you know what SOLID is? Single Responsibility Principle I don't think and methods belong in your view. You could add a method to your enum. Also, that enum could deserve having a value as well, to avoid using . Additionally, your method is responsible for two very different operations: Clicking the "new game button" and making a move inside the game. I would use two separate ActionListeners for this. If you're using Java 8, I would even use Lambdas. Otherwise, feel free to use anonymous inner classes or anything else. Interface Segregation Principle + Dependency Inversion Principle You're not using any interfaces at all, so this is not SOLID. (I personally think it's a bit overkill to use a whole bunch of interfaces for this simple program though). Other comments You're currently doing: 

Beware of instanceof operator. I am sure that whatever it is that you are trying to do here, there are better ways to do it. Java is a statically typed language, use the static types whenever possible. If you really don't know what type the object have, then I will provide another alternative below. 

This is because your class is not static. Non-static inner classes can access all properties and methods of their parent class, therefore the compiler warns you that if you use you won't be able to access the from . Making the class static will solve this warning, and will effectively tell the compiler that you're just not interested in the outside class. 

I find this a bit easier to read and understand. This can also be applied to the monkey's (@rolfl's) code: 

It is important when using a synchronized Set that you only do one method call here, as there could otherwise be a gap between and which would again cause concurrency issues between threads.