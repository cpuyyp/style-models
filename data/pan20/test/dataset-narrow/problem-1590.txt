I believe there's a degree of indeterminacy with regard to execution order. If this isn't required by anything else, and isn't required to happen before anything else, then it won't be a priority. 

Since this means you are using a Pi 2 or 3, parts for which are sometimes referred to as "2709" instead of "2708". However, as far as I can tell, the watchdog module has the same name for both of them: 

There's a kernel driver; Xbian's is presumably a user space one, but the former is a different implementation. I would guess it will consume less resources when you are not actually doing anything with the partition. However, it may not be available on Xbian. Unmount the drive and try instead: 

You would have to boot a minimal system that can run with the root fs entirely in memory -- which is possible. Are there any good Raspberry Pi distributions that load completely into RAM? In addition to the suggestions there, apparently Tiny Core can run in RAM on the Pi: $URL$ The trick with this is you will have to write to the SD card while streaming the image from the net, since it is unlikely you will have enough memory to download it entirely first. If you need to have a normal system on the SD card, you have a few choices, some of which require a spontaneous reboot: 

Again, look at afterward -- but it is unlikely to be fruitful. My advice with wifi adapters and linux is: 

If this is happening something is probably broken, and if you have really replaced the executable repeatedly, it is likely something it links to -- a library, but obviously not too critical a one or else you would be having this problem with other things as well (or, it could be the broken bit is in a common library, but it is an obscure bit). By "broken" I mean the file has become corrupted. The only other possibility, since you are using stretch ("but the default repo is jessie") is it is some subtle mismatch in pieces that has gone unnoticed (which might happen particularly if it is a relatively unique mismatch of jessie and stretch pieces). If you want to try tracking the problem down (and I cannot promise it will work), , then run , it will take 10 seconds or so to get to a prompt, then enter where is the rest of the commandline you would usually use with . When the segfault happens, the prompt will come back. Type or . The first time you do this, you may get a lot of , but you may also get a message to install some debugging packages (I'm not positive the Debian/Raspbian version does this; if not things just got too complicated). Unfortunately those can sometimes be quite large. You can then try the backtrace again and get more details. If you edit that backtrace into your question I can hazard a guess at what is broken. However, if this is happening more widely you might as well re-install; random corruption of system libraries is not something that can easily be fixed. 

Then it should happen before many or most other things. Double check to make sure that's actually in use first (), otherwise this won't make any difference. 

While you haven't said what the "Windows computer" is, presuming it's not a tiny low power arm box (like, say, the Raspberry Pi...), a very very significant difference in performance is hardly surprising. As in, several orders of magnitude, not just one, as people might guess by looking at processor Hz. This is in part an ARM vs. x86 issue. How does your phone honestly compare to your laptop? The primary heavy lifting I do on the pi is compiling (C/C++), and something relatively light weight (which will compile instantaneous on my desktop) can easily take 5+ seconds on the pi using the exact same compiler and OS. I think number crunching and image processing falls into the same general category. I'm sure you've noticed this with the java bytecode compiler too. Have you analyzed specifically where the latency is generated? If it's in here: 

I dunno what ancient FAQ that was; also compiler flags are one of those things that are easily used and abused by people that don't really understand what they are doing (the point of that link may not be immediately clear and it has nothing directly to do with the pi, but had me in ROTFL state the first time I saw it; also note there is a bit of foul language). This has a telephone game like effect on the internet and is characteristic of cargo cult programming. Do not fall down this rabbit hole, there is no rabbit, treasure, useful information, etc. of any sort inside. Anyway... 

I think you have misinterpreted a few things. First, keep in mind the product page notes "low level suction close, high level release". This means the contacts are closed and the circuit will be engaged when the input level is low. Next, digital logic deals with thresholds. 0.05V is certainly low if the logic level is 3.3 or 5 volts. It does not need to be 0.00000000 V. So there is nothing wrong there. The input signal is low so the circuit is connected. Your problem is you can't drive the signal high to deactivate it. 3.3V is not necessarily high if the logic level is 5V, which is also explicitly what that relay set uses, meaning, you likely can't use it hooked up directly to the pi. You need a level shifter or darlington transistor array (I think the latter is better for relays as they may sink more current than the former will pass but I am not sure; darlington arrays are also cheaper, look for ULN2803 or similar ICs). If the relay is only disengaged by a high signal, then you are always pulling it low when the GPIO is set as an output, so it is always engaged. Since the relay is unquestionably 5V controlled, you could test this premise by using a small resistor (< 1/2 KOhm) to connect a 5V pin from the pi to an input on the relay (probably the resistor is unnecessary, I'm just paranoid). When you set the pin as an input, it is actually in a high impedance state and if the relay's input is pulled high by default, then it will disengage, exactly as if nothing were attached. This is different than sending it a low voltage signal. 

System directories don't exist for no reason, so don't start deleting them willy-nilly. If you did this as user pi, chances are the data is in somewhere, but sometimes applications will also use as it is world writable, or somewhere in if they have a writable location there.1 Commonly is actually a small, in memory directory (meaning it won't hold much and does not persist across boots) but I believe this is not the case by default on current versions of Raspbian (there are a few similar things though; you can check for such directories with -- but these are obviously not the problem here). A good tool for finding this kind of thing is ; this will give you per directory totals for a tree, e.g.: 

That depends on what you mean by "use the PC's terminal", but once the PC is on you could do whatever you can normally can do with it remotely. 

Note that the "technical, abstract quality" people may think of as executable is not obvious without examining a file's content, and even then is not guaranteed without actually trying it -- something it no filebrowser anywhere should/would do because it represents a serious security risk. Just because you plug a USB stick into a computer does not mean you want the OS to try and execute every file which claims to be executable, in order to tell you later for sure whether it is or not. Further, that that abstract quality we may think of is still not what we often really mean by "executable", or at least would like our file browser to recognize as such (so it will, e.g., include scripts), even if we don't understand this distinction, which is why the permission mode is normally more of a pragmatic indicator. In this case, as other people have pointed out, the reason that file won't execute is because it's not in the right format for the operating system. What happens when you try to do so depends on how you try to do -- processes are always children of other processes, and it is up to the parent, in this case PCMan, to do stuff like resolve any errors and report them to the user. However, it may have other priorities that account for why it won't always do so. You can usually get a clue by running on the file, which examines its content for indications of what the file is for. 

If you are using this for electronics you might as opt for a 40 pin model, i.e., A+/B+/2. The only advantage the B+ has over the 2 is very slightly lower power usage. If power usage is a big concern and you don't need ethernet, etc., you could go for the A+. Most people are going to want the Pi 2 here, however. It is significantly faster, has twice as much RAM, and because of the more common architecture, can run a wider variety of operating systems. 

And just comment out anything else to do with HDMI. This presumes you have a standard, 1080p HD display. If not see here for other options. 

I have not used it, and I think it does not qualify as a true RTOS, but if you want a platform on which a process can run uninterrupted for an arbitrary length of time, I believe RISC OS can deliver that (beware "RISC" also refers to an abstract sort of ISA on which ARM processors are based). As per the wikipedia page, RISC OS uses cooperative multi-tasking: 

simulate this circuit â€“ Schematic created using CircuitLab Note the connection to ground from "GPIO 3.3V" does not mean you need to add that connection -- the pin is only the + aspect of the voltage source there, the other part is abstract. 

Web interfaces are the easiest to develop, since you don't have to write much client code and existing webservers take care of much of the nitty gritty. If you want to do something more custom, you'll have to write some kind of server on the pi and a full blown client app on the phone. 

I doubt that will make any difference in this case, but if you aren't using the RAM, it won't hurt. You should try hard to leave 50-100 MB+ free on the pi for the OS file cache, loosing that will hurt performance. 

1. A pi has things even a $3000 desktop does not have. You cannot really access the I2C bus, etc., on a normal computer. This is why it is called a development board. 

If all you are doing is starting one app, there's not much purpose to a window manager unless you want a frame (needed to resize the window). Note that this: 

This last point about versions is significant because the theming for each major version is controlled separately, and you could have contemporary apps using Gtk+ 2, Gtk+ 3, Qt 4, or Qt 5. I know that epiphany uses gtk, but newer versions might use v. 3. Gtk+ 2 is controlled with a per user file, . An easy way to set that from the desktop is , which is an independent package: 

Hmmm. HTTP is the serialization protocol used with the world wide web. An HTTP header is used to communicate between client and server and to wrap content payloads sent from one to the other. HTTP is a plain text protocol. There are two fundamental sorts of headers, requests (client -> server) and responses (server -> client). A typical request header might be: 

I don't think you have to do more than that but if you do need to build the kernel itself -- which will take hours on a pi -- you might as well switch to back to the latest version: 

This indicates that the second partition on the card () either does not exist or is not formatted properly.