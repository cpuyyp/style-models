What you're doing sounds a lot like premature optimization to me. Did you try using the physics-engine and did it actually turn out to cause performance issues? If you don't need the physics-simulation and just care for the collisions, why not use sensors (or "triggers", as they are called in Unity). For stationary objects, use a collider with the checkbox ticked. For moving objects do the same, but also add a rigidbody and set it to be kinematic. That way you'll only get collisions out of the engine and no other simulation is necessary (use the callbacks instead of the ones). If you only need to detect collisions in 2D and the physics engine really turns out to cause performance issues (I highly doubt that, but I have no clue how your game looks like), then you could probably get away by representing your entities as circles and just do a very fast circle vs. circle test? 

As you can see, we're always executing in the update () method. But we can dynamically change during runtime. So in the function I'm assigning to , when a certain condition is met. This pattern is pretty close to an implementation with classes and should be fairly flexible. But if your implementation already works, why not keep it the way it is? I'm pretty sure you have already implemented your own FSM pattern and it seems to work. Also using classes is really easy. Just write your class, save it to an file in the same folder as the FLA and then instantiate it with in your code. A quick google-search turned up this tutorial. 

A further optimization would be to not always calculate cos/sin, but rather have a vector that you only recalculate whenever the direction changes... Then it would turn into: 

This could also potentially result in lots of iterations but is quite unlikely. Certainly it will be more efficient than re-shuffling your whole board every time. Addendum: Please don't refer to these kinds of games as "Candy Crush". Match-3 would be the neutral wording.. or "Bejeweled" if you have to use brand-names ;) 

You can connect to as many components as you want to listen for this signal. Eg. you could add a component that looks for remaining game-time and plays a warning sound if 10 seconds remain, etc. So why did I propose Signals/Slots instead of public functions or Events? The Signals/Slots pattern is really powerful, because it is almost like calling public functions directly, but it allows for loose coupling of components. Another benefit is, that you can see the type of signals a class dispatches by looking at its interface. You don't have that with events. They aren't declared anywhere and any bit of code could fire an event... therefore events need much better documentation to be understandable. 

No. The device has an entirely different hardware than your PC and testing your App solely on the Simulator isn't going to be enough. You might hit problems in the simulator that won't occur on the device and vice versa. The simulator also doesn't simulate memory constraints of a device. I know that getting a Mac and an iPhone can be rather expensive, but I'd look around for used hardware. A Mac mini can be a good choice as these are rather cheap and won't take up much space. A cheaper alternative to the iPhone is the iPod. The hardware is essentially identical (apart from the actual "phone"). If you own an android device with similar specs to the iPhone, you might use that for testing during development and ask a friend that owns Mac hardware to test the game at key-points in development. Still, there's no way around testing on the actual device. 

Apart from the Rocket Engine, these engines just cover the client side of a game. So there's no direct communication to a database (unless you're using something like Google Gears). Depending on your game, you still have to implement some backend stuff in Ruby, Java, PHP, ASP or similar. IMHO any regular web-application framework will be sufficient for that. Node.js probably deserves a special mention, because you can implement the backend in the same language as your game (JavaScript). 

If you really want to do this in code (instead of converting the sprite-sheets you have), I suggest you use the BitmapData:draw method to draw an existing BitmapData object (your Sprite) into another. When using the method you can also supply a transform matrix to use, so basically you do the following: 

Some general advice when dealing with SharedObjects: Make sure to wrap your calls dealing with the in blocks (especially and maybe even . Some people disable writing of alltogether (in the flash player preferences) and your application might crash on their system if you don't catch the error. 

It's probably best to reduce the amount of possible collisions within a ragdoll to a minimum and just work with joint constraints. And of course playerA collides with playerB. 

I chose a threshold of 0.04, everything above the threshold would be colored blue. The rest remaining black. Then after that, it's time to determine which "islands" to keep and which to throw away. A possible approach would be to run through the image from left to right at various heights and select intersecting "islands" given a certain probability. In the example picture, the lowest line has a probability of 100%, so every island it crosses will be selected (filled white). The second line has a probability of 50% and the topmost line has a probability of 10%. Once you have your islands marked like that, you can close the gaps in between by applying a morphological operation (dilate) 

You could draw these shapes in a vector tool like Illustrator or Inkscape and export them to SVG, which can easily be parsed. Or use Flash and export the shapes as FXG, which is also a format that can easily be parsed. If I haven't convinced you yet, and you really want to programmatically create the shapes from your sprites, here are two approaches that might work. 

I think these are some common requirements. Each one of these requirements could be filled by a single person, so finding one that excels at all of them will be near impossible. You should therefore set some priorities what's most important to you. In addition to the above, there's also the usual skills that should be there, like good communication and teamwork skills etc. Update: Since you extended your question, here's an updated answer. So you have a skilled friend and you would like to give him advice on what to learn, so that he can participate in your game-project. I'd say it highly depends on the art-style you're going for. If he's a painter and you're creating a game with painted assets, even better. Then the main thing he has to learn is to scan the paintings and mask them (eg. apply define the transparent and opaque areas of the sprite). Also he should pay attention to scale. It doesn't make sense to paint lots of details when the assets are going to be shown with only a few pixels in size. Knowing tools like Photoshop/GIMP and Illustrator/Inkscape is a must and something he/she should learn first. 

I think this is quite the opposite of "killing" encapsulation. So in summary: I would recommend to separate your classes, but not because of memory-concerns... 

I didn't have to calculate voronoi regions for my SAT implementation. I implemented circle vs. polygon intersection as described here: $URL$ and it worked fine (also have a look at the links at the bottom of the article). 

As others suggested, the format might be a way to go. It doesn't support bones or animations though. Another option is COLLADA. Since this is an XML file you should be able to parse and extract information from it easily. Here's a blog post that sheds some light on this. Writing a good/robust parser for COLLADA won't be easy though. My biggest gripe with COLLADA is, that the generated files from different applications (eg. a COLLADA file exported with Blender and one exported with Maya) can be quite different. Depending on how many features you need, it could also be advisable to compile a parser like COLLADA DOM for iOS (maybe it has been done already). 

Classical 2D animations are created frame by frame. What you'll see often is that they use a reduced framerate (eg. every frame is displayed twice) to lower the amount of images that have to be drawn. Flash is a very good tool for 2D animation. It provides you with onion-skinning (previous frames shine through while you're drawing your new frame), tweening and shape-morphing. Since version CS4, it also comes with bones and inverse kinematics which makes animating characters with limbs so much easier. There's also "Toon Boom". They have a lot of different software-packages available, for hobby/fun up to professional animation software. Tools like GIMP and Photoshop also provide some functionality for animation but that's really just for very basic stuff. Another, not so obvious option for 2D animation is using a 3D Program. Did you know that later episodes of Southpark were animated using Maya? With an orthographic camera projection, proper lighting and flat-shading you can create animations that look 2D, but are created in a 3D software. Most 3D programs have sophisticated animation tools like bones, inverse kinematics, constraints, soft-bodies etc. Blender would be a good (free) choice to get started. 

Instead of tinting the whole sprite in the given colors, it uses multiplication. So if you have a white pixel () it will have the given color, while a black pixe () will remain black () 

You should be able to specify the pixel-format to be instead of . For glTexImage2D this would be the format parameter. 

The majority of social media flash games do not use a 3D engine at all. They are mostly 2D games (including fake 3D like isometric etc.). That being said, Papervision3D is basically dead. There hasn't been much upgrades for this engine. Away3D is still actively developed, so are other engines like Yogurt3D or Alternativa. But since Unity3D now also allows you to publish a SWF, this is probably the easiest way to create a 3D game that runs in the flash player. 

Mashing up this JavaScript Perlin-noise implementation with the turbulence function described above generates noise which is pretty similar to the image above: 

This is an effect of the joint-solver that tries to keep the joints together but fails to do so when big forces are applied. This occurs frequently when a "rope" consist of a large amount of small individual elements and joints. Things you could do to improve the behavior: 

You'll find this shader under > in the shaders dropdown. For the cutout texture, I recommend you set it to (available under , when you switch the Texture type to "Advanced". Use "Alpha from Grayscale" setting if necessary). That way you'll save some GPU memory.