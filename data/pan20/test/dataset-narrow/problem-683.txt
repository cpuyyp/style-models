Exercises The function above is left-biased. Why? Could this pose problems for your program? Why not? 

Your code is fine, except for the stray method. at that point isn't valid, and you will try to connect to a server called . Just try your call with , you will notice two connections: 

By the way, Haskell programs use , so would be appropriate. However, does this function really capture your intend? Let us write it as imperative variant for a second: 

Documentation mismatch The documentation and the functionality do not fit. Your function is supposed to "check if [a string] has duplicates". From the documentation, I expect a function that returns if I have duplicate characters and otherwise. However, you provide , which does the opposite: return if there are no duplicates and if there are duplicates. The internal documentation fits, but I would say "checks whether it contains no duplicate characters" or "contains unique characters only". Possible bugs You checked your string only on alphabetic strings. What happens on ? You will index due to . That's a bug waiting to happen. Also, what happens if your string contains a ? What happens if is ? Maybe shouldn't be , but that should get mentioned in the documentation (see above). Also, you should mention that your function is case-insensitive. But why does count as a duplicate to begin with? Both cases (non-alpha character and same letters in different cases) should get added to your tests. Algorithm Your algorithm is fine if you know exactly how many buckets you need. But you often don't know that. A can happen here. If you use a you end up with the mentioned \$\mathcal O(n \log n)\$, but if you use a the asymptotic complexity is \$\mathcal O(n)\$ again. Alternatively, use a set. But that's asymptotic complexity. If you don't consider any non-alpha strings (see section above), then you can immediately return if the string is longer than characters due to the pigeon hole principle. 

That's important as soon as you change to another type, as the compiler can now issue warnings. Make function-specific read-only data and The in never gets changed, and only needs to get initialized once. We do not need to conjure a new every time. Also, we have to make sure that we don't change the contents of , so we should make it : 

Upper bound for p_n There is a known upper bound for the n-th prime. It means that you don't need any loop inside , and you don't need to check if either. 

One possibility would be to use a in order to check for duplicate integers. If there are no duplicates, the length of the list should be : 

networkx If you work with graph theory in Python, you should take a look at . It's fast, easy to use and offers many algorithms. All you need to do is to preprocess your data and feed it to a . Your example could become: 

You seem to think that this code would display 500 numbers between and . It doesn't. Instead, it displays , , and returns . You need to replace with . Alternative You can use to look for the substrings, them and replace them: 

As you mentioned, Pandas or at least NumPy would do just fine. They're fast and the syntax is clean and straightforward for this example. With NumPy You just need to define a mask as a boolean array: 

looks like . With Sympy You can delegate the job to and be sure you'll get a correct result with arbitrary precision: 

Theory Your function is very similar to the structure of . Keeping only the essential, you could write as : 

Performance The first part will be slow (300ms on my laptop). It doesn't depend on the pattern, so you could calculate it once and cache it with or . took less than 100ms. The second part is really fast though. For , the trie version is more than 1500 times faster than @200_success' code (40 µs vs 68 ms). The trie code gets a bit slower with more placeholders, it's always a few orders of magnitude faster than the other answers, though. 

You don't need to compare and during each iteration. The difference between the new and the previous sum is simply the current term : $$\frac{8}{(2i+1)^2}$$ If you want this term to be smaller than , you can solve: $$\mathrm{error} > \frac{8}{(2i+1)^2}\\ \iff (2i+1)^2 > \frac{8}{error}\\ \iff 2i+1 > \sqrt{\frac{8}{error}}\\ \iff i > \frac{\sqrt{\frac{8}{error}} - 1}{2}\\ $$ Now that you know how many terms your series should have, you can return the result directly: 

Better formulas Adding a delta Note that represents how small the terms are, not how close is from π²: 

is a guaranteed segfault, as soon as I throw a malformed request at your server. Don't even give me the opportunity to segfault your code. Say what you mean: 

Here I would worry that the programmer didn't know that arrays in C and C++ are passed "by decay to pointer". I would prefer to write this as 

You should be using smart pointers; i.e., this should be . Otherwise, you risk memory leaks if any of the later lines in this function throw an exception. Also, you should be using perfect forwarding () to eliminate unnecessary copies in the case that is copyable, and to eliminate compiler diagnostics in the case that is non-copyable. 

You should be aware that this comparator can have undefined behavior if and (for example). A better idiom for comparing "things" (not necessarily even integral things) is 

(Okay, seven problems. I was close with "three".) Removing this one line (and moving the function into a unit test) would fix all of these issues in one fell swoop. 

Here you're reading not-under-a-mutex-lock, while simultaneously might be writing to (that is, it might be popping from it). So you have a data race and your program is invalid. Also, your "busy loop" 

I question your need for ; it seems like you're putting an extra layer of stuff on the heap that you don't really need. But I haven't looked closely enough to be 100% sure. 

The really nice thing about this code is that because we constructed it by starting with C++17 and moving backward, it's easy to take this code and migrate it forward to C++14 (by removing the trailing return types) and then to C++17 (by replacing the implementation of with a one-liner, or inlining it altogether) as your compiler catches up. Looking at your original code, I think it would be a little bit harder to disentangle the C++11isms from the "business logic" of how to compute . For example, you've got the subexpression repeated in two different places, for no good reason that I can see. You could have factored that out... or rather, not factored it in in the first place! :) Don't repeat yourself. 

you should obviously prefer the latter. As a bonus, this means that your code will be useful ("reusable") even for people who are still stuck on — they won't have to switch all their code from to just to use your queue class. 

Just a collection of thoughts... Terminology Since you're talking about graphs, it might help the readers if you talk about nodes (your ) and edges (your ). Your graph is directed, and as far as I can tell, you're looking for the "strongly connected components". Use simpler objects Lists of pairs of pairs aren't very readable IMHO. When showing examples, you can replace them with lists of strings: 

Another alternative would be to work with generators and join the letters at the end instead of building a new string character by character. 

Theory Calculate prime factors For a semi-naive approach, you could calculate the prime factors of first: 

Even with more than 140 000 terms, the series only gives the 3 first digits of π². This formula is very simple but converges too slowly. What's very interesting, though, is that the difference between and seems very close to \$\sqrt{2\mathrm{error}}\$. It seems to hold true for any , so we could update the function: 

Python strings are basically tuples of characters, so you don't have to change much in your code. The above example is isomorphic to yours and is much more concise. KeyError When calling , you're hoping there won't be any . Your example would fail with : 

You get more information, it's more robust, you get diagrams if you want, it can handle more complex cases and (who knows?) it might be faster than your solution for large datasets. 

It calculates the 100000th prime in less than 230ms on my computer, compared to 1.5s for your code. itertools.islice Another possible optimization would be to use to get the n-th prime out of the generator, without converting it to a list. 

The main problem is that your method relies heavily on your hard drive. The process needs to recursively look inside every sub-folder, which takes time, especially with 50000 files. Windows search is much faster because it indexes the files and doesn't scan the whole drive for each query. If using Python3 is a possibility, the only thing I'd change in your code is to use and replace the loops with: 

Code Here's the refactored code. It's much shorter and 3 times faster than your original code for the primes below 1 million: 

now returns 10 correct digits for π². This new formula is unproven, so use at your own risk! BBP-Type Formula There are many π² formulas, so feel free to pick another one. For example: 

that should be a sign that you're using the wrong type for . Instead of taking a (which can be null), prefer to take a (which cannot be null). In other words, a C++ reference is very similar to a non-nullable pointer. (And if you need actual non-nullable pointers, check out the GSL's not_null template.) Also, remember to -qualify your pointers and references to indicate that you're not modifying their pointees; and remember that should be passed by const reference, not by value. Hope this helps! 

To answer the question you asked: You want to repeat asking the user for a seat number until he enters a valid seat number. In some languages (e.g. Pascal), there's actually a control-flow primitive called . In C, we spell it . Sample code follows, far below. 

This is a common anti-pattern I see in a lot of student code for some reason: you want to compute a value, so you make a class, give it a method, and then add memoization so that the method won't be so darn slow the second time you call it. This is an anti-pattern because it takes a notionally const operation (counting the number of tilings) and makes it a non-const member function. That is, it breaks this reasonable-looking code: 

is highly likely to be optimized into an infinite loop by any modern compiler, since the compiler can see that is a loop invariant — there is no code in the body of the loop that could conceivably change the status of the queue, so there's no point in testing the condition every time through the loop. If you want the compiler to know that there's some other thread participating in this loop, you'll have to explicitly tell the compiler that, via e.g. waiting on a condition variable. 

Your code doesn't compile at all, for many different reasons. For example, you try to use functions and that don't exist in the current context (maybe you meant and ?); you refer to both and ; you try to use without including the appropriate header; and so on and so forth. Next time, you should fix all compilation errors before posting to CodeReview; you'll get better (well, more targeted) answers that way. And certainly the answerers will enjoy themselves more. 

Here's the code showing why is worse than : if someone sees they're probably going to assume that represents an int (or at worst a ), and they're going to code accordingly, and their code simply will not work if you've used some other weird type. In other words, is widely recognized as a vocabulary type (a "ubiquitous type used throughout the internal interfaces of a program"), whereas is not generally recognized as such. Of course, might be used as a vocabulary type in your codebase; it all depends on your employer's coding style guide. But I would hope it's not, for sanity's sake (again refer back to the code in the Wandbox above). For another set of reasons that I mostly agree with, see Laurion Burchall's "unsigned considered harmful". Since you mentioned you've used Java, you might like this similarly titled blog post elsewhere, re Java, which makes some good points re "things C and C++ screwed up in their implementation of unsigned types."