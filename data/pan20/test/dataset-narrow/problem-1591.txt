to your /etc/network/interfaces file. This will run your script after your network interfaces come up. 

It depends on the distance between the Raspbery Pi and the Arduino... If it is a very short distance (up to 5-10m) you could consider Bluetooth For longer ranges you could consider RF (your NRF24L01), or Wi-Fi. Any of these three will be variable based on the immediate location and the antenna being used. Here is a link to some range testing of various NRF24L01 modules. For very long distances, you might be better having each end connect to a Wi-Fi access point and send the data over the internet. You might also want to look at the FIRMATA and MQTT, each have libraries for most languages (including Arduino and Raspberry Pi), and they simplify the transfer of (sensor) data between the devices. 

Those are simply the communication channel and any/all will work - the differences between them are range, speed, power requirements and how you interface with them. You will also need to decide upon a message transfer protocol between the arduino (presuambly these are collecting the data from the sensors) and the 'server' (presumably the Pi) For example - how will the server know which sensor the data came from, how will you signal error conditions at the sensor, what if a sensor cannot 'reach' the server (offline etc) - does it throw away the measurement or store it for transmission later? One possible approach could be to use WiFi and something like MQTT which provides for a lot of the communications layer challenges mentioned above. You might want to read about some of the stuff this guy is doing with ESP8226, MQTT and Raspberry Pis Good luck... 

There should be plenty of tutorials for each of these steps. Note: If you specifically want to server the page on a different port ($URL$ instead of $URL$ then you could do a 301 redirect from the the site running on the default port. 

It instructs the user to install . This is not available on Jessie and should be replaced with . () It doesn't specifically tell the user to make sure they are in the correct directory before running the . You should be in If you copy the and paste the final command it likely will not work as there is no space between the and the . Make sure you have a space between these. 

Generally when you get a new router it is configured to dish out DHCP addresses. Part of the DHCP configuration that is handed out is the DNS server, which is normally pointing to the router itself. For example, you connect to the router wifi, and get an IP address in the range 192.168.1.2-100, a gateway address of 192.168.1.1 and a dns server address of 192.168.1.1. You can check this on linux with and on windows with Whenever you browse to the given static url (e.g. $URL$ your machine sends a DNS lookup to the DNS server (running on the router) which returns it's own address (192.168.1.1). The router will also have a web server running, serving the configuration management pages. If you do a you'll find it canot be resolved publicly (because it is only defined in the router). So, what you'd need to do to achieve this on a Raspberry Pi is:- 

That generates lots of individual jpg files, but a bunch of frames get skipped due to processing time so the numbering sequence is out of kilter. 

NOTE: if you are using a +5v I2C expander you do need to check/verify the I2C pin voltages - as the Pi SDA and CLK work at 3.3v levels, and you might need to use a level shifter... 

I suspect the error you are getting is because the build failed (because of the jpeg library). Just install and try the steps from there again. If it still fails then please edit the question and add the output of and the exact output you get from the final command. 

Regarding 'version control' / 'configuration management' - you might want to check out Puppet or something of that ilk for easier management of multiple end points. You'd probably also want to look into some kind of device monitoring - maybe something like Nagios as you'd want to know if an end point stopped communicating, or filled it's (USB) disk etc. Security in a project like this consists of many facets - making sure that only authorized devices update your central server, making sure that devices only accept updates from the central server, making sure that users that log in can only see the devices for their building etc. 

Fixing the numbering sequence For easy post-processing you need to fix the file name numbering sequence. I that with this... 

I have a Pi NoIR camera and have been trying to timelapse film the night sky. I'm looking for the kind of effect you see where the stars all rotate across the screen in a half moon shape. I have all the timelapse still and encoding the stills into a video working no problem. However the results are poor at best. So, my question is; is the Pi NoIR suitable for this type of project, and if so is there a particular package (raspicam ?) that I should be using and, are there particular settings (exposure etc) that I should be experimenting for best results. 

So, to get down to (max 3.3v) on Vout you need around a ratio of 5:1 I'd look at around 100K for R1 and 20K for R2. Meaning that if the input was 18v you'd get: 18 * (20k / (20k + 100k) = 3v. ... and if it drops to say 12v, you'd get: 12 * (20k / (20k + 100k) = 2v. Some testing of the ADC values for known source voltages will be required (i.e. calibration) to account for resistor tolerances (and I'm not sure if the performance of the MCP3008 is completely linear). 

if you finish using the device, just it, do this otherwise the partition will be marked as dirty and may need a cleanup on next mount. 

Note that the boot partition is MS-DOS, so if you have to fix you can mount the SD elsewhere and edit. If boot fails, the loader will show on your (HDMI) screen the available mounting points. This setup is contingent to the mount order. The partition number may change if the device is mounted on another slot; you can make this location independent as follows. Find the the device 'UUID' 

Here you have two simple voltage regulator circuits that you can build, parts will be available everywhere. They are inexpensive and easy to build, parts are very common; your neighbor electronic repair will have them. A Ham-Radio friend can also be very handy! The optional fuse can be 3Amps for one Raspberry. 

When using Windows ICS (Internet Connection Sharing), your clients computers are using (Network Address Translation) on a ICS's private . Indeed the only visible address on your networks will be your PC's IP Address. For , you need to port 22 on your firewall. This tutorial will help you on the setup. you can use '22' inbound and outbound, Windows is not very familiar with SSH :) 

This will show all the past Wi-Fi connection plain text passwords ... no more secrets. If you mac have Ethernet connectivity, perhaps you can share the Wi-Fi doing Internet Connection Sharing and just plug your RPi to the Ethernet port. pd: If you know the SSID and password of your home Access Point (router), you can add as additional network statement on keeping your friend's definition. 

I have Ethernet and Wireless , each one connected on a different ISP. If I disconnect is kept unchanged, in my case ATT, pointing at their 'private' 'dns-servers' (75.75.75.75). My other network belongs to, in my case ; is not happy lending their DNS servers to a competitor, so they block the access. If I do a the communication is established again. I may use public DNS like 8.8.8.8 or 8.8.4.4, but I want a more generic fix to this issue. 

The Raspberry PI family run on BCM2835 ARM6 512kB or BCM2836 ARM7 1.0GB peripheral controller. Installing on any other processor, will operate just like any other Linux, without the rPI functionality (GPIO), so will defeat the purpose; drivers required to handle your phone will not be preconfigured, finally, the boot process on a phone is significantly different than on the rPI. So, the answer is no, keep using your phone as a paper weight. 

This configuration will allow to share/extend a Wireless network to use your own router (192.168.0.0/24); will be like and or . The WAN side can be any DHCP WIFI connection. There will be a double NAT, plus the extra hop, so the system will not be a fast access point but, a very convenient. You may also use this with a , allowing internet access to almost any non wireless enabled device. I use this configuration on my boat, using a pretty good external antenna, to connect to a remote (1 mile +) access point. 

In my case, sometimes with no apparent reason I get disconnected (once or twice a day). I have this job running every few minutes to reconnect the WAN if not up: 

On either case, you will need to find (and track) your router's public ip address, often randomly changed by your vendor. Notification when someone connect the device to the internet is a complete different story.... 

In a nutshell, the RPi family of devices does not provide a method to keep power alive while finishing a write operation on the SD card. If during a power disconnection the memory card is in a write operation, there is a high chance that one or more sectors will be unexpectedly damaged. My personal opinion is that the Raspberry Pi Foundation should take a look at this situation. 

I want to configure a Wi-Fi extender: on one side WI-FI and on the other Ethernet connected to a switch providing internet to some Wi-Fi challenged devices (TV, game consoles, sip-phone etc.). For a some time, I have the IPV4 version working, using IPTABLES, here the simple version (as a bash script): 

You will noticed that our external drive UUID is '1C0EBC7A0EBC4F10'. so, now instead of using the physical location (ie sda1) use the UUID: 

I assume that by now, your host computer ARP cache table no longer remember the 192.168.0.205 IP Address. 

This assumes the static IP on eth0 is 10.10.10.1 and you have a DHCP server listening on the same (or clients with static ip). Now, I want to add IPv6 to the mix. IPV6 is working fine, however, thus far, not success in sharing it on the ETH0 port (or whatever name on Stretch). Among other setings, I have 

W10 IOT when running on RPI is a headless system due limitations imposed by the amount of RAM memory available. You should handle your W10 using powershell; after the proper installation of WinRM, run Enter-PsSession '-ComputerName ` only then you can execute remote commands on your Raspberry IOT device. Your probably noticed that the HDMI is basically, not in use and there is no GUI. However, there are drivers to use the GPIO ports and you can make it great IOT device. 

You may edit your .conf to remove (or '#' comment) the replaced network. This network definition will be enough to associate/register. You don't need the usual parameters like: 

If you are working on a zero with no other access but your ssh connection, I recommend to buy a simple and then use puTTY to talk to your serial port. You will not be able to do changes on your eth0 while connected. You can experiment and write a small bash script, add configuration commands, and then run it in background process (batch). If you are connected, you will get disconnected and the process will abort. pd. omitted for brevity.