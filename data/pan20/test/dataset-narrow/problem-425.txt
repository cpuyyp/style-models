With this test however you test that the mock that you created returns a fake process list that you created.... this is pointless as this doesn't test anything useful. You are testing the mock itslef. It would be fine to mock the if you used it as a dependency for something else that requries a list of processe but in this test, there is no such thing. This test has no value. 

I sometimes need an object that caches some data but only for the specified amount of time. So I created a class that should handle this. The main goal was to make it generic unlike the and be a single object cache and not a general all-pupose cache. 

Why are these non-readonly fields static in a non-static class? You should always avoid because it's hard to test and debug unless you have a good reason for it. 

If you want to refactor your code you should start with code-smell. Currently it looks like at least four or five developers each with different coding-conventions have written this: 

You can greatly improve the readability and testability of the code by better encapsulating each operation into its own method. This will allow you to nicely chain them. Additionally you should unify the two loops calculating the sums so that they both start at the bottom right corner. With one more helper variable you can save the second loop from going over the zeros in each row. 

I find this helper extension is not necessary at all. Having immutable types with multiple properties (>3) makes it quickly ugly to use because of the huge constructor. Up to three properties it can be quickly initialized with new values anyway. Where seems to be ok to be immutable because it looks like it was correctly addressing the primitive-obsession; above that limit I'd think twice before making a type immutable to not find oneself trapped in the immutable-obsession. As far as your implementation is concerned I don't really like it: 

They shouldn't just enumerate the text but also keep track of where they are so that I can throw exceptions with exact location if something goes wrong thus the line enumerator needs to work with real indexes even for a range. The same applies to the char enumerator. I feel like the enumerators violate SRP (single responsibility principle) and I should create two more enumerators for enumerating a range of lines or a range of characters. Is this necessary or would you leave it like that? 

Nested classes should not be public. Then this class is not a list and should be called like that. MedialCalculator sounds much better. Shouldn't the API be named CalcMedian? 

I cannot complain about your code much. You declare variables as where appropriate and you use the block to free the resources. The only things I don't like are these properties 

Instead of doing this twice you should implement the interface on this object and use this instance as a key so that you only have a single . 

You don't have to run the same regex twice by first checking if it matches and then replacing parts. You can do everything in a single call to . If it won't match then the string remains unchanged. 

Since is the actual value of an enum, and the string representaiton is just a friendly-name for it, I'd just use . Otherwise you have to be careful about the lower/upper case of the that would change its hashcode. 

There are not many wild cards in these patterns because files are matched at the end of the sting by default and directories are starting with a backslash ´\´. But it supports and . 

This interface has the same issues an the one above. Additionaly the purpose of the method isn't clear. At the first glance I thought it returns a value indicating whether the server is connected but I guess it's about a client, right? If so then it should be called . 

Here you don't need to repeat the property names. C# can create them implicitly if their names can/should be the same. This means you can just write: 

Making it non-static and providing an abstraction would enable you to use it via Dependency Injection. 

If you decorate the second parameter with keyword then you can just type the values without an array (if you need to): 

You should not concatenate strings in a loop with the operator. Use a instead. Here it might not be that relevant but this is usually the most obvious bottleneck of string loops. 

You can greatly improve it by staring with proper names. The first enum is actaully a comparison type so name it like so: 

The code is not only for the compiler. People need to read it and they need to know what it does (not only today but in a month too) so yes, a lengthy condition inside an is a bad thing. 

Other improvements Magic numbers You should create an enum for the and cast the given by the user to it. Example: 

There's one more thing I forgot but you mentioned it in a comment. You need to fake the too but it's properties are not settable but you can mock an interface so you'll need another wrapper. 

This might be super inefficient. If you use a dictionary then don't use linq if you don't have to. For fetching you can use the method agian: 

They are not intended to be used on their own - too much generics - but are bricks for the final API. customization is for ad-hoc changes in single requests. 

Another thing I'd change is the variable. If you made it a , you wouldn't need the for or you could just use a and remove the two s. 

Why is there no redo? What kind of edit I can cancel? This doesn't seem to be the right operation for this kind of object. 

To keep the implementation short I chose to use mainly dynamic objects for the formatter. It has two methods: 

this one should not. needs to be used with a return type. If it's then you should use just . You may/should use only for event handlers. 

You specify a relative path in the config but at runtime you resolve the path and use it in the entire application: . Later when you save the configuration (because there are other saveable setting) you don't want to change this particular relative path but leave it untouched. 

Sometimes when I write objects for holding data (not real DTOs, no serialization involved) I also create an interface for it. The class that implements it can also perform some null checks. I don't always like to use the because you need to remember to call it. Such implementations may look like this: