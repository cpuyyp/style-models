One thing you can do is not let the character travel diagonally when the path crosses the corner of a wall. The character is free to travel diagonally out on the open, but not next to a wall. This is done in your a* algorithm. 

This example probably still needs some tweaking to make it just like you want, but it should get you started. 

The vector between A and B is B - A. The magnitude of this vector is the distance between these points. If point A is traveling along this vector then it has reached point B when the magnitude is 0 and it passes B when the vector components change signs (positive to negative, or negative to positive) as compared to the original B - A vector. For example, in 2D A = (3,4) B = (4, 6) B-A = (1, 2) 

If you know the shape of the piece, and you know where you want to place it, I would assume you have determined the orientation of the piece already. If this is the case then I think the solution is fairly straight forward. You have a default orientation for each piece, and depending on the piece 0-3 possible alternate orientations. The number of rotations left or right are "pre-computed" to match the target orientation. After figuring out how many rotation moves, determine how many spaces to the left or the right you need to move the piece. You can calculate this by using the left-most tile on the piece and the left-most space of the desired location. Finally, the same can be done for the height. From the target orientation, in the starting position, what is the space difference between the lowest tile of the piece and the lowest open space of the desired position. I say "pre-compute", because in my opinion there are too few possible orientations to make a complicated algorithm, and a waste of cycles trying to compute this. If you haven't done it already, it would probably take about 2 minutes to map out each piece and each possible orientation of each piece. For example, the 2x2 block has only one orientation, while the 1x4 bar, and the "s", and "z" shapes all have 2 possible orientations. And the rest of them, the "L", the backwards "L", and the broken plus sign, all have 4 possible orientations. (I think I got them all). 

You'll need to be an "Xbox 360 Registered Developer". It's not as simple as just wanting to do it. There's more information on the Xbox 360 Registered Developer page on Xbox.com. I believe XNA doesn't support Kinect for Xbox 360, you'd need to gain access to a proper devkit and access to the libraries available only to registered developers. If you have an idea you want to pursue, you might find it easier to find an existing approved publisher and get them to help develop your project. 

You seem to be trying to implement the Painters Algorithm. I'm guessing you're trying to write a rasteriser from scratch as a learning exercise, as most modern 3D hardware uses what Bart has mentioned (the Z/Depth buffer). For the painters algorithm to work in all cases, you'd need to be prepared to subdivide the surfaces as they're rendered to solve possible scenarios (such as the overlapping polygon problem shown on the Wikipedia page). By rendering from furthest to closest you're also spending time rendering pixels which will possibly later be occluded by other polygons, which when you start putting textures and complex shaders on the polygons wastes precious cycles. This is the reason modern hardware would prefer you to render from front to back, using the depth buffer to determine if the pixel to be rendered is further away than the one on the screen (and can therefore be discarded). Even with most modern acceleration hardware you'll still need to sort and render from back to front any semi-transparent polygons, rendering this only once all the opaque polygons have been rendered. 

As this has moved to gamedev I'll assume it's game related, despite nothing that alludes to gaming in the question. The usual answer to letting the CPU carry on and do work once you hit a 'Present' is to double/triple buffer the backbuffer, which allows the CPU/GPU to start work on the next frame before the one you've just finished rendering has been displayed (if you didn't double-buffer then you'd be rendering the next frame over the one you'd just finished and would be a mess). The flip then is queued up behind the scenes and the CPU can carry on doing other work. If you don't do much in a frame it's possible you could hit 'Present' again before either of the backbuffers have been displayed and it could block again. Is the question above actually about 'VirtualDub' (as the info there seems to be from 2007), or is it related to making games? I'm still not sure exactly what it is you're trying to achieve or what you want to free the CPU up for prior to the Present occurring. 

One possible solution is to use for while the played is jumping, and for when player stops jumping. Another solution would be to set the player's state to "jumping" when , then during each loop of the game code preform the appropriate movement. Then when happens, switch the player's state to something else. 

It is unclear as to why you are using a perpendicular. There isn't enough detail to describe the problem you are working. However, perhaps this will help. A 2D vector can be described using the values (x, y). The left hand perpendicular and the right hand perpendicular are easily calculated. The left hand perpendicular of (x, y) is (-y, x). The Right hand perpendicular of (x, y) is (y, -x). This can be easily seen with an example. On a grid where positive y is up, and positive x is to the right, a normalized vector pointing up can be written as (0, 1). The left hand perpendicular of (0, 1) is (-1, 0). The Right hand perpendicular of (0, 1) is (1, -0), or (1, 0). 

Probably the easiest way is to alter the A* heuristic. Once a tile has been used in a path, increase the heuristic for this tile so that the next pathfinding call will try to avoid that tile. This will also make the zombies gather around the player. 

I don't know if it is because of a poor component that causes the false readings or a extremely precise component that registers the spinning of the earth, as it orbits the sun, as our solar system spirals through the galaxy. Either way, this is a common problem. The solution is to use some type of filter to smooth out the "extra" readings. There are several methods that you can use. DeadZone - simply track the last "valid" event and compare it to each new accelerometer event . If the difference between the two is greater than an threshold value then count the new reading as a valid event. This is simple to implement, but can make a blocky response since the readings will only move by the threshold value or greater. Low Pass Filter - This works by only allowing a value to change by a percentage(alpha) of the difference between the previous value and the new value. Simply This works well, but might require some tweaking of the alpha to find a value that works well for your needs. A low alpha will give you a consistent value while the device is idle, and a very fluid motion reading, however it will cut down any sharp peaks in movement. A higher alpha will give a more responsive feedback but will not remove all the noise. Infinite Impulse Response filter (IIR) - It works by combining a percentage(alpha) of the previous value with the opposite percentage of the new value. . This can produce similar results as a low pass filter, however the alpha value is just the opposite. In this case, a higher alpha will give you a smoother response and a flatter line, while a lower value will give you a more more responsive result, but also might still have a bit of noise. Rolling Average - Combine the last X number of sensor events and then divide by X. This creates a smooth response while the device is in motion. The few reading averaged the more noise you will see, while the more values that you average the more "sluggish" the response will appear. If you want to try this I would suggest starting with averaging the last 5 value and then go from there. FPS - For lack of a better term, let's call this "frames per second." You can simply only accept a sensor event if a given amount of time has passed thus only allowing so many valid sensor event per second. While this is very easy to implement, I would caution that this can produce a very blocky and sluggish response. To get this method to acceptably quiet any idle time noise there is usually too few readings per second. This causes the blockiness and sluggishness. 

For 2D, Deluxe Paint was pretty popular in those days. For 3D, 3D Studio was around on the PC (eventually becomming Autodesk 3D Studio Max later in it's life). On the Amiga you had Lightwave (which was also used for TV and film). 

I'd recommend reading the Direct3D documentation as it will do a fantastic job at explaining most of your questions. For example, the page on Constant Buffers. Stencil Buffers are described very elequantly on Wikipedia. You only need to create one if you plan on doing operations that involve creating and using masks to control the pixels to apply an operation to (much like a stencil in painting). As with most API calls, the less you can call them the better. Most static resources (i.e. those that don't change during the course of the application running) are created once (for vertex buffers this can also involve populating with the vertices) and then set whenever they're needed. There are dynamic resources (again such as vertex buffers) that you might want to create the resource, but then you may change the contents of on a regular basis (such as for rendering UI or dynamic particles among other things). You might want to change to a different depth buffer if you want to render to a different render target such as a dynamic cubemap, reflection, etc. That last part where you create the InputLayout, you're basically telling D3D where to find the vertex data inside the vertex buffer. You can put whatever you want in the buffer, all D3D asks is you tell it how many bytes it needs to skip to the next vertex and what offset important bits are from the start of the vertex (such as position, normal and texture coordinates). 

The problems that used to require hand rolled assembly are getting fewer in number. What you "might" gain in speed you lose in readability and the ability to debug. It should also be done only as one of the very last optimisation steps on sections of code as in most cases speed problems aren't something that can't be made better with assembly. These days CPU's have gotten much faster while memory speeds have not, often it's more important to control how data flows through the CPU than anything else. With modern compilers they also find it hard to optimise around assembly code as they have to deal with whatever registers you've touched and they can't usually re-order instructions in your hand crafted code. To reduce the need for assembly, there is also now intrinsics which help to get access to low level concepts, but in a way that is compiler friendly and allow them to work with you rather than against. With that said, the SPU on the PS3 is one area where people are still having to use assembly to get the most out of the processor, with manual instruction pipelining for example as explained here. 

Please remember that this is all just about the height field creation. There is no shading of the water or a background texture yet. I have done a lot of research, but I can't find anything that helps me, I am really stuck now! So does anybody know why the waves disappear by them self without damping? 

I want to implement the algorithm for a 2D water surface described here and here. Before somebody finds out, beats me up and deletes this, I'm gonna say it myself. I posted this question over at stackoverflow too. I know cross posting is a terrible thing, but I just found this Game Development Q&A site. My question is closely connected to game development, because I want to use the effect in a game. Also I use SFML, which is a library mostly used for developing games. I think there are more GLSL and graphics experts here, so maybe somebody is able to help me. Again please excuse this. So some background information: I am using SFML and C++. I want to recreate the effect described in the articles above. But instead of using two int arrays and calculating on the CPU I would like to use SFML's 's (FBO's basically) and a GLSL shader to run everything on the GPU. I've made some good progress so far. I was able to set up 3 and ping-pong between them correctly (because other than int array you can't read and write to the same at the same time). I was also able to adapt the algorithm for the height field creation form being in the range -32.767 to 32.767 to the range 0 to 1 (or to be more precise -0.5 to 0.5 for the calculation). Also adding new ripples works to some extend. So up to this point you can actually see a little of waves going on. Here comes my problem now: The waves disappear really, really fast and I don't even apply any damping yet. According to the algorithm the ripples are not stopping if there is no damping applied. It's even the other way around. If I apply "amplification" the waves look close to what you would expect them to look like (but they still disappear without any damping applied to them). My first thought was that this is, because I use float's in range 0 - 1 instead of integers, but I only see this being a problem if multiplication is used, but I only use addition and subtraction. Another idea that a user at stackoverflow suggested was, that I was sampling the texels edges and not their centre, giving me interpolated values and thus creating the unexpected damping, but this turned out to be false as well. Here is my SFML C++ code : 

To make the tile set look good, a basic rule needs to be followed. That is each tile must tile seamlessly with all the tiles it can connect to. Some examples: tiles E, and J must tile with themselves in all directions. Also, the top of tile E must be seamless to the bottom of tiles B, M, and N, while the top of J must be seamless to the bottom of G, H, and I. Tile A's top edge should be seamless to the bottom of J, G H, and I. Tile A's Right edge should be seamless to the left edge of B and C. Tile A's bottom edge should be seamless to the top of D, and G. And finally, tile A's left edge should be seamless to C, F, I, and J. Tile B's left edge should tile with the right edge of A, B, and M. Tile B's right edge should be seamless to the left edge of B, C, and N. Etc, etc, etc. As you can see this is a long tedious list to write out, but at this point I think you can figure the rest out. Creating multiple sets like this you can make some intricate maps. You can have a dirt/grass, and a grass/water tile sets. If you use the same grass tile in both set, you can go from dirt to grass to water seamlessly. This same approach can be used to construct building exteriors, fences, caverns, and mazes. 

Your pathfinding should return a list of way points to reach your objective for each unit. Since you are making a turn based game, I am assuming that the unit movement is like a chess piece. It is either on "this" tile or "that tile, and not in between. If this is the case you might end up with the scenario where a units movements runs out in the middle of the next tile. For example, if you have a unit with a movement of 5 and it needs to travel across 3 tiles each with a movement cost of 2. Clearly the unit has traveled across the first 2 tiles, but what about the third tile? Is the unit stopped on the third tile with 1 point left to go, or since the unit doesn't have enough movement left to traverse the third tile, it is stopped on the second tile and the remaining movement point goes unused. Now what happens if the units movement is 4 and it has to travel across the same 3 tiles. Where does it sit at the end of its turn? Is it on the second tile, or the third? These are game design decisions. Does a unit have to move the full cost to be considered on that tile? Or is the unit considered on a tile if it has spent any movement points in that tile. Also, are all movement points spent each turn, or if the unit can not spend the full cost of movement on the next tile, then the remaining movement points are dumped and the turn ends? If you are allowing a unit to spend all movement points, you can have a variable like which holds the movement units spent on a tile at the end of a turn. So, back to your question, your pathfinding should give you a list of way points, in your case, one tile, after another, leading to the objective. At the start, pull the first way point, after traveling through it, pull the next way point from the list. Do this until you have exhausted your movement points for that unit. Then on the next turn resume where you left off. 

I've not touched DX11, but in the shader you seem to expect sampler 0 to be the diffuse, with sampler 1 to be the normal map. When you set the textures on the C++ side, you seem to have the slots reversed from what I can see. 

Clear() is the only way. To understand why, you need to consider that Direct3D is an abstraction layer itself over the underlying hardware to present a way for you to code against them all. If you dig a little deeper behind the scenes on depth in particular, you start to discover that each manufacturer is free to implement (and therefore optimise) depth as they choose, as long as they adhere to the interface presented. The link here describes a little about some of the different techniques that have been used, it seems to date from 2002 so things will have advanced since then, but it gives you an idea of why they hide the underlying implementation from you. The Wikipedia link on HyperZ here also talks a little about some of the optimisation methods used and the efficiencies they get from them. 

Microsoft makes a lot of effort to not break compatibility between different versions of their operating systems. Windows 7 is widely available and cheap to purchase, the best thing you can do is buy a copy, install it, then see what if anything is broken, then attempt to fix it. If nothings broken, you've nothing to worry about. You could always purchase copies of XP and install them onto the new PC's? 

PIX isn't going to work with non-desktop apps. The new way to debug these is the graphical debugger built into Visual Studio 2012. I'm also not sure PIX works properly on Win 8 for desktop apps either. 

In addition to what Maik said, you'll struggle to find something with the same performance profile as the Xbox 360 CPU. From the public version of the hardware spec on Wikipedia (as the XDK stuff is under NDA) you can see that the CPU is "in-order" execution where most if not all "desktop" CPU's. This one big difference can make a massive difference to the performance profile of the CPU alone, let alone the way all the different systems are hooked together. It completely changes the way the code needs to be optimised because of the way any stalls now affect the speed the CPU executes code. The CPU also includes custom logic for performing vector operations you won't find elsewhere. It's also not as simple as just "having enough money" to buy a devkit. You'll also need to show MS you have a decent enough concept and also probably more discussion before they'd let you licence one.