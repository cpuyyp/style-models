Another name suggestion would be to change to , where default semantically means that it does not belong to something else. Other small remarks are about the horizontal white space, please be consistent there: 

First group the results by their identity, which normally produces a . The trick here is that I also used a downstream , which counts the number of times the string occurs, hence it is called . At this point I have a denoting the word and the number of occurences. It uses a , because this is what returns. Then I obtain a and convert it into a stream. Then I call on the with the reversed comparator. This is done here, because type interference is not strong enough to use . Then I the stream by the top x elements. 

Below is the code to be reviewed, all code including unit tests can be found on my GitHub project page and I'd especially like advice on reducing code duplication. The main file: 

Seperate the CSS from your HTML page, it is already good that you have seperated (most) CSS of the HTML elements, but you want to use an external style sheet, and include that in your page. This makes both parts more clear (tip: Do try to not mix programming languages) and allows you to reuse the stylesheet on multiple pages easily. Use tags where they are applicable. The tags can be reused and should be used multiple times generally, while the tags are for unique elements. This means that and should be a , and not an . Do not secretly sneak in some CSS in your HTML tags. You did it with your label, you should give it an field and reference that in your stylesheet. I would refrain from suppressing warning messages (the ) in PHP, they are usually there for a reason. You are (appereantly) sending the , which should appear in the label, as a GET argument, thus you are receiving user input. In this case it is one that could easily be tampered with, POST arguments can also get tampered, but that is slightly more difficult. You should validate your input there, malicious attackers can try to inject javascript code into it, that will redirect someone to another (evil) page, as one of the examples. 

Onto the Java 8 usage now. It is a good thing that you use the to provide a , you cannot do it much faster either way if you want it to work with any kind of as input and in this way you'll save yourself from nasty bugs and reimplementing what lots of people have already done, namely the grouping by operation. Printing the offending values using Stream seems fine as well, except that you may rewrite it to look a little bit cleaner, something like this could work: 

In general I would never let Reflection do such a task, I would add with the following code, either a public constructor taking all arguments of the object (which you can get from the ), or if there are too many arguments (more than five usually), you can also emply the Builder Pattern. 

I do not fully get what your error handling code does though, there also seems to be logic ongoing which is not neccessary, all I see that you are really using is the method call to . Therefore I suggest to add the following to your class: 

I am wondering if my current unit tests could be written better, I am most interested in whether it is possible to make the code look more concise, as currently it a boiler-plated mess. I have full access to Java 8, if that would help by making it more concise. The class itself: 

Also normally I would create all random numbers with one instance such that you could set a single seed in your program if you want to observe the same behavior. In this case this would be less easy but could still be achieved with a variable like . You should deal with as less static variables as possible, meaning that your static class really should be a instance and that the variable should be local to that instance, ideally you should be able to pass along a scanner by for example doing . In the method you could use as loop condition. In the method you could out of the loop, with the following code: 

This solution also reduces the lines of code used, hence it should in theory be easier to maintain. Use underscores in numeric literals For clarify you might write the following in the method: 

Where the latter would be called once you successfully have obtained the and that one would do the low level job. Conclusion My conclusion still is that the code overall is fine minus the coding style issues, but these improvements would improve it. I think it is also better than a Singleton class, because this to me simply looks like an utility method, hence warranting a place in a class, but I do not see a reason for a Singleton class for this. 

I'm still looking for a nicer way to write , my intention however is to not hardcode the similarly , because it creates a sort of illogical operation precedence, being that you absolutely need to write the case up front, followed by the 3-case and the 5-case (or vica versa). 

The background of this is that this is processed OCR output and I want to force a word to match a certain regex. If it cannot find a match, it should return an empty , otherwise it should return all that match the specified regex. Example: 

In this specific use case this behavior seems to be even more important as obtaining the stack trace is most likely an expensive operation. 

My additional question is whether the filter part can be written more succintly as I'm duplicating code right now while all I need to actually to is dos ome operation on and . 

Your method call is in Dutch and not in camelCase, it should be something like . Lastly, your is not an error, it is an or an , please name your variable like that. 

Problem statement I've tried to solve the following Euler problem in a very straight-forward way, ideally avoiding recursion if possible and writing it in a functional style. 

Furthermore it seems very odd to me that your methods return a . I would just work with s here, as you are not doing an extensive amount of string concatenation. Short guide: 

Normally one would use method references in case of , if had a method, then you would write it as . Upon further inspecting your code I see that you possibly intentionally have made your comparator serializable, if you need that for Apache Spark, then you can do that as well, though the solution does get a fair bit uglier then: 

This is my personal preference on how to format it though, the only real change is to rename to , as it is simply a and nothing more or less. You've done a good job overall. 

Which in turn makes it a lot more readable. There is even another enhancement we can make, that is we can return a containing the name of the Fizzer if and only if it can divide a number, else we return an empty stream. 

The code and documentation look fine in general, so this review will focus on minor optimizations on a per-method basis. Use You can set your with the following: 

Your code looks at first glance quite complete and professional, so onto the points. I hereby assume that you are using Java 7, since you have not made any restrictions and it is the most common version, though I may be wrong. 

It created a that is backed by the . You can set and get elements (and more), but you cannot add or remove elements, as that would modify the backing array in a way that is not allowed. 

Since implementing my Interactive Brainfuck interpreter in Haskell I figured that it would be a good idea to build upon an Abstract Syntax Tree. I have also decided to drop replacing the monad by some other structure for the time being as what I have now works fine, and fast. The code consists of the following: 

The specific question is about the for example, should I there enforce all other conditions which could make a test fail? In this case it would be setting the other monsters on the field, as that might cause the test to fail. Few extra notes: 

Reflection is not the correct way to do this. You will need Serialization for this. Another option is to use XML marshalling and unmarshalling, but I am not so familiar with that. For serialization I suggest you to pick up a copy of Effective Java, and read the last couple of items of the book, which are all about Serialization. You really need to take care of the following, since you are dealing with a game and network: 

The method where the real deal is being done. Here you set up the mappings and convert your data. A tricky fact to observe is that in it has a , which is really of type , hence returns , but since we know that it is of type , we can safely cast it to . I've verified and this code works on Java 6 minus . The code should be called like: 

The design still seems weird to me though, which perhaps now is even more obvious, why does your error recovery method throw an ? Indicating that your error would need recovery again! 

Obtain a . Convert the array to a , this is the starting point of functional programming. Collect the stream in a data structure, here we want to have a . The unoverloaded version of groups elements on a certain property, here it is . The caveat with the default version is that it returns a whereas we want a . So we need to supply a argument to the method, which in this case becomes a downstream collector. 

I'm learning Clojure and solved Project Euler #1, I'd like to have my code reviewed on all aspects and have one specific question. This is also my first Functional Programming language, I have however used some form of FP in Java and Python before. Task: Multiples of 3 and 5 

For this you might need to implement yourself, I cannot tell if that is possible. That leads to the end of the review, unfortunately I am only able to touch the basic concepts and not the low level concurrency stuff as I consider myself not experienced enough to give advice upon that yet. 

I decided to take on the FizzBuzz challenge with as twist that I would use Java 8 concepts to make it a bit modular, yet still let it be a short, readable and understandable program. This in contrary to some gem I found on the net: FizzBuzzEnterpriseEdition The problem description: 

I have tried to mimic as much as possible, it for example has a resp method that return slices () to the original vector, the following types are available in this library: 

I'll go with the second option as this is the most straight forward one, but you should really look into this. Our first revised code will look like this: 

My project here works upon output that comes out of a Tesseract OCR scan using hOCR format, then I read it with JDOM 2.0 and finally save it one of my own objects, which at a later point needs to be serializable. I have spotted one major codesmell, which is a for-loop of 5 levels deep. An example hOCR output file: 

In the implementation every card gets mapped to an in our Entity-Component Framework, however that is to be considered an implementation detail and is not the intended focus of this review. This code is also accompanied with tests, but as there are lots of tests, they require Entity-Component Framework knowledge and are all accompanied with their own XML file, they are also not included. You can review all code at our Github project page on the develop branch and the tests can be found here. Then now follows the implementation code: CardLoadingException class 

I decided to roll out my own EventBus system which is intended to be thread-safe. Hence a review should focus extra on thread safety apart from all regular concerns. The can work in two ways: 

I have created a tool that lets me calculate the profitability of doing certain actions in an MMORPG game which I play, it's more edging towards a quick-and-dirty solution than towards a neat solution because it's simply a tool and does not need excessive robustness, however I do think there is room for improvements. I'd like a review on all aspects, first I'll start of by explaining what it is really about as some domain knowledge is required. Domain knowledge This tool focuses on items of 29 Defensive Rating (DR) as input and it is all about upgrading the items, ultimately the goal is to produce a 32 DR item, which can be sold for a fair amount of money. The item comes with an upgrade of level 0, and for these practices it needs to be upgraded to level 7, though it can be upgraded beyond in the game, here is a table with characteristics: 

You should use the method, you want to use the generic method, so not the one returning , for this to work you need to supply an array of the correct size, such that it can store the data there. 

Here you can see, that because of four regex replaces, you create four times a , which is synchronized, and a object, which can count up if you are processing tons of tweets. There are two things you can do: 

Just a quick observation I have made here, and this is by no means a full review, but you have some dead code here: 

An example implementation can be observed in the following snippet of the test code to load in a file with two cards: 

I don't think it's really readable, as it conveys a lot of logic, which is simply unneeded. Also you should, according to most of the common Java coding standards, not be placing on its newline, also there should be no blank space between and in I would suggest following, though it needs Java 8: 

As others have pointed out the most obvious improvements already, I would like to talk about Java 8. Maybe you cannot use it yet, but I would recommend looking into it and this answer should proivde useful for anyone reading this. My main focus point here will be designing the code such that it will logically do what it is supposed to do. You have a method in which you take a as argument, and you want to return the top x occurences, that is all you want, in order that means: 

Use , as the array may be of any type and you cannot use generics with arrays. Check if the is not null. The code would have thrown the exception either way if , but I think it is better to throw them upfront. Wrap the in a to convert it to a . 

For this it also holds that should be changed to if possible. You can now get the values with versus the old (Small note: I barely use Java 6, so hopefully I have not accidentally used a Java 7/8 feature) 

My goal with the following code is to provide an extensible class that can be extended in order to read log files and transforms them into meaningful output. I'd like to have comments about the code itself, the test code, the javadoc and the overall structure. 

Their purpose is to provide similar functionality as the method, but then allowing that the mapped type differs from the original type. Hence it is something that should be in a factory class, as it will always need to create a new collection. Some example code: 

I'd say there is no reason to add them, it can even create confusion as now I start to think about the reason of the blanks, this is more clear: 

I'd like to have a general review with extra focus on how to be able to support as many input variations and locales as possible. This type of problem also has some practical issues you will only find out when practicing by solving this problem, so I strongly encourage you to review this code with an IDE at hand to be able to test alternative suggestions.