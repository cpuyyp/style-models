You would most likely use TCP sockets which allows for reliable messaging. My pigpio Python module does this for you. 

If you have some resistors you could form a voltage divider to drop the USB 5 volts to a Pi GPIO safe 3.3 volts. Any resistors with a ratio of 2 to 1 should be fine (for a perfect drop from 5 volts to 3.3 volts), or any pair of resistors with the same value should work (to drop from 5 volts to 2.5 volts). 

I suggest the first thing to do is check to see if the GPIO are still working. Remove the screen. Then run either my gpiotest (requires pigpio) or wiringPi's pintest (requires wiringPi). 

You will almost certainly need to use 5V for any sort of distance. From an AM2302 pdf (Special instructions of the single bus communication) 

I haven't noticed any problems. I'm not sure how long I've been using stretch/sid (I just have testing in my /etc/apt/sources.list). 

All the boot files are on a FAT32 sector, which is readable and writeable by all common operating systems. You can place the SD card in an SD card reader, delete the bad kernel, and rename the good kernel from any Windows, or Mac, or Linux machine. 

Perhaps verify the operation of the PIR first. Here is a cut-down version which works with my PIR on GPIO 4 (pin 7). 

The system can use the serial link as a console to allow remote logins and may print system messages during boot. Check that you have disabled these features (perhaps by using rsaspi-config). 

It should be compatible with all the existing Pi software but will also be usable with WIndows 10 and more modern Linux distributions such as the latest Ubuntu. For strike out text reason see second edit. Until it gets on the streets we're all in the dark. 

The library you based your examples on is a user land library (like my pigpio and wiringPi). The Memory Management Unit (MMU) maps the peripherals to a base address of 0x7E000000 for the kernel (not 0x2000000 as used in user land). 

Provided your kernel supports device tree you just need in . That should let the RTC work as it is accessed through the kernel. If you want to access I2C devices from userland then you need in and i2c-dev in . Make sure is not in . Device tree will automatically load (it will not load ). 

The Pi3 has only two accessible GPIO (14/15) which may be used as a UART and provide one serial link. You can use other GPIO as a software UART if you know how to write software and are pretty competent doing so. The alternative is to use serial to USB dongles. 

The Python smbus module limits itself to SMBus commands which have a 32 byte limit. You could bit bang or you could use the underlying /dev/i2c-1 device from Python. You should be able to find examples of both on the www. My pigpio Python module implements I2C as well as SMBus commands. 

You can use device tree to add additional I2C buses on spare GPIO. See for details. You need 2 GPIO per bus, one for SDA and one for SCL. 

I don't think removing modules will make any measurable difference in performance. Why not boot a Pi and leave it running for 24 hours. Then do a ps -aux (or whatever) to get the time used by each process. Perhaps something will stand out that you don't need. 

That means there are at most 5 positional updates per second. If you change 0.2 to 0.02 you will get up to 50 updates per second which will make your RC device more responsive. 

Possibly. If the gpio is at logic 1 it is already at 3V3 so there will be no difference. If the gpio is at logic 0 it is at ground and connecting 3V3 will in effect be a short-circuit. That can kill the gpio and or bank of gpios and or the Pi (unless an appropriate current limiting resistor is in place). 

This is almost identical to your previous question. You probably should have edited that rather than asking a new question. You need the bscXfer to be within the while loop. That is how the xfer structure is updated with new information. 

This is what the MCP3008 sees if you send 0x01, 0x80, 0x00. Note the position of the data in the returned bytes. 

The only problem I can see with the code is that it terminates straight away. When the program ends the pigpio library will shut down so servo pulses will stop. I suggest you add a time_sleep(10) or so to see the servo move. Here is a longer example. Change the 0 at the end of each line of servoInf to 1 if a GPIO is connected to a servo. 

You need to use hardware timed pulses for servos. Software timed pulses will lead to jitter and a shorter servo lifetime. Try pigpio, servoblaster, RPIO.GPIO, or similar which use hardware timed pulses. 

Your information is wrong. Linux automatically makes use of all cores. Any program which uses threads would automatically have threads running on any available core. 

You have not told the script to continue running. From the terminal it will run the script commands then stop. Presumably in the Thonny IDE the script does not shut down properly. Add something like a after the print statement to let the script run for 60 seconds. 

I wrote some code for my pigpio library. I posted the code as an answer to a similar question. It was tested between a PiB and Pi3B. It requires the pigpio library and the pigpio daemon to be running. Both are installed in recent Raspbian images. 

I don't know if the internal pull-ups are connected when the gpio is set as an OUTPUT. I don't know how to find out. For the sake of argument assume they are. Each pull-up/down is of the order of 50k+. So at most 3300mV/50000R or 0.066mA will flow per gpio. For 24 gpios that gives a total of 1.584mA. For the two I2C gpios with hard wired 1k8 resistor pull-ups to 3V3 each one will use 1.83mA, so 3.67mA for both. See $URL$ 

Normally you write a program to talk to the serial link or use something like minicom to debug. If this doesn't help could you edit your question and show the result of 

For help with NOOBS and config.txt see $URL$ config.txt settings are shown in $URL$ Add one of the following settings to /boot/config.txt and reboot. 

An alernative might be to run the pigpio daemon and then use its socket or pipe interface. The pipe interface is the simplest if your program is running locally. To use PWM it is as simple as writing to a file (/dev/pigpio). E.g. to start PWM on GPIO 4 at 50% dutycycle write "p 4 128\n" to /dev/pigpio. The newline character (\n) is needed, as commands will be buffered until a newline is given. 

Why not get it from the repositories? I would always do that when possible rather than downloading from a third party site. 

The under load Pi3B+ figure of 5.6 watts is 1.12 amps. So you only need just over an amp to power a loaded Pi3B+. My unloaded Pi3B+ is currently running powered from one of my laptop USB slots. The rest of the 2.5 amp is an allowance for power hungry devices connected to the Pi (e.g. to the Pi's USB sockets). If you don't have such devices your power supply should be fine. 

All the compute module Gerbers are available at $URL$ I assume what you need is somewhere among the zip. 

Possibly. It depends on the model of servo hat you have bought. Does it allow you to plug in jumper wires? If so try my $URL$ If not just drive your servo using my library and use the above linked software. 

I don't think you are missing anything. The problem is pretty much a mechanical one, how do you connect to GPIO not been used by the HAT. If the HAT is a permanent addition you could just solder to the pads on the HAT. If not you could use an adapter block with long pins between the Pi and the HAT and connect jumper wires to the pins. Alternatively you could solder wires to the pins on the underside of the Pi. 

In this case I suspect 1. will work as I expect the weak (50k) internal pulls are not good enough for the I2C bus. 

You could use a ram disk if the point is to stop SD card wear and tear. E.g. sudo mkdir /ram # create mount point (a one off command) sudo mount -osize=100m tmpfs /ram -t tmpfs # create ram disk at each boot This will create a 100 MB ram disk accessible at /ram. Save your photos to /ram, upload, delete. No SD card wear and tear. 

EDITED TO ADD I was wrong to suggest that Windows 10 or Ubuntu will work on the Pi 2. There will be no support for the desktop versions. What is being touted is Internet of Things versions which are CLI (Command Line Interface) based and are aimed a servers. 

I haven't looked at the code carefully but spidev and the BCM2835 library are both known to work. Are you sure the connections are correct? You need to connect MOSI/MISO/SCLK and one of CE0/CE1 plus ground at the Pi end. Unlike most Arduinos the Pi's gpios are 3.3V. Feeding anything over 3.3V to a gpio will destroy it sooner or later There are other libraries such as wiringPi (C but there is an associated Python module) which also have SPI wrappers. My pigpio library also has C and Python wrappers. It also lets you talk to a SPI device from the command line using the pigs utility (pigs spio, spix, spic) 

The board revision is 0010 (this is a hex number, so 16 decimal). The CPU revision is irrelevant. $URL$ maintains a list gives details (including RAM fitted) for each known board revision. 

Impossible to answer without seeing a photo of your setup. Clearly something was holding MISO high during your first test which is why all 1s were returned. During your second test nothing was pulling MISO high and the default internal pull-downs kept the level low to return all 0s. 

If you are using Python 2 type idle in a command window. If you are using Python 3 type idle3 in a command window. If you are using a GUI there should be shortcuts to IDLE and IDLE3 on screen. 

The circuit as shown will not work as there is no common voltage reference between the SIM and the Pi. You need to connect a Pi ground to either the SIM ground or to the battery ground (-ve terminal). 

From $URL$ Debian always has at least three releases in active maintenance: "stable", "testing" and "unstable". stable The "stable" distribution contains the latest officially released distribution of Debian. This is the production release of Debian, the one which we primarily recommend using. The current "stable" distribution of Debian is version 8, codenamed jessie. It was initially released as version 8 on April 25th, 2015 and its latest update, version 8.7, was released on January 14th, 2017. testing The "testing" distribution contains packages that haven't been accepted into a "stable" release yet, but they are in the queue for that. The main advantage of using this distribution is that it has more recent versions of software. See the Debian FAQ for more information on what is "testing" and how it becomes "stable". The current "testing" distribution is stretch. unstable The "unstable" distribution is where active development of Debian occurs. Generally, this distribution is run by developers and those who like to live on the edge. The "unstable" distribution is always called sid.