In terms of weapons and gear and crafting, you can apply the same concepts... Looking at WoW and Diablo II, the kings of gear-grubbing (great retention-rates, too). Instead of making gear have class-requirements ("only druids can wear this pair of gloves"), have gear be based on: a) stat-requirements ("Boots of Sneaking [req: sneak <= 50%]") b) att-requirements ("Goggles of Grokking [req: INT <= 7]") c) story-requirements ("Sword of Swords [req: 'Quest of Awesomeness' -- must have DEX > 4 STR > 7 to begin quest]") If you put an item-crafting element into the game, from there, you should be able to auto-generate stat/att requirements, based on, say, the components used to make the item (or used to enchant/patch the item), their quantity, if they have different potencies, et cetera. Now you have gear that ANYBODY can use...... IF THEY HAVE THE ABILITY TO USE IT, or let them use it anyway, but apply a penalty to misuse. Give everybody the ability to use a minigun, but if they don't meet the strength requirement, then slow their movement speed by units of movement per turn (or a multiplier, depending on what a move-unit might look like in your game). Give everybody the opportunity to use a sniper rifle, but without high perception and agility, make it impossible to hit anything... The point of the whole thing is that if you want to foster replayability with characters who are unique, then you want to limit what each character is allowed to do. Therefore, each character with different skill-sets will have different advantages and disadvantages. Just be sure to spend a lot of time balancing them, and make sure that every major quest point is solvable in at least 3 or 4 different ways, based on characters who MUST play to match their skills, and make side-quests accessable in only 1 or 2 or 3 ways: Not every character needs to access all content, and instead of thinking about adding class-specific stuff, think about removing access to things based on character-weaknesses. 

You can build the soldier, give him an equip method, where you hand him a weapon, and THEN call all of the rest of the constructor functions. So now, instead of subclassing enemies where one soldier has a pistol and another has a rifle and another has a shotgun, and that's the only difference, you can just say: 

might get passed a filename, or a resource name or whatever, load that resource -- maybe it loads sound files, or image data, or maybe it loads saved character stats... ...and then it would feed that data back into . This sort of dynamic is found frequently in web-apps. Not necessarily in an object's construction, for higher-level applications: for example, galleries might load and initialize right away, and then display photos as they stream in -- that's not really an async-initialization, but where it's seen more frequently would be in JavaScript libraries. One module might depend on another, and so the initialization of that module might be deferred until the loading of the dependants is complete. In terms of game-specific instances of this, consider an actual class. Why can't we call or in the constructor? Resources need to be loaded -- the rest of everything has pretty much been defined and is good to go, but if we try running the game without a database-connection, or without textures or models or sounds or levels, it's not going to be a particularly interesting game... ...so what, then is the difference between what we see of a typical , except that we give its "go ahead" method a name which is more interesting than (or conversely, break the initialization even further apart, to separate loading, setting up the things which have been loaded, and running the program when everything has been set up). 

...have your constructor do little or nothing at all, and write a method called or , which would do what your constructor would normally do. 

I've got a system in place which says "while the game is running, check the current time - if it's greater than our running framerate tally, and we've skipped drawing fewer than 5 frames, then skip drawing and just update input and physics: else draw the scene and start the next update iteration" When each update happens, you increment the "next_frame" time by your ideal framerate. Then you check your time again. If your current time is now less than when the next_frame should be updated, then you skip over the update and draw what you've got. If your current_time is greater (imagine that the last draw process took a really long time, because there was some hiccup somewhere, or a bunch of garbage-collection in a managed language, or a managed-memory implementation in C++ or whatever), then draw gets skipped and the gets updated with another extra frame worth of time, until either the updates catch up to where we should be on the clock, or we've skipped drawing enough frames that we absolutely MUST draw one, so the player can see what they're doing. If your machine is super-fast or your game is super-simple, then might be less than frequently, which means that you are not updating during those points. That's where the interpolation comes in. Likewise, you could have a separate bool, declared outside of the loops, to declare "dirty" space. Inside of the update loop, you'd set , signifying that you've actually performed an update. Then, instead of just calling , you'd say: 

It's a fair fight. Even better, when they get rid of their sicknesses, they'll go back to the same health -- removing an int is simple, but removing a fraction, you convert it to an int based on the current baseline (or float, if you're doing that) and subtract that number. Just remember that whenever you add an int-bonus, that changes the baseline for the stat, so recompute the fractions, as well. When you add a fraction, the baseline stays the same. There's also nothing saying this can't be 100% OOP or Entity/Component-based. This is just the basic concept for arriving at how to have both and in the same game, and have it be fair. 

If you're dealing with small games, this is somewhat inconsequential, as a finished game is better than a well-engineered game. That said, if you're already finding yourself wishing that you could switch back and forth between screens, or set an option on one screen which propagates to another screen, afterwards, then I'd suggest looking into something like a pattern. The idea is that you have one system-wide object (or domain-wide object), which can be called by all members of that system/domain. You can to this object. When that happens, you register a method or a function to use as a callback, to act on parameters passed in with the notification. 

Based on your updates, I'd consider the following: 1) use a tap, and have the tactic to be to throw the ball to the location of the tap, using the movement of the character and the placement of the tap (the trajectory of the ball) to try to deke the defender 2) use a joystick for movement and use a swipe (/"fling") to throw, which will make accuracy much harder, but will also offer speed as well as vector, based on the swipe. If you go that route, though, you need to: a) provide instruction -- it's not intuitive to an end-user at all, so you need to provide visual queues/tutorials to get the player started (an important and often-overlooked part of modern game design) b) be forgiving in aim/defense, and allow for people to cancel out of a throw. 

Then you're missing out on any interpolation for smooth motion, but you're ensuring that you're only updating when you've got updates actually happening (rather than interpolations between states). If you're brave, there's an article called "Fix Your Timestep!" by GafferOnGames. It approaches the problem slightly differently, but I consider it a prettier solution which does mostly the same thing (depending on your language's features, and how much you care about your game's physics calculations). 

1) giving JS end-users direct access to your terminal is the scariest idea ever, in terms of security, and is 100% impossible without some interfacing server language/framework (php/perl/ruby/c#/python/java/c++/NodeJS), because it is so scary. 2) running on user-input, directly, rather than building an interface in your server language is 100% as scary as giving them access to Apache itself. 3) what you want to do is build out a simple facade/proxy/whatever in your language, for playing the game. That proxy should take user-input and decide what the user wanted to do (what piece is moving where), and based on those parameters, feed Crafty hard-coded or php-generated parameters (and not the direct-input). This allows safety, first, but also allows you to build your communication strings any way you want, as long as the php and client agree on format. 4) on compatible browsers, you can run websockets -- the standard is volatile right now, but there are some libraries out there which can swap between websocket, flash and old-school XMLHttpRequests ("AJAX"). For a 100% native, backwards-compatible experience, just use AJAX, and poll the server either on a user-move or asking for Crafty's update. In fact, if the user goes first, every time, then you can just respond to their request with Crafty's next move. Next -- cheating: Don't update the game based on what the user sends you, take what the user sends you and validate that the unit at that position (according to the server) is allowed to move in that fashion, and if not, return an error or exception which the client machine then has to deal with (reverting the move, showing an error, and making the player move again) I should probably add that if Crafty has a decent error-handling output (eg: it outputs what was moved where and why it's wrong, in a consistent format), then your PHP interface can lean on that to handle validation. PHP would then figure out what the user meant to do, based on the input parameters, feed a prepared statement into Crafty, and read the result -- if the result succeeded, then get Crafty's turn and feed it back to the player's response, in the format you built for communicating between client and server. If it failed, then figure out why, and send that back to the client in an agreed-upon fashion (agreed via PHP and JS), so that your client-side app can handle the error and reset the player's turn. Oh. Also, if you're looking to allow multiple users to play against the same instance of Crafty, or multiple instances of Crafty, or whatever, then I'd suggest a data-storage format, where you can store instances of the game-state by session-id, or by REST-based client-id, or whatever. JSON could be seriously lightweight for that, in this case. I won't tell you HOW to structure these things, but from a "don't hack my server and delete my c:/ drive" and a "don't move three times in a row, or teleport your queen to an insta-checkmate, or move any of MY pieces, instead of yours" standpoint, these are the key points you need to address. 

I believe the correct answer to be 100% both. Based on how you've implemented it, you're going to want to do one or more of a few things: First, I think it's a big deal that you present your game artistically and in a meaningful way. I would never argue with that requirement. If the best way to do that, at various points of the story is through text, then do it exactly that way. At the same time, never prevent a user from speeding through your presentation, either. If somebody is so excited by your gameplay that they'd rather burn through the cutscenes and read a synopsis or read it on a second playthrough, because they just want to go back to being awesome, then you should let them do that, as well. Depending on the game, I'm totally both. I'll still watch every cutscene in Anachronox or every talking head in Fallout 1... ...but how annoying is it when you just want to auto-skip the 5-minute cutscenes in Max Payne 3, to get back to mowing down half of Brazil? So the solution might be to do something like this: 

So now we've got this really unbalanced fight between these two characters who have done the exact same things, other than the order of picking up buffs. How do we fix this? Break your integer and fractional stats into two groups. Add the integers. Then take the final integer and use that as the basis for calculating your fractions. 

TL:DR -- if you're thinking about stuffing hundreds or thousands of abilities into a list/array that you'd then iterate through, every time there's an action called, to see if the action exists and if there's a character who can perform it, then read below. If not, then don't worry about it. If you're talking about 6 characters/character-types and maybe 30 abilities, then it's really not going to matter what you do, because the overhead of managing complexities might actually require more code and more processing than just dumping everything in a pile and sorting... Which is exactly why @eBusiness suggests that you're unlikely to see performance issues during event-dispatch, because unless you're trying really hard to do so, there's not a lot of overwhelming work here, compared to transforming the position of 3-million vertices on-screen, etc... Also, this is not the solution, but rather a solution for managing larger sets of similar issues... But... It all comes down to how big you're making the game, how many characters share the same skills, how many different characters/different skills there are, right? Having the skills be components of the character, but having them register/unregister from a command-interface as characters join or leave your control (or get knocked out/etc) still makes sense, in a very StarCraft sort of way, with hotkeys and the command card. I've had very, very little experience with Unity's scripting, but I'm very comfortable with JavaScript as a language. If they allow it, why not have that list be a simple object: 

Same deal with destruction. If you have special needs (removing event listeners, removing instances from arrays/whatever structures you're working with, etc), you would then manually call them, so that you know exactly when and where in the program that was happening. EDIT 

As Kryotan has pointed out, below, this answers the original post's "How", but doesn't really do a good job of a "Why". As you can probably see in the answer above, there might not be much of a difference between: 

Both of these are horrible pseudocode hacks and not exactly indicative of the final product, but hopefully provide consideration of how you might want to address the abstract concepts of playing the boardgame in terms of your code. In terms of common issues, are you planning on animating pieces as they move? If so, you might want pieces to control their own state. Another consideration might be to "bind" and "unbind" pieces from squares. Give the pieces a simple, loosely-coupled interface for querying the square they're in and/or the square they're moving to. Your board could talk 100% in grid-coordinates (making rule-keeping easier, depending on the game), then the pieces could use those grid-coordinates to enforce rules, AND to request a connection to talk to their new grid square (dropping the connection to the previous square). Most of the positioning logic for drawing, et cetera, could be held within a piece, which just needs to take the grid-coordinates and position itself inside the center of the grid square (when it's done animating). At this point, pieces and squares could be put in separate arrays and updated separately, even. Pieces would control their logic/presentation based on the grid coordinates they're given by the squares they're talking to. Squares could maintain any bonuses that they might hold (snakes/triple-word-score/go directly to jail), and confer those to a piece, if the square believes that the rule is appropriate to that piece at that time (eg: go-to-jail/jail + just-visiting). Note that this isn't THE way to do things. In fact, it might be way over-engineered for your needs. Or under-engineered. Or it might just look like nonsense, because you'd really like to write the code from the perspective of the player who rolls dice/picks up a card/etc and manually moves a piece, versus a piece which moves itself or a board which pushes a piece around. 

Typically, when you're talking about stat-management, there are a million ways to accomplish what you're looking to do, but also probably a few established techniques which are widespread. Consider two players in PvP: Their stats/levels are the same - they each have 20STR, and HP is based on STR * 10, Damage is STR * 2. Also assume we're using an old school system, where current max_health and max_damage are caps which can be lowered when poisoned/cold, et cetera. Lastly, consider division by X to be multiplication by 1/X. Olag_the_Serious picked up a +15 strength amulet and then got sick. Jimmy_the_Geek got sick, but then picked up a +15 strength amulet. Then they fight. Olag's stats: