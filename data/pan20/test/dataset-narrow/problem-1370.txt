First of all, in the case of axis-aligned rectangles, Kevin Reid's answer is the best and the algorithm is the fastest. Second, for simple shapes, use relative velocities (as seen below) and the separating axis theorem for collision detection. It will tell you whether a collision happens in the case of linear motion (no rotation). And if there's rotation, you need a small timestep for it to be precise. Now, to answer the question: 

I can't say I've played all puzzle games in existence, let alone all games with puzzles in them. But I only remember one about whose puzzles one could say they were all always placed at the one and only appropriate point in the narrative and that they contributed immensely to it. What I mean is that when the designers of most games insert puzzles (or rather, "specific gameplay sequences") at certain points in their story, their goal is to challenge the player. And that's it. Maybe because the story requires it at that specific point in the game, maybe because it gives the gameplay rhythm. Take Half-Life 2, for example, and give me one example of a puzzle (you know, the physics ones) at some point in the game which couldn't have been replaced with another one, due to the story requiring that specific type of gameplay at that specific time. I know that in the latter half of the game, the puzzles require the Gravity Gun and can't be done without it, but the gameplay is pretty much the same: grab->put down, grab->throw. The same applies to almost all games, where the aim of a given bit of gameplay is always either to give the player a gameplay bonus or to allow them to move on in the story or more rarely, as in Deus Ex: HR or LA: Noire, to reveal more about the depths of ths story. On the other hand, in Braid, the gameplay and "story" are tightly interwoven. The first chapter is supposed to be "forgiving" and about innocence and so is the gameplay. The chapter with the ring is about finding comfort in the presence of someone dear, all the while knowing that their companionship is a burden (to someone as ambitious and driven as Tim), and the gameplay is a perfect translation of that. The same applies to the other levels and even to the epilogue. Jon Blow himself said about his game design experience with Braid that it was like sitting in a gold mine and scooping nuggets of gameplay, examining them from all angles (or something along those lines, was it in Indie Game: The Movie?). That's the phase you're currently going through, it looks like. So I what I would do if I were in your case, where you have a unique idea and you'd rather sit in the gold mine and scoop nuggets than write a story, is do precisely that, do this job of scooping as many gameplay nuggets as you can. Once you have something to say, a message to shout out, then you'll write a story with these two constraints: the message and the gameplay. They will be unrelated enough that the story can accommodate them both. Take, for example, this painting (the medium) that depicts an old Middle-Eastern king killing his servants, horses and dogs, bringing his world down with him as he is losing a battle and his palace is assaulted (the story). It's about grandiose decadence and egotism (the message). We could imagine lots of different works of art with the same message. For example, imagine a scene in a movie about a corporate CEO who in the end burns entire bags of bank notes in his condo as the tax administration/feds/IRS/what have you are after him. You can always write a story that adapts to your medium and message of choice. Edit to answer the asker's comments: So you have a gameplay you like as well as a story you like. You would like to develop both further, but doing so would mean having to make sacrifices on the gameplay end or on the story end when comes the time to merge it all into an actual game. One solution could be to work on the story first and use it as a constraint for the gameplay, which would only serve as the medium for it and, in your creative process, would always come second. Another solution, the converse of the first, is possible, where you find as many variations on your gameplay as you can and then see what can be done with it it terms of storytelling, hoping that you can build your original story around these gameplay elements. All this cranking of constraints into others looks painful. What I'm suggesting is that you take a good look at your story and try to pinpoint exactly what makes you like it in the first place. What, in its substance, makes you want to tell it. Extract that substance, forget about the details of the story like the setting, the names of the characters, their looks, the duration of the story, forget that it's about human beings (it could be about animals!), forget all of this and look at its substance, its deeper message, somewhat like I did (or tried doing) for the Death of Sardanapal painting linked to above. Then, I assure you that you will never have the slightest bit of worry regarding cranking the story and the gameplay together. You will find the story that makes use of the gameplay to convey the message. I personally believe that that is what matters the most. So scoop those gameplay nuggets. By the way, this is not how Jon Blow thinks we should make games, because this disconnects the message from the gameplay. If, like him, you can create an experience that is contained within the gameplay and have the player extract the message himself from that experience, that's also extremely cool. 

If you use GameCenter's built-in leaderboard functionality to avoid having to implement leaderboards yourself, then you end up with seperate leaderboards when you make your Android version. For me, it's a decision that goes like this: "I don't want to reimplement a leaderboard server just so I can have cross-platform leaderboards." 

We have two main subclasses of GameInfo for the two game types we have. I'm wondering if it's possible to get one of these to read a different .ini file because we'd like to move a few of the controls to different buttons for that mode. It looks to me like it's just going to read Input.ini for this, regardless of the game type. 

You should be working in world coordinates, not pixel coordinates. For example, in a Unity project, I might have a world 100 units across, and the speed is 1 unit per second. It takes 100 seconds to cross the screen. The engine takes care of worrying how many pixels per frame that is. On a related note, you don't move a certain distance per frame. You check the "delta time" of the current frame, and adjust the speed for how long the frame takes in order to keep the speed consistent regardless of the frame rate. 

Put the profiler on it. Try a huge sheet and a small one. Measure the difference. This is the very best way to answer these questions, since you don't want opinions: you want answers. Doing this test yourself is the best way to get an answer, since it will be for your actual use case. 

Trying to tackle solid mechanics are we? First let me clear up a bit of your confusion regarding various concepts of Newtonian mechanics: 

Make two separate vertices. Make a circle around one of the vertices (the base vertex), that is within a plane perpendicular to the segment between the first two vertices. Hopefully you can make a circle using trigonometry, right? That's already all of the vertices of the cone. That's also one third of all the edges (there are n edges in the circle and 3n in total). Make n edges from the base vertex to the n vertices in the circle. You can make one half of the faces (that's n faces) as you do that. Make n edges from the tip vertex to the n vertices in the circle. You can make the other half of the faces (that's n faces) as you do that. 

A collision can occur only if it is possible that the bounding circle of A meet that of B. We see here that it won't, and the way to tell the computer that is to compute the distance from CB to I as in the following picture and make sure it's bigger than the sum of the radii of A and B. If it's bigger, no collision. If it's smaller, then collision. 

The whole point, and the best part, is this: you know that your solutions to the problem (H(a) and d(a)) obey the specifications (n(a)), so you get the same n(a), but you have freedom. You know exactly the freedom you have, and you can use it to customize the experience. You should always try to give yourself such freedom while satisfying your most important needs, whenever possible. Now that we've chosen the one-hit damage d(a), and since d(a) depends on the weapon damage w(a), we can use d(a) as our specification and try to find a w(a) that gives us this d(a). The principles are the same, the problem is different: we want the player to cause more damage as his level increases, even with the weapon remaining the same, and we also want the damage to increase when the weapon alone gets better and the level stays the same. But what importance should each factor have? Suppose we want level to be more important than weapons: a bigger part of the variations of d(a) = a² should be independent from w(a), for example with w(a) = 22.sqrt(a)    and, therefore,    d(a) = ( 22.sqrt(a) ) . ( 10/22.a.sqrt(a) ) = w(a).( 10/22.a.sqrt(a) ) We get the following graph for w(a)... 

If your player has access to a load of different ways to move, they will learn to combine them in weird ways to get through the level in new ways. Check out stuff like Quake Done Quick to see this in action. 

Not really, no. Given what you are trying to do, your code looks OK to me. Anything is possible really, but it would be pretty convoluted and ultimately be a silly thing to do. :) 

So you just have to do some editing of UnityAppController.mm after you build the project. If you do "Append" it will leave your edits in place. 

Your TryToCreateNewMiner function can call it again. If your RandomPercent calculator keeps returning true, the callstack gets deeper and deeper. TryToCreateNewMiner->Miner->StartDigging->TryToCreateNewMiner 

Ok, I think I have it. Set the Canvas to use "Expand". No messing around with text box sizes or anchors, it just seems to work. To be absolutely clear, I am still using the Aspect Ratio Fitter to force my Panel to maintain its aspect ratio, and it's set to Fit In Parent, which is the Canvas, and that is always the size of the screen. 

This, as far as I can tell, takes the ground normal, rotates it around the y-axis so that it shows the proper perspective given the camera's facing. Then it tells that parent object to look in that direction, which aligns its z-axis with the rotated ground normal. This works, except the object I have also rotates around the y-axis depending on the orientation of the camera. I thought that I was throwing that information away in the second step by keeping only a Vector3 aligned with the ground normal rotated for the camera position. So I want this: 

The answer provided by Grzegorz Sławecki is already a good one, but I wanted to explain the rationale behind his method and give you the tools to adapt the solutions to your gameplay needs. The parameters of the present problem are the player's attack level a, weapon damage w, the total inflicted damage in one attack d, the enemy's health H and the minimum number of hits necessary to kill the enemy, let's call it n. If you want the player to kill in n hits, then his total damage d must be such that (n-1).d < H &leq; n.d    or in other words, n = ceil(H/d). d depends on weapon damage w and on the player's attack level a and we can expect weapons to get better as the level increases, so let's write d(a) and w(a) instead of simply d and w. The enemies the player faces are also expected to get tougher so, again, H(a). These are all increasing functions of a, and you want them to satisfy the above inequations. The unknowns of the problem are functions. You set one as a constraint, and you find the others. You do have degrees of freedom though, which is a good thing. If I understand your question well, you have a precise gameplay in mind, and this gameplay is mainly represented here by the number of hits required to kill the enemy, n(a). Therefore, set n(a) depending on the gameplay you envision for the game and then find the rest of the variables of the problem. This is what you should always do because, as your question shows, your first attempt was to try an algorithm you thought may do and then realized it resulted in undesired gameplay. Let's suppose, for instance, that you want the player to have to hit more and more times as he progresses in the game. You also want that, as the required number of hits increases, it increases less and less often, so that the player spends a longer part of the game hitting 5 times than 2 times. Here's what n(a) looks like: 

This code does not do what you think. It gets a new value when it does the Debug.Log, because the randomizer is called again. You want 

It is highly not recommended to make an iPad game without a device. The simulator is decent, but some things cannot be tested properly on it. For example, In App Purchases cannot be tested without a device. And believe me, you want to test those things. You also won't get much of an idea of its performance on the simulator since it may run much faster or much slower than a device, depending on your host system's specs. 

Getting legal advice on GameDev.StackExchange is not a great idea. Having said that, if a work is truly in the public domain, you can do whatever you want with it. 

As Ophir Prusak points out, Apple does not allow downloading code to your app. So one possibility is that you could make your game logic and behavior entirely data-driven. Then all you do is download new data to the app, and your game changes. This is not a simple solution, however. 

If you are 100% sure that the NPC's level will always be enough to specify their stats, then level in db/calculations on client is a good option. Less hitting the db means your game scales better with the number of players. However, it locks your design into this box. There are ways to patch on differences not related to level at a later date, but this could cause problems as the rest of your game might not be coded or designed with this in mind. So this decision depends on how likely it is that the current design will be the final design. 

How to tell in the general case whether two convex shapes intersect? I'll give you an algorithm that works for all convex shapes and not just hexagons. Suppose X and Y are two convex shapes. They intersect if and only if they have a point in common, i.e. there is a point x &in; X and a point y &in; Y such that x = y. If you regard the space as a vector space, then this amounts to saying x - y = 0. And now we get to this Minkowski business: The Minkowski sum of X and Y is the set of all x + y for x &in; X and y &in; Y. 

where R is the radius of the sphere and, for a certain positive even integer N, we have the constant θ = × π/N, k and n are integers with k varying from 0 to 2N-1 and n varying from -N/2 to +N/2. To make a half-sphere or an eigth of a sphere, you have to restrict the set of values taken by k and n. If k were real numbers and not just integer numbers, you'd get a whole sphere, not just the vertices on its surface. So what we've done here is rasterizing the surface equation of the primitive. The fearsome torus: it's easy after all we've seen! Again, more trigonometry, more vertices, more quads, more symmetries, more invariants... more geometry! Find out the equation for the surface of a torus, "rasterize it" properly, simplify the problem using the (obvious) symmetries of the torus and, finally, loop through the set of vertices you just defined and make the edges and faces as you go! See? Completely straightforward. 

When changing prefabs, you have to hit the "Apply" button to commit the changes. This is the only part you're missing. 

Mainly compression is in fact used to reduce distribution size. If you think about it with digital music, you could download a CD as .wav and it's 650 MB, or as 256 KBPS AAC files and it's 1/5 the size with the same sound quality*. It just makes sense to compress anything you can. You're taking the compression time on your side once to save time downloading or reduce storage media size for everyone who uses the product. As a side note, yes encryption is different from compression. Encryption makes it hard to read the data if you're not the intended recipient. When making an iOS game, we send a compressed archive to Apple, then they encrypt it, which makes the package bigger. * I have done blinded testing on this. There's no discernable difference between uncompressed audio and 256 KBPS AAC audio. 

Do not count on getting an exemption for this. I haven't personally seen one. You can build stuff in a data-driven manner, but as soon as it's compiling code locally, you're in trouble. Think of what's going on with Unity. They use Mono, and open-source version of the .NET framework. It has a Just-In-Time (JIT) compiler to handle some stuff. But on iOS, that's not allowed. So for iOS builds it does an Ahead-Of-Time (AOT) compile. This means certain parts of .NET don't work on iOS. Unity is not a small company, and their engine has a very large userbase. Yet no exemption on compiling code locally. 

The same applies to (0,1,0) so that R'2 = ω×R2. R'3 is obtained from R'1 and R'2 with the relation R'3 = R'1×R'2 but we could also get it using ω. At any rate, we now fully know R'(t). Finally, R(t+dt) = R(t) + R'(t).dt. That's your new "orientation". With the positions equation, you now have the position of the solid at time t+dt. 

In your code, you calculate but the weight does not depend on the immersed volume (). I think you misunderstood the law of physic you mentioned. I don't quite see what you were trying to do with 

Inertia is not a tuple (x,y,z), it is in fact a 3x3 matrix but in the case of a simple box, calculating said matrix within the set of coordinates naturally associated with the box yields a diagonal matrix (i.e. whose only non-zero entries are on the diagonal,so there are 3). The pdf you linked to gives Ix, Iy and Iz which are the three non-zero entries of the inertia matrix I (but I'm going to call it J because I is often used for the identity matrix). But if J had been calculated relative to a randomly chosen set of coordinates (if the axes in the pictures to the right of the table in the pdf hadn't been in these positions priviledging the geometry of the solid shapes in question) then the matrix J would have been much more complex and, in addition to Ix, Iy and Iz there would have been three other real numbers necessary to define inertia: Ixy = Iyx, Ixz = Izx and Iyz = Izy. Three additional numbers only and not six because J is symmetric. I don't know what was supposed to mean, but if inertia is going to be a vector, then you'd better make sure your solids always have nice symmetries and invariances with respect to the axes of your axis system. Classical mechanics tells us that J.(dω/dt) = T where T is the torque, ω is the angular velocity and dt is a small amount of time (your timestep). Both are vectors. To get only dω, i.e. the small amount of angular velocity that you will add to your current angular velocity, you need to multiply both sides of the equation by the inverse of J and then by dt: