I did not test the code above, but theorically it should. That allows you to create instances of classes derived from directly without having to bother with the pointers. Here is how you could use it: 

Return the iterator, not the offset Searching algorithms in the standard library tend to return the iterator where the value was found - if it was found -, and the iterator otherwise. Once again, you can implement that with only a few changes: 

I had some time to work on the algorithm a bit since I asked the question and tweaked it a bit. Here is what changed: A small optimization does a bit too much work: it always check whether , even when hasn't been modified. A simple improvement is to move the check inside the previous condition and tweak things a bit more to only increment when needed too: 

That was it for the standard library usage. Now let's go for another round of comments about other parts of the code: 

Here is a small C++11 utility collection to store any object that satisfies a given interface. Only the basic concepts are provided, I did not try to create a full collection: 

Place of method Since belongs to , you better define in . That way, its derived classes won't have to duplicate the code, and will handle its member variables by itself. However, remember to add in the derived classes, otherwise, the name will be hidden by the overloads. Choice of the collection Using a to store collections of elements is often the best choice. However, if you plan to remove elements from the middle of your collection at some time, you could consider using instead. Anyway, I don't know what you plan to do with this code, so I did not change the to an in my revised version of your code (update: actually, be careful anyway if you decide to use an ). Encapsulation From what I see, all your variables beginning with an underscore ought to be members of the classes. However, you may have made them in order to simplify your code to post it here, I don't know. I did not modidy that in my revised version of the code in order to keep the code simple. 

You could probably write a nested function that does the and then you can handle the number of the iteration in the main function: 

General advice about C++ I cannot see any hint that you are using C++11, therefore I will review your code as C++03 code: 

Also, your class is nothing but a list of cards. Instead of having to always index , you could probably have inherit from . Not sure whether you would want to do this or not, but it could be pretty handful to avoid having one more layer of indirection every time you want to access your list of cards. On the other hand, all the classes derived from would be unable to derive from a second built-in type. I'm not saying it is a good idea, but it may be worth trying. Also, if you do this, you can get rid of and since the methods and would be directly inherited from . 

From your answer to my comment, I will drop the intended Python 3 paragraph (even though there are some goodies you may like in the most recent versions, such as the new that supersedes the old module) and go straight to the main point: Qt Designer is the way to go Writing user interface code is something that nobody likes to do. You could seriously save a good amount of lines of code by designing your main UI in Qt Designer and using or to generate the boring code so that you can concentrate on the Model and Control part of the code. Internationalization While it may not be important, it doesn't cost more than a few in order to tell which strings may be translated, even if you don't set up any translation for now. But if one day you want to translate everything, you will be glad not to have to reread your entire project to know which strings need to be translated. That said, many of the strings to be translated are automatically marked as such in the code generated by Qt Designer. Consistency is the key When reading the following piece of code: 

There are many pros and some cons. You can look at the page I linked above for the details. Basically, the syntax is considered more compliated, but it gets typedefs and namespaces right since it does rely on the C++ type system and not on strings processing anymore. Moreover, the functions passed as slots don't even have to be slots anymmore; you can even pass lambdas as slots. Use Since you are using C++11, you should use instead of and to represent null pointers. It has the advantage of be being easy to search and to chose the pointer overload when a function is overloaded for integers and pointers: 

However, I remember while implementing this algorithm a nice property of the the binary search, exploited by the Ford-Johnson merge-insertion sort: searching a value in \$2^n\$ elements and in \$2^{n+1}-1\$ takes the same number of comparisons (e.g. binary search in collections of size \$16\$ and \$31\$ requires the same number of comparisons). Therefore I modified the algorithm so that it would always search in sequences whose size is \$2^n-1\$ to maximize its efficiency: 

This is better, bu still not perfect: the agorithm currently works with random-access iterators, which is ok with , or , but it also means that it doesn't work with or which respectively expose bidirectional iterators and forward iterators. doesn't work with forward iterators (yet?) but it works fine with bidirectional iterators; here is what we have to change to make our work with bidirectional iterators: 

As an additional note, your function does not actually implement an insertion sort, but a gnome sort: to insert an element in the sorted part, your function repeatedly compares an element to the previous one and swaps them if they are not in the correct order, which means it's a gnome sort. An insertion sort would compare every element to the current element to insert to find the position where is should be inserted, then it would move every element after the point of insertion one step to the right and put the current element in the correct place. Here is an actual insertion sort; the actual code comes from Rosetta Code: 

is great Instead of using SFINAE for , you should use since your function does not have any overload. It will allow you to give a meaningful error message instead of a somewhat obscure SFINAE error message: 

and correspond to the \$ i_{th} \$ bit of and . These bits do not depend on the loop (the loop does not change them) and can all be computed at once by performing before running the loop. Therefore, we can simplify the function by moving them out of the loop. If we store them directly in , we can even simplify the assignment to to a mere :