If anything, it's the opposite - the whole thing runs on one thread and it's now hitting the point where that is becoming the blocking factor (last time I checked!) The reason it's fast is that there's no fancy graphics. It's deceptive, but the main thing that slows stuff down is drawing things (think upwards of two thirds of a frame in AAA titles). Since dwarf fortress is quite basic, it devotes the rest of that time to doing interesting things. 

And the same with the normal example above. To your second question: Pixel shader inputs depend on the shader semantic you access. Shader semantics are the extra bit after the colon in variable definitions that specify where the data comes from for the input, or where the output goes. In the above shader you don't define a position semantic so you won't get one. If you added to your pixel shader input (D3D10 and higher), the position is in screenspace. You can read more about the available shader semantics here. 

What this means is that these points are rotated around (0,0) by your angle . Instead, put equal amounts on either side of (0,0): 

And make the direction of the force directly away from the control eye/ball, like a repellent force emanating from the ball. Tweak K to control the strength of the force. Make sure that K isn't too high - you don't want it to just be pushed out massively by the force, just keep it away from the balls. Leave plenty of slack in your string. With just those two you will probably end up with quite a uniform shape, so I'd also suggest you create some weaker forces around in the surrounding 'soup' to change the shape of the amoeba. You can make these random places, change their force regularly (you could make it a sinusoid function for nice movements) and make them work in the same way as the balls. Vagination(fnarr): this is the difficult one. You cause it to envelop an object by checking to see if two non-adjacent points on the string have managed to get close enough, and if so you need to: Measure the distance between the points on the string. Count the number of spring sections. Find the 'shorter' path from A to B. Break the string and re-join it with the two points adjacent. In other words, directly join point A to point B and discard all the stuff inbetween. Re-insert the missing number of points (plus any bonus points if you want to expand in size by eating something) into the string in the other side - i.e, the side from B to A. If you insert them equally along the length and make them shorter than the desired distance between points, you should get a nice springy-expandy effect. I think that covers everything. By the way: idea sounds awesome. 

You can replace the single draw call with multiple draw calls to tiles if you subtract the platform's centre from the tile's world position. Important to note is none of this applies to your physics to actually stand on the platform and make it tilt. I'm assuming you've already solved that problem. :) 

HLSL lets you compress a vector with the same value down to a scalar. When you do what you're actually doing is: 

This is assuming your map isn't going to change much. If you wanted to render sub-maps in-place (for example, the inside of a building) you just render that to a canvas too and then draw it on top. Here's an example of how you can use this to render your map: 

If you're using C# (it's in the tags) you might be able to take advantage of the Xml.Serialization in-built parser to serialise/deserialise your objects: $URL$ In theory (probably a big in-theory) it's as simple as passing the object to a serializer and letting it do the hard work. Especially if your entities are just bags of components, which should just be a list of other objects to create. If you store Direct3D resources inside your components you might need to augment it a touch by customising the serialization of those parts. There's a fuller reference for the serialisation methods here. Hope that helps. 

It's probably the same way that you would do it with just the game - you have a database somewhere that both have access to. If they're really paranoid they might have one database as a mirror of the other, and when you sign up it copies your details across. The larger problem for big companies is redundancy and sharding, to share the data across multiple servers so that they can load-balance the usage from everyone trying to access it. A lot of DB software has this built-in nowadays. 

I'm assuming by Z axis we're kind of talking about the 'height' of the tile here. If you're sure that there would only ever be one tile on each of the X and Y axes (like a heightmap) then you can just modify your map array to store two values rather than a number: 

And you're right, it's about normalizing values. All normalizing does is make the length of that vector 1 unit long - hence it's called a unit vector. On the plus side, normalizing is simple! Either languages have it build in and you can just do: 

I'm assuming here you're using : You can use the function on the context to rotate any drawing functions. Draw the tiles with offsets around the centre, then post-translate them. Confusingly you write the translation first and it gets applied second, but here's how you'd do it: 

It depends on your aspect ratio. For normal screens this is either approximately 4:3 (Standard TV or monitor) or 16:9 (Widescreen). There's slight variations on this like 16:10 as well, but the two above are a good guide. If you're creating a side-scroller, I'd imagine it's the left-right that matters more than the top-bottom. I'd suggest a widescreen format, so around the 420-430 mark will do for height. In terms of small screen resolutions: if you're happy with 760 then you don't really need to go any lower than 420. Since most monitors will have at worst this 16:9 resolution, if it can fit 760 across then it can fit 420 down. Even a really old resolution like 800x600 can fit it comfortably. If you're talking about supporting phones or people making their Facebook window take up half the monitor rather than the full amount, then I'd check out this tutorial on resizing your game dynamically. You want to keep your aspect ratio constant and resize the whole thing to make the game as big as it can be. 

Off the top of my head, the clause that sticks out to me is that you want the area to be constant. That strikes me as the pain in all of this, so let's try and come up with a easy solution to that. Take a piece of string and tie the ends together to make a circle. I may be wrong, but my intuition says that the inside of that string has a constant area, or would act an awful lot like your amoeba boundary. So I would say: implement the string. ;) Most physics libraries can do springs (in Box2D this looks like the distance joint), and the easiest way to make a string is to connect lots of strings together. Join the last one up to the first to create a loop. Make sure the springs in the string have a high enough spring constant to not get stretched apart - you want them to be quite rigid and move in unison, not to expand out. Next, create forces to act on the string. Trivially, your two cores/eyes/control points create forces onto the points that make up the string. Make the force fall off with an inverse square function: 

On the plus side, you can work in your 'world' space to do this. On the down side, you still need to draw from the furthest to the nearest, so you'll have to work diagonally across your map. :) Last, but not least: I have no idea where on earth you got that transformation matrix from. I work it out to be: 

Note how the transforms are loaded in reverse - the order these are applied is bottom to top. Clearly it's a bit fiddly to constantly undo then re-do the translation, so a slightly better way is to do your transformations around zero then move it out to where you want it: jsfiddle.net/auVrK/ 

It's easier to think of this using vector maths. The plane equation is for all points on the plane. Therefore, the intersection point must satisfy this. If our point P is defined by the line equation (where is the line's direction and t is the distance along the line) we can sub this in: 

This means that you don't remove items from the list while you're still iterating over them. If you don't want to do this, the second option is to check items from the back first: 

To get back to world-space, you need to reverse your translation from graphics. Think of graphics-space as U and V instead of X and Y: