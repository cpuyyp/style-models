Does not immediately follow from a tutorial or exercise: finishing the project requires a fair degree of independent work. Is "large" and "challenging" relative to the expectations and abilities of a beginner -- for example, it might take a beginner a few weeks to complete a "large project", but an experienced programmer might be able to pull off the same thing in a weekend. Is not a "single-file project": there are lots of things you need to do and lots of details to keep track of. At the very end of the scale, a "large project" might be the sort of thing an intern or an entry-level junior developer is asked to do. (Most beginners will probably likely need to complete multiple easier projects first before they're at this level, though.) 

(Replace "X" with the name of the language. If the language name is common word like "Go" or "Swift", try replacing "X" with something like "Go language".) This will obviously return a wide range of results, not all of which will be useful, but it's a good way of getting the "lay of the land". Some of the results will be directly useful (for example, you might uncover a popular and comprehensive style guide or a useful linter), and others will be more useful for getting context behind the design and intended use of a language (for example, googling about the language's core philosophy). Other things I personally find helpful is to browse through the top-voted questions about a particular language on StackOverflow or SoftwareEngineering.SE (previously Programmers.SE). The knowledge won't be immediately useful (or sometimes comprehensible), but it does give you a feel for what sorts of issues programmers using that language tend to worry about, what advanced features people want to learn to use, and what keywords might be helpful when refining your queries. Something else you can do is to keep an eye on news aggregates for the language of your choice. For example, I like browsing through $URL$ for Python-related news -- every now and then, you run across an article that teaches you something new or reveals a point of contention within the community that's worth keeping an eye on. Keep in mind that after reading through all of these resources, you'll likely find it hard apply them all at first -- in some cases, you might not even understand the articles you dig up. This is fine: the idea is to be aware of them in the first place so you have a direction to grow towards. It'll probably be a good idea to start small -- start by finding a style guide and writing your code to be compliant with it, for example. Or maybe try figuring out the recommended best practices for organizing a larger project and using your language's package manager. 

Suppose I've assigned a project and asked students to pair into two-person teams. I'd like each team to pair-program: work together in person to complete the assignment. Some students will do this, but sometimes they don't: either one partner monopolizes the work (which hurts the other partner) or the two partners split up the work and work independently (so both students end up having gaps in their knowledge). I'd like to avoid this as much as possible, which brings me to my core question: what can I do to encourage as many students as possible to (effectively) pair program? I read this post, which included a several nuggets of useful advice, but am interested in collecting more, if possible. So far, I plan to: 

One strategy that's sort of similar to the "embrace" strategy described in the other answers is "acknowledge" -- not only do you explore the quirk, you explicitly acknowledge that it's a flaw or mistake in the language. After all, languages are designed by humans, and humans are ultimately fallible creatures: I think it's ok to acknowledge in some cases that the language designers messed up, or were working under assumptions and constraints that are no longer relevant today. This lets you work in teaching moments about: 

Did you try telling them that? It might be worth mentioning this explicitly and giving examples of what good responsive design looks like. (And if this isn't one of the focuses of your class, mention it off-hand and link to resources the students can read if they're curious and want to learn more). Perhaps you could use this to actually explicitly make the point that trying to control the appearance down to the last pixel is a huge timesink, and that your time is better off making a design that's robust to minor changes, especially for web development? (You could talk about how fonts differ from OS to OS, how browsers can alter the page to help with accessibility, etc...) Basically, if they're going to keep focusing on visual appearance, you might as well spend some time making sure they're at least doing it right. 

Fundamentally, I question the notion that you can test to see if students understand the idea of abstraction beyond a superficial level, even if you don't restrict yourself to asking just multiple choice questions. It's a little hard for me to articulate, but I sort of feel the best way to learn + get feedback on whether you understand abstraction is to actually try tackling a large, novel-ish problem and discuss your design decisions with a more experienced dev (or, if self-teaching, learn the hard way why some decision was a bad idea later down the line). Nevertheless, here are some ideas (with the caveat that I have never once designed and administered a multiple-choice question style thing which means it's entirely possible I have no idea what I'm talking about). These are all more CS-y and math-y then your example questions, but I figured you might as well address the skills you're after in a directly applicable setting instead of beating around the bush. 

One sort of meta approach is to not try doing this within the context of a university course at all. Instead, try and build up a culture where students are heavily encouraged (or even required!) to do internships and such (or at least join a research lab), perhaps over their summer. You can do this by having a strong career fair, by explicitly working in lessons or running workshops to prepare students for tech interviews, and so forth. Basically, I feel one of the best ways to learn about the importance of software engineering and design is to actually work on a long-running project where you need to deal with the consequences of design decisions other people made. It's hard to engineer that kind of scenario in a classroom setting, so might as well off-source it (and simultaneously help students develop their resume as a bonus). The disadvantages are that your students won't necessarily learn these lessons consistently, not all of your students will be prepared enough to pass a tech interview and get an internship (though I suppose it's good that they're learning this now rather then later), and that doing this will require a strong departmental push over a period of several years which will likely be harder to do compared to revamping a single course. 

It might even be worth making the textbook optional or actually just saying outright it's not worth spending time reading it to try and further drive in the point. If you're going to do this though, you should make sure you give them plenty of other resources to make up for it -- provide really good lecture notes/slides, give them plenty of (optional?) practice problems, have lots of office hours/an online discussion board or something so it's easy for students to get help, etc... As a caveat, these suggestions are from my experiences teaching "intro to programming" style courses that focus mostly on algorithmic thinking at the undergraduate level. I'm not sure exactly what your courses are like, so my suggestions might not perfectly match your student's needs and will need some adjustments. 

I don't know if I have a solid answer to the main thrust of your question, but I do have some one-off suggestions that may or may not be helpful. First, something you could try integrating into your lessons is some kind of meta-narrative about why proofs are useful in the first place. This seems to be a very common concern from students in the discrete maths course that I help teach (especially since they've been mostly programming up to that point) -- this post made earlier might be applicable (though idk if I fully agree with all of the answers). The second thing you could try doing is squashing your first and second lessons into one. If your students are already familiar with that many programming languages, I think they'll also be pretty familiar with boolean symbols, and won't find truth tables terribly hard (or interesting). It might then be more fruitful to cover tautologies, contradictions, and contingencies around the same time -- might as well cover all of the related definitions at once. I think focusing on implications for some time would be useful, though. That seems to be a very challenging concepts for students to fully grasp -- see How to teach logical implication for more details. Making students do challenging exercises that the Wason selection task to see if they really grok implication may also help. You mentioned you briefly cover first-order logic (symbols like ∀, ∃, |, ∈, and ∴). I think those merit more time -- those also seem to be challenging concepts for students to grasp (in particular, what they mean, how variable scoping works, how to correctly use rules like ∀-introduction, ∀-elimination, and the like). One good challenge question for your students is to ask them whether or not $\forall x \, \exists \, y P(x, y)$ and $\exists y \, \forall x \, P(x, y)$ have same or differing truth values. I'd also save teaching what ∈ for when you formally introduce sets. Finally, one way to perhaps make your lessons more exciting is to introduce homework/introduce problems that involve solving logic puzzles, particularly ones that are challenging to reason through normally. Have your students start by converting the constraints into logical propositions then have them simplify them until they're able to find an answer. This lets them practice their English to logic skills and their logic manipulation skills in a hopefully more fun setting. If you want, you can even take this one step further and turn it into a programming assignment by asking them to generate constraints they then feed into a SAT solver like z3. (For example, take sudoku -- you can make each cell a variable, define 9 predicates that encode whether or not a cell contains a number or not, then define a whole bunch of implications encoding relationships between relevant pairs of cells). This lets them see more concretely how propositional logic is relevant to computer science, and also lets them play around with a cool piece of tech. 

Allocate time to promote pair programming in lecture Let students chose their own groups + provide an (optional) survey to help pair students Let students petition to work individually if they really want to Skew the projects towards the difficult side to try and get them to at least talk to each other (and provide plenty of office hours as a safety net) Collect partner feedback at the end and factor that into their final grades 

A common misconception many people have is that Python 3's function returns an iterator of some kind. This is actually false: it returns a custom sort of sequence object (which, by definition, is also an iterable). What this means is that I think it actually is legitimate to teach as being basically a "list-like" thing. More precisely, it returns an object that actually supports almost the same set of operations Python's object supports -- the only exceptions are that any methods that allow mutation (such as ) are missing, and the method is missing for some reason. More precisely, the range object... 

I like using micro-frameworks such as Spark (for Java) or Flask (for Python) for teaching the backend. There's minimal ceremony, and micro-frameworks tend to closely mirror the HTTP request-response model, minimizing conceptual overhead. And since Spark is Java, you don't need to spend unnecessary time teaching a similar language. In fact, there's even an argument to be made that the best thing to do is to ditch even micro-frameworks and start with just plain CGI or something: you literally manipulate strings, and that's it. Then, time permitting, you have students write their own framework/templating engine/what-have-you on top of that. Basically, I view web development as one giant exercise in working with abstractions, and I feel one of the best ways to make students understand an abstraction is to have them build it from the ground-up/start without the abstraction. Web frameworks and trends come and go at a ludicrously fast pace, so I think it's particularly important in web development to focus on the fundamentals rather then trends. (You can see more about this philosophy here) In particular, I like emphasizing that web frameworks are just complex ways of processing and sending strings: I think it helps demystify a lot of things, and gives students a concrete footing to help build their understanding of these abstractions. (Tangent: you can work in all kinds of interesting CS topics depending on how much you want to commit to this "build everything yourself" model. For example, you can talk about compilers, parsers, and DSLs if you have students build their own templating engine; you can talk about NFAs, DFAs, regexes and such if you have students build their own regex engine to match routes... This is all probably overkill if your focus is just on teaching web development though.) 

I think your metaphor is currently a bit limited in that it's useful only really in the context of event-oriented programming (and GUIs) and such. After all, delegates are basically anonymous functions and functional programming languages (Haskell, Lisp, etc) make heavy use of anonymous functions to accomplish all sorts of things. (And many mainstream languages do something similar -- see C#'s Linq, for example). In any case, if you had to give a metaphor, I would reuse whatever metaphor you used to explain objects (or perhaps even use objects themselves as a metaphor!). After all, an object is a bundle of data and methods that we can pass around. Well, sometimes, we're interested in just one method out of that object. In that case, instead of passing around the whole object, can we just pass a single method? 

The hope is that focusing more on motivation will allow your students to acquire a reasonable conceptual model of how network protocols tend to work, even if they forget the exact details. I think this approach also does a better job of answering the implicit "why?" question people have when learning new things. (Why ports? Why IP addresses? Why TCP? Why abstract things like this? Why is everything so complicated? etc.) Basically, confront it head-on by presenting things in a problem/motivation -> solution approach. Caveat: this approach might just be a reflection of how I personally like learning things, so YMMV. 

Implementing an interpreter or compiler for a programming language Writing a video game (either a feature-rich prototype of a novel game, or a polished clone of some existing game) Writing a webapp or mobile app with a non-trivial frontend or backend (for example, implementing their own basic search engine) Rigging together some relatively complex automation using a few Arduinos/Raspberry Pis 

I think so, yes. However, I also believe teaching assembly isn't valuable because it could hypothetically teach students how to write "faster programs" -- compilers these days are smart enough that most of the time, you're just better off using a systems language and relying on the compiler if you're interested in that. Rather, I believe the value in teaching assembly (and systems in general) is it gives the students a much deeper understanding of how computers work, which is highly valuable if they want to move on to other subfields of computer science. For example, suppose a student is interested in exploring security. If they want to learn how things like buffer overflows work, what ASLR is, be able to understand the latest innovations in kernel research, how whatever the vulnerability-of-the-day works (right now, it seems to be Spectre and Meltdown), it's essential they have a good understanding of how exactly their computer, the hardware, the OS ticks. Teaching assembly (and more importantly, things like calling conventions, the stack vs the heap, and so forth) is a pretty decent stepping stone to help prepare students travel down this path. Of course, I'm not claiming teaching assembly is the only way, but it's certainly a well-trodden and popular route. We can do the same kind of analysis for other fields -- systems knowledge is potentially valuable for people interested in compilers/PL research, in software validation and correctness analysis research, for people who want to build on top of new tools like Webassembly, for people who are interested in writing hardware accelerated code (using GPUs, FPGAs, SIMD instructions, etc)... Of course, not everybody is going to be interested in these fields, and even if they are, that doesn't necessarily mean that assembly is going to be directly useful or relevant to them. But I don't think that's any excuse not to teach the material -- the goal of teaching, I believe, is to prepare students to be successful in a wide variety of different fields, whether that's industry, research, or something else. And if that means sometimes teaching them material that they won't directly need for the foreseeable future, I think that's fine. It's better to be over-prepared then under-prepared, yeah?