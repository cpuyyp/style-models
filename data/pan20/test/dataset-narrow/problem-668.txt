As I've said, I'm used to the operands being the other way around (destination, source), but hopefully this points you in the right direction. 

Unused variables At least one of your variables () is never used. This might be because you've changed the way the code works. If you refactor your code, try to remember to cleanup at the same time / straight after. It's a lot easier to do while the code is fresh in your mind and it prevents large amounts of technical debt building up over time. margin of words I found this prompt confusing (maybe it's just me). I think a better prompt would be something like "Please enter the maximum number of words per group: ". Try to be expressive and imagine that you're not going to be the one using your application. Variable Names Similarly, think about your variable names. They should express what it is the variables actually represent. Names like , , and tell me nothing about what the variable represents. This makes the code harder to read because you have to keep referring back to determine the previous context. Single letter variable names can be ok for short iteration variables where the context is obvious, but can you honestly say that this is meaningful in its current state: 

Naming You code's naming conventions are very inconsistent (which possibly reflects the fact that you've taken bits of it from different sources). Generally speaking, I expect local variables to follow a camelCasing naming convention. Your current approach ends up with lines like this: 

I'm used to writing my assembly the other way round, so hopefully this wont be confusing. Loops You're using as a counting register which is good, however there's a built in instruction that allows you to perform loops. So, rather than you having to do this: 

With that in mind, I'd be inclined to do the memory allocation and file opening the other way around, however that's largely a matter of taste. Does the function call on , if so this feels wrong, since you're explicitly calling in your method, I would expect the close in the same place. 

Centralise Responsibility At the moment, your is responsible for knowing the target path, but your class is responsible for knowing the source path. Since they are related, it's better to have the paths referenced from the same area of code. If you push the knowledge of the source path into your class and pass it in then it will be possible to reuse the functionality in other classes in future. This leaves the class looking like this: 

These names aren't perfect either, I don't really know what 'metadata' represents and if it should really be part of the header, which is why I've split your in to two, however I've tried to name the methods so that they convey what it is I think the methods are doing. This makes the top level method more meaningful, describing the process of initializing the db file. As far as method length goes, methods that are too long are a red flag, because they usually mean that too much is being done in one place and the method is likely to be hard to follow. However, I'm Ok with one line methods, as long as the name for the method actually conveys the intent better than the line it hides. 

Each of the input lists is already a null terminated list and you don't need after this point, since you return the head, so you can just tack the rest of the input list onto the end. 

Cache input data that's reused by your tests The tests you've posted are incomplete, and so it's hard to know what you're actually planning on doing. However, your commented out code suggests that you're planning on calling every time AccessNumber is required: 

Naming Think about your variable naming. You've used for your local variable, however your parameter names are and . Do they mean anything without looking at the rest of the code? Break down the problem into methods The code below looks like it represents rotating the array by 1 place. If so, put it in a method with an appropriate name, then call it. It will make the problem breakdown easier to follow. 

This way, by each thread having its own mutex, threads are only ever allowed into the area when they have something to do. 

I've been messing around with the SE Data Explorer and I've come up with a query that basically returns information about questions that have a high number of views per day, that have few or no answers. 

This could then be used from your form. Notice this is class takes the initial number as an argument, because it seems unlikely that you're only really interested in the number . Of course, it may be that all of those statements are important and you're planning on replacing them with writing to a text area or something. If that's the case, I'd consider replacing with statements that write to a . You could then pass in initially and easily replace it by something else in the future. Either way, I would define a function and call it from the , not just write the code into the form load. This will also make it easier to reuse the functionality if you want to trigger a recalculation when an input number box changes or a submit button is pressed etc. 

Best case, the second time you call , it throws an exception and the thread function crashes. Worst case, the doesn't throw an exception and you don't notice that the thread function is in an endless loop, eating processor time. Once you've closed the connection, you should from the thread function to prevent the pointless spinning. 

compute_edit_distance This method feels like it could be useful in different scenarios. I wonder if it should perhaps be called and perhaps pushed out of 'main.c' into a utility file so that it can be reused. Leaking memory Your method is leaking memory. It calls and assigns the return value to which is cleaned up, however when you call , you're not using the variable you're calling the method again to allocate another copy of the value: 

namespace std Whilst it can make things easier when you're getting started, lots of people don't like this: 

Magic Numbers You've got some magic numbers in your code. I'm not totally against using numbers when the context makes it obvious what the numbers mean. However, this isn't always the case with yours. For example: 

Memory Leaks You aren't cleaning up after your . When the class is destroyed you want to make sure that all of the memory it has allocated is cleaned up. At a minimum, you're going to want to: 

Looking at your code, it doesn't seem like the functions that you've implemented have much scope for reuse. Whilst they could make your code easier to follow, I don't think they do, primarily because the names don't really describe what they do. I find getting names right to be hard work, but well named methods make code a lot easier to follow. Your method names that you've introduced are: 

f what? On the whole, your variable names are good and descriptive. That said, you're using consistently for the file handle to the telephone book. Why not give it a proper name? Duplicate Code There's quite a lot of duplicate code in 'main.c' to do with reading the phonebook. You have to get the file name, open the file, read from it, close it. This is common to several operations (you need to do it to display the phone book, add to it, remove from it). It feels like it should really be encapsulated in a function so that it can be called rather than being duplicated as the code can get out of sync (showing the phonebook is the only one that contains the memory leak for example). File Management I actually think that your API for the phonebook is wrong. Rather than having take in a , it should take in a filename and the FILE io operations should be hidden behind the scenes. If you were performing record level operations on the file with each call (read entry, rather than read list) then I think working from the might make sense, however that's not what you're doing. The file operations performed by the and are tightly coupled to the . reads from the current position of the file pointer to the end of the file. What happens if the caller opens the file before calling in append mode, rather than overwrite mode etc. Format strings I'm not a huge fan of : 

On the whole, I found your code very easy to read and follow. Your division of work is sensible and easy to understand. There's a couple of things I noticed whilst reading the code: Line length You have a few lines that go over the common target of 79 characters. Most of these are under 100 though, which seems reasonable to me, but you do have one that is over 130 characters. GameMessages In your class, you've got several methods that start by instantiating an instance of . This makes me wonder if it should really be a member variable of the class so that it can be shared between methods. while continue_selection.upper() != 'Y' or continue_selection.upper() != 'N': This line is checking a condition that's always going to be true (you break out of the loop before getting there). I'd consider reworking the loop so that it only contains the retry logic. Something like this: 

Test Cases The test really odd. You've basically saying, make sure that when I put 453234 into the array twice, my code doesn't tell me that the duplicate is 25. This might make some sense if your other test used the value 25, but it doesn't so 25 just comes from nowhere. You haven't posted the code for , however I did look at it in your gist and it's creating an array, then putting the duplicate in a random position within the array. Generally speaking, try to avoid in your tests because it can result in non-deterministic tests (tests that fail sometimes and pass other times with no changes to code). Some better edge case tests might be: 

As far as your actual code goes, there are a couple of things that stand out (but are mostly stylistic). In a few places you use unnecessary local variables: 

Magic Numbers For the most part, I don't mind having actual numbers in code where they make sense in context. In the die drawing code above, it is easy to follow that the 1 and drawOne are connected as the value of the die. However some of your numbers are less clear, like representing not on a ladder. Where the meaning isn't obvious, avoid using the numbers and consider replacing them with a meaningful constant / #define. 

Compilation Error Template code often isn't resolved until after you exercise it. I'm not really sure if you code is supposed to support this or not (I'm not overly familiar with some of the newer standards), however if I use an , then I can do this and it works ok: 

And the backing fields get removed, internal code then accesses the value via the property. Duplication I'm not really keen on your Left + Right nodes being as exposed as they are, it's possible for clients of your class to build their own trees, which might be what you want, but it feels odd, what happens if they do ? That said, your property and method do the same thing, they both overwrite the current LeftNode with a new one. I assumed was going to recursively call until it found an empty left node and then add it. If they are intended to do the same thing, then I'd think about removing one of them. Too much control outside of the class Consider this loop, which never ends: 

naming It's a little odd that your push/enqueue methods have have a postfix, but your pop/dequeue methods don't. I'd pick one and stick to it. heads and tails I'd rather see the head and tail of the queue wrapped up together in a queue structure. This means that you only have to pass one parameter (the queue) into your enqueue/dequeue. It also means that if you decide to change the way you implement the queue, your clients aren't impacted. Are Queues Stacks? As you've implemented it, it's possible to call stack functions on queue nodes and queue functions on stack nodes. Is this really desirable? If not, then making the change above to introduce a structure that wraps a head and tail would mean that you would at least have some level of type safety and the compiler would warn you if you tried to call dequeue on your stack.