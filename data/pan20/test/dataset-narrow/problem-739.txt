You are using a lot of different variables to store the objects in and declaring them for your whole main method. If you really needed four it would be better to have an array of but in this case you are better just having 2 (maybe still in an array) but only create them when you actually need them and set them to the right type then. By using the array that then lets you change the player 1 and player 2 while loop into one for loop to run over the array[] and you can remove all that duplicated code. It also lets you support any number of players virtually for free. For the loop you can use a do-while loop as you know you always have to run through the loop at least once. It would be more efficient to use one Random object created in Main and then passed into anywhere else that needs it. Other than that your Pile object looks fine. Your Player object is a classic case where inheritance should be used. Create an abstract base class Player and then create subclasses HumanPlayer, ComputerPlayer and SmartComputerPlayer (the computer players may or may not also have a common ancestor). Then you just have a Player object reference in your main class and it calls the relevant method in that - which gets sent to the right subclass automatically. 

The separate variable h is needed for thread safety. Otherwise you could potentially have a second thread see a partially computed h (or as already mentioned have two threads calculating a hash at the same time and interfering). Both will break things badly (for example inserting a string into a HashMap with the hash wrongly calculated and you will never find that String again). Copying value to val[] looks like a now-obsolete micro optimization. Again the immediate check for the array being empty is a micro optimization to handle the empty string case without entering the loop. 

Because does not need to return , , or . It returns , , . If you want to retain your way of result, use : 

And add your method in another class in another file called . That would look like (if you want to time it): 

Even though it saves a lot of lines and typing, it's at the cost of performance and readability. Import each class individually. 

Again, consistency. Always put a space before the opening brace, or never. I recommend always, as that is more readable. 

Some notes: Your bracing does not follow standard Java conventions. This is more of a matter of preference, but this is how I would format your code: 

Here, I suggest you do instead of . It is a matter of preference, but I think is easier to understand. 

This way, programmers using it has a choice of being able to give less information, and add it later through the methods. Also, this allows them to prevent them from doing stuff like: 

Just for practice in the mathematical side of programming, I decided to rewrite the math functions, with the addition of the function, which the Math library does not provide, but can be easily done with where you want to find out to the th root. I also wrote this to review the Newton's Method, which works like this: Given an approximate \$x\$-intercept \$x_n\$, a better estimate \$x_{n+1}\$ is calculated with the following: $$x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}$$ Where \$f(x)\$ is the function to find the \$x\$-intercept, and \$f'(x)\$ is the derivative. 

What is this verb "Enqueue"? Method names of this format should be verb-object, as in "do this to this thing". If simply adds the passed object to a queue, the correct name is . 

Don't prefix your names like that. If you're adding a prefix, it should still follow all the rules of variable naming for C#. For private fields, variables are named in , with the underscore before it. Public properties are named in . So, you can rename a number of variables, for example should be . Server.cs I do believe I've found an error here. 

[ln 179] Folder !== Directory. Be consistent throughout: if this is a setting that a user needs to understand (hence why you used Folder instead of Directory), convert it to Directory code-side. 

I've created a voting system that's similar to Stack Exchange's in a Ruby on Rails web app. It's working great - as far as I can tell, all the edge cases are caught. This is the action to cast a vote. There are some conditions I've had to satisfy: 

At the moment, I'm updating the record if there's already a vote by this user on this post, but I wonder if that's the most efficient strategy. Would destroying the old row and creating a new record be faster? I'd particularly appreciate efficiency comments - at the moment, this is a very server heavy action, which I'd like to minimise. 

More in general, this class is doing too much. This is the code-behind for , it seems, which should be an effector class (handling what the user sees). Make another class containing the helper methods like , , etc., for the business layer, and refer to it from . 

I would try and approach this more generically. Define a rules interface, run each section of the string through the Rule and add the result. The rules can then check individually for all caps, exclamation marks, etc rather than hard coding it into your central method. (i.e. a rule that returns 1 point for every exclamation mark it finds or something). Might be worth having two types of rule - "full string rule" and "word rule". the full string rule can process things like total number of exclamation marks and stuff, then you split the string on whitespace and run all the found words through the word rules. For things like nice/nasty words I would have a configuration file somewhere listing words and a positive or negative score next to them - for example please -10, swearing +10, etc. Your word rule can then scan your words against that dictionary and apply the result to your score. 

Something to remember about the Java libraries (especially older ones) is that they were written when Java was a new language. Some of the techniques and patterns we use as standard now were not available and the compilers, optimizers etc were a lot less smart. A lot of things we can just ignore now and let hotspot handle had to be considered in the code, and since these are core libraries that must run well on every possible Java device they cannot assume anything about the environment they run in so have to do as many optimizations as possible by hand. Sun's code to compute hash of string: 

Though this program tells the truth (unless you change the source code), it does tell Fibonacci numbers, depending on the user's input. Keeping in mind of all (or most) of the feedback given from previous questions, I wrote this program to see how well I have progressed. 

Why the "A" in the middle? I would remove it completely, as it both reduces readability and is doesn't add anything to the meaning. Same with all the other ones. In 

The last case is not required if it does nothing. If you really want to tell a reviewer/code-reader that it will do nothing, simply use a comment. It is also understandable, as only the and options should do anything, and the button should be completely ignored, as it is in many real-life applications. I cannot think of a single situation where a button will do anything... SwingOverviewView 

At first glance, this makes no sense. These numbers are more like magic numbers: make them a constant: 

You have a constant, which is pretty much a . You use it to append. Instead of doing that, you can easily append the char itself, which saves a String creation. 

Of course I didn't include the numbers in the description... I am sure there is a better way to do this. I just did a simple solution, where I add all the numbers and take the first 10 digits. 

It's really just performance. There's gotta be a better way to do this, but I can't think of a single way. 

In general for OO programming you separate out code into objects and each object focuses on doing one thing and doing it well. Each object should then generally have it's own source file in your code tree. 

This is a very nice implementation, and in fact will be just as fast as the sun one since over an Array internally uses a style approach. The problem with it is that it is not compatible with earlier versions of Java since the loop is a recent addition to the language. Micro optimisations You will see this term a fair amount in this sort of discussion and in general it can be read to mean "something that makes such a small performance increase that it is not worth the increased code complexity". In the usual development scenario keeping code simple will reduce bugs and increase developer performance in terms of functionality provided for time spent far more than the micro optimisations can increase application performance. In fact in some cases micro optimisations actually degrade performance as they confuse the compiler which otherwise would make the same or better optimisations behind the scene. "Premature optimisation is the root of all evil" - Donald Knuth This is a well known quote in this field, although actually if you go hunt down the full quote there is far more to it than the catchy tagline. As a developer you should focus on writing clean and well structured code and on the big optimisations such as choosing the right algorithms, data structures, etc. Once that is done if you still need to increase performance then assuming you have the right algorithms and data structures (which will save far more than any amount of micro optimisation) that is when you look at progressively finer optimisations. But keeping the code clean and readable will gain you far more in the long run...quite apart from anything else it makes it easier to get the algorithm right! The core Java libraries are a special case as every single Java program is written on top of them, so slow performance there slows down everyone...and they have to run on every single JVM so they cannot rely on clever compilers or virtual machines. In many cases the core Java libraries are a bad source of coding examples. Partly for that reason and partly because they were written when Java was new and people were still learning the best ways to do things. In fact the book "Effective Java" by Joshua Bloch uses examples from the core Java libraries as things NOT to do. That's an excellent book by the way, you need some Java experience to appreciate it but I recommend it to all developers with a year or two of Java behind them. 

and its equivalent on the next line, is redundant: you should only use when you're passing in a delegate, and even then not always. Rewrite those two lines: 

Did you just... catch a generic exception? And ignore it? You need to work out what exceptions to catch and what to do with them. In this case, you're most likely to get a or , assuming your arguments are constructed properly so you don't get an or . So instead of catching a generic exception, catch both of those and tell someone about them. Something's gone wrong and this program doesn't work, I want to know why. 

can just be , because range starts at 0 by default. The syntax is essentially - the only mandatory param is . Filename parsing If you want to parse filenames by yourself rather than using a library, then while your current solution: 

[ln 60] Single responsibility: if 's purpose is to get news, it shouldn't also be dealing with notifying the user if there is none. Make this method return if there is no news to be had because of the , and do the check in the UI code [ln 55]: 

ServerManager.cs This class is generally good, apart from naming. Rename your variables here and you're OK on this class. 

What sorcery is this? You've conjured a string from thin air! Where did that come from? You should avoid magic strings where possible, instead assigning them to a or of commonly used phrases within your application. The same can be said for in the call: what is 1987 and where did it come from? Assign it to a resource list. Client.cs Code Analysis Says: Implement correctly. Your class nominally implements , but you've only written half the implementation. You also need a method, called by . If called as , it should also clean up managed resources; if it's you should only clean up your class' resources. You also need to tell the garbage collector not to run the finalizer on your class because you've already implemented . In this case there's no difference that I can see, so a few simple modifications: 

I think I can separate Python from Java anc C++ now, so the is no longer there. But just in case, is there a stray ? Is the way this class is constructed Pythonic? Are the docstrings good? 

Naming should be : names are concise names that shouldn't be abbreviated. could just be . I know you are using a , but is a more readable name. Final Code: 

Don't reinvent the wheel, unless you were required to. Java has a method that you can use easily, e.g.: 

The conventions say that each line is a maximum of 80 characters. You exceed that many times, especially because of a large amount of arguments to a method, or calling a method with a lot of arguments, or maybe some other reason. After formatting: 

It is often bad practice to catch every single exception in one catch block, especially if the exceptions can be predicted. In this case, we have and . First, we can identify where and why these exceptions can be thrown, and if they can be prevented. The can be thrown on the first line of your block because can be . You can prevent this by doing: 

This is because quicksort is \$O(n \log n)\$ while bubble sort is \$O(n^2)\$. How I would do quicksort: 

I know you wanted it without recursion, but I only came up with a solution by using recursion. If you really don't want to use recursion, then your code is fine. 

Well, the first thing that's bad is the the fact that everything is crammed on one line. Max line character count is usually 80. To handle the hardcoded , you can use . (You don't need it anyways for my solution.) You don't need to use ; instead, assuming is a object, you can use . The thing that makes this so hard is the fact that does not have an method. Instead, we use 's method, which is better than what you have up there. Continuing from point 4, don't use (I don't even know what that is). Instead, use , and its methods. 

I've written a userscript that pops up a dialog before you take a moderation action (closing, deleting) with some pro-forma comments, so that you can add one of those before you cast your vote. I'm pretty happy with how I wrote it, but what's clear to me is unlikely to be so to others. Is there anything in this that I could have "phrased" better, or that could be optimized more? Comments on style (or, for that matter, anything else) are also welcome. It also occurs to me that this isn't as extensible as it could be: it's not easy to add new comments. Is there anything I could do to facilitate this? I've also put this code in a gist, if you want to see it there. 

[ln 215] ? Seems like one list to me. Rename it; again, consider the point above that it should be . 

String replacement If you've got a lot of replacements, or you plan on adding more, try an extensible solution instead of all the calls: 

[ln 30-31] Style choice: I recommend using around conditionals, even if they're only one line - because if you update them and make them more than one line and forget to add the brackets... exceptions. Also, your indents are off here. Indent the first line of the snippet above by one more space. 

is technically safe, and is fine for your current script, but if you want to adapt it for another script, it'll break. A more general, equivalent one-liner is: