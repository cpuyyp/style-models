In GIMP you can use the "make seamless" filter (this can also be scripted). If the results aren't good enough, the best way is a manual approach as described in the answer by CiscoIPPhone. This tutorial lists several possibilities using GIMP, including the "make seamless" filter. 

If you have a lot of sprites it could certainly be an option to scale down high-res assets on devices with lower resolutions. These devices also usually have a lower maximum texture size, so you can't just use the high-res assets as textures. To go about this you could use the Quartz 2D API (basically create a bitmap-context and draw your image with the desired size using ). Then you can use the you get and add it to the as there's already a built-in function for this. Once you done this, you have the ready and you can use it for sprites etc. Loading the data from pre-rendered files is going to be faster though. If you have lots of sprites, it might have a significant impact on the loading time of your game, so you'll have to try if it's worth trading loading-time for application-size. I'd say if you can fit the application into the new 50 MB limit (download limit for cellular networks) with the above trick, then do it. If your application will get larger anyway, I think it isn't worth the effort. Another thing you might want to check out first is a PNG optimizer like ImageOptim. There's even a small guide for iOS optimization and what you'll have to change in XCode too. I updated an app for iPad 3 and managed to have both low- and highres assets in there without increasing the app-size compared to the previous low-res version (although I only had very few assets and also ones that can be compressed very well without losing quality). 

The fixed pipeline is rather limited. Something as simple as Phong-Shading already requires a shader (the shading capabilities of the fixed pipeline end with Gouraud-Shading). The possibilities that open up with shaders are huge. Some of them are: better shadowing-techniques, ambient-occlusion, normal-mapping, etc. That doesn't mean you can't create great looking games without shaders though. AFAIK Torchlight only uses fixed pipeline and looks awesome. Also: If you're doing 2d graphics, you'll probably be fine with fixed pipeline only. 

Have a look at Tiled or OGMO Editor. These editors allow you to create your levels and can also write the level-data to XML. Parsing the XML data in Java should be rather simple. Alternatively you could have a look at the AndEngine which comes with a parser for the TMX format (TMX is an XML format written by Tiled). 

So yes, there are definitely performance reasons. It's always a good idea to have a broad- and narrow-phase, unless you only have to deal with very few and simple objects. The same procedure also applies for 2D. In the broad-phase you can use bounding circles or axis-aligned rectangles. In the narrow phase you can then check the actual outlines of your sprite, for example by using SAT or pixel-perfect collision detection. 

If it's an open source project, you might consider putting it on SourceForge and/or link it to Ohloh. People might like what you created and will (hopefully) give positive feedback/ratings on these platforms which can increase the popularity of your project. That way you might even find some developers who will help you improve the software you wrote. Having a dedicated Website for the product and maybe a Twitter feed/account won't hurt either. 

But since you're embedding a sprite-sheet which you blit to some other BitmapData object, you probably don't even want that. Therefore something like this will do: 

The chart also allows you to see market-share by region which might be interesting if you're targeting a certain audience (for example U.S. or the Asian market). EU and U.S. seem to have a high iOS/Android market-share while Africa, South America and Asia seem to favor Symbian. As with all statistics, this should be taken with a grain of salt, as it's not clear in what context the data was gathered. Especially in regard to game-development where a market-share in terms of app-sales would be much more interesting. 

A lot of physics engines operate at a scale of 1 unit = 1 meter. Unity isn't any different, as you can see in the manual. 

Instead of altering the texture and erasing pixels that should not be shown, I suggest you build your geometry in a way that it fits your floor. Our geometry should look like this (red paint-over): 

A creative way to tell the users about possible cheat-codes would be to hide them somewhere in the game content. Examples: 

So how would you tackle this? Contrary to other games of this genre, I'd like to have only a few, but very "skilled" enemies instead of masses of dumb enemies. 

I assume you assign a Prefab to in the inspector. When you try to destroy inside of your method, the error message does make sense, since you're trying to destroy a prefab and not an instance. Instead of trying to destroy , you should destroy the object that collided with your GameObject. So, replace: with: (you can be sure to destroy a collided missile here, since you already checked the matching tag in your if statement: ) 

I really like the approach where the vector itself gets normalized. Why? Because in a lot of cases you won't need the original vector after normalization. If you do, a or method should be simple to implement and help in these cases. So if I need to keep my original vector and a normalized copy: 

While a tool like PhysicsEditor (see Ellis answer) is certainly better, the poor mans choice would be to use an HTML-image-map editor. The coordinates for image-maps are in pixels, but you could simply divide these by image-height or image-width respectively to get coordinates in the 0..1 range. Here's an online-tool to draw such image-maps, and here's another one. 

While you could render your scene to a texture and use this as the background, it's most likely not worth the effort. Here's why: 

But as I mentioned previously, there's no way to avoid string concatenation/conversion at some point if you're dealing with CSS properties. Another thing to note is that the property requires a vendor-prefix in some browsers. Libraries like jQuery will automatically generate the prefix for you, if you're not using such a library, you should consider these vendor-prefixes: , , , . A CSS declaration would then look like this: 

Capture Events and use the and properties of the event object to update camera position (use the delta to the last and position to get the amount of movement). If you have some sort of scenegraph, you could build a node-setup like the following: 

I'd probably use a single color image (eg. your note-sprite) with alpha channel and then color the whole image with your base-color. So, something like in the following image (from wikimedia commons): 

Maybe you'll even want a combination of the above.. eg. export all classes to frame 2 and also an initialization script on frame 2. 

Lands are only being counted at the end of the game, so you'll only have to do this once per game-session. Since you'll know all completed cities beforehand (to calculate points for the cities), I'll probably do the following: 

As thedaian mentioned in his comment, converting the magenta pixels to transparent in JavaScript is going to be slow. You should convert your images to a suitable format beforehand. ImageMagick can be really useful for this kind of tasks. Converting your tile with magenta background to an image with transparency is as simple as this: 

Although MVC is a pattern that is widely used, I think it's not really appropriate for games. When developing games you'll also deal with sound, physics, networking etc. where do they belong to? Model, View or Controller? You'll find that model and controller (sometimes even the view) are most often better combined in one class and/or that there are other patterns that are better suited for game development than MVC, for example the component pattern. As a flash developer, I encourage you to separate your code from your assets though. If you're using an IDE like Flash Builder, there's no way around that anyways. Also try to separate things that represent different layers of "information/logic", like sound, rendering, ai etc. to make these components reusable. You can leverage the flash event-system or use a signal-slot implementation to loosely couple these objects. Eg. The player class (or maybe even the collision-handler) dispatches a signal whenever the player collects a coin. By connecting the "collect-coin-signal" to the sound-class, the appropriate sound can be played without explicitly calling any sound-related code inside the player class. Of course this signal/event could also be connected to the keep-track-of-score-class etc. This architecture allows you to easily attach more components later on and/or swap them with different ones without rewriting huge portions of your existing code. I think that most of the patterns commonly used for game development also apply when developing games in ActionScript. So just go ahead and look for some good game-development patterns and make use of them in your next Flash project. Btw. I have never used Unit-Tests for a game, but maybe that's just me :) 

In the top left, you'll see the composed image, on the top right there's the original map image. Bottom left shows the calculated light pixels and on the bottom right you'll find the distance-map that was used. You can drag the light with the mouse and increase/decrease the light radius using the arrow keys (left/right). Instead of rendering a circle, you would only render your triangle as active "light". To make the calculation of every single pixel inside the light radius reasonably fast, I use a distance map that is being used to look up how much distance can be traveled from any given pixel without hitting an obstacle. The distance map is calculated at initialization time, therefore the flash file takes a while to initialize (because calculation of the distance-map is quite CPU heavy). To avoid this, you could also pre-calculate your distance-maps and store them as individual files. Please note that a distance-map won't work with moving obstacles though. 

Well, what makes a good RPG/MMORPG? Personally I have enjoyed Torchlight a lot (single player action RPG) and it was created by a rather small team of roughly 26 people. If you look at a game like World of Warcraft, the numbers are entirely different though. 

There are lots of algorithms and papers for procedural tree generation out there (this thread might be interesting). A difficult task is to nicely blend the branches. 2D is definitely going to be easier in that regard, since you can solve that with alpha-blending. Since you're experienced with Ogre3D, Unitiy and cocos2d you can go right ahead and implement that thing (no need to start learning OpenGL now IMHO). Personally I'd choose cocos2d and release for iPad and/or iPhone, so that everybody can carry his tree around with his mobile device. 

Let and be Search and increment in your bitmap and visit each pixel from left to right, from top to bottom until you hit an unvisited foreground pixel. Search from to the right, until you hit a background pixel or an already visited pixel. Keep the amount of found pixels as . Set to . Start another search at ( and search pixels. If all these pixels belong to the foreground, increase by . Repeat step 3 until you hit a background pixel in the search. Then you add the rectangle (formed by and , ) to the list of found rectangles and mark all the pixels it encloses as visited. Increment by and continue your search (go to step 2). Your search ends when you reached the bottom right pixel of your bitmap. 

Block is at the left side of the board. Since the block cannot leave the board, it should be moved back inside after a rotation. Block hits "ground", but isn't placed/committed yet. In this case, the tile must be moved up to resolve the collision (in case of a "I"-Block, the movement would be 2 cells up). Tile would hit occupied blocks, must be moved left to resolve collision. Tile cannot be rotated. 

Objective-C and HTML5/JavaScript are quite different. If you have a background in web-technologies, the HTML5 route might be easier for you. If you have some Java or C/C++ experience, you might feel more comfortable with Objective-C. While it's certainly possible to develop games in both "environments", you shouldn't forget about monetization. You can put your Objective-C app in the AppStore and sell it, while you'll have to find other ways to make money from your HTML5 app (maybe ads or some sort of subscription model?). If your focus is iPad/iPhone, then Objective-C is going to be less of a pain and also give you the better performance.