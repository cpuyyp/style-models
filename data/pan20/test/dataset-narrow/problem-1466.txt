My experience, also, is that when a "better" student helps another, both benefit from the experience. The helper gains deeper insight by having to verbalize an understanding that may be only partly formed. When abrasive personalities get in the way of pairing, the one that is abrasive needs to learn better behavior in any case if he/she is to be successful in the long run. Instructors need to watch for this, of course, and offer advice as needed. 

I'm going to assume that you mean courses in which face to face presence is required, as opposed to MOOCs in which it is not. There isn't likely to be much true research on such things, partly due to the recentness of their creation, but mostly due to the difficulty of formulating and answering appropriate questions. What data there is is pretty scattered and is subject to taint by financially interested parties. However, opinion surveys are available, as well as reports by interested but not financially interested groups. A set of reports can be found here: $URL$ Kyle Thayer and Andrew Ko recently interviewed a collection of students concerning barriers faced by bootcamp students: $URL$ The study is small and so not definitive. It is also situated in time as these things change. Of course, an online search for "value of programming bootcamps" will bring you a lot of opinions, but little research. The wisdom seems to be that bootcamps are good for making you better at your current job than they are for helping you move into a new profession. Employers may downplay the value of a bootcamp for valid or invalid reasons, but it still falls on the individual. If your resume shows no success in the new field, a bootcamp isn't likely to help you much. But that is just another opinion, of course. Still more opinion, but possibly useful: $URL$ 

Design patterns covers a broad area. I'm going to assume that your students are beginners, more or less. Elementary Patterns A few people have developed some interesting elementary patterns for things as simple as loops and selection: $URL$ These patterns help students program at the lowest level and, after introducing the patterns you can easily come up with small exercises that see whether the students actually use the patterns to guide their programming. Any exercise that requires a sequential if structure can have the students factor out the structure as a method and apply the "Return, Not Else" pattern, for example. There are many possibilities. Organizational Patterns In addition to coding patterns, organizational patterns can be used to both teach beginners good skills that will serve them well in the classroom and later in employment. For example, you can consider Extreme Programming (XP) or Scrum to be defined by simple pattern languages in which the practices are the individual patterns. Some of those practices may not be appropriate for beginners, but others are just good practice. For example, Pair Programming and Test First Development work well together and help students solve their programming problems. An in-class exercise in which you let students practice just those two skills under your guidance is, in my experience, very valuable. I've also presented larger projects to students as a deck of "stories", the Product Backlog that gives beginners an overall decomposition into the parts of the solution they need to build. Often this is better than a narrative explanation of the problem when the still have no design skills. Classic Patterns. Many of the classic patterns are amenable for use in the beginner's curriculum. They will likely do these things anyway, but by formalizing the discussion of them introduces them to the value of patterns. For example Iterators are now ubiquitous in many languages. If you are doing GUI programming then the Observer Pattern is now standard. At a slightly higher level Model-View-Controller (MVC) can be discussed. This gives you a good way to discuss separation of concerns in programming. You can also organize your course so that you make it clear that, say, at the beginning the students build a Model without concern about how it is manipulated. It has a public interface of a few methods only. Then, once you have a model you can talk about the possibilities of (perhaps multiple) views and the associated controllers. But this is an organizational issue about the course. If they have to just build everything, they might wind up with a "Big Ball of Mud" (a pattern in fact, but not a good one). Once the students are familiar with the idea of patterns you can introduce them to more complex ones with many parts. I find the Strategy and Null Object patterns to be useful in teaching polymorphism. With these patterns you can modify the behavior of an object dynamically, which leads you to program by composition (an object has interesting parts), rather than by inheritance. For example a situation in which an object must perform in one way the first time it is sent a message, but otherwise thereafter can use strategies, formalizing the behaviors, without using ad-hoc if-statements. I realize I haven't given you many "exercises" here. My suggestion is that you can adapt many/most of the ones you are already familiar with to the use of patterns. Pedagogical Patterns You can also formalize your teaching methodology using patterns, so that your student interactions are guided by well-tested methods (patterns) that can make you a better teacher and make it obvious to you (and maybe to your students) why you do the things you do in the course. 

There are two things you can do (surely more, of course) that will enhance the overall education of your students. First is to discuss the general situation of nested structures and the relationship to trees and to recursion. The frame contains Panels which contain Panels, which contain... down to some non-recursive things like Buttons. This lesson, when generalized from the specific GUI layout case, is important for understanding modern languages and how they are compiled and processed. It also gives them the background to understand web page layouts, etc. The second big topic you can introduce here, assuming you haven't already, is Design Patterns, both programming and architecture patterns. Understanding the Observer pattern is essential to Java GUI programming for example. Once they have seen one pattern in some detail (perhaps a truncated version) you have the power to discuss others. The Java libraries are completely full of design patterns since Java and Design Patterns sort of grew up together. The Java i/o libraries depend fundamentally on the decorator pattern, for example and the students likely already know about Iterator, but perhaps not the full structure of it and why it works and other solutions to the problem are sub-optimal. Moreover, if you discuss Observer in some detail you have an entry into the Model-View-Controller architectural pattern (MVC). So it is quite rich. MVC is also used in the Web architecture as well, of course. Once you introduce Patterns to your students you have a way to talk about reusable software at a much higher level than just "reusing classes", which has a lot of issues and often leads to ugly and unusable software. Reusing proven designs, however, is a much more important idea. 

Making the project harder isn't really going to help you and it will frustrate at least some of your students. Letting them choose their own partners will encourage nothing new as they likely do some of that already but without real pairing. Also, letting them choose pairs doesn't get the real benefit of switching pairs and thereby spreading knowledge. Things happen outside your view, as you say. They will do as they wish and tell you what they think you want to hear. Lecturing about pairing is especially ineffective. You have to show it and you have to let them experience it. Letting them opt-out gives you and them nothing at all. The people who want to work alone probably need the experience of working with someone else at least as much as the others. Collecting feedback is, to me, the best part of your plan. But you should do that for all projects anyway.