I'm sure this question has been asked before. However, I'm trying to connect the dots by translating an equation on paper into an actual function. I thought It would be interesting to ask here instead on the Math sites (since it's going to be used for games anyway ). Let's say we have our vector equation : 

I'm not sure if you're question is GDSE appropriate, but this is all I can offer: Grab a library/engine. Follow the instruction/tutorials. Start building. A lot of stuff is already done for you ( like sound/graphics/controls ) so you don't have to reinvent the wheel. Here is a list of engines ( check the licenses, some might not be free. I havn't checked them all ). 

As of reading my own comment. It could very well be that you create new textures for every object in your game. Always have one pool of textures / One place the texture is read from and let your sprites reference/point to it. It simply sounds impossible for ONE spritesheet to make your device go out of memory. Most games today certainly have at least 2 to n spritesheets. 

points are the points on line t; height are their values from which the lines are drawn from one point to another. The function that goes with it: 

So we know 3 tiles will be removed, therefore we need to randomize 3 new values for 3 spots. The catch is however we first need to move the tiles in the same column that were above( blue ) the tiles that were removed (red). It would be easier to traverse from the bottom up ( highest index first to lowest). You can easily count how many tiles you need to move first based on the current index value of y|row to index value 0. You simply copy the value in order. So in the illustration at {3}{2} ( y index first then x) the tile value should receive the blue tile value. At this point we haven't tweened anything yet. 

Engine simply refers to the underlying software that "drives" your game. You build your game engine on top of SFML. SFML provides a simple way to create visuals, play audio, netcode etc. SFML would become part of that engine. A game engine can come in a form of a library or with a full fledged editor and own scripting language. But SFML is not a "game" engine. Its main purpose is not just to create games. You can also build other media applications with it. SFML simply provides a layer of software which allows the developer to do things like drawing an image or play a sound. But you can consider it a collection of "engines" for producing visuals, playing audio, etc. Usually when people speak of a game engine they are talking about a piece of software that's pretty complete on its own. The only thing missing is art(sprites/models/etc) and game logic(gameplay, input, etc ) which results in an actual game. Even if you're making a small game with sfml, anything you write on top which "runs/drives" your game can be called an "engine". Wouldn't worry too much about it. Library simply refers to a collection of classes/functions/subroutines/whatever to develop software with. 

As provided in the comments, if this is an issue of repeat delay then all you have to do is simply change your code to more of a state kind of process. It might be a bit more code but its how you get things running It could look like so : 

where x is the resulting vector, s our starting point/vector. L our parameter and r our direction vector. The ( not sure it's called like this, please correct me ) normal equation is : 

( If it's more appropriate to remove this thread please let me know) When the problem occurred I changed to hard edges and only worked with that. Meanwhile I changed my drawing logic and the fix went unnoticed: The problem was that I didn't have the right blending modes applied, these should work. ( names might be slightly different in OpenGL) This is done in Kha and Haxe: 

I'm not sure if the title matches what I'm actually facing I'm trying to test if I can see a point is in my field of view (in the context of an NPC seeing in it's direction.) I know that: 

Direction is the movement of your camera, thus the position of the camera changes. The base is the center of your camera or character ( if it's in the center at least). So basically you define the position of each background piece by dividing the position by the width and height of the screen 

The idea here is simple. The bullet class handles the movement internally. You just need to create one, set it's position and velocity. When the update method is called the velocity is added to the position. Afterwards when you call the draw function. The x and y of the calculated position are passed as the drawing position. Have a central point where delta time is calculated and passed on to the objects that need it. So in your case: 

Probably not a correct answer but here is a library of various audio engines (Scroll down to the second segment for audio libraries) At least 9 out of 12 engines go with C. Most of them also support tracker files. Which is not so different than nsf ( I assume these are NES music files ) files. 

Now you loop trough your sprites/bitmaps with a double forloop( because you are working with rows here) I might have made a mistake but it looks something like this 

It's easier to use a button for one action than using a combination of buttons. Double Dragon for the NES made you hit A + B to jump. While A and B are also Kicking and Punching. Logically it's less intuitive if you use certain buttons for different unrelated actions. As a player you get accustomed to the layout, but it is certainly not better than having a third button to jump. Of course this completely depends on the requirements of the game. Some games only need two buttons. But limiting game-designers to only two buttons is counter-intuitive. If you take zelda : links awakening and link to the past for example. Link to the past had a third button to perform certain actions. While keeping sword mapped to 'B' and Item use to 'Y'. 'A' was used for various actions like pulling, talk, running etc. In links awakening you had to swap out items to 'A' and 'B'. You could even swap out your sword. Might be handy, but unnecessary if there were more buttons. It really comes down to the gamedesign. 

Then calculate the right bottom bound. You can use these indexes to determine what starting point and limit you should use for your forloop. Instead of drawing 100x100 tiles. You only a few in comparison. You could represent your camera as a simple rectangle that you move around. Have the center, the width and height. 

You might want to divide your world into segments/ a grid so that you only check collision for agents that are relevant. Agent A thats on the other side of the screen will NOT collide with B on te opposite side. So why check collision? Google for Spatial partitioning / quadtrees /spatial hashing. I googled some for you: Quadtrees Grid Also your second forloop should start at a1+1. Because all the previous agents were already checked And need no checking. This also eliminates the need of 

Let's say our map is 800 pixels wide. And our Tiles are 100 pixels wide. Let's assume there goes 8 tiles in a row. if our players x position is 350 we get Math.floor(350/100) = 3; Here is an image sized on actual scale for proof (note that your array starts at 0, so 3 is still position 4): 

Since Consoles pretty much have one specification. And not like PC where you have tons of different variations. Developers can optimize their games better. But this doesn't mean it will do space magic in the long run. It will reach a cap. ( currently the 360/Ps3 have 512 mb in total, which to many developers seems to be an annoyance) Consoles are fairly outdated after 6 months. PCs always grow faster in hardware specs. But games on PC never really get optimized for one hardware set. They have to keep in mind that there are also people with lower specs ( hence the video and other options ). But since developers working on console games can optimize in the longrun they can do neat tricks with the hardware. PS3/360 games look fairly good in this time of their life cycles. But just imagine if a developer focused on one specified powerbeast of a pc. In the beginning of a new consoles life developers need to adapt to the hardware. You can't just slap code from one platform to the other. That is why you don't see the games we have now in the beginning of the life cycle. The production pipeline grows overtime. It's not something you can get right the first time. A lot of optimizations need to be made and it just costs time. When you see better features in a sequel it's because the development of the technology was growing during the first game. Real breakthroughs usually happen with new hardware. But developers can be creative at times that allows them to do things on limited hardware. 

Like sean said, working with events to trigger when something should or should not be used is an elegant way of doing it. 

Export to PNG and use a texture packer to create one texture-atlas/spritesheet. $URL$ or $URL$ These texturepacker export a text file( usually a json file ). This file contains all coordinate data. If you plan on using your own implementation look at the LibGDX source code and see how its making use of texture packer files. Edit: Because you are rather new to gamedev, it would be way easier if you just used LibGDX. If you insist on doing your own things then: With libgdx-texturepacker-gui: first you need to understand how json works. If i'm not mistaken in the package android.util there should be a jsonreader class. You need to parse the json file and read the coordinates you need to clip the image with when you draw it. There is an example that comes with the zip file called "test-me". It shows how to pack textures. Open the project in that folder and hit : Pack selected. It will create some files in the output folder. It will create a png ( your sheet/atlas ) and .pack file ( your json file you can open it with notepad or any other text editor and read what created based on those images) For animations you need to do some extra work, because you create sequences based on the region names ( that's why you just need to use something like libgdx, it's all done for you). withtexturepacker: There are several formats it can export too, but that's up to you. Same story as above you need to parse the file and need to create a function to get the region you want. Alternatively you don't use a texture packer and create the texture atlas yourself by placing the images uniform in a sequence like so: 

Vector : Vectors describe the magnitude and direction. If you just want the direction you simply normalize it. This causes the vector to shrink to fit into the unit circle. Meaning that it has magnitude/length of 1. From rotation angles: To get the x and y components for your direction: 

This will give us the indices of the current tile in our worldgrid. --> grid[indexY][indexX] As for merging rooms have a manager that couples Room objects together. If you go by my example you should be able to retrieve the Room object by Tile. You can then "ask" the RoomManager what room is merged with the current one and read its properties like: size, type etc. 

From my understanding you just read the camera bounds and use that as your index reference of your tile grid. Draw from the first tile in the top left corner of your current screen, relative to the cameras position, to the last tile of your bottom right corner index. This way you only draw tiles that are within camera bounds. For example the first would be something like so: 

As I said in the comments, a 2D array would probably help you out. Lets say this is our 5 by 5 grid and we have a match 

So if you multiply it ( by a scalar ), the speed in this case, the x and y components adjust accordingly that the length of the vector is the speed it's multiplied with. 

I wonder why you aren't just moving the velocity of the bullet to its own class? You could simply create a base object that has the position and velocity. And an update function that adds the velocity to the position. This update method is then called in an update loop ( obviously with an array of bullets) Use an object pool to reuse these objects when you "destroy" them. The update method could probably come from an interface to allow polymorphism. I have the feeling your velocity is lost once it goes out of scope or is overridden. And therefor your old bullets don't budge because they were depending on it. Try having a central point, like a factory, that creates objects for you. Don't let the player create objects directly. Instead it should call a different object that returns an object for the player, or directly passes it onto your managers (and by managers I mean the objects that handle things such as your bullets ). You can do everything with the x and y variables as you could with a vector. The only difference is probably that the Vector class has many functions already implemented. But for a simple movement, adding the velocity to the positions x and y would be sufficient. Your class name Bullets should be Bullet btw. Bullets implies something else than a single bullet =).