Here's a crack at a bit of code. It's probably worth mentioning though that I don't think your code could even compile or if it does your missing variables i.e. itoy_tmp5... Either way, like Robert said I looked for some patterns that seemed to be repeating and started from there. I extracted the first part to a method and then extracted again etc etc Here's the code anyway if it helps. 

In regards to your specific question on design patterns I don't have any immediate advice. However a few formatting and standard practice stuff does stand out to me. 

No I don't think you necessarilly need a viewmodel and there is plenty of debate on this on the internet. However I personally like the viewmodel approach as it provides the flexibility of adding any UI specified fields I would like without the overhead of my view being tied directly to the buiseness model. Of course this means also that you now have to have the rules copied twice like you mentioned. However if you were using jquery validation this would be the case anyway (or so I believe). 

Maybe. But how are you going to know what actually went wrong? All that's going to happen is you know something went wrong but when it comes to diagnosing it you will be at a dead end because you have swallowed the exception (so to speak). Given that your exceptions seeming to be handling cases such as the database offline, or connection issues I think it would be best to bubble those up as that would be a core system fault and you would want to know more info. Here's an alternative solution using a non-static class and sharing the Database context between methods. 

Alternatively you could get rid of the multiple private fields and just use a dictionary to maintain your skill data sets. Hence a refactored solution using that method might be. 

Using existing MVC helper methods When creating links in the view I always like to use the built in MVC helper methods such as or . This means that if the site is installed in a sub directory the correct link will be created automatically for you. i.e. . If you currently deployed the solution you have your links would break with a 404 Not found. 

In general method names recommended as Pascal Case so should ideally be named I might consider trying to make the class a bit more configurable so that it could be extended in more ways without being modified. For example if you wanted to send a text email, or you wanted to send an email using a different server. 

I think I like the combination of your third option with that supplied by Dan. I've made some other changes which may or may not be better. Not really sure. My aim was to have the Delete set status callbacks only i.e. success, failure while the UI event handler handled the confirmation requirements. If anything, I would always suggest using .Any() over .Count() > 0 operations as although a minor thing could have unexpected have performance benefits on large collections. And if anything I personally think it reads a bit nicer. 

ViewModel.Save() I'm not a huge fan of having the viewmodel responsible for calling the model to persist the data. I'm not sure where you could move this to as I haven't looked at the rest of the code but I would typically put that call in the controller and use a mapping layer to copy the properties from ViewModel to model. My main reason is that it seems to violate the boundary between the viewmodel and model in that now viewmodels know about models. I tend to prefer the level of dependency direction going toward a ViewModel not away from it i.e. View => ViewModel, Controller => ViewModel 

I think I personally like the set by constructor method in general. I think it provides a means by which you can better allow for TDD and also implicitly implies the contract all inheriting classes must obey in providing a Entity object if they wish to inherit from the base class. I think if I were going make Entity a requirement of the second method I would make the protected method abstract which would also enforce this constraint. However that doesn't allow for the easy of use in using dependency injection which I think would suit this approach nicely. I'm not sure why there would be a huge increase in the size of the Entity object itself. I would assume the size increase would only be as large as the size of the memory register holding the location of the Entity object itself. As for performance, I can't comment explicitly but I would assume you would still need to make visible the EntityData object to it's children so you would probably do that via a property accessor or method anyway so performance impacts to me would be low on the priority list unless profiling the code suggested otherwise. So assuming the Entity is required in inherited classes I would consider something like: 

So in your case if you are expecting NULL back as a possible value i.e. the value might not exist, then you should be looking at using instead. i.e. 

In response to your "I still feel there's a better way of handling this than the switch" sometimes when I see switches I think polymorphism and is there a way to handle this via OOP. I typically don't do anything about it but at times it's hinting that I have a problem in my design and I should think a bit more deeper to put the necessary abstractions in place etc In your case, although this might be needless complexity you could change your enum into a class hierachy of Urgencies. Maybe something like. 

wow that's alot of code in the Course constructor. Could this perhaps be factored out into some sort of load method. Or if you need to run this code for every course object, perhaps make a course createable using a static factory. So going with the refactoring suggestions already mentioned, you could do something like: 

NOTE: I would have loved to test for the not a number scenario, but wasn't sure how to generate that given the definition of my parameter Func. Also, initially I remove the need for a static class but reverted that to keep in line with your implementation. hence the commented out 

Yes, I believe so if you want to write a bit of javascript. You would need to create a hidden field and on every select list change event set the value of that field. Something like 

I would probably consider making the entities object a class level parameter since it seems to be used in every method. I wouldn't put the success message in this class as that seems more caller dependant. Hence I would let the caller determine what success message they want on a true result. I would only supply a failed message to at least inform the user what happened. Is this sort of a repository pattern... not sure. But I might toy with the idea of changing DataAccess to ManRepository and getting rid of man in the function names so it's just Create, Update and Read.