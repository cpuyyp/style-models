tl;dr- A loop is just a loop that has extra slots for a pre-loop statement and a post-loop-run statement. Since they're pretty much the same thing just written differently, a loop is best understood as syntactic sugar that's useful when it increases the readability of the code. Sometimes new programmers are worried about performance, thinking that syntactic sugar might be less efficient. That's not the case; the compiler really doesn't care how you write these loops, it's all the same to it. So, students should be told to just write whichever's cleaner in the current context. Homework/test question idea: Have students convert a loop into an equivalent loop, or a loop into an equivalent loop. Mapping between and The loop: 

tl;dr- That peak around 1986 looks pretty difficult to explain in terms of interest. After searching a bit, I found a paper that attempts to explain it in terms of teaching capacity. This paper argues that the rapid rise in student interest in the early 1980's flooded Computer Science departments, forcing them to raise entrance standards to avoid being overwhelmed. I'm not 100% sure if this line of reasoning is entirely solid, but presenting it here as a partial answer. If nothing else, the idea that departments had logistical troubles accommodating a rapid rise in CS students seems to make sense as a contributing factor. 

A few tweaks to expression classes, and basic caching is there. Another idea to add common implementation would be listing free variables occuring in the expression (after adding variables ofc). First, make subclasses implement method (returning list of subexpressions, e.g. in case of sum). After that, implement method in Expression, and override it in Var/Variable (to return the single variable used there). The effect should be something like: 

Implement nested arithmetic expressions. Let me start with what it can look like, and then I'll explain why it's a great example. It starts very simple: 

Where is the inheritance? I'd like to point that I didn't use Python's subclassing at any point here, and it was on purpose: Python's subclassing is mostly about implementation inheritance, and here it's not necessary at all. Of course, if you use type hints, you should define an interface, but only in that case. Python is generally duck-typed and there's not much point in pretending it's not. However, you can also add some shared implementation to this example. Adding implementation inheritance There is at least one thing that all kinds of expressions may easily share: caching. Example base class could look like this: 

One problem with these examples is that the base class is more of a mixin than a real base. But I don't think you can do much better without going big. So, ultimately, you may want to go big. Want really interesting inheritance? Go big, use a framework. While little examples like above are good for understanding the basics, the most practical examples of implementation inheritance are big, all-inclusive classes provided by frameworks, like Django's views and forms. You may consider using them to show some practical uses of inheritance. While writing a Django¹ application is definitely an overkill, modifying one may be perfectly good task even on (relatively) early level. If you prepare a working application that needs relatively small modification, like adding a view with different sorting, it may be a good hands-on experience. However, this is risky, and may be daunting experience if either students or exercise are not prepared well enough, so proceed with great care (if at all). 

It depends on the situation and your school's policy on academic integrity. At my school, it clearly states that authors may not knowingly permit other students to submit their work. You may want to ask your school to update its policy to include a clause like this. You will have to determine if authors know if other students submitted their work. The author could be a student in the current class or another class. The author could be a stranger online. In a previous class, I suspected that one student submitted another student's program. This was confirmed when I saw that the filename included the original student's first and last name. After discussing this with both students, I resolved it. I can't say that I follow a hard and fast rule. I think it depends on the situation (severity of the violation, actions of both parties, etc.). 

I briefly discuss spacing, braces, and general readability. Then I open Eclipse and demonstrate [Ctrl]+a, [Ctrl]+i. This instantly indents your code according to a default standard (which is configurable). Since there are so many concepts to cover in class and limited time, this is one shortcut we take. 

Recursion is sometimes difficult for students to grasp. It's important to understand the concept before implementing it in any programming language. My college professor said that recursion may not make sense today, next week, or next year. But one day it will come to you, maybe when you least expect it. I show this image to help students think recursively. Next, I'll start with a simple recursive program to calculate the factorial of a number. In class, I simulate recursive calls with pieces of paper. I start by writing fact(10) = 10 * fact(9) on a piece of paper. Then I write fact(9) on a new piece of paper and pass it to a student. The student adds to it by writing fact(9) = 9 * fact(8), writes fact(8) on a new piece of paper, and passes it to another student. This process continues until a student must calculate fact(1), which is simply 1. Then all the papers bubble back up to me, and I calculate the final answer. But even with these relatively simple examples, sometimes it takes time to understand recursion. More simple examples help. 

Once you have some basis for understanding the discussion, then you focus on getting your own ideas straight. In the end, it's really all about you; sharing research results really isn't a goal so much as a duty to be performed when/if you become the foremost authority on some particular understanding. If you're a younger student, you've probably got a lot to learn and develop before you can really enter that arena. But, if you're interested in it anyway, it seems like you could do two things: 

is legal because both 's are in different scopes. This scoping issue is why we have the statement above wrapped in extra 's, since the belongs in that scope. loops can omit parts Might seem weird at first glance, but 

The peaks look more pronounced for women; presumably if we had a graph of just men, we'd see their enrollment had a milder response. I'd speculate that this implies that women cared more about the optimism/pessimism about Computer Science happening at the time than men did. This is, optimism had a stronger pull to get women in, then pessimism also pushed them out harder. This push/pull effect can be seen in the relative CS degree obtainment plot: 

That may not be the best metric. Even if it's actually possible to tell apart populations of people with basic programming abilities and those lacking them, it's not enough of the solution. Some people may be quite capable, but still dislike the process. So there will be people trying to study CS that will eventually want to leave. Maybe it's better to just make these people leave quickly The way that my university was approching this was to put fast paced programming course with focus on algorithms in the first semester. The course, apart from teaching obvious skills, had an explicit purpose of failing or discouraging all the people without the skill or interest necessary to finish the studies¹. And then in the second semester, it was followed by writing a sizable GUI application as an individual project. While I don't have any numbers, I believe it worked kind of well. It seems that whoever survived the first year and was willing to stay, was well capable to finish the undergrad course and find work in IT. However, there are some caveats The main issue with the presented approach is that it's strongly negatively biased. It discourages all the people that should be discouraged, but perhaps discourages also some happened to be just a little bit to slow. And while a university sucking up in all the best country talents may afford being picky, I'm sure it doesn't work everywhere, at least not at this scale. It also must be more tricky in a private school. My university was public, and people generally paid no tuition. 

I think it depends on the goals of the course. Does your course have specific objectives for working in a team? Is the primary goal to learn some aspect of programming? I teach a software practicum course where students must collaborate like a real software engineering team using an Agile Development Methodology. All the work they do is shared. Learning to work in a team is an important skill. But if the primary goal of the course is to teach programming fundamentals, web development, game programming, etc., then I would lean toward individual assignments. It's so crucial to practice programming. You can maximize this with individual assignments. 

One analogy I use in my intro class is transportation. The Internet is the roads, bridges, and highways. The World Wide Web is the cars and trucks that travel along these routes, carrying cargo to/from different places. 

I believe something is lost when you simply copy and paste code. They say that to learn a definition of a word, you read it, say it, and write it. So I think typing code definitely adds value, especially when IDEs like Eclipse have autocomplete and syntax checking. Typing is a learning experience. Unless you are copying from a raw format, copy and paste could bring in invalid characters. For example, try copy and pasting "hello world" from Microsoft Word to your favorite code editor. You'll see invalid double-quote characters pasted. 

Seems like a developing field is a discussion that a community of researchers engages in. To participate, you'd need to: 

Speak the language, e.g. know about quantum computing terminology. Know the background, e.g. quantum physics and computational theory. 

Focus on the well-agreed-upon concepts. You don't need to understand them or even be able to use them just yet, but have them in the back of your mind as you progress in your more foundational studies. Take note of the skills and tools that seem to be most useful in the current community. For example, if the field seems to be best-attacked through a particular branch of mathematics or using particular computational tools, then you might want to put acquiring those skills on your to-do list. 

This answer's based on "A History of Capacity Challenges in Computer Science" (2016). As we can see in the plot, there's a rapid rise in Computer Science majors until the mid 1980's. It seems generally agreeable that this followed from computers being an interesting field of study. 

is actually perfectly legal code! Since it omits a condition and doesn't do anything, it's basically an infinite loop that runs forever without doing anything. In C#, it doesn't consume CPU time, but it also blocks the thread from progressing. For example, 

This sounds like a question of vetting. Here are some things I do when evaluating Node.js libraries: 

It depends on the programming level of the students. In my case, students are just starting out with Java. I tell them to ignore the quirks and multiple ways of doing things (e.g., adding 1 to an int var). Find a way the works and go with it. Then discover the different ways as you progress with the language. These students are new to basic programming concepts and problem solving. Language syntax shouldn't stand in their way. 

In the software practicum that I teach, students develop new software for a real customer. My school has a standard software license agreement that the students, customer, and I must sign at the start of the semester. The agreement basically gives ownership to everyone involved. The software becomes, in a sense, open source. The agreement has two separate clauses. One gives more "ownership" to the customer. There is some flexibility; one past customer worked with the university to modify the agreement. Also, students could hire their own lawyers to represent them. But I have yet to see that happen. 

If the system is object-oriented, you can use UML class diagrams to document the design. Eclipse has a plugin called ObjectAid that generates these diagrams from the source code (no additional work required). Students can generate professional documentation from their source code. There is jsdoc for JavaScript and javadoc for Java. These require specific comments and tags, but it's well worth it. Source code documentation is important for future development. For all types of diagrams, there's draw.io, Balsamiq, PowerPoint, Visio, and many more. A picture is worth a thousand words. 

This is not a complete answer, and it misses the "drawing an accurate picture of work in the field" goal, but I think it shows an approach worth mentioning. I'm not sure you can show the picture accurately without a hands-on experience with coding. 

Starting languages for non-programers Vastly depending on what is the purpose, but for some people it may be beneficial to choose for a first language a scripting language, that is used only as snippets in a wider context. The main advantage is that you get useful stuff basically from the point zero, and not only after learning half a language. If you stop learning after 5 hours, you may still have some benefit from it. Some possible choices: 

Note: Initially my answer was just about computational complexity, but then it grew a bit, so I broke it into multiple sections and tweaked each a bit. Thanks to commenters for pointing out the details to fix. Understanding computational complexity That may be covered by your "understand better how these structures behave", but it important enough to deserve its own place. It is very hard to appreciate the computational complexity behind a library structure operations. You don't need or should care how things work under the hood, you should be happy with information that given operation is guaranteed to run in "O(log n)" or "O(container size)" or in "amortized linear time". But to get a good grasp what all that O-speak means, you should actually write the code that iterates over a linked list or finds stuff in a BST. Once you have some well set expectations of how things work, you can move on and perhaps never write own containers again - but you will forever remember what happens under the hood when you call some random library method (or at least have a rough estimate, see Certainty about behavior). General knowledge about writing containers (mostly inspired by Buffy's answer) If you ever happen to actually write a container (e.g. one missing in given language), you will not only benefit from specific knowledge about containers you wrote, but, more importantly, from general knowledge about writing containers. There are several reoccurring patterns about containers design, and knowing them from the "internal" perspective certainly helps. Certainty about behavior That one may be important for educational value. Only writing your own structure or algorithm gives you certainty that it behaves as you expect. Built-in structures may often contain extra optimizations and don't necessarily implement any "canonical" structures. They differ in details. Avoiding over-complex library APIs Library containers not only may behave in "non-canonical" way. Their APIs usually contain many additional functions that, while useful in production code, for learning are just unnecessary distraction. E.g. in C++ containers have multiple variants of every method just to allow optimized memory management, or some syntax shortcuts. C# is not very different. De-mistyfying library code Direct answer for question "why do we have to do this": to see that there is no magic. You can do all that things, using libraries is mostly just about saving time. Debugging your own components will likely help you appreciate that libraries are well tested and patched, but should also show that writing similar code isn't something unreachable. 

Find the package in npmjs.com and view the stats (e.g., daily/weekly/monthly downloads). You can sort of gauge its popularity that way. Look for similar libraries and compare their stats. Look at the package in GitHub. View those stats (e.g., # of contributors, # of releases, # of stars). View the GitHub documentation (README.md). Is it helpful, mature, professional? Look at the GitHub commits. Are they recent? Is the repo actively maintained? Finally, just try it out. Sometimes you need to test a few libraries to see which one is better for your application. 

I built a light but fun AI project using the Twitter developer API and a simple Python program to bring my dog Maggie to Twitter. If you send a direct message to @maggielistens, you'll see what I mean. This program uses a version of an old program from the 60s called Eliza. It acts like a therapist by responding to your commments and questions. It uses regular expressions and text replacement to appear like a real person. It won't pass the Turing Test, but it's a fun way to get students interested in AI and programming. 

My biggest challenge each semester is keeping students engaged in class. It's obvious that most of them would rather be somewhere else. I don't know if it's the students, my lecture, or both. I wish I had the resources to present a lecture this way. I believe that generating interest is just as important as the content itself, because this builds a passion for CS that will fuel future learning. How do you make your CS lectures more interesting?