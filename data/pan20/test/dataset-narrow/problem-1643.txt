There are no common devices available which you will be able to connect to those pins to provide wireless communication between your micro:bit and a Raspberry Pi. The micro:bit does include a Bluetooth interface. The best example I could find of using Bluetooth to communicate between a micro:bit and a Raspberry Pi is this Youtube video from user Barry Byford. In the comments below the video he includes a set of links to the resources needed to get everything working. In essence he: 

You could, I suppose, desolder the switch and replace it with a relay or SSR which could be controlled from the Pi's GPIO. The switch is surface mount, which can be a little fiddly to solder with an iron, but it looks pretty do-able. 

My personal preference for getting 240V down to something less lethal that'll work with a Pi is an enclosed switched mode power supply. They're pretty safe to work with, are easily mountable, quite robust, and tend to produce fairly stable output. They're not nearly as cheap or tiny as your current module but I think they're also quite a bit more likely to work, and less likely to kill you. Suitable units in the current/voltage range you're looking for, such as this MeanWell RS-15-5 cost around about £7-£10. The specs for that module are: 

Per previous answers, some text manipulation would be necessary to get the contents of the CSVs onto a web page, and be careful what you're publishing externally. I've used the Android version pretty extensively and it does a good job of finding everything on my home network (and kind of fun to play with on public wifi). 

By far the easiest options for moving large amounts of data between Pi Zeros and other Pis are USB OTG, which has already been covered by Dmitry Grigoryev's answer, and ethernet or WiFi. While USB OTG will work great if your Pis are fairly close together, the run length specification for USB tops out at around about 5 metres. Further apart than that and the time taken for signals to move between devices starts to interfere with your data transfer, resulting in degraded performance. Using ethernet or WiFi will involve a little extra expense, as you'll need to buy suitable adapters for the Pi Zero, but has a couple of distinct advantages: 

See this discussion on the raspberrypi.org forums. I think your issue is likely to be that the Pi doesn't support the big-endian audio format that Java is attempting to record. I'm stabbing in the dark a little here without more code to look at, but I think the relevant section from that discussion is xranby's comment: 

Per the comments below your question, that's just not how USB works. Your desktop is enjoying a variety of advantages over the Pi - a USB 3.0 adapter, superior bandwidth on its internal buses, faster CPU, etc. etc. etc. It's not entirely realistic to expect similar performance from a Pi. The Netgear adapter you've spec'd may well not work as expected in any case - USB 3.0 devices can get a bit weird with the Pi's USB 2.0 sockets despite claims of backwards compatibility. You might want to investigate using a wired ethernet connection directly into the Pi (via HomePlug if you don't fancy long cables), or looking into something like a USB gigabit ethernet adapter. Jeff Geerling, in this article on jeffgeerling.com, claims to have achieved the following on a Pi 3 using this approach: 

I haven't tested any audio options with the Pi Zero aside from the HDMI out (which worked fine for me, but I wasn't doing anything clever with the GPIO pins at the time). That said, your options with the Zero should be the same as with any other Pi. You should be able to use any compatible USB sound card, or a GPIO I2S DAC (the Sense HAT uses the I2C pins, ruling those out) such as the pHAT DAC. I took a quick look at the pin usage of the Sense HAT and the pHAT DAC, and it looks to me like you should be fine to stack the hats up. Make sure your power supply is sufficient to run everything all at once. 

I think it sounds plausible that you've installed OpenELEC, as opposed to vanilla Kodi. OpenELEC uses a different username and password. From the OpenELEC FAQ pages: 

He went on to describe these issues as 'solved' by the tips in this 2i2 related thread, also on the raspberrypi.org board. 

It looks like the camera is just about capable of capturing at the rate you're looking for (50ms per image), although your actual rate may be impacted by other factors (SD card speed, image resolution, etc.). 

To the best of my knowledge there is no terminal access in OpenELEC. There is, per Ghanima's comment above, an option and terminal access in vanilla Kodi on Raspbian, but not in OpenELEC. The instructions on the OpenELEC homepage recommend using Putty to create an SSH session from a remote machine, with the default username and the password . 

This looks like a very early release and may not work/may not work well. That being said, articles from redmondpie.com, and idownloadblog.com outline a method for sideloading Kodi onto an AppleTV. With Kodi installed you can use samba or similar to share content from your Pi to Kodi on the AppleTV. You are, apparently, going to need a Mac running XCode 7 and a USB C to USB A cable. As posted on idownloadblog.com: 

helixtech.org.uk reports success using a Philips PicoPix projector and a couple of minor configuration tweaks. The PicoPix is both USB powered and HDMI fed. 

It isn't possible to say whether you connected the module the right way round or not from the information you've provided. Normally, when using striped ribbon cables, the stripe should go to pin 1 to provide a nice quick visual reference for orientation. It appears you put the stripe to the opposite end of the module board. That's absolutely not a problem provided you did the same thing at the other end. If the red stripe went to the Pi's GPIO pin 1 then you've hooked it up right at the Pi end and wrong at the module end. That's undesirable to say the least - it reverses 5V and ground, and 3.3V and a GPIO pin. My best guess would be that you had the red stripe at the wrong side of both devices (so everything was connected correctly) on your first try but for some reason the LED didn't light up - insufficient power supply perhaps? You reversed the connections on the second try and released the magic blue smoke. 

If you can always reach your Pi on your local network by visiting 192.168.0.1:5000 then the Pi already has a static local IP address. If that IP address changes occasionally then the IP address is being assigned by Dynamic Host Configuration Protocol (DHCP), controlled by your router. You want to make sure the Pi's local IP address is static before continuing. With regard to installing Apache, Flask's documentation currently states: 

I believe those (u092e, etc) are Hindi Unicode characters. Whatever software you're using to convert those characters into speech apparently doesn't handle them. You need to check its documentation relating to non-English Unicode to see if it can be enabled, or switch to another package that supports Hindi text-to-speech. UPDATE With the additional information that the package used is espeak, it looks like it does have a Hindi language option. Unfortunately the documentation describes this option as 'initial naive implementations which have had little or no feedback and improvement from native speakers', so your results may be less than spectacular. From the espeak documentation on language files: 

To the best of my knowledge, no models of the Pi or the Cirrus audio card offer this functionality. Jack detection is generally done using additional contacts/switches in the jack socket which are closed when an object is inserted. The image below shows how this is achieved in the Fairchild FSA8049 switch. Without these contacts it will be complicated, if not impossible, to detect a jack insertion. 

To the best of my knowledge Raspbian Lite is entirely convertable to 'full' Raspbian with enough . It's just Raspbian without some of the pre-installed features. With that in mind, anything that works on one should work on the other, but may require some additional installations on your part. 

There's a tutorial (with a video demo'ing the system performance) posted at novaspirit.com with some instructions on reconfiguring the kernel to support USB DisplayLink devices. It's a little long to post in full. The gist of it is: 

EPICSQt is available from SourceForge here. The installation instructions are provided in that download, in the QE_GettingStarted.pdf file in the documents folder. 

I think you should be able to achieve this with an Auvidea B101 HDMI to CSI-2 Bridge. I'm hesitating to recommend it wholeheartedly, as their website is a difficult beast to navigate and their documentation and software support is minimal. It would be a good idea to take a look through as many forum threads as you can find (in particular this thread on the raspberrypi.org forums) to assess the level of challenge you might face getting the thing to fire up. That said, there's a plausible demonstration of exactly the setup you're looking for in the 'Demo 2/Laptop HDMI to Raspberry Pi 3' section of this video posted to Youtube by user Samir Sogay. It shows an HP laptop running Windows 10 connected via its HDMI output to the Auvidea B101 board, which is in turn connected to the Pi's CSI camera input connector. The laptop recognises the Auvidea board as a second display with maximum resolution of 1280x720 (the maximum resolution of the converter), and allows screen mirroring to it via the standard Windows 10 graphics properties window. I think it's going to be difficult to find a solution that allows you to use it as a touchscreen while it's connected to a Windows machine this way. The touch signals aren't going to be conveyed over the HDMI cable, so you'd need to figure out some way (I'm unaware of any suitable existing solutions) to translate those to something usable by Windows and get them into that machine as a recognisable Human Interface Device. Tricky. 

.exe files will only run under mono. Prefix your file location with 'mono' in your script and it should work. 

If your WiFi connection is working as it should be and you suspect an issue at the NOOBS end somewhere, it's not particularly difficult just to write your own images to the SD card. They're available at each package's homepage - OpenELEC here and OSMC here. You'd write the image to the card as you would any other disk image - the Pi Foundation has a tutorial on the process here. 

You should be able to get Kodi to work with Bluetooth audio as long as you install it into a fresh Raspbian image, rather than using OpenELEC. From Kodi's wiki: 

The best information I can find suggests that it's possible to output 4K resolutions, but at fairly miserable frame rates. The Pi 3 has the same GPU as the Pi 2, so the information should still be valid: Source: $URL$ 

My go-to for headphone output from the Pi is these Tendak HDMI adapters, which include a 3.5mm jack output. They run fine off bus power (no need for an external power supply) and produce reasonable (not exceptional) quality audio. From the look of them they're just rebadged Chinese mass manufactured things, so I'd imagine there's likely to be an internationally available equivalent. 

Per Dave Jones comment below your question, MIPI CSI-2 was never really designed with long range transmission in mind. It's widely used in mobile devices to connect their cameras to their mainboards ('MIPI CSI-2 is the most widely adopted imaging conduit in mobile devices'), which would put the 'normal' signal range at a few centimetres. The best solution I've seen for extending range is the HDMI adapters (such as this one currently listed at pimoroni.com), which have supposedly been successfully tested using 'simple 5 meter HDMI cables'. The spiel posted against the Pimoroni adapters warns that 'The video signal should not show any degradation until a certain distance (yet to be found).Passed [sic] the limit the video signal will be lost entirely.' Basically, the longer your cable gets the worse the signal will become until all you're getting is noise. If you need to put the camera further than 5 metres away I would recommend buying a second Pi, using a standard short camera cable, and streaming the footage from one Pi to the other over a network. You can achieve sub-100ms latencies at full resolution using something like gstreamer, which is close enough to real-time for most applications. 

You need Linux/ARM or Windows IoT/ARM drivers in order to make anything work with a Pi. Maybe your Google Fu is stronger than mine and there are some out there somewhere, but the card predates the Pi by at least 7 years. It seems deeply unlikely that anyone would take the time to create drivers for such a niche item.