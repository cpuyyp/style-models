The name of the identifiers here suck, and I could have written without trouble. I choose putting them in a because it shows how well it can scale. One could also make and chain them with , for the cases where you want only the first condition. You see this kind of thing used in web frameworks, such as BlueEyes, Lift or Unfiltered, for example. 

In Scala, never use unless some API requires it of you; use instead. If you have to interface with an API that returns , convert the result into an . As long as you do that, you can ignore checks, for they'll always be errors: you got a from some code that shouldn't be producing it, or you forgot to convert some return value to , or else you didn't even know you had to. Use or -- seems better suited, but either will do with the proper conditionals. Also, do not use -- use . Yeah, it looks weird, but / is idiomatic, and faster. There's a function that is used for parameter validation. Either or will do. 

The first two being means this cannot be reused. However, if you turn them into , then will already return a valid iterator. 

Finally (unless I missed something), the inside can be avoided simply by using multiple , and statements like this: 

The on can be replaced by using . I'll let you work out for yourself how to do that, now that I called your attention to that method. And, yes, it that method works on as well, though it doesn't appear on Scaladoc for Scala up to 2.9.2 because it is added implicitly. I suggest you use the nightly scaladoc to look things up -- the documentation there is better, though it may show things not available on release versions, and so is the tool itself. 

I wanted to know how efficient all that set manipulation really was, so I benchmarked it all. My solution is two order of magnitude faster than the one in the question, and three than the accepted solution for the greplin input. Since the big-Oh is different, this would change depending on characteristics of the input and input size. 

We'd usually make the solution more functional. That is, move the "fizzbuzz" logic into something that returns a string, and use that: 

Scala has an unfortunate overhead compared to Haskell to do these things. Also, Scalaz will be able to do a bit more in the next version, but this works with 6.0. The gain with Scalaz is not, however, legibility or conciseness (in this code, anyway), but of composition. For instance, in the current Scalaz we can abstract most of the body of like this: 

For this reason, in my mind, it makes more sense to add the additional padding to the body. Then both the container, and container-fluid class work as normal. Also, you can eliminate all of the extra unnecessary container-fluid divs on the page, only one is needed. This will make it a whole a lot easier later if someone else with Bootstrap knowledge needs to work on your site and it will keep the markup to a minimum. The next thing you can do to streamline your markup is remove all of the col-sm-12 classes from all of the places where you have both col-xs-12 and col-sm-12. This is unnecessary. Think of classes as additive. If you want your design to behave the same from one breakpoint to the next you don't need to add a col class for that breakpoint. While you're at it, you can remove some of the extra rows. The only purpose for the row is to break up the content where you need to ensure that the floats are cleared. So, in this case, you can use one row for your main content and just add the row class to your footer tag. In keeping with the some of the key recommendations as the previous post, you should also remove the invalid markup, use the proper semantic tags for headings and style the html selectors instead of adding unneeded classes. So now we're down to what to do about those images. Two things need to happen: 1. At all breakpoints images need to expand beyond the padding and touch the edges of the screen; and 2. If the images are set into columns that don't span the full width of the screen, the far left and far right images need to retain their inside gutter. To accomplish this you can wrap the images in a containing element and give it some negative margin, just like how rows work. In keeping with the mobile first approach, I created three classes: .col-img-full, .col-img-left, .col-img-right, all with margin: 0 -35px; applied. Then I added a media query, to remove the inside margin for just the right and left images with two rules where the left image gets margin-right: 0 and the right image gets margin-left: 0. This makes your design much more flexible! In the event your client/boss/whatever, wants to make a small change and add a third column to the design. No problem and no extra markup or css is needed, just drop your column in the middle with your image and everything still lines up nicely. Okay, finally, let's deal with the navigation. The container-fluid in the middle of your nav was making a mess of things. This is partly why you were getting the scrollbar at the bottom of the screen. Plus, the extra markup was potentially limiting your ability take advantage of some of the core Bootstrap nav features, such as adding navbar-right or navbar-left classes if you want to change up how the elements float. So, I brought everything back to basics and just styled the markup to match how your existing design looked on my screen. I didn't really understand what you meant by "centering the menu" because I see your codepen with the uncollapsed navigation floating left. I made two additional small adjustments to your css for the nav: 1. On my screen the arrows after the links were unaligned. A better way than trying to tweak the padding for those elements from the top and adjust for margins at different resolutions is just to position them absolutely from the bottom. 2. Also, I found that your navigation was breaking onto the next line at certain resolutions, so I added a media query to make sure it stayed put at all resolutions. Here's the final markup: 

This is longer, and handles nullness in two separate places, and doesn't protect against nullness, but I think it reads much better. To get more than this I need Scalaz: 

The solutions given are simple but have quadratic complexity. I tried to improve upon it, while keeping it strictly functional. The solution I came up with is huge, though some of that resulted from breaking it up into smaller pieces for readability. While it is much faster, I'm not sure if that's due to an improved complexity, or just better heuristics detecting when no more palindromes are possible. I feel like it could be improved, perhaps with some Scalaz tricks. I see a couple places where I could remove some code by using an Scalaz abstraction, but not enough to be worth. On the other hand, I'm not particularly familiar with Scalaz. So, here it is: 

That is, if used as you did. I'd make it an instead, and initialize it at creation. I'm not sure would help you here, but might. I just don't think it is a particular good fit for BFS, but it might just be ignorance on my part. 

Ok, I'm changing the answer now that I understand what you are doing. The main problem here is -- while Scala people, in general, don't mind special operators, they don't add operators just because they can either. You can replace with the existing just by adding to any one of the terms. Views aren't often used either, and it's important to have a very good understanding of how they work if you are going to use them, and it's not that easy to gain performance with them, since the machinery they use to support non-strictness is quite heavy, and not everything takes advantage of it. For example, will create a new collection before and are applied. Views can gain when you have many mapping/slicing steps, and few elements of it are ever used. Most of the time, iterators will gain you much more performance, at the cost of the mutability problems iterators have. If you want to reduce the number of times you iterate through the list of proportions, there's at least one place where you can simplify: 

And, yes, was a good start, and for new comers to FP it is not obvious to implement something that will stop at the first incorrect size in functional style -- at least on a strict language like Scala. You'd either throw an exception or use recursion. 

One good technique at eliminating vars is recursion -- it can certainly be used in this example. Alternatively, you can identify a common pattern, such as fold, traversal, etc. For example: 

This is a fold, not a scan. A scan produces something with the same number of elements, and change the elements. A fold produces something new. 

In other words, for every prime you calculate the multiples (up to the limit) and store them in a boolean array (you could decrease the memory by a factor of 8 by using a bitfield, just didn't want to complicate the whole thing). Since "being not a multiple of any number lesser than itself" is pretty much the definition of "prime", you already know if a number is a prime when you reach it and it's not marked in the array. And if it isn't, you know that it's a multiple of some lesser prime - and thus, all it's multiples will already be known as non-prime, no need to re-calculate them. Your code takes around 217ms to run, mine takes 17, but on the other hand, mine takes way more than 12 times the memory, even if you used a bitfield. Note: After using google and trying to remember what I learned in school, this is probably a variation of the Sieve of Eratosthenes and I have no idea how good this implementation is. Probably there are much better solutions out there, I guess. 

Well, what you do not actually test is: Are the login parameters passed to the LoginService correctly? In your example, you are simply assuming that the next login will fail or succeed, but you do that completely ignoring the actual parameters. Especially for the successfull test I would use the actual expected parameters instead of . For the not successfull test you could do the same, return a result with if the login data is the expected value (otherwise it will be null). This way you don't just test the way the LoginRestService handles the responses from the LoginService, but also that the LoginRestService gives the correct parameters to the LoginService in the first place, eliminating one possible cause of errors. 

JUnit will fail anyway if an (unexpected) exception is thrown, by creating an Error (instead of a simple failure). As you do not catch any other exceptions (which means every exception fails your test anyway), you can simply remove the try-catch block, as your test case will still fail then if the is thrown. 

Normally operations on a hashmap should be pretty much constant (O(n)=1), so it's something like O(n) = n + 2*m (number of characters in the String plus twice the amount of different characters in the string, since you iterate twice over the map to find the max and the corresponding character). Memory should also be pretty much linear, since you are storing one int per different character. 

As iterates once over the map, iterating again over it to get the corresponding character is pretty much wasted. You could remove the call and start by iterating over the entries and remember the one with the highest count, thus saving the whole iteration ( getting a O(n) = n + m runtime). Your hashmap will probably need to resize itself once or twice (at least). You can reduce the need for that by choosing a good start size for your hashmap (aprox. the number of different characters in your string, which depends on the language), but normally that shouldn't be that much gain (depending on the length of the sentence and the amount of different characters in the sentence).