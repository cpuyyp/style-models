is such a pain in the back. They made it so difficult to connect to WiFi and then re-connection does not work either.. or setting it up is really weird. It may take a little bit more space on your card but I love using wicd-curses. 

You can use a USB GRPS/EDGE/3G/4G modem like this one. Most of them have Linux specific drivers and easy to setup. ( You can easily get on on eBay auctions for under Â£10 but they are usually locked to a network ) 

The simplicity of these is that its a transparent UART channel so you can add as many transceivers as you like and all the nodes will get the data. You need to create some kind of simple model based on JSON, where you embed an ID, the NODE you are interested in a multi tenant environment, and the command or data. JSON is easy to read, compressed well when theres loads of its better than XML, or any other custom models. 

If they are USB cameras... you can preview the stream on demand using any software you like.. as long as you say which USB device you are using. You could even use a desktop application to take screenshot or short videos. Since you can use a desktop you could use any remote desktop program you like to join and view the files or video. You can also create scripts to take snapshots from USB devices over time or short videos - This way you can log in and just view the recent recordings or even stream them down to your self using uv4l webgui 

As far as I know the first time boot-up is fully automated then reboots and you have access to the following remote management resources. 

You are running Windows IoT core on the Pi. You can use Visual Studio Community to develop in a range of languages for the Pi on IoT. With C# you get the benefit of remote dubugging which is really usefull, and requires no setup (which is fantastic) - You do have a few flavours though, and Pi is slightly limited, in sense of multi app but fully capable of running a single app. You have Console applications and UAP C# I would suggest using UAP as it allows you to easily design slick GUI, and its universal so it will run on Windows 10 phones, Tablets and PC's too. (And Macintosh with Mono) You should have a look on the Microsofts Official project gallery, for samples and ideas. $URL$ Happy Codding. 

If you have an old laptop you can use that and install it there. Just to try it out on your machine you can boot from the USB drive. BIOS must be able to boot from USB !ACTHUNG!WARNING! Make sure you select the correct drives during the entire installation process. Namely Partitioning and GRUB sections. It may cause irreversible data loss! Lets Start 

Now you can write text by typing as usual, and it will go to your Arduino via minicom, or just read the output if you logging stuff on the Arduino and dumping it to You are correct, you can use screen on the Pi while on a SSH session. is used to execute things in a separate "screens". You can use many screens running and switch between them via one SSH session. 

This in memory process can take some time to process the video file. The artefacts that you experience are caused by unusual framesizes, weird framerates or really big keyframe spaces. If you see this is means the video file has its keyframes very widely spread apart and the player and hardware was not able to fully load the segment of video into memory to chop it up. So it loaded the best P or B frame and started playing from there. Sometimes strange framesizes cause corruption during splitting of video in memory and these artefacts are produced. There are so many variables that cause really bad video experience- but its mostly because people encode video without actually understanding how to do it properly, using bad examples, or built in high compression profiles that are designed for continious streaming, like webcam feeds, TV feeds but are used for stored video instead ! The video decoders on the Pi are designed to decode video and work best with video containers that strictly conform to specified standards or streaming profiles where you cannot seek. 

Each and every SD card, even Hard Drive always has a different amount of usable sectors. This is a common issue when cloning your expanded Raspbian and trying to rewrite it to another SD card, as it most probably has less usable sectors. The same may apply to the the exact same card, due to different sector alignments caused by partition aligning and various other little things. Usually these get overcompensated so the actual image is slightly larger than the SD card that way. 1) One way to overcome this, is to setup your image from scratch without expanding the file system to 8GB. Dump the image (which will be 4GB), then write it to another 8GB card. Boot the new card up and only then expand the File System. 2) You can reduce the file system on the existing image, using by 100MB for example. The problem is you only resized the file system but the image is still the original size. You would just need to redo the DD and limit the size by 99MB (so there will be roughly 1MB of unused space in the image), not to hit the newly resized file system. This will be sure it will fit all next 8GB sized cards. I find option 1 easier and faster to be honest but we had to learn the hard way. 

I had more luck with running a script file instead of running commands directly. This is most likely cause by character escaping that is required when passing args directly to bash. Making a script file with the commands inside them could solve the problem you are having. 

You have to setup samba to allow anonymous/everyone/guest to be able to connect. This takes away the error message you. This is deprecated ... 

The list goes on and on. Essentially you can use other designs to fuel project but always try and shop for parts before buying them, then place them on the PCB, as sometimes a part that can have an alternative may be very expensive and only needs a small design change to save allot of money. Now after all that, have a CLOSE look at the IO board that is going to be released soon for the module. You will realise now, that things are placed deliberty in certain places and not just at random. 

The best place at the moment to look for any supporting device libraries like that would be at the Microsoft's IoT Github page. If you cannot find a C# implementation anywhere then its likely there is none yet. You would have to find a C implementation, like for Arduino and try and see how its configured, any caveats, etc and try to port it as you suggest. It would be brilliant if you could get the IoT Git, do your implementation in somnething like "samples/I2CBarometer" - following the conventions (directories, file names. Similar to the Compass Sample, using an interface to allow various chip 'drivers' to be implemented) and do a pull request. You may have to follow some other steps for doing PR. It is likely somebody may accept it, comment on it, etc. Even if takes a while, your code will be there for other to use, in the right place and hopefully indexed by search engines to be found. If you need more help feel free to comment below to notify me (I am not associated with MS but willing to help the community grow). Maybe first get your base C# code going then it can be converted into a Sample and Interfaced ready for Git. 

There is a custom source called nginx-rtmp - This works really well but you need to do quite allot of things before it works. It is awesome because it has allot of built in features and supports other streaming protocols, like HLS or embedding MPEG-DASH into websites, not just RTMP. It is extremely efficient in repackaging the video stream into flv or mp4. Here is a blog post on how to get it working. The only serious prerequisite is ffmpeg needs to be compiled on Rasbpian (Do not use the repo one it is slow) from the newest fork. I think on Arch it has the correct ffmpeg. This takes 5 hours on the Pi. Try and find a compiled version or use qemo to cross compile. But in a nutshell using nginx 1.4.1 (you can try newer if you need to) 

Since you mentioned your background is in .NET development then I personally (because I am a NET'tie too) would recommend Windows IoT I would have thought you already have Visual Studio but even you do not you can download the community version for free. You can develop UWA (Universal Windows Applications) using XAML (really easy layouts) with C#/VB whatever your flavour to do simple things like timers connected to HDMI screens. Windows IoT supports GPIO pretty well by now. Since you are .NET developer you will also appreciate the ease in debugging code running on the Pi in your visual studio over the network by just running in debug mode. The nice thing about UWA is that you then run that same application on any other Windows 10 device, like a smart phone. So you could use a smartphone or laptop to control the count down timer all form one application over WiFi. A great starting point for .NET development on the Pi If however you choose the route of going with Linux/BSD then I suppose Python would be the easiest way to get into it from .NET - Python works really well and you can also use Visual Studio community to write and deploy Python to raspberry Pi. I am not 100% sure about debugging features? but I have used VisualGDB (paid) but it works nice! 

But if you really insists on using Visual Basic... you are luck, Mono version 1.2.3 fully supports compiling Visual Basic code to IL on the Pi. I have made a few application using Visual Basic .NET 4 Console application that do almost anything you want it to do- The longest part is installing MONO and then you can just execute EXE's compiled with the MONO compiler :) Ohh look, free Visual Studio 2013! Thanks new Microsoft. 

I currently use this one at home because it allows me to connect my existing land line and set up dial routes inside the SPA3102 to select if it should use landline, like toll free numbers(because allot of VoIP and mobile providers charge a small amount) or VoIP 

That 3rd party repository is hosted by a member off the Pi forums. They compile the latest versions of the gst-omx project and publish the files there. You can check if it recognised the Pi's hardware capabilities using this command 

Print out the path somewhere and you should be able to find it. Its possible the default path is buried somewhere deep. 

Ideally you will want a separate USB Powered HUB with its own power adapter, in your case an ATX power supply. This is a good power supply for 3v,5v and 12v as its clean and does not suffer from voltage droppage on loads and peaks. 

That is a snippet that will spit out the serial port names while connected with a debugger in Visual Studio. What I recommend, is to create a in the loop, then you can look at the ID to see if it says , , - etc etc 

I would suggest backing up your Pi and installing the latest official raspbian image from scratch. Do an upgrade and firmware upgrade. The reason I suggest it because it has wpa-supplicant pre installed and all you need to do is add 3 or 4 lines in to the supplicant file. This is different because the interfaces file uses wpa-roam. Thanks to that line if you loose connection wpa-supplicant will try to reconnect to the next access point in the file. If there is only one it will try to reconnect to that one only. I was messing about for weeks with an old image that was upgraded and had lots of rubbish. COnnection was dropping out all the time and it was driving me mad. I put on the latest image and my wifi is stable now. I could not run for an hour or more -with the new install it is going for over 24hours now. I am not sure how many times it reconnects but I know it is connected the whole time now. Interfaces file 

Go to $URL$ and downlaod the .NET & Mono version, no install. You may have to go through registration to get the download. Extract the contents and manually reference the RT DLL (Don't forget to set copy on build on the reference property pane, so the DLL gets copied to /bin on publish) 

omxplayer is pre installed with the latest (for a while now) and also you can do the same to play video to a selected output device. If you get permission error try putting in front of omxplayer 

Each of those have some kind of communication library to create Net Sockets, like virtual UART ports where you can send binary or text data at a high level while the libraries handle error and flow control transparently. 

There is an excellent post here with step by step. $URL$ I do not think it is easy to get the server side of SignalR to run on Windows IoT yet. It is possible to get the server going with Xamarin Mono on Debian with NoWin HTTP Server. The issue is that SignalR requires to run a dedicated HTTP server and that is not possible on the Core version because of sandboxing... (but maybe that will change or there seem to be some hacks floating about) 

The answer is yes. Yes you can use any transceiver you want. Bitbang (I bet they did not teach you that in .NET classes) but better use the hardware UART! 

By studying the schematic you come to realise there are 3 more voltages (4 in total) used on the Pi. 

Well there are 2 solutions without using extra software. First solution is the get your Pi to call you at the office. But you need to enable port forwarding at the office though. I am not sure if that is possible for you. You basically get your Pi to SSH to you, creating a reverse proxy so to speak. Second solution is to get a VPS, like say digital ocean droplet. Then both your Pi and Office call the VPS (both Pi and Office PC initiate outgoing connection which then automagically opens a port in NAT for that session) This may require a bit more config on the VPS but essentially like double reverse proxying. Otherwise, without opening a port on your router (NAT) - The router doesnt know where the packets need to go to. A bit like a firewall but dumber. When you call out the router knows where to send the replies too. If you cannot log into the router you can try doing UPNP. A home router should work fine, more commercial ones have this disabled for most ports. You can bypass some strict firewalls by SSH'ing over port 80. Some more clever routers inspect packets to see if it is truly HTTP traffic and not some other stuff going on. Bypassing that, the only way I have done that is to have a 3G/4G connection to bypass the corporate firewall.. sneaky.. but they can't block that traffic.