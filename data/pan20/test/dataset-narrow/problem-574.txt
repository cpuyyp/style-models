the values , â€¦ will already reside in your cache, and you don't have to access your main memory for those. However if you store only pointers in your , ie. 

As you can see, a list of pairs is enough to capture everything, since you're going to traverse all of them either way. It also leads to a complexity of \$\mathcal O(K)\$ (*). If you're concerned about the order of elements, a single at the original definition can help. However, even this might be an overkill if you never intend to increase the number of factors. If all you want to do is to solve fizzbuzz, you can drop down to a guard solution: 

Note that due to ' type signature we don't have to use at anymore. Follow naming conventions and use existing library functions Still, our function is sub-par, since we don't follow the common naming convention () on the one hand don't use library functions for our advantage. So let's say we have so that repeats the times and collects the results in a list. Then we can write 

I've switched the order of and so that both occurences of are closer to each other. Of course, this means that we need to change too, but that change isn't really large: 

Still too much garbage collection, but that's fine for a start. Additional discussion Try to avoid . Instead, you could have used 

Ah, that's a definition problem. What's minimal? What's "smallest"? Your program is short, but a single additional function removed some repetition which can lead to a technical debt. That function won't increase the size of your program, though. 

There are other ways to write , but I they differ on personal preference only. Use the standard library is in disguise: 

Depending on whether you write ANSI-C or C99, I would defer declaration of variables as long as possible. For example, at the moment it's easy to accidentally change to some bogus value, or forget a and accidentally check the after the loops or similar: 

The squiggly line () and the aren't self-explaining, but the is. So we get the expectation that will be a pattern. That pattern breaks down in the next line, where (follows the pattern), but : 

We expect the first argument always to be some kind of time measurement. We also expect the vector to be conform to the time's unit(*). From this point of view, it makes sense to encode the in . However, this yields the question why the other side of the spacetime, space, isn't encoded in too. (*) strictly speaking, we're not encoding time's unit but only type. Either way, you probably want to allow only values. Furthermore, you want to make clear what unit uses. We could use a phantom type, e.g. 

You use explicit recursion, which is fun, but not always necessary. can be expressed with and , for example: 

Note that I've removed 's type signature. This is somewhat controversial, but the general rule-of-thumb is that you want type signatures at the top-level and usually leave the type-signatures at the not-top level, unless GHC gets confused. The (small) problem with type signatures in and is that the type parameter in is not the same as the one in . is necessary for that. So lets get rid of that. 

This will probably be the last one in the Zombie series. Motivation Zombies! The dread of any barbecue. The grilled brains are sticky, their odour is icky, and they never stop talking about crossdead. But that is not the kind of Zombie we suffer from. We are looking for easy-to revive question Zombies. Questions, that have at least one 0-score answer but count as /unanswered. A revival just needs a single click in those cases: an upvote. We only need to find those Schroedinger questions and cure them. The first cure accidentally included closed questions, as did the second. This query remedies this fault and only looks for the Zombies that haven't been thrown into jail. It also includes an activity index (see below). The goal The previous questions have shown that the requirements on the query were not really communicated well. This time I'll try to list all requirements for the query: 

Ownership could take a slice instead of a vector. That way it's more general. The actual implementation is left as an exercise, but it's more or less the same: 

This will return if returned , and the number of read characters otherwise. Putting all back together I omit the functions I've already covered above, but if we use them, we end up with the following program: 

You need a C++11 compiler for this. Alternatively, move into the private part of your class declaration. The move, assignment and copy operations can be defaulted: 

would not compile if was . Check 's return We should really check whether returns . Split functions doesn't follow its name completely. We find the first recurring letter on a set of strings on a per-string basis. That sounds perfect for a split: 

The rise for power Let's start with . First of all, there's a better algorithm for \$b^e\$, which takes \$\mathcal O(\log e)\$ instead of \$\mathcal O(e)\$: $$b^e = \begin{cases}\left(b^2\right)^\frac{e}{2},&e~\text{even}\\ b\left(b^2\right)^\frac{e-1}{2},&e~\text{odd}\\ \end{cases} $$ Implementing this is left as an exercise. But it seems like you want to use only in , since it doesn't work with negative exponents. Therefore, you should reduce its scope: 

I admit that is a bad name in that context. might be a better one. By the way, we cannot use or here, since that wouldn't merge the map values. Try to relax your type signatures* is fine, although you could relax its type. Also, is against a function name. You can use safely in this context. 

is provided by , so no reason to implement it yourself. Also, try to avoid in recursive functions or accumulators, as it turns \$\mathcal O(n)\$ algorithms into \$\mathcal O(n^2)\$ ones. Encapsulate often used functionality in a function You often use . That's somewhat error prone as you can accidentally forget the file name. Instead write a small function that takes care of the for you: 

The steps 0 and 1.5 are missing. They handle the current value and the range of valid values. Coming up with them will be the crucial part. By the way, you usually don't use in a binary tree. But that depends on your use-case. Also, you have memory leaks. For small examples, there is no harm not using : 

But let's say that you don't actually know how many points you have. Let's assume that someone wants to check a many points. Suddenly, the memory usage of your program explodes: 

If you don't want to re-use or , I'd go with and your third approach. Congratulations on your first approach, by the way. I've seen raw-pointer usage going wrong too many times, and it's refreshing to see some clever use there. Well done. But that's more or less the way you would do it in C (sans template and , of course). But you will probably admit that working with pointers at that point is somewhat a headache. Both and (as pointers) can be expressed as and for two suitable and , like you did in your second approach. Either way, unless you really need to use raw pointers use either smart pointers (e.g. ) or (better) full containers like . 

This is especially important to screen readers or other users that look for a structure. A blind person can decide to jump over a list; it's much more harder to jump over breaks in a paragraph. So check what tags like , and so on mean. Not only do they carry some kind of representation (this should look like a paragraph, this should look like a headline), but also meaningful semantics (this is a paragraph, this is a headline). Also, the code gets easier to read. If you want to change they appearance, use CSS afterwards, e.g. 

Don't repeat yourself. If you notice that code is very similar, ask whether you can use that similarity. Express functions with other functions. Avoid in recursive calls, as it will add another factor to your time complexity 

This is a valid place for an exception. A function has only a single return value, so it can only tell you that something is wrong with an exception*. Exercise: Try to use that function in your code and handle the exception. Also show the exception to the user, they're probably interested in what went wrong. You should use the code similar to 

Add type signatures is missing its type signatures because I don't know the ones of and . Always add type signatures to top-level bindings. Not only will it serve as minimal documentation, but it will also make sure that the compiler does not infer too general types or types you didn't expect. Document complicated expressions and should get some documentation. Bottom line Don't mix parsing and arithmetic, at least for arithmetic tests. It's messy and hard to read. Both and are easy to write without any parsing at all. If you were going for code obfuscation: kudos to you, that was brilliant. 

but that's left as an exercise. Don't use Single-letter type variables are used in template declarations, but never with . This looks like a bunch of declared template functions: 

Compare the following two lines. Both do the same, but which one would you rather see if you need to change your code drunk in three months, with only 5% battery left?