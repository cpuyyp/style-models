Second, you can call on each element of at the outset which eliminates the need to specify an value to (and thus reducing all the calculations by one call to ). It also shortens the arguments to since duplicates have already been eliminated. 

This last is important; if you don't know where the code is slow, you don't know where to apply effort to speed it up. My comments are that, if you have a function that is doing some work, all the information that it needs should generally be passed in as arguments. It took me a bit to figure out what and (after I overcame the cognitive dissonance of thinking was itself an error). 

I'm not clear what you are asking about combing function; you can add an additional argument which is a character vector which then the code just has a series of if/elseif's checking that parameter to see which algorithm to use, if that is what you mean. 

If a streak must have at least one , how can you have a streak of 0? The example here (and the following example) are consistent with a definiton of streak of "the number of consecutive 's preceding each ." I'll continue with this interpretation so that it matches the existing code. Now to improvements to the code. The initialization of can be simplified because is the default numeric value, so the first line can be re-written as 

The first two lines together create a 0/1 vector corresponding to whether the value in was (1) or (0) (and uses the fact that it must be one or the other of those values). This can be done as one statement, using the fact that and become and when converted to numbers. 

Based on what I've seen on Firefox 53.0.3(32-bit), on Windows 10, my implementation is around 5-20% faster most of the time. You can try it bellow: 

This code was written purely for fun, but that's not an excuse to write it poorly. Still, I feel that there's something to improve on it. Besides of any performance issue that there might be, and some readability crimes, what else can I improve in this code? 

In the name of all Javascript developers, I thank you for taking this very simple step! You have no idea how much is helps us and helps you! 

The method name should be . Boolean methods begin with , like if you were asking a question. Since you are 'asking' if a directory has some defined attributes, you should reflect this in your method name. Based on your current name, I wouldn't expect it to return if it had a file there. One example of this is the method . You have another example on the following line: 

You are extremelly inconsistent with your backticks. Either you use it or you don't use it! Don't mix both, please! 

And to improve performance, you don't need the . It's a waste of time and CPU power. Also, why instead of ? And why not an array with these objects? I would rewrite the whole thing as this: 

This is nowhere perfect, but it is better than storing it in plain text. This is just a tad better than nothing. Still, it isn't safe. 

This will have the exact structure you wish. Simply use to access all values. And done! An alternative with 0 lines of code! 

I make a vector of all the indexes higher than , and use that most functions are vectorized. For example, with equal to 1, (and picking equal to 2) working the statements from inside out: 

The last simplification uses the fact that a function returns the last evaluated expression by default. I don't necessarily recommend doing that because with compactness comes a loss in being able to see what the computations are/mean. (To understand it, you must essentially reverse the steps and break out each transformation separately to see what it does and to figure out why.) Looking at it again, the conversion to numeric is not a necessary step to determine ; you can operate from directly: 

You can avoid appending to vectors (which can cause re-allocation of space and can considerably slow things down in principle; though in your case of only a length 10 vector that shouldn't be noticeable) if you allocate them to the needed size initially and then assign within them. 

Your approach seems reasonable, but there are some simplifications you can make. First, your construction of is needlessly complex. This works just as well: 

Finally you can eliminate some single use intermediate variables. This may not appreciably speed up the function, but it does make for cleaner code. 

Second, you replace with , and then test against . That means you are replacing both 's and any 's in the data. If you only want to replace 's, just replace those without recoding them. 

Further elimination of duplicate work would involve recognizing that higher order interactions, as you are determining them now, are repeating the intersections of the lower orders (that is first intersects and and then intersects that with , but the intersection of and was already determined). And "first" order interactions are just the arguments passed through (as they were simplified in the previous iteration). 

Your validation is scaringly non-existing! You currently don't even check if has the method . You don't check if is an object! Here's how I would do that: 

Besides this line being repeated, it also has the number of rounds to run. You should create a constant for that, at the top. 

This should do it for you. It throws an if the imge is invalid or if it can't write to the location. 

Notice that you have to use instead if you are using this in JSON! As I refered earlier, I would review it as an object. 

But I'm still not happy. The regex don't need the around every word. Or at all. Basically, you could write both as this: 

The on the same line is target of discussion. In my opinion, it should be in a line on it's own but most people prefer this way. Other things like this: 

Remove . It's useless there. Change the id to Give the class to the . The is the one that will control the width of your . It makes sense to set it this way. Closing in the same line Since you are using jQuery, later on you may want to use the pseudo-selector , which won't work if you have newlines in it. 

While you're doing right in using (the equivalent of) , you are forgetting that can be called, breaking your code. My suggestion is to use something like this: 

As @Dan said, you are re-re-re-re-re-forcing jQuery to painfully look for the header, every time you scroll. Can you imagine how slow that is!? I will take @Dan's suggestion and change it a bit: 

The comments are good; I copy them here so this question has a "proper" answer, and add some my own: 

Then determine what the algorithm is that you are trying to do: Looping over each element of the first column of z, skipping any missing values, compare that value to every other value to the end of column. If the current value and some subsequent value differ by more than some threshold (in absolute difference), set that subsequent value to NA. R is a vectorized language, so explicit loops are often not the most efficient way to perform an operation. Let's vectorize that inner while loop. 

I am assuming that the call to is not what is taking most of the time, so I'm not including that in my analysis. One thing that is slowing down your code is that you are assigning to every iteration of the loop (well, every iteration that is 0). That could be pulled out of the loop since it only needs to be done once. 

In your code, is not defined. Presumably it is some threshold value, since it is used in a comparison of absolute differences. First, reformat your code so that I can better determine what it is supposed to do: 

That is, generate all the answers and guesses, check for each one (vectorized) which (staying or switching) would be a win, and then accumulate those results. The rest is just to put the data in the same format that your function already had. 

Your interpretation of the code is correct, but I think that it could be written more idiomatically. But before getting into that, the textual description of the output and the example output don't agree 

Performance: Performance is quite satisfactory. It takes around 2.5s to search 9-bytes long repetitions, on a 8.58MB string, on my machine, using Google Chrome v47.0.2526.106. Using IE11, it takes over twice the time (around 5.6s)! Screenshots: Google Chrome, IE11. The time it takes is always around the same (with very small variations), which is a good thing. Running this code on a string that is 10% the size will take 10% of the time. That is, for a string that is 0.86MB it will take around 250ms. This is the code used to test: 

As far as I know, it is working as it should, returning when expected. Is there anything else I can improve on this code, regarding performance or readability? Or even a better way to do this, without that pesky ? 

Still, there is no validation of the data. And there's no way to pick 0.5â‚¬ (50 cents). You should look into that. 

Created a few variables at the top, with needed information. Created a loop to go through all the elements Reduced the number of local variable to the bare minimum Removed global variables being declared inside the function 

If you want to support older browsers, this is required. Otherwise, just ignore this, since all modern browsers support it. (Partially or completelly) 

What's wrong? The names! implies some actual text, but you have a . is alright, but it is actually . And that is a . I propose the following rewrite: 

This function should do 1 thing and do it well, not a bunch of them and doing it ok-ish. The already-mentioned readability Variable names should be descriptive. Example of variables you have: