My next step is to see if rebooting helps but I am hoping that there might be an explanation and a way to prevent this in future (assuming the reboot doesn't help). Later ... a reboot cured the problem, but I'm still curious as to what may have happened. 

WiringPi is a C language interface to the GPIO pins including I2C. It can be used to access the Wii nunchuck. First of all, the nunchuck is an I2C device on address 0x52. It expects to be initialized with a write of the value 0x00 to register 0x40. Following that, sending a write request (without a register) of value 0x00 causes the nunchuck to return a simply encoded sequence of data which includes: 

There is an integrated circuit (IC) called the MAX7219 that is designed to drive 7 segment LEDs. Specifically, one IC can drive 8 at a time. It also has a second mode which allows a single IC to drive 64 LEDs in a matrix. Putting it another way, in your example, one MAX7219 could drive 8 columns of 8 LEDs per column. The MAX7219 is drive by a protocol called SPI. Since the MAX7219 is an "input" only device ... one needs 3 pins to drive it. A clock, a chip select and a data pin. If you want to drive multiple MAX7219s you have some choices. First, the MAX7219 can support daisy chaining to any length you desire. For example, if you used 10 MAX7219s you would have an 80x8 array. If you used 20 MAX7219s, you would have a 160x8 array. An alternative mechanism (one I don't necessarily recommend) is to have all your MAX7219s share the same clock and data line and use the chip select to specify which instance you are writing to. A whole different approach would be to use NeoPixel LEDs. These are LEDs that can illuminate in a variety of colors and brightness's with usually 8 bits for each of red, green and blue. These LEDs can be "chained together" with no obvious limit to their length. You could then "snake" a chain of NeoPixels either up/down or left/right achieving the matrix you desire. Because NeoPixels are highly timing sensitive, I use a cheap Arduino as the driver for the NeoPixels and then drive the Arduino through communications from the Pi ... basically an Arduino becomes an LED driver module with the content logic coming from the Pi. 

then it does not matter if the connection comes up right away or not, your code will wait till it does, then execute the main body of the code 

I think MUCH larger difference will be in how much power the display uses based on its size and type rather then the control signals you are feeding it with. An 20 inch LCD monitor over HDMI is going to draw way more power then a small SPI screen. And if you are working with the same size/type of screen. I still think the large draw for the screen will make the small difference in power consumption between the two types of communication. 

Is there any way to get these to work, or possibly a different way of a approaching this. EDIT: full stack trace of above program failing 

The solution comes down to a couple of issues. All of them are related to the fact that when google home starts the python program it does not do so from within the programs directory, so any local files that do not have full path names are not found in google homes working directory. python's import will look at its installed packages, and also at the current working directory(and others possibly) imutils needed to be installed "globally" rather then just living in the program folder 

I am testing out some I2C connected hardware and my C program is working fine using Wiring Pi. However, what I wanted to do was read a byte or write a byte to the slave device from the shell. I looked at Wiring Pi's command but couldn't see any obvious flags to allow it to read and write from I2C. Does anyone know of a shell command that I can use to read and write data through I2C that runs on Raspbian on the Pi? 

One solution is to follow the same recipe that you would follow if you lost or forgot your password. Here is a good article here: $URL$ Basically, if you follow that article, and reboot your PI, you will be in a root shell prompt. From there you can edit your root protected files and undo the root shell start ... reboot again ... and all should be rosy in the garden. 

I appreciate the PI4J project and the access it provides to GPIO from Java (my language of choice) however, compared to C, Java is much slower. Normally this is not a problem but I was working with accessing the HC-SR04 ultrasonic TX/RX and I needed to make timings at the microsecond level. For example, to measure a distance of 10cm, I need to measure a pulse that is high for only 590 usecs. My belief is that Java is too slow for these rates. When I wrote my app in C, it was more than fast enough to take a measurement. However, I only needed to report the measured distance every second to my user. This meant that I could write my interfacing code in C but write the remainder of my logic in Java. This worked great. Using Java's JNI, I could call "wiringPi" directly and without issue. However, prior to calling the wiringPi APIs to change the state of pins and watch for changes, I have to call wiringPi setup functions including defining the input or output direction off a pin. I figured that I could use PI4J to setup my environment and then call C to perform my measurements. This appeared not to work and I had to do all my wiringPi APIs from C and ignore the PI4J library altogether. And with this pre-amble, now the question. If I wish to make direct wiringPi API calls from a C function and the C function is called from Java via JNI, can we "mix in" the use of PI4J in conjunction with direct wiringPi API calls? 

Looking for something that is grounded, metal case of an electronics device is usually grounded. Be careful if you are on carpet or any other surface that builds up static. Also, you should try to avoid touching the actual components even after doing this. grab the board by the edges. 

Working on a project that uses a little keyboard and an E-ink display. I have tried a couple of keyboard packages for python (pynput, pyxhook) and have written/tested simple keystroke loggers that work fine on my desktop (ubuntu) However I try to run them on the pi both libraries die 

You are already using a USB port! The desktop kit has a mSata Connection that connects to the USB port of the pi. It comes with a little dongle that connects the mini usb port of the mSata adapter to the full size usb port of the pi. You are asking to accomplish this Rpi(USB)--->mSATA--->(USB Drive) Which there is no need. You can boot directly from a USB drive If you need more usb ports you can use a hub 

You can take a look at this $URL$ But looks like you need multiple cameras which only the compute module has. if you could use two zero's each with a camera, and trigger at the same time it might work. 

The pigpio GPIO library seems to provide a mechanism to invoke the pigpiod demon remotely using TCP/IP sockets. However, there appears to be some details missing. For example: 

simulate this circuit â€“ Schematic created using CircuitLab When the GPIO is low, the transistor will be off and no power passed to the motor. However when the GPIO goes high, the transistor will conduct and the motor will run. The motor may produce "electrical noise" which may disturb the operation of the Pi by producing spurious signals. You can minimize or eliminate that with capacitors and chokes around the motor as well as using shield or twisted cables. If the motor noise is still causing problems, an opto-coupler can be used to isolate the solution into two disconnected circuits. I have also run into problems with electrical noise with the servos and again an opto-coupler solved my particular issues. Should you need to control the speed of the motor, there are two solutions. First you can toggle the input to the transistor such that it is alternately on and off. If performed fast enough, then you will get an average voltage to the motor as ratio of the time on to the time off. Should you not need to control the speed of the motor, yet another solution would be to use a relay to control the power to the motor. 

The main issue is that your calling main() from within the interupt handlers, this means they never fully finish. And usually global interupts are disabled while an interupt is being handled. Since it never finishes, interupts are never re-enabled. You only need to set the global variable x and get out of the handler. Then be looking for that change in main() I do not have your setup, so I cannot test this, and make sure I have the indentions right (what should change for each value of x) but this is closer to what you want 

Or with bash Bash scripts only require a header line and then can be a list of the same commands you type in the terminal. There are many other things you can do as far as handling errors, output, etc... but to get you started Create a file myscript.sh (doesnt matter the name) add these two lines 

Now obviously this is a very insecure way to do it, as anyone could create this file to kill your program, but I am guessing this is just for hobby use and there will be no issue there. 

Try/Except is used to catch errors (exceptions) Since I cannot see where you are calling go() from, I dont know if go() should be an infinite loop, but if it is 

If the code is written correctly such that the GPIO pins are input only, you should not have an issue. However, the use of resistors may still be warranted ... but not to limit the current in case of bad coding but instead to pull the default state of a button to a logic level. When the button is "up", it is effectively an open circuit. What then is the logic level on the GPIO? If you don't have pull-up or pull-down resistors, then the logic level will "float" and you could have un-expected results which appear to be button presses when no button is pressed. You can code around that with the PI's logical pull-up and pull-down resistors. I believe the GPIOs allow us to say that a pin is input and should have a pull-up or pull-down resistor (logically) attached. I am guessing that in the circuitry there is the ability to engage internal resistors to achieve that capability. 

By writing an application that reads two 8 bit values at adjacent I2C registers and comparing these against the value returned from a I conclude through experimentation that the order of the data returned is Low Byte / High Byte. 

It may be that your question is an example of "How do I start a program when the Pi boots?" which I believe has been asked and answered a couple of times. My personal preference for solving this problem is to used . I'd suggest googling around on systemd. There is also a tutorial video on setting up to run an arbitrary command ... see: $URL$ 

Ok, i figured it out, figured I would post the answer. pythons keyboard module, docs and source here as stated in the "Known Limitations" section, (even though I don't think this is a limitation!) "To avoid depending on X, the Linux parts reads raw device files (/dev/input/input*) but this requires root." So this does bring up security issues obviously since the program now needs root privileges, but for my case this is not an issue. 

No there is no need to stop the camera before reboot. Also preforming is not doing you any good as the reboot is going to force the program to close anyway. If you are worried about your program needing to shutdown gracefully, you should notify the program to shutdown rather then kill it. A simple way would be to use touch in your crontab like so: 

You are running the script at the beginning of the function all_interfaces_up() This function is going to run even if they are not up, notice the two return values You could have your script check for connection and wait until it has one, then execute rest of code 

This style of trace is usually used for impedance matching or timing. Impedance Matching, because how the traces interact with each other and other components, changing the way the traces make corners and where they are located can change the impedance Timing: at 1.2Ghz and moving at the speed of light( in a vacuum) a clock pulse only makes it about 10 inches before the next clock pulse leaves the source. This means that if you have multiple components that need to be in sync, it can be beneficial to 'delay' a signal by making it go further so that it matches the timing of another device I did not design this board, so I dont know what the specific reason is here, but those are some options 

I would consider having a look at the MAX7219 IC. This costs less than $1 and can control a 64 LED matrix. The IC contains memory of the state of each LED and also controls the multiplexing to keep them all illuminated as needed. What's more, is it uses SPI and hence only requires 2 GPIO pins to control the whole story. You will have to rewire your LEDs into eight groups of eight common anode or common cathode arrangements. Although primarily designed for controlling 7 segment LEDs, it has a perfectly fine mode for controlling 8x8 matrix of LEDs. It doesn't care that the matrix has become a single line ... your software will be controlling which LEDs are lit anyway. Home page for the IC is here: $URL$ More available on Google and YouTube. 

The wiringPi library provides a number of blocking timer calls. One is used for micro second granularity (delayMicroseconds) and the other is used for milli second granularity (delay). See: $URL$ Using either of these, you can block your C program for a configurable amount of time. For example, if you need to send a pulse every 50 milli seconds, you could code: 

In Jessie, there is a demon program called that is responsible to starting most of the major subsystems and, if those subsystems are not already known to they can be easily added. Here is a tutorial video on setting up programs to start at boot time: $URL$ If your services are already registered to but not configured to start at boot time, try running the command: 

The & will cause the program to be launched in the background, allowing the next line to be executed before the first one finishes. This will allow all 4 to be launched at the same time. The output of each will go to the same file named 'logfile' this could be changed to each output to their own file. 

This is much more of an electrical engineering question then a pi question. But you don't need to be using a Darlington pair transistor. You are just switching a small load, which means you are using the transistor in saturation, unlike an amplifier which is what the Darlington pair is normally used for. 1k should be fine for the base resistor, and the circuit is right (make sure the grounds are the same as in the comments) but I would switch out the transistor for a different one Look here Also take a look at the voltage drop between collector and emitter for whatever transistor you use, because you are only working with 3.3V, if it has a drop of 0.7V the camera is probably not going to be happy. I stole this explanation from here: Back on Darlington voltages - Darlington transistors do not work well in saturation. When the primary current carrying transistor is saturated, the collector voltage of the input transistor is lower than its emitter, and it no longer provides the desirable gain. In that mode, the input transistor is not much more than a diode in series with the base of the second transistor. That is one of the reasons why it is so hard to get a Darlington into genuine saturation. The current gain of the input transistor helps, nicely, until the collector voltage gets down to about 1V, give or take a little. Then, it turns into mush. Yes, in your post just preceding. That is because of the Darlington pair, for the reason I just described. I would not describe it, however, as "taking voltage away from the device I was switching". Instead, I would say that the (effective) on-resistance simply is not very low. It does, however, provide less voltage drop across the load. Jim 

To achieve a video stream between the Pi and your mobile phone will require a reasonable bandwidth for data. As such, a good network connection will be required. For Pi <--> phone connection, there are two choices ... WiFi and Bluetooth. To the best of my knowledge, Bluetooth won't have the bandwidth that you need. So let us focus on WiFi. If your phone can be a WiFi hotspot, then you can enable that and configured your Pi to join your phone's WiFi hotspot environment. At that point, the Pi and the phone will be part of a local area network and TCP/IP connections between the two will be possible. If your phone can't be a hotspot or you wish to investigate an alternative, the Pi itself can be a hotspot using the "hostapd" technology. At that point, your phone could join the WiFi network exposed by the Pi. In both cases, the Pi and the phone will be able to form TCP/IP connections. From there, the next challenge will be to find a suitable software package that would allow video streaming from the Pi to the phone. It is possible the "motion" application running on the Pi might be able to do what you need. 

The technique I use for setting up a static IP address is to edit the configuration file. At the end of the file I add: