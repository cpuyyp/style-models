You can now access TVHeadEnd in your web browser at the address: . To set up TVHeadEnd, check the Configuration tab: 

Airplay is installed and activated by default on OSMC. All you have to do is install OSMC on your Raspberry Pi and setup the audio output to direct it to your analogue speakers, as it is set on HDMI audio by default: 

The script performs a version check, which might fail. In that case, follow the instructions to install the right version of and try again. 

2b. Download the kernel sources You can use the script to install the kernel source for your raspbian image. 

You can now open the Electronic Program Guide to browse the program list and start playing/recording your TV shows. 

Download the OSMC installer for your OS Run the executable to install OSMC on an SD card and setup the network connection Plug in your Raspberry Pi, equipped with the SD card Locate the IP address of your Raspberry Pi in your network (typically this is done by checking the leases on your DHCP server) , default password: Turn off kodi: Set the audio output to analogue: . In this file, locate the line: 

Framebuffer Very similar thing is possible in Linux using so called . It's a lowlevel graphics interface on Linux. You can interact with it using device. After opening this device you can call bunch of calls on it in order to configure it (setup resolution, , etc) and query it's current settings. Then, you can just write bytes to the file in order to paint some graphics. You can use system call in order to map this file in memory. This way you will be able to just write bytes to some memory region and they will apear on the screen. You can find quite good tutorial on this here. Since is low level interface, your application wont even need any graphical server (like X server/wayland etc) running. You will be able to run your application straight from Linux command line. It should also make your porting very easy as this should be quite similar to what you had in DOS. This unfortunately also means that your application wont play nice with other windowed applications on the system. Other possibilities If, on the other hand, you don't want to be so lowlevel, you can use one of existing graphical libraries out there. libsdl could be your first candidate. It's very portable (it runs on Linux, Windows, Windows CE, Mac OS X, most BSD and even on Risc OS or Atari and that's not the whole list), there is a lot of documentation out there and a lot of games, emulators and similar software uses it. In addition to graphics, it also gives you unified input (keyboard, mouse, joystick) and audio API (and you probably need all that for your game). 

See also the HDHomeRun HOWTO guide from tvheadend.org. 1. Install the HDHomeRun Linux Drivers First of all, you need drivers for communicating with your HDHomeRun. Assuming your HDHomeRun device is connected to your network, access $URL$ for installation instructions on Linux. This means installing and the HDHomeRun Config GUI from source: 

but never mind, it'll work nonetheless... 4. Install and Setup TVHeadEnd At the time of writing this answer, there's no apt repository containing ARM binaries for TVHeadEnd. You'll have to build it from source. 

Under DVB Inputs, select the folder above your HDHomeRun and assign a Network type. Under Networks, add a network corresponding to your location Back to DVB Inputs, select one of the tuners, assign the network and check the box "Enabled" Under Services, you should now start to see channel names appearing Under Channel / EPG > Channel, click Add and select a Services. Confirm with Apply. 

I want to use my Raspberry Pi as an headless (no monitor, no keyboard) Airplay receiver to stream sound to my speakers. How can I set up OSMC over ssh to achieve this? 

Neither do any of the devices you own with cameras except maybe a dedicated camera itself, if it uses much of an operating system at all. Genuine real time operating systems tend to be I think very minimal and confined to specialized purposes. Windows, OSX, IOS, and Android use exactly the same (or relatively similar) non-realtime, multi-tasking concepts and strategies as the linux kernel. "Non realtime" does not mean at random the operating system grabs a piece of hardware, stops it doing whatever it is doing, and asks it to do something else. It might do that sometimes, if the hardware allows for it, which I would guess most cameras do not allow for excluding a hard power reset, which itself may or may not be something the OS could trigger. Hardware is hardware because it is actual physical stuff including independent microcontrollers, processors, and memory1 that is capable of performing some function on its own (although it may require some assistance/cooperation from other pieces of hardware, including the CPU running OS software), to complete tasks on a given level. When you take a picture, userland software running on top of the OS passes a request to the OS to ask the camera to take a picture and the OS does so. "Non-realtime" latency may come into affect at that point -- e.g., a number of milliseconds may be introduced by the OS, delaying the request by that amount -- after that the OS keeps on going with something else, the camera takes the picture, and when it is finished, it signals the OS via an interrupt (probably; this is actually not necessary in this case I think but still, probably) and the OS juggles that along with the other things it is doing, meaning more latency may be introduced before the software actually gets the data from the camera. In the case of video streams, the device itself, and the userland software, and probably the kernel driver, will be buffering enough to prevent turning this into an insurmountable problem, although if you tax a pi with enough other stuff you will start to notice quirks in the video stream (which is not to say this is where all such quirks come from). 

The answear Unfortunately the simple answer is no. Why? GPU is not designed for general computing so it just can't do most of the CPU's work. From your other question I understand that you want to use VPN so much of the computing power has to go to encryption/decryption. At least in theory that could probably be done by GPU but it would not be easy to do and it would require a lot of code change in the VPN software you are using. And additional overhead for transferring data from CPU do GPU might make it actually slower than using only CPU. 

You could try epeg. It's designed exactly for the job you need - to create fast thumbnails from jpeg files. The only problem is, you need to compile it yourself as there is no package for it for RaspberryPi. It's a library but it comes with a simple test tool that you can use. 

Introduction USB on RaspberryPi is quite a complicated topic. USB in general is very complicated bus, with many modes of operations and possible configurations. It's not often but from time to time it happens that some USB device won't work with some USB host while it is working without problems with other USB host (like other PC computer). Problem is - with RasbperryPi, comparing to other USB host, it's much easier to find a device that has problems. Some more details So there are two separate issues here: Power Problems RaspberryPi does not deliver enough power for some devices. Using powered (active) Hub solves most of this problems. Protocol problems Usb host device in RaspberryPi is not the best one and it has a lot of problems. Good host devices provide a lot of hardware support for many USB bus features while the chip used in RasbperryPi does not. Unfortunately it seems that it just wasn't designed to be used as reagular USB host connecting many complicated USB devices. There is a lot of ongoing effort to fix all the problems in software, though. There is one RaspberryPi Foundation's employee working full time just on that right now and there are some other volunteers helping. It seems that the progress is quite good and we already have some fixes in the official firmware. More patches are available, however, but they are much more intrusive and are not yet considered stable enough to be pushed to the official firmware yet. This should change in very near future, though. Conclusion I consider USB host to be the weakest part of the RasbperryPi device. The problems where especially visible at the beginnings of RasbperryPi and are being constantly improved over the time. This means that many informations about USB problems on RaspberryPi you can find on the Internet may be outdated right now or will be outdated in very near future. That being said, it is unknown if all the problems will ever be fixed. 

2c. Compile and install the V4L/DVB module The LinuxTV community develops and maintains the Linux Kernel Media Subsystems. See their wiki page How to Obtain, Build and Install V4L/DVB Device Drivers. As their "Basic" approach would go for more than 4 hours, I decided to deselect most options of the module: 

Once the linux kernel source is downloaded, build its scripts. If you don't, the next step will fail because it can't find , which is one of those scripts. 

I want to use my Raspberry Pi to record TV shows as video files. I have a HDHomeRun device that can stream live TV to my Raspberry Pi via Ethernet. How can I set up the tvheadend PVR backend accordingly, which provides a web interface to set up video recordings? 

2. Install the V4L/DVB kernel module Next, you need your Linux kernel to be able to stream TV on your Raspberry Pi. There's a module for that, but it'll need to be compiled from source. Let's go! 2a. Upgrade to jessie In case you're still using the raspbian wheezy distribution, you'll have to upgrade it to raspbian jessie first, in order to be able to install a recent version of the gcc compiler. 

A normal multitasking OS such as linux, running on a modest processor, has a userspace latency on the order of milliseconds, so being off by 0.35 ms when measuring an event vs. some piece of more dedicated, realtime hardware is to be expected. What would truly be flabbergasting is if they were consistently the same. 

Obviously you won't get more than the 100BASE-T speed, i.e., 12 MB/s. In reality, I wouldn't expect more than half that, but it is hard to say since most real internet connections in my experience won't sustain this anyway -- but I don't torrent. My LAN transfers to/from the pi's USB drive are pretty slow, 3-4 MB/s, I suspect because I do them via sshfs. In short, if you are shuffling gigabytes of stuff on a daily basis you will be disappointed. 

Note on some distros this command is . Now chown the device to that group and tweak the permissions: 

The postgresql server might have some independent log of its own; you should check the documentation for that. 

where is your actual chip name (this module can handle few different chips like and ) and is its address on (you can configure the address of the chip when wiring it). This will create entries in directory that will allow you to use them the same way as other GPIO ports in RaspberryPi, providing you are using interface (for example in wiringPi). Unfortunately, Python's module does not support this mode so it won't be able to use this pins with this library. The pins will have some high numbers like 248-255 or similar. Note: is - it can give drive sink (accept in low state) as much as 20mA but it can only source 0.1mA in high state. This means that you are usually going to use it in reverse logic, i.e. . 

As pointed out in comments by Lord Loh, it is Jazelle instruction set. It implements subset of java bytcodes as another ARM execution state (besides native one and Thumb). But you can't really use directly it since the documentation published by ARM is not complete and they seem to provide better one only to JVM developers. 

Check to make sure the links are there and they point to the right place with . I believe this should be sufficient and you can now try booting the system. If so, after you get in remove those links and run , then check the links have been recreated (remember, the priority may be different). If you still get "Connection refused", create a link from to and try again. 

Presuming you are referring to Raspbian, the same SD card should work unless you have removed from the boot partition and/or corresponding directories from . If you are referring to an OS that is Pi 2/3 only (e.g., various forms of Ubuntu) then no, it will not work on a B+. Also, if you have specified a specific kernel in , then comment that line out. You can also check to see if one ended up there some other way. 

The problem with this is that if you then log in on a console and run , you'll have sourced twice, which is usually undesirable. Another idea is to use and do this: 

There is "safe mode" boot option in raspberry Pi firmware for some time now. To enable it, you have to use a jumper to do short between pins 5 and 6 on P1 header. This makes bootloader code to almost ignore content of config.txt (except from option) using default values and try to boot with (or if it's not available). By default boots to minimalistic busybox based initramfs. It mounts /boot/ by default so you can easily edit it and restore your RaspberryPi to normal boot. More informations (including photo) on this thread. 

I believe is a setting responsible for that clock as I saw some foundation members mentioning APB is a internal clock driven by GPU (but I haven't found a definitive proof for that). You should not threat it like a static value but I don't know how it can be determined from userspace. Also by default, if , cpufreq will be changed according to system load. It should be between and which both, defaults to 250. On the other hand, kernel SPI driver seems to be using (according to file) clock which seems to be set as static 250Mhz. driver does not change this value (as far as I can see, it only sets ARM clock but it is doing this through GPU which may adjust other frequencies by itself automatically). 

HDMI displays do not by definition require a SPI connection. I believe the ones out there for the Pi that do, use it to incorporate a touchscreen interface, which you've said you don't need. You can plug the Pi into a normal HDMI TV or monitor and use it, so if you can find a 3" HDMI screen that should be fine. You may have to tinker with settings in as described here. 

If nothing shows up, check to make sure it is listed with (you will have to first). If it is listed, try ;1 if that succeeds look at: 

Put the SD card and an ethernet cable from your LAN into the pi, then plug in the pi power. Wait a minute or two and ssh in. If you need wifi, you'll have to do more configuration on the card first, so hopefully you have a cable. If you don't get some part of this, ask specifically and I can explain in more detail. 

You can in many cases run code compiled for ARMv7 with an otherwise ARMv6 userland, if the processor itself can run it (meaning, you'd also be using an ARMv7 kernel), which the Zero cannot.