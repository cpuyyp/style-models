Reading the docs, it says that the method accepts an index. This index comes from the second parameter of which you are currently not using. That means all you need to do is start keeping track of the indexes. In order to keep track of the indexes, class names, and CSS rules, simply create a look up table and use a counter for the indexes: 

Both of these loops involve the only argument () and will run a certain amount of times based on this argument. Looking at these they both run the range of 

Personally, I think your naming is just fine. However, the only thing I'd change is . That name is very general. Luckily, since we are talking about races, we can use information about races to name the variables. As you probably know, in a race, when two or more teams end with the same exact score, it is called a tie. Therefore, you should rename that variable to . And, now that I think about it, your function could use some renaming too. doesn't really tell you what the function is doing; what is a "good winner"? I would name it to . That name tells you if the bet (not the winner) was on the winning team. 

This line is moving a pointer to a memory location into . However, this subroutine is supposed to add numbers together. If it was meant to add numbers together and then put the result in memory, then why isn't it doing that at the end of the subroutine? In my opinion, you should move the first line out of the subroutine and to the first line after the subroutine call (and before ). That way, the subroutine is doing it's job of adding two numbers together, and the routine is doing it's job of getting two numbers added together, and then putting that sum in memroy 

Instead of storing the state of being selected and the state of being flagged as booleans, I recommend creating an enum called that has values and and And, if you want to take it a step further, you can set 

To make this thing "more object oriented", I recommend that you put all of this into a class. Right now, you have variables spread out, and you have functions with names that make them sound like they are methods for a class (), even though they aren't. You should make a classes like and where has a few s that have methods. 

Design Your design is a little awkward. You have a function that will return one of three string values: "Arithematic series", "Geometric series", or "neither arithmetic nor geometric". That looks a little awkward for whatever is using this: 

What? That doesn't make any sense. There should not be any change in speed based on whether or not something is an if or something is a ternary. Even if there was, the difference would not be that great. Now, for the most part, you are doing okay with the ternaries that you are using. However, for the most of your ternaries, I think you should switch the order. For example, right now you are doing this: 

JavaScript In your , you are accessing whatever element has the property of two times in a row. The function is not very efficient, because it has to search the entire DOM. Your code would be a lot faster if you stored this value in a variable: 

You have a potential error here: in this function, you attempt to send a signal to the server that you are connected to. However, if the client had not yet connected to the server, will fail. To fix this, create a variable called and set it to . Then, when the first fires you can set this variable to . That way, you can setup an statement in the code above so that you don't try to reply to the server without first connecting to the server. Here is what I mean: 

Don't remove the indentation inside of code blocks so that the code is on the same line as the signature. It makes the code harder to read as it's hard to piece together which goes to which signature. For example, this: 

Unnecessary matrix generation In JavaScript, Arrays don't have a fixed size. For example, you could do this: 

Debounce You say in your title that the scrolling event is being fired too many times. Well, this makes perfect sense: as long as the user has their mouse over the scroll bar and is moving the bar ever-so-slightly, the scroll event is going to try and fire as quick as it can. Even for the tiniest movement, this event could fire over 50 times. However, there is a simple way to prevent your code from trying to run that many times: a debounce. A debounce is when you setup a variable to prevent code (typically an event) from running while another piece of code (often the same code) is still running. Every time this scroll event fires, a new thread is going to be created with the event code running in it; a debounce would prevent these from running at the same time. It is very simple to create a debounce; you just need a variable and a conditional. Here is what the basic design would look like: 

Merging hit type methods You have three methods , , , and that could potentially be merged together into one function; you could pass in parameters to denote where players are moved from. However, this might complicate things. It's up to you. 

I see what you are trying to do with printing out that extra at the end, but it's really unnecessary; you're only printing a few characters in total. Avoid the extra call and just print the at the end of each call (which can now become calls`). 

The above code that I wrote does that same exact thing as that big chunk of code that you wrote does, only this is in just a few lines. I made another subtle change to the code: rather than storing the new in a variable, I passed the directly to . 

This may be a little confusing. Basically, what this is saying is that the directive is going to read the attribute by the name "profile", and pass it on as a "parameter" to the template under the name "profile". When using the directive, it would look like this: 

Element Sibling Insertion ID's versus classes/names/tags In the earlier part of my answer, I stated a big problem with your function returning different typed values. The problem is evident in this function: 

But, having it be a class provides benefits, such as being able to have a field/method be either public or private. It's up to you which one you go with. Second of all, the class does a lot of work in it's constructor. A constructor is meant to declare and define different fields and methods; your constructor does not do this. To aid that, it would be better to put all that set up into a function that initializes everything, and starts the game. To add to that, everything is very spread out. In your class constructor, you should have all of your fields at the top, and all the methods at the bottom. You seem to be throwing things all over the place. That being said, you class constructor would now look like this: 

Right now, the property is empty. Before we populate it, we need to figure out, "What do we want to put here?" and "What does the template need?" Well, it's quite simple to find out what the template needs: the original HTML code was in an so the template is obviously going to need whatever was in the . After looking at your HTML again, it seems that the children of that element that was isolated above only use the from the . That being known, we can now change our directive to this: 

I must say, I respectively disagree with @ishyfishy's example of the function. Although, I do agree with the point about splitting the arithmetic functions away from the function. I believe that the arithmetic functions should only handle performing the arithmetic; all the I/O should be handled by function (I have been taught that this is a good practice, although I do not have a source right now). So, the "1" (addition) section of the statement in would look something like this: 

Note: This may not apply, but you didn't include the class definition so I do not know. I recommend calling this class , and then having a single static public method called that takes a single array and "heap-sorts" it. That way, if you are writing other code that needs to "heap-sort" an array, you can use the class and call it's method to sort it. This will make your code more organized. Here is what I mean: 

(The extra 0's are for filling up the 10 bytes given for the name) (Note the order: you want greatest to least) And, you can easily Now, in your main code, you can easily iterate through and, if the counter is evenly divisible by the value in the field, then you log the field. Now, the code could be written like this: 

This may just be me, but when you add a new to the array, and then you , wouldn't you be retrieving the that you just put in? If so, don't add the to the array until you are done calling all those functions on it. Then, you can add it to the array. 

The incrementing was moved to the same line that was being stored. This looks more clean now, in my opinion. The if conditional was converted into a ternary operator to set a new value to index. This also makes the code look more clean, in my opinion. 

There is no point in calling the method because all the words in your dictionary are already lower-case. 

How many times are you going write something like that? This constant property access, while it is not that big a difference, it unnecessarily slowing down your code. Your code will look a lot cleaner if you just stick this value in a variable: 

That is a good idea to store the time it took the user, then to show it to the user. However, for some reason, you don't do that in . Why not? I don't know about you, but I'd want to see how long it took me even if I won the game. 

You should not have an in the middle of your code; all the ing should be done at the very top of your code like you were doing before. 

Braces Always use them, even around single-line statements. They make your code more maintainable and less error-prone. 

It's not that you shouldn't use unless absolutely necessary; it's that you shouldn't use it for arrays. It should only be used for objects. For this code, you should be using a normal loop. 

This is created every time your function is called. Assuming more drawing will take place in this code, why not put both the canvas and the context in a global scope? There is no point in finding the context, putting it in a variable, and then destroying it at the end of the function every time it is called. 

Note the ? This is required for it to be valid JavaDoc. In more complicated functions where the parameters aren't clear or the return value isn't clear, you can include something like this in your JavaDoc: 

To me, a function called or should return which of two number arguments passed is either the greatest or the least. To better describe the functions, I recommend calling them something like or . 

But, when I match all the squares, I don't get an alert showing my tries (and it's not just because I have popups blocked). 

Different types This function's returning get's really confusing, and makes your code very hard to use (as evident of how you are using it in , which I'll discuss later). Your function can return one of the following: 

Now that we have this basic min subroutine, we can the subroutine for finding the min of 3 numbers. Using our handy-dandy sub, this new subroutine can simply use the sub to determine what is the greater of the three values: 

Anyone who knows this instruction set should be easily able to know what that line is doing. Comments are supposed to explain why, not how because "how" is very easy to find out on one's own. 

These seem to be past code that you are no longer using. Get rid of them; they are making your code harder to read. 

In , you do a lot of looping. In each loop, you are destroying and re-making variables as they exit and leave the scope (the loop). This is very optimal. To help this, move the declarations of , , and to the very top of the function (before the loops). You can set them to 0 when they are needed. Here is what I am saying: 

Usually, the name given to an error in a /(or ) statement is something along the lines of "err", not "msg". 

Notice that last line; it uses the new parameter to keep track of the value that it would normally be returning at this point. Now, instead of constantly building up on the stack, the will completely finish executing before the next function starts. This keeps the stack size constant. Now, to call this new function, you would write: 

Create an array of the names of classes that you might set the state to. Iterate through this array If the state string passed in via argument is equal to the string that we are currently on in the iteration, go to 5 Go to 2 Set to an instance of the class referenced by the string. 

TopinFrassi has already provided a great answer. Since there is not much else to say, my review will be fairly short. 

An entirely new idea for your system: since this is just an image slideshow, just create an object that holds an image url and a capt 

Now that there is a conditional for in the new structure that I created, there is no need to have that conditional in the loop. 

Where is a variable that will iterate through all the properties/keys of . You could then access the value of that key/property by using 

Good News There's a solution that allows you to keep on reading from and that is to use the amazing Windows API. Luckily, you can do that in C because Windows provides a header file that gives you full access to the Windows API in your C/C++ code. Now, you may think to just include the file in your code and use whatever the API has to read the keyboard. Well, you can't quite do that because if you try compiling that on *nix, you'll get an error saying that the could not be found. An easy fix is to use the pre-processor: 

This type of access, when overused as it is here, slows down your code. Store these sorts of things in variables: 

I don't believe that this is exactly what you were looking for in a review, but I thought I'd point it out: In the class's method, it looks like you are starting to create a switch statement which will check each possible numerical value of the enum property and, depending on the number, log out what the card is. However, I think a better way to do this would be to, in the enum, set a string property that contains the name of the suit. Then, your enum would become this: