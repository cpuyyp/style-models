The difference is that your routes are mapped to the controller methods. Your GET route would map to the method in the controller. While the POST route would map to in the controller. Also, the GET route would be handled by in the controller. Changing the routes is a case of changing the controller methods. This means one place to change your routes rather than two. 

This is really very open ended and is open to many forms of interpretation. The code format below is strictly the way I like to make my code legible. 

First things first, you're creating no less than 5 jQuery objects for each time someone hovers and moves out of a menu item. Two things on this : 

It's fairly obvious what .call() is doing in context. I recently came across some articles that went into depth on abstracting the .call() function. The premise is along these lines (this code is verging on pseudo code as I have stripped it down for ease of reading) : 

Make your code scalable By this I mean using techniques that allow you to do some relatively advanced things without the need for re-writes / re-factors in the future. One of these is to bind events to a lower level element with rather than or . If in the future you modify the menu for some reason with jQuery/JS and DOM elements are removed / re-added, event bindings will be lost. Using avoids this problem. Refactoring your code I've deliberately not included any CSS changes in this code as you can and should include these in your CSS rather than dynamically with jQuery / JS. I have however added and removed a class, this should contain all the style changes required for the mouseenter and mouseleave events. 

I've written this relatively simple class to help with managing arrays of anonymous objects in my scripts. 

The main advantage to this is that the class can be extended easily using other design patterns such as a Facade that further simplifies the class API. It can also be added to easily with further methods within the class body itself rather than by a pure static call. The class can also be instantiated with the keyword providing the ability to create separate cache instances that utilise the same static properties and methods. I need to add this class is very much a prototype that I thought of when I saw your class above. I love cacheing stuff in general and providing standardised interfaces for it is always a great thing to do across all applications you write. 

Is it possible to solve this problem yet still be consistent with fp, i.e. no mutations and no loops? And of course: Any other improvement suggestions are welcomed. 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 3): $URL$ I'm doing the 2nd part of Day 3. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 3 (part 1) in Functional Programming (FP) 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 5): $URL$ 

Running this code with in normal mode will create a . I had to "cheat" by running this code in : (node 6 supports Tail Cail Optimization (TCO) when the flag is turned on). I also tried to cache the but this didn't help either. I got the feeling that big size Input is the limit for FP. 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the a problem from project euler: 

As you can see, it is not consistent with the idea of FP. First I wanted to write it using recursion but I hit the stack limit. Therefore I used generators (and loops). That was the only solution I could come up with that resembles FP. Any suggestions how to write in FP without any additional FP-Library (i.e. in pure JS only) is much appreciated. 

There is some form of JS voodoo going on here that I can't programatically work out, can anyone help me shed light on how JS is interpreting this and why when I call: 

Example of the chaser and chasable interfaces in action: First lets make our interfaces a little more rounded 

So you now have interfaces that describe what they do. It now makes sense that both a Dog and a Lion can implement . Not only this, any animal class you create are capable of using it without semantic issues. Your interface suffers from the same problem (to a lesser degree). Having a canine interface is probably not a bad thing, declaring that canines only bark or howl is true. Is it true to say that no other animal species can bark or howl? what happens when this cat turns up on your doorstep? (stupid example but I found it amusing) Cat videos aside, we now have a strange edge case where a cat is displaying canine behaviour, but it is not a canine. Enter the interface (that I find both funny and embarrassing). 

I agree with Gerard a little, you have made (in my eyes) a common error with interfaces where you've tried to make them specific to a certain type rather than what they actually do, I see this a lot in the wild (excuse the pun). This isn't to say that interfaces based on type are bad, they have their place but in general an abstract would be better suited for types as types will have unique properties that you could not declare in an interface (nor would you want to). As an example I'll elaborate on the "Dog is also capable of chasing" example. Declaring a as makes no sense when trying to describe what a Dog is, instead, make it capable of doing something. 

Going into the nuances of having a single Cat that can bark out of a set of possibly hundreds of Cat instances is beyond what you're trying to learn but I'm hoping you get the gist of where I'm going with this, behaviour as interfaces generally work better than types and give you a lot more flexibility when actually determining what your classes do. I'm making general statements a lot here, but you will see that your interfaces become very specific to actions. As such they are smaller and make more sense. I have found it much easier to have a class that implements 5 smaller interfaces than 1 or 2 monolithic interfaces due to the increased flexibility available and it keeps things DRY. 

I'm doing the 2nd part of Day 5. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP) First my procedural solution: 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 1st part of Day 5): 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? I have problem with the lookuptable . Everytime I "add" a new element to the scoreboard, I had to pass the new scoreboard along. There is probably no other way around this in FP since FP functions have to be self-contained, i.e. every new value that needs to be calculated have to passed along. But I still wonder whether there is a nice FP solution to that. Any other improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 2): $URL$ I'm doing the 2nd part of Day 2. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code Day 2 (1) in Functional programming (FP) 

Don't use jQuery to... Modify CSS unless it is absolutely required (ie CSS alone can't achieve what you want). In this case CSS can handle you're requirements easily. If you find you need to change a lot of CSS and would like this CSS to change due to a jQuery or javascript event. use and . Applying the styles in CSS rather than in jQuery. This is far more efficient in terms of code and your eyes. :) Cache your jQuery objects 

You're jQuery can be written in one simple function as a catch all for the entire navigation. As you stated you think it could be condensed, you'd be right. As a rule of thumb if you see yourself writing the same thing over and over you should be able to cut it all down into one function. Starting with one of your methods I'll step through it to show how you can condense this and make it more efficient. 

I would say that there isn't a correct or incorrect way of achieving this. Everyones requirements differ. You probably want to expand this out, there's a lot going on in the one static method you have in that class. Whilst I don't have anything against mediator patterns, I would probably combine a number of patterns to build a powerful caching class, as well as utilising magic methods (I know some people are averse to this). I need to note the below is a lot more complicated and would benefit from some refactoring to be stored against the actual method rather than a key. 

There is nothing wrong with this approach at all. Rather than say you should or shouldn't do it any other way I'm going to give you an alternative approach that allows you to write less code in your file. I've noticed that your deals with a lot of different types of requests. This can get very hard to manage when your application grows. It's a good idea to separate out your controllers into manageable classes that deal with one area or feature of your application. The example below would ideally be in a class for example. Taking this chunk: 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 6). You can only access the 2nd part if you type in the solution for the 1st part: or look at my solution for part 1. 

I got 2 while loops that are nearly identical. Is there a way to refactor them? I tried to refactor them into one function. But that function takes and returns 4 parameters: 

Is there a better way to write it in FP (without any libraries and with vanilla JS only)? Also any improvement suggestions are welcomed! 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code. $URL$ 

Is there a way to write with less parameters and still be consistent with fp? Any other improvement suggestions are welcomed as well! 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code: $URL$ 

The code above has got more operation than in the first part of this riddle. But it's way faster and shorter than the functional approach of the 1st problem (Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP)). My FP solution: 

For the cross product I used this code snippet: $URL$ Slow as hell but seems to be fp with vanilla JS only: 

The FP solution is longer and slower. I couldn't solve it without recursion. After a while you hit the stack size. Thanks to Thanks to @Blindman67 he suggested a workaround with . Do you know an FP approach that is faster and shorter than the procedural one? 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the 4th problem from project euler: