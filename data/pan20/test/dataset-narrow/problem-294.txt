I'm reading over the postgresql admin cookbook. Some of the database server parameters require a restart and with a busy database, you may need to restart quickly. There are a number of things to do to speed up restart: 1) issue a normal checkpoint before shutdown checkpoint, 2) flush all dirty shared_buffers to disk, 3) record the contents of the database cache prior to shutdown and then warm the cache again immediately after restart. Therefore, the book seems to recommend: 

Which one should I use when restarting a busy database which gets inserts very often? One of the above or is there a better method? 

In pgadmin, I selected a table from my production database I want to export. I right clicked and selected backup. I set the filename to devices.sql and selected plain as format. Then I clicked the backup button and it created a sql file on my computer. Now I want to import the contents of that table into my development database. So I run the psql utility and enter the following: 

Is fragmentation on intermediate pages something to worry about and what is causing the increase in fragmentation? 

I'm trying to setup an AlwaysOn AG with T-SQL commands but my secondary is always in a disconnected state (when I failover, my old primary becomes disconnected). This is not an firewall/network issue, I'm able to send messages from SQL1 to SQL2 with a TCP-sender/receiver. The option New Availability Group... in SMSS also generates the same problem. However when I'm creating an AG with New Availability Group Wizard... it works perfect. This is the T-SQL statement I'm using: 

Somebody told me there's a difference in the internal working (I not mean a difference in features or supported resources) of SQL Server Enterprise and SQL Server Standard. One difference I remember was that the Enterprise version uses multiple threads for certain operations and the Standard version only one (I forgot the details). I've searched the web for an overview of the differences (+ some explanation) but I was unable to find such a list. I now wonder is there a difference in the internal working between the two editions? 

Make sure that SSH is allowing forwarded ports; if you get a message that states the forward was not permitted or was refused, then that is why. To fix this, you'd have to change the server configuration; add this configuration to the SSH server: 

I'm trying to understand how to compare a DATETIME value (ostensibly inserted as GMT) and a TIMESTAMP value (automatically generated at INSERT time). As I understand it, the DATETIME is set to whatever it is set to - and the reporting comes back with the same value, no matter what time zones are in place on the server or client. In the MySQL documentation, it sounds like TIMESTAMP values are reported in the current timezone, but stored in UTC. In this situation then, subtracting the DATETIME value (earlier event) from the TIMESTAMP value should be possible without a lot of timezone conversion - because the DATETIME is GMT and the TIMESTAMP value is UTC. However, doing this accurately - and understanding it - is proving to be a problem. I have situations where I need in minutes and in days. If we assume that column is DATETIME and column is TIMESTAMP... So far, I've tried: 

The second method is twice as fast as the first one. But the disadvantage is that after a few years the archive disk will contain a lof of folders/partitions containing the filestream data + database needs to be offline. As with the first method there is only 1 folder/partitions (or I can split that big partition by year). I hope my explanation is clear enough because it was hard to put all this in writing. What is the best method to accomplish the archiving or am I missing something? 

On the secondary dm_hadr_database_replica_states is empty and the database doesn't show up in sys.databases. When I look in SSMS the database is shown in 'Availability Databases' Is this a bug in SQL Server 2016 SP1 Standard CU2 or is there something wrong with my T-SQL statement? 

I have a reports table which has literally millions, if not hundreds of millions of report records, which date back to 2011. I think it's slowing down my queries exponentially. I only want to keep reports from the past 6 months. I have a time column in reports table which gives the current time so I can use that to measure reports older than 6 months. So I am thinking about running some type of cron job on my ubuntu server in which the postgresql server is installed on. But I am looking for some guidance about going about this. 

The only other option I have is to insert the reports into some orphans table, but then I would have to copy those orphans over when the unit is created, which is additional work. 

I've setup an AlwaysOn AG on SQL Server 2016 SP1 Standard. Then I created an AG and added a database with autoseeding (synchronous mode). I used SSMS 2017 to create my AG and to add the database. Everything works fine. But when I check the wait stats I get waits of type VDI_CLIENT_OTHER (80%) on the primary with an average resource time of 42 seconds. After some research I found out that the waits are generated by 4 sessions that execute the command VDI_CLIENT_WORKER. As I understand the wait means that a thread is waiting for work when seeding a new AG. But what I do not understand is why I have those waits because my AG is ready and why do I have 4 sessions that execute the VDI_CLIENT_WORKER command? I found out that each scheduler has one VDI_CLIENT_WORKER Can somebody try to explain what VDI_CLIENT_WORKER-command does and how can I solve the problem of the many VDI_CLIENT_OTHER waits? 

Our time zone here is US Central Time - currently Central Daylight Time - GMT-6 for CST and GMT-5 for current CDT. It also looks like DATEDIFF converts both values into dates then compares them - instead of comparing time between the values and dividing by the number of 24 hours in each. Thus, I don't think DATEDIFF will work directly for me anyway. The specific questions, then are: 

Why are these calculations so different? I am assuming that it is a lack of understanding of TIMEDIFF, but what am I missing? 

UPDATE: Tried using the function with the values of and . However, the function with such specifications appears to read the setting of Daylight Saving Time from the current system time and not from the time as read from the database field. This means that when the data should be taken as a date in CST, it is read as CDT instead. I keep thinking it's got to be simple to get the UTC representation of a field - which would simplify things, seems to me. UPDATE 2: Looks to me like I mispoke regarding . I'm using this function and it seems to work: 

I'm a newbie regarding the query store and have some problems understanding what I'm seeing. We have a third-party application (running on SQL Server 2016 Enterprise SP1 CU7) that uses the query-hints and . When I do some monitoring in the querystore I see that some queries has multiple plan ids in the plan summary window. Why can a query that uses and have multiple plans (sometimes completely different, sometimes the same)? And the second question, if there are plans that look exactly the same (same physical operators, same set options, same queryhash), how can one plan have a missing index and the second plan not? This are two anonymised plans: Plan 1 Plan 2