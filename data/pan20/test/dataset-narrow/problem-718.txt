Algorithm Your algorithm uses (as you correctly stated) \$O(K^2)\$ time by calculating all possible combinations. This can be reduced to \$O(K)\$ with a bit of cleverness: As far as I understand it, the problem basically boils down to: , maximize by removing up to <= total elements. This means to maximize , one needs to find how many elements to remove from each "end" of the array, because as you correctly deduced, only those matter. Now we can step from one end up to elements in, and for each step calculate the change in if we were to remove elements up to this point. If it's the best result so far, we note it for the current position, else we note the previous better result (after all, we always can take less elements away). We do this for both ends. Then we can add the noted values for taking elements from the front and elements from the back together (so up to elements total), and find the maximum for this value. This value is the highest increase possible for . Adding this value to the previously calculated original value of gives us then the maximum value for . Step by step Let's take your example: . Let be the map . 

is used in several places, both as a integral value and a pointer value. Try to use more explicit values (especially the more type-safe for pointer values), as currently every time is involved, I have to double check whether the value represented is a pointer or not. 

Yes, it's a lot of boiler plate code inside the s, but after that its mostly done (though some of it could probably be replaced with macros if it gets too bad). Plus side: you can't really get the final usage wrong! 

So the best we could get is an increase of by (by removing elements from the front and elements from the back, though that wasn't asked). Algorithm code In code (using arrays for consistency with existing code): 

Doing so allows other threads to perform work on all unrelated elements. 3) Read/Write exclusivity What's the difference between reading and writing ? Reading can be done concurrently, writing can't. There is a lock that helps for this special case: allow multiple threads to read the related object(s), but only allows one thread to write to it (while no one else can access it). The catch? It's only available since C++17. Before that, there might be other libraries providing that functionality, though (e.g. boost), or you make do with a normal . Small problem In the current version, every changes to an element of is done in one transaction - no thread can see any partial state. If this property is required, this can be implemented with some special considerations. How do you change a object in one transaction? 

Now we can go over both and and look what the best results for removing up to elements from the front and (so ) elements from the back. 

Additionally, the list of sizes supports a operation: retrieve the size at an index. Any suggestions for improvements are welcome! mpl_types.h 

I have implemented two genetic operators, which is really just a fancy way of mangling lists. In particular OX-1 (illustration) and displacement mutation. I found it necessary to extract out the randomness from the algorithms in order to do unit testing with some known examples. Is that a decent way to go about it? Any comments on performance, structure, clarify and so forth is appreciated. 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making. 

I'm completely new to Javascript and NodeJs and functional programming in general. The code below scrapes a torrent-website containing movies, gets info about the movie from the OMDb API and lets a user choose a movie to watch by streaming the torrent. Any feedback appreciated. 

Given a boolean 3D matrix and a set of actions specifying bit flips at certain positions, a set of resulting matrices can be obtained, one matrix for each action, as if executing each bit flip individually. A statistic (feature representation) defined on a matrix which for each row, column and depth counts the number of active bits at the same depth within some hexagonal distance in the first two dimensions of that row and column. What's the fastest way of getting such a statistic for each of the resulting matrices (afterstates), given the previously mentioned original matrix (grid) and actions (, and )? For example, given , , the first afterstate of can be obtained by . Actions are guaranteed to be bit flips. If the feature representation for is known, the feature representation for can be derived and need not be found from scratch. In the code below, the naive approach () and an incremental approach () are given. The naive approach should be easiest to understand. This is the hot hot hot path of my system and I want to make it faster, but I'm no speed demon. Any tips and comments on anything else, small or large, is also appreciated. Below the code is some background which is not required reading but may make things more concrete. 

You might appreciate taking advantage of some ES6 features. You're using an object literal like a map, so why not use a real ? Speaking of ES6, since you're a beginner, you would benefit from taking the time to learn it now and save yourself the headache later. As others have noted, you can accomplish finding the mode in a single for loop. 

I've created a function that takes an integer greater than zero as an input and converts it into its corresponding Roman numeral. If you're not familiar with Roman numerals, you can read about it on Wikipedia. I've tested this code with some examples, so it should be working correctly. I'd be interested in hearing about any general improvements I could make on the code. Nitpicky details are fine as well; whatever you have to say I'm willing to hear, but I hope your answer is more substantial than that. I suppose my main concern is whether this is sufficiently efficient or if there is a way I could improve on that. Also, do you think I've used the correct data structure in this situation? I can't think of a better data structure for what I wanted to do, so that is why I chose arrays. 

There is a shortcut you can take to find the missing number after you've found the duplicated number. You may have come across this fact before, where the sum of the numbers 1 to is . We can leverage this along with the duplicated number to find the missing number. If you add up every number in your list and subtract that from what the expected sum would be from 1 to , most of the terms will cancel, leaving you with . You can visualize that with an example: 

These are already available in your scope, so you do not need to reassign them to a local variable with the same name. 

You've declared your function as , but what information does the returned convey? You're always returning , so no information is gleaned from the returned value. I'd suggest redeclaring your function to return and remove the statement. This goes for a few of your other functions that return . If you're always returning the same value of or , just remove the return statement and declare the function to return . Here's the list of such functions which I've changed below. 

Here you throw a string. You can throw any value, but it's more helpful for debugging purposes if you throw an object. Just pass this string into the constructor to make your own error message. 

This will swap s when passed addresses to s, a.k.a. s. Now your function will swap the members in the s correctly. 

It's easy to see that there's a lot of code duplication going on here. What might not be easy to see is a nice way of condensing it. One way to start is to see the similarities and where the lines of code differ. It appears you want to perform an action on each of the four directly neighboring cells and something separate for the center cell. A nested for loop could help tremendously. The only thing to consider here is ignoring the diagonal neighbors. The other piece of duplication shows up where you do one set of actions when the argument is one value, and an almost identical set of actions when the argument is the other value. The only place the repeated lines of code differ is at a single hard-coded value. If you just set a variable to be the correct value for either case, you don't have to repeat yourself. Something you may have not considered is trying to index the array past the boundaries. You should avoid it so you don't encounter errors. Simply add a check for this before indexing the array. I've split this check into a separate function because the boolean expression is quite lengthy on its own, let alone compounded with other boolean expressions. Another tip is to handle all the cases. If you use a , use a at the end. If you have an , use an at the end. Even if you just want to ignore the case that didn't match the other cases you do handle, you can just write a comment, log a message, or even throw an error.