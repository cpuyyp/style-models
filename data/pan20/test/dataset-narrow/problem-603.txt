Mapping int to int... You have used to suppress a warning. However, you should know that there is some performance benefit in using a rather than a . You create a mapping from integer to integer, by using your own keys. I don't see the need of this, honestly. Instead you can declare the and similar as constants, such as: 

### It's not necessary to use double quotes around the name of the property here. Simply using should be enough. For example, instead of (It shouldn't be necessary, but maybe it is necessary in this case) Template Engine As I mentioned, this would really be a good job for a template engine. Groovy comes with a couple of them, and I think that the MarkupTemplateEngine would be a good choice here. I would at least use a template for the card data, maybe a template for the full HTML site as well. Read the template documentation and play around with it. You can also see an example of how I have used it and a template I have written There's so much to write about how to use a template engine in Groovy that I can't really write it all here, so I'm just pushing you in that direction this time. 

When reading your code, the Strategy Pattern alarm goes off in my head. Before that however, I have some other remarks. 

It is convention to not prefix boolean fields with . The name of the method should be + variable name with upper case starting letter, so: 

Slightly inspired by a previous question/april fools joke I decided to take on Fibonnaci sequence in the lovely language Brainfuck. In order to do this I have also worked on Brainduck, which is a Brainfuck tool/analyzer/IDE. In Brainduck I added the functionality to run Groovy code if the line begins with . I wanted this to serve as both a way to make assertions while running the code, to make developing BF programs easier, and to serve as documentation. This question is not primarily about Brainduck though, but about the Brainfuck code I wrote using Brainduck. A slight summary of the stuff I am using: 

Point 1 here can also be applied to your main loop (that goes from 2 to 20000000). Initialize k to 2 and check if that's prime. Then set k to 3, check if it's prime and then increase k by 2 each time. So that the numbers you check for primeness also becomes 2,3,5,7,9,11... Theory on another approach (Untested in all languages, might not work) I'm not sure if this will be faster or not, but here's a thought that you might be able to gain speed with: Since you loop through numbers to check for primes, add the already found primes to a list and when checking a new number then you only need to check if it's divisible by one of the previously known primes. That way you won't have to check with 9 and 15 for example. Pseudo-code: 

Player Everything fine except for the method which I don't think is even needed, as any code wanting to print the hand can call 

Is not how Selection sort works. At first glance it looks like Bubble sort, but considering how it actually works, it looks more like a form of "ping-pong sort" (yes, I just made that up). So, how does your current code work? I added a little output whenever two elements were swapped and this was the results of the first swaps: 

Besides what @rolfl has said, I only have one nit-pick. I consider this to be a pretty big one though. Put this at the beginning of your main method: 

I like the Javadoc, but it's totally overkill to specify the class name in the javadoc. The class name is already displayed in the javadoc functionality itself, you don't need to duplicate that when you write javadoc. 

Use better variable names! What is and what is ? Describe what the result is for in the variable name. 

For your drawing an image plans, you should read up on Creating and Drawing to an Image and the chapter that follows it Writing/Saving an Image. You can use the object as shown in the first link to draw rectangles on the image. 

This can be solved by wrapping a inside Use the interface, Luke! Your and methods does not need to reveal the implementation, use as the return-type instead. The same goes for your unit test, declare as: 

This is in my opinion significantly better than your original version. However, I would recommend Pimgd's solution, either an array or using chained . 

Getting the file path Once you have created the file object, you can use to get the full path, or as we're using Groovy - use the property: 

Yes, some of the things you are doing is redundant and quite messy. As this seems to be a homework assignment I will only provide hints for you here. What you can do is: 

Overall, your code looks nice and clean, I just have a few things to say: Your code is described as "... convert ... into four spaces" which throws me a bit off pace when reading this line: 

In Java it is better practice, if you want to allow access to your variables, to make getters and setters and make the variables themselves private. 

Judging by what you actually do in the method, I would expect this method to input a and return . At the moment, your method is dependent on several class variables and is therefore causing side effects, things that cannot be seen by checking the method header only. So change your method to: 

Stream, Stream, Stream, all you have to do, is Stream... Immutability? Consider making immutable, or having a separate that simply holds the result from the (then you'd also just have to call once) Adding is merging Your method can be quite simplified when using : 

Conventions According to coding conventions, Java class names should start with an uppercase letter. should be . Variable names Whenever you have a comment after declaring a variable, rename the variable to comment itself. 

Creating a new each time it is rendered is a big fat waste of resources. Create it once, outside the render method, and only refer to it from inside - just as you have done with . Additionally, as I doubt that path exists on all computers, I would recommend using a relative path or use classpath resources (possibly with the Maven tool). 

Technically, those tasks don't need an active Activity. They need a . However, "acquiring" an activity should not be that much of a problem. See below. 

However, this is a sign that you might have too many variables, since is the same as . I would keep the variables of primitive type and get rid of the not-primitive variables. Since and is a regular , I don't see the need for the type. Just be sure to initialize your min/max variables properly ( or ). And then, what you are doing is to always get the minimum of two values, so this can be simplified by using the method. 

However, I suspect you are also interested in who wins, in which case you could have both and return a instead of a . And by the way, I'd prefer to use an for the possible values of each tile. A can have the value of , but I don't believe you want to place a tile in your game. Using an reduces the eliminates any possible risk of invalid characters. 

(200_success and others is right that this should not be ) In Java, the naming conventions for boolean getters are that they should begin with , followed by the name of the variable they are a getter for. So let's say this variable were to have a getter: 

I got tired of running the same command in multiple directories, so I thought "there has to be a way to make this easier". The commands I was running was mostly , , , , and so on and so on... So what I did was to create a bash script that you can pass a parameter to. It will then run the same script or command in all subdirectories, until it finds a place where the script returns exit status 0 (meaning that it was run successfully), then it stops going deeper in those subdirectories. As I am not that used to bash-scripting, I am wondering if there's anything I can improve here. I would also like you to comment on the usability of this script. You are also welcome to make feature-requests, bug reports, or pull requests (my favorite!) on my bash-recursive repository on GitHub. The script is: 

I have a feeling that using some interval for your actions will be very common, so you can abstract that functionality into a with the constructor . In the method, you would then only check for the interval stuff and call the other action method: 

Where is a Or, you could utilize the fact that the method of a set actually returns a boolean indicating if the add was successful and use a . 

As the above output is a bit big, by looping through the integer array you can output just the characters which actually occur: 

Congratulations, you have now screwed up your program! Switching the deltas for any direction should not be allowed, it should not compile. To make it that way, you have to add to your field declarations in your enum (Technically you only need final but it never hurts to put in private there as well) 

EnumeratedRankComparator Now let's see what we can do with Let's use some static methods to create the comparator: 

It's a bit problematic to refactor when the parameters are from four different types of classes. I have a couple of alternative approaches for you though, pick one if you like one. One option would be to make your classes , , etc. implement one common interface. Perhaps this would even simplify your ? If they would be of the same interface (or shared superclass would also be possible of course), then you could use a method like this: 

This constructor should also be Constructor calls constructor As your constructor is essentially initializing it with specific values you can call one constructor from another 

Your indentation is severely off, this might not be something that Code Hunt give score for, but it is what humans pay attention to. Also, don't write the statement for when if is true on the same line, and preferably use braces (I know, I know, I don't like that advice myself when it's only one line but I'm starting to get used to the convention by now). Here is how I would have written your original code, stylistically: 

It's often a bad practice to import everything in a package. this will clutter your IDE's Ctrl + Space functionality, and makes it harder for other people to see exactly which things you are using from a package. 

Note how many times that 3 is declared? Would be better to extract that to a constant, or even better, a parameter. And with a few other changes to the above (as suggested by @rolfl in chat): 

(Yes, you could use a simple for-loop to setup this) Then we have to determine first of all: Is our username in the map or not? If it isn't, that corresponds to our case. 

When you mix and on the same line, it's usually an indication that you are doing something wrong. Your code can be used in any MNK-game which is nice, but this code will not check for a winning condition in this case for a 7,6,4 game (Connect Four): 

Note however that this will throw an exception if the type is not found. So instead, you might want to consider using a where you add all known MeasurementTypes (preferably in a static initializer block), or you can loop through and scan for the one with the right name. Also remember that enums can have methods, implement interfaces, override methods, and contain fields. As I'm not sure what your ultimate goal is, here's an example of what an enum can do: 

And then you of course have to make the related changes in , primarily the function which I wrote like this: 

If you don't get that compiler error in the Code Hunt application, then Code Hunt apparently does things differently. 

Threads Your application seem to be both using and . For Android, I'd recommend using s and/or s. That is, avoid using directly. This is just my opinion though. 

Sessions are meant to be re-used. You should not initialize a new method every time. I believe is OK to use as that re-uses an existing session. As for the rest of your code, I have a couple of things to say. 

In this case though, it doesn't hurt that much IMO to have false-positives, and I must say that your simple filter is quite good. 

No, it is no need to use in this case. Rewriting with You currently check the first item in the list twice. If your code would accept an , you would support even more data types (You still support ArrayList also). The only thing you need is the from the iterable. When you have that, you can first see if it contains at least one item. If it doesn't, return 0. Otherwise, you do similar to what you are already doing, but with different code.