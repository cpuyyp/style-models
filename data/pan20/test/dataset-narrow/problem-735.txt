Personally I am not too concerned about the string-concatenation you use for computing the value when recursing, but there may be a better way with using a pre-computed array, with tracking indices. I would consider the array/index solution a "phase 2" thing if performance is an actual, proven problem. So, having said the above, it's best to explain it with code... I would do two significantly different things... I would set up a lookup table of string-based "digit" keys, and the corresponding character value. I would then loop through that table in the recursive function to determine the matches.... Setting up the table is relatively complicated, but it's a 1-time thing consisting of 2 correlated string arrays: 

Then, in your concrete class, instead of trying to beat the circulat construction logic, all you need to do is to implement the concrete method like: 

Your question here is again an improvement over your previous version, but, I was hoping you would take some of the abstraction suggestions and apply them. As it stands, your program is not a general purpose program, rather it is a complex constant value... Let's look at the things that are actual constants: 

is a red-flag, and should be . Your code will spin in to an infinite loop for 25% of all long values .... anything larger than will cause this loop to become infinite: 

Code Style A number of commonly criticized code style issues are there in your code. The most noticable one is the lack of braces for single-statement blocks. This is relatively commonly found with if-statements, like you have with: 

Note that Scanner never returns an error, it just returns a scan at EOF (or any other error). The advantage for you of a scanner is that it simplifies your loops, and error handling. This is not obvious immediately in your case as you scan the , but will become apparent when processing messages. To get the name, you need: 

Nulls Your code is not very defensive when it comes to null values. If the iterator contains a null, you will have NullPointer exceptions all over the place. Bug If the initial iterator is empty, you will throw a NoSuchElementException when you construct your DeDupIterator. This code: 

This splits the responsibility for managing the 'valid' threads in to two places, and it breaks the single-responsibility SOLID principle. Your model should instead have a callback mechanism, something like: 

If this is the case, you should: Only connect once! The connection to the database should happen outside the loop (not a new connection for every record). The , and should all be 'prepared' outside the loop too. You should select more than just 'TOP 1' from the results, and you should probably be careful with your transactions so that the database performance is not limited by the amount of time it takes to unzip a file 

Use the slower Random to seed your class, then let your class run with the rest. Note, there is no real way to use the time systems in a computer to get random values... it's just not infused with enough entropy to be random, or predictability to be reliable. 

On my computer, the difference between this optimization and a naieve step, is 0.022ms vs 4961.271ms (or 225000 times faster!!!!!!!) 

Note that the fastest run (91.5ms) has the slowest 'Calc' time. I am not sure why this happened. I believe the variances I see in your code are in part caused by the increased thrashing your algorithm puts on the garbage collector. The other algorithms result in more stable performance. Compare your fastest time to the alternatives. I suggested one in the answer code I supplied before. In my test framework, it looks like: 

Note that is available in Java 7 and later but, the readAllLines version I use above is in Java 8 only. You need to use the CharSet-based version of readAllLines if you want it in Java 7. So, you can read your file easily, make it static: 

Note that the community consensus for code style in Java is that braces should be opening at the end of the line, not the start of the next. I understand if your local work environment may have different "rules", but you should be aware that it is different to common Java style. Your variable names are awkward. Things like "uneven" are not the opposite of "even" in this case, the opposite is "odd". Also, and are variables that I could not "imagine" what they are short for. If a 1-letter variable name is not special, it should at least make some sense... is for , use and in coordinate type variables, use for , or something.... but in your context and I cannot think of something that and could mean. Your main method, and the way it accepts the argument for the "size" of the test list, confused me a bit. I had to figure out the format of the input, etc. and how to make it run. You should comment things like that. Now, about your algorithm.... it is not bad, it essentially builds two lists, and appends the one to the other, but I am concerned about the exit conditions of the loop... you have multiple of them (the for-loop conditions, and then multiple conditions with "recovery" after the loop. This is because you are tracking multiple pointers through the source list. If you just iterate with one pointer in the source list, and have conditional code inside the loop, it's cleaner. 

That's complicated, I guess, but really it sets up two tests, one which parses 2000 input values using the forgiveness method, the other test uses the permission method. It runs each test 1000 times, and then takes some measurements of each run, and reports on it. The report, on my computer, looks like: 

A common practice in Go is to use a boolean to indicate a success (receive on channels & values in maps). You are using an error instead. I would have written your signatures as: 

Note how much more logical that main method is. Digits In this case, because you have to transform from different digits following each other on the line, and because each digit spans different lines, I would probably create a "Digit" class which has a method "getRow(x)" where the rows are from top-to-bottom..... For example, the Digit will output lines like: 

The next item is whether you can guarantee that the static methods on your class will only ever be called from a single thread. If you can guarantee this then the code will be good. If not, then it is possible for there to be 'transient' situations where the network 'blips', sending a 'network down' followed by a 'network up' notification. If they come from different threads then it is possible the the NetListener instances may get the notifications out of order. For a thread-safe system I would create an enum with three states: 

This will prevent spurious wake-ups, but if you have asymmetrical code (more than ) you will get exceptions (I think that's a good thing). In your method you can also gain some efficiency by not using the queue at all if you're the only active thread... 

Resources You should use try-with-resources for your IO sources and sinks. As things stand at the moment, you don't close the readers properly. Algorithm You're reading both files in to their own sets, and then merging the sets, and then outputting the result. A better solution would be to use the boolean return value from the method to determine whether the word has been seen before... consider: 

At worst case, now, the only risk is that the mail fails to send. That should be logged in a reliable way that allows you to (manually?) identify, resolve, and resend the mails. Note that a failed mail will fail whether you mark the Campaign complete or not, and repeatedly resending the mail will not make it suddenly work. There is no reason to save the campaign after the mail-send. 

If begin or end are less than then you can do a binary-search on and then just output those primes while they fall within the array, and between and . No need for calculations..... Your inner loop scanning primes should terminate when > . At the moment, if is 31, you are scanning all 3400 primes to see if they are factors.... ouch. 

This is repeated for each file. It's unnecessary, and can be removed with the option to inotifywait. You are using the event to track. This is triggered when the file is created... but is that what you want? A download may take a while to complete, so moving the file part way through a download may not make sense. Many programs will continue based only on the filehandle, which does not depend on the file location, but not all programs will behave well if the file is moved part way through. You should consider tracking the event instead. This will only trigger when a file handle is clsed after a write to the file handle. I expect this will track the 'end of download' rather than the 'start of download' (the way you have it set up) will only notify when the first file is created. This leaves you open to race conditions where a download may happen when you are copying the file to a new location. This new download will not be triggered on the next cycle because it started before the wait. As a result, you are at risk of losing events. 

The is fine, but the and should be final too. Additionally, there is no need to put the initializer in to a constructor, it can be constructed at declare time. Also, it can be just the interface that's used, not the concrete class . That removes the need for the constructor entirely. 

Which requires 1 character, and then up to 18 'broad' characters followed by a constrained alpha/digit character. EDIT: 2 things: 

unless you have a good reason, when you use a loop like this, do not declare the loop variable outside the loop (in this case, the ). It makes things confusing. Using in the substring leads to confusion. is the full string length, and it implies that you are going to get more characters than there actually are. In this case, the method silently ignores your request for too many characters. You should do this explicitly by using instead of the variable is completely unnecessary - use 

Generics Generics... you want them. In your solution, they would be relatively easy to apply too. Consider your Node class: 

Instead of doing the System.exit, I would prefer a less abrupt exit. Consider a custom Exception, like "EndOfProgramException" which you can catch.... 

It's an interview, and you have been given the opportunity to show off what you know. If I were "assessing" your submission, what would be my impression? Don't use things badly. Your code here is horrible: 

Almost the entire Swing GUI framework has been built using this system. Consider all the Listeners available on JComponent and all the Events that can happen. Each Event has a corresponding listener available. 

So, what you do is look for the possible variables in the input, instead of looking in the input for what could possibly be a variable name, and then seeing if it exists. Now, this process will be slightly slower than what you have, but normally the environment is small (less than 100 or so variables). If you have a crazy environment, you may suffer. 

Is this method really a problem? Why are you worried about it? There are some small changes you can make, but they do not have much of an impact on the performance of the routine (if it is slow...). About the only things I can think of improving are: 

I would prefer to see the logic a bit clearer in the sense that first should be handled first, and it can be done like: 

Note that the above code puts a waiting process in to a spin lock (100% CPU) instead of locking. This is the same as your code. My preference would be to use a more traditional Lock (or even synchronization) and block threads that are waiting. 

before you add the to . Also, I would avoid the array entirely until the button is complete.... Result 

The GC will only nequeue newly cleared soft references. Further, from the SoftReference.get() method, we have: 

Return-Early Having suggested the RegEx option, I would also suggest a simplified lastIndexOf/indexOf using early-returns, instead of nested if-blocks: 

Your code's general structure is decent. The Single-Responsibility-Principle is established by having relatively clear logic structures in the , and methods. While the basic structure is fine, the actual bitcount algorithm is very inefficient. Recursion is not the answer to this problem. Even if recurstion was the solution, I don't like how you find the low bit, and I don't like your terminal conditions. Additionally, actual bitwise operations should be used to count actual bits. Additionally, your continued use of 1-liners for conditional blocks is disheartening. So, if you have to use recursion, something like: 

Note that many text books extract the first 3 stages in to a 'partitioning' function. The purpose of that function is to identify the pivot value, move the candidates around, and then insert the pivot value back in to the data at 'the right place'. That last part is key, it leaves the pivot value in the exact place it is supposed to be. This means you never have to include that pivot value in the sorts again. Let's break that logic down in to it's methods, then, with the assumption that' there's a 'pivoting' function that does the first 3 steps. That leavs a simpler quicksort that looks like: 

the OP_READ is deregistered. the client handler is scheduled to run on a different thread the main thread goes back to monitoring the selector 

A test to see if recursion is needed A recursive function call A computation for the current recursive level. 

Then, in your other methods you should reference the 'public' base variables instead of , etc. Finally, you should add values to the class that indicate thresholds for things like and . All the currently 'abstract' methods on the should instead be full methods, but should be parameterized. For example, the method on : 

This makes the purpose of the code more apparent. Also, a bug is that you have to declare this ourside your method. It should be a class-variable, not a method variable, otherwise it will always be the wrong value. The bug you have is a technical one (but important that you learn) ... will never return the input . It will retrun (inclusive) to (exclusive). In your case, with it will only ever return , or . Change that to be and you will get the values , , or and it will be 1 third of the time.