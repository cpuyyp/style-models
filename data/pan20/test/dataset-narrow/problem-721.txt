that may use JSON internally where you can setup the de/serialization process as required by each file. Generic solutions almost never work in such cases. 

Computable properties are based on the interface with a single method that requries the current log. 

I have to disappoint you beceause it is not . Class members are by default. Having as a field is a very bad idea. If you ever decide to make your application run queries in parallel they will close each other's connections so they should not share it. It's always peferable to make everything as much function local as possible if you don't want to debug tricky bugs. 

Functional and OO mix This is kind of a mix of functional and OO programming because the class is carring a state. In a pure functional way you would provide the method with all it needs this means it would require the generic parameter and it would be an extension: 

If you used the enum instead of just calling it like that, your methods might have be implemented as: 

You can improve the by reusing the argument so that you have only a single instance of the helper. The helper maintains a that stores senders that are currently handled. This will allow you to use the return value of the method which is if the already has been added an thus acts like your variable. Finally you the from the set as if you were setting to . 

Since is a you should use . You might be sure now that it is either null or a valid string but this is a dangerous assumption. 

Currently searching for a persons would be faster because it is a key in the dictionary. You could add another dictionary that maps numbers to persons and make the number search as fast as person search by looking at the key instead of searching all values: 

If the collection is empty then the loop simply won't run even once. You use a list here so doesn't do any harm but if you had a deferred the it would execute it. If it performs some heavy work this could be very bad for ther performance. 

Example As an example of how I'm using it, I post one of the unit-tests I created for it and the schema of the test table. I import the test-data from a CSV, I turn into a and pass this to the seeder which takes just 4 lines of code (not counting the constants). 

With LINQ you can get the job done quickly. Is it sometimes slower? Maybe, but who cares? Most probably no one will ever notice that unless you test it with an insane number of elements although your production code will never ever see that many. If you need to optimize something then run a profiler first. Why? Because if we assume for a moment that we use a poor comparer here and you only work on optimizing the loops you'll never find out that actually the comparer is making your code running slow, no matter how hard you try. People say LINQ would be slow so you focus on optimizing its queries but not the comparer bottleneck. Usually there is something else that kills the performance like reflection, poor comparers, string concatenation or other calculations and only rarely LINQ. 

The last extension in this class allows to chain another expression and more validations. Here are some examples (the lines throwing exceptions are commented out): 

I don't find many things to complain about :-) but this bothers me... I would change the name of those variables: 

Benchmarking The s shouldn't measure thier execution time. What if you want to run it more then once? You cannot measure the entire execution time. Instead create a . 

Test repository This repository creates a sql-client-provider and initializes the tables and columns with types and lengths. It also provides a test method for selecting settings that uses the framework. 

Possibilities I've created a simple renderer but you could add an abstraction layer to it and use it via DI to implement the method of the . You could then write various renderers that render simple strings or html or xml or whatever you want. As long as you keep each functionality in a separate class you can easily extend it and make adjustments to any of them without affecting any other working parts. 

Unless you are really searching for any file extensions that conatin the using would be a better idea: 

You have big lambda here with even more nested lambdas. Consider refactoring this into separate filter methods that you can test and maintain independantly. 

I think it's a good idea to stick to the & convention like the console does it. Then you can turn this: 

Seeing this method I would say the same. You cannot easily add new call-types and you cannot easily change their rate because they are all in the same switch. You have to open it every time. The Open-Closed-Priciple is violated. Even worse, the rate is not a part of the call-type but some magic number inside the switch. What you can do is to create a class for each call-type. This means forget about the enum. Remove everything but the basic stuff from the and give it a constructor: 

If two categories is all you need then it's easier to use instead of . With it you'll be able to select the group by a value: 

Before you do other things you should separate and encapsulate, this means you should put certain logic into their own methods that specialize in doing only one thing. If you put e.g. the loops in such method methods, you won't need any comments. Here's an example of how it could be done with C# 7. Also notice the changed names. There's no need for the prefixes. This is just a start and there is much more to improve. I left it out intentionally. 

Look at these three methods. What do you see? They are virtually identical. In fact you don't need them at all because all types that you convert to have the same three properties. All you need is just this interface that all three classes implement. Alternatively you can make the an abstract class and the base class for the other types. 

This design will allow to add more levels anytime and to customize the basic-form. I also think with small adjustments (if necessary at all) you should be able to reuse the level definitions for multiplayer. 

Now let's get improve the variable. This one is really confusing. Is it asc when it's or ? It'd be much easier to use if you named it . Then is the same line: 

Such a template contains only a message that is rendered from custom properties (if any) and the name of the exception is derived form the template's name. 

More interesing is the that will enumerate my timestamps on each access to the property or it'll throw if there are not enough of them: 

IProgress interface To see the errors right away you may try another approach with the . Here's an example; 

You can also exagerate and make it pure LINQ method without any manual loop but personaly I think the loop looks better: 

But what is ? This is the new delegate that is passed by the caller. He'll recive each index array via this parameter so the new signature is: 

HashSet Instead of having a list with predefined lengths, you can calculate them based on the max length and save them in a for faster lookup which is O(1) in comparison to the list where it's O(n). LINQ To determine whether a word is a pyramid you can use LINQ where you first group each letter and sort it in the ascending order. Then you check if the count is increasing by one: 

This is also a no go. I'd be really surprised when I found that my command has been disposed by the method using it. It is however a good idea to maintain the command by the method. It would be better if you hadn't to create it outside. I suggest this design instead: 

Let's refactor it a little bit toward SOLID. It's not yet perfect but is should give you an idea how to start (you should take @Heslacher's advices into account) 

Well... there is no quality yet ;-) and actually you are going to gain some code if you want to improve it. I won't try to prove whether there are numbers that can break this fraction in any way but for the sake of the review let's assume the denominator can be zero. 

Sure, you can always write your own method for everything but if you are lazy you could just use LINQ with + + 

From this interface you can derive all your connections. There you can have a default constructor to create default connections or a parameterized if you need a different connection string (for example when testing): 

I think you'll know how to use it. Save notification as you do and later get only those where the property is null. DbContext 

SRP A downloader should only be able to download. If you need to search for urls or parse some websites then you need other classes that specialize in such tasks. Don't put all these responsibilities insinde a downloader. It's not its job. It might even turn out that you will have only one downloader but mutliple website-parsers or link finders etc. 

In the last rows of the statistics you can see that short version is about 3 times faster then the original one. 

Alternative solution There is a much shorter way to get the same results. You could use two different regexes: