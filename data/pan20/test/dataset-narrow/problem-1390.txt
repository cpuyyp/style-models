Really, there are a lot of things that you can do, here. Perhaps your cutscenes might appear "out of sync" if you line up animations with key moments in the text... That's okay, if you teleport forward in the scene, as well as on the cards, or play everything at double-speed if people are trying to fast-forward the text... ...or selectively choose which animations appear in fast-forward or not... ...or just ignore it altogether (as long as player-state is perfect when the game starts again). Players who are actively trying to speed-read, or are actively trying to skip the cutscenes and get back to gameplay aren't going to be upset that you didn't find a way to convey ALL of the animation and voiceovers, et cetera, in the 500ms that they were willing to wait, before playing again. The point is more that you should try to appease both, if possible, and do so without stepping on your art, unless they're asking to skip it. 

The animation module would be listening for the event, and would change the current animation. The opposite check could be added to an method. This might be overkill for a Pong-clone... 

Now, instead of finding ways of tying everything together, you're dealing with custom events, the names of which you name, followed by agreed-upon types and numbers of function parameters... The disparate parts don't know anything about one another. So when you make a multiplayer character, you might use a moderator as a way of registering to receive network updates. If you kill that multiplayer character, it doesn't really need to update its network position any more, so you can unregister it from the moderator. A player character who gets knocked-out or stunned for a short time might also be unregistered from receiving controller updates. Once your components are this loosely coupled there are all kinds of things you can do. You might also have, say, an achievement system and a goodie-unlock system which listen for your kills, and unlock after you reach X. Now, instead of having to be hard-coded into the middle of your player class, they can just listen to the same moderator, to be notified of the same event. You could also have multiple moderators... For component-based stuff, this is usually the half-way between OOP and 100% entity-system. For example, you might have every player have their own internal moderator. That moderator might be the talking point between each of the components (like when a control tells the movement to jump, tells the skeleton to change animations, tells the IK-engine to blend the jump in with whatever you were doing, etc)... ...and then the player might be given access to a "global" moderator (or one which manages ALL players). And that moderator would handle all communication from the player(as a whole) as it needed to be broadcast to the outside world. 

My plan has been to use RSA to exchange AES session-keys with a client, which is then used for all the usual in-game stuff. Clients never connect with each other, all communication is client to server only. The question is: Would I be wasting my time by encrypting the communication? How are big AAA multiplayer games doing it? If I do do encryption, is the basic scheme I mentioned a good start? 

The strength of this is that I can scroll the map by changing the map surface x and y. Also all the ingame coordinates are conveniently set in relation to the map rather than the screen. However I can no longer use pygame, and I'm trying to switch to pyglet instead. As far as I can tell pyglet doesn't have an equivalent class built in, and therefore I need to build my own, this is what I need help with. I've used pygame.Surface extensively without really understanding how it works (python programmers these days huh). So I'm hoping you can offer some insight on how to get started. I know it needs a width and height, as well as some kind of list of the sprites which have been 'blitted' to it, and that moving the surface itself moves all the contained sprites, so surfaces blitted to it are somehow anchored to the surface rather than the screen. How is this stuff done in pygame, and how do we create a pyglet friendly version? 

I've tried googling and haven't found anything concrete (obviously), except that using some kind of sleep is bad design for these loops. So how can I alter this to slow the whole thing down, and avoid having 100% cpu usage for a program that's not doing much at the moment? 

I can't concretely prove a bug by using this, but it kind of looks and feels like it should at least be undefined behaviour. So is it OK? If not, what is a common practice for dealing with this situation? 

A very small map surface, with 8x8 tiles will make my CPU (amd 8 core 3.10ghz) run at 25%, with 70mb memory used per client (the cpu-fan goes crazy). The frame rate is still normal at this point. A slightly larger map, 16x16 tiles shows a drop in frame rate, down from the desired 60 to around 48. A map of what I'd want to be small/normal size for a real game, 40x40 tiles, brings the fps down to 12 and uses a surprising 215mb memory (all the spritesheets combined are 22mb, and I'm only using a basic green tile for testing), with the same CPU utilization as before. On the same 40x40 map, replacing the image sprites with blank 1x1 pygame.Surface objects results in a frame rate of 27 (it's set to 60) My basic question is this: Is the problem likely to be in my code, or is pygame itself horribly inefficient? If the latter, is there anything short of learning to code c++ that can replace pygame for these purposes? If the problem is more likely to be in my code, how can I find out what it is? EDIT: I profiled my code, and here are some of the highest numbers map size 40 x 40 tiles: 

You've got a few options, but really, the two which make the most sense in regard to an isometric-projection (45-degree angles), are tiles and full-fledged 3D with a static camera (look at XCOM, StarCraft II, Diablo III). Of course, you can also do without tiles if you're, say, making a game like TMNT2 - The Arcade Game or River City Ransom, and it's an old-fashioned hallway brawler, where in a modern version, rather than tiles, you could use one large hand-drawn background, if you wanted, (plus parallax images) and then create collision-nodes in-place, on the map. Also, creating a map using tiles becomes vastly more simple, as soon as a map-editor is written. What is the client actually trying to accomplish, here, and on what scale/budget/timeframe? 

while just having a larger constructor function. There is an argument to be made for objects which have 15 or 20 pre-conditions, which would make a constructor very, very hard to work with, and it would make things easier to see and remember, by pulling those things out into the interface, so that you can see how the instantiation works, one level higher. Optional-configuration of objects is a natural extension to this; optionally setting values on the interface, before making the object run. JS has some great shortcuts for this idea, which just seem out of place in stronger-typed c-like languages. That said, chances are, if you're dealing with an argument list that long in your constructor, that your object is too big and does too much, as is. Again, this is a personal-preference thing, and there are exceptions far and wide, but if you're passing 20 things into an object, chances are good that you could find a way to make that object do less, by making smaller objects. A more-pertinent reason, and one which is widely-applicable would be that the initialization of an object relies on asynchronous data, which you don't have, currently. You know that you need the object, so you're going to create it anyway, but in order to have it function properly, it needs data from the server, or from another file which it now needs to load. Again, whether you're passing the needed data into a gigantic init, or building out an interface isn't really important to the concept, so much as it's important to the interface of your object, and the design of your system... But in terms of building the object, you might do something like this: 

If you want a list of things to do to end up with sprites like what you end up with in Diablo / Diablo II / StarCraft / Fallout, then the first step is to create your 3D model, texture it, and animate it (walking, attacking, hurting, dying, etc). Then, when all of that is done you want to set the camera to the same angle as what you would see in the game. Then you would turn your model 45 degrees and save pictures of each stage of each animation, and keep doing that until you had pictures of every model, in every animation, from every angle. To save space, things that didn't make sense to happen at every angle didn't. Treasure chests were not shown from the back, et cetera. Some games had characters that could look straight up and down, and straight left and right, but other games only used characters who were facing on 45 degree angles. To add multiple kinds of armour, using the old-fashioned Diablo II procedure, you'd have to put each KIND of armour on your model, and save out all of the pictures in all of the poses in all of the directions. I say "KIND" of armour, because most of the armour was just recoloured versions of the same model. They did that recolouring in the game. So you'd make one kind of gauntlet, and add that to the model, and then in-game, you'd just recolour it. BUT if each type of character needs to look different in chainmail, then you need to model each kind of character wearing chainmail. There are more-modern ways of doing this... ...but if what you want is for the game to look like Diablo II, then this would be the way to accomplish it. Saving all of this to a sprite-sheet is relatively simple: You take all of the little pictures and you copy and paste them all into one big picture. For the purposes of importing the sprite-sheet into the game and making it dynamically-usable, or for the purposes of using "masking" to change the colours of armour, et cetera, those are outside of the scope of your current problem. Also, if this sounds like it's a lot of work to do manually, it really, really is. But that's why you want to look into "Batch Processing". So that you can write a script that says "Take all of the versions of this model, and for each animation, save a picture every X % of the way through the animation, and name it ".png" You could then write a batch process which would take all files in that folder, and put them in order, or put them out of order... ...or make one huge spritesheet, or just make one spritesheet per character, per armour type, et cetera. A more-modern game might treat the character like a ragdoll. 

So it appears a lot of time is spent appending items to lists, but I'm sure not what kind of other, more efficient method of organizing my game there is. As expected however, blitting pygame surfaces trumps the other functions by a huge factor, as shown by the cumtime (whatever that is). So I guess the question is the same, can pygame be replaced by something, or might there be a more shallow problem in my code still? 

I want to determine which sprite to use when one agent is "facing" another agent. My game is 2d, and uses 8-directional movement. Deciding which sprite to use for movement is easy enough since there are only 8 options when moving form one square to another. 

My game uses an entity manager and entities to represent everything including the player, enemes, items, ..everything in the game. In my engine it's the responsibility of every entity to update itself. Sometimes an entity finds out it has expired somehow, and thus needs to remove itself from the entity manager. My question is: Is it safe to have an object delete itself? I will illustrate what I mean. 

I'm trying to understand what kind of operation the author is talking about. If I'm getting the overall point correctly, it's that accessing elements that are closer together in memory is faster, so therefor it's desirable to reorder the array such that there aren't any holes left when a game object is deleted. If that is what the author means, then how is it possible to implement? This is what I'm imagining: 

I'm trying to make a tactics game using python and the infamous pygame library. I use threading for networking and pathfinding. The game uses a p2p lockstep architecture, with one of the players acting as a host. The server starts 2 threads (send / receive) for every connected player. All the connected clients also start 4 threads during their lifetime, 2 for networking, one for the main game loop and a new temporary thread for each pathfinding request. My problem is that the program uses a lot of CPU and memory, even for very small maps, even when not blitting any sprites with transparency or running any pathfinding algorithms the program is slow and CPU intensive. The map in my game is built out of tiles, which are 96x96 pixel pygame surfaces, which map sprite images are blitted to 

This makes instantiating and deleting the event somewhat more tedious, but at least it allows me to use specific types for every event handler. What is the conventional approach to solving this problem? Even better, what is your own ingenious solution? Thanks. 

But that can't be right because just rearranging the pointers doesn't change how the memory is organized. So the author must be talking about something I don't understand about memory management. My question is: Have I misunderstood what the author meant? If not, then please explain how the author is suggesting the rearrangement is supposed to be done. 

The benefit there is that you can now use dependency-injection/inversion-of-control more-easily in your systems. Instead of saying 

Well, the problem as I see it is that people use the term too loosely, inasmuch as they refuse to specify what kind of "GAME ENGINE" they're referring to. It's not that "Game Engines" aren't full-fledged things, which handle all aspects of the game... ...or that they can be. The problem is that a Physics Engine is an engine which is self-contained, and will accept inputs of things to do work on, and will output the equivalent in work, after the engine transforms the input. So is a Lighting Engine. So is a Graphics Engine. So is a Sound Engine. All of these things meet the qualifications of being an "engine", as a lexicologist might consider it, in the abstract sense, and all of these engines are game engines, in that they are all engines predominantly written to be used in games. The extra layer of frustration comes in when you consider that you can have an overarching game-management engine, which wraps ALL of the other engines, as plug-ins, or as bolt-ons. This is something which doesn't really happen often, in the real world, except when thinking more of fully-autonomous corporate subsidiaries... Dell bought Alienware -- Alienware is still allowed to do its own thing, in a modular and self-contained way, but the self-contained entity known as Dell has wholly-encapsulated it (with a few "API" Alienware-branded touchpoints left exposed). So now, most of the functionality of Alienware is still held by Alienware, still self-contained, still a revenue-engine... ...but it's owned and operated in a loosely-coupled fashion by Dell, who, themselves, are their own revenue-engine. OpenGL isn't really an engine, because there's nothing particularly self-contained about it. There are no well-defined inputs and outputs. Consider it like Calculus -- something goes in, you know what's coming out. A graphics engine might be one where the resource-management engine hands the graphics engine the textures, and the physics engine hands the graphics engine the transformed polygons, and then the graphics engine will make all of the magic happen, and can be loosely coupled through bolt-on/plug-in interfaces to work with OpenGL or OpenGL ES2.0 or DirectX or Canvas/JS or Flash/AS3 or a software renderer, based on switches, but without other graphics work happening externally. Is it an engine? Sure. You've got well-defined inputs and outputs, you've got known quantities/properties for input (fuel) and you have expected results. Wrapped inside of a game-engine, is a specific engine still an engine? Yes. Do fans/journalists/etc get the distinction between Rage being an overarching game-engine, Havok being a physics engine and Euphoria being an AI+physics "natural and procedural animation" engine? Not remotely. Is it still an engine? Yep. Also: "game engines" aren't a requirement at all. Pong is totally doable as a bunch of procedurally-called lines in Notepad.exe But as complexity of game-code, as well as complexity of visual and state-managing (RPGs) expectations rose, engines made life better, whether they were physics engines, graphics engines, lighting engines, sound engines, combat engines, stat engines or just flat-out engine-configuring/running engines...