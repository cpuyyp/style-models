will generate a single vector due to fusion, not three intermediates. Depending on the used version and optimization level, you might even end up with a single loop and no generated vector at all. So immutability doesn't prevent optimizations. Quick Sort on the other hand really needs mutability. So a variant ( or ) is more appropriate. Interface Now that we know that it's fine to use an variant, let's have a look at your code. First we look at 's type: 

That's again a DRY violation. If you change the price, you have to change it at two places. That's error prone. Instead, reuse the information you already have at hand: 

I usually keep the number of prime functions or variables down, too, and use them only if they were derived from the original one, e.g. 

And last but not least, I would use the same promises as the usual C#/F# functions: either throw an exception when the value has not been found, or return an . That way, if we got an , it's valid, so we don't have to check for an invalid position. I've choosed : 

However, credit card numbers follow a fixed pattern, and therefore are a perfect candidate for regular expressions: 

Keep the errors on the error stream When a program has a lot of output, you usually pipe the output into a file: 

For any non-positive , the list should be empty. should execute the actions and collect their results, e.g. 

All in all, your code will work, but we can improve it. Write functions in terms of other functions You have written both as well as . However, you only need one of them. The other one is the d variant: 

First of all, there is no need for 's first parameter to be . More on that later. Also, it will get easier if we switch the parameters. Also more on that later. So let's start with that modification: 

You stay in the respective alphabet while shifting and therefore not lose the case. Up to that point, everything seems fine, right? Now we come to the mentioned bug: 

takes a range, so we end up with the correct numbers. Your program choosed numbers between 0-99, by the way. However, now we can also get the rules in there: 

Other than that, your code seems fine. You could use better names and documentation, but given that you write code for a code challenge, it's not that necessary. You might want to use a binary search for your limits, though, if you need more speed. In , you can speed things up if you use bitshifts instead of . You can speed up if you calculate the Fibonacci numbers there. That prevents you from calculating the same sequence over and over again. Hint: you can implement as a generator, which makes this a lot easier. 

I've written a small Tcl/Tk script for a friend that displays the current time, as well as a quote. He uses it in some project with a Raspberry Pi, and since I didn't want to cobble up something up in Qt, PyQt, or some kind of website, I tried to write something in Tcl/Tk. Demo Here is how it looks in the end: 

So instead of use both as well as as upper limit. In , you return on if the string hasn't been initialized. This should either get documented or checked. Consistency should also set to zero. That seems to be your "empty string" scenario. Don't include the in If the string is empty, should return , not . or don't return the either. 

That way you're also more likely to expand the documentation in your implementation file, not only a brief comment: 

we can now say which characters we want to change. But we can make even more generic. At the moment, we need a list of keys before we can actually call . But that prevents certain kinds of ciphers, namely those that work with the value of the previous character. We need some kind of state for that. Here's where that hint from my last comment comes in: 

Don't repeat yourself You print the sorted number twice. And maybe you want to print the digits at some point, too. Create a function for that: 

First things first: is this a good variant of FizzBuzz? Well, yes. I would probably write the same variant, except for whitespace and types. In your usual Haskell code, you want to annotate the top-level bindings with their types: 

which would mean that your pointer is constant, but not the value it points to. Further improvements Your is a tad to complex. Don't be afraid to simply when you're done with the job. And move conditions that should be checked once out of a loop: 

Your old version returns on , but your new one returns , unless you also check . Therefore—At least in the sense of asymptotic analysis—both variants will have the same performance. 

Regardless, the string type depends of course on your later use case. Since hints that you will decode JSON, you will likely use aeson later, which uses lazy s as well. Given those functions above, we could now write as 

Whoops. The doesn't get checked, and you don't get a warning (in older compiler versions; new ones do warn about possible whitespace issues). If you declare your variables later (e.g. C99-style), errors like that cannot happen (although it introduces possible shadowing): 

Create functions You saw the example above already: . We can use functions to make the game easier to read and to extend. For example, all your s might not work at the moment. What happens if the user inputs a at the start? Or even a letter? Instead of handling that error at every occasion, let's write a function that covers that: 

Since you seem to prefer guards, we can also write the other cases first instead. Why? Because I prefer to use guards or patterns with clauses last (personal preference, really): 

Use descriptive variable names for iteration is fine, but for "exploration reason why" isn't. Keep the scope of your variables short You already use C99, so keep the scope of your variables to a minimum. You never use outside of your in , so move it into the loop, for example. Use instead of magic numbers on arrays with static size In , you use twice: 

As you can see, I don't use names for things I'm not interested in. This makes it possible to focus on the interesting parts, e.g. the and matches, and the single-element match in the last line. Now, your other definitions get a lot easier if you don't use guards, but pattern matching instead. If we rewrote the next pattern with your style, we end up with: