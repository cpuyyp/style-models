This function should have some appropriate error handling too. Then, your code can become simplified like: 

Then it "just works". Call Directions I don't exactly know how to describe this problem I see in your system, but you are doing things backwards. You have multiple entry parsers, and they all get polled to identify whether they can process a certain set of data. When they can parse the data, they then get given a 'reader' from which they can read more data. This is a problem because the parser should no tbe given the reader... it should instead be using a push model. Consider a bunch of entries you want to parse from the logs. Create a single 'nexus' that is fed lines. It starts off in an 'idle' state. Then, as it gets lines, and it feeds the lines to the possible parsers, until one of them can handle the line. If one can handle it (), it lets that parser 'own' the lines until the method returns false.... 

This process is effective, but not very efficient. What if I were to tell you there is a way to solve the problem without having to do step 3, just by remembering what you did in previous iterations of step 1 and 2? The way we do things, is to remember the size of previously-computed squares of set positions. We remember the previous row, and the current row only. No need to remember more than that.... Looking at your example: 

The way the regex works is that it looks for two things (the regex is in two parts - using "lookaround" expressions).... 

Code Style Read the Java Code-style guidelines. Java class names should start with a capital letter. 

This class breaks the contract of Equals and HashCode.... when two objects compare as to each other, then their values should be the same. Since you have tolerances on the equals method that are not consistently applied, you could have many technically different points all being equals, but they may all have different hashCode results. Instead of forcing your method to have a constant, or predefined tolerance, you should instead have a parameter you can pass in which allow a custom method that is independent of the HashCode/Equals contract. In addition, your hashCode() method is broken too: 

The text-to-key problem is one that has multiple solutions. The Map solution is a good one, there's nothing wrong with it. There are two other algorithms that are good too. First, though, please convert the char-to-key to a function. Having such a big loop is a problem. 

Well, your code is neat, and you use the Try-with-resources structures well. There is one potential bug, which is that there may be lines whihc have a 'successful' , but no which would cause an IndexOutOfBoundsException. As for the performance, the key here is Amdahl's Law.... essentially parallelization. You have five CPU intensive parts to your problem: 

Hmm.. I was expecting this to correct the errors in the 'randomness' too, but, now I see the problem there.... you are using , and not . Float has relatively low accuracy. If I change this line here: 

Now you have hard-coded Quotes, and you can add and change them at will, and the array changes along with them. How do you use this? Well, your main method becomes really simple then: 

Often in larger projects this type of handling becomes quite regular, and it is common to centralize some of these validation processes in to a 'Utility' class that is reused. This is especially true with unit-testing, and I commonly see something like: 

Using an enum will only help if you know all the values/keys at compile time. If your data is coming from a database, then you can't know that, so you can't use an enum. Note that your question assumes a double-key - the value is unique, and the value is also unique. There are three common ways to do this problem, the easiest way is the one you have done, and then store the data in a with the most commonly used lookup as the key, and the less-common lookup as the value. This makes it quick to find the most common search on the key, and slower, but possible, to find the value. I would improve your code by throwing an exception when the lookups fail to find a matching value. If someone asks it should throw an exception... right? The easiest solution for this type if problem is possible if you can assume that the key domain and value domain have no overlap (a value cannot also be a key). Since your keys and values are ints and Strings, it's clear there is no overlap. To use this solution, create a "mapping" class, call it or something: 

scan each position in the input if your sequence will be longer than the span, remove the unneeded digit using division (if the value is non-zero - or decreasing the zero-counter if the value is zero). if the next value in the sequence is zero, increment the zero counter, otherwise include the digit by mutiplying the product. if the new product is larger than previous products, then remember this new maximum report the maximum. 

There are any number of ways you can add validators to the the system, config files come to mind as being an easy way to manage them without code changes. 

Bearing that in mind, this answer becomes 'complicated'. Basic performance improvements for current code: 

Here you have taken a copy of the array, and put it in the array. Then you calculate all permutations of the remaining 5 digits, until the head-5-digits of the number change. I calculate millions of iterations in that loop that are wasted. A better solution will use some mathematical properties to limit the problem significantly. For example, the basic formula you have, is: $$ A \times N = B $$ where and are both 5-digit numbers, and N is an integer. Additionally, none of the digits in A are in B. Using this, we know that: 

Your code is asymmetrical.... You open your inside the using block, but you close it outside in the final block.... anyway, the Close is completely redundant: 

The right-to-left product is going to be the same as the left-to-right product, top to bottom will be the same as the bottom to top, etc. There is no need to calculate all the values in both directions. All you need is to track the maximum... Comment out the lines: 

Note that I suggest using the class. The Objects class simplifies and methods. I do a bitwise XOR on the hashcodes of the two values, but at most one will be set. Note how this class would be used (a RuntimeException declaration will not need a throws clause, or a catch block).: 

This code is a WOM implementation of a stack - Write Only Memory. Normally it's done as a joke. The only way to get the data out of the stack is to parse the standard output waiting for statements with the values in them. I can understand that your code is here for you to watch the process happening, but beyond that there's not much real functionality in here. I encourage you to use proper code where the methods actually return their result, and the calling code is the code that prints the output. Alternatively, I strongly recommend you use the IDE's debugger interface to step through your code so you can watch things happen that way. Having said all that, here are some general comments: 

That would need to be wrapped up in to a method that handles the IOException, and cleanly closes the file: 

The and fields in the should also be final, and instead of being public, should rather have 'getters' for them. Sorting You have special handling for the buckets and the ranges, depending on negative values. This special handling has also resulted in a lot of code duplication. You essentially have two complete method duplicates, one for sorting the high-byte (with negative values), and the other for sorting the remaining low bytes. Your code 'buckets' the data (or a data subset) in to buckets based on a significant byte. The challenge here is that the most significant byte has a different sort order than other bytes. The trick to solving this is to flip the most significant bit, and the resulting order is now accurate as if the long was unsigned..... Your code would boil down to something like: 

Note how there is only one join, using left outer joins. Also note that a count of a null value is 0, so the null values in the outer-join results do not contribute to the sum. The construct allows you to count the things you are interested in, even if the query returns them in multiple contexts. You will need to carefully understand the query, the implications are different to yours, and it may be more accurate than what you have (or less accurate). 

Normally I would take issue with the short variable names, but, in this context, with the generic array data type, is not too bad of a name. The only style issue I have other than the , is that you need space around the operators in your conditions and assignments. The code: 

Now, that runs in \$O(log(n))\$ time where is the integer being tested.... but, can it be a bit quicker? I don't think the time complexity can be significantly improved (i.e. I can't see an \$O(1)\$ solution, but I can see some grunt performance improvements out there... assuming that function is better than O(N) performance: 

So, using some math, you can avoid the BigInteger problem entirely, and keep things as and values. I imagine that this will be enough of a performance improvement to avoid the timeout. Note, that for large numbers, BigInteger has \$O(s)\$ type complexity where s is the magnitude of the number, when doing multiplication. The bigger the number, the slower the product. Thus, your complexity for your current solution is \$O(nms)\$ where n is the size of the A array, m is the size of the B and C arrays, and s is the average size of the BigIntegers used. By reducing the problem to int-size values, we reduce the time complexity by a full order to just\$O(nm)\$. There are likely ways for you to be able to solve the math in O(n) time as well.... I just need to think about how to restructure the condition in the loops 

Ouch. Additionally, the method is only called from one place (), and the call-site has only one line of code. Moving this logic in to the call would be fine. Other methods call , but that method is not included with your code. You have the variable. This is a horrible datatype to use because it introduces the need to do the explicit casts in the rest of the code, like: 

Bottom line, is your code only works for limited use-cases. I would much rather your code had a 'sentinel' node, which was never null, and then your actual data follows from that head position. That would reduce your code, and make the insertion process simpler, and also fix both issues above. Note that the 'head' node would be kept as part of the class fields somewhere, not passed in as an argument to the (recursive) method... in fact, the method should not be recursive 

Now, that's a bunch simpler, especially the reduced error handling, and the reduced content in the client. There were a few things to hammer out here. We shifted the printing of messages like and in to the and methods respectively. This reduces the mixed logic of handling a client and also reporting activity in this function, and shifts it to the more logical place where we are actually adding and deleting things. We used defer functions to handle cleanup of resources at the same time/place that the resources were created. We used a scanner instead of a reader. messageChan Let's cover that concurrency issue I mentioned earlier. It comes down to the . The problem is only one client is busy at a time. Let me explain... this code here: 

Your code looks sensible, with two exceptions, the unlock should only notify when the lock is unlocked.... your code currently allows for asymmetrical notifications (excessive notifications). Consider: 

here you have the exact same functionality as you did before.... if the user wants to, they can compile-time type-check their values when they set them (by ensusuring the parameter matches the value When they retrieve the value, they can cast the result to the specified type, or return null if it is not castable. The functionality in is unchanged, but, I recommend you use constants for the keys: 

This removes much of the code duplication. Note also that convention puts the at the end of the line in JavaScript, not at the start of the next line. Also, you should add space between your operators and expressions to make them more readable. Finally, you don't need to add the as it is not useful in the condition since the function returns a boolean already. A concern I have is that you have two arrays, and . You index them both with the same index, and there is no apparent control that ensures they are 'in sync'. Are they a 1-to-1 matching pair of arrays? 

Your four questions are good ones: Correctness - are there any bugs? I can't see any significant bugs. There are lesser potential bugs which relate to unexpected input (for example, null lists, or lists with null members (each of those will throw NullPointerExceptions) Correctness - I used the language correctly? For the most part, it is neat, and well structured. Your names and conventions are good. Yout use of the is uncommon but creative, and useful. The few places where there are problems are technically functional, but, for example, this line here is concerning: 

I would expect UDP to be slightly faster in latency than TCP, but not so that you could measure it by 'feel'. I would expect the differences to be in the order of micro-seconds. Then, when I look at your code, i see that you are creating a new TCP socket for every single character that you send. This is a real problem, and is not the way that TCP is supposed to be used. TCP is a stateful connection, and needs a fair amount of communication to ensure both sides of the socket are are steady and reliable state. This overhead is what is creating your latency each time you connect. With TCP connections it is standard to connect the socket at the beginning of your application, and to then leave it connected the whole time. All you need to do is send a byte each time a key is pressed, rather than re-creating the entire connection. With UDP, it is stateless, and there is no guarantee on delivery. it is also much faster/easier to create connections, because there is no need for negotiation. On the other hand, if the key-stroke does not get through, it won't show up on the screen either, and the user can be the 'resend' mechanism.... if the user types a key, and it does not show up on the screen, the user can type it again. So, UDP may be a useful protocol for you, and you may want to keep it... but... the reason it is so much faster than TCP is because you are using TCP completely against the way it is designed to be used.