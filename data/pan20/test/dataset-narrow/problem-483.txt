It's common in cases like this where the trailing arguments to the function you're defining are also trailing arguments to a function in the definition to omit the arguments entirely. The technical term for this is , I think. Whether you choose to do this yourself is primarily a stylistic choice. 

(By the way, a variant of that I have always felt has the wrong type, , is available from .) Finally, I would be remiss without pointing out that there are several good functions that already exist for doing conversions like this: 

Now, as we all know, building up a linked list by repeatedly appending to the end is a bit inefficient. Probably for such small lists as you'll be using in test cases here it won't matter, but it's a good idea to get in the habit of paying attention to some of the easiest stuff, so let's try to improve this a bit. We have a choice here: either we can keep the interface of this function as-is, that is, always output a list in the right order, or we can choose to change the interface, and change all the call-sites of this function. I think for this case we can keep the interface. The idea we'll take is to build up the list backwards, then reverse it at the very end. The name is traditional for local workers. 

This has a major impact on the performance of your original code, but as you will see we can do better. Problematic Optimization Flattening the 2D array to 1D sounds like a good idea until you factor in the cost of post-processing. When the array is processed as 1D the border pixels change values and, in fact, exhibit border-wrap effects. We often fix problems like this by wrapping the matrix inside a false border - i.e. we add a \$1\times1\$ border all around the matrix. Unfortunately this would not work here. Instead, you can fix this by applying the filter and then going back and zeroing out border pixels each iteration. More Optimizations 

The principle of the dynamic range here is that if we have some palindrome \$a_1 \cdot b_1\$ already and we are trying to find another palindrome \$a_2 \cdot b_2\$ such that \$ a_2 \cdot b_2 \gt a_1 \cdot b_1\$ where \$b_2 < b_1\$ then that implies \$a_2 > a_1\$. You can add a break condition as Dennis does however you will find it doesn't have much affect on this algorithm unless the palindromes are sparse. 

I hope we can agree that B is the simpler approach. In this case the Jokers are simply gaps between characters chosen from the input string. The problem with integrating this logic with your approach is the order in which the recursion is performed. You know when you skip a character (currently when you are adding a ) but you need to know that another character is added after the skip for you to declare the string as non-contiguous. The method is shown below: 

In fact, there's even a function that squashes those two things together. Veteran Haskellers will prefer to spell this function in its infix, polymorphic form as 

Actually, this whole process at the very end is quite roundabout! If you squint, it looks like what we're really trying to implement here is a little function 

If we're feeling fancy, we can choose to use instead of two separate calls to and ; and we can unroll the definition of ; but I think neither of these is terribly important. Nevertheless, they're idiomatic, so: 

The report here says that it passed the test, but that QuickCheck didn't run as many tests as it wanted to because most of the random inputs it generated weren't in the desired range. (In fact, perhaps it's questionable to use QuickCheck at all for this, since there's only ten inputs of interest anyway!) By the way, this function (a partial version! boooo) exists also in : 

As with waaaay back at the beginning, I find the choice of base case a bit odd. Let's try the trick from before of letting the "loop" run one more iteration (and this time hopefully the refactoring isn't wrong!). 

There's a few things I find more satisfying about this: our base-case input is , a common base for s; our base-case output is , a common base for s; and there's no duplicated code in the two branches of the . Finally, I think I'd choose to replace the -- with a pattern match, noting however that this function has a slightly different behavior for negative numbers. Since we were never really doing the right thing for negative numbers, this doesn't bother me too much. 

Bugs in nonContiguous If your input string contains spaces then your function produces arbitrary output regardless of whether you are correct or not. 

Performance Scalability is always what I look for in problems like this. Yes a may not be that big these days but why limit ourselves with inferior algorithms that do not scale well? Consider you have the number $$n = 123456789012345678901234567890...$$ Let's just say this number has \$m\$ digits. You will end up performing \$2m\$ multiplications and \$m-1\$ additions. However, of those multiplications, you can only have \$10\$ unique values since there are only \$10\$ digits. You should therefore pre-compute the powers so that you do not have to recompute them over and over. 

Problem Background Essentially this problem is asking you to remove all palindromes of even length from the string as they are first encountered. So becomes and NOT even though both and are even-length palindromes. Naming Unfortunately, I cannot think of a succinct name for what operation this function actually does. You could go with but that is a bit much. I would just stick with and document the function with some commented examples. Method The good news is that you do have the right solution by using a stack. The bad news is that you are using some unnecessary intermediary data types for processing. Note that you do not need to put the data into an actual stack. Instead you can just use the output string as the stack. By eliminating these intermediary data types and processing steps, the code is much more readable. Here is a char array solution: 

Personally, I often prefer to , and the is complicated enough that I feel like it should be named, so I'd write it as follows. But this is an aesthetic choice that you may or may not agree with. 

Actually, most of the changes we made to can be done here, as well. In the interest of totality, we'll change the type, too; it will return a (which we happen to know will be a singleton list, if anything) instead of a . 

As usual, the tests. Since the old function was pretty partial, we'll arrange to have inputs it knows how to handle, though our new one tries to give an answer even when you feed it garbage. 

There's something a bit funny about this base case to me. It seems like it's not the most basic one you could choose. If we let the "loop" run one more time... 

which we can use to index into our lookup table with the digits of our integer. So let's try to write this directly! Taking a cue from the final implementation of above, we can write 

My only complaint now is the name, for two reasons. The first is that isn't capitalized, which is inconsistent with the naming of the remainder of the file. The other one is more of a philosophical one: our input is an integer, not a base-ten integer. If anything, the base-ten-ness is being imposed on the output. So: 

Ignoring integer wraparound the second condition suffices. The only way \$x \cdot y \cdot z = 2\$ for \$x,y,z \in \mathbb{N} \$ is if one and only one of \$\{x, y, z\}\$ is equal to \$2\$ and the rest are equal to \$1\$. If \$\mid\> a-b \mid = 1\$ and \$\mid\> b-c \mid = 1\$ then either \$c = a\$ or \$c = a\pm 2\$. If \$c = a \pm 2\$ then \$b\$ must be between \$a\$ and \$c\$ since it is equidistant from them both (this is 1D). 

You'll notice that if increases by , these column differences remain the same. The only thing that changes is that we obtain one additional column difference in . Hence you do not need to perform the function multiple times. Simply perform it once on the entire \$m \times n\$ matrix to yield a \$m \times (n-1)\$ matrix of column differences and take submatrices of this difference matrix. So the original code you posted: 

The code runs much slower with these bug fixes. Quick Optimization The algorithm cannot be performed in-place so you are using to store the output of applying your filter to . But then you want the output to be placed back in so you perform a deep copy. However a swap of the pointers would suffice so you could use this instead: 

First things first: you'll definitely want to learn a bit about precedence! Normally I'm in favor of adding some unnecessary parentheses if it helps disambiguate a strange situation or if the operators involved aren't often mixed, but too many of them can get in the way of readability. Also, take advantage of that sweet syntactic sugar for lists that the language provides! So iteration one of this function is 

(If you haven't seen before, I encourage you to try to code it up yourself! Then check the Report and compare answers.) Additionally, we're going to have to change things up a little, since we've changed how works and calls . Before, we had and hence . Now, we have and hence . Since we expect each of the lists in the output of that to be singleton lists, we can smash them all together with : 

Now, we have this branch primarily because still isn't total (it can't handle an empty input list). Instead of protecting ourselves from calling in this case, we should just let deal with empty lists correctly. So: 

Whoa, whoops! Can you figure out which refactoring above was the culprit? =) Now we have to decide whether we like the old behavior better or the new one. I think in this particular case we should like the old behavior better, since the goal is to show a number, and we'd like to show up as rather than as . It's a bit ugly, but we can special-case it. Since we like our future selves, we'll leave ourselves a note about this, too. 

Similarly, instead of performing a on the rows of the submatrices, we can perform a cumulative sum along the rows (or rather row): $$\begin{align}CSMD[i][j] &= \sum_{k=1}^{j} MD[i][k] \\ &= CSMD[i][j-1] + MD[i][j]\end{align}\\$$ Incorporating Matlab's built-in along with changing some intermediary variable names to better illustrate their purpose yields the following code: 

As mentioned in the comments this code is not long winded at all. It is very clean in general. Too clean in fact as you will see below. 

Another approach This is a fairly poor analogy but here it goes anyway. What if I told you to flip through a deck of cards and tell me if there are any Jokers? Which approach do you think is better? 

The next step is to realize that if is our \$m \times (n-1)\$ difference matrix, yields a \$1 \times (n-1)\$ matrix of column means. If we truncate columns of this matrix as we do when we take submatrix it does not affect the means of the columns that are still there. So instead of performing over and over on submatrices, we can again pull it out the loop, perform once on the entire matrix , and take submatrices of this mean matrix. So now the code could look like this: