I know it doesn't really cover the find or some methods, but these functional JS exercises are pretty educational. 

This looks like code that supports browsers like IE9, but your code uses arrow functions and other ecmascript-6 features not supported by those browsers. Since that is the case, includes() can be used to simplify this function slightly: 

Store DOM references in a variable (or constant) The function does a DOM lookup to get the value of the radio buttons on every call. Those DOM references should be stored in a variable (or a constant if the browsers that support are sufficient). I know you mentioned you are considering switching to using select lists so I suggest simply storing references to those by id attribute value in a function when the DOM is ready (e.g. jQuery's .ready()). 

For the sake of efficiency, what you have may be close. As others have pointed out, the selector for the fields to reset the value of could be combined (e.g. the single selector offered in the answer by Roland Illig. Another approach is to use event delegation by adding a click handler to an element containing those inputs - e.g. the document, form, etc. Then check the property of the argument to see if it: 

Use instead of This likely wouldn't be an issue in a small application but in case there was other code (potentially multiple functions) that needed to be executed when the page is loaded, it might be simpler just to use instead of 

See a demonstration of this in this playground example. Another approach would be to have a 2-diminsional array of ranges and group the zip codes based on the range that each fits into. Something like: 

MVC and the variable Considering MVC design patterns, it feels like the view.js file is a controller specifically for the view - A.K.A. a ViewController. Have you worked with any frameworks besides jQuery like Angular, Vue, etc.? I don't see any tags with those framework names in your SO profile so I am guessing not. It seems like the data returned from the XHR might be best stored on the model object. It could store the data locally, store it after successful XHR load and have a function to get that data: 

Feedback The code seems to work okay, though it appears that the counting is off because of the comparison operators used (i.e. ) and the initial value of the indexes (e.g. ). Use Greater than Or equal to (i.e. ) in order to accurately count with the correct number of seconds per minute, minutes per hour, etc. Your code doesn't display the value of but I added it (see code snippet below) and noticed it was going between values of , and . Suggestions Pre-increment instead of post-increment and use immediately after Instead of incrementing each value using the post-increment operator and then using it, use the pre-increment operator. So lines like this: 

What is ? If you look at the example below, you will see I added a property to the and components, and set that to a new item in the data of the root app. 

The names could be modified slightly so they aren't so close. As far as the finish() method goes, the three lines below that actually update data could be moved into a separate method, unless that feels too small. 

Originally I was going to add properties to both the and components and use traditional parent-child communication techniques but it got a little cumbersome with emitting from the nested children. Then I decided to use an Event bus to set the selected id (see Non Parent-Child Communication). One could use from the component and call the method directly but some believe that goes against the traditional parent-child communication flow. Also notice the code below uses the shorthand syntax for v-bind. 

Your question appears nearly identical to this SO question, though in your case you have working code and are passing an object instead of a single value. To follow the guidelines in the documentation, perhaps altering the code as described in the answer by asemahle would be an optimal route. 

Caching DOM references I agree with kingdao's answer: DOM references should be cached, though they should be cached once per page load instead of each time the function runs. So in the example code, and should be declared outside the function, and inside the DOM-ready callback (i.e. ). Also, the names might be a little misleading. For example, the jQuery function (i.e. ) returns a jQuery object referencing DOM elements. Thus an appropriate name might be instead of (though you can use the if you want). Also, cache the currentYear elements in a constant too. 

While I don't think it is bad practice, it could be simplified. One technique to simplify it is using event delegation. For example, the array of tab options could be added to a JavaScript array: 

... and similarly in the other spot where is called. Separate functions I would move the nested functions (i.e. binarySearch and doInsertion) outside of insertNum, unless you like keeping it all tied up together? 

So the code appears to actually add a JavaScript call on the client side, instead of adding a element... Outputting JavaScript with If you are going to add JavaScript to the client side and echo the image path (i.e. ) it would be wise to sanitize that value so it won't break the JavaScript. One technique for that is to use or . 

One could also use the operator instead of Object.hasOwnProperty(). One must ask: do inherited properties count? For simple objects (like the examples and ) it seems to not matter, but for more complex objects it will matter... If can be used, then it may provide better performance. 

Foreword I know that this was posted nearly 1.5 years ago and the code appears to have changed dramatically and perhaps you've already learned about what I will mention below, but I feel like this question needs an answer... Feedback I like the good use of the Notification interface, as well as the radix passed to . Suggestions 

More Comments While the others have offered great feedback and suggestions, I also noticed a couple things with the current code. The derived table syntax suggested by Austin Hastings will (and likely already has) definitely decrease the length of the trigger. If you still needed to use a transaction similar to the code you posted above, perhaps these comments will be helpful. Excess SELECT statements These two statements appear to be useless. Perhaps those were left over from debugging. 

And the same could be true for if the first argument of the function (i.e. ) is renamed accordingly. 

But then again, as has already been mentioned by others, performance can be improved by simply returning the number as soon as it is found, which eliminates the need to create/reuse a variable: 

For #1, we can access the property. For #2, we can create an array - e.g. and if the attribute is in that array: 

The rewritten code definitely feels less cluttered, and it makes sense to remove a block that never gets executed... Since the code already uses , more functional approaches like .reduce() could be used to clean up the code, unless the performance losses would be too much. 

But I am not sure about replicating the debounce effect in ... maybe that could be achieved with a watcher (perhaps making it more complicated). 

Before getting into the code, I would suggest reading this article Stop writing slow Javascript. It has some good techniques for reducing time needed for DOM/page interaction. And while it is over 9 years old, JavaScript Event Delegation is Easier than You Think explains the benefits of event delegation as far as memory goes. resetDatePickers The configuration for the two date pickers is very similar. The date selected handler and the min date on the to date are the only real difference. A date selected handler can be used for both fields, depending on the id attribute of the selected date picker. 

tl;dr The code can be re-written to first count the number of occurrences of each number, then return an array filtering out any number that occurs more than 3 times. 

I would create a mapping, using a 2-dimensional array (or list might work as well). I admit it has been many years since I did much Java so I am a bit rusty but I was able to come up with the code below. First, I made a method to return the mapping: 

I was able to get a faster (in Firefox that is - maybe not in Chrome or Opera) approach using forEach() and findIndex(). Here is the performance comparison tests. 

See this in action in the snippet below: Edit: The code can be simplified by using Object.assign()- each function call to can use that to assign the on the object that gets destructured: 

Make a helper function One way to simplify this is to use a function to abstract removing the class name from the element. For example, create one like : 

Feedback The code looks like it works well and utilizes the API in a good manner. The form markup looks very simplistic. The JavaScript code uses the fetch API in a good way and handles the image arrays appropriately. As far as tips for looping through the results, see the last suggestion below. Suggestions Below are a few tips for cleaning up the Javascript a little. Most of the explanations are based on experience and reading posts like this one. Form submission handler The first part of the JavaScript starts by registering the property to the form. 

Hopefully the response by James is sufficient for your concern about best practices. I did notice some redundancy in that snippet of Javascript. Specifically, the line that handles adding the nonce attribute to the script and style tags could be simplified: 

It is bad practice1 (see also the section under heading Why CSS !important Should Be Used Carefully on this post for a more detailed explanation) so if possible, try to find a selector has higher specificity and remove the . Repeat styles There are a few selectors that have varying styles and some repition: 

Well, in mdfst13's answer, there is mention of the user viewing the Javascript. A non-admin could still see that is a link to Cuenta_us.html and access that page even if the link doesn't appear on the page - thus it would be wise to have server-side validation on such pages. Other feedback The following code is a bit repetitive: 

Then the callbacks that process the data can be abstracted to a function. The function below replaces the loop with the functional approach of . 

Originally, before I added the javascript tag, this question only had the ecmascript-6 tag. I don't see many features of es-6 in your code, like let and const, arrow functions, default parameters, etc. So judging from an ecmascript-6 point-of-view, I would say No. See the rewrite below which utilizes those features. 

Apparently the elements in your list don't have a unique , but the array index can be used, using the alternate syntax: 

If I were you (and I am) I would take the suggestion by J H, i.e. "You're doing a linear scan through an array. You'd be happier if you were doing hashed O(1) time lookups in a set (or map)." and use the end time as the index of the output array (i.e. the hash map). Also, let us build on functional techniques (beyond array_map()) and use array_reduce() to iterate through the timeslots. By using the end time as the index, we can look for that end time in the array and if it exists, then combine it, setting the last start time, moving the combined timeslot to have the index of the new end time and un-setting the timeslot at the previous end time. Then when outputting the times, we don't need to worry about the keys, since we output the start times only. A great advantage of this is the need for referencing via the statement within the lambda function is eliminated since we aren't iterating over the keys anymore. 

Feedback The code looks pretty good. The Javascript code waits until the DOM is ready, then caches references to DOM elements in variables before using those variables in the functions later on. I initially thought some of the CSS could be consolidated (e.g. many common styles under and but then I realized that might be tricky with the SCSS...