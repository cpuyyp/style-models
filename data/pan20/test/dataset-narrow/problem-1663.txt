Following the information I learned in GPIO events in Python I would like to ask the following: 1)If I have a callback attached to one pin and another callback attached to another pin, what happens if both pins get an event? 2) Is there a way to establish some kind of hierarchy between events? Say, this event A gets executed provided there is no "more important" event B being called. 3) is there a way for two or more pins be attached to one callback and pass an argument to distinguish them I would like to experiment with the raspberry pi but unfortunately I won't have one available till friday, so I am trying to learn the theory first thanks 

indicate that gain settings are not settable by the user. and can only be used to read the value. Maybe using the different can help to adjust exposure to different lighting situations. 

Find a good overview as how to autostart scripts or services at the Archlinux Wiki. A convenient way for simple testing is the use of cron. Edit crontab by and use the alias to schedule a task to be started after reboot. Use full paths for you executables though. Another typical way is to utilize the default init framework that allows services to be enabled using the command. 

No, it cannot be done with NOOBS. NOOBS stands for New Out Of Box Software which says everything. Even worse NOOBS now has a special boot option that erases existing data when trying to install something new so don't try NOOBS if you want to keep your existing data. 

The problem turned out to be an apparently troublesome SD card slot. Every time the slot gets too warm the card apparently looses contact and the system stalls. A few months after asking the question I've moved the OS to a hard disk and left only the boot partition on the card. I didn't do this to solve the problem but only to figure out if it was possible to move the OS at all. Since then I've never experienced a problem with this particular board again. 

First thing to do is to verify the "believe" that the system uses LPT to output the data since that not only determines the protocol (which in case of LPT is application dependent) and therefore heavily influences how to interpret the data but also pin out and maximum signal voltage levels. It would be highly advisable to check on those voltage levels before connecting the Pi with a voltage divider meant for a certain level. If searching the web does not yield any useful results on the hardware specifications you'll have to do it the hard way: sniff data and control lines it while it's operating with the current printer. LPT obviously has 8 data lines, 4 output control lines and 5 input control lines; which however - as protocols could be application specific - might not necessarily be used in total. So it is important to figure out what is used when and how. The sniffing could be done using a digital scope or - since you have the Pi - something like the Piscope. People report to have used it with sample rates up to 1 MHz; so lets hope your system is not using EPP/ECP with a bitrate of up to 2 MHz. So if got a scope with at least two digital channels the work is pretty much straight forward (prepare to spend a night or two anyway). Connect one data line and one control line and check what they do. The more channels you can observe at the same time the easier it gets to figure out the big picture. Try to understand how data and control lines work. After that it should be possible to interpret it the data lines as characters and so forth. The most important control line will be /STROBE as it latches the data lines; that is: the source (the mysterious security system) sets the data lines according to the character it wants to transmit and triggers the strobe line to signal the receiver to read the bits now. Depending on the smartness of the source it might be necessary for your Pi to emulate the behaviour of the printer; especially the ACK and /BUSY signals that might be used to signal that the printer is ready to receive new data. (All is getting more complicated at EPP/ECP modes which are bi-directional.) 

Wireless dongles are a common source of problems. They frequently require more power than the USB port can deliver. The USB port of the RPi is sometimes a bit underpowered which especially at boot time causes the dongle to malfunction. Buy a powered USB hub connect it to the RPi and connect the dongle to this hub and you'll see it will work. 

It basically says it is downloading package 203 of the amount of packages it needs to download. It also gives a percentage of progress. When you've started the update is has shown you the number of packages to download (updates or new) and the number of packages to remove (if any). Eventually it will complete the update procedure unless it has lost the internet connection. Do not interrupt the update procedure unless you have no other choice or you may corrupt your OS. 

Serial Port Sample explicetly mentions the Raspberry Pi and the use of its on-board UART as "verified to work": 

I: Photodetector Use an additional photodetector, e.g. a fototransistor, attached to a GPIO pin and detect when there is light. A simple circuit could look like this (source). With Vcc=3.3 V and Vout tied to a GPIO input pin of the Pi. According to the source the resistor would be 100 Ohms, I would think it should be higher (Adafruit is in the range of 1k to 10k Ohms). Major drawback of this circuit is its analogue signal that is feed into the digital input and might be somewhat less repeatable. 

It's possible to achieve this but it requires fiddling with partitions and you need the NOOBS installer from the Raspberry Pi foundation. i know it's not good practice to refer to websites only but it is really too complicated to explain here. Relevant links: a hassle free all in one solution a site on how to create a suitable image for NOOBS 

If you don't set the bit in OTP you can't boot from an external drive. The Raspberry is simply hardwired to search for the boot partition on the SD card. You can move the root partition to the external drive as you've already found out. I believe the reboot loop is a different problem. Did you connect the external drive directly to the Raspberry? If yes then you need to connect it through a powered USB hub. The external drive probably draws too much power during powering up thereby depriving the Raspberry itself of power causing it to reboot. 

1 Usually a series resistor (in the range of 1..10 kOhm) between the GPIO output pin and the base of the transistor (supposedly connected somehow to the "IN" pin) would be the way to go. From the trace on the board it would seem that the middle resistor (1 kOhm) is attached to the "IN" pin serving exactly this purpose. You could easily check this with an Ohmmeter or following the traces on the board. If it does - no need for any external components. 

you get the usual callback called when pin 17 falls or when pin 20 falls The callback function prints which channel was called. My question is, what happens if both pins falls at the same time? Unfortunately I don't have a Pi to try it right now and even if I did, the human error in -say- pressing one pin attached button before another also counts. What happens when it is done at the exact same time? 

I am not so fluent in programming for the Rpi, which I only do in my very few spare time, so I would like some confirmation. If I put this cleansups and puts to input all used GPIOs , right? I ask this very simple question because in the docs of a sensor (ultrasonic) I have there is this code for us to use: 

I'm searching for a solution for what I consider a simple routing problem but I can't get my head around it. It's about 3 pi's. The first one works as an accesspoint (I call it #1), the second one works as mailserver (#2) and the third one works as an sharing server (#3) for drives and so on. Forwarding between interfaces is enabled on all three Pi's. There are also other devices connected to #1 that do not play an important role in this situation. There's also no bridging involved (on #2 and #3) and also currently no firewall. Currently #2 and #3 are connected wirelessly to #1 and all three pi's have connectivity to my network and to the internet. Sometimes #3 has issues with connectivity especially when it is very busy so I want to connect it to #2 with an ethernet cable. This requires #3 to be in a different subnet. I've set in the routing table of #3 that #2 is the default gateway so #3 sends all packets to #2 and receives its packets from #2. #1 has a route describing that #3 can be reached via #2 and #2 has rules that describe that #3 is to be reached over ethernet and #1 over wireless. So now #2 can ping to #1 and its connected devices and it can ping to #3. If I issue an ping -I eth0 on #3 it indeed appears #3 can ping #1. Unfortunately #3 can't reach the internet. It isn't supposed to anyway but this points out there's already a slight problem. Somehow if I disconnect wireless on #3 (so it remains connected by ethernet only) it can't ping #1 anymore and obvious it still can ping #2 while #2 can ping both #1 and #3. In the previous step it was established that #3 could ping #1 over eth0 so I don't understand what is going on. It seems like eth0 is influenced by bringing down the wireless interface. There are literally hundreds of routing examples on the web but nothing seems to work in this situation. Can please someone enlighten me and please don't mark it a duplicate only (which it very well might be). Edit: As requested a diagram and the output of the routing tables involved.