Also, it may be clearer to replace your by a simple to make the 2 different situations more explicit. Useless code The special case for small lists (size equal to 0 or 1 is not required). Flipping pancake The code used to flip pancakes is very complicated and does not really show the kind of operation we perform on your pancake stack. I'd rewrite this: 

The problem you are trying to solve is pretty common and has a O(n) solution on a sorted array (you'll find explanations looking for "array find pair sum" in our favorite search engine). Your case is slightly more complicated because the array is not sorted and sorting it would cause a mess in the indices. Many solutions are possible : either build an array with value and index before sorting it by value and/or keep a copy of the unsorted array so that you can find its initial position back at the end. The resulting solution is likely to be O(n*log(n)) because of the sorting (other operations such as lookup/copy and obviously the proper algorithm are only O(n) and as such considered negligeable). Other details and can be given a starting position (defaulting to ) so that you don't have to add 1 yourself if you want to count from 0. 

Style A few things are unusual in your code regarding style. I suggest reading PEP 8, the style guide for Python code. Among the things I'd change: 

The other case corresponds to a situation I had more troubles to generalise. It can be rewritten as: 

Finally, you can also add more nested iterations. In your case, we could write (but some people would consider that this is going too far): 

Python 2 in 2018 It is probably a bad idea to write new Python 2 code in 2018. You should try to write it in Python 3. 

This fixes another issue you had which is the fact you were building an actual list in memory when you just need a generator to go through the different lists. An easier way to generate successive fibonacci numbers The formula you've used is fairly efficient to generate the n-th fibonacci number without generating all the numbers before. However, in our case, we do need to compute them anyway. Thus, a naive solution would probably be faster. I'd suggest the following generator: 

and you don't need to close the file manually. Using the guard It is usually a good habit to put your code behind a guard to have your code running only if we run your script and not if we import it (because one wants to re-use a function for instance). No need for as strings are iterables too As pointed out in codesparkle's comment, you don't need to build a . Once this is done, you code looks like : 

You could also write this as a single set comprehension. Set comprehension is a convenient way to define set (you also have list comprehension and dict comprehension and even something called generator expression but this is out of scope at the moment). It usually goes like this 

bugged more than it should have. The reason is that you have a similar-looking logic in 2 places which is not exactly the same. Once you get and check if the result is False (or falsy) and the second time you check if the result is None. Both operations have often the same result but not always: None is considered falsy but is not the only falsy value - the most common falsy values are False, 0, "", [], etc. Anyway, in your case, an unset field has the None value so it is probably best to use (or ) in both cases to avoid resetting a value computed and equal to 0. Then, things look a bit more consistent: 

On that final version and working with , my code returns 13259 in 0.2 seconds while your implementation return the same result in more than 3 minutes and 16 seconds which is roughly 1000 times slower. 

I haven't played your game and I haven't understood much of the code but here are a few comments. A few things are not quite pythonic. You can make your code go through some automatic checks with pep8online (PEP8 is the Style Guide for Python Code) and pylint. Among the things that could be applied to your code : 

Finally, is not required as a first argument to . Style Python has a style guide called PEP 8. It is definitly worth a read. You'll find various tools online to check your code's compliancy to PEP 8. From what I can see, the main "issue" is that the function name is and not . Documentation If you wanted to do things properly, it might be interesting to add some documentation to your function. More details (and personal preferences) We have a nice ternary operator in Python. Using it, you could write : 

Then for the only optimisation I can think of, you could avoid some copying : when after the main loop, it corresponds to a situation where the end of is already sorted in the right place. Thus, you don't need to copy it from to and then from to . 

First, congratulations for the work you did : one can easily see that you put some thinking into it and as far as I have tested it, it works. However, I still have a few comments and most of them are about the fact that you might have tried to be too clever. Indeed, the use of both recursion and nested functions is a bit too much for my brain. Among other things, it took me a while to spot that the argument of the is not used (and I am not even sure of it, am I right ?). You could make is easier to grasp by using names conveing more meaning. Here's my attempt to un-nest functions and to change names (I am fully aware that they are not perfect) : 

Loop like a native I suggest you have a look/read at Ned Batchelder's excellent presentation "Loop like a native". In your case, any time you write: 

The right data type Your store unique palindroms in a list. In order to do so, you check if the string is in the list before adding it. You should use a set to make things easier. 

Various details Because I have thrown-away a lot of you code, I didn't get a chance to comment on it much. It is usually a bad idea to use and to loop over something in Python : it is hard to get it right, it is not efficient, it is hard to read and there is a lot more to write. Just look at these examples and tell me which one is simple to read/write : 

Then I do not understand enough what your code is trying to achieve to try to be able to help more. For the time being, the code looks like: 

Interestingly, this now looks a lot like (or depending on the version of Python you are using). We can get rid of it and write : Also, you don't need to use : 

Be consistent in your code style The code style seems a bit inconsistent. For instance, sometimes you have whitespaces before "=", sometimes after, sometimes both, sometimes none... You'll find various coding styles online and different tools to check you code compliancy. Declare variables in smallest possible scope I find it a good habit to define variable in the smallest scope in order to make things easier to track. In your case, could be declared inside the loop. Getting rid of the your -d values All your values (except for ) could be removed because the link between the name and the value is hard to understand at first.:w So far, I've got: 

Please note that I had to reorder members of your struct so that I can simply reuse tests cases from the problem. Now, I assume (which might not be nor true nor wise) that if anything goes wrong during my changes, I'll detect it almost instantly. Better performances At the moment, your code works by implementing the functionality with a straight-forward algorithm considering the different cases. A simple observation can lead to better algorithm. For instance, if we order and in such a way that the left-most end is and the right-most end is then we have a much smaller number of situations. Assuming , we have a bacteria on the left if and only if and a bacteria on the right if and only if (with the 4 combinations possible : right, left, right + left, none). Before trying to perform any optimisation, we should try to be in a situation where performances can be properly measured : at the moment, the times are much too short to be analysed and the datasets might not correspond to situations leading to timeout. Before I go further, the assumption here is that your code is not efficient enough when the number of queries performed on a sample gets huge. (This assumption is based on the fact that the values can be much bigger for the number of cases than the number of bactoeria). We can reproduce such a case by putting the lines doing in loops. This gives measurable times on my configuration :