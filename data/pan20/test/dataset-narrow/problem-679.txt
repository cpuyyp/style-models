Very often a generalization is hard to spot when you are developing code. It is often easier, while developing, to write the everything out in its long form, then seek to generalize as part of a tidying exercise when it is working. The more experience you acquire, the more likely you will become at spotting a generalization early, but even experienced programmers will often write verbose code before boiling it down to something more manageable. 

Presumably statamic statements allow you to include/exclude statements within tags. If so, then you can write something like this in the document's : 

Then consider sacrificing readability for performance by not assigning what the terneries return. Instead write them directly into the expressions where the resultant strings get used, eg : 

OK, with just 15 minutes of 2015 left to go (GMT) and with some shameless cribbing of ideas from @cFreed's and @Sumurai8's answers ... 

It will be at least as reliable to test whether the parent element , as that class will be toggled synchronously in response to a click. You can also benefit, syntactically, from chaining and (or reducing to add/remove a single class). 

Automated tests would be fairly simple to code, though it's hard to envisage something flexible enough to handle any set of input elements. It's maybe more realistic to prepare a few sets of test cases, each comprising input HTML (a container full of elements) and an array representing the expected sort order. It would be a fairly minor challenge to run a sort and compare the resulting order of DOM elements with expectation. 

For every list, Open or create Sequentially load each file in the folder into memory by creating a new instance of and calling 

I am implementing a multi-player game in C# and having seen all sorts of projects, from indie developers all the way to large studios struggle to patch networking into existing products in the past, have made the decision to get the networking aspect done first, and build the game on top of that. I've so far gotten to the stage where my server can accept clients asynchronously, but I have a strong feeling that I've implemented the threading very badly. I think it is possible that I am misunderstanding and/or misusing async/await and Tasks, but having read documentation and similar questions I think I will need practical experience to get my head wrapped around the correct usage of these. As a result, I am hoping that someone would be generous enough to look over my code and help push me onto the right track. I have excluded 'using' statements and the client code for the purposes of this question, however I can confirm the code does function correctly. I am not too concerned about issues such as naming, and the fact that I have a bit too much code logic in the Main function right now -- these will be modified and extracted to more appropriate locations respectively as the project progresses. I have denoted lines I am particularly concerned about with 

2) Always dispose the connection In above code your opening connection and closing it, but this can lead into connection leak in case of errors. Please wrap your code into using statement or try clause like this 

You can minimize you code taking out the filtering out side of loop. Avoid catching exception inside a loop if it needed ,(it seems like it cannot be avoided here) No need to invoke datarow extension method to get value , you can get it directly. Naming of variable is really bad. 

toggleRows should not take a checkbox id but a show variable to show/hide the row by doing so you can call this method from any where. 

Have you considered using views:- -views gives you an explicit way to reduce the complexity of code. so your whole line of code will drop to only few lines. you can replace each subquery with the same view name (or named common table expression as Phrancis metioned) then the optimizer knows it's the same thing and can either cache the result or restructure the execution path so much better than inner query 

I would create two extension method , ToApplicationData and ToAddress and will define mapping over there. it will sorten you code and much better readablity. you can break this methods too if you want. 

As rule has been passed to ArchiveAction class , you dont need to check type inside ArchiveRule class. Move all processing related code to the process method like ZipTempFile ,MoveArchiveToDestinations 

I am quite sure this code is okay, outside of the overhead induced by the run-time typing - my apologies if this makes it a bad fit. I am just hoping for a once-over review by someone more experienced to reassure me that this is a good design. 

I wanted to remove this very strong coupling which my components have (as a result of specifying exactly which component should receive the message), and transition towards an event / message system. As a result, I've written an implementation which seems ideal, however it uses run-time dynamic typing which has me concerned that there may be a better way to achieve my goals. 

That's really bothering me. It just feels wrong and suboptimal and I'm sure I'm not thinking this through properly. Full code below: 

Exhaustive set of event properties which components can subscribe to manually - adds extra code overhead to each message type, which I'd like to avoid Dictionary from event Type to handler in each component - have to subscribe at run-time, which feels undesirable. Switching dynamically inside a non-overloaded handler - more viable than it sounds since most components will not listen to more than a few message types, but still has unpleasant code overhead 

Adding a new message type does not require any modification elsewhere to be supported. Subscribing to an event is as easy as creating a method with the correct event class. There is practically no overhead for listening to a specific event - no need to instantiate a class, inherit some event-specific interface, register interest at run-time with a subscribe method, etc. As messages are represented by classes (like a MoveMessage), they can contain all the relevant data without needing to be cast or coerced. 

The following code is designed to demonstrate the above principles. Its probably not 100% correct; I had to make a number of educated guesses particularly regarding the static DOM hierarchy. If you want to try it, be prepared to do some debugging. 

Untested and includes a few assumptions, therefore may not be 100% correct. Be prepred to debug, or just raid for ideas. 

The expensive part of the opertion is finding the full set of qualifying TDs in the DOM, so you should avoid doing so more than once. 

This is a good thing to do anyway as it puts just one member into the namespace. Then, will return an array of keys, which can be looped through : 

Whenever you have repeated blocks of very similar code, you should always seek to merge them into one generalized block. Sometimes this exercise is hard, sometimes simple, depending on the nature of the algorithms/paradigms embodied in the code. Here, without changing the HTML or the CSS, the javascript will simplify to : 

Due to the volume of code, I would be inclined not to touch it. Recoding and revalidating would be a lengthy exercise. I wonder if the way ahead might be to enhance the (already good) comments, to provide better guidance to the existing architecture. 

Not sure this is 100% correct. Heaps af assumptions were necessary, so will almost undoubtedly need debugging. You may well choose to adopt some of these ideas and not others. 

Originally, I began writing code to loop through my list and my list and then realised I was going to be writing duplicate code for every list of data and switched to having a and looping that and ended up having to use reflection. I was wondering if anyone can think of a way of achieving my goals without using reflection or having duplicate code for every type of model stored. I'll attach my current completed class below. I don't mind doing so much but it's the code: 

I'm working on a game which utilises a variant of the entity component system pattern. In my current code, I have been communicating between components using code of the form: 

However, as mentioned at the beginning of my question, I am concerned about using run-time dynamic typing in this fashion (See my dispatch code in Entity - the second snippet in this post). This system will probably be handling a lot of messages, and I have some concerns about the overhead incurred (it also feels like a code smell in general) I would really appreciate feedback on this approach; particularly whether it seems like an abuse of dynamic to more experienced C# developers than I, but would also appreciate alternative suggestions. Alternative approaches I've considered, and why I did not go with them initially: 

I'm not sure whether my distaste for reflection is justified or not, but it feels ucky that I'm using reflection here. I'm trying to make a very simple class which has a number of where with a load and save method. The load method should: 

... and in general that is what we would write. However sometimes it's advantageous to start a promise chain with a resolved promise, even if it's not strictly necessary. For example, we might want a chain such as ... 

would need to return 1 for to return . Therefore the last question is unlikely ever to be selected. For equi-probability (well as near as possible) use : 

it is an exercise in a form of classical inheritance, by which methods bound to an element are inherited by selected child elements. methods are defined as properties of an object bound to DOM elements with . These methods are intended(?) for private use (within the plugin) but are ultimately accessible by user code. the child elements (spans) will retain a relationship with their original parent after being moved elsewhere within the DOM. the selection of first child spans is hardcoded. 

You should recognize much of your original code but it's been shuffled around - refactored. Refactoring is commonplace. Even very experienced programmers find they need to refactor, and it's is an important part of their skill-set. It's seldom necessary to restart from scratch. 

Timer as a widget Your timer is essentially a widget. As such, it would be more easily invoked by passing in a single container element and having all the internal elements generated on view initialization. Hence, most of the statements would become statements (or their jQuery equivalents). 

so it all depends upon your use case.In this case table will always have columns so passing a array of column will make sense. 

I would write an extension method to do parsing of input string. so it should not be inside your query method. I have declared a class named SearchCriteria to encapsulate all data member you want t o query. 

Please separate out your code into at least two classes 1) Fetching data class 2) UI binding stuff class 4)inline SQL vs Stored Procedure Stored Procedure is good as your code lies at one place in db but creating Stored Procedure for one line of SQL is not a good idea. If your logic is going to be complex and big ,Use a Stored procedure other wise inline sql. PS: I have created a gist named SQLHelper class for you to abstract out the sql connection and command things, $URL$ 

I would write an extension method to check whether the above condition holds true. and I hope eHistoryCurrentMedsGroup is a list of some object so you could use Any(). 

so basically it is your choice : with optional params you cannot enforce user to input the value, so user can leave giving any input and complier will not complain. 

b. create an interface named as IView and implement it in your view , pass the instance of IView to data context of the view