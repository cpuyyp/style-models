There are numerous "basic activities" that are found in games, usually dependent on the genre. For example, "empire management" games like Sim City, Civilization, and Dwarf fortress require the player to macro or micro manage cities and/or people. In these games, the player's goals generally involve keeping his "empire" stable and growing. However, games can be based off just about any kind of activity. There are video games about dancing, exercising, sports, board games, card games, etc. Multiplayer can expand these into cooperative or competitive games. Even the activities you mentioned can be combined into unique activities, or broken down into simpler activities. LostGarden.com has several articles that go very in depth into this subject. Here's one I particularly like. 

My guess would be that you need to store the x position of the character along normal straight ground and use that position to calculate what position of the curved ground that the character lines up with and should be at. 

It would probably be easier to manage the from base approach in terms of balancing the game, but ultimately it is up to you to decide which approach fits your game better. 

As Petr stated, it is difficult for us to provide you with a good wage structure when we know so little about how this needs to suit your game. However, I can provide an example formula that suits this statement: 

On the other hand, the from base approach gives each individual modifier the same effect on the stat. In this case, having five x2 modifiers would only result in the stat being multiplied by 5. Adding another one would increase the total multiplier to 6. This method would probably work better if you don't want multiple stat modifiers to have such a dramatic effect on stats. This method provides a more linear form of growth for stats, like so: 

As mentioned in the comments, you could spawn the enemies with negative y-coordinates. However, if for some reason you can't do that, you can instead have a "game screen" that is bigger than the size of the view screen. Just render the center part of this game screen, and spawn enemies on the non-rendered outer edges of the game screen. 

This method would require some editing if your rotations are not always whole numbers or if the angles are not represented in degrees. 

Thus, to answer your question, there may or may not be non-U.S. laws protecting some famous buildings from being depicted in drawings and pictures without permission. However, even if these laws exist, they might not be applicable if you don't live in the countries with these laws. 

Potential Wage formula: Wages_per_week = (Driving# + Stealth# + Robbery# + Brains# + Toughness#) * Greed# * 20 With this formula, a goon with stats of all 1's would cost $100 a week. However, if he had the max greed of 10 he would cost $1000 a week. This would make Greed act as a sort of multiplier to the total of the other stats. A goon with all 10's would cost $10,000 a week, though would cost only $1,000 a week with a greed of 1. I don't know for sure if this is the kind of formula you're looking for. This formula can be exploited for some beneficial game mechanics. For example, you could have the player visit different locations in the city to buy randomly generated goons. Then, you could have some areas that usually spawn unskilled goons with low greed, with a rare skilled goon popping up there for a cheap price. Conversely, you could have areas that spawn expensive greedy goons that are usually quite skilled. Perhaps you could even have the player spend money to gain access to areas with better goons. If this formula isn't quite what you wanted, I suggest you use a formula that can be best utilized to improve your gameplay mechanics. I hope that helps. 

When the collision first occurs you could save the id/index of the point in the array that is closest to the player. Then while the player is closest to this "center" point, you can just iterate over that point and the center point's neighboring points instead of all the points in the array. If the player moves away from the center point and is closer to one of its neighbor points, you can set that neighbor point as the new center point. If this works without glitching too much, then instead of iterating through each point in the array every frame, you'll instead just have to do a few distance checks every frame. 

How many stat modifiers do you expect to be applied to these stats by the final part of the game? Is there a limit to how high these stats can go? Does the player gain these stat modifiers frequently or rarely? Do you want each new modifier to have a minor or major effect on the stats? Since we don't know anything else about your game, it seems that you should pick whichever approach satisfies your answers to these questions. The stacked approach that you described makes each cumulative modifier have a dramatic effect on an already boosted stat. For example, having five x2 modifiers would multiply a stat by 32. Add just one more x2 modifier, and the stat is multiplied by 64! This might be alright if stat modifiers are very rare, or if there is some sort of limit to how many stat modifiers can be applied to the same stat. However, this will make unboosted stats look completely pathetic in comparison to any kind of boosted stat. Basically this method would make stats grow exponentially, like so: 

If you make a website for the game, you can require people to create an account on your website in order to buy the full version. You can store every account in some sort of database. Then the demo of the game can have a login option (only required for buying the game). When someone is logged in with their account, the option to buy your game can become available if they do not already own the full game. When players buy the game in this manner, you can simply add the "bought game" status to their account and unlock the full game on their computer. Additionally, when a player who has bought the game redownloads the demo on another computer, the full game can immediately be unlocked after they login, since they have a "bought game" account. This is similar to how Minecraft does it. 

You could make it so that after a player gets a specific kind of bomb, he can't unlock the same bomb again until Z seconds have passed. Thus, the player could still utilize the bomb to gain enough score to gain other types of bombs, but wouldn't continuously just keep getting the same one he used. 

Yes, a rules engine can be used for complex AI, at least to some extent. Unfortunately, game AI rules engines are apparently rather rare. Most of my Google searches on the subject turned up results unrelated to games or just questions regarding using it in games (including this question). I only found a few games described as using rules engines. One of them was a real time strategy game called HomeWorld 2. Another real time strategy game that uses a rules engine to a minimal extent is AI War: Fleet Command. The AI for that game is described in greater detail in this series of blog posts by the game's creator. As for whether a rules based engine would be suitable to your game, I suggest you try to implement a relatively simple rules based engine and test it with your game. If it seems like it would work for your game, then you can expand it. Otherwise, you can discard it and try a different approach. 

This kind of procedural generation is considered extensively at this website dedicated to listing game mechanic ideas. There are several entries on that site that go into quite a bit of detail on how procedural content generation can be done effectively. There are nearly 30 entries related to procedural generation. Reading these entries gave me a better understanding of procedural generation and helped me to fully appreciate what it is capable of. This early entry seems the most relevant to your question. It details one method of accomplishing what you're asking. 

It sounds like you should utilize some form of inheritance to to give each type of cell unique behavior, and to allow you to easily add new kinds of cells. For example, you could modify your Cell class to not have a type, but instead have a method called onLanding(Board, Player). The basic Cell class would just add that player to itself using the methods provided by Board. Then you could create other types of cell classes that are derived from Cell and override its onLanding method to move the player to another tile, change the player's name or color, or any other functionality that your Board and Player classes provide in their public interfaces. The Board class would not have to know what each type of cell in its grid is; in its play_turn method, it would just call the cell's onLanding method whenever a player is moved to that cell. Then the cell can do whatever it needs to do to the player. 

Currently, that sounds like that would be most fitting to your Board class. It might be a good idea to move Board's play_turn method to another class, though its not necessary. You could create a new class that handles the game play and game rules, while Board's primary responsibility would be to contain the current state of the game board, such as player positions and cells. The new class could then update an instance of Board to reflect changes in the game state. I admit I'm not any kind of master of OOD, but I hope my suggestions at least give you some ideas. 

I'm not expert at copyright law, but according to this article relating to U.S. copyright laws, it seems to be permissible to commercially use depictions of famous buildings. One copyright law mentioned in this article states: 

For your situation, it would probably be better to avoid modifying your Actor class hierarchy for this problem. Re-factoring your base Actor class to accommodate multiple textures will probably cause a ripple effect that will require you to re-code how your derived Actor classes use textures (which could be a hassle if you have a lot of derived Actor classes). On the other hand, creating a new kind of Actor class in your hierarchy just for multiple textures will make your code less flexible and more difficult to change if you decide to change how your textures are used or displayed. It's better to use inheritance for "is-a" relationships rather than "has-a" relationships. Therefore, I suggest you instead use a hierarchy for your textures. You could create a class that inherits from your class. Then, you could have this class contain two separate images. Any Actor that uses this kind of texture can modify the rotation of one or both of the images through the public methods of . Thus, your NPCs could use this kind of texture and handle the game logic to rotate the "cannon" part of the texture without modifying the "base" part of the texture. Alternatively, if you might be later adding actors made up of more than 2 textures, you can instead make a class for your texture hierarchy. This texture class could contain N images in a list. As a result, any actor using this texture class would be able to have as many textures as it needs. 

It really depends on the game and its art style. Some games use simple pixel art and scale that up to the intended in-game size. Other game makers create sprites for the game's default screen resolution and only scale them up for full screen mode. Generally, it really depends on how much time can be put into creating detailed sprites and/or how important it is for the game to have high quality art. Based on the 2d flash games I've played and seen, sprites are typically created at their intended in-game display size, though this may vary per game platform. 

You can have the attached sprite be an entirely separate entity, and just have this entity be moved beneath the original entity each time this entity updates. If you were using scene2d actors, you could have the bottom sprite just be an actor that continuously executes the MoveToAction with a duration of 0, instantly moving beneath the upper sprite (actor). 

You could put that all in the same class. It's really up to you. Alternatively, you can separate the user interface and the game logic into separate classes. For example, it looks like number 1 on your list is related to the user interface, while numbers 2 through 4 relate to game logic. Thus, you could put #1 into the PlayStateUI class and the rest into a PlayStateManager class. 

However, that article only specifically mentions famous buildings in the U.S. as examples. I can only assume that famous buildings from other countries are also acceptable for U.S. citizens to create depictions of. Unfortunately, after doing a bit of Google searching on the topic of Middle East copyright laws for buildings, the only relevant articles I found were discussing how copyright buildings couldn't be copied in actual construction. To add to the complexity, the age of famous buildings also affects how much copyright protection they have. One of the articles I found stated this in regards to Middle East building copyrights: 

For tools that generate random music for games, this ludum dare post provides a comprehensive list with good options. My personal favorites on that list are autotracker.py and CGMusic. Autotracker produces great music for retro/8-bit style games, though it lacks a proper user interface. CGMusic has a good UI, good customization, and creates complex piano songs. I also know of 2 free music creation tools that allow you to manually create your own songs. Pxtone and musagi both are good for anyone familiar with music theory or experienced with making music. Be aware that since pxtone is a japanese program, it will need to be downloaded from a google-translated website and then set to English mode (which is easy to do).