Goal: "Your implementation of check must be case-insensitive." If limited to , converting to lower or upper makes little difference. When using extended (8-bit) character sets, robust code would use a round-trip as extended alphabets do not always have a 1-to-1 mapping. 

Buffer size bordering on being too small. Consider either right-sizing the buffer and/or use When printing an error message about an invalid string, bracketing the offending string helps highlight strings that may have leading/trailing whitespace or strange characters. Note: better to use for error messages. 

Use standard signatures may be acceptable on your platform, but not others. Better to return . Avoid non-portable code is non-standard. Use For array sizing and indexing, is the Goldilocks type, neither not too narrow nor too wide. As you develop, use that rather than for indexing. is OK for learner code. 

Nomenclature. size is the size need for the array. length is the length of the string (not counting the null character). Suggest . 

Avoid naked magic numbers. Invariably, useful code goes through maintenance and needs to change things like maximum name length. Better to define constants - it self documents them. (Many places in code) 

I'd like to offer a 5th: detect error and exit. Much like #1,2 but instead, handle the error and return. No need for an . 

is not the best type for array index nor size math. is the Goldilocks type, neither too wide, nor too narrow. 

Order of complexity higher than needed With , which execution time varies linearly with , inside a loop which iteration count can depend on , this algorithm is at least \$ O(n^2) \$ and a \$ O(n) \$ is possible. Use separate pointers to read from and write to can accomplish \$ O(n) \$ - still in the forward direction. See below. What if arguments overlap? could exist at the end of , and so must account that may change anytime changes. To inform the compiler this situation is not relevant employ . 

Small detail: Be more generous in buffer size to read an . There really is no need to tightly control buffer input to 12: 10 characters + \n + \0. Consider that from time to time, the file will have unusual data. So either add more error checking and exit code on bad input and/or have a generous buffer. I suggest 2x expected worst case. Additional error checks also suggested What is the widest this could ever print? Is 12 sufficient? Mouse over below for pedantic needs 

Why ? The input stream can be excessively long, and certainly more than 65,535. Suggest a wider type. (Good that code uses an unsigned integer.) 

Further: Use 1 dimension. Knight moves are then , , , ... This further simplifies the "matrix" code. Example: test for end condition --> with being the same as the former . Parity: Every knight moves is from a black square to white or visa-versa. So to go from to , code can ascertain before searching begins if the count shall be odd or even. So each recursion call is calling calling ... This can make for 2 arrays, one black and one white and offers various simplifications. e.g. no need to check for attainment in one of the functions. If code does not use a 2-wide padded edge, then the 8x8 board can become two 32-bit integers (, ) using only a bit to indicate visitation. Pre-compute possible visits: Rather than . Pre-compute the "up-to 8" places for each of the 64-squares that a knight may next jump. E.g. from the corer square, a knight may only jump to 2 locations. This speeds up by not doing worthless -off board jumps and allows for an 8x8 model hinted in the preceding paragraph. 

For code to function correctly, it assumes the endian of integers and FP is the same. Certainly common, but not specified and exceptions exists. 

Pedantic: Careful with computing sizes. Both and are constants. As array sizes are best characterized with type , on coding using much larger values, * may overflow math, but not math. Not an issue will this small program, but as a guide for large task, insure math is done with math 

Formatting: Excessive vertical spacing. Many places in code. Certainly a style issues, but this, IMO, beyond a useful amount. 

has little value. Simple make the the size zero on initialization. The first time more memory is needed, then begin. Consider if code used many sparsely populated then that could tie up lots of unused memory. Rather see a much smaller initial size. fails to update the other fields. 

Allocation woes. needs enough memory for a null character terminated string. This implies a +1 to the addition. The cast of is not needed. Multiplying by the size of a pointer is wrong. It should be by the size of an element of , which is a . should be rather than , but that make s little difference with small strings. 

I submit that there is a good chance that although the loop needs to iterate twice as often, the overall time will be less that the original code. Profiling will help determine that. Further, for multiplying this will certainly be fastest to use half-sized than OP's unposted multiply routine. 

Adding common name to global space. These will certainly collide on a large project. Assume your good code will be re-used on larger applications. Suggest putting all the following in a variable, maybe called . 

Code does not consume the remainder of the line, should it have more than characters in it. Failure to consume the rest of the line causes the next iteration of the loop to pick-up on the old line resulting in erroneousness reports. Entering a line of characters will demonstrate the problem. Staying with (assumed requirement else consider ) does pose limitations, like trouble detecting null characters, yet aside from that: 

Well laid out consistently, but a bit tight. Good basic error handling. Good uses of in allocation calculations. Good used of with such function declarations. Compiled well without warnings. 

If the pointers never overlap, let the compiler know that and allow it additional optimizations using . 

Note that expects and so follow that signature. Adjust and functions accordingly. Casting a to may lose information. If conversion to an integer type is truly needed, consider the optional type or better yet . 

1) The reasons for 2 loops and is to optimize division by 2 and allow the next prime candidate to be found with . As printing is a sink-hole of time, these small savings could be ignored and code changed to one loop. 

Is there specifically any way I could improve the argument/input parsing blocks? See #3 far below Would it be more consistent to ask the user for minutes if they supply an hours command line argument? Could go either way on that. #3 far below does that. Should I offer the variety of options at all, or should I stick to command line arguments only or "dynamic" input only? 

Allow an initialization value: Or better, functions on as if it had less than elements are in it until elements are added. 

Avoidable integer overflow. When the text version for is passed, what happens? Both and are experiencing overflow, which is undefined behavior. This means, even if you get the hoped for result today, you may not get it tomorrow or on another complier/platform. Best to avoid. One method is to accumulate amongst the negative side as there is the same or usually more negative numbers than positive one. (think +2147483647 vs. -2147483648). 

Consider that good code should qualify buffer size with a parameter. Something like . As this is a learning exercise - set that aside for later growth. 

Questionable code when is unsigned. Suggest . Else will the wrong value even is one assumes ASCII-only in the string. 

is weak code. FP can easily have less precision that and itself need not return integer values exactly as expected. Better to use an integer . Sample follows 

IMO, initializing the complete structure promptly after memory allocation is a good thing. (Also with ) 

Nice to have example usage in .h file. Suggest bracketing instead as it does not stop syntax highlighting. Pedantic: is the type to use for array indexing rather than . Code accordingly, remember that is some unsigned type. Namespace abuses namespace with , , . Suggest a more uniform prefix. is not too bad, but then use . Avoid magic number - why 30? Numbers other than -1,0,1,2 and maybe 42 deserve a macro or object. 

Weakness: unnecessary loss of accuracy. The above simply throws away the least significant bit of . To improve accuracy, this division would benefit with a "round to nearest even". About 1/2 the time when a bit is shifted out, the quotient is incremented. Example code to demo improvement. 

Do not understand why the coding goal does not allow "123", "123.", ".123". will accept leading white-space. Indicating the address of the fail location sounds like a useful enhancement. E. g. return on failure, on success. 

In a couple places, use to allow wider application of the functions that are not changing the referenced data. 

I have my doubts that any method is significantly faster than another given the sink-hole of time that is, but here is another approach 

Inconsistent indentation. An without is tolerable, yet not preferred, yet then code breaks a line that would look fine as one. Suggest re-formating. 

Architecture: IMO, the time for trusting that buffers will not overflow is past. Pass in a and check for valid sizes in function calls. serves little value and its application can cause UB on unruly input. Rather than use it convert to digit character, just add , offset as needed. --> Global functions that being with are reserve for the implementation. Use a different name. 

certainly needs a number like Nice use of in Use of in error handle is a reasonable exception to the never use . Useful when multiple error points. In the end, rather have code do complete error checking with than elegant without error checking and without . 

Just integer addition and compare are needed I would incrementally calculate and , increment the smaller of the two. Of course, when they are equal - voila! 

Allocation responsibility This code obliges the calling code to provide the space needed. This fine. Yet I find it more useful for the functions to handle that. OP's choice on this, just wanted to provide an alternative POV. Added functionality A means to report the without adding a new number would be useful. Parameter order I'd expect the state data first. 

All uppercase tokens like , from a style point-of-view, are typically reserved for macro constants. Still this is valid code. I would recommend something instead. 

Inconsistent indentation implies OP is not using an auto-formatter to maintain a consistent style. Life is too short for manually maintaining the format. Use a programing environment that has an auto formatter and use it. 

Clerical: Since the design document is "K&R C, Exercise 1-20.", that information should have been in code. Name and date is nice. It is your work, proudly sign it, 

Detail on "this runs in O(n)". Code first initializes with . This takes a fixed amount of time. From an efficiency stand point, the initialization can dominate run time when the string length is small. If the target use of this algorithm was applied to many small strings, a different approach should be considered. Code could vector on the initial portion of the string. If was at least of length (maybe 4 to 8), then proceed with your current approach. With small a short string, simple compare each character of against each character of . If this extra code is worth it or not depends on various things. The point being that a simple pre-analysis of the arguments and could be used to steer which algorithm is used. The major downs-side is more code to develop, rate and maintain. 

Wider, but not arbitrarily wider math needed To reach , 80 bit math is needed. Suggest using a complier that supports or equivalent. 

Stress test The queue approach is non-deterministic and would benefit in knowing how much extra CPU is left. Presently the processor is ample and the cumulative task list is low. There is spare CPU power. Yet let us stress test this design to find out how close and how code handles falling behind. Add code to detect when is starving. Did every task get serviced at least once every 0.1s say? Append a do-nothing task that consumes a x% of CPU time, call it Administratium. Did the queue ever fail to add because it was full? What was the maximum queue usage? Was task latency too great? Armed with this adjustable idle task, preliminary testing can gauge the degree of margin in the design. 

Avoid magic numbers. The is is certainly derived from the 512 in Use a macro to define both or derive it. 

I ran test cases and found OP's functionally correct for finite float over a 2,000,000,000 test cases. As a test case, I tried OP's original versus the below and was at least 10% faster with the new code. Of course, that is just one platform comparison, yet aside from NaN issues, the below code is functionally similar to OP's and as a plus, is highly portable - unlike OP's. The point being that OP's compare method needs some reference point to justify the bit magic. 

Later. Information hiding Code does not detail what might be the part and implementation part. To this end: 

Why cast allocations sometimes and not others? Suggest dropping the casts. Is using a global ? Tsk - tsk! 

Rarely are micro optimizations worth the effort, yet this may be one of those exceptions. Functions like or may be used a lot and so warrant "tricks" (AKA micro-optimizations) not meant for normal code as they are higher maintenance yet may provide meaningful improved performance in select cases. Use with caution. One is to take advantage that the usually 256 different values are mapped to a smaller than 256 set. So by using two functions: perhaps 256 byte look-up tables that differ only in , then the compare for a null character is not needed, simplifying the crucial inner loop. Further, I found many compilers perform pre-increment faster than post increment. 

Minor: Unclear why code is using for array indexing rather than the idiomatic . Later code quietly returns this as an . I'd expect more care changing sign-ness. Else just use . 

No need to perform type shortening - no space not code savings expected. Use the type of the functions return/use, in this case. This avoids automated warnings about shortening/sign-ness change. Recommend to use the sizeof of the de-referenced variable rather than the size of the type. Easier to code, review and maintain. 

General: Do not use for values. Either use and functions like or use . When is close to , OP's approach suffers severe loss of precision due to the or . More numerically stable code posted. Still needs some divide by 0.0 checks. 

Use of is OK here as the loop should always execute at least once. Some style guides eschew . As will such styles issues, follow your group's coding rules. 

Design idea: In C, many of the basic string functions assume the destination array is big enough. As the standard library functions are crafted for performance, checking size allocation is left as a responsibility to the caller. could be re-designed to do that test. Instead of leaving the size test to the caller, consider that is not a basic building block and it could check for sufficient memory. As with such things, error handling is an important, but for now, TBD consideration. 

Better to use . This also prevents buffer overrun. Avoid naked magic numbers Why 30, 256? Use constants to allow for graceful code updates and self documentation. Be more tolerant of long names. e.g. and their construction should they contain unexpected characters like , etc. See also Falsehoods Programmers Believe About Names 

Since function allocates data, make that clear in the function declaration. Also document candidate error returns 

Avoid end-of-line assumption assumes the lines ended with . It could have ended with just one of those. Robust code would consider that. Testing NULL-ness In , code does a . I recommend doing the same with , add . It allows more tolerant usage and follows the acceptability of . Use the size of the de-referenced variable Rather than use the size of some structure, use the size of the de-referenced pointer. Easier to code right, review and maintain. 

1 Rather than types , functions and file names , use a common prefix. 2 Instead of allocating to the size of a type, allocate to the size of the referenced pointer. . It is easier to code correctly, review and maintain. 

In terms of wiping out data, files are very commonly saved in blocks (of some unit like 256, 512, 1024, etc.). Stray data from previously files versions often lie in the remnant of the last block. Consider zeroing out past the original file length to a multiple of blocks. Code can later truncate back to the original length if desired. 

Unclear why some apparently debug code remains and others are commented out. Expect greater consistency. 

I found the vertical spacing excessive, yet with such style issues, follow your group's coding standard. Use instead of or use @user3629249 to clearly indicate their intended non-used. As in does not alter the referenced data, use . This adds clarity and breadth to code's functionality and can allow certain optimizations a compiler may not see. 

in serve no purpose. Code can be simplified to and retain the same functionality. Code that does not exceed the presentation width is more clear and easier to re-view. (Code should not need horizontal scroll bars.) I'd expect for pointer to data that is not modified by the code. better conveys code's intent and allows for select optimizations.