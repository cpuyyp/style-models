Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

As this is a learning experience, you should be concentrating on learning the language and its quirks. Java <> PHP, in quite a few ways. You shouldn't limit yourself in copying the Java interface, it's a good interface to clone but now that you've done that you should explore enhancing it with native PHP functionality. You should take as much advantage of native stuff as possible, the performance difference is noticeable. I have to admit that the ArrayObject was an off hand example, my primary intention was to point you towards the SPL. I did base something similar on an ArrayObject, but the requirements weren't exactly the same. Still bits and pieces of your code could be rewritten to take advantage of native functionality. For example, this: 

For fun, I made a function queue in JavaScript. I named it tinyq. You can add functions to it, and each function is passed the next function in the queue. You can also pass parameters to the functions, and they can return values. 

So, what do you think of my function queue? Any improvements, or anything I'm doing wrong? P.S. I was also trying to make this small, any suggestions on making it smaller? 

Apparently is a and is an . In order to parse this as a date, I need to convert it to an int. These bytes represent the timestamp (or ). I have code to convert this byte array into an int, but there has got be a better way to do it than the way I came up with. 

This is my first foray into the wild world of jQuery plugin development. The plugin "ajaxifies" forms, which isn't particularly spectacular: 

Points 1 to 3 are user interface specific concerns. In an MVC approach they belong to the View and not in the Controller. Point 3 can be a user interface concern, if the texts are static, but can also be viewed as a data concern. The same way you get data from the database, you could collect all these static texts in a configuration file and only have to look at one file to change them across every View in your application. That could be considered a Model approach. Having said that, this: 

is the "Date" header, is the data length (4 bytes) and the 4 following bytes represent the date (timestamp). I have code to read those 4 bytes and return it to me as a : 

For my application, I was using , when I noticed it was returning the wrong value. I was using multidimensional arrays, therefore I needed a method. I Googled around and found a few, but they all only took 2 parameters. The official can take an infinite number of params. I wanted mine to, so I wrote my own function. 

This is obviously incomplete. The outer check is simple enough, it's whether is empty or not. If it's empty, nothing happens, if it's not, the inner check is on whether has a index, and if it's value is . If that's true, something happens, but who knows what? I'm assuming one of the things that would happen would be to set a proper value to . Anyways, if the check is false: 

This way a function to get cabin information is available to all your controllers, you don't have to rewrite it every time you need it. Don't repeat yourself. If there's any HTML / CSS or any other presentation logic in your Controller, and of course any persistent data logic, you are doing it wrong (in MVC terms). But MVC for small sites may be an overkill. It's a correct approach conceptually, but you will have to decide for yourself if it's the right one for your application. But if you decide it is, you should follow it as is. A very easy approach to separate presentation from logic would be to use a template engine. There are quite a few of them out there, and there isn't one that's better than the others. Using one is more important than which one. And of course it wouldn't hurt if you didn't try to reinvent the wheel and started using an MVC framework. Or if that feels too much, a micro framework. There's is an often quoted article by Rasmus Lerdorf that some people perceive as advocating against template engines and frameworks. It's not, the only point of the article is that you don't have to use them. In the article there's a very nice and tidy approach on how to get an MVC kind of structure out of the box, without the added complexity of any third library. If you really don't want to use any third library, you should copy Rasmus' style. 

That is, I am converting every byte to a string (like ), joining them together, removing the , then reading that string as a base 16 value. This works, but it seems a little too convoluted. I then realized that I could replace the / with , so now my code is: 

This is just an extension to @palacsint's answer. You shouldn't pass strings to , it uses , which is inefficient and insecure. You should pass a function. Problem is, in the loop changes, so you'll have to use a closure. Don't do this: 

that would make it easier to clean up the series of lines. Python is a great language for this sort of thing - it should be easy to cut this down by half or more with built in tools. 

HTML is a finicky format. It's easy to screw up an escape or lose a bracket and mess up the output. With separate files it's trivial to preview them and verify them independent of possible code bugs. Since HMTL is so finicky, keeping it inline with code also means you'll have to worry about an extra quote character somewhere causing code parsing errors. It's easier to iterate on tweaky stuff like changes to CSS using an HTML specific editing tool than by messing with tags in a Python IDE or a plain text editor 

Like I said, this code works, but I just feel there's a better way to do this than to convert the bytearray into a string and then parse that string back as a base-16 int. 

I am working on a program to decode MMS PDU files. They are binary files and I am reading them byte by byte and decoding each header value as I come to it. One header value is the Date, and it's represented as follows (in hex): 

I don't actually know much about how base32 (or base64) works, but I noticed that there was no official base32 implementation in PHP, so I figured I'd make one. I Googled around a bit to figure out how it works, and found this page. Using the examples at the bottom, I hacked up this base32 class. GitHub project: $URL$ 

From a style perspective I like the first option; if you're treating this as a property its clear what you intend For implementation, I'd try a class level default with an instance override to provide the right words to allow for specialization or extension (for other languages than English, say, or use at Oberlin College). Whatever your gender politics this implementation is extensible to new cases and one offs. 

Plus you can use safe_substitute to allow more error-tolerant display so you don't bork your server. 

The main idea here is to use the dictionary CircleSet as a sparse grid: it will only have keys where a point falls into a circle. I'm using a separate set() object to track intersections so that the 'overlaps' function does not have to look at every value and see if there are multiple entries, but you could ditch that and do 

I thought of a neat solution to this. Not sure how efficient it is, but I thought it was neat. If you look at your result array, you'll see results from "0000" to "2222". These are the numbers from 0 to 80. In base 3! So, using that, I whipped up a function to create all numbers in that range as an array. 

This code works, I've tested it using this page, and it gives the same result, but I don't think this is the best way of doing base32. Is there a better way to do base32 that's maybe more efficient than what I have?