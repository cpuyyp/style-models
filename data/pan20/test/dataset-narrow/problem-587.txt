There's a lot of code in your while the isn't actually necessary. If the gets triggered the program will terminate anyway, so all following code is an implicit . Note that you ask a question while not checking for a answer. You're also not checking for , and more of such variations which one may expect to be valid. One way to solve this is by repeatedly asking the user for an answer until you get one you're willing to handle. One way of doing this would be: 

By the way, that construct looks like it can be written in more straightforward manner but my C is too rusty to make the translation. 

This isn't your bottleneck (not by a long shot), but that second reeks of bad time complexity for something simple as telling the user where the images are. One of the major time-consumers appears to be the downloading itself. I ran against your code to find the bottleneck(s): 

Blanket imports Do you know what you're importing when you use ? The entire turtle. You don't need the entire turtle. This is what you need: 

and out of the after handling the first successful hit, but since I'm not sure I'll ever do that the current, simple version will suffice. All PDFs should be in the following format: 

There's 2 possibilities: 2 spaces or 4 spaces per level of indentation. But whatever you do, be consistent. That's the most important of all. As a side note: your tags were oddly matched at times. I fixed your inconsistencies in the code below, I'll leave fixing your CSS as an exercise. In your CSS, the same rule applies: be consistent. With your whitespace, with your indentation, etc. HTML 

Extract the to it's own variable. This allows you to extend your program to, for example, ask for user input and use that value instead. Perhaps the user prefers or . 

Honestly? It looks pretty straightforward. Everything in your code screams you've done this before. Good! You're adhering to the standards of Python (the PEPs). The imports are at the exactly right places. The code is readable, easy to understand and does things the easiest way possible. In other words: it's Pythonic. You could consider wrapping your statements in into a template so you'll only need one call. However, since you only print once, I'm not sure how useful this would be in the end. While your code is easy to understand, you might want to make the naming even better. You got 5 variables with the term in it, not even counting where you use some of the exact names again. You're also overwriting after the after using it as a temporary variable. That's probably not the most maintainable way. Single-character variable names should be avoided, even if they appear to be obvious. 

The second in ends the function, so we don't need the operator. Instead, we could use to replace the data in the variant while keeping the the same, and then just return the result of . 

Don't put a space between an identifier and the colon that precedes a type ( rather than ). Put the and the on the same line. 

Note that the function plays a very important role that would be lost if it was inlined (by hand): the lifetime of the returned byte slice is tied to the lifetime of the input parameter. It's as if it was written thus: 

On the first match, when is a , will contain a reference to the . When we get to the loop, is now a reference too. Generally, when we iterate on a reference to a collection, the iterator emits references too. Indeed, is now a reference to a . Here, I wrote to match the dereferenced value (note that this doesn't necessarily copy or clone the whole ) because we bind values, which are cheap to copy, so we bind them by value, not by reference. Finally, let's simplify these nested matches. Let's look at first: 

Here, I'm using to convert the to an , because I'm too lazy to define an error type that unifies the parse error and our new out-of-range condition. Then I'm using to perform the range validation only if the parse succeeded. The closure returns if the value is in range, or if the value is out of range. Instead of using , we could also use the method provided by the crate. It takes a closure that returns a , and returns if the closures returned , or the original value otherwise. 

The parameter doesn't have to be a , it could be a slice instead (). However, if you had used a non- item type ( is ), then in order to return individual items from the input , you'd either have to the items or move them out of the (using ). You've implemented binary search by hand, but the Rust standard library provides a very flexible implementation via . 

Instead of using the crate, I recommend you use the crate. It's not as low-level as and it has more features. For example, with , we don't need to add a magic value in . 

Halt. Stop right there. This assumes the script is located at some specific location. happens to be always in the same place, but this assumes the script to be in a place relative to . On what OS do you intent to run this? If it's Linux-only, you could replace it by: 

= some value minus one. The actual value we need is plus one. Since the description of the challenge says and are given (not and ), it doesn't make sense to modify them. Let's go from to instead. 

Exactly. Way longer than necessary. Now imagine you share this code. Like you did here. How long does it take someone not familiar with your program to figure it out? Way longer than necessary. For the sake of your future self, improve the readability of the code by splitting things up. 

Now it will work regardless of where the script is located. Of-course, you just made the problem worse for non-Linux systems. Even better would be to ask where the user wants to drop his files, possibly by using arguments (take a look at ). But why don't you simply drop it instead? A map named will simply be created in the current directory. This would be obvious and expected behaviour. 

When you run out of money, the game will halt. Not really a problem, but somewhat unexpected. After all, you keep asking me after every round whether I want to quit. Why not asking me at the end of each game whether I want a new one? On top of that, consider leaving a trailing space or newline behind a question, so the answer isn't typed directly next to the question. Makes it all just a little neater. I know most people have a nice big monitor nowadays, but it's recommended to stay below 80 characters wide when writing Python. Better to use a couple of lines more than to have a line of 200 characters wide. Scrolling up and down is easy, scrolling sideways is more tedious. While I mentioned being consistent in your code, being consistent in what you show the user is perhaps just as important. Use proper capitalisation and spelling whenever possible. Oh, and is your doing what you think it's doing? 

Yes, there will only ever be 7 in a classic Tangram. Yes, it still looks hideous. A piece is called a by the way, so you could use that in your variable naming. is a construct I expected to see in your solver. 

For this code to be usable, it has to be completely 100% thread safe. Can anyone see a hole in it? Also, am I just re-implementing something that already exists in some corner of the .NET base class library? For the sake of context I'll provide a practical use: there's a long running application, and some code that must execute if a file exists. The file might exist when the code first runs, or might come to exist later, or might never exist at all. I invoke it like this: 

But we can do better than this. The above code has two loops: one which calculates the factor counts and one which searches for the contiguous fours. Lets merge this into one loop: that way it will stop generating factor counts as soon as it finds the fours. 

And so on. When you're done, every number will either be 0 (if the index is prime), or it will be the count of prime factors of that index. Now it's as simple as finding the first four contiguous fours. This solution takes around 130 milliseconds: 

If you're working through the Project Euler questions, you should become familiar with the Seive of Eratoshenes. Not only is it a very simple way to generate a bunch of prime numbers at once, but it's an algorithm which can be subtly modified to solve other problems. In this problem, we want to calculate how many prime factors each number in a range has. We've going to be testing a lot of numbers, so it would be great if we can calculate all of the factor counts at once. And we can! First, pick a safe top number that we're going to test up to. I'll guess that the answer will be a number less than a million. Create an array of a million zeros. It starts as an array of zeros, but we want to transform this array so that: 

You also ask another question - why use an event rather than a multicast delegate? You can think of an event as a multicast delegate, but with restrictions. 

I like the pattern of the jQuery Deferred object. I like how you can call any number of times, but the listening objects will only be notified once. I also like how you can attach a listening object after has already been called, and the listening object will still get the notification. If you're programming in an uncertain multithreaded environment, it greatly reduces the amount of thinking you have to do. I couldn't find an equivalent in the C# library, so here is my implementation (a basic subset so far): 

Instead of having a mutable variable, I'd factor out the code that decides if a number is prime in a separate function. We can use early returns to avoid defining a mutable variable. 

If you were to take by mutable reference, rather than by value, then the original variable would indeed need to be declared as mutable. You could not invoke the function with only an immutable reference, because closures can't be invoked from an immutable borrow. If that's a problem, switch to instead. 

should be a boolean instead of an integer. Rust has a built-in boolean type, , and the keywords and , which you can use instead of and . 

You don't need to do that, since returns a , and is the maximum value. A condition such as would always be false. 

Additionally, considering the way you've written the prompt messages, it looks like there shouldn't be a newline after the prompt, so I suggest you change the that prints the prompt to a . Here's the revised code: 

If you want to combine the result of with the range checking in a single operation, that's possible too. First, let's look at the "lazy" way, where both error situations will produce the same error message: 

You don't need to define the variable as mutable if you move it inside the loop and take advantage of the fact that and are expressions. 

You can use instead of . This requires adding calls where the compiler did a copy when the bound was present. 

In general, using for the error type is not a good idea, because taking a decision based on the contents of a string is not very robust. It's preferable to define a struct or a enum that implements the trait. The trait also makes it easy to compose errors in a complex program. Normally, iterator adapters take ownership of the original iterator. This is true of the iterators in the standard library; for example, takes by value, and the struct doesn't have any lifetime parameters. The reason is that an iterator adapter often consumes the original iterator to perform its own iteration (assuming it is driven to completion). On the other hand, yours takes the original iterator by reference. This is less flexible, because it means that I can't write a function that returns a unless I received an iterator of bytes as a parameter (I can't return a that refers to a local byte iterator, because the byte iterator would be dropped when the function returns.) There are cases where it's useful to use an iterator adapter without giving away ownership of the original iterator. For these occasions, we can use to give a reference to an iterator to an iterator adapter. Mutable references to iterators are iterators themselves, thanks to a blanket implementation in the standard library (). In your iterator's method, the in the loop in superfluous. I only write when necessary; when I see a , I expect to find some code after it, and when there isn't any code, it makes me wonder whether I missed something. In your iterator's method, you use to refer to the encoded string and to refer to the decoded string. and are similar terms that don't carry any meaning. It might be clearer to name them and , respectively.