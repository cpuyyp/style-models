There are multiple ways to make Dates in javascript. The format above will create a new Date based on "today"'s year, month, and date (think day of the month). Technically you could also do this with a DateString, however "new Date(dateString)" is implementation dependent, and may have inconsistent behavior across different browsers. And if making 2 Date objects makes you uncomfortable, you could always do the following: 

(Note I strongly recommend using over , you'll run into less problems in the future this way. Event Binding You should try to get into the habit of using instead of `$({selector}).click(function(){}). applies an event handler for every instance of , whereas the will apply a delegate event handler to , and listen for any within . The difference is making 1 event handler compared to making many. Right here, there shouldn't be too much of a difference. We are assuming that there is only 1 . But, as you can imagine, using can give huge performance benefits over directly. But, most importantly, by using , you are binding the click event to . Should you remove and re-add a new in its place, the click event will be lost. This is not the case with applying the to a parent element. 

Caching Variables and selectors Whenever selecting an element on the page, if you are going to select it multiple times, try to set the jQuery element as a variable first, and reuse the same variable. 

Overall approach Hiding and showing menus has been done a lot, and to be honest, you are applying a lot of javascript for something that can be done mostly with css. I'm not aware of your DOM, however you can move the toggle menu behavior (and even the animation) to your CSS and just have a simple click event handler that fires a toggleClass event. Example: 

If it isn't, then your DOM should be corrected. == and Type Coercion As a general rule of thumb, you should always opt for over (and conversely opt for over ). basically means does a sort of equal b. It doesn't take into account the variable's type. passes as true (even though one is clearly a string, and the other clearly a number). means does a and b match the same type, and does the value equal each other. In this case, will return false (because of the difference in type.) I know this might sound small and nit-picky, but in reality it really isn't. Using will lead up to unexpected behavior that can be hard to spot. Additionally, is faster than . will stop trying to compare two variables if they do not have a matching type. Simplify Conditional I want to highlight the following conditional: 

Caching variables is more performant and can be much easier to read. You shouldn't have to find by id IDs are meant to only exist once on the page. By calling , you are effectively saying "Starting from my current element, lets search down the DOM tree until I find something that matches my {selector}" 

These things together will make your code easier to follow, more maintainable, and often both faster and shorter. So, start by looking at your core data structure: 

So now we need to tell Python what "local" means. Unfortunately, I can't come up with any definition that matches all of your test cases. But hopefully, if I show you a couple of things you can do that don't quite match your code, you can glean enough to fill in the blanks. The first thing I thought of was a strict rolling window - "every three adjacent items" (except dealing with the two edge cases): 

You have an awful lot of excess whitespace. Use one or two blank lines between functions, and one blank line to break up different parts of each function (especially, just below the end of a loop or block). Don't put blank lines immediately between a line ending in and the start of the indented block beneath it. The while loop in uses a class attribute as a loop counter, which actually seems to cause a potential bug here: the counter persists, so on subsequent calls you will skip the loop, never append to the outer list, and it will be returned empty. If is a local variable instead, and it will work fine no matter how many calls you make. Instead of keeping a loop counter like this, and incrementing it manually, preferred Python style is to use a loop. The equivalent for loop to your current while loop would be: 

These three classes differ only by one hard-coded string argument. I'm assuming these are going to be expanded a bit later, but even so - consider consolidating them. 

This is a list of lists of strings. For most of the rows, you don't seem to care about column 0 at all. Column 1 contains row labels, and corresponding to keys in your dictionary . The rest of it is numeric data, currently stored as strings. It also contains 'header' rows - you only keep one of those around, so presumably you only expect one to be in there. I'm guessing that is column labels, which a DataFrame lets you include directly in the same data structure. The only trick parsing this into a DataFrame is that it is a little easier (and, apparently, more efficient) to swap the columns and rows from how you have them currently. That will affect how it prints, and which methods you call to relabel things, but not much else. This is how I would parse it into a DataFrame: 

You can check that this list comprehension will give you all the True/False results of that in that loop: 

Going down, is a .. very strange name for a list. It seems to contain solutions, although you put two numbers in it each success, which seems odd; but I'll assume that that makes sense, and say call it . You don't need the number at all - the way you use it, it will always just be . The two statements could be combined, as in: