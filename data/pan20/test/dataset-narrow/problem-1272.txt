You can add some randomness to your grid by putting extra space between contiguous cells: Let say you want L to be your minimal distance, then you can put your grid cells apart by L+2*e; When you choose a cell, you can set the position of the planet to the center of the cell adding some random noise (at most e). In the worst case of two consecutige cells chosen and maximum random displace applied one toward the other, you will get L as distance. 

so if random is this means that you will get 1 and 5 with 10%, 2 with 20%, 3 and 4 with 30%. This method can be stressed further as @zacharmarz correctly pointed out. Whichever size you use for your uniform generation, you will arrive to run out resolution so you know that will be points in the curve that you will never reach. Let say that MAXRAND is 1000, you can't newer get results of the curve beween 123 and 124 for example. You can go further by doing another generation so you can subdivide the curve between 123 and 124 in 1000 pieces here an example with MAXRAND = 6 (!!) 

I'd rather do the opposite: write all using a dynamic language and then track down the bottleneks (if any). Once you find one you may selectively reimplement the functionalities involved using a C# or (rather) C/C++. I tell you this mainly because what are trying to do is to confinate the flexibilities of your system in the C# part; as the system becomes complex your C# "engine" will start to look like a dynamic interpreter, probably not the best one. The question is: are you willing to invest the most of your time into writing a generic C# engine or to extend your game? If your target is the second one, as I belive, you will probably use your time best focusing on you game mechanics, letting a seasoned interpreter to run the dynamic code. 

I'd rather cast shadow rays instead of line of sight rays. Let's say this is your view area (the potentially visible area) 

This means that you can convert your tile coordinate system easely in pixel: (x,y) => (35·x,-15·x) + (-35·y, -15·y) = (35·x - 35·y, -15·x - 15·y) = (Xpx,Ypx) You have to resolve the inverse problem you know Xpx and Ypx and you want to know x and y (in tile coordinate). Xpx = 35·x - 35·y ; Ypx = -15·x - 15·y ; can you solve this?it should be: x = 1/70·Xpx - 1/30·Ypx y = -1/70·Xpx - 1/30·Ypx Obviously you will have non integer values in general case: taking the ceil of both x and y will gives you the coordinate of the whole tile. 

The summing vectors do not need to be unit vectors but simply equal in length so, if |A| >= |B|, you can: 

I don't think those games used a realistic sound perception model. Probably the best approach is to evaluate the distance between source and hearer and distribute the probability of state change in the enemy. A gaussian distribution would be perfect but heavy; you may divide the distance in tree ranges: near (always wake), far (never wake), middle (chance to wake). In the latter case you can degrade the wake probablity from 1 at the "near" end and 0 to the "far" end; a sigma interpolation would be good but chances are that you will not notice the difference beteen sigma and linear interpolation... When you are in the "middle" range roll a dice at each shoot and see what happens. To add a little thrill you may consider to make the waking up monster to scream so they may advise others slipping neighbors using the same model (play a scream sample would be nice) The distance can be measured in terms of difference of positions or by casting a ray and summing up the "impedence" of each tile crossed (empty space:low impedence, concrete wall:high impedence). In the latter case the "impedence" can be seen as a lenght measure. If your monsters don't go around when sleepping, you can consider to take the opposite way by precomputing the sensitive zones for each slepping monster (I suggest you to do this way). If you want to precompute you may take all the tiles within the audible radius (the radius the moster can perceive with non-zero probability in empty space). For each tile you compute the distance and thus the probablity to wake up the moster standing in this tile. If the number of tiles are small you may store these results; if not you can summarize these values using macrotiles: 2x2 3x3 and so on tiles wide areas. For each area you associate a chance value that is the average of the chances computed in that area. The macrotile approach has the advantage to be simple to compute (4x4 macrotile coordinates are the current tile coordinates divided by four), but they may be inaccurate if a macrotile crosses a wall or when there is a large variance between the probablity values of the tiles that make up the macrotile. If you think that the macrotiles are too rough than you have to tink about a clusterization algorithm and consequently to store those cluster in a more flexible way (a way that is a little harder to compute at run time) Using a precomputing strategy you can use a better sound propagation model: using the "impedence" model I gave you, you can compute the shortest path and use the shortest path length as distance. Immagine that the player is in a empty room and between him and the sleeping enemy there is just a single tile wide concrete soundproof wall, using the ray approach you will compute a large "impedence" instance but using the shortest path the sound will "travel" circumventing the wall, stretching a bit the path but strongly decreasing the impedance. 

About your code there are some problems: First you do not have to store the previous state in each iteration (particularly if it is is expensive): you know exactly how much iterations you will do as soon as you compute accumulator. There is an error to the while loop: basically you integrate each in each step using a black-box integrator then you do a linear interpolation between last and current state. To make sure that this makes sense the the interpolation has to be done between the last state before and the first state AFTER the point of interest. You did: 

i.e. every affine vector can be reduced to a canon version where w=1 (we choose among every equivalent vector the one we like best). Visually (2D euclidean - 3D affine): 

You need to use some spatial partitioning in order to check for distance before consider a random position "good". Binary space partitioning can be useful: you construct a tree structure that you query before adding a position to get the closest one; if the closest is far enough you put the position into the tree so it will checked against the next position. If the current position is not far enough you reject it. Take into the account that as you insert positions, the probability to reject the next position increases... A differen aproach is to "cheat" by partition space before computing position. You can create a dense grid where each position is far enough from its neighbor, then you place randomly your planets in this grid. If the number of grid is large compared to the planets, you wont see the trick. 

You have to consider that an event is not purely based on user decision. As you noted some event has to append if when a set of decisions sequences are taken and then something else appends (like two day after). What I think you need is a way to model events and way to trigger it. While the first is more bounded to your specific case, the latter can be modeled by an hierarchical state machine (HSM) that directly or indirectly triggers your events. Keep in mind that a state machine suffers of the Curse of dimensionality that is only mitigated by an hierarchical structure. Soon you will understand that you need to model the complex meaning of status using a HMS but also provide a way to query it. In this scenario you have basic events (user decisions, time, change in weather and so on) that are processed by both the HSM and by basic event callbacks. The HSM provide a model for the "memory" and the callbacks provide a way to describe how that memory has to be used to compute the consequences of a sequences of decisions/external events. You may also end up in using a dictonary (or some other collection structure) of HMS, one for each "aspect" of status you have to compute. An example may be to use an HMS event related and one for the decisions that callbacks take in order to trigger events. All this infrastructure serves the purpose to mimic the behavior of a human Dungeon Master: he generally takes a mental record of the current situation (HMS["external"]) due to player decisions and environmental conditions; when something appends it can take decisions using its mental record and record some internal strategy status too (HSM["internal"]) in order to avoid to react in a similar way if the some situation appends for example.