I would use a circle for the body and a single rectangle for the beak, but that's just my opinion. Overcomplicating your collision geometry can slow down your app though, you're practically doubling (or more) the number of characters on-screen. 

Well since you spaghetti so kindly, I personally use an enumeration for which animation state the character is in. The states I use for a 2D platformer are simply RUN, IDLE, JUMP_RISE, and JUMP_FALL. Each animation state corresponds with a set of 8 sprites, which are loaded to my camera function, which changes what the player looks like on screen. Are you looking more specifically at 2D animations or 3D? Both function on essentially the same principles, but you may require a 3rd party program for 3D animations depending on your skill level. 

SDL2 is very capable of doing exactly what you ask. SDL2 is also more efficient and has much more utility. I highly recommend upgrading to SDL2 by following the instructions provided in the Migration Guide on SDL Wiki. EDIT: It took me a few days to migrate my project from SDL 1.2 to 2.0.3; most of the migration process was changing from SDL_Surface to SDL_Texture and figuring out how the new SDL_Renderer and SDL_Window types work together. 

I would also go for the ID solution. You should give every object in your whole world (not just on the current map) a unique ID. A 32 Bit int should be sufficient. Further every object can store a state value, also a 32 Bit int value. You can squeeze a lot of information into 32 Bit, e.g. you can make 32 flags out of it to store 32 bool values. Or you can use the higher bits for flags and the lower bits to hold a numeric value. For something as simple as a treasure, you only need to store a bool, where a value of 1 means opened and a value of 0 means closed. The you have a game save object with two methods: 

You only need to know which rooms the player has already visited and if he has the compass for this dungeon or not. Easy. Each room of of each dungeon has an objectID with a boolean state, that is 1 if the player has visited the room, 0 otherwise. Same goes for the compass, the compass of each dungeon has a boolean state. Same goes for doors in the dungeons (which may have been opened or not) and "crack-walls" (which may have been bombed or not), each one has a unique ID and a boolean state. All information of this game can be stored in this one simple list... it's pretty amazing, don't you think :-D Here is a very cool web page that has detailed maps of all dungeons of TLOZ, as well as an overview map of the whole overwold. Including information where specific items can be found (including secrets). Also check out the "Interactive Overwold Map", which allows you to navigate a 3 by 3 screens map and show/hide secrets and tips, including the insides of all secret caves. Basically this page contains all the information necessary to make an exact copy of the game, pixel for pixel you like. The game logic is rather simple and the whole game will tun out to need much less code than one might expect. I guess the most time consuming task is setting up all the maps of the game, defining all the object IDs and so. Doing all this "in code" is probably a rather bad idea. I would think of a format that your code can parse, e.g. XML or JSON or maybe something as simple as structured ASCII text. Each map has a fixed number of "fields", so you could store each map as X by X values, where each value defines the content of the field: a tree, water, a coast line and which coast line, rocks and which rocks, a wall and which wall, an enemy and which enemy and into what direction it is looking (most enemies cannot look at a direction, thus you could treat the looking ones simply as different enemies, there are only 4 directions they can look at after all). Values below a certain value represent static objects, those are always the same when you enter the screen, all other values represents dynamic objects (those that store their state) and the number is split into two parts, one part is directly the object ID of the object, the other part the type of object. E.g. dynamic objects have the highest bit set, the next 7 bits define the object type (allows 127 types, e.g. 1 is a door) and the last 24 bits are directly the object ID (allows up to 16.7 Mio objects, you won't need that many), however keep in mind that values below 1000 are reserved as special values. Since creating levels is often the most time consuming task, you may want to speed the process up and instead of starting by writing the game code, you start by writing a level editor for your PC/Mac. This seems like a waste of time, since it will take a lot of time, but trust me, it DOES pay off. Most professional games started by writing at least a simple level editor. It makes creating levels a very easy task (drag'n drop an object where you want it to be, give it an object ID if required, done). So not only it speed up the level creation process dramatically in the end, you cannot test your game code unless you have level data for testing it, since untested code is worthless code. And if you only created dummy level in the beginning, an editor allows you to quickly create them and also quickly change them to test certain aspects of your code. Now go out and have fun young jedi. I wish plenty of luck with this project. Update 2 If you'd like to use all the original artworks in your project, I found them online. Have a look at this page. It contains all the sprites used in the game. Even the original font. Just thought this might be useful for you. 

Just a quick question about fine-tuning/optimization. If I'm making a 2D platformer with a parallax-scrolling background (meaning no two frames are the same) do I really need to clear my renderer for every iteration? The entire scene will be drawn-over anyways, so if I can get rid of one extra function every iteration, it could help to speed things up a little bit, though I realize that render-clearing is not a very expensive function. By the way, I'm using SDL2. 

The angle of the feet is equal to the angle of the inclined surface. Since we conveniently have two points on that slope, we can find the angle of inclination (it's also possible to use two corners of the slope's triangular shape, but gradual slopes would become over complicated; for rolling hills, this is the best solution). Ultimately the slope will be H/P (assuming the heel of the bent leg is directly beneath the corresponding hip), or arctan(H/P) rad. Using cosines, one can easily find that H = (F+T) - (Fcosθ + Tcosφ). The angle of the foot becomes arctan((F(1-cosθ) + T(1-cosφ)) / P) PS: If you want to REALLY get into, you could also find the added width to P. PSS: The foot will only bend to far up, so keep that in mind before you try to climb an 80 degree slope. PSSS: People don't climb hills on their heels, but they do rest on them. Keeping the foot perfectly flat up the hill could somewhat accurately depict the player standing on the balls of their toes, and allowing the heel to sink to the ground while idling could make for some very realistic movement. 

Basically, your character has 5 main points associated with them, as shown in the image above. 2 head collision points (green) 2 wall collision points (red) 1 ground collision point (yellow) Every step of the game you check collision on each of these 5 points when moving. If either of the head collision points are hit, you have jumped to high! If either of the wall collision points are hit, you have hit a wall, and if your ground collision point is hit, you have hit the ground, and should move your character up a pixel (until it no longer detects ground). So how does this handle slopes? Well if you look at the image above, you'll notice that some things may be low enough to pass under the wall collision points, and then hit the ground collision point, forcing the character to move upwards. This means if you had a slope, if the slope is too great, it will hit the wall collision point before the ground collision point; no access. However if the slope is low enough, it shall hit the ground collision point before the wall collision point, moving the character up, and therefore making the character walk up the slope. Extra points can be added for collision detection to improve mechanics, though remember every point you add means more calculations... Adding two ground collision points, and spreading them evenly along the bottom sometimes helps. The further the ground collision points are from the middle, the steeper slopes are that the player can handle. Alternatively you could just make the wall collision points higher up, but this may not end well (your character may end up "Jumping" onto obstacles. So my advice is keep the wall collisions reasonably low, (remember if the head collision points are in the corner as shown in my image, then they can also act as wall collision points). Sorry don't have access to any code to help you out here, and its 1am, too tired to think of it off the top of my head. Hope it helps you, and if not, someone else who glances by :) 

If you call store and there is no state stored for this object ID, the object ID is added to a list among with its state. If there already is a stored state, it is updated to the new state. The load method searches the list for the object ID (for fast access, consider a hashtable, so you don't have to perform a linear search or a sorted array, so you can perform a binary search) and returns the stored state or 0, in case no state has been stored (0 should always represent the default state for all objects). When you now open a map screen, you initialize all the objects on that screen. The objects all perform a call to the current game save object to find out, what their initial state should be. For treasures, if it is 0, they display as closed and if it is 1, they display as opened. What is inside the treasure is usually hardcoded in the level data, unless you want to make it random, but if it is random, you don't have to store that in the state either, it will be randomly chosen when the treasure is opened. You may also make it partially random (e.g. the treasure must contain rubies, bombs, etc. and the amount must be at least between X and at most Y). Depends on how (un)predicable you want the game to be. I think the original TLOZ is rather predictable. If the user now opens a treasure, the treasure updates its state in the game save object, indicating that it has already been opened. So next time the user enters the map screen, the treasure displays opened. Whenever the game is stored to disk, the game save objects simply writes all known objectIDs and their states in the list to a file. This can be a simple list of two consecutive 32 Bit values like 

You absolutely can combine them! Many 3D games contain an image for the characters body and one for the head, and some combine the two for a single texture for the entire a model. Here's an example of a whole head's texture: 

Obviously enough, if a collision-enabled object does not come within vertical range of another collision-enabled object, the collision system wont even both to run the numbers. There's tons of ways to implement this, too. If your system is texel based, you could even use raycasting as an accurate qualifier which might, in some cases, be simpler. 

One solution would be to use raycasting collision for the circles, and traditional box-collisions for rect-rect collisions. 

Personally, I use a spin on the first option you listed. When checking if A collides with B, however, a series of disqualifiers (or a singular disqualifier) can be used to reduce the computation required for each iteration of your collision checker. For example: 

My question: Which of these two processes, if either, would be less of a burden to the cpu? If neither seem reasonable, what other alternatives are there? 

If a saved game is loaded, the game save object reads this list again and initializes its internal structure with it (the hashtable or sorted array). To indicate the length of the list, you may either store an additional int value in front, that tells the code how the long the list will be or you can terminate the list, e.g. by adding a final entry of objectID to it, where is reserved value (no real object in your game has this ID) and thus indicates the end of the list. Of course not every aspect of your game may be savable that way, so a save game file may contain more information before or after the object state list. E.g. you may want to store how much rubies/bombs your character currently has, which other special item he posses, and so on. On the other hand, you could store all this to the list as well, using special reserved objectIDs. E.g. real objects start with objectIDs from 1000 upwards. If 0 is reserved, this gives 999 special object IDs. objectID 1 could store the amount of rubies, objectID 2 the amount of bombs, objectID 3 the kind of sword the player owns (in that case different values will indicate different swords; IIRC you could only have one sword at a time in TLOZ). I admit that this is a very simply approach, but simple is usually good (think of the KISS principle). It should also be no problem to make this whole think very performant. Choosing the right data structure, adding to the list, searching the list and reading/writing the list from/to disk should be very fast, even on the slowest iPhone it should happen in no time. E.g. you can store everything in a , keys are of type with the objectIDs and values are with the state information. Such a dictionary cannot be stored to disk directly (only dictionaries whose keys are can be stored to disk with a couple of simple function calls), but iterating over a is really trivial. Just add all those 32 Bit values to a and this one can be saved to disk with a single method call. Loading is the other way round, read the whole file into a (single method call again), iterate over the list and keep adding the keys and values to a . Should be piece of cake. I guess the original save format was somewhat similar to such a list, yet as the NES only had a 8-Bit CPU, I guess the values where only 8 Bit (that's why you could not have more than 255 rubies) and the objectIDs probably 16 Bit (16 Bit doesn't fit into the registers of a 8 Bit CPU, but just like 32 Bit CPUs can handle 64 Bit values, 8 Bit CPUs can handle 16 Bit values, it's just slower as multiple operations are required for everything that only requires a single operation for 8 Bit values). UPDATE Since I think this is a cool project, I wrote some sample code to give you starting point, in case you decide to go that route. This would go into : 

I have no experience programming AI. However, I can offer you my naive strategy that might help you brainstorm a little. I know you said you'd prefer experienced individuals for this question, but this is an intimidating question to say the least. Right then. What I would do is implement a per-turn checklist/surveillance. Each AI unit, every turn, would: 

Scan the map for advantageous positions (high ground, bottlenecks, etc) either within a range or globally, depending on how smart/fast you want them to be. Compute the number of minimum turns required to reach that spot, and compare that number to the number of turns the player would have to use to get there. If the AI should decide to move, scan the immediate surroundings. If the terrain's obstacles are purely static(mountains, forest, etc), then find the quickest route around. If the obstacles are dynamic (other AI, or (I guess) player units), check if the AI is in the way, and if so, determine if it is about to move. If it is moving soon, wait it out, otherwise, go around. In order to move as a team, I would implement a 'squad' sort of class/array. Assign one squad to the front; if another is available, assign it to the rear; if another is available, assign it to the side closest to the nearest hostile. If a single unit is dispatched to reach the gates, dispatch a single unit (or two, if you want to smite the player) from the largest squad. 

My final advice though, is to try it all out for yourself. Check out Reimers tutorials in XNA and DirectX (and just browse google for some OpenGL tuts), and work out which one you think would be better for your interests. 

I made an isometric game in flash once. Never finished it (unreliable artist) but for me, sorting was simply a matter of organizing according to y coordinate. The further down on your screen the block is, the closer to the top layer it should be. Your character, for example, in the stuffed up picture. The Y coordinate of his foot is greater than the y coordinate of the block that overlaps him. Therefore, he should be in front of it, not behind. Then if you start having multiple layers in your world, each individual layer of the world is sorted individually. Then drawn bottom upwards. Just comment if you need more/better explaining 

DisplayBox.SetValue is a function which goes through and sets the texture. This is working! DrawIsoCube() draws the cube (the test model) and this is working too. The problem is definitely something to do with the unreusability of the render target. Pretty simple yet it's not working. It appears that whatever the last image being rendered is, is shown in every image of the allBlockIso array. Anyone know a fix? Cheers. P.S. sorry if this wan't explained well. I'm not very good at explaining :P 

While testing my player's jumpinig algorithm, I've come across two odd problems. 1) My player's hard-coded jump height is always much greater (roughly 1.5 times) than the in-game result, making me enter completely abstract numbers for the hard-coded value. 2) My player's jump height increases with lower FPS. At 60 FPS, the jump height was found to be 237, and at 30 FPS it was 269. This has me completely bumfuzzled. I've been using this article pretty heavily while implementing my jumping function which can be seen below. 

As a mobile gamer, I can say (personally) that some in-game adds don't bother me at all. For example: the game Jupiter Jump by Noodlecake Studios only shows ads after the first attempt (full screen) as well as at the main menu along the top. I think this is well-executed, as it doesn't overload the player after every attempt. Vector, by Nikku, is a little encumbering. After every attempt (roughly every minute) a full-screen ad is displayed. This not only annoys the player, but abruptly interrupts the flow and plot of the game. Placing your ads away from the main focus of the screen creates far less stress for the user, and carefully managing the frequency at which you display ads can also keep your players engaged and entertained while unknowingly supporting the developer. One thing to avoid at all costs is "pay $2 to get 50 coins!" If the user downloaded the game for free, odds are that he or she will steer clear of paying for anything, unless they become obsessed with the game (Candy Crush Saga). Also avoid using "sign up for Dish to receive 1000 XP" sort of deals. It's completely irrelevant to the user, and encouraging the user to sling his or her credit card information at one random company or another is borderline immoral. 

The code is untested, but I verified that it does compile. It doesn't assume you are using ARC (automatic reference counting), but in case you do, the code will become somewhat simpler (all / calls can be removed and must not call in that case; calls need to persist also with ARC). Of course, if all the "objects" like the player's sword are also represented by real objects in Obj-C, I would not place the values for the object states ( enum values) into the header. There is no need why the "whole app" needs to know about them, it's enough if the objects know how to interpret the state numbers. In that case I would place them into the implementation files of these objects, since this knowledge should then be private (encapsulated by the object). I found a pretty useful web page, that lists all the objects from TLOZ. Storing the Triforce State in object IDs is also easy. Each piece is represented by a flag (you have 32 flags per int, the Triforce doesn't even consist out of that many pieces). Storing the dungeon maps seems a bit harder, but that isn't really the case. You know, those overview maps: