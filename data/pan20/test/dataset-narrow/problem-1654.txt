The numbers in the left column correspond to line numbers from the source. Notice line 4, -- incrementing an integer by one -- is three lines of assembly (each is one instruction). Line 5, checking the same condition as the loop, is 5 lines of assembly. The compiler can be made a bit smarter, which should help to speed things up. If you throw in the switch (2nd level of optimization), i.e., , it will spot the fact that this loop does nothing, and that's what it will then do: nothing. If you look at the assembly as per above, there won't be any for that loop, and: 

Remember, the pi cost ~$35 retail. Not $135 or $350. So that's the answer to the literal question in your title, "Why do the USB ports and Ethernet port share the same controller?". Note it's not an unusual approach for multiple USB ports to share the same bus --- it is probably the norm. I notice the laptop I'm on now has 3 USB ports but reports only two, 2.0 "Full speed" hubs. So at least two of those ports share a hub and they will not both get "Full speed" at the same time. I'm sure if you check your current system it's put together along similar lines. Combining the ethernet with that is unusual, but it's worth noting that USB 2.0 should provide 480 Mbps whereas the 10/100 ethernet connection would require at most 100 of those. Wikipedia notes, citing spec as a source, that, "Due to bus access constraints, the effective throughput of the High Speed signaling rate is limited to 280 Mbit/s or 35 MB/s"; whether that means per port or for the bus as a whole is unclear. 

This is an acknowledged defect of the A/B models that is corrected in the +/2 models. When you connect certain things to the USB ports -- a common culprit is wifi adapters -- there is a current surge and corresponding voltage drop (power = voltage * current, or voltage = power / current) which causes the pi to reboot. Unfortunately you need to have such things attached when you boot. In my experience removing them is okay. 

Yes, that is the most fundamental step in dealing with a potentially corrupt SD card. If you cannot do that you might as well just re-flash the card. However, all that's required to do that is a computer which can run on an ext4 filesystem; the obvious choice for that OS wise would be some GNU/Linux distro. But if you don't have a normal computer running linux and don't want to install it: 

The error is NOT that you are not out of space. You may also be out of space, but that is not the problem, or at least, not the primary problem. The explicit error is that you are perhaps not not connected to the internet -- or, since those are 404 errors ("page not found"), it could be that the pages have really changed and the db needs updating, which is why it wants you to run an update. The second error implies is already running in another terminal. It could also be one that prematurely exited, or because of disk corruption ("no space" might also a symptom or a cause of that). I would try a reboot, then . 

On pi-specific distros (e.g. Raspbian), the openGL ES libraries are compiled for it and use hardware acceleration. Thus, anything that uses openGL ES would also make use of such and do not need to be specially written for the pi's GPU. This would mostly be applications that involve 3D graphics. The easy way to check this is to run on the application binary and see if anything points into . 

Individual GNU/Linux distributions are usually made up of pre-compiled binaries, and these tend to be more limited than the aforementioned possibilities -- commonly x86, x86_64, PowerPC (old Macs), MIPS, SPARC, ARM. You could roll one for a whole host of other things though; there's a few dozen arch's in the vanilla kernel source, and the source code for the rest of the userspace is publicly available. That's exactly what was done to create Raspbian, in fact, except that support for the BCM2708 was added to the kernel. 

The extended partition reported by fdisk is one that's divided into a number of other "logical partitions". The reason for this is that MBR partition tables only actually have room for four primary partitions, so if you want more, they have to be chained in this way. This is also why there's no and ; these are the primary partitions but you only actually have two, and the aforementioned extended partition . and are logical partitions referenced via the table associated with the first extended partition, in this case . What that adds up to is you can ignore . The only real partitions are 1, 5, and 6. This does not necessarily mean they have been formatted, however, so you may get some error if you try to mount them. 

Not there. Since you aren't referring to an option, GDB assumes you are trying to alter the contents of a symbol in the process memory -- but there isn't one with that name "in current context" so you get that error. 

You may also want to comment out the line from the above to prevent clutter or confusion in the future. A few things to note about this: 

I don't use python for this stuff but hopefully that doesn't matter much. By my reading of 8.5.1, "I2C Serial Bus Address Configuration" you have the two address pins connected to other (non-I2C) GPIOs and their state determines the bus address; they should remain in the same consistent state. Judging by your use of 0x40 = 0b1000000 you have both those lines low. Beware this means they must actually be outputs set low. Not connecting them, or connecting them to inputs, is not the same. I think you should then see address 0x40 occupied in . I presume you've confirmed this. It refers to using that seven bit address with an eight bit either high or low to indicate read or write; those timing diagrams show a "7 bit serial address bus byte" but if you look it is an actual 8-bit byte; the least significant bit is either 0 or 1. However, I believe this is standard and the nature of the vs. methods deal with this so you should be sticking with the address (the python interface is a little confusing to me this way; with C API you open a handle to the I2C node, , then use an to set the specific 7-bit device address, and thereafter the handle always refers to that specific device and no address is used, but you are always either reading or writing; I'm presuming your use of the python API is correct). Then the first thing you should do is then write 16-bits in two bytes, MSB first, to register 0x02. Presuming you want 14 bit resolution for both temp and humidity, following 1) a-b-c on pg. 11 this means the value here should be 0x1000. Note I think Figure 10 at the top of that page ("Writing Frame (Configuration Register)") involves a misprint when it says for frame 3 & 4 "Data MSB/LSB from SLAVE" -- that should either be "from MASTER" or "to SLAVE" (if you look at the ACK bits those are all "by Slave"). "0x1000" because to read temp and humidity together, you want to set the 12th bit counting from 0, i.e., 0b0001 0000 0000 0000 (so the MSB is 16, 0x10). This is also the "reset value" from table 2, pg 14. If there's a method I would use that, not . Then you "trigger the measurements by executing a pointer write transaction with the address pointer set to 0x00". Thus far that seems to be what you are doing, but it is then not clear whether you are either waiting for either the "conversion time" to pass (pg. 5) or until the DRDYn line goes low (connected to a regular GPIO as input). Doing the latter is probably more of a hassle as it requires a poll or callback and takes up another pin, but it also seems like the most unequivocal method. The conversion time is 6.5 ms for both temp and humidity; I would guess those are concurrent but you could try both 7 and 14 ms waits (I don't think the resolution will always be that precise, and while you should get at least what you ask for you might experiment with ranges from 10-20 ms). Then you read two bytes from register 0x00 (temp) and two bytes from register 0x01 (humidity). 

This is a two state system -- the switch is either to the left or to the right. Since there are three pins, and presuming two of them are not hardwired together, this means the switch position determines which two pins are connected, and that one of the pins is always connected to another one. You want to determine which of the three pins that is -- I'll call it pin X. Connect it up as follows: 

See if you don't know about that. is check only sections 2 (system calls) and 3 (library functions) to avoid including a long list of section 1, etc. stuff. If you absolutely want to invoke another executable and process its output (which is much more of an awkward hassle than a system call such as , not to mention much much much less efficient) see , which returns a to the process's stdin or stdout. 

Probably not. It is more likely evidence of a corrupted filesystem, especially since (which can usually repair minor problems) failed. You'll need to either: 

The window manager, which controls the appearance of window frames and titlebars. The desktop environment (DE) -- if any (you aren't using one) -- which controls things like taskbars, and may provide a unified interface to the window manager. Widget libraries, which are used by individual applications to provide normal GUI features like menus and other controls. DE's also sometimes provide a unified interface to one or another of these. Since they are are coded into the applications, there may be more than one in use on any given desktop (resulting in a subtle or not so subtle difference between one app and another). The two most significant ones on GNU/linux are Gtk+ (primarily) and Qt, both of which use incompatible major numbering systems, meaning, e.g., an app written for Qt 4 can't use Qt 5 and vice versa. 

You might have a look at the output of for clues about what you want to to use in a "Before" clause; see for how to interpret the output. A more detailed big picture is available with (see here for an example of that). Examples of service files can be found in and ; they are enabled/disabled/started/stopped etc. via (see ). 

If that does not work, increase the number to 256; the default is 64 and the units are MB of RAM dedicated for use by the GPU (so you probably want to do this in conjunction with a "hardware acceleration enabled" setup). If 256 does not solve the problem, then this is not the issue. 

Right, because you are copying the entire physical device. If the partitions on it do not fill the entire card, you should find out how big they are with, e.g., . This is from the util-linux version, but I suspect the freeBSD one is very similar. The card is from a Pi, but it is not in the Pi: 

The is effectively meaningless here, although that may be hard to notice if there is no output anyway. However, if this is run from the command line it will leave the backgrounded process more prone to "hangup" signals if the "controlling terminal" dies which is perhaps why you've resorted to . In any case, the background operator must be the last thing in the command. So the complete version for should be: 

With regard to the common linux distros, there are two partitions in the image. The first contains a small vfat filesystem (50-60 MB) with a single directory of a few files such as: 

Will show all the processes belonging to user . The total of the amounts would be what is used for that user (who may be logged in multiple times). However, note that the value is very significant here. Its exact significance is hard to calculate,1 but if it is quite high, it likely means there is another process created from the same binary. For example, there may be many instances of running simultaneously, and their SHR number may be 90% of their RES number, indicating each one really only added 10% of the RES amount to the amount of RAM actually consumed. For an login, there are minimally two processes, an fork (although I think this depends on your ) and a shell instance. Finally, note that a maximum number of logins can set for the system as a whole or per-user; see and . 

Not exactly, but if you follow the instructions in the answer you linked you will be using the updated version. If you want to understand the purpose and function of , read , which begins: 

Without trying I'm not sure, but I think if you run an application in the foreground in an script, X exits when that application does. This leaves the user still logged in at a VT, unless you actually use a DM. Alternately, you could try a script like this: 

Chromium (a fork of chrome) is available for the pi, supports HTML 5, and although it is undocumented, has a mode. I tested this on the raspbian, but I imagine it is in the Arch and Pidora repos as well: 

This indicates the kernel did boot successfully, but the root filesystem on the second partition is unavailable. This implies you might have copied only one partition from the image. If you are using Windows some tools might do that. If you are using Linux, OSX, or anything with available the methodology here is pretty foolproof. If not, you should follow the instructions for your operating instructions to the letter. Currently it looks like Etcher is the recommended method; Win32DiskImager should also work. 

Based on similar experimentation I'm going to second the conclusions in the link about UART, namely, at 1 Mbps it is reliable, above that less so. If you want speeds that are anywhere near networking speeds, you need to use a networking interface -- ethernet or wifi. That you want to do datagram based transfers pretty much locks that down. Something missing from your list is connecting the Zero to the B+ via USB as an OTG ethernet gadget, which means: 

The first will probably say ; the second will return that and some other choices including . There are other nodes in that directory which will tell you the current frequency () and the min/max possible (check ). Set the governor with: 

The full path is necessary as $PATH may not be properly set for rc.local when it is run at boot (but it will be for "myprogram"). The just backgrounds the process, allowing rc.local to continue and exit. "myprogram" is now running owned by root. That may be desirable if you want to open a low number privileged (server) port at start-up; for security the process should subsequently switch (effective) user id (euid/uid). If you don't need root privileges at all: 

Guess what equals? 5, which is why you keep getting your argument back. But itself has a different value, which is the memory address of . Dereferencing yields the value at that address, which is 5. That's reading the value at . Hence ditch the and make a pointer: 

I don't have them installed so can't see a list of files; on the them shows different sets of details, but trying to them looks exactly the same. However: 

It doesn't really make sense that this is some kind of intentional "sleep" mode. What is the point of a wifi adapter that cuts out after a minute or two? In other words, I do not think your problem is caused by such a feature, so trying to disable it will not help. I have an adapter with this exact same chip that I use without problems on the pi, by the way. You need to make make sure the pi is keeping the correct time (look at the output of ), then allow this to happen and look through afterward; the messages in there are timestamped. Look and see if there is any explanation. If the adapter really were putting itself to sleep, I think there would be an indication. If the adapter doesn't have a light in it to indicate whether it is working, it may actually be something unrelated.