That's certainly a legitimate approach, how successful it will be is another matter. This article is about an iOS game called Gasketball that took a similar approach and how that worked out for them (spoiler: not so great). Based on this article I don't think players are enraged by the idea of getting a free-to-play game then paying some amount of money to unlock the full game. 

Your signature for is incorrect. It should be . Flash can be forgiving about this sort of thing resulting in some infuriatingly subtle errors. 

That is setting the size of the screen Flixel will draw onto. If you want a zoom level of 2 you should have . You should check out the source for Mode to see how to create a world larger than the screen. What happens in Mode is that the world size is set to 640x640 and the player, blocks and enemies are added in that world space. The create() and generateLevel() methods are where most of this happens. 

I've been noticing that if I have two images, lets say squares. I have A as the parent of triangle B. Triangle A and B both have their offsets at their anchors, which are on the 4 corners of it's "box". Triangle A should be behind triangle B, since it renders from top to bottom in the hierarchy (the last item being on top). However as I re-size my screen, sometimes triangle A will poke out from behind triangle B. Even if they both are using the same image, and have the exact same dimensions. Whats causing this, and how do I fix it? Additionally, I noticed that while the anchors and offsets can be finely adjusted, the image is not. You have to adjust by certain interval sizes and the image will just snap to that new size rather than adjusting finely as you change the offset or anchors. 

These are just a few questions to ask yourself and your team. You can probably come up with plenty more. Whatever you do you definitely want to be exporting bitmaps for use in your game. If you're interested in skeletal animation you should check out Spriter. Looks like there is at least one Cocos2d implementation of the Spriter format on Github. 

I'd like to go with option #3 and could devise my own solution easy enough but don't want to reinvent the wheel unnecessarily. Is there some standard naming convention used for a gamepad API that supports both 360 and PS3 (and possibly other, similar) gamepads? Is this even really an issue -- should I just create an API, document it and call it good? 

I want to be able to do range checks against the entirety of an enemy object, and not just it's transform.position. The enemy object can have it's side or nose within range, but range detection will not determine if it's close enough to be targeted unless it's transform.position is within range. 

Making this mesh via code and the texture seems to only tile on the sides, but not on the top. Any idea whats going on? 

I want to create a custom chaped collider in unity to create point-defense triggers for objects. I have a spherical collider that triggers for attacking objects that enter it already. However I want cone-shaped colliders for point defense to detect and shoot down enemy projectiles in certain areas. I can do this by creating a custom mesh and importing that for the collider. How much of a performance hit can this cause? If you have 1,000 of these colliders active in a scene with objects flying in and out of them, will I see significant performance reduction compared to just using a spherical collider and dropping the cone idea? 

A potential optimization is to use distance squared values rather than distance as is relatively costly to call each tick. 

In my case I maintain the state of the keyboard by listening for the and events in the client. When one of these events is fired the client sends a message to the server and then updates its own state. This allows the client to employ client-side prediction (see this article for more details) and gives the server the minimal amount of information it needs to execute the move. When the server receives one of these events it updates its own internal state and then rebroadcasts the event to all other clients so they can handle it as well. To keep everything in sync the server will periodically (every 10 ticks of the engine in my case) send a "sync state" message to all of the clients giving them the exact positions of all players. You never want to sync the state of a client to the server as that opens up all sorts of cheating opportunities. EDIT To be clear, state syncing should only ever go from the server to the client, never the other way around. END EDIT I found Maple.js to be quite useful as a reference for a concrete implementation in Javascript. 

Edit2: I just realized that I can manually edit the attributes I want. I can send it's text to the appropriate class, clear the input field, and de-select it if I wanted. No need to fire the event other than for ease-of-use within the inspector. Sorry for wasting you guy's time :) I'll leave this question open in case someone does figure out how to fire these events manually though. 

I'm creating a text box that allows for selectable text, based off of Unity's InputField. An issue I am now facing is that the selection highlight does not respond to masks (The parent has a mask, but it is just ignored) depth is also ignored, this seems to render through any other UI element that's in-front of it.: 

Write a script to parse the JSON format you have into the Cocos 2D format you need. Recreate the tps file so you can easily export whatever format you may need in the future. This assumes you have the source sprites that are packed into your atlas. 

I've used A Bitwise Method For Applying Tilemaps and found it to be a very elegant solution. The article provides a concrete example and discusses how to extend the algorithm to handle multiple terrain types. 

Texture Packer won't convert it's exported data from one format to another. To export in different formats you need to have the Texture Packer (tps) file used to create your JSON atlas. If you have the tps file, just select the exporter you need from the "Data Format" drop down list in the left-hand pane. The TP home page has a graphic that explains the process succinctly. If you don't have the tps file you have two options: 

I'm getting some attacking to work with my units and I noticed that the coroutines seem to start adding up even after the StopCoroutine(IEnumerator) as need called. I dug around on ways to perform an attack loop, most of the time I found "Use InvokeRepeating" and "Don't use InvokeRepeating". Since invoke uses reflection it's performance heavy anyways, so I'd rather not go down that road. How do I get my coroutine to stop? Is it because it's in a while loop inside the coroutine? If so, how do I fashion an attack loop without using invoke? 

Prefix: I am NOT trying to rotate a sprite 90 degrees by it's transform, this changes what is up/down and forward/backwards for the object. I need the sprite displayed on the X-Z plane in comparison to the default X-Y plane in it's natural state in the game world with rotation transforms of 0. I'm trying to use 2D sprites on the X-Z plane, how do I go about either modifying the built in sprite renderer to do this, or creating my own custom sprite renderer component? 

Since you're using XNA you can check out the Platformer Code Sample on App Hub. I believe the relevant code is in the method in the class. This is a working example of what I outlined above. Metanet also has two really great tutorials on 2D collisions. 

Are there any particular technical contraints that make one option more attractive than the other? Frame-by-frame animations will tend to use more memory than skeletal ones. Skeletal animations will require more complex code to implement. Are there any design constraints that make one option more attractive than the other? Do you want your character to bounce around like a rag doll when he dies? Do you need to be able to change the animation at runtime? These things will be easier to do with skeletal animation. What tools does your artist prefer? What workflow does your programmer like? 

I'm at a loss, and have no idea what I'm doing wrong. My dynamic meshes seem to work perfectly fine for everything else in the game. Thanks. 

I've found that making a looping script works well for an attack timer, and avoids the problems that come with using a coroutine to time something. Bonus here is that you can use this anywhere in your scripts for an easy timer. 

When an object is clicked an event is published with relevant info on what was clicked. There are subscribers to this event using "MouseClickEvents += YourMethodNameHere;". This works as intended. However, since two players will have the same scripts as components this creates an issue where the 2nd player's scripts also add themselves to the invocation list of player 1's delegates, and vice versa (as far as I know, I don't know how to check what is in the invocation lists). So each player receives their own events, and the events of the other player. If I have a fundamental misunderstanding of a concept here, please let me know. 

Just support different aspect ratios and don't worry about it. Pick a specific aspect ratio (say 16:9) and do a best fit on all other aspects (i.e., letterbox or pillarbox) 

Using a plain ole sprite sheet and animating frame-by-frame works just fine. The same goes for doing skeletal animation. It's really going to come down to your specific needs, for instance: 

In your collision processing you need to get a list of all rectangles that your player is definitely colliding with. As you loop through this list you need to test the intersection of the player and each rectangle. This intersection will give you and values. Compare and . Whichever value is smaller is the axis you want to resolve along. That is, if , adjust your player's position along the x axis. If , adjust the player along the y axis. Loop until done.