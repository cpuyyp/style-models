Unity Shader Code : Note: If you are testing out the shader and nothing is displaying; Rotate your camera around so the normals are facing the right direction to show up. 

Further note on shadows: I explored using a geometry shader to make shadows but since the GL calls run immediately, they are not in the normal rendering pipeline and and won't pick up the pass. 

I was only ever able to rotate a mesh in XNA. I was able to mimic the bone binding effect by structuring the different meshes in a hierarchy so that they affect each other appropriately (pictured below). The hierarchical method works for this simple tank model but a more complicated model would require a skeletons in many situations. 

The final effect I ended up with in XNA is pictured below. You can download my project here. The code is essentially the same as the original code in the question but simplified to only do turret rotation instead of barrel and turret. Download the XNA Project 

Using GL Lines: I would recommend using the the GL API for drawing lines. The line thickness will always be 1px on screen and there is no option to change it. There will also be no shadows. The GL method calls are executed immediately so you need to make sure to call them after the camera has already rendered. Attaching the script to the camera and using Camera.OnPostRender() works good for rendering in the game window. To get them to show in the editor, you can use MonoBehaviour.OnDrawGizmos(). Here is the barebones code to draw a line with the GL API: 

If you have submeshes, the renderer for those meshes will need to have materials. Many tutorials focus on renderers with only one material, which you access through its property. If you have multiple materials, you can instead access the array. Each material corresponds to submesh . If you want, you can apply different materials to each submesh by editing your assets in the inspector. Each material could have different textures, different instance parameters, or so on. Or, you could apply one material to all of them, and then edit that material in a script. Bear in mind that Unity uses a copy-on-access pattern, so it will internally create new material instances the first time you access the array. As an example, the following would apply a random color to each submesh: 

You can the component. Be careful about which object you destroy, though. If you pass a GameObject to , you will destroy the entire thing. To destroy the component, you must pass a reference to that component specifically. 

Those calls aren't free, but they are very fast and usually aren't a problem. When in doubt, check the profiler for performance hotspots. Unless you're making thousands of these calls per frame, they're probably not a big time sink for your game. 

Your solution multiplies by negative one, which flips the direction back to match your desired result. It's a minor kludge, but it works in a pinch. When I find myself doing that, I usually figure I've flipped the direction of a vector accidentally. You can also fix this by flipping the operands for the subtraction: 

"Ascii Start Offset" is a Unity internal field. It is not available in any of the Managed(C#) DLL's, so you can not use reflection to get to it. The "Ascii Start Offset" field is named in Unity's internal representation of the class. Since the "Ascii Start Offset" is shown in the inspector, I knew it had to be available using a Custom Editor. All of the properties shown, are available to the custom editor via . I figured this out using a reflection tool and diving into what Unity does behind the scenes when drawing fields. There was, of course, more churn before I figured it out. Luckily there is so you can make your own custom editor on the fly. Normally Custom Editors are made with a decorator (you can see an example below the horizontal break). You can't use this snippet in game runtime, but it works just fine anywhere else in a editor script. 

Here is a full script that attaches all of the given points to the main point. There are some instructions in the comments of the code to get it set up right and about what is going on. If you are having problems changing the color of the connecting lines, make sure to use a shader on your line material that takes into account the vertex color such as . 

Artificial Intelligence is, unfortunately, an entire subsection of Computer Science. It's truly huge - something you can take a couple of semesters of in college just to get you warmed up. There are a lot of common options - Decision Trees, Rules Engines, Neural Networks - the latter of which most people tend to find extremely interesting when they first hear about them (and invariably prove to be a horrible idea in the kind of scenario you're describing - look out for that). I recommend you look up some topics or books on basic AI development in general - it may not seem directly relevant to games specifically at first, but you'll appreciate understanding the fundamentals. 

Although this may seem like a bit of a cop-out, it is worthwhile to note that no one can make a provably accurate model of space-faring economics because we have no examples of it in real-life. All examples of space-oriented trading simulations make their own science fiction assumptions about how their universe works, and most of them take the Planet of Hats approach to alien worlds, in that, despite planets being huge and diverse things, the worlds are culturally very small and limited and possess only one real identity. With this kind of view on planets, it is consistent for them to have only a single, simplified economy for each of them - however, this is certainly a massive simplification of what might occur in real-life. In other words, if you want realism as your primary goal, then you should know that it is unlikely that there has ever been (at least that I'm aware of) an economic model that is even close to being both realistic and on the galactic scale. Although it may be useful to use real-world economic models as a starting point, there is no guarantee that it will be even close to accurate. There is a measure of fiction, imagination, and utter guesswork that is simply required to make this work. 

It is possible to use C++ with the Free version of Unity, although it is easier to work with if you have a Unity Pro license. All you have to do is wrap it up in a DLL and follow the instructions below on where to place it. I wrote an article that covers this topic: Unity and DLLs: C# (managed) and C++ (unmanaged) 

I notice the problem on a Cube(5/8) and Quad(2/4) but seems to generate all the geometry fine on a plane, cylinder, etc. The following are some results from using the bare-bones geometry shader. Cube (closest: Unity default, further back: Cinema 4D exported cube): 

I am playing with a geometry shader and I am wondering why it doesn't generate geometry for each vertex in all meshes? 

Lines with Shadows and Radius If you need to change the line thickness and want to have realistic shadows. Just use a cylinder mesh and scale the height. Here is a script that will make a cylinder to connect each point to the main point. Place it on a empty game object and fill in the parameters. It will hold all of the extra connecting objects. 

Keep in mind I had this problem over 2 years ago and I have since moved onto Unity 3D. This is more of a conclusion than a solution. The main problem was that moving the bones did not move the mesh. I used Cinema 4D to model and rig the model and exported as . There are many fbx export options in C4D and I tried many variants with no success. Here are two topics I made on C4D Cafe about XNA and C4D but they do not have a solution. 

To adjust SFX volume, change the master volume of the audio listener. To adjust music volume, change the volume for the music's audio source(s). This doesn't take into account the new audio system that shipped with Unity 5. It may now be easier to manage this with audio groups and mixer controls. 

It's absolutely possible to improve on this method, if you're comfortable with the math, but that's the basic gist of it. 

This gets you a vector pointing from toward yourself. By applying a force in that direction, you end up pushing yourself away from . Think of it using one-dimensional numbers: 

Once you start a coroutine, it will continue processing automatically. If you call twice, you will launch two independent coroutines. If you call once per frame, you will start a new, fully independent coroutine on every frame. By the time your game finishes running 50 frames, you will have 50 copies of running. This is probably not what you want or expect. If you want 1 copy of , you will need to start it exactly once: 

You'll need appropriate values for , , , and , which means you need to know the location and size of the texture on the atlas. I've also assumed that those four values are in UV-space. If your atlas coordinates are specified as pixel coordinates, you can convert those to UV coordinates with . Suppose you have a texture at with size , on an atlas with size : 

As mentioned by others, it's likely you want an effect similar to a "snake". Effectively, you want to break down the "tongue" into individual pieces that form a trail, much like chain-links. The objects you'll want to create should work similar to a linked list - each node will point to potential nodes that can come before and after it. From there, you pick some relative positions near each end of each node where they will visually connect when drawn on the screen. You may want to have a maximum angle at which each node can bend relative to its prior node in order to make it look smooth. From there, you can simply make a node act special if it is "the end" node, i.e. the following node it points to is null. You can have it manipulate things in whatever manner you'd like at that point. 

It sounds to me like you have to take your input, in gesture form, and convert it into simple 4-directional input. You're basically converting very complex input into something much simpler. You're going to want to take the starting position and the ending position of your gesture command and determine the angle of the vector between them. Recall your high school math - it's a simple formula. You're going to have to get comfortable using COS and SIN. With that angle, just determine which direction it most faces. You can break them up into 90 degree segments for each direction.