I would like also highlight an extremely small memory footprint, which was achieved thanks to usage. 

In the book “Introduction to Linear Algebra”, that comes along with this course, the author highlights several times the advantages of finding L (low-triangle matrix) instead of E (elimination matrix). It becomes pretty clear by inspecting the code. 

Let user know that calculation was successful or not Let's check which error can happen in your code: 

First of all, your solution for this task looks pretty elegant, from my point of view. I would just provide minor comments to optimize this code. 

I would suggest to create enumerated list of those errors, return one enum element as output of your function. 

The main improvement which can be done here - not to use Recursion at all. Solution without recursion 

But I did not expect that the difference was going to be so huge. Just as an example, I implemented the Inverse function through finding matrix E and matrix L, and compare performance by BenchmarkDotNet with square random matrices (N = {5, 10, 20, 30, 40, 50}). 

Split complex task on simpler ones - one logic per function Your function ParseInput is doing not just parsing, but also reading from standard input. So split this task - ParseInput will just do parsing. 

You tried to implement a linear (\$\mathcal{O}(n)\$ time) solution, and this is the correct final aim, but, I think, you agree that the current solution is hard to understand especially without any comments. So let's start from something easy-to-understand and not very efficient. But this will allow us to check a correctness of your solution in a first place. Brute-force solution (\$\mathcal{O}(n^2)\$ time) It is clear that this task is related to the maximum subarray problem except the condition of replacing by . So let's make a loop through all positions of the original array; on every iteration let's replace the current element of the array by and find the largest sum by Kadane's algorithm. 

Better to avoid static not-readonly field I don't see any actual reason for you to keep variables Item1, Item2 and OperationString as private static fields - make them as local variables. In general, based on my experience, many nasty bugs (especially in multi-thread applications) happen because of an inappropriate usage of static fields. I know, this problem is far away from this simple calculator application, but anyway. 

Following the 18.06 Linear algebra course, I was curious to reinvent the matrix class and basic functionality, like \$PA=LU \$ decomposition, Gauss elimination, finding inverse matrix etc. Any comments about the code design, linear algebra and performance are welcome. 

I completely agree with you that such tasks is a good opportunity to learn new concepts and the language itself. And, as you asked, I have a few comments on your code 

For sure this task can be solved in \$\mathcal{O}(n)\$ time and \$\mathcal{O}(1)\$ additional memory, but extensive testing should be priority number one. 

Your input data is a boolean matrix, so instead of keeping every value as a byte you can use just one bit. For that purpose you can use bitarray module. 

Be aware of the difference between || and | logic operations And without a need, do no mix up this two operators. So use 

Another point, that you are loading whole matrix to the memory. It can be too expensive in certain circumstances. I can suggest one stream-based solution which will calculate a number of islands in dynamic manner. This method was discussed here. 

I was able to shave some milliseconds off by moving the call inside the calls, which let me get rid of the explicit loop: 

The actual hashing is done in and OpenSSL. Those pretty much cannot be reduced, so at best it could be made ~3 times as fast. 

In python 2 you can remove the invocation. That alone saves a few seconds. A set is faster for testing, so that's also an easy fix. Take advantage of 's and by noticing the length stays constant and you are at 2x the speed: 

First, the obligatory pointer to PEP 8. In particular, your class names and some docstrings do not follow it. Variable names and line lengths arguably as well. Next, a couple of specific cases where you could make the code clearer or more efficient: 

Python 3 introduced a new cleaner format for the common case when you want to step up from the current class and pass (the first argument): 

I also found this PyPy issue that leaves me less confident there's any performance still on the table. 

However, beware. AFAICT, the item could have been deleted by another process in between checking whether it exists and deleting it. You should probably just delete the item and raise an error if that fails. 

At this point you can probably guess that I'll recommend doing away with the list. A generator should work. If on Python 2, is probably better than as well. (Note, I didn't mention . That could be changed into invocations if you are on Python 2, but you seem to be on Python 3.) 

You should define the lower level method instead. will use that to define and that way you are sure to get efficient testing. Speaking of which: 

What's the worst case running time of this? At most \$O(n)\$, since has \$n\$ values and there are no cycles. However, since you are comparing ranks in : 

Two ways to rewrite it: When you know which version of the method you want to call you can name it directly, but in that case need to pass self as an argument: 

Again, I do not think relying on this is a good idea, but it does not seem insecure either. Personally, I would rather make the number of iterations a smoother function of time, i.e. round after the multiply. You still get different iteration counts for different passwords, but you also avoid the abrupt stepping up every two years. Also, you lack any code to upgrade the iteration count of password hashes as time goes by. That should probably happen somewhere in the class, e.g. if the iteration count is less than some fraction of the current. 

Nothing else really. The s at the start of all your strings are a bit ugly, and some people prefer using empty print statements to indicate extra empty lines. 

My recommendation (echoing well known advice) is to use the 32-byte random string directly as an ID (converted to base64 if needed). That gives such a small chance of collisions that you can do away with the loop as well. (It's likelier e.g. that the CPU fails to loop due to cosmic rays than that you see a collision.) 

If "large input" is only up to a couple of GB, there's not much you can do. As long as all the data comfortably fits in memory, the built-in sort is about as good as you can get. If, OTOH, your dataset is large enough to cause swapping and/or not load at all, you could: 

Several people are recommending to remove the final keyword from the private fields. I would strongly recommend against doing that. The whole point of the final keyword is to prevent accidental re-assignments to these fields from other methods in the class (private and public). So, if a Person is immutable, then all the fields in Person should be marked final. I actually have my IDE configured to automatically mark fields private on save. Immutability is a good thing to have unless you really want mutable state. Your builder does not need getters; remove them. I would not inject the builder into the Person constructor and keep the business of building in the builder. Instead inject the individual fields from the build method. This way, you can make the Person constructor public and use it without the builder as well and you stick to the principle that constructors should not do work (other than assigning arguments). Now regarding the getters on Person; if your fields are final, you might as well make them public and skip adding getter methods. Why type when you can just type ? The only reason to have getters at all is that is if you are depending on frameworks that still expect javabeans style getters with the naming conventions and verbose sillyness that comes with that. If that's not the case, don't add them. Some other things I would tweak are moving the Builder.build() method to . This will simplify the business of creating a Person builder and you won't need to type which looks a bit ugly to me. 

There's a lot of stuff to cover here that others have already covered. Here's a few things that stand out to me: Reuse Pattern instances You have a few Pattern.compile calls. You should assign those to some static field and reuse them. Compiling a pattern is more expensive than using the pattern on some string. So compile once and use many times. Patterns are immutable an thread safe once compiled. Circular dependency You have a circular dependency between the FileManager and Genesis. Both seem to need each other. That's a huge design smell (poor cohesion, tight coupling). Break the cycle by refactoring into more cohesive classes. Constructors Your constructors are doing work and creating more objects and having side effects (directory creation). A good practice is to make your classes more testable by not letting them create instances for their own dependencies but instead injecting those via the constructor. You don't have to use a dependency injection framework for this. Simply create all your objects in your main method and provide them to each other via their constructors. Constructors should not do anything else than assigning things to fields. Logging You seem to have implemented your own logging. Probably better to use either java.util.logging or something like slf4j. This is a wheel that does not reinventing. Output You should get rid of the PrintWriter thing, which you rightfully commented is hacky. I'd suggest separating logic and output a bit more by adding abstractions for your input and response and then rendering those in an appropriate way. Essentially this is an event driven system where input events get handled and trigger some output and side effects. Assuming you actually want to do something more interesting than printing things on a console, this will be helpful when adapting e.g. to various chat bot APIs from slack, microsoft, and others. Also it will help making this more testable. 

By default pickle uses an ASCII format, so you shouldn't really open the file in binary mode, although nothing should break if no one touches the file. You could leave out the s from both calls or use binary pickling by passing to . 

Read the input in blocks, which you sort and save into files. Merge the files while iterating by always choosing the extremal item. 

On Python 3 you can encode the letters into bytes and avoid inside the loop, for similar performance. You might still make it about 1.5x as fast if you replaced the -> algorithm with something faster ( and depth first search?), but that's about it. 

You are saving some data that you never use. , never used after this. The whole parameter is unused if you remove the assignment. already is. If you remove from here, you can also remove from . 

Again, you are creating lists which takes time. This whole thing you iterate over could be a constant nested tuple that's only allocated once at the top (or even outside the function). 

In the other place you correctly used . The difference is that executes the given string as an expression, which is seldom what you want (and usually unsafe). 

Now you are walking the path twice, which again may or may not be faster than recursion. You should only need to call this for one of the paths, though. 

By choosing block size close to , you only need to keep about \$\sqrt x\$ items in memory at a time. 

My .NET knowledge is shaky, but as far as I know is allowed to terminate early, at the first unequal element. If that is the case, it allows a timing attack. An online attacker who knows the salt and iteration count could test 256 passwords that give different first bytes in the hash, time which of them returns failure quickest, then move on to the next character. This turns a normally online attack into an effectively offline one. You should use a constant time comparison here. 

Yes, path compression. You descended down two paths from and to and and it took \$O(log\ n)\$. At each step you can point a node to its root, instead of just the next element. You can do this recursively like so: 

You could leave out that second – it will cause an extra unnecessary line break if the name overflows the limit and will not alter normal output in any visible way. Calculating the column width is also independent of the current score, so you could move it out of the loop, breaking the overlong line: 

There's also a question mark I have: – that works in Python 3, but not Python 2, because . Since your code seemed to work for you, I assume you are on Python 3. I'm not sure if Python 3 people think making it portable with a dot/cast is a good idea or not (i.e. ). There's always the explicit if you can't decide. 

Here you could avoid the list creation by using a generator (by changing the to ) or you could use . Probably no difference performance-wise, but the latter is less code. 

Is it an improvement? On the original: I think so. Nested logic is generally more difficult to follow. On the --? Not really, but that's the price to pay for caching the intermediary values.