This makes closed for modification (cannot change price / individual price), but open for extension (can add to price). (Naming and structure in my example could probably be improved, but it serves the purpose) The behavior is still possible to modify, though, so an even better solution would be to have some collection or set of rules you can add to, so you don't accidentaly override without calling . 

As a sidenote, I'd look for another name than "BaseClass". It doesn't say anything about what it does. 

Property will expose the current value on postback by it self. You could also expose an event on your control that you refire in the ValueChanged event of the hidden field. 

instead of duplicating an existing function. ;) (I like linq, but sometimes, what Jeff suggested is actually more readable) But more importantly: I don't see why you should have to dispose model. Do you have unmanaged resources within the model? If so, shouldn't dispose of the unmanaged stuff and return some plain old Clr objects to you as a model? If the model is adapter(s) for SQLDMO or such, could you translate instead of adapting inside ? 

This might be off topic, but if you use switch statements for more complex functionality, you should read this before going further. $URL$ 

More on extensions methods here: $URL$ Inheritance Put these methods in a base class and have the behavior that differs in inherited classes. [edit]Updated to show how the base class can be generic[/edit] 

It is very confusing to set a property just to discover that it returns something else just after you set it. Properties are supposed to keep the value you give them. (At least logically) And since your SkipSomeStuff property is public, you have no guarantee you won't access that property by accident before the intended recipient accesses it, and the stuff isn't skipped after all. How about keeping the skipSomeStuff member, but set it using a method called SkipStuffNextTime() or something like that? Nobody will misunderstand the intent of your code that way, and only the code it's relevant for will access and reset it. 

Here's a C# version using a cross of the template method pattern and the collector pattern. It'll pick up any issues from any derivative implementing the AddValidationIssues method. 

You could possibly swap with . If you can, you should generally try to avoid too many subqueries. At least attempt to indent them properly. You could also benefit from having a look at common table expressions. These can help you group up the subqueries in predefined results for your query. Makes it a lot easier to read. $URL$ 

I just re-read some comments and realize you need paging too. Add a private int page, and a private int pagesize, then add the multiplication of those to foods[i] in CreateButtons, and swap foods.Length with pagesize. You can have as big an array as you want then. 

I would refactor it into a plugin that takes the content as an option. Then you will have two instances of "dialog controllers" each with its own events. Have a look at the "plugin with data" example in the jQuery docs. $URL$ You'd set it up like 

Notice that I replaced your setter with an method. It's ususally good practice not to replace an entire encapsulated collection using a setter. Although you can validate the entries in the setter, a property should not do much logic other than returning or setting privates. If you have a look at the collections in the BCL, they all expose an method and a method to empty the collection. The method also gives you the option of adding multiple sets in turn. If you need different logic when stuff is added etc, have a look at the template method pattern: $URL$ If you need multiple base classes with differing logic, you could combine the inheritance with the extension methods, or another base class. :) 

You should use as predicates on your interface and have the implement that interface. By only using , you won't get translation to L2E etc, but will have to enumerate the entire DB table before you can evaluate the . The interface can be mocked, hence unit-tested without a physical db and also used with other ORMs. It's generally prefered to keep and the in a separate implementation. You can pass the to the repository constructor, which can access an internal property on the UOW exposing the . By doing that you can share the same between repositories, and batch updates to several entity roots of different type. You also keep fewer open connections, which are the most expensive resource you have when it comes to DBs. Not to forget they can share transactions. :) Hence you should not dispose the DbContext in the Repository, the Repository really doesn't need to be disposable at all. But the UnitOfWork / DbContext must be disposed by something. Also, ditch the predicate to . Since you return an , and use an for the predicate, you can keep building the Queryable after the call. For instance . It will still be translated to "select [fields] from [table] where [predicate] order by [orderprop]" when enumerated. Otherwise it looks good. Here's a couple of good examples: $URL$ $URL$ $URL$ And here's how I do it: Model / Common / Business assembly No references but BCL and other possible models (interfaces/dtos) 

always write compound statements instead of single statements after conditions/loops etc. A common mistake is when somebody later wants to add more statements is to forget adding - especially when the code is not your own. 

is the name of the function if you want to use standard C but I understand your compiler has some convenience function. You should also check the return value of ungetch() to see whether it failed or not. It returns EOF when it fails. Code is for programmers to read so there is absolutely no benefit of making terse expressions by ocular optimization, instead let the compiler optimize and focus on writing clear code. Use compound statements instead of single line statements for clarity. 

general impression overall the code looks clean and tidy so it is quite easy to follow some comments/suggestions MISRA and other coding practices recommend to always use compound statements after conditionals to make the code more clear and more foolproof for maintenance 

You should not change the function parameters like you are doing to 's'. If the function becomes a little bit more complex it then becomes very hard to read. Instead create some local variables with descriptive names; trust the compiler to optimize the code for you. 

is not a good name for a function, pick a name along the lines of {verb}{noun} to make it more clear what the function does. 

I am not quite sure what is used for in your it seems to be set to 0 and then passed to and never changes its value. It could be instead declared inside instead of being passed. When you do memset, use sizeof the array instead of some number e.g. 

There are several style guides (e.g. google has one), it is up to you pick one or do your own but there is no universal style guide. Important is just that you are consistent in your code so that you don't use different styles in different files, that is confusing (irritating) I find your code looks fine from the style point of view. Normally one would avoid (if possible) to include the headers like Hangman.h and CharReader.h in your header GameManager. Instead you declare them as pointers in the header and remove the headers. 

sidenote: when you declare functions that do not take parameters, write as argument. In C when you write e.g. it means that the function can take any number of arguments (as opposed to C++). Writing makes it clear it takes no arguments. get_slices There is no reason to declare as static, better to have a local variable that you return. You should also check return values of allocations, they may in some cases return NULL so that must be handled. also again, lose the gotos generally speaking it is good to check arguments to functions so that they are sane. e.g. with asserts 

I would introduce a layer in between your threads and the file. E.g. have a thread that handles all writing to the file, it holds a mutex protected queue which is written by the other two threads. That way you have a layer between the physical file (slow access) and the queue (fast access). You then do not have to lock the file in any way since only the thread that writes the file needs to have access to it. 

Note also that the variables should be initialized in the order they are declared. A tip is also to write Doxygen styled comments (doxygen.org), that way you can get a nicely formatted html document which is generated from your code. A see a direct error also, you have not declared a virtual destructor in Error but you inherit from it, add a virtual dtor to avoid getting base pointer delete issues. 

that way you will be sure it always works even if you change the size of one day. using meaningful variable names and functions would be better, is not very descriptive. To use boolean include instead stdbool.h 

Lot of code but here are some comments. class Card Personally I put private parts of a class at the end of the class, those are implementation details. The public parts OTOH are more important for the user of the class. (IMHO) Use scoped enum for the card suit, as it is now you use char so any char can be accidentally assigned. assignValue assignValue depends on the order of when the member variable m_card was defined, it would be better to make it static and take as argument the card otherwise this can be an error source in the future. A std::map could have been used to hold the values of the cards e.g. map constructor you do not initialize all declared variables, std::string is initialized automatically to empty string but it is good nevertheless to show that you initialize it for clarity. one day you may change the type of the variable and forget to add it to the constructor nameCard you seem to have omitted the King. your switch sets a string for 0-3 but forgetting to call this function will forget to define that variable, you could instead make sure the card has a textual suit by defining it in the constructor same time you assign m_suite. again the mapping from value to some string could be held in a std::map both for suits and for the textual values like "Ace". that would make things like Deck::fillDeck smaller. Deck Use a smart pointer instead of a raw pointer to the cards, that you do not have to worry about memory leaks.