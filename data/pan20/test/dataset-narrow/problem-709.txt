Uh... you seem to be overloading the word "skill". Is a skill one's skill/strength at persuasion, intimidation, stealth and so on, or is a skill the ability to perform a certain action (like "A powerful double attack", dubbed "hack and slash")? Try to use one term per concept, that way when you're talking about skills in your comments I know you're talking about persuasion etc, and when you're talking about abilities you're talking about special moves. 

Bug: leads to you removing the last node. Your solution should have comments: I have NO idea how it works. And that's after reading it a couple times. If this was production code, I'd have wrapped it with unit-tests, thrown the implementation away and rewrote it. 

Fixing bugs creates a new int array with a size of . 's default value is 0. Thus, the entire array will be filled with 0. Given that your innerloop starts at index 0 and sets the "found" index into the array, it's possible it's setting 0 over the default value. That's not so important. What is important is the reverse implication: If the serial array contains a 0 at a given index, you do not know whether this is because no tile-index was found, or because the tile-index that was found was the first one. 

Your example implementation is not good enough. It's not very complicated at all, as you suggest with the title; rather, it is really simple. The abstract class is not needed. There is no reason why a class (like a or something of the sort) should want to extend - something like a might already be extending a or a . You are abusing the is-a relationship. Consider this rewrite of your code: 

Of course, if you look at it now, it seems rather silly to assign to on one line, and then, on the next, to overwrite it without reading the previous value. I'd combine the two... 

If you instead converted the Strings directly after reading, you could do input validation per input ("hey, you entered a 2 for your second binary number!"), and you'd save on doing all this conversion. You'd convert once, do the math, convert back 4 times (4 different results), and done. Something like this: 

The is only used in the function header, to get the group values, and to pass it back in the function. It's also constructed once... Does this alter the group values? 

And these are the writes. Seems like we're only ever accessing and . Do we really need an array, or can we just work with "current" and "previous"? 

There's a full queue already of 15000 mails (remember, threads are allowed to be suspended indefinitely, so I can add 15k mails before the VM starts your thread). First thread is created and run. It increments to 1. We put the limit at 2. It sees there's mail, and currently 1 thread. It adds a new thread and sends a message. The message sending is done, but the other thread hasn't started yet. So we create a new thread. Repeat until we have ~14975 threads. That was a single thread breaking your code - so synchronization is not gonna help. Though whatever you do, you'll want to have synchronization as well. 

You've got properly formatted data, you say? Why not use something like ? Maybe exactly is not the best choice for this, but some sort of function that tries to parse the entire line in one go seems best. Then you instantly have all the variables you need. Failing that, you could always just call multiple times by hand. It's better than using here, because you're not sharing ANY code between iterations. 

Additionally, for any three integers a b c, if a = 0 then a + b > c && a + c > b is false. Because that would imply that b > c and c > b. Thus I'd rename isTriangle to isValidTriangle, opposed to the function I described above. 

If you turn the arrival and departure times into objects that give or to a variable, then sort this array (\$O(n log(n))\$), then you can iterate over the list of events. As a result, you'll have 6 iterations after sorting, and the algorithm will bound on not the length of the durations but the amount of trucks. So read inputs, sort the array, and then... 

It fails this check, but that's not required. As is not overridden, it can't violate that contract. Do not lie in the comments, for it is worse than having no comments at all. 

It's most likely faster (one never knows with micro optimizations when one just looks at the code, profiling works better in these cases). New snippet: 

I'd wrap the in a tag. Maybe you want to add more attributes to spells later. In fact, I'd probably make and . I'm also thinking you might be better off here and there by using some sort of "quantity". Lets say a spell had 10 components (for some arbitrary game design reason)... 

Here you've got a double return at the end of a function. Both cases end with the same line of code. In those cases, you can just move the return out of the if-statement: 

would check if it matches the secret pattern so far. would check if the player had input enough moves so far. is what is now. Your second pass The code you posted was the first pass of the program. The first write, so to say. Well, once you're done with your first write, you should match if each function name does what it says it does and not much else. That's how you could have discovered the turn design too. It's good that you extracted the button, but there's more to extract. Pattern would be the next thing to extract. It can have "matches" and "equals" and "extend" functions. That would help simplify some of the array functions you're using in , and . There might be a third class you can make responsible for handling the blinking animation so that you don't have this graphical logic stuck between your game logic. Lastly, not having an IDE at hand is no excuse for not cleaning the code up later. Just because you're prototyping things doesn't mean you're not allowed to use your tools. Autoformat does wonders, and generating code can help even more. Decluttering main I know from experience that it's best to keep Main.as as clean as you can. That way you can abuse it later if you need to test something, and then delete it without regrets afterwards. Right now there is no such testing place. To declutter main, start by taking a look at its member variables: 

Seemed fine at first, then I took another look... The validation function displays the error message? I'm sorry, but that's indeed a violation of SRP. You'd be better off returning a which you could use. You already HAVE this validation result... so in a way, you've already done what I said. What's wrong is that your function names do not reflect this. You call , but it also displays errors. Rather than changing the validation method to return a (which would imply taking out and doing everything in , you should change the function name instead. 

Your algorithm is selection sort. Selection sort has a time complexity of \$O(n^2)\$. For sorting algorithms, that's pretty slow. Consider looking up a sorting algorithm such as quicksort, which, whilst it does have a worst case performance of \$O(n^2)\$, on average, it tends to take \$O(n log n)\$. Or, as suggested in the comments, make use of the built-in libraries. Use . Use of library code, especially when part of the language that you're programming in, can save significantly on the work you need to do. 

So, we've significantly reduced the length of your code now, it looks a lot more managable. The next step in cleaning complex code like this is identifying subfunctions. And, actually, the area I have been shooting at all this time is a prime candidate for this! Take another look at them. 

If you can change to point to the end of the string by default, then you don't even need to deal with this statement! Making this block as small as the following: 

Always add curly braces for if-else statements! It's just too easy to forget that they're not there and screw something up. 

Your program first says , before complaining about the "[[ ]" not being correctly balanced. Next, your program is hardcoded to check for , and . But what if we wanted to add ? Then you'd have a problem, because you'd need to change the code in a lot of places. My first thought of a solution for this is to use two strings, and then using to see if our token is in the string. It's not the best solution, I think, but it would work pretty well: 

What's that for? On a repaint, you update your model. Why does looking at data change the data? Could use a comment. Or a wrapping function. (I get the feeling it's for centering the hand.) 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

You've named a function in a way that suggests it shouldn't be used, but keep it public then support it via anyway. There's no need to name your functions something different here; Java can do overloading just fine. If you name your function , java knows when it needs to call or . 

The constructor can take an argument. Since you're only going to be adding two integers to the list, you could provide this information and save memory space. 

That way, if you have a coworker who is not so knowledgeable about this sort of data structure, they can use it by reading your documentation, rather than having to figure it out themselves. Failing that, save them a google and put something like "Implements a persistent set via red-black tree, see wikipedia (wikipedia link to persistent sets) (wikipedia link to red-black tree)". It's a half-assed comment, but at least provides a foothold for someone unfamiliar with the topic. (Which, if you haven't guessed, would be me - your class is not making clear to me what a persistent set or red-black tree is and whilst I might not need to know, lack of usage documentation makes me have to need to know in order to be able to use it.) 

Looks like you could benefit from a function that takes an integer as maximum value... and then returns an integer between 0 and max minus 1. Which does exist - you'd simply create a new instance of and then call . 

At this point, you could consider shifting certain parts of the logic towards a function which does simple calculations. Your call. I'd prefer that to this inline logic, because if you use the functions, you can write this function on a different level of abstraction. That is, you can write English code consisting entirely of function calls. At that point, if you made a mistake, you'll spot it instantly. Because if you have a function that looks like this... 

It will throw an exception, but after that you'll be in a dirty state. If you then call again, but without an index, () then you'll get more exceptions for going out of bounds. 

A good list (for shopping list) allows me to check if something is already on there () and allows me to cross items off my list when I have them (, ). 

You check 4 different cases here... but instead of checking if one of them happens to be the case, why not check if it's "not the default"? That is, you define to be an empty String, and then set a value to it if you find a special character coming up. So if is not empty, then it's a special char! And aside from that, don't manipulate to break a loop. Just use for that. 

And gone are most of your troubles. The problem in this case, however, is that you do need to know what type your object has. You cannot "just" insert an object and get a value out. To do so anyway seems to imply bad design. If you wanted to go that direction anyway, consider making a map of Class, Converter of sorts. Something else you could do is leave the method you have right now as is, and just wrap your and conversions in a separate function. That would significantly simplify the method as well, boiling down to "if integer, finetime via integer, if long, finetime via long, if string, finetime via string, if date, finetime via date, else log error and return null". 

By recognizing the statement "If not conditionA or not conditionB, then controlA is false. If controlA is false, then functionB." to be "Only if not conditionA or not conditionB, controlA is false. If controlA is false, then functionB.", it becomes easier to see that there's no need for the control. Only if , controlA. If controlA, functionB. So if , functionB. This simplifying can only be done once you've removed the specifics of the code, as what specific code is executed is too much detail for pruning branches. 

contains the items. So, it's not , it's . By going through your variables and giving them more detailed names, it'll be easier to understand what your code does - both for yourself and for anyone else who has to read it. 

You ought to format your code properly. This is hard to read for me. Here's the recommended formatting: 

Bug: on empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

You create a set, give it a name, but don't do anything with it after the function returns. Do you need to keep a reference to it? 

and . That's all there is to explanation of your code. And it needs more explanation than that. Your function names already explain part of the code, although if you're not familiar with the workings, the difference between , and might not be immediately clear. Your class name is , but internally you're using a "Red-black tree" - again, for someone not familiar with the thing you're talking about, these concepts aren't directly related. You should use comments to explain 

A verb as a variable name seems weird to me. Especially as a boolean. Try to make your booleans adjectives, questions or statements instead. In this case, I'd go for . You'd get an aptly named method from this too, rather than . 

And is true, so application thread 2 will soon be moving into the while loop. Now we've got 2 application threads again! Darn it. So, before we start a new thread, we should make sure that it's actually dead. Now, whilst it is possible to save the running thread, it makes things hard, so lets discard the running thread - wait for it to die first. Looking through the Javadoc of , we can find , which does this: "Waits for this thread to die." Great! 

Consider declaring a variable and using . Strings are immutable, so whatever performance benefit you had with ripping open the , you completely waste it and then some here. You can then put the into a . 

"If a matching object is found with a different reference type its type is changed to if returns true." This sentence is missing a comma. Change to "(...)with a different reference type, its type". "If is null the pool's reference type is used instead." Also missing a comma. Change to "If `referenceType is null, the pool's (...)". At this point I think we can agree that you've written a marvelous piece of code. It's well documented, makes full use of the language's features (loop labels! Last time I saw those is when I was reading the spec for fun!), and doesn't seem to have any obvious flaws. As you can see, none of the things I pointed out relate to the actual code, save for the naming of some functions. The rest is all related to the comments and order of your functions. I'd suggest analyzing the code with various tools such as Sonar and whatever else is out there. I'd also suggest writing a set of unittests if you really wanted to polish it to perfection. 

This will include the name of the argument in the stacktrace and makes debugging just that tiny bit easier. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

Could also be a separate method. If you extract those two sections of code to separate functions, the main sorting function will look like this: 

It's the same... but inverted? I think you'd be better off by having a method which returns a boolean and then calling it from these two functions...