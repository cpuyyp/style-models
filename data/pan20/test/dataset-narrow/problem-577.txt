Not that familiar with C++, but that certainly looks like recursion to me... The variable gcd contains a function, which then calls itself. The very definition of recursion. But I would ask what you gain by not making it a regular function? 

Whether you're solution is over-interfaced or not, depends upon whether the interfaces are used for one of the above reasons -- if not, then you should probably be using the objects directly, instead of using an interface. On a totally unrelated note: you are accessing fields in your datarow by positions. This is a bad idea, as it is fragile -- it's easy to change the position of things and have it appear to continue to work, and only fail on some rare condition. You have properties with declared backing fields, where the backing fields aren't used to do non-standard manipulation. They should be turned into auto properties for smaller code and easier reading. 

Now the 7 lines are 4 lines, and it should also now be obvious that a further reduction can be made -- just do the final 3 lines once, outside of the conditions that determine what to print. Whether you print a newline or not, is unconnected to what you print, there's no reason to combine them. Fixing the above moves it out of the "works but horrible implementation" category. But as a general rule, I dislike mixing output and logic, and to a lesser extent loops and logic. If you extract the logic in the loop out into it's own function, that returns a string, you make it easier to read, maintain and test. 

Whether you should use inheritance (either of a concrete base class, or an abstract class) or not or even whether you need two classes, depends upon a lot of factors, and there's not enough details here to say. But there is an alternative...extension methods on an Interface. They would allow you to have just one concrete implementation, that acted upon both. 

It is then clear that the action is the same. Always try to do as much as possible in the common code, and not duplicate code between branches. 

Your first loop is unnecessary, you add more code, and more complexity, by making it a loop, and remove nothing. A loop where the loop control variable is unused should be suspect. You are repeating yourself, and in the process making your code harder to read. 

What kind of performance are you getting? Is it acceptable. If it's not, then I'd look for changing your algorithm, and not minor tweaks. In particular, I'd look into NOT splitting the string and recalclating each time. Instead keep track of the state (what line and the number of characters on that line, whether it's a paste or a delete), and do the right thing based upon that. Adding an additional character at the end of a 5k block of text, adds one more line at most, if the last line was 1 character long, then unless the key being pressed is the enter key, it doesn't even do that. But before doing anything, sit down and see how well your existing function works, for your typcial data, and then for some extreme data. 

There's a few changes I'd suggest to insert, firstly as the second parameter has to be an array, you can use type hinting to indicate this: 

The first thing that jumps out is all the Strings you have which are reused throughout, those need to be removed and ideally put into constants so you only have to change them in one place if you ever need to rename them: 

You can increase the readability and reduce the number of checks required in your if block by performing each of the four booleans you get at the start, then checking against them instead of performing it over and over as well as separating out the check then reveal logic into its own method, like so: 

Another thing you should be careful about is ing the same thing over and over, as it's usually unnecessary and can be replaced with a which will ensure that it's only loaded if it hasn't been in the current session. 

Which will save you a lot of rewriting if you decide to change the names of any of the properties down the line 

I've been implementing a custom internal server error page in ASP.Net MVC which will check if the current user is either an administrator or accessing the page from localhost, and if so, show them a whole bunch of details about the error to debug it with, otherwise just send them to a basic HTML error page. So far, it works great, but one problem I had was that if there is an error in a partial view on the page, the system gets stuck in a loop trying to report the error. To avoid this, I'm storing a temporary counter of how many times the current action has requested the error page in , but I find the amount of lines and style of the code to get, set and check this variable a bit verbose: 

I would also avoid using regexes or any kind of manual string parsing, you can do it all with and , thusly: 

I don't really like the method of exception pseudo-typing you're doing, I'd use different objects to represent the type of exception rather than the content, like so: 

It all looks good to me, though you can simplify your NodeBase and methods if you use variable properties, like so: 

You do a lot of mapping from parameters to arrays and vice versa, which you could simplify by storing an array of the parameter names and whether or not you want them trimmed, for example: 

Additionally, I'd suggest reading up on your SQL for a start, this whole thing screams out clause. In every case, your database will be more efficient at sorting the results than whatever programming language you're using them in (and certainly PHP). Such as: 

You also haven't got any access modifiers on your methods. As directly prints out a segment of HTML which wouldn't be valid on its own, I'm guessing that it's probably only used once somewhere in your View and as such should be or to prevent misuse. As for the actual code, aside from collapsing some statements there's not much to change. These lines in don't appear to be doing anything though: 

First of all, good job! This is obviously a complex algorithm and it looks like it's working. I'm going to do this incrementally. So I'll save this and keep editing as I go. And since it's so long, I won't get to everything. Plus I don't understand the algorithm too well. First of all, doc strings in Clojure go before the arguments. I used to make this mistake all the time. The reason is that you can have multi-variate functions. 1: 

So, I tried and failed to refactor this myself. But I will give my general feedback. What this function, which is a map of a map of a map of a map, tells me is that there is a failure of abstraction. should be should be a high-level function which should read somewhat like the inner loop of a pseudo-code implementation of Viterbi. This function relies too much on the structure of the data structures involved. Deeply nested structures are common, but a single function that accesses them so deeply is not. A good rule of thumb is at most 1 nested map/reduce within a function. There need to be functions which act as your primitive operations here. I can see that you began writing some near the top. You should continue that trend here. Then your functions would be operating at a certain level and calling functions from the level below. An alternative approach would be to turn the algorithm into a sequential series of steps. This may or may not apply here, but it is hard for me to tell. As an example (not real code!): 

Could this be replaced by using frequencies? 4: Now it's starting to get hairy. I may make some mistakes here, because the code is not factored. 

Again, it's just an example. But the idea is that each function takes the data it needs and creates a new data structure that is the result of that calculation. I don't know if this is possible with this algorithm. But it could be. One hint I can give is that you know you are on the right track when your functions are returning "appropriate" data structures. That is, when the data is a mapping, you return a map. When it's a set, you return a set. Also, the functions don't take much more data than they need to calculate the answer. I suggest you take the iterative algorithm description and work backwards from the final output. Again, nice going. It was a pleasure to go through it. 

This definitely has too many levels of into/reduce. You could do a pattern. Do we need ? And why are we passing in a list when we only need the first? And it's often a good idea to put the driving sequence in the first or last position, so you can do threading. Let's try it this way: 

If you want all your exceptions to follow this style, then you could have one parent Exception class, then make your application exceptions extend it, like so: 

Therefore, I think you need to either increase the number of guesses to 10 (at the least), or chose a smaller set of things to guess, like A-F, 1-6, or something GUI based like Mastermind. 

Additionally, you have made and into optional parameters by making them auto-initialise to empty arrays, however you cannot have an statement without specifying at least one field and value, therefore instead of making them optional array parameters, you should use type hinting to ensure they are arrays, and then check to make sure that the arguments are correct before you send the query off to the server, something like this: 

Then you can have your validation method return a state, and you can do your checking block after, like this: 

I put as a method as it isn't clear whether you're using this design pattern elsewhere, but I assume so as you're connecting to something and there's usually other exceptions that can happen later. If you aren't, you can just stick it back into the catch block of . Additionally, if it isn't clear, the ternary is so you don't have to manually type in the message to attach a cause to an unknown exception being wrapped. And I took the liberty of replacing the generic message "connection" with the stack trace of the exception that caused it being passed to your logger, as this more detailed information will be useful should you wish to debug the cause of it. 

However, when you increase the number of possibilities to 10, and reduce the guesses to 5, you can no longer do this, and the chances of never guessing a correct number increase dramatically, e.g.: 

I have a array and a of a custom object and I'm needing to loop around and perform an operation on both but only as long as one of both is available, the original method is as follows: 

And you can delete the rest of your class. Edit: Using the new method would then allow you to add pieces of text at the specified points in your message, so your validation method that returns a State would use it as follows: 

Obviously the on every iteration is inefficient, however as I need to maintain a counter, an enhanced loop means keeping a separate counter and performing a check on it every time like so (list declaration skipped for space): 

It's secure, but it's really chunky and tedious to write. I'd do this by overriding the magic method to trick GSON into thinking the methods exist, like so: 

Unless I'm missing something, you're ing the entire table over an over, then do exactly the same thing with it every time (except with different HTML class names). If that's the case, you can replace the whole file with this: