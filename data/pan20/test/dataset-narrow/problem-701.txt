Basically that means, you're very inexperienced in java itself and you can't provide an easy and well written solution for a rather easy problem. Why I wouldn't give you the job, if you were a junior with a degree (applies to senior, too): 

What's 0.0005? What's false? PolyPortrayal Is there any reason to use inner classes? draw() Switch statement also works on String (since JDk 1.7 I think) MainAgent Dude, I have to scroll to see all the variables. That type is too long. glances of and checks the scrollbar. It's WAY too long. 

Now what? What can I do with that? Do I need that? Is this ... important? I would have chosen 'getMessageKeyPrefix' or something like that. Why must this be exposed anyway? 

Looks good, except: activateObject/passivateObject method: I don't see any usage of the running variable? Beside that, you don't need to do anything in that method anyway, that will be called, before the object will be returned, I don't think that is needed for a Cipher instance, isn't it? But why I'm actually answering: I'm fairly certain you won't gain any benefit by using a pool for Cipher instances. The management of the pool, the synchronizing, the maintaining of the code and the additional library will use way more ressources. A general rule is, "by definition": More code means less performance. Of course, that's not entirely true - what I want to say: If you want to improve performance, you have to measure, before and after your changes. And not only millis, but also cpu, memory, gc, io and so on. You have to be sure, you're changes actually did make an improvement and not the opposite. Hope that helps,... 

I've reviewed your code and i can comment on some things: I have a similar personal site and I can tell you there is not many things you can really cut in order to make the code more tidy without resorting to frameworks. Inevitably as this is a static website you will have duplication especially if you want to have those auto-prefixes. Colors I would like to criticize the use of colors in your website. In my opinion they look dated. Try to use a lighter blue color in the background or use a flat color scheme from adobe kuler. Links I cannot see any of your links because they have similar color with the background. If you plan ton becoming a great web designer you will have to pay attention to those things as they stand out. Buttons and Animations Don't use those 3d buttons they look horrible. Make them flat or at least with a smooth gradient and shadow and please disable the animations! Fonts Change the font to something more popular from Google fonts and not convert something from Font Squirrel. Also make them slightly bigger in size. Background Add section on the top of the site with a background image of something that you like similar with example some medium blog articles. Make sure its of good resolution and quality. If you can make it static when you scroll even better. Overall Overall I'm sure with a lot of work and passion you will become one great designer. You just have to keep strong attention to detail and make your own statement by showcasing your portfolio. Good luck! 

To be honest, the code is way too chaotic and very hard to understand. Main object oriented principles are not followed, a lot of bad naming, passing around of variables everywhere. Just following the code flow is very hard. The main concerns: SRP The SRP: Single Responsibility Principle. Your does like everything. It's something like . Your types should do one thing. I'd suggest you first start to refactor all the responsibilities into separate types. I mean, you just provided us a list of those responsilities. This, and the passing around of the variables is hurting the most (e.g. the , which is passed from the type to everywhere. I do not accept the "Shutdown hook" argument. Thread management When I see Threads, I'm usually very suspicious - it's a very icky source of bugs. And when I see Threads starting other Threads, which then start other Threads again... well, actually, I have never seen that. If a bug occurs: Good luck, or better: good night. First of all, I don't see any reason, why should be a Thread? Shouldn't it be possible to start the app twice with a different ? As long as you don't need to tail dozens of files, I wouldn't implement this type as . Why does need to be a ? If the file is "rolled over", the actual thread is done anyway? Even if not, e.g. the new file has to be processed, too, I'd just "read the rest". Performance A priori: If you want to improve "performance" (whatever that exactly is!), you have to measure. HDD Quote: 300000 lines per 8876 My test file is 100MB's with 1'024'000 lines (100 chars length). I read it completely in 186ms with a and 8192 buffer size. To count the lines, using a , it takes 281ms. And that's on a ~3 year old fair SSD. I wouldn't care about read speed from the disk, so that's why I would get rid of all the Threads you are using for accessing the file system. As long as you do not read with some stupid buffer sizes, reading will always be faster than writing anyway. I'm also fairly certain, that the removal of those Threads will improve the throughput, because thread management is not free. In general, I usually say: Adding more code and complexity will reduce performance - which of course, is not entirely true, but I try to avoid doing performance-improvements, as long as a certain part of the code is not a problem (which reading from a file is not). Logging Configure your logging correspondingly. Check your Logging API's performance guide. RabinKarp When I call the search method 10'000 times, I got ~9 millis, using indexOf, I got ~1ms. Again: This type has added complexity, without being a problem and without measurement. HTTP Your main bottleneck will be the http processing. If you can avoid it, avoid it. If you can reduce the amount of requests (called remote calls in general), reduce it. It - mainly the latency and the performance of the backend system - is usually the only component, which you can not influence. 

I'm going to post a slightly different opinion; the previous answer is perfectly sensible but they aren't the changes I'd make. 

You will also have to write some 10-20 lines of boilerplate to get ANTLR to lex and parse the text, then run your listener over it. The two big wins in this approach are that you get to specify your language in EBNF (or an ASCII version of it), and you don't have to write the branching logic yourself. This makes the listener and grammar vastly easier to read and reason about (and have interns/newbies modify) than hand-written parsers. Another cool win is that ANTLR does a reasonable job at best-effort recovery. You can configure it to act differently, but by default it will coalesce the tree to a close legal approximation, and give you warnings (rather annoyingly pushed to std-err by default) when it does. then the nasty bit: you'd have to modify your build system to tolerate the generated code that comes out of your parser generator. The tools for doing this are reasonable on the java side (ant, gradle, and maven tasks all ready to go), but I don't know how they are in .net land. Further, for your situation, this is a pretty heavy-handed measure. If you can get away with writing your parser by hand and never touching it again, doing that is the best option. If you find yourself going back to that parser time and time again I would urge you to consider a solution involving a parser generator. 

Expand what to include what? Why does the "Envelope MBR" - which you got from roads - must be expanded with "world.getMBR()"? 

The code looks very nice! However, here my small complaints: Tests The tests are good, but you're testing the implicitly, when you test the . The itself does only the following things: stream, filter with the given predicate, and count. The static methods im should be tested separately, as should the logic of the . The problem is, if the test fails, you don't know if the problem is the or the . The more "implicit" things you test, the harder is it to find the bug. You're testing with too many values. The logic itself should be the same with two values (one is a palindrome, one is not) as with four values (two palindromes, two not). If the behaviour for two or four values is different, then it's two different test cases. The lists to count/filter can have a better name. To make a test case more readable, it's usually split in the three blocks given/when/then, separated by an empty line. Setup the test data / perform the action / assertion. Also, I recommend, but that's personal preference, to static import static methods, at least the assertion methods, so it looks a bit more clean. What's missing (at least what I couldn't find): 

one simple rule to follow is: Do not nest selectors more than three levels deep! Otherwise you will have to much specificity and your rules will be too much coupled with the DOM. Plus no reusability having such a long class names. I would't be bothered to type for example: You want a simple life for you and your fellow colleagues you are going to use your components. Try to use small reusable classes to apply effects and have a simple convention for names. 

You can also consider using generators which are slightly more slower that the iterating method but have less memory requirements. Here is an example: 

I've reviewed your code and I can make the following remarks: While I like the BEM methodology, its not a panacea especially following it to the letter. You must seek simplicity to your code even if that means not following some rules but compiling an pragmatic view of your problem. In that case you should not add classes if you do not have use cases or rules to apply. Your HTML can be simplified to: 

Note how the code speaks of its self and it doesn't have to exaggerate. Every name has a meaning with the right intent. A makes matchers and an returns a boolean by accepting a query and checking if its matches the query. Inside the we simply chain over the query and validate that either every query parameter matches the object or in case of a mismatch we return false and that's it. My point is that you should always have a birds eye view of your code and try to think of ways to make your work easier to handle. Search for alternatives and don't fall into the rabbit hole of applying things that they don't fit accurately. There is always a simpler method to do your job. Good luck with your FP endeavors. 

I also prefer a verb in my method names (they should have, actally, but in that case I think it's okayish), that's why I use 'with' as prefix; And I explicitly do not use not 'set' as prefix, to distinguish it from the setter of the User type. If you do it like that, the 'actual building' of the user is within the builder and not in the User - and the User type is kept quite stupid. It might seem a bit strange, that the 'build' method doesn't actually build, but non-persistent built types are often only used for unit testing. The sweet part about builders, you can expand them to persist your built types or other fancy requirements. 

Dude... where to start. I even have a hard time to somehow group the issues. I'll just go line by line, I guess... oh and disclaimer: If sarcasm is found, keep it. And this will be kind of a code review I'd give my co workers. Welcome to the real world, I guess. MK_7 Quite bad naming all over the code. What is supposed to mean? Seventh level of Mushroom Kingdom? Quite a fancy easter egg, but keep those for a start up, not while doing your PhD, man. Comments This is the worst: 

Other than that, the code is quite straightforward, the "stuff, which has to be done" is separated into subroutines. 

Note however that this should really only be used for instructional purposes, there are plenty of libraries out there that have built-in observer pattern implementations, not the least of which is guava. You're likely much better off using one of those libraries than suffering from the inner-platform effect. 

I don't know how much advantage there is to a unified 2-method interface, at least as anything other than an implementation detail. You might consider dropping that interface in favor of and (and possibly ). You might also use a sealed class to implement your point observer, rather than an interface. 

as an ANTLR fan, and assuming you dont have a raging hatred for auto-generated code, I'd be remiss if parser generators didn't get mentioned here. With a parser generator, you'd specify your desired syntax in a grammar file and the interpreter in a listener (or 'walker' or 'visitor') C# file. 

Even if you address my concerns, I'm no cryptologist, so I would be very surprised if we can come up with a robust crypto system on this forum. I would strongly encourage you to look into one of the many libraries that provide the AES or a modern stream cypher like Spritz or HC-128 if performance is a constraint. 

I'd encourage you to use the operator instead of . The reason being it gives you a kind of duck-typing with collections: your code (at a source compatibility layer) stops caring about the specific implementation of the add like thing, and instead asks if the type implements a fairly common operator. The single most obvious advantage here is that it allows you to switch from to completely without (source-compatability) issue. 

My two cents Abstraction / inherticance I always try to avoid abstraction and inheritance. In general, it's really hard, to achieve a high cohesion when working with abstraction, because it's very tempting to mix abstraction and implementation. Beside that, it's not possible to (unit) test abstraction without implementation, the other way round, often you will test abstraction/logic from the super class implicitly when testing implementation. Also: The more inheritance is present, the more complex it gets - if you pass another parameter in the constructor in the base class, have fun changing all your subclasses. Some subclasses override methods, some don't, some call abstract methods, some don't. A very confusing part of your code is: A Player is a hand. The Dealer is a hand. They both should have a Hand, don't they? overcomplicating things I don't see any need for your interfaces, for instances the and interfaces - nowhere in the code you declare anything as one of those types. If anyone teached you, to make your application "future proof", by this sort of "over-engineering", don't listen to him: in most of the cases, it's not needed. I used to do that, too, but I just ended up with way too much unnecessary and harder to maintain code. Or sometimes even worse, what I thought, what will help in the future, had to be dismantled, because, well, I ain't no fortune teller and the requirements went the complete opposite way. separation of concerns A class should do one thing, also called single responsibility principle. Your class is a , does calculate the score, prints the status and does some initialization. Since a Dealer should not be a Hand anyway and should be a state of the Dealer, some responsibilites will be moved to the correct place. Printing/displaying objects is something I see often at the wrong place. Objects shouldn't display itself, there should be a separate type which does that job. Other things Noone seems to call ? I only find it in the interface and in the implementation. And I think there's other unused methods, too. The IDE should usually show unused code, if not, try to figure out how to activate that. Dead code is something like a deadly sin. Also: Sometimes you work with arrays, sometimes with Lists, I think you don't need to work with arrays. 

This looks too esoteric and I had to search for the documentation for both and and after that I had to run your code to the browser with breakpoints to understand the internals etc. At some point I stopped because I thought it took me enough time already and its not worth it. Its clearly too complicated to read and to understand, not only now but also in 2 years time when you revisit your code and think what exactly did you meant to do. My point is that in the current state is un-maintainable. Anyway here is my take on this: 

I have reviewed your code and I can make the following remarks: FP concepts I understand that you want to solve the issue of matching objects to queries. If you pass an object and a query you should be able to check if the query satisfies all parts or no. However to be honest with you you try too much in the wrong direction. All that , , etc are very interesting and useful but in the average programmer they don't really mean anything for the problem you are trying to tackle. For example I was able to rewrite the code using lodash chain in 5 minutes and with better readability. I will post my code at the end but before that I'll comment a few things: : Why the name matcher? What does it matches? An object, an array? I think its too generic and confusing. And why does it accepts 2 parameters? Ideally it should accept only one at the time.It should have been like and now you would have more flexibility with naming.