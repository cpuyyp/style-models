On the draw call, a object is created/cleared. During the tile draw loop, each tile is checked to see if it has any Lights associated with it. If it does, the objects are appended to the . The tiles are drawn onto their own . After the tile loop, the list of s is iterated through and drawn on their own using a texture I made that looks like this: (Note: I used the R, G and B values here but you should probably use the alpha channel in your actual texture.) Using a custom shader, I render the tile surface to the screen and pass in the lighting surface as a parameter which gets sampled for the "darkness" value at each pixel. 

That's the basics of how it works. Let me know if you have any questions. On a side note, I have a more in-depth explanation on my blog relating specifically to checking the different states (Up, Click, Hold, Release) using the mouse if you're interested. 

You could take that larger image and then generate some more noise on top of it but (and I'm not sure if this is possible) focused towards the middle (so the edges stay the same). It could add the extra bit of difference that would make your brain think it's not just mirror images. (I'm also not sure if this is possible) You could try fiddling with the inputs to the noise function to generate the initial image differently. You'd have to do this by trial and error, but look for features that draw your eye when you tile/mirror it and then try and get it not to generate those. 

Where is the root directory to load content from. Keep in mind that when the variable is disposed, so are all the resources associated with it (ie. anything you loaded), so you want to keep it in scope until you're done with the resources it loaded. 

My recommendation is to use a custom binary file format. With my game, I just have a method which goes through and saves each field using a . This also allows you to choose to compress it if you want and gives you more control over file size. i.e. Save a instead of an if you know it's not going to be larger than 32767. In a large loop, saving something as a instead of an can mean a lot smaller file size. Also, if you go this route, I recommend your first variable in the file be a version number. Consider for example, a map class (very simplified): 

The reason it's expanding in both directions is because you're setting the origin as the centre point of the texture (). When you increase or decrease the size of the texture being drawn, it's still drawn in the same spot, it's just smaller in general. If you want to shorten it based on the destination (or source) rectangle, you should set the origin to the bottom-centre (). Then, the position you draw it at will just be the front of your ship. Let me know if this is not clear and I'll make a diagram. 

What you need to do is check if this is the FIRST time the key has been pressed. Remember that the game updates 60 times per second (that's about once every 16.6ms!), so when you press the button, it's unlikely you're going to have it held down only for 1 frame. The way you get around this is to keep the previous keyboard state as well as the current keyboard state. You then compare them to see if this is the first frame the key has been pressed and execute your code only if that is true. So, at the top of the class, add these two field variables: 

I think the reason your sprite is shaking is because you're moving it back from the object based on . I'm assuming that when you press or hold the movement, it sets the velocity. If this is true, then I think what's happening is: 

is the clipping rectangle to use. I pulled this from my textbox UI class which is where that and basically all other variables comes from. is just a rectangle that is a few pixels larger than so that when the background is drawn over top of it, it will appear as the border for the box. Pretty simple. 

Ok, after about two hours of tinkering I managed to do this but it requires adding some extra bodies. You'll probably want to extract this stuff into a method/class but the basic idea is this: 

Attach each holder to the "mainHolder" using a . This will prevent them from moving away from one another. The on the mainHolder prevents them from rotating. I don't know if there's a bug in farseer but if you add a and both bodies have , the joint doesn't work properly. This is why only the main holder has . 

Hence, your player would appear to bounce back and forth. So, what you need to do is make the player go backwards to the point where they are resting against the obstacle instead of the full velocity. Then, ensure that when they have the button pressed down, the velocity doesn't get set if they are against something or it doesn't get set if there is an obstacle within the initial movement range (i.e. ). 

(Easiest) You can just play a sound and indicate that the position they chose is invalid and they need to choose another option. Use a search algorithm to find an open tile. However, I think there should be limits on how you use this. Take, for example, a situation where they click on the left side of the map and the only open spot is far on the right side. Your search algorithm finds that open spot and places the other warp there. This does not seem very intuitive and may be frustrating. My suggestion in this case (assuming you don't want to do #1 which is my main suggestion), is to only search the tiles around the current tile (perhaps in a n-tile radius). This way the warp gate won't appear too far from where you clicked. To do a search like this (assuming a 1-tile radius), you just need to call the function above on the eight tiles around the current one (assuming the current one wasn't available). You could do this in a loop or, again, with if statements. 

Note: I happened upon this because "Community" bumped it and I see that my comment was helpful so I figured I'd post it as an answer. 

You want to look into steering behavious. So that, rather than following points, the AI sees the track and the other cars on it and drives itself based on the information. The site I linked above is a great resource for information and examples. You might want to check out OpenSteer, a C++ library developed by same author. There's a C# version too if you're using that: OpenSteerDotNet That should get you started. If you build and open the OpenSteer demo application (in C++, not sure about .Net), there's a example that shows a car navigating through a path by using... I guess you could call them "feelers." Basically, it has about 10 parallel lines come from the front of the car and are about 3 or 4 times the length of the car. The lines represent the path that the car will travel and can curve if the car is turning. If these lines hit something, the car knows there's something in it's path and it steers in such a way that it will miss it. There's another version that just uses a simple rectangle in front of the car, but it's not as robust as the lines. Here's an image of what I'm describing: 

You'll pass this to the spritebatch to tell it to use the . Then, your Draw method would go something like this: 

If all you want to do is ensure that the clicked on tile has open tiles around it, I would just create a function that checks the tiles around it. And then call that on the clicked tile. You could set it up in a (nested) loop or just create if statements for it. So, in pseudo-code: 

Based on your sample image, I would say that you have to imagine the wall stopping the light. So on the tile for the wall, it would be lit, but past it (moving away from the light source) the light would not continue. In your example, the top tile of the emitted light (2 squares up from the source) would be dark but the wall tiles would stay the same. Now, that said, if you have different layers, you may want light from a higher layer to transfer down a wall to a lower layer. But that depends on what you want and what looks good. Edit I guess the idea is, imagine yourself in that room, with that light source. What would happen when the light hit the wall? It would stop at the wall, right? Also, if you want to go wider with the emitted light, try and imagine the shadow it would cast as it passed the right and left edges of the wall. It would go off on an angle from there so maybe on the tiles that it crosses, you'd have partially lit tiles there. Something you may also want to consider, if you haven't already, is that if emitted light overlaps, you may want it to get brighter. In that case, you'd want the light effect to be additive (i.e. the "light value" for a tile from one light source is ADDed to the "light value" on the same tile from the other light sources).