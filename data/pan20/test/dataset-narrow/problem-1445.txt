Try the following method which relies on XNA's built in Math API to intersect a and a and get back the point of intersection: 

Calculate global transform by multiplying the local transform by the parent's global transform. Adapt the global transform to and render the current sprite. Render all children passing them the current global transform as parameter. 

The Factory Method takes care of instantiating the components knowing only their names. Similar to what you already seem to have but with a string key. Reflection would then be used to access the component's properties by name and set their initial values. IIRC, relevant methods are , , . 

I'm not sure but I think XNA's Matrix.CreateShadow could be leveraged to simplify the first step. Once again, example: 

Short Answer Try to use the same block as much as possible in order to maximize the amount of sprites that are batched and reduce the actual number of Draw calls made to the graphics device. In general, you only really need to use a different block when you want to change some of the parameters to . 

I could not figure out exactly where the code is failing, but I've noticed several things that you might want to change nonetheless. 1) The multiplication by the parent transform should be recursive all the way to the root I recommend for instance using a recursive property such as: 

Next we need an utility method to call an event by name. This is where the reflection comes in. Once again I'll assume that there are no parameters to the events, and I'll place the method in the same class that stores the events: 

And finally iterate over the array again and write each character to the console, with a linebreak at the end of each row. 

In particular, I'd like to know how to get a set of audio samples that are compatible with the XNA's Sound API classes, such as the class. I've used the class for synthesizer work in XNA before. But now instead of synthesizing my sounds, I'd like to read audio samples directly out of audio files - basically I want to do my own mixing and sequencing of samples into a single object. I've had subtle timing problems when trying to do sequencing on XNA before using regular timers and calls, so I need more control. Clearly, XNA already knows how to load sounds, for instance, using the content pipeline and the class. Is the underlying format used by the class the same as the one used by the class - signed 16 bit interleaved PCM? In short, how do I reach the point where I can play an audio file using the class? 

All of my quads appear correctly textured on the Unity3D editor, a Motorola Xoom Android tablet, and on an iPad 2: 

Concept To me it looks like a 2D Skeletal Animation system. In other words, animations are constructed out of smaller pieces, which are transformed and put together to create each frame of the animation. Optionally, there may even be a bone hierarchy (i.e. a skeleton) in place, so that for instance, arms will be attached to the torso and moved automatically whenever the torso moves, etc. That's not strictly necessary though, since it's possible to just place each of the pieces manually, at the root level. That's the equivalent of having only one bone in the system. It's a bit outdated by now, but James Silva (who created The Dishwasher: Dead Samurai for XBox Live Arcade) wrote a XNA book where he goes into great detail on this topic, even providing a full implementation. And here's a few other links that might also be relevant: this and this. Very Basic Implementation Here's an example (with C# syntax but a bit as pseudocode) of how to implement the most basic system of this type: 

The best part is that there's no need for any pixel shader code - colors are automatically interpolated between vertices thanks to gouraud shading. This is the only solution I could come up with, but I'd be interested to know of a more proper way to solve the problem too. 

Note however that the transformation matrix is relative to the world origin not the sprite's origin, so it might need some tweaking to get the result in the correct position. 

And as you go over each tile in the board, you'll register it on the dictionary doing something similar to: 

You're talking about the cylinder going through a mesh. But your picture shows a much simpler scenario where you're projecting into simple quad. So the main question is, can you represent your surface with a plane? If that's the case, then I think you may be able to work with a shadow matrix to achieve this. A shadow matrix is one that typically takes a ground plane and a light position and projects any geometry that you render into the ground plane, from the point of view of the light. It was normally used in conjunction with a stencil buffer to render planar shadows of objects, but it should also work in your case, since it's going to project your mesh into the plane. I found the following OpenGL implementation here which I have not tested: 

Notice that I also changed from using a multi-dimensional array () to a jagged array () in order to be able to pass each row as an individual array to (to the version that takes an array of chars). 

For repetition instead of setting your vertical texture coordinate from [0 to 1], set it from [0 to N] where N is the number of times you'd like the texture to repeat. Adjust this value depending on how tall your quad is in comparison to your texture height. For scrolling I'd simply scroll the vertical texture coordinate, so that instead of ranging from [0 to N] it would range from [inc to N+inc] with the value of inc being incremented or decrement each frame. From time to time I'd wrap inc back to the origin in order to prevent overflow/underflow. 

That the rotation is centered around one of the card's bottom corners (or near the corner) should be evident from looking at it: 

Short Answer SRT is the usual order for a world matrix. The camera uses a view matrix which works by taking the entire world and transforming it in the opposite direction from where the camera is located. Since this opperation is the opposite of a world matrix, the multiplication order needs to be reversed as well as its arguments. Long Answer The SRT order mentioned in the books is the correct order to create a transformation matrix to position an object in the world, or in other words, a world matrix. Your 2D camera class on the other hand, is creating a view matrix which works almost in the opposite way. To be more specific, it moves the entire world in the opposite direction as the camera, giving the illusion that the camera is the new origin of the world. So for instance, if you have a camera that's positioned at (50, 0) and rotated 45ยบ to the right, the way to simulate that is to perform the inverse transformation on the world, i.e. translate everything in the world by (-50, 0) so that the camera becomes positioned at (0,0) and then rotate it 45ยบ to the left to give the illusion that the camera is rotated to the right. The conclusion is, since you're performing the inverse operation as a world matrix, the multiplication order needs to be reversed too. With Pictures Not sure if it helps, but I tried making a few pictures to demonstrate why order matters, and why there's a correct order (they didn't turn out too well though..). First for world matrices. Imagine a square object located at (50,0), rotated 45 degrees to the left, and double its normal size. Since transformations are always relative to the origin the image below should make it clear why SRT gives the correct results, while TRS does not. 

And here's an example of how to use it. Notice both sprites are being drawn exactly with the same parameters (except for the color): 

Use a physics engine such as Farseer or Box2D to handle both collision detection and collision response between physics bodies that are good representations of your sprite's bounds. These bodies could be simple oriented bounding boxes or some other shape if more appropriate. Good for when the collision geometry should be fairly similar to the sprite's look. Similar to number 1 but handling collision detections yourself using an OBB-OBB intersection test between your sprite's bounds. See the Separating Axis Theorem for one common way to implement this sort of intersection. That's only valid if you want to use the sprite's bounds as the collision geometry though. If you wanted you could also add an additional pixel perfect collision test after step 2 by checking the opacity of the pixels on the sprites against each others. For this you'd need to transform pixels into the same space first. But I wouldn't really recommend doing this, and would go with one of the other alternatives instead. If on the other hand you need different collision shapes than the sprite's bounds then I think your idea was right on track. So what I'd suggest in that case is to add a new layer on Gleed2D just for collision geometry, and draw it using the tool. I actually do something similar to this on my graphic adventure game engine, although I use my own editor for creating the geometry. Here's a video of how it behaves. You could always add this functionality outside of Gleed2D if needed, and it's pretty easy to do using the Clipper library as I did on the video above. 

I don't know what's the problem with your implementation, but I have used the method below (taken directly from this sample) on a raytracer and it worked correctly and performed well too. So you might consider swapping to this implementation: 

2) Selecting Nodes Then you need a way to go through each of the polygon's vertices and decide whether they should be nodes in the visibility graph. The criteria for that is concave vertices in the outline and convex vertices in the holes. I use a function like this: 

There's an article on Game Programming Gems 7 called For Bees and Gamers: How to Handle Hexagonal Tiles which would be exactly what you need. Unfortunately I don't have my copy of the book with me at the moment, otherwise I could have described it a little. 

Implementation 1) Representation About implementing this, first you need to have a way to represent a polygon for your floor. The following class should be enough: 

What I'm doing here is checking if the direction before the move, and the direction after the move are opposite. I do this by checking if the dot product between both directions is close to -1 using an epsilon comparison. Another solution that seems to work is replacing the same check by: 

Linear Algebra Library Although you can do all the calculations without using matrices, using them makes everything significantly easier. For starters, if you don't want to implement matrices and vectors yourself, I've successfully used the following library before: Sylvester - Vector and Matrix Math for Javascript You can just copy and paste the packed version of the library at the top of your code - it's a one liner. If after this you still intend to do this without matrices, the process is pretty much the same as I'm going to show, but you'll have to unroll all of the matrices multiplications yourself into their own separate expressions, and run them separately. Example As for an example of how to use it, I've digged up some old code of mine which you can try below: $URL$ I'm not sure how much that will be helpful to you though. The code is a mess - it was done many years ago when I was just starting to learn about 3D, and it was pretty much just me messing around trying to get some 3D image rendered from scratch. Also, I didn't even know Javascript, so I was just making it up as I progressed, so disregard anything that looks wrong language wise. More Info The most relevant is the way I calculate the world matrix that is rotating the object: 

But since you asked if it was possible to write something like here's an extra trick. If instead of passing it an enumeration you don't mind passing it the name of the button, then it is possible using a little bit of reflection and an extension method. Just add this class to your project and you're good to go: 

You're trying to choose a language just based on the popularity of some titles that have been made with them? Sure, Minecraft was made in Java. Well, Terraria (over one million copies sold), Bastion (a gazillion awards last year), and Magicka among others, were made in C#. Does it matter? I really don't think so. Furthermore if you already have a few years of experience with C#, I don't see any advantages in changing over to Java. And by the way, if you decide to use C# and want to take advantage of modern hardware features, you could look into using something like SharpDX for instance. Otherwise, use XNA or keep a close eye on the ANX framework which is currently under development.