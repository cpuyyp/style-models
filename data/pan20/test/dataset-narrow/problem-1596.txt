Update: In Linux, mounting something works a little bit different from what is happening on Windows systems - at least from a user's perspective. The mount location (in your case ) is a directory (aka folder) like any other (e.g. or or ). Whenever you mount a device, the device's file system becomes inserted into that directory - and whenever you unmount said device, the (empty) directory stays behind. You can allways remount it to that location again - provided, the directory is still empty (meaning nothing inside and nothing mounted to it). 

No. The Raspberry Pi is powered at 5 V. Using it as a power source for a heating element with 1.8 kW would require it to cope with a current of about 360 A - about the 110-fold of what is advisable and definitely in the range of the impossible. The only way to do this would be to have a power source which is being controlled (but not powered) by the Raspberry Pi. However, I would strongly advise to start with something more simple. 1.8 kW is a lot of power - you could easily burn down your house or inflict serious (possibly lethal) damage on people. On top of that, no insurance would cover that.. 

to unmount a USB drive. In python, you could insert that command into the os.system()-method. The easiest - though not most elegant way - to include that into your python script would be to mount the drive as first command in your while-loop and to unmount it as the last command in your while-loop: 

If I understand it correctly, your PWM-frequency is 100Hz and your duty cycle is 20%. This would mean, that your LED is on for 1s/100*0.2 = 2ms and off for about 1s/100*0.8 = 8ms (and so on). Are you sure you can see that? Maybe you should start with 

After connecting the hardware components, one needs to set up a communication inferace between the MCP79410 and the RPi via I2C (can be activated via sudo raspi-config and therein "7 Advanced Options" -> "A7 I2C" -> "Yes" ). To do so, one should check their availability first: or, for older RPis, should return 

from . Before the next step, one should make sure, one's system time is accurate (e.g. by comparing it to a radio controlled clock nearby). Now, one sends one's current system time to the RTC using the command 

The default state of pins is given in $URL$ The default Device Tree settings configure most pins as inputs, some with pullup others with pulldown. Pins set as input cannot be said to "have a voltage", except for the high value pullup resistors they are in a high impedance state. Any voltage you measure is a artefact, and depends as much on the measurement circuit as the state of the pin. If you want to change the pullup on a input pin you would do something like Incidentally DO NOT use constructs like - You are NOT setting the pin to False, use or (or constants like ) which will make your code easier for you, and others, to read. 

You can manually add the user to , but this is only part of the story. If you want the user to have the same privileges you should set the groups. The user is normally a member of This can be done with the following command (replace username with the actual name). 

If you have halted the Pi it will "reset", and thus reboot. I would suggest you refrain from connecting them on a running Pi, as this risks SD corruption. 

Your Pi are running different releases. is no longer available and not supported (apart from possible security updates). It is not possible to update from to . You have to do a clean install, although you could just duplicate your SD Card. 

You state "5V pin to power the relay module". I assume this means the 5v from the Pi is driving the relay. What current does it draw? It is not a good idea to power any inductive load from the same power as the CPU. You should take measures to reduce interference. Decoupling and shielding or twisted pair and good layout helps. You will find other posts discussing this. As others have suggested a pullup should be used to reduce susceptibility to interference. The lower the better. Even 1kΩ will only draw 3 mA. The Pi's inputs are incredibly sensitive to interference, more so if used as interrupts. 

I have not actually used Berryboot, although I did look at its internals. Berryboot requires specially prepared images, and AFAIK all images share boot files, so they are required to be built using the same kernel. NOOBS operates differently, each image has its own boot sector, so they can operate independently. Again you seem to be limited in the OS supported. PINN is a fork of NOOBS, and seems a bit more flexible. The above does not actually answer your question, but in conjunction with goldilocks answer should give you some help if you want to experiment. 

If you installed Raspbian via NOOBs you can access the NOOBs menue by holding the shift-key during start-up. In the menue, click on the -button in the top of the window. Select the -tab and add an separated by a space to the end of the line. After exiting NOOBs, your Raspberry should boot into an emergency-terminal from which you'd be able to change any script. 

Well, I had the same problem and had to find out that this question is a rather hard one. This blog entry introducing the official 7" RPi display explains some of the most important keywords involved (HDMI, DPI DSI, DBI). If your display needs to be a touch screen, than the first important aspect is, that (from my research) only displays connected via the DSI-port (J4) or GPIO will not need an additional data connection for relaying the touch input. If your display is connected via HDMI, then an additional connection (usually via USB) is needed (and will have to access the USB ports from outside if you do not want to solder around - this might conflict with your casing). You should be able to get this information easily. The next important aspect is, that displays using the GPIO ports usually need special drivers (either to be installed on a standard raspbian or delivered with a non-standard raspbian provided by the manufacturer of said display). This complicated things enormously, as those drivers might be documented badly or outdate fast - even the next update of your OS might render them useless - not to speak of difficulties using OSes that there is no driver for. You should be able to find the drivers and some customer feedback online. If you can't find the (correct) drivers or some support easily, then you will most likely have troubles using the displays once you bought them. Furthermore, displays using the GPIO ports usually need to provide an additional GPIO breakout in order for you to be able to use some of the GPIO ports for something else. This information should be obtainable by looking at pictures of the displays (is there a GPIO "outlet" somewhere on the screens backside?). TFT, LCD (or maybe even LED, oLED) are different technologies for displaying stuff. Although they determine the optical quality and power consumption, I personally would not worry about those too much. More important - at least in my opinion - is the touch technology, meaning resistive or capacitive. The former should be used with a stylus and usually can't take gestures ("multi-touch"), the latter is what modern smart phones use. And lastly, regarding compatibility with RPi3 (as opposed to RPi B+ for example), DSI and HDMI should always be fine and regarding GPIO I would go with the manufacturers information (as they are the ones, who provide the firmware/drivers). Hardwarewise, there shouldn't be a problem. To become a little bit more specific, the only DSI screen I found, was the official 7" one. It will work without any alteration to Raspbian (I don't know about other OSes). There are quite a lot of GPIO screens of which I would use the ones by known manufacturers sold through major outlets in order to avoid being stuck with bricks (At my department, we have several displays we can't use anymore, because they are cheap knock-offs whose firmware is nowhere to be found anymore.). And regarding HDMI: As HDMI as well as the touch device (whose information are being transmitted by USB) are standardized, there should not be a problem regarding any of the major OSes. I hope this answers most of question. If not, just clarify your question in the comments. 

"current is being lost" indicates a poor understanding of circuit theory. Current flows through the whole circuit, it cannot be lost. Your problem is high resistance in the cable i.e. voltage drop, and unfortunately there is no simple fix. You could use heavier gauge cables, but these would have to be impractically large (and expensive). It doesn't make any difference how many pins you use on the Pi. Whatever you do DON"T apply power to 3.3V pins, the Foundation warns "Under no circumstances should a power source be connected to the 3.3V pins." See Raspberry Pi Power Limitations Running 2 switch mode power supplies in parallel is not recommended, and the results unpredictable. You should independently power each Pi (ensuring the earths are connected), although if the only connection is through Ethernet this is unecessary. 

NOOBS is designed to be a "simple" installer, and requires a keyboard and screen. (It is possible to bypass this, but the steps involved are highly complex.) is disabled by default. It is possible to make it work in Raspbian by including a file on the boot partition, but AFAIK this can't be done with NOOBS. The only viable alternative is to use a serial console. 

Most of the pins are configured as inputs. This is normal, and usually the safest option. All of these inputs are put into a defined state with either a pullup or pulldown. The normal values are shown in $URL$ These are quite high impedance ~50kΩ. The only pins set as output are those specifically configured as such e.g. TxD. Inputs can also have their pull changed in Device Tree. When you connect external circuitry to the Pi any pins on a well designed board which are being used as inputs should normally have a pullup or pulldown, however if the Pi has a pullup and the external circuit has a pulldown, the state will depend on the actual resistors used. 

includes predictable network interface names which have been used in other distributions for some time. This can be used to unambiguously identify/manage interfaces. The Foundation decided to "Disable predictable network interface names for Ethernet devices" after only 3 weeks. There is an option under of to toggle this setting. The onboard WiFi of the Pi3 and PIZeroW which is connected over will still use the name See How to set up networking/WiFi Advanced Configuration discusses "disabling" interfaces and how to handle multiple wireless networks. The 2nd part of your question is not a standard network feature. You should be able to do this with a script in a web server. 

The PiTFT does not use all GPIO pins, the 40 pin connector is merely for physical stability and ease of use. Some PiTFTs even have another 40 pin GPIO connector in order to easily allow for more GPIO peripherals. You might want to get one of those. Using DSI instead of the GPIO would be hard, as you would have to write your own drivers (and might need custom made driver boards as well). The Raspberry Pi Foundation allowed some insight on these issues when they introduced their 7" display. 

In order to set up a MCP79410 real time clock (RTC, see manual), one needs to start by connecting it to one's RPi and a quartz crystal. The following is supposed to be a rough sketch on how to connect the pins to point one in the right direction - in practice, one might need capacitors to smooth signals or resitors to pull-up the SCL- and SDA-interface, depending for example on the battery and quartz crystal used. 

Well, the way you wrote your script, it does everything sequentially - one line after another. However, there are ways to execute commands parallely using python on a Raspberry Pi, whether it's a zero, a 3b or something else. The keywords you are looking for are threads and sub-processes (both links are for Python2.7, but you'll find the Python3 documentation on the same webpage). Both are fairly similar in implementation and results for most purposes. 

Why don't you use the one recommended on the product page of your LCD? That way you minimize the probability of further incompatibilities.. Update: The difference between the driver boards recommended by Mark Smith and me are their interfaces. TFP401 must be connected to the Raspberry Pi via HDMI and (!) USB, RA8875 needs a GPIO connection using the SPI interface. Furthermore, RA8875 cannot be stascked upon the Pi directly as the GPIO ports' layout is not the same. 

I had the same problem after I messed up my .xsession-script. Rebooting wouldn't help and username as well as password were correct. However, you can still access your Pi using SSH (e.g. using Putty on a Windows machine or on Linux/Mac OS X) and then retrace the steps that created that mess in the first place (most likely editing or in a way, that the command to be executed did not work or finished after a few seconds or is executed in the background).