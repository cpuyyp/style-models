Depends on your curriculum design. Bootstrap is designed with the assumption that students will (and should) be away from their computer some of the time, so they can think and design calmly instead of just hacking away at their keyboards. In Bootstrap, the worksheets are central to how students are encouraged to do their work, and it's why the Bootstrap:Algebra curriculum has shown really good transfer from programming to algebra skills (specifically, solving word problems). So I don't view worksheets as a nuisance to bear because the network is down; rather, they can be an integral part of the problem-solving process, asking students to do something contemplative and methodical. (Of course, you have to believe that being contemplative and methodical are actually positive attributes…) 

As the kids these days would say, you're doing it wrong. Let me explain. As I've commented elsewhere, every "full language" has a whole bunch of things that educators would find inconvenient or undesirable. Your Haskell students can use monadic state or UnsafePerformIO too! So Haskell is "just as bad" in principle. That's why Racket (in an explicit departure from Scheme) gives you the means to define your own languages, and DrRacket ships with several student pedagogic languages already built in. The first few grow in power to the point of being very powerful — but not having at all. Only near the end of the pedagogic language tower do you find (and its structure mutation variants). Until then, the feature is literally not present. For instance, in BSL (Beginning Student Language), here's a program interaction: 

Note, this evaluation was not performed according to any formal evaluation model (see substitution model or environment model); it was merely to help build intuition for how evaluation could be done. Extra (tail-recursion): I mentioned earlier about how recursion does not necessarily have these pending function calls that much be recursed back to once they finally have the result of the recursive call. Consider a recursive function to find the sum of a list (ignoring the python built-in sum()): 

This indeed would have pending recursive calls, as it waits to add lst[0] to the result of the recursive calls. We can make this tail-recursive by accumulating the sum of the list in an argument that is simply returned unmodified at the end: 

while both recursive calls of the right branch, since it was just a node without any children, have trees that are empty, which is None in python. Thus, they fall to the base-case, which means it is evaluated as 0. So now the original return value is like this 

There's absolutely no reason your first program needs to be in the first place. You can start with values of various kinds, and show how to combine them to create more interesting values. For instance, in How to Design Programs, we start out with numbers, strings, and images. Pretty quickly students can start to create interesting pictures: e.g., flags of various countries, or a scene (imagine a beach with a tree and a sun). Now they can start to change the size of that flag or parts of that scene (e.g., the sun is at different positions). Next they can make a function that given a parameter, produces the flag or scene at that time (by using the parameter to calculate the position of the sun). Now they supply this to a function called and they have their first animation. From there they can go on to much more sophisticated animations. In short, we think a rocket launching off a pad — a good metaphor for their education — is a pretty nice follow-up, and not that hard to do. The book's prologue ($URL$ shows this progression. 

All recursive paths from the right branch already reached the base-case, and now on this recursive call, all children of the left branch will as well, which means the return value of the original function is now 

How to use recursion Let's look at an example: maximum depth of a binary tree (where a tree with a single node is depth 1). A recursive solution in python might look like this: 

You don't need to think about how this is actually evaluated; you just define it how you would mathematically. If I somehow know that the maximum depth of the left branch is $x$ and the maximum depth of the right branch is $y$ and that $x > y$ (without loss of generality), then I know that the maximum depth of the entire tree is $1 + x$. This way of thinking about problems is one way you can use recursion. Of course, you need to make sure that the inputs to the recursive calls are in some way smaller than the input to the function that makes the recursive call, which segues into how recursion is evaluated. How recursion is evaluated To think about how recursion is evaluated, we can use the same example. In the example above, there are pending recursive calls, waiting to return (note that recursion does not necessarily have this, see tail call). To see this, suppose our tree looks like this 

DrRacket is saying "you've put something in the function application position called and I don't know what it is" — the same error as if you had written instead. That is, it's not even saying "sorry, I don't allow you to use state yet"; it's saying "state literally does not exist in my world". Because, at that level, it honestly does not. So the sense in which you're doing it wrong is that you're using the wrong language level. Your programming environment ships with languages that explicitly preclude the use of state. Instead of using them, you're giving your students the full, unrestricted force of an language in industrial use. It's no surprise that they will find various features in there that you don't want them to. (Sadly, there are no "language levels" for Haskell that can keep students from some of the ugly corners of that language, but the principle applies to every language.) There are many more trade-offs between using Racket and Haskell, but this one is easily addressed. (Note that I said Racket, because it's Racket's enhancements over Scheme that enable us to create these kinds of language levels. And with very little effort, you could too, if you didn't like the ones we provide.) 

Once this evaluation reaches the base-case, it has the the result of the original call to sum_list(), and it does not need to be added to, or modified in any way as you recurse back up. 

and you have a variable r storing the root. If you call max_depth(r), it will try to evaluate the else clause; it will evaluate max(max_depth(r.left), ...) and then add 1 to that result. To the r.left recursive call, the input looks like this 

The r.left recursive call evaluates else clause, which means it tries to evaluate the max depth of the left and right subtrees, and add 1 to whichever is greater. The r.right recursive call also evaluates the else clause. So at this point you think of the return value of the original call to max_depth looking like this: 

First, note the difference between NP and NP-hard. NP simply means verifiable easily. NP-hard means verifiable easily, but also means that the problem is as hard to solve as the hardest problems in NP, which are not known to be easily solvable (see P = NP). For describing what it means for a problem to be NP-hard, I have had success by referring to the canonical Traveling Salesman Problem. I might introduce the problem like this: Given a list of cities, the distances between each pair of cities, and a number $k$, is there a path of length ≤ $k$ that visits each city and returns to the start city? And then I would say something like: If someone tells you a path to take i.e. an ordered list of cities, you can quite easily check to see if it includes every city, starts and ends at the same city, and is of length ≤ $k$. However, trying to come up with that path in the first place is more difficult. You could imagine trying every possibility exhaustively, checking if the conditions hold for each one. While there are algorithms better than this brute-force approach, which has runtime that is exponential in the number of cities, none have been shown to be polynomial in the number of cities.