Thats good news. You can get the memory address of the start of this array ising the techniques shown in the code below. After that fast operations are permitted such as calling memcpy or passing this address to OpenGL. 

It's very simple. Which is your primary goal: learning or time to market? Avoid using a library if your primary goal is to learn from the experience of implementing the concepts that are solved by the library. Whenever I develop a game (part time), my goal is purely learning. I don't care how long it takes, thats why I'm doing it all from scratch! Now, you decide. 

The floating point numbers shown are examples of actual calculated interpolation value i.e. the proportion of the physics update that is complete at the time the frame is being drawn. I am going to have to change the draw code to draw the objects at a fraction of the distance between their previous and current value positions and rotations. That is yet to be done. Question: Will I also have to do move my collision detection code out of the update routine and into the draw routine, seeing as I will be drawing these interpolated frames ? Bear in mind, my highest priority goal is to make this networked: multiple player ships on as large a Universe as possible. So a physics update solution that is compatible with the networked game that is required. Is the interpolation worth the effort? Right now. I rarely if ever see a problem with smoothness. If I reduce my physics updates to 25 per second which I have only done as an experiment then it is a bit jerky. But the game easily runs at higher rates than that so there may never be a problem. So the two questions: 

Send periodic keyboard state samples every from client every to match server physics update rate e.g. 50 times per second. Highly resilient to packet loss and other reliabilty problems. Out of date packets disacarded by server. Generates a lot of unnuecessary traffic. Only send keyboard state when it changes (key up, key down). Radically less traffic sent from client to server. However, UDP can lose packets without you being informed. So the latter method could result in the vital packet never being resent unless I detect and resend this in a timely manner. 

Declaring a method as virtual in a base class causes the compiler to introduce a hidden pointer into objects of this class (and its derived classes). This is the , the pointer to the . This pointer and table can be absent in classes that do not declare any virtual methods. The vtable holds the addresses of the correct methods to call. There is one vtable per class. When an object is constructed, its vfptr is set to point to the appropriate vtable in order to make this all work. All virtual method calls are indirectly looked up in this vtable to provide the polymorphism. Therefore, determining which method to call takes place at run time, not compile time or link time. You must be aware of how virtual methods work in order to use them safely. I recommend further reading, inclusing virtual destructors (very important). Polymorphism can be exploited with or without pointers, using dynamically allocated objects or automatically cleaned up objects. References can be used instead of pointers: 

Building a multi player asteroids game where ships compete with each other. Using UDP. Wanted to minimize traffic sent to server. Which would you do: 

My game loop uses a fixed time step to do "physics" updates, say every 20 ms. In here I move objects. I draw frames as frequently as possible. I work out a value between 0 and 1 to represent the proportion of the physics tick that is complete and interpolate between the previous and current physics state before drawing. It results in a smoother game assuming the frame rate is higher than the physics update rate. I am currently doing the collision detection in the physics update routine. I was wondering should it instead take place in the interpolated draw routine where the positions match what the user sees? Collisions can result in explosions by the way. 

Can somebody recommend a free C++ open source library which I will use to build a networked game using UDP. Must be available for Windows/Linux/Mac. As lightweight as possible please. 

However, this is linear and not a "curve" so you'll have to be more specific about what you are trying to do. 

That's it! Just add the extra code for each other object/object holder you want and it will handle the rest. Here's an image to illustrate my test: Here you will see the green bodies are the holders. They do not rotate or collide and are welded together. The yellow and red bodies are your "objects" (yellow is the main). You can see that they are rotated by the same amount and are rotating around their respective holders. Also, only the red and yellow bodies participate in collisions. I believe this meets all three of your conditions above. Working Example If you load up the Farseer "Samples XNA" solution and find SimpleDemo1.cs ("Samples XNA" project > "Samples" folder), I rewrote it (code here) to test. Hope this helps. Let me know if you have any questions. 

You could make the player into several fixtures representing each side. Then you could either give each one an event, or give each one an ID in the to figure out which one is the "collider" in a shared method. This was good for me because I could set the side and top fixtures to have zero friction so the player doesn't stick to platforms. If you're stuff is all axis aligned rectangles, you could calculate it based on their positions and dimensions. This is probably not a great idea for more complex situations since it can get difficult to follow and Farseer already has to calculate this anyways. I think you can check the 's world manifold's normal. In your event, there are three parameters: two and a . has a method called which has an parameter called . This is a that, I think (someone please correct me if I'm wrong), represents the angle of contact. 

You could develop your own SOAP or REST API, host it on a website and have your apps connect to that. You'd have full control over it and wouldn't have to pay for anything (other than hosting, of course). There is more of a development cost up front than using some kind of pre-built package, but you have the control to scale as you need to and make the API do exactly what you'd want. Unfortunately, I don't know of any libraries or packages that provide this functionality so I can't help you there. 

Since you're using XNA, I think the ideal (and typical) solution is to use your own timer variable. You're almost there, but you can't use because of the comments in the other answers and because you can't be sure that the level would start exactly on the first second of a minute since the game started. Sure, it's possible if you have no menus and your game runs immediately and restarts every 60 seconds. But going forward I'm sure you're going to want to make it a little bit more robust. So, what you want to do is create a field variable at the top of your class. Then, in your update, you want to do this: 

Remember, is actually drawing a black pixel to the screen but since the alpha channel is set to , it's transparent. So, rather than drawing a black pixel, we'll continue to draw the regular pixel colour and just change the alpha channel on it. By using , we're saying "when the bitmask alpha == 1, don't draw the pixel". This is what you were already doing with . However, if the value is less than , but not we still draw the pixel, it will just be semi-transparent. Likewise, if the value is equal to , it will fully draw the pixel. Hope this helps! Edit How is the bitmask generated? I think it would be easier and more efficient to pre-calculate the different alpha values in the bitmask texture rather than dealing with edge detection in the shader. If you really want to do it in the shader, you could try sampling pixels within a certain distance from the current one (if the current one is not "blocked" (i.e. ) to see if they are blocked. And then, based on whichever blocked pixel is closest, you could set the alpha value based on the distance away. For example, let's say you start by going up pixel by pixel for a maximum of 5 pixels or until you hit a blocked one. Then you would do the same thing for the right, down and left directions and possibly on the diagonals as well. After you do that, we'll say the closest blocked pixel is 2 pixels away. So the alpha is ( being the pixel distances and being the max distance checked). In this way, if a pixel is 1 pixel away from a blocked pixel, it will have alpha () and will be mostly invisible. 

I am looking for some advice on what would be a good way for users to play Asteroids over the network. Its my first game and so far I have it working in 2D using polygons across a scrolling world in single player mode. Zoom in and out is also supported. Its not bad. I really want to develop it as a networked game as a learning vehicle. However, given all the work involved I want it to be a game people will enjoy playing. My plan is that each player gets their own ship, exists in the same world and can shoot the same asteroids. The world can be big enough for ships to avoid each other. I want the players to also be able to attack other players ships. Normally when playing in scrolling mode your ship stays in the middle of the viewport. This will limit the distance apart that ships can be if you are to see/shoot your opponent. Will this be a problem for the players or do these 2D multi player shooting games work well? 

In my Asteroids game the user can scroll through space. When scrolling, the ship is drawn in the centre of the window. I use interpolation. I scroll the window uing , centering it around the centre of the ship. On my first machine (7 years old, Windows XP, NVIDIA), I am doing 50 updates and 76 frames per second. This is smooth. My other machine an old compaq laptop (Pentium III) with Linux and Radeon OpenGL driver delivers 50 updates and 30 frames per second. The ship regularly seems to "shudder" back and forth when at maximum thrust. When you position the mouse cursor beside the ship it is obvious that its relative position in the window changes. Also, the stars seem blurred into short "lines". Playing the game in non-scrolling mode, the ship moves within the window, is therefore not called repeatedly and there is no problem. I suspect a bug in my positioning of the ship and the window but I have dumped out these values and they seem to only go forward, not forward-back-forward. The driver does support double buffering. I guess if it is my bug I need to slow the frame-rate down to debug properly. My question: is this an obvious driver bug or is the slower machine uncovering a bug in my stuff and if so, some debugging tips would be appreciated. I am drawing in world co-ordinates and letting do the scaling and translation so if I had a quick way of verifying what pixel co-ordinates OpenGL produces for the ship centre, that would help clarify this. 

The ability for the user to set a "world window". By this I mean they supply a rectangle in world co-ordinates and you fit this to the viewport (display it to fit the entire window). By using this function, they can zoom and pan as they see fit. OpenGL has calls that you can pass this on to: By the way, the user specifies everything in world co-ordinates from now on. You could also implement some utility routines to aid in collision detection: Nearness checks using bounding boxes or circles and a more expensive polygon intersection test. 

I've had a quick look at VBOs in OpenGL and they seem to be a good way to transfer large amounts of vertices to the Driver. They rely on all the stuff you passed being in one contiguous block of memory. You're wondering is the STL vector class a good fit? Well it is if you can treat it as single contiguous block of memory for passing to the functions that OpenGL will use for transferring Vertex data between your array and the VBO. So can you do that with a std vector class? According to its documentation: 

Caveat for beginners: beware the subtle differences in the use of pointers and references. Best to learn pointers exclusively first I would think. 

As somebody who has a lot of software development experience and who only really tried to develop a game from scratch recently, here is my 2 cents. The answers so far have provided long lists of pros and cons. I will provide what for me is the most important reason NOT to use a game engine. As I took on the task of learning to write a game purely for challenge and reward I decided to do it from scratch with no engine, just OpenGL and SDL, because I wanted to learn everything above that level of abstraction. At no stage have I regretted that decision. My game is a nice scrolling version of 2D Asteroids, basic but smooth. I am not trying to compete with vastly superior games, but I do distribute my game and people have enjoyed playing it. I will take the same approach in making the game multi player. This is a huge challenge and using libraries might make it easier, but I my goal is not to make it easy. My goal is to learn, and for me it is a part time activity, so I do not have a lot of time and progress is slow. But I have my reasons for this approach. Call it "higher learning". So, answer your own question, do you want to learn how to do the things that the game engine instead does for you for the benefits that this learning might bring? If so, do not use a game engine.