once this is done you can further refactor your if else clause in a strategy pattern , so you will need a factory which will return class will handle the Archive rule or mirror rule inside a different class and your FileActionService will contain only processing logic 

As per my interpretation, you don't need empty string check inside the if clause you can put it out side, and last condition could be expressed in one line. 

Have you considered using views:- -views gives you an explicit way to reduce the complexity of code. so your whole line of code will drop to only few lines. you can replace each subquery with the same view name (or named common table expression as Phrancis metioned) then the optimizer knows it's the same thing and can either cache the result or restructure the execution path so much better than inner query 

I would write an extension method to check whether the above condition holds true. and I hope eHistoryCurrentMedsGroup is a list of some object so you could use Any(). 

This is bad way to write code , I could not even read the code without headache. Please separate out your logging functionality, you function should not be more than 30 lines per method, so first 

I found about 5 things that can be improved, or maybe it's more accurate to say that I did 5 passes over the code in my efforts to improve it. Here's the changes I would recommend, in the order that I encountered them. Better Names The first change was mostly cosmetic, but it was very helpful laying the groundwork for more changes later. 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

okay first of all, you need to use buffered stream to read data from the file, there is no need to write data once in file as it might hung altogether. so I would suggest that read the file line by line , parse it and then write to file. 

b. create an interface named as IView and implement it in your view , pass the instance of IView to data context of the view 

Rest code looks okay. just wondering why you just not cache the data for a predefined interval rather that doing this.I am not sure which kind of application you are working on. 

If any object provide dispose method , prefer using statement. Use dictionary rather than list of parameter as you have a possibility of specifying param names also Current implementation sticks only to datatable , you might need to think about the datareader. naming of variable should be explicit. 

Here are few comments 1) Try to encapsulate the piece which is subject to change. your code is dependent upon amount which can be withdrawn so rather one by one division you can create a list which will consist of that piece only. 2) Use for loop in case of repeating logic. (See below) 3) Prefer Writing Extension method 

It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

This sacrifices quite a bit of functionality to pull this off, mainly because of my preference for s. To add the ability to add/remove child nodes, I went with a view instead. This way the data itself stays the same, just our view of it changes. I also added a helper to provide depth-first traversal, to abstract away doing things with the nodes in the tree. 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

Allows you to flexibly specify values while providing class level defaults that vary on application. Super (as mentioned in other answers) is great for avoiding repetition here. For example 

For combining (1) and (2) you can reverse the sort by only trying if your are under a test directory Also this is a great use for a generator / map combo to avoid extra loops 

This has a couple of advantages 1) not hitting the disk for every query will be much faster 2) the dictionary lookup faction is much faster than straight for loop comparison, since the dictionary uses hashed values instead of more expensive string compares. As an aside, you should look into readlines, which the usual pythonic way of reading text files with info on lines. For the longer term this is a great application for Python's built in database functionality (with the sqllite module). You could convert your existing text files into a sqllite database and then your lookups can be much more flexible and precise ('find spectrum and power for stars with id > X and < Y' sort of thing). You probably also want to set this file up so you could call it from the command line, which would involve using the argparse module to grab command line arguments and out them into known_stars, master_list and output_file 

You can minimize you code taking out the filtering out side of loop. Avoid catching exception inside a loop if it needed ,(it seems like it cannot be avoided here) No need to invoke datarow extension method to get value , you can get it directly. Naming of variable is really bad. 

Please separate out your code into at least two classes 1) Fetching data class 2) UI binding stuff class 4)inline SQL vs Stored Procedure Stored Procedure is good as your code lies at one place in db but creating Stored Procedure for one line of SQL is not a good idea. If your logic is going to be complex and big ,Use a Stored procedure other wise inline sql. PS: I have created a gist named SQLHelper class for you to abstract out the sql connection and command things, $URL$ 

I used nsubstitute and fluent assertion instead of Rhino mocks , It will make your test code more readable here is an example. 

so it all depends upon your use case.In this case table will always have columns so passing a array of column will make sense. 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

Now that we are using a more appropriate data structure, we have regained the simplicity we had before, and don't run out of stack space. 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

Server is a part of Message so server initialization is part of message itself. so updated solution: 

2) Always dispose the connection In above code your opening connection and closing it, but this can lead into connection leak in case of errors. Please wrap your code into using statement or try clause like this 

Well I have changed your code a bit to make it cleaner.It is recommended to have a uniform interface for methods, so now you have two methods in FamilyExpense class is addExpense and another is getExpense rather explicitly calling each method. I am not sure why you have used getFamilyId and setFamilyId. 

Introduce a DAL helper layer which will be responsible of opening and closing connection and executing commands. There are lots of DAL helper layer is available Write an extension method to get values from the data reader. Here is one dummy code 

Bind method should be used only when if your element is not loaded into DOM on pageload. So you could attach events to it using bind after wards. also if your using jquery >= 1.7 use 'On' method to achive it. but as per your js fiddle you don't need it at all. second you could declare a variable to store the jquery object of follow. Make sure about the variable scope though.