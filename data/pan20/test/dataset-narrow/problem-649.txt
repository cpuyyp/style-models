And I m having a Discount class. In fact, we can apply Discount on product, the the amount we obtain is a Euro : 

I m working on calisthenics objects and I'm actually having some troubles while trying to follow the calisthenic objects rules. In fact, I m stuck with the one telling that we have to wrap all the primitives inside of objects. Context I'm having a Euro object that looks like : 

On the Account class When working on the Account class, I was facing some problems while recording transaction. In fact, I wanted to test the deposit function and I had no way to mock the DateOfOperation (not injected, but created from a hidden way). From a technical point of view, this method is private, and its creating a new DateOfOperation to create a new Operation. But the fact of creating this date internally seems to break some SOLID principles. From a business point of view, I don't want people to provide me some DateOfOperation as argument, because they could have modified that date while passing it as argument. And my operation could now be false. So, I don't know how to test this result, and I m lost between the two possibility : matching absolutely SOLID, or accepting that I'm completely hiding the date creation of the operation. One step further to blow my mind, Uncle Bob, in Clean Code proposes to have the fewest parameters possible while creating methods. If we have too much parameters, we should split it in multiple classes / functions (I think I m in this case) 

There are some things to be said about your C version as well, but since you explicitly asked about the C++ version (and also because my C-knowledge is not that great), I will leave those for somebody else to comment on. General Hints and Tips 

is a reference to a -object. References as class members are rare and very dangerous, so let's pull out our alarm lights and go investigate whether the reference is justified and used correctly: 

which is much clearer. Declaring Variables Assuming that you are using a reasonably modern version of c (e.g. , , ...), you do not need to declare all your variables up front. Instead, declare them when you actually use them the first time. This will add readability to your code, because the reader doesn't have to juggle all those variables in his head that are not going to be used until tenths of lines later. Check The Return Value Of Every time you call , you make sure that the call actually succeeded, which is the right thing to do. However, you do not do the same with calls to , which can also fail if, for example, no more memory is available. 

This can't work unless you stipulate a specific size for the partition and do not grow it. You can't discard any value from the input sequence or you won't get the actual maximum. The fact that you're popping a value means that you may be discarding a proper part of the solution subset. Consider a slightly contrived example where X = 0.25. The initial state is to process 1/X items (4 in this case) of which 1 is maximum and 3 are discarded. The values were 100, 99, 98 and 97. You keep 100 as the 25% maximum and discard 99, 98, 97. (You could try to keep all 4 or even the first 25 values. It doesn't matter how many you keep initially, the logic problem will still arise as soon as you pop a value. I think the contrived example makes the logic flaw easier to see.) At some point, you've seen 7 values. The maxima subset has 1 value (100); the remaining values (99, 98, 96, 95, 94 and 93) have been discarded as not part of the maxima set. You get value 8, it's 92. You need to append this to the top set. Yet, sadly, you discarded a value larger than this. When you get to value 12, you again need to expand the maxima subset. However, you will have discarded values that may be larger than the 12th value in the sequence. You cannot do a from the maxima subset unless you can prove the value being popped must be less than all future values which may arrive. 

This is a follow-up question to Sorting algorithms - Bubble sort Again, for practice purposes only, I took on an implementation of the well known insertion sort as a method to be used similarly to . As expected, the code lives inside a header file called insertion_sort.h: 

I'm a little sorry that this answer turned into a huge wall of text. Yet, there are still some things I didn't list here for brevity's sake (especially in the design section) that seemed of lesser importance to me. A lot of the content of this answer is not directly related to the two questions you posed, but I still hope that you will listen to the things I explained in those sections as well. 

All in all, you code is mostly well written. None of the points above constitute a "Act now! Your code is on fire!"-grade problem, only tips that could make your already good code a little better and prevent some subtle, thus nasty bugs. However, I can't tell whether your approach is really worth anything. You should definitely perform some benchmarks to see if there are any performance improvements compared to a single threaded approach and, if yes, how big they are. Another thing you should consider is learning to do proper testing. There are a variety of testing frameworks (for example, Google Test) which provide functionality for writing and executing tests effectively. Especially since you are concerned about determinism here, writing and executing tests at a much larger scale should help you verify that your code works correctly. 

These aren't "utility" functions. They appear to be central to your app. There are rarely "utility" functions in any app. What we used to call "utility" functions are almost always part of a standard library. 

Your use of the dictionary seems to be a way to allow the numbers to arrive out-of-order. Rather than sort them, you seem to be trying to use a dictionary (and associated hashing) to maximize efficiency. This doesn't really work out perfectly, since you wind up doing sequential searches for a given value. Hashing a low:high range (a dictionary key:value pair) to avoid a search doesn't help much. Only they key gets hashed. It does help in the case where you're extending a range at the low end. But for extending a range at the high end, you have to resort to searches of the dictionary values. What you're really creating is a collection of "partitions". Each partition is bounded by a low and high value. Rather than a dictionary, you can also use a trivial tuple of (low, high). To be most Pythonic, the (low,high) pair includes the low, but does not include the high. It's a "half-open interval". Here's a version using a simple of tuples, relying on hashes instead of bisection. A binary search (using the module) may perform well, also. It would slightly simplify adjacent range merging, since the two ranges would actually be adjacent. However, this leads to a cost in restructuring the sequence. You start with an empty set of partitions, the first number creates a trivial partition of just that number. Each next number can lead to one of three things. 

This ensures that each header file includes all necessary headers by itself. Keep your spacing consistent. Notice the differences between 

Design issues Apart from your program having undefined behavior currently, the thing that I most dislike about it is that your queue offers basically no usable interface. First of all, if I wanted to extract the size of a queue, I'd currently need an ugly template hack to get the second template parameter, whereas you actually should provide a getter. Secondly, the mechanism you devised of "get a single pointer to an element, then increment the position of an internal offset to the next element" is about as clunky an interface as I have ever seen. Neither can I get more than one element at once, nor can I go backwards, nor can I do random accesses, although the underlying container supplies all of this functionality. For a start, you should offer an iterator interface. Iterators are one of the core mechanisms of the STL, and enable your queue to work with most of the algorithms it provides (you'd likely need two different iterator types, though, one for read-only and one for write-only). Another feature that I'd really like to see is an interface separation. Basically, your class offers two different interfaces: One is read-only, the other is write-only. However, these interfaces are mixed together in a single class, which potentially allows somebody to do illegal actions, such as writing from a read-only thread. To prevent this, and enforce separation of concerns, it would be really nice if you had two interface-like classes (i.e. and ) which only export their corresponding half of the whole interface. Another point I want to touch on is the whole issue of copying and moving. As is, you simply deleted move constructor and move assignment operator, but this is lazy interface design in my opinion. There is no reason why copy should be forbidden (unless you can provide one), and even much less reasons why move should be forbidden. Neither of those two things seems particularly hard to implement for a data structure like this. Finally, I can not really come to peace with the design decision to force a double pointer indirection for the sake of avoiding copies. Of course, there are cases in which this is totally fine and appropriate, but in those cases you'd simply make the content type of the container and would have basically the same solution to the issue as you have right now. Since you seem to be very focused on performance, here is a point that might convince you: Forcing a pointer means forcing another level of indirection. Chances are, all those objects you create with are living in different parts of the heap, which makes it nearly impossible for the cpu and data prefetcher to get all those values into cache in time, meaning you are probably going to end up waiting a lot of cycles on memory. The more your data structure is fragmented, the bigger the chance that you will completely kill your cache and end up taking more time just waiting for data than it would actually have taken to copy all of those bytes over. In addition, if you consider move semantics, you can actually avoid a lot (if not all) of those copies and turn them into (comparatively) cheap moves. (Disclaimer: I haven't done any benchmarks on this. This is how the situation might pan out on a modern x86_64 processor, but I don't guarantee that any of the possible effects I've listed will be observable.) 

Problem My problems appear on the multiply method of the Euro object. In fact, currently, I m accepting a double as parameter, and it doesn't follow the rule of wrapping all primitives in objects... Moreover, a "double" in a business context doesn't mean anything at all. I m a little bit stuck with this example and don't know how to bypass this. Moreover, I don't want to use getter / setter on this implementation... Any suggestions ? 

On the DateOfOperation class The DateOfOperation exists only to match the rule : Wrap all primitives and Strings which, in an Calisthenic objects context, means that we have to wrap primitives (even if Date is a class definition... same for List, String etc...) This way, I m completely hiding my Date (at a Java sens) creation inside of the DateOfOperation constructor. The problem here is that I can't mock my Date, and my expectation in unit test can't be true... What I m looking for I m looking for some explanations, or code modifications that could be applied in a calisthenic objects context, that would help me correcting the previous problems, or understanding the limit of that kind of stuff. 

This may be better than a list. A list where the order of the arguments is critical is a bad thing waiting to happen. Code like is utterly opaque. It should be replaced with so that the meaning is obvious. Also, once you have an class, your separate function becomes needless. You can subclass like this. 

Once you have that, you're simply making a sequence of details. In this case, each detail is either "x-y" or "x" as the two forms that a range can take. So it has to be something like 

It's (often) slightly faster in Python to avoid the statement. After measuring that with , you should rename the variable . That's a poor name. 

Don't reuse to be the index of the loop. It's confusing. It violates the meaning of start. The lengthy parameter parsing is good, but can be made more clear. Don't waste time on checking for or . Just use the statement. 

In this example, I've shown the format as an in-line . It can be done as an expression, also. Given your ranges, the overall function is this. 

A few. Sorry it seems boring, but there's not much better you can do. The biggest change might be to make this into a generator function, which may be a tiny bit neater. 

The name of the type parameter to , , is the same as an alias template you defined before. This could possibly lead to name shadowing or worse, so I would suggest you change either of those two names. The template typename parameter does not convey what type of iterator you require. I would suggest . is currently somewhat dysfunctional, the reason being that you only check for index equality, but not whether both of the iterators are iterators over the same container. Thus, if I had an iterator over container a with indices i and an iterator over container b with indices i, both iterators could still compare equal, which is likely not what you want. 

You queue is nearly useless Harsh words. Why do I say something like this? The answer is: You only offer two methods to access elements. While this is conforming to the most basic definition of a queue, it's not very useful in everyday programming. At the very least, you should add an iterator interface, which would also allow your queue to interact with most standard algorithms and increase usability by a huge margin. Also, you should add some type definitions to conform to the standard's container library requirements. Some other things 

It extends an existing partition on the low end or high end. The number is adjacent to exactly one range. It creates a new partition. The number is not adjacent to any range. It "bridges" two adjacent partitions, combining them into one. The number is adjacent to two ranges. 

Avoid trying to build a "mutable tuple" as a fixed-length list. Either use immutable named tuples or a proper class. 

This is a pretty radical rethinking of your algorithm, so it's not a proper code review. Assembling a string with separators is simpler in Python. For your example of ","-separated strings, always think of doing it this way. 

There's no real way to speed up the brute-force enumeration of all possible 3-letter passwords. Perhaps you could use the dictionary. There's a finite list of 3-letter English words. They may be slightly more common. Also, if you google for "most common passwords", some kind of 3-letter version of that list could be tried before anything else. 

The statement can be removed, also, since it's really two generators. But that's being really fussy about performance. 

You still have the calculations. You're just giving them names and keeping them separate. Giving them separate names makes them more reusable, easier to test and easier to find. The most important thing here is to avoid creating a (nearly) useless class who's only job is to contain a bunch of functions. Your code uses no instance variables and simply uses another function that happens to be in the class. Both of these could be method functions. There's no reason -- in Python -- to create a class unless you have instance variables and a change in state of some kind. [In Java, you must often create "all-static" classes because there's no other place to put stateless math like this.] You can simply put these functions into a simple module and avoid the class definitions.