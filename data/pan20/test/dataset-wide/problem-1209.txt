IP address: Perhaps the IP won't change that fast, or at all for that matter but when you want to write good code, you make it independent. Pass the IP address as a parameter to the method or get it from a config/resource file like the line that is commented out in your question. Static vs. Instance: Since this is kind of a utility class and you're nowhere creating instances and/or modyfying properties/fields in the class, you can leave it static. Also, static methods can be a little bit faster than instance methods. More reading on this from MSDN: CA1822: Mark members as static. Basically: 

When using this method, there's no need for creating strings and arrays and again conversions to numbers. Your entire code can be written as follows: 

This gives the same kind of situation like yours. Luckily there's the Func<T, TResult> Delegate. The method can now look like this: 

Now you'll get a compile-time exception when trying to serialize an instance of a clas without a public parameterless constructor. You can read more on this here: Constraints on Type Parameters (C# Programming Guide). 

Otherwise, what's the use of making an extension-method? ;) Anyway... As you stated in your comment, one can indeed not assume that a person would always want to traverse only a . Thank God for generics! :D You keep your method but you make it a generic one. When calling the method you specify the type of control you want to traverse. Here's some code I came up with. Please mind that I haven't been able to test this as this is just written out of my head: 

As Dan Lyons stated in his comment you could use the instead of custom goto labels. Check the example on the link he provided. If you want to avoid using completely. I suggest you take the adding of the items out of the switch/case and place that in methods. And then, in every case you call the appropriate method to add the necessary items. Example: 

I'm not saying your code is wrong, only saying that you don't need delegates to achieve this. Also this: 

Above code is for inserting a leading zero when the minutes variable is smaller than 10. This this can be shortened to following code: 

You must also apply this kind of validation elsewhere in your code where you ask for input. Logical errors: The variable name confused me. You checked for: 

Also mentioned is that an entity should not actually containt any logic. Define another class specifically for validation on the properties. You can add validation methods to the class if you want but I'd keep them separated. This way the class can be used in other projects without having to modify them. Here's an example of a class: 

Remember, the .NET framework contains classes and methods for almost anything. And this also goes for adding zeros (or other characters) to a string when they do not yet meet a desired length. This is done with the method, and in your case the String.PadLeft(Int32, Char) method. You simply provide the desired length and the character that will be put in place. Your code will become: 

In a situation where you store an integer as a key and the message as a string in a , you can also the String.Join method: 

This way of working swallows the exception. In case one occurs the default of will be returned, otherwise the converted value. Results: 

is coming back everywhere. So you can place it before the switch statement and place it in a variable: 

In addition to the answer of Andr√©. Try making the return-statement as clear as possible, always! It's not easy to read such a line where you will return something after a long line of evaluations, certainly when using the ternary conditional expression (x?a:b). Place the results of the evaluation in meaningful variables so when you read your code, you know what it's supposed to do. Your code might look something like this: 

Since you're using the method, there's no need to throw an exception. You just have to notify the caller whether the conversion succeeded or not. Plus, throwing an exception in a get statement is bad practice. This results in following: 

Constructor + overloading: Your constructor contains the values you use for the connectionstring. Don't place these values here as it makes the use of the constructor very limited. Create a separate method that will create the connection and call this method from the constructor. The default values you are using can be placed in a settings file or make them private constant fields: 

This will keep asking for input until it is correct. Using a method In your case, you need to ask for 3 numbers, so you won't repeat that same block of code 3 times. Throw it in a method and reuse it whenever you need it: 

contains redundant checks. The property is a boolean and thus needs no evaluation against or in the condition, plus you un-check the item when it is already unchecked, no need to do that twice. Rewrite it as follows: 

Your thinking is good: it's a small difference but... there is a difference. And you have to find a way to extract the difference out of the methods and try create a parameter from this. Small example: 

The only possible solution I can come up with, to shorten/simplify your code, is to extract the redundant code and place it in a separate method for example: 

Before processing input, check if it is in the correct format. In this case you can use the Int32.TryParse Method: 

I don't know what the possible rest of your code looks like, so my opinion might be wrong. What I don't understand is why a lot of people use jQuery for the slightest bits nowadays. The display of the array could be done like this: 

How to: Read Connection Strings from the Web.config File Stored Procedures Introduction to Exception Handling in Visual Basic .NET 

But again, pumping al code in one line is certainly not a good practice. Method naming: Giving your functions/methods names like is definitly not good practice. It doesn't tell anything about what it does and what it eventually returns. 

Update: As RobH stated in the comments, you can use LinQ to avoid nested if statements. Here's how your code would look like: 

You can add extra validation to check if the number is valid. A month ranges from 1-12 and days from 1-31, so you could/should check on that too. Use the var keyword if you know the type already: 

Implementation: Your implementation is not bad, and so aren't the ones from other solutions. Although I don't like too much LinQ methods, creating separate classes or multiple loops for something rather simple as this "problem". I implemented a non-LinQ solution that requires only one loop over the collection, using the IENumerable.GetEnumerator() method. The logic is as follows: 

So your would perhaps become and would certainly become . Seeing or makes me think about booleans. Examples from .NET: 

Although the answer from Heslacher is a really good one, here's also what you might do. Create two boolean variable to check for on the and : 

Reinventing the wheel: First of all, you are aware that there is already a reverse method in the .NET Framework, right? Like stated: no need to reinvent the wheel. Here's link for more info on the Array.Reverse method. Unless you wanted to make your own implementation for whatever reason! :) Variables: I don't agree with rolfl. Whether you have long or short code, create a regular or generic method: give your variables a meaningful name. It's good practice and better for maintaining your code. Recursion vs. Loop: Here I do agree with rolfl. In this situation, the recursion can be replaced by the loop (not going to write that code again). Extensions: Since you make the effort of making a generic method, I'd take it a step further and make it an extension method. Nice for reusability and readability. Final code: Here's what the code looks like with all the tips I gave: