Your is not balanced. If I insert numbers from 1 to 1000 I effectively get an inefficient linked list. is indeed a bit tricky. I would just replace the deleted node with the left node and insert the right node into the left node. You could trivially replace with and put above your tree to make it not only work with s, but with any data type. In that case you should make 2 versions of functions that now take an : One that takes a and one that takes a that is then perfect forwarded. 

This implementation uses a second array for the merged list. It is probably possible to do it in-place, but that requires some more effort. My solution reduced the complexity from O(n*log(n)) to O(n), but changed the space complexity from O(1) to O(n), which is not strictly necessary. I would probably favor your solution because it is easy unless it is proven by profiling that the small efficiency deficit is a significant problem. 

Note that this is a free function, not a member function of . Prefer free functions, because they work in more cases (like multiplying an to a ) and are thus more consistent. This allows you to do this: 

is a user defined data type and C++ gives you a lot of freedom to make it the way you want. However, if you make it overly complicated people cannot use it effectively. As a rule of thumb you should aim to make your data types behave roughly like an because screwing up the usage of an is pretty hard. To add 2 s you write something like this: 

Some of your member functions should not exist. You don't want algorithms and containers to result in implementations, because that number becomes rather big. Also people tend to forget to add all algorithms to their containers, especially when new ones appear. Instead you are supposed to implement algorithms and containers separately to only need implementations. This applies does not apply to , and that have a non-member function , and because the member functions are more efficient than the free standing functions. Also only moves elements while actually erases them. Unfortunately it doesn't apply to because requires random access iterators which you don't have. Your implementation seems to make a lot of copies. If you can't find a clever efficient way you can just create a and that and then apply the positioning to your list. I would expect a linked list to work with move-only types such as , but it doesn't because you copy s in various functions. I am getting compilation errors with both gcc and clang. It looks like you only tested with VS's compiler which tends to be a bit lenient. Avoid functions. That is what the destructor is for. Also you already have . Your does bad things when . For example you can do 

I have a DataGrid that I filter when the user inputs text into a search box. The column that is filtered is based upon which radio button the user selects (Name, Town or Post Code). Although initially nothing happens until the user has started typing into the searchbox, for some reason there is a noticeable delay in selecting the different radio buttons. Intuitively I thought that something was happening when the radio button is clicked, but there is (as far as I can tell) nothing being called. The C# program is relatively long, so I'll include the XAML for the radio buttons and the methods that they are being used but not the whole program, unless nothing is found originally. SearchGrid 

I have a method that retrieves information relating to a Contact that was made between two Companies. I am looking to improve my code in any way and am intrigued in hearing any recommendations you may have on how this method can be improved. I use it throughout my program but modify it according to the DataModel I am attempting to load. 

Sometime ago I asked a question regarding a slow Filtering method for my . Months later and I have a relatively quick method, though I am still looking to improve performance, especially when the user is deleting text from the SearchBox as this seems to slow down more than if the user is typing characters in. OnTypingIntoSearchBox 

I really see no reason for anything to slow down purely based on the selection of the radio button, is there a way to improve this code? 

I have around 350 loading into a and am already noticing some lag when filtering on their . This concerns me as we could easily reach > 1000 quickly and I need filtering to be as quick as possible. I'm trying to avoid calling as I know this is expensive but I am not quite sure how to do this here. Here is my code: C# 

I use a here as I couldn't get the styling I was looking for in a . I also created a minimal version of a , so I can search on fewer properties. Reading around there are solutions but many are < 5 years old. I'm also aware that can be slow so I suppose I should be looking at a different approach to the itself. I'd appreciate any help and advice, thanks! 

I hope that isn't too much code - apologies if it is. I'm essentially looking for anyway to improve the efficiency of this filtering method, either by the user searching through typing in text or by checking specific checkboxes. 

From the code you can see there are two more methods involved in the filtering; CompanyMatchesFilters 

I have re-written my filtering method to try to improve performance and I feel that although this is the fastest yet, there is still room for improvement on some of the slower machines my program runs on. The is bound to an , as the user enters text into my each that matches the filter is added into a filter . The is limited to the first 25 so as to enhance performance. Here is the method that is called as the user types; 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. Don't Ignore Compiler Warning and Error Messages It is unclear whether the code was ever actually compiled and tested, and it is clear that it was never compiled without DEBUG defined. I have compiled this using Visual Studio 2013 on Windows 10 Pro and XCode running on El Capitan. In both cases it doesn't compile because the function declaration in the header file is wrong. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines well. The function could be broken up into at multiple functions, especially the contents of the block. The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. Don't Repeat Yourself In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns, replacing them with abstractions; and several copies of the same data, using data normalization to avoid redundancy. Generally when there is repeating code in a software module it indicates that a function should be written to contain that code or a loop should be written to perform the repetition. When code repeats in different functions it becomes a maintenance problem. Someone can fix the code in one location and miss it in another location. The solution to this is to write a function for the code that repeats. 

A collision is when 2 different functions have the same name, the same arguement types and a similar functionallity (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionallity of a class such as std::vector or std::stack. Namespaces allow these constructs to be overriden. The use of the programming statement: 

Welcome to Code Review, very nice first question for Code Review! You're quite correct about the program structure and you may want to do some research on software design principles such as the Single Responsibility Principle, the Don't Repeat Yourself Principle (DRY code), the Keep It Simple KIS(S) principle and Demeter's Law. What is the State File For? Currently the program is reading the state information from the file, but the state information is never used, the state array is thrown away after it is input. This could almost be considered a bug or broken code. Use stderr to Report Errors When C was first developed the creators created 3 File pointers to use, , and . The function prints to , reads from and a special file pointer for reporting error messages was created, this is . It is better to report errors to stderr than stdout because redirecting file output by does not redirect stderr. It is possible to redirect stderr to a file as well using (Unix and Linux). To print errors to :