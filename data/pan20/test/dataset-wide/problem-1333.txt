Making fields more friendly Then, again as per Mat'sMug's suggestion, I'm using a private type to store fields: 

You can only use the syntax with statements inside a block, and you can nest Blocks.... Note that indentation helps enormously, so I've changed the indentation to 2 spaces, although 4 is more typical, but doesn't always suit StackExchange rendering. 

IMO, you're better off with a function that either returns a boolean that confirms the sheet is present (before you try to do something with it), or returns a reference to the sheet or otherwise Nothing. That way you can keep you error handling concise, and avoid the need for labels. Here's an example of the reference approach: 

Having said that, you're going through some variable gymnastics to pass a ParamArray argument to a private method. You can avoid that by declaring the helper function's parameter as , but then you do need to check that it is an array before enumerating it. 

And, I'll use an Enum for setting the state of the predeclareed instance. It's either ready, or it's Initializing a new Point. Note the use of a leading to make the non-default enum member hidden, and the use of square-brackets to make the syntax valid. 

That would allow me to use the array to build multi-line results. For example, like a hex editor view: 

Assigning ActiveConnection is an object whose default property is . When assigning the property, it is better practice to always use , although ADODB will manage things behind the scenes if you forget and just assign the property. 

Despite the documentation above, does actually seem to return when the ParamArray argument is missing, but it's still safer to check the array bounds. You obviously have a private helper function in , but it is not necessary - if the ParamArray variable is "missing", it will be an array, but its upperbound will be -1, and its lowerbound will be 0, so the statement is sufficient. 

Implicit Variant Types You've been diligent with Type declarations, but in you have omitted the Variant type of the ParamArray: 

Referring to the current project I know you probably meant for this code to be generic so that it works across any project, but it would seem that the code is supposed to sit inside your addin. 

That is, usage of members against , like or, more correctly, can be unreliable and result in error . You'll have more reliable code if you first assign the result of to a local variable, and then access the method from that variable. 

Render the Frames Define a sprite of random numbers between 1 and 3, and a sprite the same size of all zeros. 

Am I missing something? Why were you using ? Arrays are not objects, so you can copy them using a normal assignment: 

Timing events Using offers very limited granularity. gives you improved granularity but also a few problems when timed-code runs through midnight, but it avoids the need for win32 functions. If you want better timing see GetTickCount, or better still, QueryPerformanceCounter. I've used for the sake of simplicity. 

I'd like to get a distinct list of attribute values where the attribute name is in , but my final/actual list of attribute names will number around 30. I have this C# code working using XmlDocument and an XPath query, but I'm unsure if this is the most efficient method. 

Options on Hex Format While I have implemented a to allow for various hex syntax, I'm forcing the hex string to have adjacent characters, but some consumers of the function might want some more flexibility. If I added an optional parameter , then I could do things like: 

If the subform is set dynamically, and you only know the return type will be a Form, then return that base type: 

Well, here's a form saved from Excel 2013. Notice the VB_Exposed, VB_HelpID and VB_Description attributes. I set the Description and Help attributes using the Object Browser Context Menu ("Properties"), but a user might have manually edited the attributes in a previous export/import, and so they might be in a different order 

Complete Code This is a pre-declared class. I require that new instances of Point be created from the default instance, and only the default instance of Point (which means that the default instance could do useful things like tracking the number of Point instances), but it isn't much work to facilitate any instance of Point being a valid factory. 

Or maybe the non-existent compiler constant would convert to 0, and thereby False, by default? The Access rendering "32000" limit Access can run into difficulty on large/multi-monitor systems, where the host window equates to roughly 32000 ( the exact limit seems related to the 32000 give or take the borders imposed by various operating system versions) in the X direction. This is, in my understanding, party an Access limitation, and partly a factor of the way that forms are serialized. You may want to check the behavior when an Access window is wider than a typical 1080p monitor (16x 1920 pixels across), or you may get some unexpected problems. 

Waking this one up... ExecuteNonQuery Return value never assigned never has its return value assigned. Return value type You have an opportunity here to return a richer value than a . Very often when executing a command, you're interested in the number of records affected. You can return the number of records affected, or -1 if there is an error. Execution Options You're not explicitly setting any on the . As per MSDN: 

I'm trying to replicate the attributes text that appears in File Explorer, for files and directories. I can't just use the enum names, as the summary text uses a single character for each set flag, and that character isn't always the first character of the enum member. I'm also not using the reserved attribute. So, I'm using a operation to concatenate the flag characters. 

Be careful with properties matching built-in control names is the name of a built-in type, but you're using it to return a . That might be confusing for users of the property. Accessing the `Forms` object The Forms object extends the names of open forms at run-time. That means you're using late-bound code and you're not getting any Intellisense. Worse still, if the form isn't open, or it's in the wrong state, the call will fail. At the very least, you should have some error handling. Using the default instance of the form Access creates a default predeclared instance of a form (much like VBA creates a default predeclared instance of a UserForm), but Access only does this if the form is open. However, it is also possible to create instances of the Access form (and, I'd argue, is the preferable way to deal with Forms and UserForms). Your code is intimately tied to the default instance, and should perhaps be made capable of handling any instance of the form. See this example to see how a form with a default caption of "foo" is handled by VBA: 

To Collect or Hash The has a number of limitations, but it is enumerable and you can refer to items by index or key. But the VBA implementation of a Collection is 1-based, and they don't have any way of confirming membership, and the method returns a , so they're loosely typed. Did I say method? Yes, that's right, is a method. Let's make it a property while we're at it. Dictionaries aren't enumerable, but they have useful methods like and . They're implemented as hash-tables behind the scenes, so they're faster than Collections for retrieving members and/or for confirming membership. What if I could combine the best features of Collections and Dictionaries?