Simplify remove Since you have a doubly linked list. You don't need the variable . You can find that from . 

Your main problem is that you have a RAW pointer in your class and don't implement the rule of three. This will break your object: 

This will only allow conversion to bool when an object is used explicitly in a boolean context or explicitly cast to a bool. 

Yank that stuff out of the loop it will probably make it fast. If you must have branches in a loop then make the true branch the one that happens most frequently. 

Move Operators: Much easier to write in terms of swap. Then you only need to write it once (in the swap method). Also Best to mark move constructor and move assignment as (assuming they are). If you place them in containers it allows them to be moved otherwise containers will attempt to use copy semantics so that they get strong exception guarantees. 

You can use on variables in Make to incrementally add flags. This is better because a lot of people will set the standard flags on the command line before calling make This is quite common CXXFLAGS=-O3 make Make also has a bunch of standard rules: 

Sure the iterator does share the same data type. But it does not have the same meaning. I would have used to indicate that meaning of the . Redeclaring functions. You don't actually need to re-declare the friend functions. The friend declaration in the class should be enough. 

endl vs '\n' Don't use unless you absolutely want to flush the buffer. Probably OK here. Just wanted to note it. Don't pass pointers: 

Now the code is broken with a double delete (shared pointers do not automatically know about each other. If you wanted your singleton to controlled by smart pointers you should have returned one from the call to . I prefer the singelton to control its own lifespan: 

Copying Because you are not managing the memory you don't technically need to follow the rule of three or five. But this also results in unexpected behavior. 

If your code ever changes you want to writ it in a way that allows you to update the code with the minimal number of changes. This means writting function in terms of each other. In this case write the in terms of the . Thus if there is a change in the code you only need to update one function. 

Again who owns the data. If the container ownes the data then you need to add manual code to destroy the objects. Not using standard patterns This looks like a classic case for the command pattern. 

That's way to much work. The problem arises from converting your input from a stream into a string and then trying to parse a string manually and keep track of the position. The original stream would have kept track of your position for you. If you want to do line based input (a good idea). Then you should read a line into a string. Then convert that to a stream and just use the stream from that point on. 

You allocate the buffer and force every member to default initialized. Then you turn around and immediately copy over those default initialized values. What you should be doing is constructing and using the members of the list to construct in place once. Same problem here. 

Algorithm Basically your code is C. You should be wrapping state into objects. Your graph is represented by a global 

Personally I like to see all the members initialized in the initializer list. But I can see some advantages for objects with lots of constructors in avoiding writing the same thing repeatedly. Style Check. Most style guides for C++ (though this is not ubiquitous so just take as advice and not a rule). User defined types have an initial capital letter, while objects (which includes functions/methods) have an initial lowercase letter. This is because the most important thing in C++ is the types. So it is useful to be able to quickly identify types from objects. 

You don't initialize the members. Since the members are POD they have indeterminate values and thus reading them is undefined behavior (unless you assign something to them). So the move assignment operator has the same problems as the assignment operator as it reads the value of (only a problem when called from the move constructor). 

I doubt you could measure the difference. But if it is important then you should measure it. People will always have opinions on this; they are not relevant. The only thing that matters is data. BUT it only matters if this is important. Normally I would consider more expressive readable code more important. This code is readable and easy to update (I could even put the data into a config file that is modified seprately). 

Note I always put the const on the right of the type (rather than the left). Admittedly this is a religious war so choose a side and stick to it (there is only one minor side instance were it makes difference). But I find it makes reading the type name easier (as types are read from right to left with const always binding to the left (except where it is the leftmost lexeme in the type then it binds right). Methods that do not change the state of the object should be declared const: 

You always need a job queue. So this can never be . So rather than a pointer a better choice would have been a reference. Also a reference implies there is no ownership of the object so you are not supposed to delete it. 

You are passing C-Strings and arrays of C-String. That's not a good start. Who owns the pointers? Am I supposed to free the pointers after use create them? I can't tell based on this interface. About the only thing I can tell for sure is that token_count is an out parameter but I am not even sure if I should reset that to zero before starting (which means the user of the code does not know if they need to set it to zero before starting, which means the only safe thing to do is set it to zero (which means if you set it to zero inside the function you are wasting instructions))? Also passing arrays through a function is dodgy. Its not doing quite what you expect. In this case you are passing through as the parameter. Which makes validation on the other side a pain. When passing arrays don't give the function a false sense of security be exact with your type (or learn how to pass an array by reference). Also I am betting and are macros. Don't do that macros are not confined by scope. Prefer to use static const objects. Note if you use a vector all that information is stored for you. Prefer to pass C++ objects. `std::string is always good for passing strings and why not a vector for a container of objects. Unlike normal; I will not complain about this (as it is confined to a very strict scope). But you should be aware that its frowned upon. 

Stable Sort A very nice property of a sort is when it is stable (its a maths term go look it up). Change this line: 

The reason for copy seems that you put common code from the copy constructor and assignment operator in a single place. I would change this up. I would put all the copy code in the copy constructor without the call to . Thenuse the copy and swap idiom to implement the assignment operator (now there is no reason for the method). Use copy and swap idiom to implement the assignment operator: 

There is no point looping over all the values. if then there is no point in running through the d loop as you will never find the value. There is no point in checking all values of . If you must use a search arrD then do a binary search of the array. This will vastly reduce the number of items checked in the innermost loop. Alternatively just find the cube root of the result using a maths function. 

Looks like a duck cat!!! Note: This is not designed to parse valid HTML. The idea was to parse invalid HTML that is found on the web. So it makes allowances for a couple of common problems found in HTML that you see on the web. It also assumes (incorrectly) that all text between => and => is one big blob of text. parser.h 

Checking the state of the file manually is basically never correct (its an anti-pattern). Also this case is also wrong as does not check for end of file, so you could have hit end of file not read anything into grade. A better check is: 

The reason to use a free standing function over a member is to allow either sides of the expression to be auto converted into the class (rather than just the right hand side being potentially auto converted into the class). Make sure this the expected behavior. Stealing things from std::string 

Overview You should be using std::thread and family rather than pthread. The main reason is that these are exception aware and will do the correct thing when being destroyed. Moving on assuming we are talking about pthreads. Secondly you don't use RAII enough. As objects you create via pthread are not cleaned up correctly in all situations and as a result your application is not well defined. pthreads is a library. As a result all it knows about is stuff (this includes functions). Passing C++ stuff to a C library is undefined. So the callback functions you use in need to be declared as C functions otherwise there is no guarantee they will work correctly. To declare them as functions you need to Your design relies on global objects. This is always a red flag. All this queue handling shenanigans should be done inside a class to protect the the queues from some other programmer coming along and using them in some other manner than is expected by your code. You can then declare a single object in the main function and pass it around as a parameter (so you don't get global state that can be accidentally mutated from somewhere else). Design I am not clear what you are trying to do. The code does not do what the description above says. 

Will a long or an int not just work (1 .. 100) fit nicely in these types. One variable declaration per line. You are not helping the compiler by making less lines of code (it will work just as well with more). But humans who have to read this will work better with cleaner more readable code. 

Summary: The code wraps functionality into a node object that should probably be contained in a higher level construct (like the list object). There are a few clues in the code that indicate that this is a work in progress to teach concepts (so we can forgive that). Way to many comments for real code. They clutter things up and make it hard to read (But OK since it is part of teaching course). This is just lazy Avoid if at all possible 

Unless they gave you special instructions. A zero and one length string is a palindrome. Use auto when you can 

The problem with C casts are they are exceedingly dangerous. Basically you are telling the compiler to override the type system (designed to protect you) and do as you say (even if what you say is stupid). But to compound this C casts are exceedingly hard to spot in the code. So even a good code review may miss very dangerous casts. The C++ casts are designed to stand out. They can be just as dangerous as a C cast (though because they perform specific subset of operations each not quite) but because they stand out they are much easier to spot while reading the code and thus review and check that you have got correct. If I see a in the code I usually go and start picking through that code with a fine comb. Stop using malloc/free/realloc C++ has its own memory allocation functions that are built into the language. 

When testing a stream state best to use rather than any of the other states (as this catches all failures). Also note that when a stream is used in a boolean context (ie in an condition) it converts itself into a value compatible with the context using the method as a test. 

Now you are probably thinking that this is inefficient as this requires a copy of the object out of the function. Which is technically true. But the compiler writers put a lot of work into making sure that this copy does not actually happen. RVO and NRVO (optimizations) basically make sure that the object is built in place at the destination (no copy required). Also in C++11 we introduced move semantics to the language. So on the rare occasion that RVO and NRVO fail a return value will be moved (not copied) from a function. moving a vector simply involves swapping three pointers (or something very close to this) so it is not very expensive. Prefer over The difference is that flushes the stream. 

Iterators Currently you can sort anything that uses . But an iterator is a data type that has the same behavior as a pointer (when used in appropriate contexts). But there are other types that are iterator; so using them makes your code much more generalized. 

Template traits class. The templatized version holds nothing (see ). But the code depends on particular values being there. So if you try and use it then compilation will fail. Thus to use the code you need to actually declare a template specialization explicitly for your class (see ). make_X function template functions can deduce their type based on the parmaeters passed to the function. While a class can not. So you can use template functions to create objects of the correct type without having to be explicit about it. 

Getting close to a release of generic server. Nisse Server: Part 1 Helper Functions Nisse Server: Part 2 Socket Layer Nisse Server: Part 3 Stream Layer Here is the server. The basic usage should be very simple: 

This is what it was actually designed for. There is one time where saving typing is OK. But it uses to shorten a deeply nested set of namepaces into a single name. 

Types and names In C++ the most important part of the program is the type information. There is nothing more important than types. Get your types correct and you are 85% there in a C++ program. As a result it is useful to be able to distinguish types from objects in the code. So a common convention is to use a naming scheme. A very common naming scheme is that user defined types have an initial uppercase letter while objects (variables/methods/functions) have an initial lower case letter. 

The only time it is needed is when a method is defined in a header file included in multiple compilation units. Then it is used by the linker to note that the one definition rule is not being broken. Constructors All the constructors are good. Though I did have to double check the copy constructor. 

It adds a line. It is also longer to type than just prefix each swap with As pointed out by @Matt below. There is a good reason to do this. Read his links below for a more detailed description. No point in doing copy-swap idium for a class that is not managing resources. So really there is no need for the copy constructor or the assignment operator the compiler generated versions will work perfectly well. If you can compare against a value: 

But it is your source file so I am not going to complain too much. Just note that you are being lazy. These do not need to be dynamically created. 

PS The above code is also broken. The command assumes there is enough space in the destination. This is not true. Additionally the result of is not modifiable (even if does return (C is not know for its const correctness)). So copy data onto the end of the string is not allowed Looks like this is your main object. Global mutable state is a bad idea. Looks like this should be a class and all the following methods members of that class. It also makes the re-using the object easier (Note: The above is is not mutable so it is OK to make it global). 

Thread 1 is now waiting for g1 (held by thread2), while thread 2 is waiting for g2 (held by thread 1).