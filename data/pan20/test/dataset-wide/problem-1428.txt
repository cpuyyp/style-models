I'm not sure if you're interested in better algorithms, but if so here are some. In this particular implementation, I would consider changing how you handle substrings. You're currently doing a lot of string concatenation, which can be slow as a new object is allocated each time. Since you're just tracking substrings anyway, you could instead store the source string, start index and length of each match. That would save you potentially quite a bit of memory, and run faster as well. If you're really attached to having separate string objects, at the very least figure out the extent of the match and then do a single to extract it, rather than building up the substring one character at a time. 

This is not secure at all. Apart from the issue (use ) and the hashing issue (use bcrypt) already mentioned, and the fact that is not timing safe (use hash_equals), an attacker can log in without knowing the password like this: 

plugin field I would still like to see the declaration of as well as the method. As mentioned in the comments, it looks a bit like it might be bad design. 

Security SQL Injection Sometimes you use prepared statements, which is good, but other times you don't. This is vulnerable: 

Since your data is already sorted you definitely don't need to use a dictionary. You can just accumulate and then whenever the or rolls over you write them all out. That wouldn't be a huge change from what you've got. But honestly, what you've got is a bit confusing because you're trying to do several things at once. Namely: 

Pretty straightforward here. We could've written this more succinctly, probably even in a (really big) one liner, but this strikes a reasonable balance with clarity, I think. So, now we just have to put those two together... 

loop Your loop would work much better as a loop, as you are iterating over anyways (you would get rid of two extra lines of code, and the code would be clearer as well). raw list It's always a bit ugly to have raw types, so could be . Naming 

If you extract the code to a function, you could get rid of quite a couple of lines, and avoid possible bugs that may happen because of copy-pasting. (But as I said above, you shouldn't actually do this at all.) $isset I would get rid of this variable. Just check at the beginning if either value you need is set, and if not, return. Naming Don't abbreviate variable names, it makes code harder to read. Without proper context, I have no idea what or are. formatting You are not using enough spaces, eg after . HTML Your HTML isn't valid, you can check this yourself, eg here. You are also using elements such as to style your document, which you shouldn't. The same is true of using for styling (it should only be used if it has a semantic meaning). 

(disclaimer: Glenn's a friend and former colleague of mine, but he is really good at this stuff. I don't get kickbacks. Maybe a beer, but probably not.) 

So now we have a nice, clean list of the data you need to output. Basically we've handled the first and second bullets from my list, so all that's left is turning that into XML. There's probably a cleaner way of doing this than using s directly, but let's just stick with it for the moment. But again, let's stick all the logic in a nice clean function. 

This is a lot of code, so this is not a complete review, just a couple of points: Overall Program Structure Class Your class is a bit over 700 lines long. Without even looking at the code, it's a good guess that it does too much. What your class does: 

Escaping Variable Part of Query Check out this and this post about correctly using the wordpress database class to avoid SQL injection. Even if the variable data is not directly user supplied, I would always use prepared statements or at least escape data as defense in depth, and to prevent second order SQL injection. Your code should look something like this: 

Try running this with Explain Plan turned on. That should tell you what part of the query is taking the longest. Run and then your query. That will give you an idea if the I/O usage is high. If the above don't suggest improvement, check the overall DB for problems. Glenn Berry's SQL diagnostics queries are a good place to start. If you still can't figure it out, hire someone like Glenn to help you. Or start reading a lot of books on SQL Server optimization. 

Admittedly it's a lot of lines, but they're very easy to understand. Also, the test method itself becomes dead simple. Since I'm on the topic of tooling, you might want to look into the TestDriven.NET Visual Studio plugin, which provides very nice "right-click -> run test" integration. 

For password hashing, bcrypt is generally recommended over simple one-round sha256 hash. Weak hashing might actually be ok for your security requirements, but as bcrypt is actually easier to use in PHP (it manages salts for you), and is more secure, why not use it? Also, for hash comparisons, you should not use , but a timing safe function such as hash_equals to avoid timing attacks. Also, currently it looks as if your query logs might be in a public directory. If so, that is a really bad idea (exposes database names, etc; invalid logins might be mistypes, also exposes valid logins). Misc 

You'll notice I'm using classes of the form like , that's because it's nice to separate CSS class names that are used purely for JS from those used for styling (more info). The full JavaScript: 

I recommend using bluebird for promises; it has a ton of nice features that really improve quality of life and seems to be faster than the alternatives by quite a large margin. (Note: I only briefly looked over the JSPerf, but it seems to be done well enough.) Using bluebird (and a few other adjustments), the promise version of the code can be simplifed to: 

Comments You have some comments which don't tell the reader anything they didn't already know: , , . You can assume that the reader will be at least somewhat familiar with the language itself. What you should comment on is why you do things, and if it is unclear, what. Misc 

Which still looks quite readable, and might be a bit clearer than what you have (because it's more obvious which is the input to be tested and which is the expected result). Either way, I would add comments on the top of each array entry, so it's immediately clear what it contains: