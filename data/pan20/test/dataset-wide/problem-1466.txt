The VB.NET version handles more diagnostics because the two compilers have a different set of diagnostics they report for different cases: 

In the first, I have an representing a theme style, with 0, 1, and 2 being the three themes I support. Themes 0 and 2 are identical in the part affected by this (white background), while 1 has a black background. In the second, I want theme 0 to always be the default, no matter the value, and themes 1 and 2 to return different items. Beyond the general comments, there are a couple things I would like specific feedback on. Both of these convertors are one-way convertors, and always will be; however, that looks a little off - should I replace that with ? Instead of formatting my code like this: 

This question pulls content and ideas from a good many of my other questions and their answers, and pulls a lot of things together. I am quite satisfied with my approach here, but seeing as I'm refactoring my app, I might as well ask about my practices and get suggestions for improvements. This is my search method (thank you for helping me with it, Heslacher): 

Algorithm When you check whether any number is prime, you check the divisors from 2 to . If a divisor is greater than the , you need not check it. This is because once you get above this number and less than , you are only checking for the reverse pairs you checked before (4 * 5 == 5 * 4), and any number greater than cannot go into more than once. Eliminating these extra checks could greatly speed your algorithm up on very large numbers. 

Just because I'm bored, I wrote yet another prime number generator. I think it's pretty clean, but I won't be surprised if someone finds something to comment on. 

will throw an exception if the user types a non-number. Use to see if it is a valid number, and make the user input a valid number. 

Next on my list is to generate more tasks, especially when working with larger passwords, so basic pointers on how to split the password into groups for each task more efficiently would be welcome, but please do not provide a full solution - I need to think this through myself. 

is not a possible value for - only and are. Otherwise, your code has no errors according to the official W3C validators: 

Nested ternary conditionals are ugly. Ternary conditionals nested three deep are ugly to the third power: 

Your CSS does have two errors according to the validator. First, you cannot set . If you wish to use the default value, change it to , if you wish to inherit it from the parent element, use ; otherwise, use a specific number or a predefined value, such as : 

Your HTML markup is, however, very difficult to read due to your wild indentation. For example, you have this: 

There are definitely a few things you could improve here. First, you should create a method to convert a Roman numeral to an Arabic numeral and vice-versa: 

I wrote my first WPF UserControl today, and I would like you to review it. Its purpose is to have images by default resize with the page, but expand to full size with a double-click: 

This ASP.NET MVC website is for my professor to track my progress on my Checkers app. This is the first time I have build an ASP.NET website entirely on my own, and I would like a review to make sure I am doing everything in the best way possible. First, my HomeController: 

One thing I noticed is some of your variable names don't mean very much - , , and , for example. While your methods are short and easy to follow, it is always a good idea to give variables meaningful names. Another thing I noticed is that you may want to provide error handling here, and in similar areas: 

Another thing you could do to improve the code is use better names. You have the inputs named as and . They do not represent users, but Roman numerals as strings, maybe would be a better name. also does not represent a total, but an Arabic numeral converted from a Roman numeral: . Finally, you do not support 'D' (500) or 'M' (1000). If you support these, you should probably add support for "CM" (900) too. Otherwise, your code looks pretty good to me. 

It is just easier to read this way. Also, you should have each element have its own line, not put many on the same line like this: 

Use This is important for proper execution when running a program with multiple files. Code Duplication 

Two string arrays with members that are supposed to match by index? Extremely difficult to maintain, as I learned from my own experience. Use a map instead, so you can do something like: 

But wait a second - there is a built-in way to do this in a single statement! This method is in the namespace, and can be written like: 

F# has a function that is the same as , except it prints a newline at the end. You should use this instead of manually specifying you want a newline with * Well, sometimes complicated, fast code is better in performance-critical environments. 

That has a lot less duplicated code. You should consider splitting it up into a couple methods as well, instead of having everything in one method. Third, never delay your program like this. Consider if you were marketing this project, and I built an identical one, except I didn't delay - which would you pick as the consumer? Probably the one that was faster. Fourth, I would probably merge these two s: 

Because attributes are supposed to specify the language of the webpage, they are not allowed to be longer than 8 characters, according to the W3C validator: Bad value javascript for attribute lang on element script: Subtags must not exceed 8 characters in length. The correct use for this attribute would be to use it as this for a Spanish webpage: 

is not valid, the correct attribute is There is a pretty bad UI problem here. When you click the buttons as follows , the calculator reads , whereas it should reset and only read because you clicked the button. 

There is a lot that can be improved in this code. First and foremost - please use longer, descriptive variable names - doesn't really tell you anything. The only time I would say it is acceptable to use a single-letter variable name is the traditional and variables used like this: 

First, you should use descriptive variable names. 'test1' is not very descriptive of what it is used for. Second, instead of initializing 'len' to 10, you should initialize it to -1. This would be better because it is an impossible value for a string's length. 

The same applies to . The rest looks good to me, except you should be consistent about using using spaces around your operators according to the PEP 8 style: 

First off, I don't know Swift. These are generic issues that should be addressed in all written code, and I'll leave the Swift-specific stuff to the experts. Comments 

You should use the method. This will assign the value to the if possible (an argument must be assigned in the method), and return a Boolean value for success: 

Instead of creating a new variable and iterating backward until it is equal to to set the remaining elements of the array to , I just start with the variable in and iterate until the end of the array is reached. This will work because the outer loop has finished iterating anyway because once , we exit the outer loop. Third, put spaces around your mathematical operator(s) to make it easy to read: 

Just because I've never written a real Sieve of Eratosthenes, I decided I should probably write one just to make sure I know what it is. I'd like (constructive) criticism on best practices, potential problems, and anything else you see fit: 

is two-way bound to the selected value displayed. My question is, is this a good way to be doing this? Previously, I had all my s in arrays by menu in an external file, and I would use a to populate the . Jeroen Vannevel suggested I just add them directly like this. I don't like how big my switch is growing, and it just feels generally clumsy this way, where I have my menu items all mixed in with my logic and everything. How could I improve this? 

Right here, I'm not sure why you use the logical when you don't need it. You should be using the conditional operator instead: 

What happens when the user enters ? Your program will crash. You must always test for division by 0 in cases like this: 

This is my basic C# calculator; I'm sure there is much that can be improved. This design is based on Bjarne Stroustrup's C++ calculator, a purposely be-bugged version of which can be found at his website. 

These types are used to create a , which is used in to provide the correct value for various calls; this valid is primarily used in : 

In the Minimax object code, you use good variables names. Not so much in the Board object code. Otherwise, this looks good to me, very clean, neat, and well documented. 

Note also that I renamed the variable to so it demonstrates better that the program is just waiting for the user to input a value to continue. However, with all these pauses for input, maybe you should explain that to the user so they don't wait for the program to respond and wonder what is going on. 

Your indentation is off there. Each closing brace should have the same level indentation as the opening brace, unless they are on the same line, which is rare. Naming Your names should state what the function does or variable is, and only what the function does or variable is, and the variable/function shouldn't be/do anything but what the name says it is/does. tells me nothing about what the function does. doesn't tell me what the variable does, what it contains, or what it is used for. appears to do UI updates, according to the comment. Loading an object is not the same as displaying it, and loading and displaying from a single method violates the Single Responsibility Principle. 

In addition to holroy's comments, I should not hard-code the values into my method and into the test. I should write my tests to compare the expected value against the value in the configuration I am testing against: 

Your indentation is messy too. Mainly, you should be consistent, and 4 spaces is the typical Java standard. This, for example, is difficult to read and see the scope automatically: 

Notice that I also added a missing space around the operator and shifted the brace up next to the end of the statement according to common C++ style. Also, why are you using capital and variables? In C++, those variables are lowercase, did you do something like ? If so, it doesn't add any meaning to the code, so you shouldn't. None of the really good C++ I've seen ever lines variable declarations up like this: 

I am implementing the logic for a Checkers game in F#. I am writing my code in a library so it can be called from any UI provider, and am trying to do it in good FP style. I currently have the following code; each file is provided in the order of compilation: Checkers.fs This contains some unions and records that will be used throughout the entire library. 

Why define something just to make it throw an exception every time it is used? This is being abstracted from , so if you don't do this, it will use the defined in . If that is not correct for this instance, you should either not abstract from , or you should implement the correct version of this. If you use a block, there should usually be a block too: 

You don't really need that if because the top part only returns when the condition also is . Otherwise, both the condition and the return is . Change it to: 

I recently reinstated the unit tests in Rubberduck. Previously, our parser was a synchronous parser, with everything running in sequence, and we could just request a parse result. Now, however, it runs asynchronously and we can only request parses. As a result, I have to somehow perform a blocking call to the parser, which I did with a semaphore. First, the semaphore blocks the code from continuing to execute, then the event handlers that gets called when the parser state changes releases it (or, if the code parses remarkably fast, the semaphore has a slot available and waiting for the method to take). Below are a subset of the tests for my Introduce Parameter refactoring. While I am especially looking for feedback on how I handle the blocking parser and the way I set up the tests in general, all feedback is welcome. 

Beyond this, your calculator does not follow the order of operations. Probably the simplest way to handle this would be to only update the calculation when the , , and buttons are pressed (like the Windows calculator does), parsing and calculating everything else from the stack. 

First, you can't possibly check for all possible uppercase/lowercase combinations of the answers, and it is looking messy even as it currently is. This is the perfect place to convert the input to lowercase like this: 

For reference, C# 6.0 has a expression, which is called as , and returns the name. This is preferable because it references the variable directly, forcing it to be updated if the variable name is ever changed. Linq Simplification Every time I query the list, I check that the only declarations returned are not built in () and have the type . I can improve readability and performance by selecting these in the constructor as (note that I changed the name as Mat's Mug suggested): 

One thing you could do is create functions to call instead of writing each sub function out every time you want to animate something. 

Your function is very large. It should be split into multiple small functions that are responsible for a single action. is preferred to : 

This is one example of a place you could use another function. You can split that off into an function, perhaps, and call that by itself and get rid of the // structure at the beginning of , replacing it with something like this: 

Fifth, to really be a useful calculator, you should let me input any basic mathematical equation, like , parse it, and calculate the value. Just as a warning, while you could use to do this, don't - this will execute any legal Python program, which creates the risk of malicious code being run through your calculator. You could add some constants, such as and , you could allow calculating powers with the symbol, and much more.