Text is widely considered a much better protocol format. If you decide to go binary, you better have reasons for doing so: 

Another step to simplify code is to filter out the invalid numbers before doing any calculations on them. helps us here: 

So your component test really is more of an integration test, not a pure unit test. There are basically two ways to improve on that: 

It's likely doing several things that could be extracted to other classes or functions. A good candidate for extraction is the function. It seems to me that this has been taken from some 3rd party website or library, as its dash_separated_name doesn't fit in with other camelCasedNames in this class. 1. Replying to your comment: 

Each view would have an array of its subscribers. method would add a new item to this array. And in , after the data has been fetched from server, we'd loop through this subscribers array and call a method like on each view. 

Each cell is instead indexed by named coordinates like . This completely hard-codes this solution to 3x3 grid. Attempting to extend this solution into a larger grid would lead to a lot of trouble. Another big oddity is that in addition to keeping the gameboard state in the grid where it naturally belongs, it's also partly kept in each player object: 

The main complexity of this function arises from using a plain for-in loop to loop over object keys - this adds two extra indentation levels instead of just one level if one were to use a higher-level looping construct. So I would use some library function or create something like: 

Will incorrectly return the index of 'bar1' not 'bar'. Use positional data to locate the keys within the string. All keys begin immediately after a space, and end immediately before an equals sign, and contain no spaces or equal signs. Start by splitting the string on the '='. Your first key will be . Find the last index of a ' ' character in . Everything before that is your first value. Iterate your split results to build a and a , processing the value of key as appropriate based on the assignment type. You can then check if a particular key is defined by looking for it in the dictionaries, and get the value directly. Is there a purpose to specifying the number of array elements in the key, when you already know the number from the value? How do you propose resolving the difference in the case of an incorrectly constructed string? 

Should either be or , but which takes precedence. If you can control the incoming format, and are not dealing with something beyond your control, use and don't rely on the count being placed in the key. 

I'm not sure what feedback specifically you're looking for. There are minor formatting and naming questions, but only two things I would specifically draw attention to. The first thing is that you're enumerating all the settings in the App.config, but you're only interested in settings that relate directly to message delivery. You should name-space your setting keys, and filter the settings before evaluating them. 

On surface it's a well laid out code with bunch of helpful comments and good method names. However, looking deeper the data model of this game looks rather odd. Instead of storing the game state in a simple 2D array as such: 

First off the code is hard to make sense of, because I only see part of it. Most importantly I don't have the source for SessionsStruction class, which you are extending, and the name "Struction" doesn't make any sense to me (is it even in dictionary?). It would also help to have a code sample of using this class. The class also has no documentation describing its purpose - and after reading it all, I'm still wondering what's this all about. Some immediate problems I see with this class: 

Checking for runs A basic check for runs is quite simple. You just loop through all the buckets in order and check for the longest sequence without holes: 

According to the single responsibility principle: no. The App component defines the routing. It feels awkward that it also handles login logic. It seems to be doing too many different things. While the Login component seems perfectly suitable for handling everything login-related. 

It should be fairly obvious how to extend the to support additional BBCode tags. One missing feature is to automatically append close tags if one would input something like . This is left as an exercise for the reader :) 

Well... now that you've learned how to use loops, why don't you just throw it all away and try to write it from scratch. Often it's easier to rewrite the entire thing instead of trying to improve the existing code. Don't be afraid to delete the code. You've learned a lot by writing it for the first time, it will not go to waste - you'll be smarter now, and it'll be much easier to write it the second time. You can back up the original code, so you can always safely return to it when your rewrite fails for some reason. There's nothing to loose. 

Accessors in C# You should read on accessors in C# - your setter does not do what it should - it should set the value if . If this has no meaning (you can't change the value of - you should drop the altogether. Correct use of accessors: 

Make your structs immutable is a helper structure, with public members, which is fine, but you better make them , so you know they won't be changed after the object is created. Choose your validations Don't throw on your own. It may confuse a future debugger. Either throw an or let the runtime throw the for you. Choose your comments Most of your comments do not add much to the methods, and are therefore redundant. Let the names of the method and variables do the work for you. If you feel the name is not clear enough on its own, it is better to rename it (maybe to ) and then you can safely remove your comments. Being nice is better than being strict Unless there is some requirement restriction, I don't think you need to throw an exception if is - why not simply call instead of telling the developer he should? Since there is no meaning for calling twice ( is ...), you might as well hide it altogether, and call it when needed. Use the power of String Use to make more succinct: 

You could also use an automatic mapping library, but before you choose to do that, you might want to look at some O/R mapping library, like NHibernate for c#, which should replace the mapping in your code altogether. 

If you're planning to place a ton of these characters on a page, you might be better of using event delegation, instead of binding the event handlers on each and every element - see the jQuery.on() function reference. 

Regarding a plan to implement them recursively, I would suggest you instead look into implementing an algorithm like merge sort or quick sort, which are recursive in nature. 

Presentation matters. It really does. If you would apply for a newspaper reporter position, would you submit an essay where paragraphs would start without indentation and sentences would end without full stop? Any fool can write a program that a machine can understand. A greater challenge is writing code that other people can easily understand. You need to learn how to properly format your code. Google "JavaScript style guide" and follow whichever you like - doesn't really matter, as long as you format your code consistently. Code structure One of the benefits of a framework like React is that it allows you to split you code up into multiple simpler components which you can then compose into other components that perform more complex tasks. Your code does not take advantage of that. Instead it has been written as a single large App component. The same applies for functions. Instead of large function like you should strive to break your logic down to smaller functions. Giving these functions good names, will also allow you to make your code more self-documenting without needing to write a comment. 

I'm not sure exactly where to start with reviewing this code. There are many things that jump out as unsafe or awkwardly approached. If my source string contained: 

To expand on TheCoffeeCup's answer: When scanning for matches, make sure to order your tests from least expensive to most expensive (or most trivial to least trivial). You only want to be performing the most expensive scan operations when you absolutely need to. Depending on the persistence of your grid and the number of searches being performed, you may find it more efficient to pre-convert your 2-dimensional array of characters into a one dimensional array of strings (one string per row). Expanding on that, searching vertically is essentially the same as searching horizontally except the characters are translated in position. If you create two single dimension arrays of strings - one for horizontal scanning, and one for vertical scanning- you can perform that part of the scanning using the same simple loop. 

I can't tell from the code sample where the loop is being called from. It seems like it's in the update method, in which case you're updating the entire map of rectangles with every change? This would be very slow. In general when dealing with GDI, GDI+, and WPF, you want to avoid doing any unnecessary work, since it is just slow. Only update the rectangles that have actually changed between update calls. You can do this by having a separate map initialisation function that sets up all the rectangles once, and an update function which takes a list of cell references for cells that have changed, and updates just the colour of those cells. 

The element has no attribute. That attribute is for . Also cannot contain text within itself, only inside . There's a pretty long line for deciding between these different displays: 

Business logic or not I guess the general dichotomy is View logic v/s Business logic. So, to decide whether something is part of your application business logic, try to imagine your app having a completely different UI, like a command-line UI. Would the logic still need to part of your application with this new UI? If yes, then it's likely your business logic. Email validation and checking if user is logged in, seem to me as part of business logic. Controllers The role of a Controller is the most vague one in MVC world. That's why there exist several Model-View-* patterns: Model-View-Presenter, Model-View-ViewModel, Model-View-Adapter. To answer your question: 

In the code above you first set and then inside you set again. These two are not the same variable. Do not define instance variables outside class methods, unless you want to do some meta-programming with them. You define method for accessing the variable. As this is such a common pattern, Ruby provides a helper for generating such simpler getter methods: 

As can be see, we simply replace each token with corresponding HTML. When writing out the we also take care of prepending the as needed. Additionally we escape all HTML special chars in URL and within rest of the text - using a little utility function. To tie it all together: