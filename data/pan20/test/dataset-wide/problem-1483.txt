An alternative way of doing it would be to use to find the predecessors on the fly, handing off the caching to the library. Here it is necessary to track the depth as well as the predecessor. 

I can understand having a special case for because it saves you a special case in the matrix power code, but why the special case for ? 

is only suitable if you want to allow me to fetch and then modify its contents. Otherwise you should either use or declare the return type to be . 

and similar: it's generally clearer to have method names without , because if you need to test whether the number is in the row you end up with , and the double-negative requires more thought. I would change it to and invert the return values. 

is not. The x-coord is offset by a quarter and the y-coord by a half. If the arguments to the constructor are centre and size then one of the four quads is misplaced, so on average something like 1/8 of the items which should go further down the quad are being stored in the current node. If the arguments to the constructor are corner and size then three of the four quads are misplaced, and on average something like 7/16 of the items is not being pushed further down. 

That means that could be called with numbers on the order of 800.000.000.000.000.000. Trial division would need to run up to numbers on the order of 900.000.000. That's not entirely unreasonable on a modern desktop, but if you find that the program fails some test cases due to timeouts you may need to implement a more sophisticated primality test. That is quite a large subject. 

The minimiser should take care of unescaping the Unicode escapes. It might be slightly easier for me to find which characters they are, because I can look up the hex values in a Unicode character table. 

That's fine for general-purpose use, but you should consider adding a constructor which takes for testing purposes. 

What's the difference? Answer: the first one is better style. should be rewritten as ; and or should be rewritten as . With good variable names this usually gives a very natural reading. 

For high-performance brute-force combinatorics involving binary strings, bit fiddling is the way to go. You don't want an array of bits, you want an array of rows. Consider that with 

But on the basis of the requirements inferred from the actual code, I wonder whether you might really need the simpler 

To chip in an extra observation: is memory-inefficient. In standard VMs it uses a byte per entry. For storing large arrays of Booleans, it's generally a good idea to prefer . also has methods to clear and set large chunks of consecutive bits which work on a backing and give a major speed-up â€“ although that's probably not significant here, since you're unlikely to find that 

Note that sympy.permutation has some methods to generate the symmetric group over a base set, so constructing can be delegated to them. 

? It should get you about fourteen or fifteen more decimal digits of accurate initial value, saving three or four expensive iterations of Newton-Raphson. 

Unfortunately the dichotomy of vs limits the elegance of Maybe monads in C#, but with the following: 

is unnecessarily complicated. You know , so you can reduce and to one variable, with a more informative name (e.g. ): 

And it's far easier to spot the special case that uses instead of and to either fix it or add a comment explaining why it's correct. If it's a bug then the comment suggests how the symmetry allows three cases to be collapsed into one. 

It's class vs struct. With only two elements, the struct is probably going to be better, but it's unlikely to be a bottleneck either way. 

If the vector is just initialised as then it will initially contain at all indices. Then change to and change the logic in the output loop. Ditch the and output as a special case. 

I would also be tempted to use sublists and eliminate the need for , but that depends on how you're handling memoisation. 

Firstly, those comments are pointless. Secondly, two of the methods are written correctly and two are not. The latter two should be 

You pulled out a method to get a node's height: why not also pull out one to get its size? Again, I would make this a method of . The smaller refactor would be 

Why? If there is no word, returning a list containing no words would be more consistent and would simplify things for the caller. 

To make your code more memory efficient, you could also introduce iterables. I'm assuming that you don't care about the order: 

I'm not sure what exactly the scope of this comment is, but I wouldn't describe the following loop as generating prime factors. 

is inadvertently reimplementing (and probably not as well) a standard primitive. You should use instead. The code 

I find the latter more aesthetically pleasing. It doesn't do a test which it knows will succeed. NB this point is purely a subjective point about style - I'm not trying to microoptimise, and microoptimisations should be done with good benchmarks. 

Python has standard formatting conventions, known as PEP8. There are free tools to lint code to those standards (e.g. this online checker, which was my first search result). Use them. 

Rather than using and and making assumptions about the exact size of one of them, you're using a language which has . I would guess that your s could be and your s could be respectively, although it might be even more complicated than that. ing each logical type would not only provide clarity on the meaning of variables but also help you see where you can use types vs types vs exact types. 

It took some thought to decipher the intent here, especially since 's meaning is not documented. It would be clearer to use or to implement something similar. 

Firstly, the purpose of is to split work between multiple threads; the purpose of / is to avoid the need for multiple threads when handling things such as I/O. So combining with / is a code smell. Secondly, what's ? A field of the class? In my opinion it should be an argument to the method rather than a hidden parameter. Thirdly, that lambda is far more complicated than it needs to be. The code I've quoted above could be 

and the following s in the same style are very weird style. They make me suspect that you've come from JavaScript. A simple refactor gives a normal method: 

makes more sense to me as the name of the constant than as the width of the interval under consideration. Why calculate the width of the interval at the start of the loop, before updating / ? There may be valid reasons, but if so they should be commented because it's a surprising place to calculate it. I think there's a bug. If is exactly the root, will be zero, so neither nor will change, locking the execution in an infinite loop. 

The same complexity but much better memory efficiency can be achieved with a true generator approach which is based on the fact that all you really need to do is count to \$L^X\$ and convert into base \$L\$. 

C# supports operator overloading subject to some constraints, and has all of the arithmetical operators implemented. So you can improve legibility a lot by using standard operators rather than . Local variables in C# normally begin with a lower case letter, so using upper case is not very helpful. In addition, doesn't tell me anything useful: I know that the type is because I can see the declaration, but what does the variable mean? Renaming and using overloaded operators I get rewritten code which IMO is easier to read: 

is wrong. The worst case scenario is that one thread is in the method, about to acquire the lock, and while it's in that state every single object gets freed. That's a deadlock: given the example use case, the loop is blocked unless there's another thread which can make a parallel call to followed by . Moreover, expanding the scope of the lock in and isn't sufficient: the scope of the lock in is also too narrow. 

Since you say you're wanting to improve your OO, why are the methods static? Unless the documentation says that's a safe way to use Scanner, best to assume that it might over-read into a cache and cause problems. Create one scanner around System.in and then re-use it. Given the way you're using it should clearly be a instead. Similarly, given the way you use it seems that each should have a . Use rather than the iterator unless you need to delete. (And although it's a while since I used Java much, isn't generic?) 

Three of the enumerators could be simplified a bit by rewriting to only have one . E.g. Fibonacci could be just 

Performance: with an alphabet of size \$L\$ let \$T_L(X)\$ be the cost of calling this function for products of length \$X\$. Then \$T_L(1) = L\$ and \$T_L(X+1) = T_L(X) + L L^X (X+2)\$ assuming that constructing the list takes time proportional to its length and extending the list of results take amortised constant time per element added. This gives \$\Theta(L^{X}X)\$ complexity. 

This is usually written . But more importantly, what do the values it stores mean? is not a descriptive name. There is no comment explaining what it's for, or even explaining what the method is for. 

In addition to earlier comments, have you considered making the neighbours of a vertex be an indexed property? I think that would be quite a natural notation. 

Now we come to the big tradeoff of speed vs complexity of code. and . If the images are already in 32-bit ARGB then is relatively cheap. If they're in a different format, it can be quite expensive. 

Firstly, I'm surprised to see . Does that mean that two audits can have the same version? If so, that looks like another source of bugs. Secondly, is this really the best way to do that test? I'm not saying that I know a better one, but I would sincerely hope that there is one. 

So you want to find primes. But actually it seems, from the way you use the list, that you really want to find primes between and . If that's the case, 

This function is worth special-casing in a fraction implementation. You already know that each fraction is reduced, so the only common factors can be crosswise. By separately reducing and you can keep the intermediate values smaller and reduce the risk of overflow. (I see you've made the corresponding optimisation in ).