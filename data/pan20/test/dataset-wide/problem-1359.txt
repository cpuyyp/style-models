Read all lines into a (care with large files!) Turn it into a . Turn that into a by flat mapping every to a splitting on the blanks. Collect all elements into a grouping by the identity () and using as downstream such that the map-value will be its count. Get a from the map. Turn it into a . Sort by the reverse order of the value of the entry. Map the results to a , you lose the frequency information here. Collect the stream into a . 

A mapping that can safely map instances to . The only methods to interact with it are and , the ensures that the types are correct on compile time, it also uses which is from Java 7, but you should be able to convert that. The method can safely cast back to , because the method ensures the types. 

Consider changing your programs design. Currently you have an class, with almost everything in the main class. Now what happens if you want to run two instances simultaneously? You cannot do that in one program. I would advice to change the following points: 

I also included that it tells you what the actual input was. Other remarks are that your code has syntax errors, making it borderline ontopic, and your coding style definately needs improvement, I propose the following hence: 

To get familiar with the Rust language I've decided to implement the method of Sieve of Eratosthenes to find primes up to a number N. I have created the following code that both prints the prime number and whether it is prime in tabular format and prints a vector consisting of the prime numbers. As additional library I'm using the external library bit-vec. 

Here we explicitely specify an over the general interface and to obtain it we use the third parameter of , which is one that takes a as argument, which means that you need to provide the map yourself here. Another difference is that we here use a method reference, , over for improved readability. 

I have decided to create my own , because I wanted some abstraction and a couldn't give enough in my opinion. I'm also using the class, as I really like how it is being used in JavaFX 8 and figured it would be useful. The basic properties of a cursor are: 

I'm still working on a parser that can parse log entries from a game called HearthStone, the overall idea is that it will read the log file live when the game is running, parses the log file and show interesting and useful data in real time. The focus for this question is to load the card data from JSON files, as can be found on $URL$ which represent accurate card data in HearthStone. I wanted to not use any external libraries and I know Java 8 came with the new Nashorn ScriptEngine, so I decided to play around with that. The main reason why I did not want to deal with external libraries is that in my opinion creating objects to store all properties of some item down a JSON object is really annoying and I want to quickly have a result available. Of course it turned out to take somewhat longer than I hoped, but I am still happy with the result. 

Ultimately I plan to release this as a separate GitHub repository and provide it as a Maven library. 

As a whole, the best advice I can give you is to consider more abstraction, make your methods smaller and give them a single responsibility. A very important second advice is to use language features that are the standard in this day. 

For you'll need to make your own replacement. I suggest you to also place it in an class such that you can simply remove that class and fix imports once you upgrade to Java 7+. Another important note is that if the catalog and repository classes are bounded by another class (or interface), then you should use that bound in your literals. So assuming that every catalog class extends and every repository extends , you will need: 

For every provided regex it creates a pattern and matches and replaces the occurences with the replacement. It is also important to look into now: 

I do not fully get what your error handling code does though, there also seems to be logic ongoing which is not neccessary, all I see that you are really using is the method call to . Therefore I suggest to add the following to your class: 

The design still seems weird to me though, which perhaps now is even more obvious, why does your error recovery method throw an ? Indicating that your error would need recovery again! 

Obtain a . Convert the array to a , this is the starting point of functional programming. Collect the stream in a data structure, here we want to have a . The unoverloaded version of groups elements on a certain property, here it is . The caveat with the default version is that it returns a whereas we want a . So we need to supply a argument to the method, which in this case becomes a downstream collector. 

The code and documentation look fine in general, so this review will focus on minor optimizations on a per-method basis. Use You can set your with the following: 

Another name suggestion would be to change to , where default semantically means that it does not belong to something else. Other small remarks are about the horizontal white space, please be consistent there: 

your function can fail in a few ways but you only set the when malloc fails, you may want to add some more error codes like when nothing is read. 

Prefer references instead of pointers when you pass arguments to functions, that way you are sure in the function that they are defined and not null. Also you see that it is not clear from the function prototype 

I am not quite sure what is used for in your it seems to be set to 0 and then passed to and never changes its value. It could be instead declared inside instead of being passed. When you do memset, use sizeof the array instead of some number e.g. 

EDIT to the actual code review: writing to calculate size is unnecessary and is hard to read, just write size. i.e. malloc(size) initialize all variables, one day you may change the order of the statements and then you may end up with uninitialized variable during runtime BTW I don't think your code works, when is successful you never set str to point to the new buffer i.e. temp_alloc so by next fgets on the same line (by lines larger than ) you are in uncharted territory. 

after that you can treat the pointers as any other pointer and you do not need to delete them. giveCard This function copies the card from the deck, which somehow seems a bit unintuitive, but ok that works i guess as well. Alternatively you could move the card to the players hand, then when you initialize a new deck just create 52 new cards in a fresh deck. Hand you may want to keep the hand sorted to make it easier for user. display There is no need to have the extra ( ) around ++iter Player You are inheriting from Player (Dealer) but Player has no virtual destructor, add one. It is not necessary to write in Dealer, when you inherit you can access the base class members that are protected/public. If you want to access private members then maybe you should reconsider why you made them private in the first place. It seems wrong to declare the Deck to be a member variable in the Player class - do each player have their own marked deck? I would think it would be better to declare it outside Player/Dealer since they only have a handful of the cards at any time. 

you should check the return value of , it is not always successful. you need to deal with that event as well. e.g. reading many lines and with a memory that is fragmented may cause it to fail to find a large enough continuous memory block. also is an expensive function to call, it is better to allocate larger blocks than try to allocate several small blocks. 

The while loop's expression says it should quit when c is not a digit but after that you do not handle the case if c was EOF. Should you then return EOF or 1 ? Personally I get a bit confused by the function name, when I read getInt() I expect it to return an int instead of getting the value via an argument but that is just me. 

I would like to add to @LokiAstari's excellent answer It is a good rule to write out all possible tags in a switch statement, you have one case which you do not handle also add a default as well to catch any invalid values that may be added in the future. Your / functions I find are a bit too long, IMHO it would be better to split up the function in a couple of separate functions to make it more readable. (Also here you suddenly stopped having any comments). You have quite a few variables in your functions so separating the functionality into several small functions will help with that too. When you write comments have in mind that the reader often wants to know why something is done, not what is being done since that is the purpose of the code. When you initialize member variables do it in the form of 

general impression overall the code looks clean and tidy so it is quite easy to follow some comments/suggestions MISRA and other coding practices recommend to always use compound statements after conditionals to make the code more clear and more foolproof for maintenance 

Initialize all variables: , , etc. your function has some issues You do a call to download (asynchronous call), but you do no attempt to wait for it to finish - instead you directly try to open it. If for some reason the download takes longer then it will fail. If your function fails you get a crash since you do not handle the return value of . I think the better approach would be to split it in two functions, one which does the download and returns when the file is there, alt. timeout with error code. Second part to open the file and returning the file pointer. E.g. 

you have an unitialized member variable called 'top', you use it in GenerateCode and it will be set there, but if you never call GenerateCode, just a simple class declaration will invoke undefined behavior since delete top is called in HuffManCodes destructor. 

Having user/pwd in code, especially in clear text is a bad idea. If you still want them in the code at least encrypt them in some way. As they currently stand anybody can with a hexdump program read them.