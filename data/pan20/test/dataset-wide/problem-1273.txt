Thus you get self documenting code and all of functions for free (for each field compiler generates accessor function with the same name). This also leads to more concise implementation of other functions: 

Writing instead of is not only a bit shorter, it also allows you to change/reorder fields in without updating . Btw, in my opinion, splitting in several lines adds more readability than rewriting it somehow. 

'encrypts' each letter of input string independently of other letters. This could be emphasized by using at the top of instead of hiding it in helper functions: 

ps: I changed the type from (implementation) to (interface) for maintainability purpose, see Interface-based programming. 

I tend to instantiate my collection as soon as possibile. Also, using you are sure that nobody will set it to (no need to null-check == code more readable and safer) 

A better approch to returning is returning an empty collection: it's safer for the caller (no need to check for null): 

But... DON'T REINVENT THE WHEEL! A better solution is the Apache FileUtils class, see method. ps: English is not my mother tongue 

Here is my attempt. It follows ideas from your code but uses function to update vectors. It is subject to fusion hence runs quite fast (test case #15 runs in 0.18s on hackerrank). The code is a bit ugly because of index juggling. Python version does not require this and is much cleaner. 

Working with text is easier with . E.g. it has already defined. Tagsoup understands so you don't need many type conversions. For greater amounts of data it will be notably faster and much more memory efficient. Instead of defining you can convert tag stream into tag tree, take first node and convert it back to stream: 

Some suggestions to improve your code: There is a convention for naming things (see $URL$ Properties should be written in 

A "save to file" method without a valid file is useless. If the file is your method is a no-op without a warning for the user. Code reuse: your code works with TextArea only. A better solution would be a String argument instead of TextArea. Method name: "saveFile" is too generic Exception handling: you should catch the exception only if you know how to handle it or if you enrich the exception with new information before rethrow it 

Haskell is great for it's declarative style programs and most of the first hundred Project Euler problems are easy to write in such a way. First of all, this problem is about ratios, so let us import module. 

In this case changing fields in or won't break . You can enable extension to get only specified fields : 

As lazy IO is considered deprecated, it is better to use iteratees/conduits/pipes to work with IO effectively and in compositional style. Here is an example using pipes: 

The following is my attempt in Haskell. I made comments which probably state the obvious for Haskell experts but it should make my reasoning clear. 

On this side, I am quite happy. I can just iterate through the slices with the given block or interlace scheme. On the other hand, I have 298 lines of code which does this: 

Since there are so many lines and I have a bunch of helper functions, I wonder whether there is some better wayâ€½ 

You can read more about it here. And of course it is better to use instead of simple lists if the code is full of lookups. 

Using is justified only for big numbers, in your case using is enough and could be a bit faster. Here is another solution: 

It is really nice that you provided domain-specific type aliases. This makes type signatures more readable and allows to easily change underlying data representation as in this case. 

2) Your main feels strange, I don't like this creative use of postdecrement and greater then operator 

In this case a loop is better because you know the number of iterations. 3) is bad and force the developer to read all the code to understand how to break the loop 4) No need to pass a StringBuilder to reverseVowels: the method itself should create it. 5) Use temporary variables to improve readability: 

, and become , and becomes and so on... Comments No need to comment each line of methods, you can split your code into simpler methods, example: 

creates cycle from a list. skips some characters and returns list starting from . Try it in ghci ( is infinite so be careful with it). 

I switched arguments in because this allows to define function more concisely and it is also correlates with update/insert from : they have collection as a last argument. Now it is possible to skip directly to and implement it in couple of lines: 

replaces letter by searching for another one positions away. I'll implement this literally by creating cycled alphabet and searching for letters in it. This is inefficient but allows to get taste of laziness. 

I currently try to learn some Haskell to improve my overall programming skills. To practice, I implement the C course exercises that I very familiar with. One is this: 

The code must be C++11 and compatible with GCC and the Intel C++ Compiler. Do you have suggestions to achieve the same results but with less dense code? 

We go through the blocks, and within each block combination, we take all slice combinations. The block combination with switched sink and source blocks is to be done right after because we can re-use a bit of data with that as well. For the functions of type , we want to iterate from slices to blocks, like this: 

Consider the use of to mark overriden methods so future you (and other developers) understand the origin of your methods at glance. 

fields are bad practice, fields are even worse! A means that ALL your s share the same as . You should keep private the internal state of your classes, see $URL$ Instead of a list of s you should create a list of generic objects. Your class (I'd rename it to ) could be rewritten as