Dealing with bad input If the user provides bad input, whether on purpose or on accident, you are not dealing with it at all. When extracting the , , and , check whether the input stream is still in valid state. If not, print a message and go to the start of the loop. 

Logic error in LinkedList::Remove The posted code does not take into account the possibility that the given input corresponds to the of the list. 

I would encourage you to change to use for its coordinates instead of . However, I have a hunch your program is getting killed by too many creations and deletions of in . I would update the function to not create at all by moving the logic of to . 

I tried the following change to your function. It does not use . It does the tokenizing in the function itself. I got a little bit of speed up. 

Create a base class called . Create sub-types , , and . Make sure has the necessary virtual member functions that are needed for supporting the high level functionality. Implement , , and in separate files. When the need for adding comes, it will be a very simple process. Create a class that captures the quantity part and the length unit part. Remove altogether. Make a regular class, not a class template. 

I would go with . The fact that it is reference counted is evident from the goal of . Provide a version of the function The current version of is a non- function. If a function has a object of type , it won't be able to use the function get access the contents of the object. You should provide a version of the function. 

and replace all usages of by just . Simplify a few expressions You have repeated usage of and . They can simply be and . Give some computations a name You have the following expressions: 

That produces a compiler warning from g++: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] I suggest changing that to: 

The generic target building rule will take care of building the executables from the dependent .o files. 

I think you can use templates to good use to simplify the user interface and still retain the flexibility. I would suggest declaring some s instead of using . 

Since these functions are recursive, the check for whether the tree is empty should not be added here. Instead, they should be added in the functions of the same name. 

Suggestion 1: Create a separate function to get user input I would put the code to get user input for and in a separate function. Also, add the option to let the user quit the game if they want to: 

Traditionally, the variable is used for the C compiler and for the C++ compiler. I would recommend changing 

I don't know that they compute but they compute four different things. It will be easier to understand your code if you can give those computations a name and put them in a function. 

Use a better name than I would prefer to use something like or . Update The functions will be problem when is . If you like to use the functions for all types, it will be better to change to a different function, such as . 

You are forcing the user to construct a temporary object before they can use the allocator. It will be better to leave to do couple of things and do them well. Allocate memory when needed and deallocate memory when it is destructed. You can let the client classes use to implement and . I would add a function template that returns an . 

Adding as a unit When the time is ready for adding as a unit, all you need to do is create a file with the following contents: inch.hpp 

For the same reasons as above, can be removed from being a member variable and used as a function local variable. For the same reasons as above, can be removed from being a member variable and used as a function local variable. I don't see the need for as a member variable either. You are asking the user to provide it at the time of encrypting the password and decrypting the password. Why store it in the class and the file at all? It can be used as a local variable in the functions where it is needed. 

My suggestions: Use a to define the classes/functions for the game Using s is good way to contain all the classes and functions that help define the game. 

Make functions still smaller You have functions that accept input, process the input, and display the result of processing the input. You can separate the first part the last part into separate functions. That will make your code easier to follow and maintain. For example, can be: 

to test the code. Change to just after the has been introduced The part of becomes redundant since is now a . 

In addition to all the helpful suggestions made by others... Using a console interactively to get input is so old style!! It's more convenient to have the input data in a file and just read them directly without the lines for the prompt. Just use: 

This will work only if you declare the function a friend of the class. Move parts of the class to the bottom The users of the class care only about the section of a class. Hence, it makes sense to put them first in the class. The section of a class are, to a large extent, implementation details. It is better to put them last in a class definition. 

Main Suggestion I think it will be useful to have couple of overloaded functions, one for working with s and one for regular s. With a , pay the cost of making a copy, reversing the copy, and returning the copy. With a , you can avoid all the above costs. You make all modifications to the string in place. 

PS My suggestion for can be a problem if used in an interactive application where objects are constructed and destructed based on user action. For such use cases, the memory allocated by the application keep on increasing. There are other ways to manage the life times of objects for such applications. Your code, updated with my suggested changes 

I'll leave the implementation of as a detail. Avoid I would recommend using an overload of . That makes usable with all kinds of objects. It also makes the task of outputting objects of the class more idiomatic. 

There is no need to use a nested class template for . should use the same template parameters as . After all, you will not need to have a tree of in a . You can just use: 

You will be able to avoid one call to by returning from the function or breaking from the loop when . Of course, you don't need to check whether in that case. 

After seeing your code the first time, something didn't feel right. I couldn't quite put my fingers on the problem. However, after going over the code a few times, I came up with a few things that can be changed to improve the code. Using the right nomenclature I think the nomenclature is wrong. Metre, kilometer, and mile are better thought of as units of distance instead of being distances. 12 metres is a distance but metre is not. Your use of distance and quantity is not quite right. Distance is a quantity + a length unit. When we say distance from point A to point B is 5 kilometres, 5 is the quantity and kilometre is the length unit. Design of the and various classes It occurred to me that your design violates The Open/Closed Principle. You have the following that's the lynchpin of your entire program. 

The only thing I could think of that would make your program potentially faster is: Initialize the member variable using initialization list syntax 

I would change to work with a functor type and use a traits approach to deduce the return type and the argument type. 

Now you have a framework where the basic objects are in place. The only things that will keep on increasing are the types of errors your application deals with. That's easy to do by sub-classing . Here's a small program that shows how they can be used: 

Using vs hand crafted function to reverse a string You can reverse a string or part of the string using like you have in your code: 

You don't need the variable. The variables , etc. should be , etc. The type of can be . I also think that is a better name for the member. 

If you do that, the only member data needed in will be just the ID of the event. Suggested event handling code 

My suggestions: Move from being a public member plays an important role in the event manager. Making such a crucial part of the event management system a publically accessible member variable seems risky to me. I would make that accessible only as a member function. 

That will make some of the functions simpler. BTW, you have a memory leak since you are not deleting the stack of minimum values in the destructor. Replace with Use of 

which will print the values using an index that is off by one. I would recommend converting the loop to a loop: 

If you would like to use a for that function as well, you will need to use another class called . That is analogous to the use of and in the container classes in the standard library. 

I understand that the reason for your post is to find a method that will be faster than the one you already have. However, the posted code has the potential to access memory that is beyond the valid limits. For the sake of making a point, let's say that on your platform, is . Your input strings are and . Given that, evaluating will end up accessing memory past the terminating null character of . In theory, that is cause for undefined behavior. Here's my updated version of your function to make sure that you always access memory within the valid limits. 

A similar change can be made to Removed unnecessary use of In the function , the argument type is . The in that type has no benefits. I would change it to: 

Other suggestions There is too much codde in one file. In addition to many helper functions, you have the following classes: 

is executed no matter what. Also, as has already been pointed out by the other answer, you need to use 

Use right type names Don't use where other type names are more appropriate. You can use to avoid such issues. I would recommend replacing 

A matrix multiplication algorithm usually involves three loops. The fact that you are using two loops and use some obtuse logic to reset indices point to unclear thinking on your part. As a matter of fact, there is an error in your logic and is easily exposed if you allow for multiplication of matrices that don't result in square matrices. If you change 

length_unit_impl.hpp This file has couple of helper function templates and a class template to make implementation of concrete s as painless as possible. 

Other suggestions: Add functions instead of This may be a matter of stylistic preference but I think it is better to use: 

Update, make the name of a It turns out the name of a can be a consisting of characters for which is . Changes needed for that: Change to 

There is no need to return a . It can be just . If you want to return a , you need to change the statement to: 

First of all, I would change to . is the better term to be used as a super-class of , , etc. When I think of the Strategy Pattern I think of a set of concrete classes that implement an algorithm. While your use of provides a mode of transport to its users, I think use of something like would make your example more appropriate to be called a user of the Strategy Pattern. 

Separating the data involved in the program to three distinct abstractions makes it easier to understand the code. It allows the program to be divided into smaller chunks that are easier to understand. From a functionality point of view, it is better to divide the functionality into two main functions. One can independently implement them and check them for accuracy. Construction of the set of equations is separate from solving them. One can implement the code to parse the set of equations without solving them. The parsing code can be verified for accuracy before passing the parsed data to the solving function. Solving the set of equations is independent of the method to construct them. The function to solve a set of equations can be implemented and tested with a set of hard coded equations. Once both functions are independently tested and verified for accuracy, they can be combined very easily. Here's my implementation that captures those notions.