I would use instead of the field accessor for two reasons. First, doesn't show up in the Haddock documentation for which is a bit confusing. Second, on the off-chance that the author of begins hiding the constructors of from export (which is very common practice in Haskell so that library authors can change implementations without breaking users' code) you'll be safe from breaking changes. Knowing the instance and available functions, you can now write a clearer version of . Unfortunately we have to be a bit cautious of bounds, throws an exception if you try to get the successor of , but it's not too bad. 

Intermediary representations of data can always slow down your code, but with aggressive inlining I don't think this would be too much of a performance hit. 

Now, are and equivalent? That depends on whether checks to see if you've been passed a with equal length sides. If you compile with GHC will tell you about partial pattern matches in your functions as well, but if you forget to include a guard you're on your own. E.g., my version of will not compile if you don't include the case, your version will fail at runtime if you leave out . In the example of , the guard version will perform three comparisons on . The default definition of defines all of the comparators (, , &c) in terms of , so in the worst case you'll have to call three times to figure out which guard matches. In the case version compare is called only once and its result gets reused, potentially saving a lot of time if the implementation of were costly. And lastly, having a set style and preference leads to consistency, which is always a boon to readability. I did it, therefore I do it. 

Copied from my earlier comment. I think you may be feeling unsatisfied with your solution due to the negligible benefit creating a new type has gotten you. That is, you could change the function to and not win or lose any benefits from static typing. Have you read this paper that solves FizzBuzz by refining a solution based on a command type? FizzBuzz in Haskell by Embedding a Domain-Specific Language Sometimes the most useful types are those a step abstracted from your actual problem. Developing an intuition as to when this is the case - and knowing what types to actually use - is a challenge! You may find some success in working through Pearls of Functional Algorithm Design by Richard Bird. Each chapter is much like the FizzBuzz paper linked above, simple but inefficient solutions are iteratively refined into equivalent, algorithmically efficient versions. 

Somewhere between primitive recursion and grossly clever one-liners we can find a happy medium using functions from the Prelude. To start though I'll look at the cosmetic. Immediately I'm confused by name and signature of the function, the square root is a function of a single number, not two. It's confusing for your function to be named when typically the tick mark is used in Haskell to distinguish strict functions from lazy ones, or to name successive iterations on some value. When you're browsing your Haddock documentation later or coming back to this code in three years you'll be stupefied by , but probably have a pretty good idea what might do. Next, I would rewrite the function so that isn't copied around everywhere. Since its value doesn't change, make that clear. 

It's a little dangerous to define a top-level constant like , the name isn't descriptive or distinctive and you end up shadowing it quite a bit. A compiling but incorrect typo is almost inevitable. Since you gave it a definitive comment, why not just give it that name instead? Try . I can see why you may have used a statement in (to save typing out repeatedly), but I have a strong preference in the other direction. All pattern-matching which can happen at the top-level generally should. 

Besides the aesthetic appeal of this solution, to me this illustrates the power of thinking about what you want to do in Haskell, instead of thinking about how it's going to be done. 

Note that the divisors now start at 1 and end at , so includes in its function composition pipeline. The inclusion of should be obvious, it causes 1 to be excluded from the list of divisors. is there in case is prime, that way itself isn't included in the list and we get back . Note also that in your original version using caused many evaluations of . Instead of testing the elements of the list of possible divisors an important optimization is to cap the list range to . Of course if we start getting mathematically rigorous in our optimizations there are many better ways to calculate prime factors (including starting with a list of actual primes), so let's not get lost in the weeds. An alternate way to implement that is closer to your original would be to use from . I think this version is important for two reasons. One, there really is a function for everything in ; learn it, love it, live it. And two, this implementation reads the most like prose to me, readable code is maintainable and beautiful. 

It's useful to encapsulate this because there's nothing about martingale betting systems that involves a random element, the system itself is entirely deterministic. 

Performing any modulus operations at all is unnecessary though, it's obvious that in the range only the final element will satisfy the modulus operation. Instead we can directly build the list of booleans from what we know about the length of the period. 

Notice that you use both and in the same scope. Use pattern matching instead, instead of using as an intermediary identifier you can directly expose the components of the tuple and probably give them names that help your code be self-documenting and thus clearer. 

I'm not sure that there are appreciable improvements left to make to . You could use and , maybe record update notation, but I don't find it that bad to begin with. Use even more -notation in to unify the handling, and extract the commonalities. 

You should recognize the similarity to your function . There is no way around the fact that growing a list by elements takes cons operations. When you want to add one element to the front of a list, you use and that's it, you're done. When you want to add one element to the back of a list there's no constructor for that, you have to consider that element to be a new list of length one, and prepend your original list in front of it, causing you to have to walk down every single element of the original list. That is “slower” than the other case, but if the ordering of elements in your list is important you gotta do what you've gotta do, right? 

This is still unsatisfactory, right? There's that convention-typed tuple, and we've got a perfectly good datatype lying around, so let's use it. 

This is probably as far as I would take it having started out at your original version. There aren't any real further improvements that I can see, just matters of personal style. If I were to write this from scratch though I'd probably produce something that looked more like this. 

Sorry to say this is not good practice. Exactly why is a bit more technical of an explanation than I like to give off the cuff, Google for "Haskell typeclass interface" and you'll find a bunch of threads comparing and contrasting and recommending you use an ADT. Here's one from Reddit with a game programming example that I think is particularly practical. In your case, I imagine you intend to provide different configuration methods (XML, command line flags, &c) which would also be instances of . You've already realized that you want to work with some abstract thing elsewhere in your program and not a , because whatever is using a configuration value doesn't care where that value came from. The next logical step is that by making a class, you actually are still passing a around everywhere, you're just relying on callers to never look more closely at it than as a generic instance. You've got implementation leaking all over the place. Instead, making a datatype. 

Just something to think about. Note also how I aligned both cases of the function on so their right hand sides start in the same column. This can be tedious but aligning things like multiline functions or lists can really help readers of your code as they scan through, the extra whitespace and visual similarity helps stop your Haskell code from looking like word soup. You could do with another few type aliases as well to clear up the purposes of s and s in your program. At the very least I'd give— 

(It would be even better with "" in place of the range, given a top-level list of prime values by that name.) 

Aha! QuickCheck has determined that our property doesn't always hold. Each line printed after "Failed!" corresponds to an argument to the property. This might appear a little confusing due to the use of (the unit or void type). Because our property was polymorphic, GHC picked a default. You can specialize the property to get output with other types, try . (You may have gotten slightly different output, that is okay and expected due to the generation of arbitrary data having been random.) By itself this might not tell us enough though, why did these two arguments produce a failure? You can get all of the cases that QuickCheck tried by using instead. 

What an utterly bizarre problem statement. For one thing bikes don't have check engine lights... I guess this boils down to “find the minimum value within a list subsequence” which you've got nailed. You have the right idea with but there's no need to flip the list turnways. The clue is in the name you picked, . 

You have some logic/naming misconceptions in places. For instance, is really checking that your rows/lines are the correct length. isn't syntactic sugar, it's a no-op. Its implementation should be , because what's really interesting about it should be the type. 

As @200_success mentions in a comment, this isn't a kosher use of . I believe though that it is the property of antisymmetry that is broken, not transitivity. \$Rock \leq Paper \leq Scissors \leq Rock\$ means that by transitivity \$Paper \leq Rock\$, which violates antisymmetry since \$Rock \neq Paper\$. This may seem academic, but many library functions will break or produce incoherent results given your instance. Try to guess what will return. Don't get in the habit of writing bad instances just because you like their namespace. What you should do instead is just write a grab bag of pure functions and domain-specific datatypes. This would look something like— 

From there we can deploy our usual bag of tricks higher-order functions to write this more idiomatically. 

You can use in place of . Given the type signature of the return type of must be in order for the type system to unify what you've written, making your type annotation on the function implementation there redundant. You can perform eta-reduction on then (that is, write it in pointfree style) and drop the for an implementation of— 

Notice that we've eliminated the predicates from our first list comprehension! I'll get back to that in a bit. Our next step is to lose the contrivance from the definition of , this bit of functionality would obviously be better expressed by mapping over the range instead of using a list comprehension (again I only did so to minimize the changes between steps). 

and are unnecessary functions, their names are pretty much as long as their implementations! They clutter up the top-level, they don't do anything surprising or interesting, I'd just use their implementations wherever you need to instead of adding another function to your mental burden. 

is a little abusive of case statements and guards, plus you end up performing a lot of comparisons when you should really just go by the ordering gives you back. 

I think your first version looks pretty slick. You could use a let-binding to do a little reordering and naming. 

can be cleaned up by favoring pattern matching over guards. Whenever you see a wall of guards that depend only on , consider pattern matching instead. 

You can see most of the program is devoted to input and output, and only two lines (three if you count the function type signature) are required to implement the algorithm itself. Here's the trick. The loops can be reordered so that instead of mutating an input array, you're actually producing an output list of multiplicands. 

Best practice would be to separate the pure operations of your program from those that actually require IO. Counting the frequency of elements in a list doesn't require any IO, so you should tease that function apart into its constituent components for reusability, testing, comprehensibility, or whatever other purpose you'd like. 

Take some time to familiarize yourself with the functions available in and . There are many easier ways to write . As always, consider the types and use Hoogle. Looking at think about the type you would give that function on its own. is an , and is any type . So you'd have a type like . The first hit is for , which does exactly what you want. Next consider what easy intermediate values you can construct that get you closer to the result you want. The first step would be to replicate each element in the original list times. That sounds like a job for . 

And if we look back at the documentation for , sure enough under the section heading "Searching with a predicate" looks like it does what we want, just note that it returns a value. This is of course because the predicate we provide might not match any element of the given list, which now obligates me to point out that you should always code defensively and consider the totality of your functions on any given input. I'll address some concerns in iterations on my solution but here's how we'd put it all together. 

In you can use instead of . and look to be dead code. You recognized that columns are just rotated rows, but then still duplicate a bunch of code to check them instead of reusing the function. I.e., 

As far as I can tell your solution is not only slow but incorrect because of your usage of . Dropping that single function from your pipeline nets an exponential improvement, and it stopped including the similarity of to itself in the answer. Make sure also you're compiling with , otherwise won't be optimized into a strict fold and you'll blow up the stack with thunks. I also came up with a version targeted toward readability, but it's ~3x slower than your (corrected) based version so I'll just include it here as a curiosity. 

Now given the original height of the tree and the cycles it will experience over a given span of time, we can find the resulting height of the tree. 

Common Haskell style is to use camelCase instead of snake_case, so instead of . Wherever possible, Haskellers usually prefer case analysis to equality testing. If you rewrite to exclude testing (which is a tautological case anyway, why bother evaluating it?) you can check if the list returned by is null with , which enables more function composition goodness. 

Right off the bat whenever you need to associate one set of elements with another, you should think of a map. In Haskell, you'll want to look at the documentation for . By reordering and reconsidering the operations you're performing on lists and sets, you should be able to rewrite your code to use maps and significantly cut down the amount of code you have written and end up with something more expressive too. As it isn't clear that you've actually turned in this assignment I'm afraid I'll have to be coy, but here's the most pointed help I can give you on your specific questions. Regarding removing duplicate words, the trick is to rely on the fact that maps can only contain a given key once. Pay close attention to the various ways of constructing a list that are specified in the documentation for . Filtering out the non-letters in a string doesn't get much simpler than in your code above. The dissatisfaction you are feeling might be because of the gross duplication between the definitions of and , and and . Any time you have two lines in Haskell that are identical but for the value you're operating on, your code is crying out for a new function definition. Your code is lingering in IO far more than is necessary, pull the pure data manipulating machinery out into separate functions. To start you off, knowing no more than the type signatures I've given here, what do you think these functions do? What part of your code do they replace? Take a shot at defining them.