So, having said the above, I would recommend your re-introduction of the classes in to your code, and ignore the synchronization and volatile aspects. A Reentrant lock and condition would be good for waiting for network availability. 

You define a "coordinate" as a single int64 - but, a coordinate is at least a 2 dimensional thing..... right? What you have there, is a distance. You call it a distance in some places, but in other places it makes the code funny... for example, here we have a function called which returns a ... ??? ...: 

@chillworld is correct in his observation that the issue is related to the int overflow causing the problems in the performance tests. The more accurate solution to this is to use a to set the score, instead of an . 

you create a new BigInteger value, with the corresponding overheads, and memory allocations, etc. This could be a lot of allocations. The native Java routine breaks out of this situation by using primitive values and arrays, and keeps a bit-vector that is mutable for the duration of the addition cycle. By doing it that way, there is no memory management penalty.... A second issue related to performance, that is not obvious, is that the real BigInteger class does things both ways ..... it does a bit-vector for large integer values, but for 'small' values it uses a simple java primitive. In other words, it simply does if the two inputs are small enough for long value representations, and also if the sum will fit in a primitive . In other words, it is much faster for smaller values than for values that exceed Algorithm I have, in the past, tried to out-perform BigDecimal (not BigInteger), by building a mutable version of BigDecimal. It became really complicated really fast. The concept of a MutableBigInteger is nice, but the reality is that it becomes a mess, fast. There are some open source attempts at this, though I believe they are all languishing in disuse. The reason is simple.... BigInteger is, by an large, fast. The penalty of the Immutable memory hit because you need to create new values and arrays often, is outweighed by the cost of memory management and expansion that is required otherwise. Finally, the individual operations inside the BigInteger class are able to use the native storage mechanism directly when doing calculations, and you don't need to do the translations for each bit, for example. In other words, 'wrapping' BigInteger is never going to give you the performance that BigInteger itself can give, simply because the internals of BigInteger can access the more efficient internal data structures. 

The all do nothing (except the very first cell at ) because they become zero-length strings. Thus, only the first line, and the first value get printed. To compensate for this, you are printing an constant-string value to complete the line, but, the first line is one character longer (because you printed ) than the others, so the first line has to have a single-char shorter constant to complete it, and you need the condition. I have made this obvious by initializing the array with an () in this ideone which produces: 

Your expectations are unrealistic. It is not reasonable, with current mobile technology, to brute force a password in any realistic time frame. There are three factors that you should know here, though... 

Error handling is boiler-plate that can be made more readable by separating the error conditions out explicitly. In checking/refactoring this, I found an apparent bug, too (which was hard to spot because of the compound exit condition). The bug is that if the arg-count is more than 1, you print the message "Excessive arguments, only the first will be considered" but then terminate anyway..... so much for ignoring the subsequent args... I would prefer: 

which is the difference. Note that the math is more complicated if the b value is larger (a negative result). Compare the above with a and b : 

I prefer the read-the-whole-file concept to the stream concept. It makes it clear that there are memory-requirements. Additionally, it makes the logic clear. I would also consider a mechanism for handling raw lines without messing with the line termination padding and characters. Your code strips new-line/carriage-return characters and replaces them with just newline characters. I would prefer to see the line's end-of-line sequence unaltered in the transform. To do this requires a more careful consideration of what methods to use.... None of the methods, nor the default nor methods do. You have to override these things. Consider the code: 

Thus, you can accomplish the conversion with efficient switches, array lookups, and 'simple' math in the loops. I have put together an Ideone implementation of this code so you can compare it with your code. 

I'm just going to point out one significant issue because I believe it will require a re-think on your implementation.... When you use an ExecutorService it manages a number of threads, and ensures that threads are busy working in a way that's relatively easy to control. You have a system set up where the intention is to have a pool of threads managed in a way that allows multiple uploads to happen at the same time, and to limit the concurrency to (which should possibly be changed to ). Unfortunately, your intentions are not represented in your code. You don't have those controls at all, and your attempts to control the concurrency, and even the attempt to be asynchronous, are all thwarted because you create the and inside the method call. Every time you call the function you create a complete new environment that is independent from other calls. There is no sharing of anything, and no control... and only one of the threads in each thread pool will be used. You probably want to do the following: remove the two initializers from the method, and instead make them private fields, perhaps even static, depending on the class the method is in.... Then, because you cannot control the orderly shutdown of the thread pool, you probably need to have some form of controlled method, or you need to ensure all your threads are Daemon threads.... I would consider something like: 

The logical solution here is to sort the data in order, then scan it looking ahead for the partner that has the right difference to the target. Slicing, and combinations, etc. are not going to be the most efficient algorithm. A sort with \$O(n \log n)\$ scaling, and a simple 'look ahead' to find a potential pairing, will be much, much faster. If your data has duplicates, then you will need to look for multiple matches for the correct difference. Consider doing a binary search for the target value, which will still leave you at an overall performance of \$O(n \log n)\$ algorithm 

so why force the 0 in to the value for ? In addition, the magnitude of an int64 is never going to exceed half the magnitude of a uint64, so a double-overflow is not possible, and the logic required to check an overflow condition is a case of checking the change, or the direction of the change, of the sign-bit of the equivalent int64 value. Perhaps this is best described if you handle the complete calculation in int64 space, and convert the result to uint64 - and realize that the MSB of the uint is the sign bit of the int. The following conditions are all OK: 

Negative if Your main if-block would be better if done as a positive check, not a negative check. your code is: 

First up, that inner part is doint a "side-effect" operation that can be avoided. Functional-programming purists try to avoid side-effects in streasm as much as possible. SOmetimes it is unavoidable, but you could easily re-write that line as: 

If your test values are from 0 to and are the same as the ordinals of the enums, then I would completely get rid of the test value, and have the code: 

Often, when performing text manipulation, Regular Expressions can do the work for you. Your solution is essentially manually building a text parser and stripper, when a regular expression will do the work in a much more concise way. The regular expression would be to remove all text up to the last or character, which would be written as: 

Also, the implies the exit is successful, use a non-zero output for an error condition (); Declare-where-used You have a number of 'fields' which are declared at the class level, but only used briefly inside specific methods. For example, is opened, and closed. There is no need for it to be a class field. The following would be better: 

Consider the following code in the . This code handles adding and using event handlers (though removing handlers needs to be fixed as well).... 

Going through that list, your code defines . I agree with , and . Those are 'easy'. IMMUTABLE - Is it possible to change the source? Can a thread change a page that is being crawled? Yes, I don't think it can, so I do not agree with . - is it safe to modify the source while Spliterating? Yes, I think it is. The Documentation for includes: 

This problem is a common problem in coding challenges, and it's a nice one, because there's a really elegant solution which is really fast. It does not even need dynamic programming.... just a little trick of logic. Your solution takes each position, and for each position, sums all values to the left, and right, then it repeats that until it hits a match. Your solution thus scans all N elements about N/2 times (on average, you scan half the data until you hit a match). This makes your solution a time-complexity of \$O(n^2)\$. If you double the size of the input, the solution takes 4 times longer. Now, a simple solution is to scan the entire data once, and calculate the sum of all the values: 

Your query is well structured, and consistent, but there is one issue you have failed to incorporate.... not all bad questions have a user. When questions are migrated, or there's a user deleted, the question may have no link back to the Users table. This requires an Outer Join to Users. Additionally, I have found that CTE expressions are fantastic for aliasing column names. For example, both Posts and Users tables have an ID column, and you need to have and in different places. Both also have a . When these aliases become long, and complicated, it bogs down the readability of the query. Oh, about the readability, the case statement is dead code. Don't use code that serves no purpose, or, alternatively, "debug code" should be removed before deployment. If you cannot trust yourself to have the right conditions on the query, then you cannot trust yourself to have the right debug code either. So, if you alias these values in a CTE, and use the CTE to make the Outer join neat, you can reduce your query to: 

Your code's general structure is decent. The Single-Responsibility-Principle is established by having relatively clear logic structures in the , and methods. While the basic structure is fine, the actual bitcount algorithm is very inefficient. Recursion is not the answer to this problem. Even if recurstion was the solution, I don't like how you find the low bit, and I don't like your terminal conditions. Additionally, actual bitwise operations should be used to count actual bits. Additionally, your continued use of 1-liners for conditional blocks is disheartening. So, if you have to use recursion, something like: 

You can improve it by making it a loop instead of a recursive call. There is no need for the recursion, and it limits you in ways that a loop would not (for example, you are limited by your stack size with recursion). Additionally, the loop implementation is simpler, and probably a bunch faster too. If you do stick with the recursive call, you should make the recursive method private too. The loop could be as simple as: 

Since your current zoom is consistently bound to 0 and 100, you can rely on bounding the difference only. See this running in ideone. 

all expected elements in each row are present all expected elements in each column are present all expected elements in each mini-square are present. 

Algorithm The algorithm works well enough. You have captured the essence of the problem in your code, and reading your code it is apparent what it does, and why. This is a good thing. It is not very often that the intent of the code is so easy to discern. The draw-back of your algorithm is that it is not going to be able to support the more esoteric operations like parenthesis e.g. .... That sort of support will require a preprocessing step. Keeping the equation as a string is convenient for some things, but i would have preferred to see the process broken down in to components, for example, a parse step could break the input down to . at the same time, it could be trimming the white-space. Then, you just need to scan the and find 3 items separated by the highest precedence operator, and swap all three with the resulting value. Code Style You should read through the Code Style Guidelines for Java. This code, for example, has a number of faults: 

With this code, there is no need for the 'Top' sort method at all, it's superfluous. Your recursion entry can change from: 

I have exaggerated the indentation to make it all visible..... Now, gives us some extra methods over just-plain-Map... You should use them. First up, this "check" method. @maaartinus correctly identifies this as being a problem with the name. The standard name used in many libraries (including the Java Native libraries, is . 

When presented with problems that require and input value set, and an output value set, it's always best to express the problem as a function. In your case, the problem is: "Given an input room number, what floor is it on?" This type of question can then be expressed as a single function: 

The above code will pre-print the message, and then each loop iteration it will erase 5 spaces, print a 3-wide integer value (padded with spaces), followed by " %". It requires the appropriate escaping for . Update: A few additional things: %3d -> You request details on what the does. It prints a minimum 3-character wide string representing an integral amount. if supplied with the integer it will print (two spaces and a 0). If supplied with it will print . If supplied with more than 3 digits, or more than 2-digit negative numbers, it will use as many characters as it needs. So, for it will print , and for it will print . You can read up on the documentation for the Formatter class to see how this works. Examples and tutorials are available online which will help too. Error Handling - you should do more than just . There are degrees of error handling, and depending on the conditions there may be reasons to ignore, log, wrap, dump, throw, record, combine, or just count exceptions. But, never should you do a System.out.println(e). This just prints the toString of the exception, and that's not very useful. You should probably at least use 

Just use a LinkedTransferQueue and deal with duplicates elsewhere (use the add and poll methods respectively). Just use a List with a simple and basic synchronization. 

This is a compromize I use quite often. It gives you an abstraction between the class-load initialization, and the runtime usage of the enum. It has the following benefits: 

and then, you have a reference to that you are not releasing. If you say , then the garbage collector will release the pixel data as well as the texture object. Instead of finding all the places in your code that use the texture, and calling and they should just set their Texture variable to null, and move on if they no longer need the Texture. If you are not releasing your pixels after doing that, it means you have some place in your code where you are still holding references to the Texture, perhaps some value in a HashMap, an array, or somewhere else where you are holding a reference. Remove those entries, and you will be fine. Note: it is possible that your program is part of a very, very, tiny, small proportion of programs that may need finer memory control, and need to keep a Texture cached even though no-one is using it at a particular moment in time. Java has Soft-References that may help, but that is not likely to be your solution, and is more complicated than this post warrants.... 

is not a great name for something that is a list. It is typical in computer programs for to point to just a particular element in a list, stack, or whatever, not the whole thing. Something like , or would be better. Then, you are not closing the InputStream. This is bad practice, and is a bad habit to be in. Java7 allows the try-with-resources statement, which is ideal for this code. Now, there is the less-commonly-used method stringPropertyNames() available on Properties. It is useful here, instead of iterating on the . Why are the and methods public? Do they need to be? They should be private to the class if they are not used. Constant values embedded inside code are often called 'Magic values'. In this case, the values are Strings. You should declare a constant for your resource names.... Putting it all together, how about this method: