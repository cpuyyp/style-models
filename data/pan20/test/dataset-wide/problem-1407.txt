There's also a trade-off between complexity and trusting your user. The example use case calls , but if someone uses the pool badly they could leak the objects by losing references to them without calling . If that only occurs in a rare error case it could pass unnoticed for a long time. The paranoid option would be to return an wrapper around which also has a destructor to ensure that if the reference is lost it automatically frees the wrapped object. 

None of these need as wide a scope as they have. In particular, and are only used inside the nested loop, and are initialised every time they're used. They should be pushed in (if not eliminated...) 

I'm not entirely sure what this code does, but it certainly seems too long for the problem. First some general review: 

Clever code needs clear commenting. The proof that your code works should be in comments in the code, not in the revision history. 

is not a useful name. Whether or not you should swap the elements depends on factors which are outside the scope of that method. But abstracting it does serve one purpose: it makes it clear that there's a micro-optimisation. If two elements compare equal () then there's nothing gained by swapping them, so I would favour over and a rename to . 

What does do? Do you need a special case to handle ? It's not obvious here why should not have masked out. I think I can more-or-less figure it out by reading the whole method, but IMO a comment wouldn't hurt. 

However, this is obviously a semantic abuse. IMO the best solution is a ForEach extension method. The argument against it seems to put purism above pragmatism, but I would argue that there's a purist case that if you're writing with a functional style you should use functional control structures. 

Again, names. If the name of a method is a noun, I expect it to describe the object returned: but the returned is not a sum-finder. It's the sum. I suggest that a better name for this method would be . 

Firstly, this could use a better description (in a comment) explaining what it does. I had to figure it out from the code. I think the description should probably be something like 

If you wanted to do it properly then you could extend the number theory research and learn about Euler's totient function. 

I personally don't find a very descriptive name. would tell me immediately what it's doing. I'm not sure, though, how useful a DFS is which just returns a list of vertices. Most of the time DFS is used as a building block for other algorithms, and they require additional data. 

General comments This is a monolithic block of code. Even some newlines to break it up would help readability, and really I think it would benefit from being split into several methods. 

This creates a race condition: another thread can access in between the two assignments and get a non-UTC value. If you're going to do it at this level it should be 

Naming. adjacency has two as. And what you have here isn't an adjacency matrix: that's indexed by two vertices and contains bools. This is the adjacency lists representation of a graph. See earlier comments about use of dictionary and set rather than array. 

can be written as a one-liner using something called list comprehensions. This is something that's worth learning because it's very common style for Python. 

isn't an obvious name for something which isn't a class. And given that you're using inside the method without fully qualifying the name, it has even more potential to confuse. 

IMO a better improvement is to say that where the type does implement you shouldn't require the caller to implement a comparer. There's a useful item in the standard API for this: . There's a slight impedance mismatch, but it's possible to convert to or vice versa. For consistency with I would favour 

This is Java, not C. You don't have to declare all the variables at the start of the method. There are 20 lines between the declaration of and the first use. Keeping variables to the smallest scope possible aids readability. Also, it's not obligatory to declare variables to be equal to the "default" value. Observe: 

would be more Pythonic as . Spot the symmetry with the second line. The reuse of names is not particularly helpful, especially given that is a bad name. How about this? 

Magic number alert! The acceleration due to gravity should be pulled out into a constant ( field). Where does this formula come from? What limitations does it have? 

The addition of the name doesn't communicate anything to me about what the difference means, so as far as I'm concerned this could be inlined. (Obviously, if following my suggestions above then the call could also be eliminated). FWIW, after reading the code carefully I still have no idea what this function's purpose is. 

It's useful to document the expected type, but it's more useful to document the meaning. Here is the of the problem specification, but I shouldn't have to work that out myself. The parameters would benefit from descriptive names, and the should outline what the integer returned means. 

According to the usually excellent MDN, map and filter take . This is consistent with the first excerpt, but not with the second. The explanation is that the second one is jQuery's map and filter, but that's a nasty trap. I'm partial to the convention that variables which hold a jQuery object should have names starting . Hungarian notation may be maligned in some contexts, but it's valuable in languages which don't do static typing. 

Why was temporarily decremented? I presume it's to avoid an out of bounds array access in . But you can do that just as well by making that be the guard condition: 

Firstly, I find the code quite hard to read. It's understandable that you would want to use your native language, but that doesn't prevent you from using capitalisation: e.g. instead of . And it doesn't explain the inconsistent word separation between e.g. and . 

Now, you specifically ask whether there's a simpler way to do it. I think that using booleans it can be simplified quite a bit by inverting the assumption. Rather than prove it acceptable, prove it not acceptable. Taking into account various of my suggestions above and refactoring I get: 

Ok, there are two inconsistencies. Firstly, vs . I suspect that that difference is due to refactoring the code before posting in, in which case please don't do that again: we want to review code which compiles and works. Secondly, vs . The simple concatenation is far more readable. 

The code looks reasonably clean and simple, but there are some minor things which in my opinion could be improved. 

What purpose does this serve? It seems to me to introduce a bug, because the spec does not ask for falsy elements of to be ignored. 

as a sketch decomposition. It needs a bit more work to handle special cases correctly and, more importantly, to memoise or otherwise exploit the dynamic programming structure of the problem. 

I see two big problems with this implementation. Firstly, it's not uniform, which is something that I would expect users of the library to insist on. Secondly, it's not efficient. In the worst case it walks the entire length of the deck every time. I would suggest removing the parameter, and using the following approach: 

The limit to the number of variable names you can use is large enough that you don't have to reuse them like this. Using different names for what are effectively different variables aids comprehension. 

I would have used an , but that's a matter of personal preference. Should it throw an exception if or return an empty list? That's a tricky edge case which should be clearly documented. 

I get the impression that you care more about performance than numerical analysis, but I think it's worth making this point anyway. There's an important difference between 

Going purely on my guesses, I would expect and possibly to be the same for all s in the group, but I would be astonished if is and the name suggests that that also changes. I suspect that here there are some more important bugs. 

I find the naming slightly curious. Given , I expect the linear one to be called . Alternatively, would fit with . Also, in I don't understand the name . I would find that clearer if it were , although I'm sure there are some who would argue that it should be . Also, from a perspective of naturality, I would consider changing the order of the constructor parameters. 

can be used, but I don't think there's any way to do so really efficiently - i.e. with early aborts. I think you would have to bound the maximum possible denominator: 

If you're aiming for KISS at the level of maintenance, this looks like a reasonable solution, although there are some minor details which IMO could be improved. 

The types of the various lists and maps assume that the vertices of the graph will be s. assumes that the vertices of the graph are consecutive integers. 

(I'm not quite sure what the most Pythonesque indentation would be - I wouldn't normally follow PEP8 on maximum line lengths). 

Why perpetuate the common mistake in the standard libraries? exists: use it! I wish Microsoft would every method in .Net which takes an or a for a timespan and replace it with a version taking a . 

I've not seen this before. Nice trick, but it can be done in pure bash. The catch is that bash case modification is part of parameter expansion, so you have to store each word in a variable, and you'll need a loop. If you're not completely committed to having a one-liner then this is something which could be pulled out as an auxiliary function, and you might even find it useful elsewhere.