(Or even better, use static final strings belonging to the class instead of string literals.) The localized format strings on which that method relies will use argument specifiers to designate which argument to format, so as to be able to accept the same (some possibly unused) field values in every case. For example, in the en-US locale, some of them might be 

General comments Your code is pretty clean, but it's unclear what you imagine it being used for, except possibly just to illustrate adjacency lists. If you're looking to build something actually useful, then I suggest coming up with a few model applications, and thinking about what you need to provide to serve those applications efficiently and easily. For example, how would you model a shortest-path problem with your graph, and how would you implement Dijkstra's algorithm to solve that problem? Or how would you compute (and represent) a minimal spanning tree? graph.h As to specifics, I'll start with your API definition, as presented in the header file: 

Pandigital testing You are making a tremendous sacrifice of efficiency here to implement this in terms of . itself, although not terrible, is also not great. To even get there, however, you need to format your number as a String, which by itself is more expensive than one whole pandigital test needs to be. You could instead just pick off the digits one by one via the modulo and integer division operators, and keep track in an array, or even in bit-array form in a single (only 40 bits of the 64 are needed). General is a wider data type than you need for representing the numbers being tested. is wide enough to express all integers having nine or fewer digits in their decimal representations. You could, and probably should, use -- or even better, -- everywhere you currently use . Also, there is a space vs. speed tradeoff available here, where you have opted for using less space. It is possible to augment your sieve to efficiently fill an array with the actual primes it discovers, particularly if you're willing to declare a big-enough array at the beginning, and not worry about unused space. It would be more efficient to process the elements of that array that are in use than to iterate over the whole range, testing directly against the sieve. In fact, if you do this then some of the extra space need be consumed only transiently, because you can let the sieve itself go after you finish filling the array of primes. 

just declare them inline when you define the method (which as you declare them in the class, you don't need to do anyway) This constructor: 

Don't do this in a header file. You might as well have put Vector2 in the enclosing namespace. It's really not a kind thing to do to people who use the header. 

leaks a single instance of a GraphicController. You should avoid singletons. Or the client should be responsible for the lifetime. You have a lot of C-style casts in EPhysic class. Please avoid them, they are unchecked and could hide issues. use (or other appropriate cast) I haven't checked any more as I have to get back to work, and the scrolling up and down is beginning to get to me... 

A few comments on 'things I wouldn't do'... I'm assuming the code you have given is in a header file. If so, that's an awful lot of code for a single header file. Perhaps one header for each class? Another general thing is that you shouldn't inline anything beyond simple getters and setters, unless you can determine that the inlining produces a significant performance improvement. It keeps your interface a lot cleaner and doesn't cause your clients to get surprising headers delivered to them. It also means that you have more leeway in changing your implementation without causing client code to be rebuilt. More specifically: Why have this? predeclaring these isn't very useful 

Your code exhibits some inconsistency about whether binary operators are separated from their operands by spaces, sometimes even within the same expression. I find code much easier to read when there are spaces around such operators, but if you choose not to place such spaces then at least be consistent about it. Personally, I prefer also to see space between keywords and parentheses (, , , etc.), but not between functions' names and the parentheses around their arguments. That's a bit easier for me to read and parse, but it is of little significance as long as you're consistent. 

In fact, the user must exercise some care with your class to avoid the possibility of SQL injection. In the end, this comes down to another aspect of the problem of your class relying mostly on the user to format values correctly for the database. Relying on the user == accepting the consequences of user error. Including security consequences. Literal appearance of the substitution character Your class appears to provide no mechanism to express queries in which the substitution character appears as a literal. It cannot distinguish that case from the one where that character is a placeholder for a parameter. Variation from standard prepared statement behavior JDBC and native prepared statements provide for placeholders for SQL values, appearing wherever values can appear, not for arbitrary text at arbitrary positions, as does yours. This is why they don't have the problem with literal appearances of value placeholders that your code has, but it's bigger than that. In particular, standard prepared statements do not support placeholders for SQL keywords, for table names, or for column names (and this is what allows for them to be pre-compiled). Of course, you can support placeholders in those contexts if you wish, since you're not parsing, much less pre-compiling anything, but the resulting class will feel a bit alien to users familiar with JDBC. Name of the methods The name of the methods is a bit confusing, and the variation in its overloads is very confusing. Since the method name does not itself designate what is to be set, I would expect the parameters to pick up that responsibility. Some of the overrides do, sort of, by accepting a parameter index as their first argument, but some don't. Implementation details 

Factor Out Constants Several of the numbers used are constants which could be factored out, such as the difference between Kelvin and Celsius (273.15). This will prevent typos from causing calculation errors. Something like the following: 

I've got a couple quick notes. Overall it looks like this method will work. Validating args[0] The only validation that you do on args[0] is to check if there are any images in that directory, but you don't check other possible failure conditions, such as if the directory provided doesn't exist. For a user, no images being found and the directory itself not being found would have different actions required to fix the problem. It would be helpful to perform better validation here and providing meaningful feedback, and perhaps a different return code. Duplicate Calls to Get Path There are a couple instances that call . This could be factored out to a variable. Use TimeSpan Formatting TimeSpan provides functionality for converting to a string in a particular format (see $URL$ In this case, I think you'd want the "g" format. Return Codes You return -1 in the event of no files being found, but you don't handle returning a different value if fails. If this was being called from a script, I'd expect any failure to return a failed return code. Catching Exceptions While the exceptions thrown by are likely all IO related, it would be helpful to catch at least some of the individual errors and displaying helpful information where possible. For example, if an exception was thrown because of a write permission issue, it would be helpful to let the user know that they need to correct their permissions, as opposed to hoping that the library you use provides a helpful description. There are also some instances that I bet could throw an exception that you don't handle. For example, I would expect to throw an exception in some circumstances. If some exceptions are handles and displayed in a user-friendly way, I'd expect all of them to. Commenting Some of the comments are helpful, such as the reference to documentation for a method from StackOverflow. However, there are also some trivial comments ( is pretty clearly going to get the elapsed time). But there are also instances where comments would be helpful, such as what the values you set on the MagickImage are (what does do?) 

It's at least twice as costly as rearranging a min heap appropriately without removing the modified element could be made to be. You've given no basis or context for putting that on absolute grounds. 

Update Here is the fastest code I have been able to come up with. Note that it does not rely on atomic operations and it does not use any implementation -- I tried several variations employing such objects, but in the end I found that structuring the code to use native synchronization on suitable coarse-grained objects produced the best result. The below code runs in about 10% of the time of the original code on my test system. It should be noted, however, that the below code is only about twice as fast as the best sequential code I could come up with, so much of the performance gain is from general algorithmic improvement (especially getting rid of all the atomic operations, I suspect), not so much from improving the parallelism. The Sieve of Eratosthenes is simply not well suited to parallelization, though this code seems to demonstrate that it can obtain at least some advantage. 

You can quickly compute the exact total number of grains that could be eaten over a given time span by multiplying the time separately by each consumption rate (== truncating division by seconds per grain) and adding up the results. Having such a function in hand, you can avoid simulating the entire course of the process by instead searching the space of possible times. For example: 

One - this declares local variables with 0 values. It doesn't zero the values in the class. Two: It's the destructor. This object will never be accessible again. Why bother? Three: Destructors should not be inline. A destructor has to destroy all the member variables, and that can unexpectedly generate a lot of code in every client. 

allows you to declare a . Is that what you really want people to do? Also, as you haven't made it , you can do which is almost definitely wrong. I'd think two separate constructors with no defaulted parameters would be better. You also have a lot of this: 

Again, this should be explicit for safety. Again, IMO this should be two separate constructors, as this means your header has to pull in whichever windows header defines GetConsoleWindow, which your clients probably don't want to know about. 

This is an awful lot of code for an inline function and pulls in a lot of headers into the code that your clients really don't need to know about. 

Use the initialiser list to initialise members when you can. The compiler HAS to initialise all the members so you will end up with default initialisation followed by assignment. And remember to order the initialiser list in the same order as your member variables. 

Not that I have significant problems with this, but you should probably return a or similar, otherwise the client is liable to leak the returned value. 

This is unnecessary. Without it, it will propagate the exception up, the same as manually rethrowing the exception. Remove Unneeded Controls You seem to have both a radio button list and 4 radio buttons. We really only need the radio button list. There are also a few panels that aren't needed. Use ViewState Instead Of Session Instead of using the session to store data between questions, we can use the ViewState. The ViewState doesn't persist the data on the server, but rather stores it on the client side. Since we don't need to make use of the internal state data (such as the current question), we can store it in the ViewState. Using ViewState also allows a user to have multiple question sessions going on at a time in separate windows, whereas the session data would otherwise be mixed between them. We can also use properties to simplify this access. Instead of using strings to access the variables, we can implement the access in the property, which will prevent us from accidentally using the wrong key. For example: 

Ideally, it would be great to have a result information class that we could serialize and pass through, which might include the percentage, which answers were right/wrong, etc. Note: It really shouldn't be using the session at all here (see reasoning above), but the architecture of transferring the data is out of the scope of this question, so this is here for a proof of concept. Separate Data Access From Rendering Currently both handles data access as well as calling the rendering method. I would extract the data access to it's own method, something like: 

... and skip the initialization loop. (Elements not explicitly designated in the initializer get initialized to 0.) Comparative efficiency It's hard to be sure what to compare here. The two codes comprise slightly-different versions of the same underlying algorithm. Implementing fixes for the various shortcomings I discussed would bring them to pretty much the same place, which would look more like the second code than the first. There are a number of possible variations on this approach, some of which may run slightly faster than others, but I don't see room for anything substantially more efficient. 

I take you to mean that you want to tokenize a language similar to the one recognized by the standard POSIX shell (since you tagged [posix] and presented an example), or maybe even that exact language. You posited in comments that perhaps you needed a parser generator such as or for this job. Although these tools can indeed do such a job, code for such a subsystem -- a "lexical analyzer" or "scanner" -- is more often generated via a different kind of code generator; and its GNU variant are the canonical tools for this purpose. These two particular tools allow you to describe your tokens (and separators) via regular expressions, and from such descriptions they generate C code for a table-based DFA that processes the language character by character and splits it into tokens. This is certainly one plausible way you could proceed. On the other hand, depending on the language you want to recognize, it's not necessarily unreasonable to write your own lexical analyzer from scratch, or in favorable cases to use an available function such as to do the job. This affords the possibility of a better-tuned implementation than can be produced via a general-purpose tool (or not), it does not incorporate an additional language into the project, and the source might even be smaller. You ask, 

Only Handle Answer Checking on Next Click There's no good reason to check anything about the selected option when it's checked; we really only care when the user clicks next. This greatly simplifies the logic, as we can remove all of those methods, and implement all of the logic in the next button click method. For example: 

Two items I would have a look at in terms of the actual calculations. Use Full Names in Methods For clarity, and because the few characters are inconsequential, I'd prefer to see the full names of the units being used in the method names. This will improve readability and understandability of the code. 

Overall, I think this code is a great first try. That said, it has a lot of room for improvement in terms of simplification and improving readability. As an aside, I'm not sure if you have a strong motivation for using Visual Studio 2010, but if you don't, I would recommend considering using a more up to date version. Visual Studio 2017 was recently released. Naming Conventions The naming of the methods should be PascalCase, and should not be abbreviated. For example, instead of , use . This improves readability and is consistent with C# conventions. You also use Hungarian notation for the question class. I would also denote that it is a model. Instead of , it should simply be . See $URL$ and $URL$ for reference. There are some great points in that documentation. Use C# Auto-Implemented properties The class can be greatly simplified using C# auto-implemented properties. Use instead of creating you own backing fields. See $URL$ for reference. I would also rename the Question property to QuestionText to avoid confusion. With this, the Question class could be extremely simple: