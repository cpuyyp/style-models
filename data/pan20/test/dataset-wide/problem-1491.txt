Which is much more concise. This also does away with any need to delimit the code with comment lines (I wouldn't recommend that, if you feel it's necessary put each delimited block of code in a separate method). Note that the auth component stores data in the session, which is accessible in the view. Consider reading the current user data directly out of the session rather than passing variables around which contain information that's duplicated elsewhere. Use caching There's no need to get the banner info from the db on every request, you can wrap that in a cache call: 

This function simply loops on all the keys that you specify as needing to be not-empty and returns true only if they are all populated. Many simple functions Always strive to have simple functions, that do one thing - for example: 

This allows the building-blocks to be changed - or used individually. It also aides readability/maintainability as it is much clearer at a glance what a function does (assuming methods are well-named). Avoid repetition The fields and array keys for the values key in look to serve the same purpose - although they are different. You don't need 'fields' if the keys can be used i.e.: 

Yet the code in the question isn't simple. It's 180 lines of code that mostly duplicates built-in php functions. To wrap the functionality in a class, simple would be (example and almost pseudo-code): 

By using crypt and blowfish (the string '$2a$' indicates to use blowfish encryption) passwords are stored securely such that password leaks such as the recent linkedin incident become a none issue. Be configurable In the above code example, blowfish and a cost parameter of 10 is used. Instead it would be better to make the hash algorighm used configurable: 

Since all the properties are public - it's not necessary to have a method which just returns a public property. Assuming the code in the question will be used in one form or another, here are some tips for refactoring the code to be easier to read, use and maintain: Don't repeat yourself (DRY) #1 

Consider using existing template systems to help you that support inheritance. Template inheritance isn't a strict requirement, but is a powerful feature that makes maintaining templates a lot easier. Twig is easy to use, and feature-rich. If you want to go it your own way, you could simply implement the use of layout files: layout_default.php 

For a few reasons, your best option is to use delayed job execution That means setting up a job queue such as gearman, and instead of trying to do things all at once and in serial - you simply register a request to perform the job later. The benefits of working this way are numerous and include: 

You'll have the possibility to handle requests for a packed js/css file on the first request where it's missing. Write to the equivalent path of the current url - and the webserver will take care of serving the file and sending appropriate headers. Derive the url at run time, not the file's contents Instead of using a url which contains, serialized in some form, the contents that are to be returned - just derive the url for the packet file. So e.g.: 

Template structure The template is clean and easy to read but it is not a good habit to put the layout in the view file. Especially since the reason given is this: 

The benefit of working in this way is that the run-time logic is reduced to the bare minimum, there's no need at any point of a web request to check if files exist ect. This is also more or less a pre-requisite to be able to use a CDN. Explicit is better than implicit I'm not sure what the logic at the top of the code in the question is for, but (and this is from experience). if in a project there are requests for: 

You can enforce any mandatory args just the same, but given that everything is a class you should be able to set all of the currently-mandatory properties after instanciation anyway. Mid Point: Needless interface The interface only defines one method, and where used has exactly the same code. You could just as easily add it to your Node class and override or configure it to be disabled in the cases where it's not applicable. Mid Point: Needless constants What's the real benefit of these: 

To what floor do the instructions take Santa? There is no need to go character by character to determine that, instead: 

I think you need to look first at the problem you're trying to solve rather than the code you've written. Is a class necessary A url is just a string (or an array if it's split into component parts) - is a class really necessary to represent a url? Or are a couple of functions required in the (e.g.) router class to parse and build urls? Reviewing existing code that does a similar things (php frameworks, pear, github, the blogsphere) would help evaluate whether the uri class is appropriate - bear in mind a web page typically has 10s or 100s of urls on it, and it's not free to instanciate many objects. This is likely to be faster to execute, and effectively easier to use: 

That's one logical test instead of 4 Don't rewrite php functions Built-in php functions are much faster to execute than equivalent user-land php code, and are more robust. 

The above example probably does not match your usage here - but may be applicable to other scenarios. So, rather than having the mailer a mandatory constructor argument, have a method to get/set the mailer instance, generally this is an easier pattern to work with, example: 

The numbered questions 1 Correct usage of an Error object? Probably not. Using DI is fine, creating an object to inject into the construtor where it's not fundamentally required is not. The use of the term "an Error object" implies it's a common/global concept - I'm not familiar with this. Javascript has error objects for example, PHP has exceptions. In both cases though, they are classes that are created to represent one error and to be thrown and not something that's passed around and especially not something that's eagerly created incase an error condition occurs. 2 all classes need getErrors? The Error object is not something I feel should exist. Ignoring that though, from what you've said in the question, the Error object is supposed to be used with various, possibly quite different classes. Since (I assume) the same instance of the error object is passed around there is no need for the getErrors method at all - just get a reference to the singleton Error instance, and query it directly. 3 PDO usage? You're better off using some abstraction, doctrine is a reasonable choice if you aren't using anything at all right now. 4 Proper way to display errors? Probably not. This class isn't presentational, it should be returning only data. 5 DRY try/catch? Only catch exceptions that you know how to handle. in the example code a PDOException is caught, no corrective action is taken which simply means that a fatal error will be thrown on this line: 

Mixing and usage is a little strange, as they are functions which overlap in functionality. file_put_contents in fact is just a wrapper to call , and - expanding that call to it's component parts would therefore make what the code is doing more obviously repetitive. So, the first goal I would suggest is to avoid repeatedly opening the file to append text to it; the goal of the function is simply to append bytes to a file - so make the function do that, in one write call. An example of what I mean is: 

As should be apparent written like this, the settings arrays are near duplicates - you can easily consolidate the two methods into one, or change into finder methods as you see fit. The controller code then becomes: 

In this way you can mock the test class, or simply subclass it and override so that it does not exit execution. 

In this block, the array key is tested twice. But, unless it's a cli request it's not possible for or to be missing. This code is more approproate to acheive identical functionality: 

doesn't do anything for end users. It also doesn't do what you want, as it leads to ugly html. Look at the source of this page and look for "<form>" - if it were left aligned it would break out of the indentation level where it is. If you used similar code to that in the question to build all your html the indentation would be so wayward you wouldn't be able to read the raw html output without re-indenting it. It's something that is of no real value, because anyone who wants to see the html structure can just use firebug/devtools/their-tool-of-choice and it'll indent the code for them. If you really want to have indented html anyway, there are tools for that like htmltidy. 

If there's a class tracking all errors (why, what's the use/benefit) - it should either be asking individual instances what errors they contain, or some intermediary logic should be doing that. If the error class just contains an array of strings, there's no context to know why of where an error came from. Using DI is fine, but not having a needless dependency is better. As a related point the function only returns true or null. It would be preferable to always return something: