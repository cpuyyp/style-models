(sorry to you java people if doesn't stick with convention. I've been in the .NET world for too long... I would have returned new string[0] if it let me) This class is simple, direct, easy to digest and understand. When I go to start the game I know that all 13 and up year olds will be playing my game only. And if someone told me "I put 13 as my age and it said I couldn't play", or "I put 9 as my age and it let me play" I would know very quickly if that was a lie on their part, or if I introduced a bug... just run my test. If you want to put their claim to the test, just add it to the test or create a new test 

Maybe you could respond back to the teacher that you used a class which is passed around by reference :D for example 

To answer your question.. it depends on how you want to handle the data. Take a step back and put your self in the users shoes. Lets say the user has those numbers saved as bank account transactions.. He would want those numbers saved somewhere, but not necessarily visible. If that was the case you wouldn't want "delete" that data. You could, however, parse the data into say a table. You could give each cell in that table a class that has a boolean value called visible, and a int value. Then you could set a row or column to not visible as you wish. That would give you the ability to then just loop through the rows and columns and output the data as needed. 

In my commented I suggested a class that could do what you want it to do out of the box. However sometimes having a custom piece of code to show things in a better way is the goal. I can see this going in two different ways. One is to use a variation of the Visitor pattern and a list, and the other is to use a dictionary with and the key, and the class that represents how to view it as the value. The first way you could make the interface one of two ways. 

WOw, this is getting to be a long post, and that is just the first file. I think this principle gives you something to think about. 

I'm working on updating a GitHub project that I use at work, but I think the person abandoned the project as there is a pull request for it since 2014. At work we use a Repository pattern with NHibernate and mappings and so forth but this project they use Entity 4.? I had to update the project to use .Net 4.6.1, and because of that I had to update to Entity 5.0. (I know I could have done 6.0 or greater, but I don't want to break the existing code and 6.0 gave me compiler errors which I don't know how to fix yet). The existing DataContext has a DBSet for all 3 tables (which I don't like) so I'm slowly splitting that into individual repositories. Here is what I have thus far. First the POCO, and interface for said repository 

but even here I have some duplicate code. And it looks like it does the same thing as well. If the user is valid (if he's brand new or existing) then we redirect that valid user back to the homepage. ok so make a method called that 

There is probably even more ways to refactor my code, but without better context that is the best I can do. This is where having unit tests is super useful because you can continue to run your test every time you make a change to it to clean it up. 

I have this API to control some hardware. The API is not very well documented, but I've been able to make do with what I have. It is a API for a RFID device, but also has LED's on it that are controlled from the API. So the idea is that this is a OPOS program. The RFID device opens/claims/and enables. When it is enabled I start a thread that polls the reader to see if there is a RFID card in the field. The user has the ability to turn on and off the LED's when ever they want by using a DirectIO call. Here is the hard part. I've found that if i make concurrent calls to the API that the commands will give me back some gibberish (might be wrong word) answer. Valid messages returned are 0 to -7. We wrote a simple parser to run commands for us so we don't have to change the program it self to test for bugs. 

You may notice that i took out the check for more than 0 files in the directory. Foreach does that for me because if the list is empty it just skips the foreach statement. 

You'll see that I marked and as final which would force me to make sure that I never set or to anything different than what it already is. Or in other words don't change the reference to which and point to. Now with a slight change in to make the compiler happy. . Fire up the game and sure enough the program still works. We would call this encapsulation. It's a form of refactoring that is fairly safe because you're not really changing anything, you're just moving things around to make more sense and to clean up the code some. As an exercise I'll let you try to do the same with , , , and . Next point that I want to point to is having public fields. In your code there are very many places that you set the field to a specific value. such as in your keylistener . It would be much better to make Block have a public method called , . You could make a but the amount that you want to rotate might change and it is easier to update 1 reference instead of many. Changes to Block: 

it might be slightly over-engineered, but it gives me two things. First is that it gives me a class that I can easily change the outcome of a file is found (regardless if it really does or not) by simply extending with a class that overrides FindFile and returns true or false as I see fit. Now testing that class isn't really worthwhile, but if I were to have a class that used a that could give me some value. Now lets consider a class that would use it. 

There are other ways as well but that should encapsulate your work some and make it easier to find where a mistake is. Because of the nature of your work on this it won't be super easy to test that everything is visually pleasing, but the code should be encapsulated enough to make it easy to adjust what you need adjusted. 

Here is where the value comes in because I can override FindFile in easily, and I can pass in an instance of that easily info . So now all the math and resource finding things an go into the and be tested in a test framework (such as NUnit, or Microsoft's test framework). The underlying issue is why go through all that trouble to make 2 more classes just to return a client? Simply put for testing purposes. If all that code is testable then you know it works as you expect without having to run the actual application. It also gears your mind more towards the MVVM principle of seperating work that you do in the code behind with actual work that you want done. Also by seperating when you go back to this code and decide to use the MVVM approach you'll find it almost trivial. (Essentially it would be a matter of setting your button bindings to a method which is just the inside of your current button click events.) I personally think that this type of work is being overshadowed by different approaches such as MVVM. Granted WPF was built with MVVM in mind, but what if someone comes in and says oh MVVM is SOOOOoooo 2015, we use MVMVPM now, or your company decides that MVVM is to strange to work with and they only want MVC/MVP pattern used? No big deal because your code that does the actual heavy lifting is extracted and tucked away safely in a blanket of protection. (FYI.. I use MVVM, I like it and would recommend looking into it after you've learned how to seperate heavy lifting code from code behind) 

My definition of monkey testing is basically playing with a program in as if I was a monkey (press every button, unplug things, go in the wrong order..etc etc) So I made a rather simple SmartCard library that when I "enable" it it just polls the smart card reader for a card, and reports back information. see code 

My turn: typeo in your class name <- you were missing the 'r' in Strategy. I also see that you are hung up on having a pricing strategy for every product. And although you could do this it doesn't make much sense in the market world. The old adage "Everything has a price" comes into play on this one. From a cash registers standpoint all SKUs have a price. That should be part of your struct. However, even struct is a poor choice IMO. Struct should be able to describe a value in the end. Instead a SKU and a price is closer to key value pair. What's more, and I'm sure all store owners would agree, I wouldn't want to be able to enter in a product into my database without giving it a price, yet by default you can, and you do as is shown in your test with Next up is that I feel with your improved idea about how to create strategies is still wrong. Why would you create a set price for items then attach a sku to each of those prices. It is like you are switching your key and your value around. Now your entire system is indexed off of the price instead of the Sku. TestCaseData. I know you are using MSTest, but you've preached about using that ability from NUnit a few times. Not using it with the way you wrote your tests was like holding one hand behind your back while coding. Why? Even if MSTest doesn't support it you can write you test in such a way that at least gets rid of the duplicate code. (just saw another typo .. should be ) So you could delete all your other methods and replace it with just this one. And if you wanted your error code to be more specific you could change the assert part to check for a "error string"