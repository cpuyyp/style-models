I have a graph represented as an adjacency list. I need to find a triangle in this graph. A triangle is a triple of vertices , and , such that , and are edges of the graph. The graph does not necessarily needs to be undirected. I found the following pseudocode for solving the problem: 

You can imagine the idea of my algorithm as follows. I have the numbers of the set in the vertical axis on the left, where the first element is actually the empty set. These numbers are not considered as only numbers, but, as I go down from the empty set (the first element), I start considering greater sets, that include all previous elements plus the current one. Example, suppose I have the set . I first consider the empty set, then the union of the empty set and , then the union of and , and finally the union of and . In the horizontal axis you can imagine I have an increasing sequence of numbers up to the number we want to obtain (by summing the numbers of a certain subset of ). Example, suppose we want to obtain 4, then the increasing sequence would be . So, I first start considering I want to obtain the number 0, and then 1, 2, etc, as it is usually done in a dynamic programming algorithm using a bottom-up approach. Apart from the setup of the matrix, my algorithm assigns 1 to , for some , where is the size of the set , and for some , where is the number we want to obtain, when either the current number in the subset, that is , is equal to the number we want to obtain , or when the previous solution to the subproblem, where the number we want to obtain is , was 1. That might seem a confusing explanation, and I think the code is self-explanatory. Is my algorithm correct for all instances of the problem? Is there a way I can improve it? 

I was trying to write a dynamic programming algorithm using a bottom up approach that solves the subset sum problem's version where the solution can be either an empty set and the initial set can only contain positive integers. The following is my implementation, but I am not sure it is correct for all cases. 

I implemented a invert-range operation in a (logical) circular vector. A circular vector is a vector without a logical starting and ending object, or, equivalently, the successive element of the element at the last index of the vector is the element at index 0 (similarly for the previous element). I'm not 100% sure it's correct. If it's correct, any suggestions to improve it (especially in terms of performance)? 

Notice that the headerView should be a property of the ViewController. That way you can access its textView property to use its text to add to the ViewController's array. Conversely, you can declare a callback closure in the addButtonPressed: function of the header view and pass in the textView's text. 

I predict that scrolling in this tableview would be choppy. The problem you are trying to solve is pretty common - for example, find a shopping app that has to display many images of products in a UICollectionView. The scrolling in these UICollectionViews is smooth even though you might be scrolling through hundreds of images. How do they do this? Here are my suggestions. 1) Find an image caching framework to use like Kingfisher or its Objc predecessor SDWebImage. 2) Parse objects have a URL property (according to their docs). 3) When you populate the tableview, each cell gets configured with its own Parse object. Within each cell, use the image caching frameworks method for setting an image on that cell's image view with that cell's Parse object's url property. 4) Paging - if you have thousands of users, you don't want to download all 50000 at once. Inside cellForRowAtIndexPath, you should check the current row against the data source array of the table view and see if you're about to run out of data to display, and when that happens, eg (row <= data.count - 4) call your fetch method for more Parse data. 

This doesn't need to be declared as an NSMutableArray. Swift defines a mutable array like this var data = ["Apple", "Apricot"] and if you wanted it to be non-mutable, then declare it with let Remove the functions that Xcode auto populated your code with if you aren't actually doing something in them. This includes didReceiveMemoryWarning, awakeFromNib, and setSelected. Subclassing I think you're incorrectly labeling the parts of a UITableView in your description. Going by your comp, the UITextField and Add button are contained inside a tableHeaderView. This shouldn't be subclassed as a UITableViewCell - if you look at the documentation for the tableHeaderView property of a UITableView you'll see its a UIView. Let's just rename the InputToListCell as InputToListView and change it to a UIView. Passing Data From the Header View to the TableView As a general rule in iOS, a view that is a component of a larger system shouldn't know anything about nor should it be able to control that larger system. Here, the component is the InputToListView and its parent is the UITableView. The InputToListView shouldn't have an array of its own. When it is declared in the ViewController, its button property should add a selector that is called inside the ViewController. Delete both tableView and array properties from it. 

What jumps out at me is the nested for loop in checkForWinner. If I were to try this I'd think more in terms of a different condition for how a winning combo is determined. We know in this board there are only 3 spots. It also doesn't seem to make sense to check for winner at the end of each move. I think I'd just do some kind of recursive check on the neighbors of a given space to see if any are == . 

However, since this function is only one line of code, I personally wouldn't use the function. Code duplication Notice how each block in the if statements look almost identical: 

Basically, the compiler is allowed to order the assembly such that the following happens (psuedocode): 

However, this version naively creates a new array for every merge. If we instead create a second array at the beginning and simply shuffle data back and forth between arrays, it becomes faster than yours by about 100 to 200 ms on average, and it sometimes reaches the speed of : 

It's also much better to use than , because you don't want to be relying on specific dimensions in GUI applications, in order to allow the GUI to work well in all systems. What if my screen has 2 or 3 times the resolution as yours? Then everything sized in this way would be appear half the size! Additionally, it doesn't make a huge difference but centers the frame in the screen (good job doing that after sizing the frame), whereas you might want to use , which would make consecutive frames open in different locations. 

Alternatively, if you really like the temporary variables, put some empty lines in there to separate logical sections. Also, consider using Project Lombok, where you could just do this: 

While we are discussing iterator categories, it's useful to name after the iterator category you require, so or would be better names. 

But this also disregards - which could be called an edge case, so you need to test zero as well. Not too bad. If you tested these cases, you'd cover most possible bugs. There are a couple more edge cases since we are working with floating point numbers, but from someone learning to code, I wouldn't be upset if they didn't cover them. 

Similarly, Java 8 code is not meant to be formatted like that. Regarding the concern of colleagues formatting away the line breaks, you could add a comment explaining why it is like that. But poorly chosen IDE format settings could still interfere, unless you did something like this (this isn't good in practice, though): 

This might be a bit nitpicky, but and aren't that good of names for classes. Granted, they are in your namespace, so it should be fine, but why not just write out the names and ? I do find more ambiguous than , because I see "desc" as shorthand for "descending" more often. 

C++ doesn't supply a , so I decided to implement one. However, I was viewing this as more of a hash library than extensions to , so I placed it all under the namespace . This was my first time seriously using template meta-progamming. I tried to make my code work no matter the cv-ness of the variable, or whether it was an rvalue or an lvalue. I'm not sure on the efficiency of execution, but I believe the compiler can optimize it down to simple arithmetic on hash values. hash.h