String v. Variant Functions: You may have noticed that most string handling functions have 2 versions - the "normal" function, and a version that ends in "$". The ones that end in "$" return a , the others return a . If you are assigning the return value to a or passing it to a function that takes a as a parameter, you should use the function that returns a . The reason is that there is an implicit cast performed, so this... 

Setting objects to You almost never need to do this - the VBA run-time is a self-cleaning organ. If you haven't read the blog post When Are You Required To Set Objects To Nothing? by Eric Lippert (which is much better written and explained than I could do in the space here), do so. When variables go out of scope, they get released. If you do find yourself in a situation where you need to explicitly set an object to it indicates a design problem - you should probably be using a structure where the life-time of an object is tied to a specific procedure instead. Same thing goes with arrays. You gain absolutely nothing by freeing their memory immediately before they go out of scope, because when they go out of scope...their memory gets cleared. These practices do nothing other than add noise, and usually wind up with me having to quickly check and make sure my scope assumptions were correct by going and finding the declaration. Which leads me to... 

Overloading VBA Keywords Don't do this. It not only makes your code hard to read and understand, it also makes it really easy to do something unintentional. In this bit of code it's obvious that is an enum (other than the fact you declare the variable as with your prefix and the member of returns who knows what because it's declared as - looking at you, Hungarian notation...): 

The C# code doesn't have a return statement outside of the loop. I don't have VB.NET installed in Visual Studio so I can't test it, but this is probably defeating optimization code in the compiler because it assumes that the return instruction can be reached. In fact, C# will give you a different warning if it is include in its source and warn you that unreachable code is detected if you include the corresponding code: 

This means that the calling function doesn't have an easy way to determine if there are any results other than the non-obvious method of checking to see if there are 2 items in the returned array. Since you are returning a , I would suggest returning either or some other non-array value if there are no results - this makes checking the return value simply . Still on the topic of arrays, resizing arrays in a loop is horribly inefficient. Every time you use , the entire memory area of the array is copied. Using a is roughly 10 times faster (benchmarked with 100,000 inserts). A is slightly faster than a , and makes it much easier to return a containing an array (it has a method). Excel specific Calculating offsets and requesting objects from Excel is also expensive. You already have your conditions set up to "short circuit VBA style", but each time you go through the loop you collect all of the 's before you know whether you'll need them or not. For example, if this test fails you don't need to retrieve any of the others: 

user2023861 covers a lot of good ground, so I just have a couple more things to add. First, instead of using parallel arrays, you might want to consider using a collection container like a List and filling it with objects. Each line appears to a distinct record with a set of properties, so I would make them a simple Class: 

The algorithm you're using does a bunch of superfluous work. It would be much more efficient to concentrate on tracking the maximum difference that conforms to the specification than where you are in the array. Setting the maxIndex the first time through your main loop isn't really setting any meaningful limit for you, because you also need to check to see if there are any other number combinations that have a higher difference than just the array maximum. In fact, you don't need to know what the highest value is at all or it's position in the array. The highest difference already assumes both of these, because when you set the greatest difference it is calculated based on the lowest value up to the current point in the array. The idea of limiting the minimum check to the position of the previous high is well intentioned, but why not just run through the array once and keep track of everything at the same time? The pseudo-code is much simpler: 

You created implicit casts when you extracted the function. You have it declared as returning a , but you declare as and then return that with . Then when you call it here... 

Make sure the right workbooks are open. Add worksheets. Move data. Sort data. Copy data. Add headers. Delete rows with "template" in them. 

You forgot when you extracted the function. You have at the top of ...and the repeat that call at the top of both and . If you want to make the 2 functions a bit more reusable, give them a Workbook parameter and pass that in. If you don't care, skip the variable declaration all together and just use explicitly. Note that this isn't the same as - it's a hard reference to the class in the project the code is in. 

Removing variable declarations makes them implicitly . The following are undeclared in : , , , and . This is a huge performance penalty, because every time you use them, the underlying values need to be coerced out of the . You also can't store strongly typed objects in a , so that means every single one of your calls to and is late-bound instead of early-bound (that's why you don't get any Intellisense when you type or . That's a ton of needless overhead, especially when you're in a loop. If you can early-bind, do it. Put at the top of the module, and then declare everything. Put the strong typing back in. Note that the original code had this wrong too - lines like... 

No reason to use the object when you are selecting single cells. Use instead so you skip the concat. 

...then do a code review on the entire thing. Ask yourself, "In the context of the full Sub, what is the reason for every single line of code other than part above"? I'm guessing that in roughly 99.99% of cases, there won't be a good answer for all of them. 

Finally, just as an aside - I have no idea what is doing in , but from the block it appears that is calculating both and when it only ever returns one of them. I'm guessing this would be a more efficient structure: 

This is a bit more efficient and much more readable. The test is unnecessary because your loop counter is already bound by that condition and the can't change inside the loop. It can be omitted entirely. With blocks should be outside of loops unless the object they are referring to can change. Remember, each keyword is at least one dereference. The value for is repeatedly calculating the last row of the Worksheet. You only need to do this once - afterward you can simply increment it: 

I was inspired to throw this class together by an SO question and thought I'd subject it to some welcome criticism here. The class is basically just a wrapper around the shell utility , and is intended as a replacement for the built in function. The rationale for replacing the function is that it has many more features than either the built in VBA functionality or the when it comes to directory listings. For example, won't recurse subdirectories, won't take wildcards, and neither of them will filter for file attributes or sort the output. This class serves to fill that gap. Disclaimer: This is essentially a rough draft waiting to be extended. Known limitations include: 

...you set the font to the same value regardless of whether the condition is true or false. There may be others that I missed. I would also try to use consistent syntax. For example... 

AdvancedFilters method I would consider a method with 6 state flag variables to be a candidate for creating a new class to hold that state. It would be much cleaner (and more in line with SRP) to simply extract this functionality into a class that is responsible for Worksheet filtering. It could probably use a more descriptive name as well - if the only thing I knew about the method was its name, I'd be pretty surprised when it started deleting rows. More Miscellania I'm a bit up in the air about storing member variables in a user type - it seems like a bit of overkill. When they have the same names as properties and are assigned to a variable named , I'm not in the air any more. When your member variables are accessed in the properties, it looks like a stack overflow at first glance because implies (at least to me) an instance of the class: 

The beauty of this approach is that because you now have the underlying data structure of the array in a variable, you can just change the pointer to any memory that has been allocated, and set to the the data type of the list. An function is then just shifting memory one element higher in memory from your insert offset and dropping in the new item, and is the opposite. What makes this really slick is that you can just point an back at the , and VB6 won't even blink because it is exactly what it expects to see. About now, you're probably wondering when I'm going to get to typing. Gimme a second, because I want to go over Variants first. Again, keep in mind that we are dealing with a COM object and not strictly a VB object. Microsoft put Variants into COM specifically to allow loosely typed languages a way to marshal data via the API to and from strongly typed languages. The way this works is by passing a structure that includes all of the information that the receiving API needs to determine what the underlying data represents. In that VB6 only implements a very small sub-set of the available data types that a Variant can represent (see the MSDN link a couple sentences back), you could conceivably enforce data typing that VB6 doesn't even natively know about. All you have to do is to examine the Variant as a memory structure instead of passing it through the built in function. This is basically what it is doing anyway (and although I can't verify this, I believe the casting functions use the Variant's union to determine whether a Variant can be cast to a strong type). By directly examining these you can bypass the VB runtime and also avoid all of the string handling involved with using . This article is a good place to start, although most of the links seem to have died. Finally, and not for the faint of heart - if you want to have your List return its type without using the function, you can always hook the VB runtime dll itself and intercept function calls to native VB functions. I wouldn't do this in production code personally, but you can get a good start on that here if you want to really start mucking around in the internals. Scroll down and read about trampoline functions. I've never hooked the VB runtime itself, but it shouldn't be different than any other dll as long as you are really careful what functions you use while you're shuffling its memory around. Disclaimer If you try this, you will crash your IDE at least once while you are debugging it. Make a habit of never starting a debugging session when you are manually handling memory without saving your source code first. 

Don't discard return values that you need later. Consider this pattern that is repeated 3 times in the following: 

6 - Consider using a regular expression to remove duplicate line feeds in . This can also avoid the possible bug if the data contains a . Since you immediately split the result, I'd use a function like this... 

That out of the way, you should try to use the tools that the host application offers when possible (and performance allows). Excel actually keeps track of blank cells in its collection. You can identify all of them by calling , which replaces the need for manually identifying them cell by cell. The method also works on non-contiguous cells, so the entire can basically just be replaced with a one-liner: 

Dead Code: Think about the line of code , then ask yourself what this is intended to accomplish. There is no situation that I can come up with where setting a variable to itself will accomplish anything useful. VbNullString: should be replaced with . Note that the two are not the same - is a compiler constant that is basically a string pointer to null. actually allocates itself as a string with zero length, which is very different, especially if you're using 'd functions and API calls. The following demonstrates: 

4 - I'd put your enumeration in its own module and make it public instead of private. That way if you have other procedures that use custom error numbers you both easily can reuse them and avoid the possibility of collisions in error numbers. 5 - Named parameters after line continuations should be indented consistently. This is incredibly difficult to read: 

OK, that's probably doing much better now. But what if there were a way to link multiple tables of data using common identifiers? Well, you're in luck - that sounds a lot like SQL, which is supported by Excel via ADODB. The first step boils down to this: 

@RubberDuck hits some good points, so I'll just mention another couple things with the original code. First, your last row variables shouldn't be variables. Excel can return values for row counts that overflow them. Get into the habit of using variables instead. This might not be an issue with your particular use case, but it will be at some point so the sooner you get in that habit the better. Second. Avoid concats in loops whenever possible. VBA is no different than any other language in that string operations are expensive. Likewise, avoid using methods such as that return the same value in every loop iteration. Don't forget - this is a function call. Cache it instead. For example, in this loop: