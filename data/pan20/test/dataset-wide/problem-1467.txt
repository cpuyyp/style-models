The difference between and is that the double quoted string allows variable interpolation. Since you are not using variable interpolation, consider 

By writing it this way, it just holds the input to generate (two million in this case; ten in the original example). You can write a generic, reusable function: 

This idiom is quite common in C. Note that I'm not arguing against the range-based loop proposed by EngieOP. That obviously will avoid this specific problem in this case. However, there may be other circumstances where that won't help you. Another solution for this specific problem would be to use the method of the vector object: 

Does this work properly? It seems like it would move the actual tile when you want it to move a temporary tile. 

First, we define a constant to hold the possible digit values. Then we make a new that masks out the . If is allowed, then we generate all the numbers that start with separately. Then we remove from the , as it won't be allowed in any of the other numbers. printNumbers 

I think that makes it clearer what the string is. Also, I prefer to name scalars (numbers, strings, etc.) with singular names. I'd name for the latter reason. 

Be careful about using . It's one thing if the three columns that you use are the only columns. It's another thing entirely if you have a large text column that you don't need in the table. There are some people who believe that you should never use and always specify the columns. Note that using may also cause you to go to disk when you otherwise would have a covering index. This means that even a small column can be a problem. I don't like the name for the database connection. It's too short to be obvious what it is. Admittedly, is slightly more accurate than , but is accurate enough, reasonably standard, and more easily recognizable in my opinion. You may want to replace with as your check. I.e. instead of checking the time, check for newer values. Assuming this is an autoincrement primary key, you should already have a unique index on it. You could put an index on , but it will be a slightly less performant non-unique index. This also avoids the problem with near simultaneous chat messages where you only have the first one and never look for the second because it has the same time. 

You should avoid doing the same math operation for every iteration of the loop unless the result will change based on something that happens in the loop. In this case, you are only reading from the array. So instead you can say 

You define as not , however this gives the two of them different meaning. Something is if but is if . Better might be 

In the first, is a string representing a MySQL query (i.e. a SQL string). In the second, it is a query result handle. I find that makes a lot of sense in the first signature and no sense in the second. I would suggest changing the second to something like 

However, that's still incorrect. That closes the last database connection that was open. That may or may not be the right connection. It really should be 

You are embedding the value in the SQL. You should replace the in the query with a . Also, I'd use a heredoc or nowdoc to write the query rather than relying on a multiline double-quote string. 

When I look at this code, I find an immediate criticism that may help. You name many of your functions as nouns, e.g. 

The function is starting to do something here. If the array is at the end, you return the minimum possible integer, which will be a negative number. If the array is not at the end, you grab the first value of the array and move one further back into the array. 

Note that the prior checks (as shown in Tim's answer) ensure that the list is at least of size 2 and that you aren't removing either the head or the tail. The start and end conditions ensure that you only remove things between the head and the tail. 

That tells the reader what you think is happening. In terms of this code review, it might let someone point out that can also return on an error. It also looks like fgets doesn't always return on Ctrl+D. Try entering some input and then hitting Ctrl+D. At least that's what I get from the documentation. 

Should that be instead? It seems unusual for a successful connection to evaluate as boolean false. First, I moved your variable closer to the single statement that used it. Then I looked at it more and skipped the intermediate variable entirely in favor of a variable. This way there isn't a ternary operator embedded in a function call. You could put back the variable if you wanted. I had some trouble finding where was used. I also moved the memory allocation and copy into together. That makes it more obvious that they are associated. I have much the same kind of comments for as for . In , you have 

I'm not sure about calling there. It might be better to throw an . Note that I also have the board track the empty space separately in this implementation. That saves calling every time that you want the empty space. Just call it once in the constructor: 

DRY Part II The functions , , and also should watch for the situation where the is outside the list. For and , you may want to define a function that you'd use like 

There's no need for an else clause that has the same code as the then portion. I also changed the inequality order. The reason is that in C style languages it is particularly easy to write where you meant to write , , , or . As a general rule, it is valid to have an there, so the compiler can warn at most. If you write the comparison backwards, e.g. , then the compiler will throw an error on the typo. This is by no means required, but some of us do it as a matter of course. Obviously there's no point to this unless you are comparing to a constant type value or an expression. Incidentally, I prefer not to use an else with a . An else is essentially negating the if check, so you have clauses for and not . I find it easier to follow if it is and not . Note that in some cases the else is so trivial relative to the main clause that it doesn't make sense to invert them, e.g. 

I changed to , as that seems to better describe it. SQL is what I'd call the input to , not the output. The function returns a resource handle representing the statement that SQL will create. I also changed to , as that better reflects what it holds. I removed the variable and took the out of the block. This way it returns a consistent value when it does not fetch the title successfully. 

By defining this as a , you make members (unless overridden). As a general rule, it is preferred for members to be as a default. If you are marking a member as then you should have a specific reason for that member. That pushes you to write code that does not rely on the members being . You do not seem to be publicly using your members, so you might as well make this a . Note: this is not to say that there is never a reason to use a or member, just that I see no sign of such a reason here. 

Bugs! There is a bug in this. It prints for and , which should both print . Note that if then is always true. Perhaps you meant . Also, should probably be . std::find The simplest form of this would be something like 

is more robust. For example, what if you change Enqueue to take a collection of items? Note that you want to compare the sum of startingPos and Count to the array length. Otherwise, you may overrun your array even though it doesn't have much in it. Also, you may not always want to Grow when you hit the startingPos + Count issue. Some of the time, you may want to just reset the array so that startingPos is 0 again. Alternately, you could make the data circular (when you hit the end of the array, start putting things at the beginning again), but the logic for that is trickier. Unless you are really memory or time short, the dumber solution is better for robustness reasons. If you implement a Reset function, you may want to refactor Grow and Shrink so that all three call a function that handles the array initialization and copying. Or just replace them with something like 

This replaces nine statements with four. That seems a bit better. If your compiler will support it, I'd prefer the full word Unicode properties to the single letter versions. . 

When doing a comparison like this, you should really consider creating an interface, e.g. , so that you can maintain consistent method interfaces. You can then have your two permutation types implement the interface and use a templated generator class. 

The will reverse the arrows from the way that they are in . So where you had , you will now have . Using the ensures that you will have parallel matches in both. You could declare a second constant, but then that would be fragile in the face of changes. This way you can make changes in a single place. Then replace the as follows: 

As a general rule, you shouldn't unless you know that you will always want every column in the row. In this case, you only want , so . You currently return the last row with that ID even though you fetch all of them. I'm guessing that is unique -- only one entry with a particular value in the table. If so or if you're just happy with returning the first value found rather than the last, it's more direct to say 

This allows for more flexibility than the other version. As a general rule, it's best to put as little code inside a block as possible. Only things that can throw an exception that should be caught by the and connecting code. One reason is that other code than you originally intended may throw the exception and the solution in the block may not apply to the new case. 

That reduces your duplicated code, easing maintenance. It also eliminates the bug where you weren't updating the size. This is one of the main reasons why duplicate code is bad: it is easy to have inconsistent results. Don't trust your input