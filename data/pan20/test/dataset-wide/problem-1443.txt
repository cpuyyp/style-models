This will be easier to understand, and the names of the functions helps document the code. Let's look at the SQL: Use prepared statements and parameter markers as much as possible rather than concatenation to build your SQL statements. This will reduce your susceptibility to injection attacks. This is particularly important when concatenating strings together as it is the strings that can contain raw SQL which can change your statement when concatenated together. This includes concatenation by variable replacement as you are doing in several places. This is not as big a deal if you are concatenating in values read from numeric database fields, but you still need to make sure that you don't inadvertently replace numeric values with strings. Since PHP is a dynamically typed language, this is a distinct possibility, and needs to guarded against. Don't use unless you are aggregating values. There is a group by in your DB2 Query which I can only assume is being used to remove duplicates from the result set. If you are getting duplicates, use DISTINCT instead. It is more semantically correct. When I see a GROUP BY without aggregation terms, I wonder why the GROUP BY is there, but DISTINCT tells me that you only want to see unique rows. Note that your group by could still be providing duplicate rows since there are more terms in the GROUP BY clause than there are in your SELECT clause. Things that could be causing bugginess: 

This is equivalent to what you are doing and removes the variable entirely. Bugs There are bugs in your program. @Mathias provides an example as to why your code is wrong. You should consider @vnp's comment. The typical game tree traversal involves a reduction phase of some sort. As another hint, you should really review slide 27/39 of these slides. (Ask yourself, what does your code do differently than what is on that slide!) Abstraction (and more hints) You can actually abstract a lot of this. See my question here for a general framework on solving these games. A general framework declutters a lot of code. However, as mentioned in the prelude, a mathematical analysis may (or may not) provide a better solution than the general framework. 

What does mean? You proceed to use it to determine the level (i.e. ) but it is not clear from the name (or even the method you use) that that is what does. Java 8 now supports - statements for strings. You may eventually want to refactor this into some sort of "difficulty" , but for now, I would change the level select to a switch case instead of - chain. See this answer for the syntax. 

Use named indicators rather than numeric indicators. Even with display files. The keyword should be used to name your indicators. Otherwise you are going to have to keep going back to the display file to determine what all those numeric indicators mean. It is a lot more readable if you can write something like rather than . Use file references. That is activated by the keyword on the file spec. This way you can keep your file activity seperate by using a qualifier rather than by forcing yourself to rename fields or set prefixes. This allows you to read and write into data structures and assign values by name (using ). Break SQL out into it's own procedure, it just clutters the logic of the routine that contains it. Because local variables and parameters are scoped to the sub-procedure, the does need to be in the same sub-procedure as it's associated , but keep everything else separate. Don't mix and match command key processing. In your DDS you specify but . You are also assigning indicators 01 - 03 to subfile control keywords. So F3 must be detected by the AID byte in the file information data structure or the old K indicaotrs, but F5 can be detected either by the AID byte or , and - don't refer to Function keys. This will be initially confusing to anyone coming behind you. Either use the AID byte exclusively, or reserve indicators 01 - 24 for function keys F1 - F24. Once you start using on your display files, the K indicators will not be usable. Not a big deal, the letters aren't contiguous anyway (there are gaps in the sequence, do you know off the top of your head where they are)? Finally, your life will be made a bit easier by using a message subfile rather than a standard subfile for error messages. 

Small syntactical changes should at least be . Some would probably argue that you should spell out and entirely. I personally like small names, but regardless, the capital should not be there. You wrote this one time: 

Inside the function. Function naming should be renamed to . Better algorithm is unneeded and limits your algorithm significantly. I would over the of your string: 

Seems like it can be abstracted, what if the user wants to change the location? Maybe by default use this location, but allow the user to change it. Create a default argument to but give the user the option to specify it. Same with: 

Your code doesn't use pattern matching well (it is kind of unecesary the way you use it). I would advise you take the solution you have and rewrite it to use pattern matching more like the Rosetta Code solution. 

I have a few observations from looking at your code. Some of them are related to the PHP code, some of them are related to the SQL. Some of these observations may also help you resolve some of the perceived bugginess of your code. Let's start with the PHP: Use only one database abstraction per database type I see that you are using three different database abstractions to access two databases. I would try to bring that down to two: one for your DB2 database, and one for your MySQL database. I am guessing that your code is using both PDO and mysqli against the MySQL database. Choose one and use that. If you need multiple connections to a single database, you can do that with a single abstraction. Use different connection handles or objects to differentiate between your connections, not different database abstractions. Use functions to structure your code It could be that your code is using multiple database abstractions to keep your MySQL connections separate. A large monolithic block of code can be hard to visualize all at once, particularly if it is doing a lot of stuff. Break things up into functions that just do a single thing, then assemble the functions into a main procedure. For example: 

Should probably wrapped into a "main function". Furthermore, to keep stuff in the "main scope" I highly recomend you actually make a function. So instead of just: 

Take in a divisor count. Index through each triangular number and check if it satisfies the condition. If it doesn't increment and repeat. Once it does print out the results. 

I wouldn't go as far to say that functional programming and Python don't mix, but you should really consider what you're going for while writing it whatever language you are writing in. I would not make your goal: 

is strictly increasing. Calling will stop a particular iteration quickly, but really you can stop a whole cycle, switch it out with . 

Is unneeded. (Although, there might be some weird floating point thing I'm not taking into consideration. Regardless, you can adjust for this.) Don't have: 

I would say that if you are looking for a code review of code written right now, you should be using modern practices. I can excuse the lack of as it appeared with v7.3 (PTF'd back to v7.1). But you still should be using free form H, F, and D specs. Also ditch the O specs for print files as those do not have a free form equivalent. Also realize that by sticking with SEU, you are not able to use any advances in RPG or SQL put forth since v6.1 (about 10 years) without turning off syntax checking. So that is a big issue as well. On to style, I have just a few points here: 

The GROUP BY Using the wrong array to provide parameters to your PDO prepared statement because your big chunk of code is unwieldy.