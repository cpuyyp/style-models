@BroiStatse gave a very nice answer. I would like to give my observation about his two last points, and take them even further: When delegating a to a method, you can use a shortened syntax using : 

Meaningful names - names like , , do not add any information about the code, and are similar enough to confuse. Other names like , , are even less helpful. is much more valuable, and make most of the documentation redundant. Don't use the same name twice - you use as a method name as well as a variable name, this is unreadable, and potentially error prone. Don't overkill - the problem is finding all pairs of numbers which correspond to some restriction - it's like writing a big table with n lines and n rows, and marking each one which fits - that would be \$O(n^2)\$, anything more complex would be wrong. Your use of recursion is unclear, and I can't see the point of it a simple loop would suffice: 

You do not properly check for the edge conditions, i.e. when is or empty. You are setting members of your child's instances in the parent - you should move that to your constructor. Your code is not DRY, since you call twice. 

Is a URL suffix? Is the column in an ID? Neither option seems plausible, so it might be a naming problem - name the fields appropriately to what they hold: 

and all the helper methods are no longer needed. Indentation and readability When parsing the time string you've got a piping block which looks like this: 

I don't see anything wrong with your implementation - if it works for you, and does not interfere with the system - go for it! I will even go further and claim that the guard conditions in your internal constructor are redundant because the constructor will only be used by the single public constructor, or by a test which: 

Why is that important? You go over the whole JSON, and discard everything - but you gain nothing. Simply use only what you need, no need to actively remove it. 

You should expect Starting a couple of years back, is moving to a new expectation syntax, you should consider porting to it: 

Your algorithm is also unclear - you create a list on each iteration, which always contains exactly two elements - and - is it a bug? Meaningful naming - use names which convey the correct meaning - does not convey what the list is used for, is confusing - since it is used in the current level, not the next... 

Succinctness As rubyists, we love being succinct, and we love playing with enumerations. You will see very few literal and in ruby code, as well as very few explicit calls. For example: Instead of writing we will prefer to compound the condition to which will do the same thing, but we "save" . The power of Enumeration Ruby has a very powerful , and is used widely, often more than once in a line (using method chaining). For example: 

Changes is will be similar, I'm leaving this as an exercise for the OP. Another small observation - your does not have a , which might prove problematic... 

Regarding your benchmark, I believe that 'warming up' is a little like cheating... you are caching the results in your static array. If you wanted to have a high-performant solution, you could have pre-calculated the first 1,000,000 primes, saved them to a file, and read them at the beginning of the procedure... :P 

How is it better than your current code? It is not more expressive, nor is it more succinct, nor DRY. Also, these associations are similar to some extent, but they look as DRY as you can make them - one is , while the others are , one uses the default idiom, while the others have names different than the associated class, conditions are different (and though one might argue you can predict the filter by the association name, one is singular, and the other is plural...) In short, I think your current code is good enough - any change will only harm readability. 

Be more transparent Your code hides pretty well the fact that and is different from and - both in your code and in your tests. It makes your code quite obfuscated (in the name of DRYness?) - you should make it clear that you have two different behaviors - and spell them out: 

You don't need to define empty actions in your Controller. Your code should even if you delete all the empty actions, leaving you only with the views and routes: page_controller.rb: 

returns an array of two arrays - one where the elements returned to the condition, and one that returned . So, a single liner for your need would be: 

This is a very problematic line of code, since it logs as well as changes the value of . The change is also not as obvious as you think, and might easily be missed. This causes two problems: 

Showing that is inside the function, and not after it. Playing with the idioms You can parse the string using the recursive method idioms, which would look like this: 

Assertions? Assertions are used by some languages to make some development checks where a condition is assumed to be always true. This methodology is not longer en-vogue in most places, and even where it is - it is also disabled in production: 

Indentation Be sure to indent your code properly. Indentation helps the reader understand where he is in the code (how deep). Some languages actually depend on correct indentation. Meaningful names You should give your variable names which will have meaning, and will help the reader of your code understand what each one is responsible for. Names like , , should not be used for any variable other than immediate throw-away variables like if . A variable name should never ever be used, since it is too easily confused with the digit , so in some fonts you will never know the difference between and ... Your code should tell a story Try to design your code in a way that a reader will be able to follow your logic. In your code, there is an endless loop, and in the first you check whether a mysterious is , and if it is you end the game... The story starts with the ending! A more pleasing option might be: 

Final note: I guess that the public constructor actually uses and in some code you deleted from it, otherwise, the guard conditions there are also redundant... 

First, I'd like to say that your code is written very well, and is quite readable. As for your question - your code runs at least once per word in your text. Since a line should be (quite) longer than a single word, I think you can reduce the number of calls substantially. I can think of two strategies: 1. Binary search 

In your code the need for the assertion seems a bit artificial, since it checks that the first character is exactly the character pushed back by the caller: 

Too sophisticated for your own good Let's look at the condition you worked so hard on for being lazy: 

This strategy might need a little refining, but it should reduce the number of calls to considerably. 2. Approximate line length 

Class per test vs Class per Method Also, your code example implies that each class contains a single test, which loses all meaning for the class. The post talks about a class per method tested, which mean that it may contain more than one test, but all tests are relevant to the same method. 

Others have suggested different strategies, I'll comment on your code: Meaningful naming and are abbreviations, which are rather ambiguous. Better call them and . The name of the method () adds to the confusion, since it is not apparent what exactly are you adding. is more descriptive. Method names should be actions (, , ), but variable names should be nouns ( instead of ). This is especially important in ruby, where the same syntax might either call a method or refer to a local variable. Make your code human-readable The innards of your method are quite 'magic'. For the casual reader there is no way to understand why what you do there works. A lot of s and s, and and with no rhyme or reason. Build your solution in a way that a reader who is not familiar with it will understand what you are trying to do. Otherwise, she won't be able to maintain your code when needed. You won't be able to maintain it to in a couple of months, or even weeks. Break it up to meaningful helper methods. Try to keep meaningful structures (if you are concerned with whether the ID is odd or even, maybe a better solution will not include flattening the store in the first place?). If you find that you are still left with unintelligible code (and only as a last resort!) a couple of comments explaining what you are doing and why may be very helpful. Redundant logic 

Mutable Long? I did not follow you explanation about , for one thing since I can't see that it even supports ... Also, when in each line you have numbers in the range of and , how big you expect the files to be? The max number is ... Magic Constants A constant like is not very useful. Using the literal is readable enough, and resolves any ambiguity it might have by hiding it in a constant: 

Unclear algorithm - in your method you create a variable, which is half the length of the item list. This suggests you might do something binary (recurse the first half of the list, then the other half, or something like that). Actually, you are going over the list item by item linearly. This creates a very unreadable code, and it took me quite a while to understand what it actually does. If you are iterating over the list - use an : 

Since in ruby returns the last element in the array (), there is no exception! If the computer chose (id ) and the human chose - computer will beat human, since . In short: 

Was that a result of an unfortunate copy+paste? Again - comment is not helpful, only confuses. I also believe the prompt will appear only after the user entered it, since you check before you print the prompt. 

In OO design this is expressed as an relationship - "ChangeRequest is a WorkItem" A nested class is a class which is declared inside another class, it does not inherit anything from it, though it might have special permissions to access its enclosing class: 

Naming You should give your classes and variable meaningful names. Class names should not be verbs, but rather nouns - also doesn't really convey what the class does - will do a better job. Variable names like , and might be technically accurate, but they don't help the reader know what they mean - , and would better convey meaning, and will make your code a lot easier to read. You should always abide by the naming conventions of you language of choice - camelCase for java variables - is a bad variable name. is worse. There is no need to repeat the type of the container in its name: is better than . Redundant code You found a very curious way to assign the variable - you are actually assigning it times! There is no need to assign it with , and definitely no need to override it times a simple: