NB I've assumed that GetValueByName is now a static field - it makes no sense to me for it to be a method of Invoice, as that both pushes functionality into Invoice which is nothing to do with invoicing, and limits its applicability. I would be tempted to make it an extension method of object. Also, I've used your for consistency, but when I do things like this I prefer to use and reuse 's syntax. I also handle and take an IFormatProvider as an argument. 

The indentation is rather messed up. I suspect the original code mixed tabs and spaces with a tabstop other than 4. StackExchange converts tabs to four spaces. 

This is overkill. It suffices to add each edge once: you don't need to compute the transitive closure. 

This looks backwards to me. creates the lock file, then creates the JSON file, and finally deletes the lock file. I think the logic should be 

In a word: itertools. If you're going to enumerate over combinatoric structures in Python, it's worth knowing. Note that you have to have a clear idea about what constitutes an equivalence. Here the double loop is inefficient: gives the same sum and absolute difference as . Also, you don't care about repetitions: gives difference 0, which by the terms of the question is not a pentagonal number. Taking those two things into account, you want . 

Avoid massive chains of statements. The various checks here would be better refactored into a function which can take advantage of early return. 

this code will run for a very long time even though I can tell you without running any code that the output should be 

Show me the method without a name and ask what it should be called, and I would say . The name implies that this is called in response to the street view being shown, so it makes no sense that it should itself hide or show the street view. I suspect that it's actually an autogenerated name for a button or checkbox called , but autogenerated names are not always useful names. 

I understand that this was for a demo rather than production code, but it's really neither idiomatic C# nor good OO. I would have preferred 

Before even thinking about performance, concision, etc., run JSLint or similar over these methods and fix the indentation, other whitespace, and bugs. As it is the lack of consistency and poor indentation makes it hard to read and hides things like a missing comma which is leading to implicit semicolon insertion: 

looks weird to me. If it's necessary to split into multiple lines (which I'm not convinced of, given that essentially the same expression is on a single line in the ), wouldn't one tab be sufficient indentation rather than two? 

is a bit suspect. You could get different results with the same test case on different machines, or even on the same machine in different locales. 

However, that's not the final word. Na√Øve string search is asymptotically inferior to techniques such as Knuth-Morris-Pratt string search. You probably shouldn't roll your own KMP routine, but you could use to get the benefit. So a better implementation would be a loop around . 

This is quite alarming. What is ? It seems to be using a field to pass a value whose scope is a single method. If the tasks are executing in separate threads then this is a definite bug, because there's no synchronisation and one thread could overwrite between another thread's assignment and invocation of . Without it's probably safe, but it's definitely a code smell and risks becoming a race condition if the class is refactored. I should also add that the name is confusing. If it's just getting data from one blob, why is it not ? 

which isn't the correct output format, and breaks if the number of cases isn't 100. In future please post your actual code for review, not a hacked debug version. 

does almost the same thing: the only difference is that it does an extra at the end, hence the changed loop condition. 

This is a red flag that this code isn't yet ready for other people to review, because you don't seem to have reviewed it yourself. It's not quite the only comment, but there are only two more. The node class really needs explicit documentation of the invariants which are assumed to hold, because otherwise there's no way of checking whether the methods which modify it maintain / restore those invariants. For this reason also I would say that the code isn't yet ready for review. 

What happened to the indentation? Why do some have a space before them and others not? Why the blank line before the closing ? is a mouthful. Extracting a local variable with a short intelligible name would improve readability. is not only a bigger mouthful but also potentially very expensive. A common subexpression which takes non-constant time should definitely be extracted to a local variable. The comments are largely noise. The only one which contributes to my understanding of the code is the one saying what is supposed to contain. 

tells me that s will be accessed in LIFO order, but doesn't tell me what each means. Is it a count? An encoded permutation? 

Maintainability Maintainability is important in its own right, but also particularly relevant to security because unmaintainable code is more likely to acquire bugs over time. Fix the indentation. It currently appears to be at random, and is completely unreadable. 

Names are key to maintainability is a useful name for a datatype, but as a name for a variable it is opaque. 

KISS My first thought when I started looking at the code was that the first few lines seemed unnecessary: 

So if is between and but is not found in the table, that's an ? It sounds to me like an . However, if the logic given here is correct, then we can refactor as 

By using iterables it tackles the memory-optimization issue effectively. However, it is possibly not as efficient as it could be because of the way it splits up the work. 

Linear search is never ideal. If you're using a recent standard, is asymptotically preferable, and also IMO conveys the purpose better. Or maybe you would be better off with , which would remove the need to sort at the end. 

then you can replace the and maps with a single in priority order and replace the first 41 lines of the first code block with 

Java naming convention is that class names should start with an uppercase letter. is also not very informative: what does it check? 

Rather than counting configurations, generate them; then find a canonical representation and add that to a . Ensure that you only generate the canonical representative of each equivalence class in the first place. Count them (generating if you must), but at the same time count symmetries, and record counts per symmetry. Then divide the count for each symmetry by the size of its symmetry group and sum. Run various counts, one per symmetry, and then account for the double-counting. 

Under what circumstances would ? I suspect that this should be asserted false rather than handled as a special case. ? If the collection needs to handle multiple orders, perhaps you should forget all about / and instead use to define the ordering. 

There's more than one algorithm to find an nth root. It would be more accurate to say "Uses the Newton-Raphson algorithm..." I wonder whether it would be worth using the secant method instead, but I'm just throwing that out as an idea rather than a recommendation. 

(As an aside, I don't think that is a great name. English doesn't inflect adjectives, and it's not a standard "nouning". Now that the name is no longer used, I'd refactor renaming it to ). 

Length in what units? Generally with cryptographic stuff it's clearer to explicitly use bits as the unit of length. 

You can avoid creating a bunch of temporary strings (copying all your character data twice) by using StringBuilder to something nearer its full potential. 

have wholly unnecessary explicit casts (which in the second case generates a warning) because you're using the raw type . Both can also be simplified using the same syntax which you use when making the copy of the power set so far. 4. KISS You have three loops (including the one hidden behind ), which seems to me to be unnecessarily complicated. If you make a shallow copy first then you can combine the deep copy with the adding an element.