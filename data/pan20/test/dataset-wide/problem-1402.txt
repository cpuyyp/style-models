Note that in Scala you don't need to use a statement as long as the last bit of code in your function returns a new value. 

I was able to reduce the run time of your code to a few seconds (2 seconds on my computer) by changing the type of from a to an immutable . You were correct that was the major bottleneck in your code. This is a bottleneck because checking that an item exists in a means inspecting every item in the until we find it or reach the end of the . Fortunately we can use a (which under the hood is supported by the class) and reduce the search time for objects from linear to effectively constant. Notice that in the code below I simply applied the method to your function converting the returned to a . 

Overall your code is very reasonable for somebody learning Assembly, I would say quite nice work. I can produce something what will look more advanced (I hope), but it's more like tiny details improved here and there, and some of them for the price of worse readability of source. I mean on the syntax and low level. On the algorithmic level your code can be improved considerably, as Pawe≈Ç already answered, but he missed another opportunity to halve number of divisions. My variant of code, showing: 

Hmm... ok, one bit of source just to make it look a bit less like "wall of text" (although I'm afraid it's too late for that :D ). 

Actually, ignore my previous answer. You're looking for the binascii module. It uses C modules for performance. 

While a full object-oriented approach would work, I would go for a more lightweight solution that leveraged Python's native data structures. First, define all of your states like so: 

While this solution works, the parsing bit seems rather ugly, especially how I deal with days and day ranges. That part would be easier if I could just test if today's day of the week was in an allowed set of days, and I feel like that might be possible using , but I have no idea how to do it. Any other suggestions? I'm rather new at this parsing thing. 

Well, that about sums up the changes I would make. If you have any questions, don't hesitate to comment! :) 

Style Comments Methods which take functions as parameters ( and in this case) should be invoked using infix notation. That is, if there were a god of Idiomatic Scala Style he would prefer to Defined functions should use camel case, e.g. over . In general, and you will get a feel for this the more you use Scala, pattern matching is preferred over if-statements. You will notice that in your function I've swapped your if-else statement for a pattern match on the value . The last style tip I have for you is to break a chain of higher order functions over several lines. This last one can be fudged in some cases, but in general I find that it improves readability. Efficiency Comment The one change that I made in the name of efficiency was to change the container type of from to . The reason I made this change is that accessing an item in a takes linear time on the length of the list, whereas accessing an item in a is almost constant. And as you know, you are accessing elements of by index is in the last line of . 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

EDIT: The invalidity of PIC-ness was nagging me, so I finally did dig into the issue, and fixed it, these are things to be modified in the answer above: Commands to compile: 

(I did debug it in NASM, so if I'm unlucky, something may fail in FASM due to syntax, but it should be easy to fix. But it's highly unlikely, they should have identical syntax for instructions and I don't use any macros/etc) 

Overall I'd say your off to a great start. Here are some of the changes I would consider making to your code: Formating Output When printing strings that encapsulate values/variables you have two (idiomatic) choices in Scala. Option one is to use string interpolation: 

CASE CLASS I would change to a . One reason for this change is more concise object declaration, e.g: 

Here are some changes that you could make to your code. I'll explain various parts of the script below. 

When pattern matching and inspecting multiple values of a sequence type (, , , etc) you can reduce the length of your expression by using sequence patterns instead of explicitly breaking the sequence up with the operator. So instead of you can more concisely use . When you want to check for explicit values while pattern matching on an object you can use those values instead of replacing them with variables that are then checked with an statement. For example can be more concisely expressed as When using pattern matching on sequences (especially when the expression goes beyond the standard ) it can enhance legibility to use single letter variable names and comments instead of long variable names. I think that we would both agree that good code should describe itself through both value and function names. However, in this case there is no way of adding intuition with function names and so all of the description ended up in your value names. Like I said before, do what works for you. If legibility was our only metric then maybe pattern matching isn't the ideal way to implement your function. It could still be recursive, but instead of s you could use functions. Do whatever suits you the best but when possible I would recommend short variable names accompanied by comments over long variable names. 

I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code. 

I would say that your latest code looks fairly sharp. However, after translating your code to something I could test, I noticed a pattern that could be captured with the code below: 

I've introduced a smidgen of strange syntax just to show you a possibility. As a way of explaining what is going on, consider that the following are functionally equivalent: 

With the above code if I set to my run time dropped to ~70 ms (naturally this number will vary on different machines). This code is a bit more bare-bones than what you have and may not fit your style but it is quite a bit quicker than what you have posted. The significant changes are 

The first thing that comes to mind is just to cache user permissions in memcache, but that might or might not be necessary. I'd try this way first and see if you run into issues. A simpler approach would be to define each user's key to be their username, then use get_by_id(). That has the advantage of being automatically memcached by ndb and being faster (I think). 

The following code is intended to parse a string of the following format and return whether the current time falls in that window: 

You don't need to list those as globals. Variables defined at the module-level namespace are available in functions in that module. Just remove the global declarations and you should be fine. Another thing: calling is kind of dangerous. It's always better to do this instead: 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

Hmmm... anyway, I really like what you wrote here: "I'm noticing that reading doesn't really help much as much as writing programs and running into issues and solving them." This is absolutely spot on. All this general babbling around usually makes little sense when hit by real world problem. Also refactor a lot. Not just the code, and implementations, but as learning is your goal, dive deep into finished project and go trough all the API, all the abstraction, and try to imagine something better, easier to use, easier to understand it's responsibilities, easier to read and get the idea and eventually easier to implement (although sometimes to get better API and abstraction the implementation can be more bloated, but the cost of bloat has to be clearly justified by the cleanliness of resulting API/abstraction).