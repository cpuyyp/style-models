This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

Each move has some seemingly intrinsic characteristics. In particular, each of their name should be lower case Strings, and their values are limited to some given set of words. My impression is that these rules aren't bound to change that much anyway, so why rely on the rules engine to impose them? For one, instead of checking if their names are lower case, why don't we just ensure that they always are? Instead of making it a rule, why not turn it into a basic assumption? 

Now from your question you state that you do not intend to use the method anywhere else. Your example tends one to think it would be beneficial in other situations as it is fairly generic. In that situation I would be leaning towards an extension method as others have pointed out. However I often find myself in the situation where a block of code will be repeated in a function and only the variables passed in will vary dependant on local switches etc In this situation I think it's perfectly reasonable to create a local delegate and use that in the function only. So, to summarize. Yes I think it's acceptable. In your example, probably not, but in situations where the block of code is local only to that method and you know that is the case, then yes. You can always refactor later! 

I'm not sure of the purpose of the () method. If we are reading the file when we first access the singleton instance why do we need this method at all to be public? could we not ensure it exists in our constructor? When using the singleton pattern I always like refer to Jon Skeet's article on it. 

I don't know what field represents, but I kept it. However, due to the fact that it's not readily understandable, you should reconsider why it's there in the first place. In any case, notice that there are only getters for this class, and no setters. This is because, like I said, objects most likely won't need to change, there's no point enabling the state transitions in them. Rules Integration I missed a critical aspect of the problem you're trying to solve with your code, which is the rules engine primarily geared towards not-so-technical people. However, I still think that having those rules in the system does not mean we should completely forget about good OO design. I believe that rules should augment your design, not hijack it. Since having a enum is quite restrictive, my idea is to define it instead as a value object: 

Normally, I do this for methods I have yet to implement while I work on specified methods one by one. 

If you wanted to add properties for each individual day to make it easier to access say for example Monday then you could easily do this such as. 

This is more a suggested slight tweak to the excellant ideas and solution provided by Jeff. I would potentially look adjusting the ProcessedSingleName method as below 

Using existing MVC helper methods When creating links in the view I always like to use the built in MVC helper methods such as or . This means that if the site is installed in a sub directory the correct link will be created automatically for you. i.e. . If you currently deployed the solution you have your links would break with a 404 Not found. 

Have you considered using log4net? If not I would recommend this as a simple and well tested logging framework: Other considerations to the implementation might include: 

Mapping model to ViewModel As Kevin has suggested there are great tools out there already that do this for you. I haven't personally used any of them but I have heard good things about AutoMapper. Making use of Partials for sub view models Because we have now separated the different elements into components I would consider creating a different partial view per view model. This way even your views become re-usable and you share common view presentation around. i.e 

There's quite a few things you can fix here. If it is not already in version control, do that first, and then do a commit for every improvement; that way, if anything goes wrong, you can roll back easily. Git is good, but use whatever you know. Firstly, the business logic and the page layout need to be separated. Many a tutorial on the web mixes the two up, perhaps because many years ago programmers were just too thrilled with the web's possibilities to remember the benefits of modularisation. So, at the very least, move the first half of the code to a separate file, and then it in your first line. That becomes your 'logic' file. Whilst you appear to have a few functions in your logic file, the bulk of this is not split into functions at all, and ought to be. There are too many variables sitting in "global space" that need to be local to a function; this will destroy them when each function ends, which is what we want. That said, a few will need to persist in order to be displayed in your HTML layout; potentially they could be the results of functions, although there are several ways to do it. One step better would be to use a templating engine of some kind, so that your business logic is wrapped up nicely in objects. However, that might be a case of trying to learn too many things at once, so perhaps leave this one for the time being. In terms of the logic itself, try to avoid the error suppression operator, since it will hide problems from you during development. It is better to test intermediate database operations (from connection, then from the query, then from reading results) and just output an error gracefully. I noticed also that the clause in has two paths that do exactly the same thing. You may wish to check this. Where you do a financial transaction, this must be in a database transaction to avoid something being being debited without a corresponding credit - you want this so either everything completes or nothing does. The refers to an absolute pathname rather than something in the current project. It is better to obtain this path from a configuration file, rather than "hardwiring" it into code. Also, this appears to be a PHP file - note that this PHP will not be run to generate data - will treat it just like a text file. 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

If we're speaking of actual efficiency (as in performance) though, I don't know how much more efficient pattern matching is compared to iteration of characters. However, this is much more readable. In any case, notice that the actual translation logic is wrapped inside the condition that the input string does not contain a number. This way, you return from the method as soon as you determine the input is unacceptable. To check whether the input string starts with a vowel, you can also use pattern matching like: 

No I don't think you necessarilly need a viewmodel and there is plenty of debate on this on the internet. However I personally like the viewmodel approach as it provides the flexibility of adding any UI specified fields I would like without the overhead of my view being tied directly to the buiseness model. Of course this means also that you now have to have the rules copied twice like you mentioned. However if you were using jquery validation this would be the case anyway (or so I believe). 

I would supply all the variables that you have hard coded into the method i.e. localPath, filename, ftp server, networkcredentials. Otherwise how can you re-use this method for other operations? I would probably avoid making the method static unless there was good reason to. In your finally clause you don't check if responseStream or writeStream are null? What if they never got created before an exception was thrown? I personally think unless there is a very valid reason you should always do something in an exception catch block, whether it be logging somewhere, re-throwing the exception or anything. Otherwise the calling method will have no idea that something went wrong. What is _result? I don't see it being set and I don't see it being declared anywhere? If Length is a constant, make it a constant. i.e. const int Length = 2048. I might also consider implementing some sort of call back method so you can provide status updates on the progress on the download. Just a suggestion, not sure how you would implement it exactly.