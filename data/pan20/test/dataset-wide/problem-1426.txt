Problem Background Essentially this problem is asking you to remove all palindromes of even length from the string as they are first encountered. So becomes and NOT even though both and are even-length palindromes. Naming Unfortunately, I cannot think of a succinct name for what operation this function actually does. You could go with but that is a bit much. I would just stick with and document the function with some commented examples. Method The good news is that you do have the right solution by using a stack. The bad news is that you are using some unnecessary intermediary data types for processing. Note that you do not need to put the data into an actual stack. Instead you can just use the output string as the stack. By eliminating these intermediary data types and processing steps, the code is much more readable. Here is a char array solution: 

Bugs Your optimized routine has a couple major bugs. I always recommend checking the output between original code and optimized code should you need to perform optimization. 

Since I am not a Java programmer I will just comment on the core algorithm here. I am not sure if there is a non-naive solution to this problem so I will focus on the naive approach. 

Another approach This is a fairly poor analogy but here it goes anyway. What if I told you to flip through a deck of cards and tell me if there are any Jokers? Which approach do you think is better? 

As mentioned in the comments this code is not long winded at all. It is very clean in general. Too clean in fact as you will see below. 

Background I will first change some notation since I do not like that \$M \geq N\$. Let \$A\$ be the minimum number in the range to check and let \$B\$ be the maximum number in the range to check. The task is to return all Stepping Numbers inclusively between \$A\$ and \$B\$. Be careful when trying to find Big O of your algorithm. You assumed your algorithm was \$\mathcal{O}(n^2)\$ but you never defined what \$n\$ represents. If you let \$n= B - A + 1\$ and \$d = log_{10}\,B\$ then your algorithm is \$\mathcal{O}(nd)\$ since you must iterate through \$n\$ numbers and perform an operation on each of the \$d\$ digits (on average) of each number. General Advice This section is a mixture of coding style tips and finger-pointing at some sub-optimal code. Most of this advice will not end up in updated code section, but I think it will be useful to you. 

As mentioned in the comments of the other answer, your decimal floating point numbers are stored as binary and rarely have finite representations. If you simply want code that passes your test I would mention that it is much easier to remove padding from than it is to expand the scientific notation. 

Yet Another Approach By restructuring the recursion we can remove the skipped parameter. The trick is to use recursion only when needed. Iteration suffices to skip indices but we "must" recurse to choose an arbitrary number of elements from . Here is a simple substring printer (powerset) using this method: 

Performance Scalability is always what I look for in problems like this. Yes a may not be that big these days but why limit ourselves with inferior algorithms that do not scale well? Consider you have the number $$n = 123456789012345678901234567890...$$ Let's just say this number has \$m\$ digits. You will end up performing \$2m\$ multiplications and \$m-1\$ additions. However, of those multiplications, you can only have \$10\$ unique values since there are only \$10\$ digits. You should therefore pre-compute the powers so that you do not have to recompute them over and over. 

Now we no longer have any explicit loops (in the matlab code at least). This algorithm is much faster and simpler. Consequently, it is much easier to port to C. You will find that for , for your algorithm has dimension and for the simplified code I provided it has dimension . However, in your original algorithm, and are always the same if , hence you were performing one calculation too many. Now let us reincorporate the variable step factor. Realize that if we increase it is equivalent to taking every \$\textrm{tstep}^{th}\$ output after the cumulative sum. So if you want you perform the same three-line code above but at the end sample it via or in general . You can use to compare the outputs of your original approach to this approach. Remember that you one-padded your output so if you use \$\textrm{tstep} \gt 1\$, you need to remove the extra padding when comparing the matrices. Finally the last index of the non-padded output will differ as well (if \$\textrm{tstep} \gt 1\$) since your computation computes the last index differently than the rest of the indices. You can fix this by performing instead of simply however the latter approach is more consistent in my opinion. 

Now you just want to be able to detect if there is a gap in each substring. This can be done quite simply if you keep track of whether you ever add a gap. Use a boolean instead of manipulating the string. 

First let us remove the variable step factor. So . I will reincorporate the variable step factor later. Let be a \$m \times n\$ matrix. yields a \$m \times i\$ submatrix of . Let . This yields the column differences of . 

Notice that operator[] inserts elements if they do not already exist in the map. If you do not want this behavior or you want to handle the error differently than returning a value-initialized unsigned int then do the following: 

The reason that we do not handle zero being a Stepping Number is that appending a digit to zero does not result in a new unique number compared to what we already had. There are a few different relatively simple ways to include zero in the output if necessary. Note that I used more comments in this code than I normally would in an attempt to be make this post more instructional. I do not want you to be under the impression that you need to comment 50% of the code. I generally only comment lines that are not self-evident. Whatever that means depends on the context. As a final note, if you do not like recursion then you can generate all \$1\$-digit to \$d_B\$-digit Stepping Numbers instead. You would initialize with all 1-digit Stepping Numbers (except 0) and use to create higher-digit Stepping Numbers. The advantage is the code would be simpler (you could remove ) and a potential disadvantage is creating and filtering a larger list which could be slower. 

Ignoring integer wraparound the second condition suffices. The only way \$x \cdot y \cdot z = 2\$ for \$x,y,z \in \mathbb{N} \$ is if one and only one of \$\{x, y, z\}\$ is equal to \$2\$ and the rest are equal to \$1\$. If \$\mid\> a-b \mid = 1\$ and \$\mid\> b-c \mid = 1\$ then either \$c = a\$ or \$c = a\pm 2\$. If \$c = a \pm 2\$ then \$b\$ must be between \$a\$ and \$c\$ since it is equidistant from them both (this is 1D). 

Your overall method of sorting the list would be good if the program called for finding the largest number in a list of size where and were unspecified beforehand. However, if we know (or can assume) that << then there is a faster method that just requires using more memory. It's often nice to think of how you would perform the task yourself in problems like this. If you had a stack of papers with number grades and needed to find the second highest grade would you sort all of the papers first or could you use your memory to help you solve the problem faster? 

I hope we can agree that B is the simpler approach. In this case the Jokers are simply gaps between characters chosen from the input string. The problem with integrating this logic with your approach is the order in which the recursion is performed. You know when you skip a character (currently when you are adding a ) but you need to know that another character is added after the skip for you to declare the string as non-contiguous. The method is shown below: 

The next step is to realize that if is our \$m \times (n-1)\$ difference matrix, yields a \$1 \times (n-1)\$ matrix of column means. If we truncate columns of this matrix as we do when we take submatrix it does not affect the means of the columns that are still there. So instead of performing over and over on submatrices, we can again pull it out the loop, perform once on the entire matrix , and take submatrices of this mean matrix. So now the code could look like this: 

Similarly, instead of performing a on the rows of the submatrices, we can perform a cumulative sum along the rows (or rather row): $$\begin{align}CSMD[i][j] &= \sum_{k=1}^{j} MD[i][k] \\ &= CSMD[i][j-1] + MD[i][j]\end{align}\\$$ Incorporating Matlab's built-in along with changing some intermediary variable names to better illustrate their purpose yields the following code: 

Updated Code This is much simpler code that uses some of the advice I gave above. In we are iterating from right-most digits to left-most digits because it is simpler and because it does not matter what end we start on when checking for Stepping Numbers. 

Bugs in nonContiguous If your input string contains spaces then your function produces arbitrary output regardless of whether you are correct or not. 

The swap method in the other answer is the approach I would use, however there is a similar answer that more resembles your approach so I thought it would be worth sharing. The method will be to build the array of non-zero elements and fill in the rest after. The trick is that if we do it backwards we can get the correct output in-place. 

This has a major impact on the performance of your original code, but as you will see we can do better. Problematic Optimization Flattening the 2D array to 1D sounds like a good idea until you factor in the cost of post-processing. When the array is processed as 1D the border pixels change values and, in fact, exhibit border-wrap effects. We often fix problems like this by wrapping the matrix inside a false border - i.e. we add a \$1\times1\$ border all around the matrix. Unfortunately this would not work here. Instead, you can fix this by applying the filter and then going back and zeroing out border pixels each iteration. More Optimizations 

Advanced Assuming the range of numbers to check is large, there is a better way to solve this problem than the brute-force approach. We can use the concept of induction and recursion to solve this problem in \$\mathcal{O}(2^d)\$. For simplicity, the following approach does not handle the fact that zero is a Stepping Number. Rather than checking all numbers between \$A\$ and \$B\$ to determine whether they are Stepping Numbers, we will instead generate a superset of Stepping Numbers in this range. Let \$d_A\$ be the number of digits in \$A\$ and \$d_B\$ be the number of digits in \$B\$. This approach generates all possible Stepping Numbers on \$[d_A,d_B]\$ digits. We then filter this initial output to produce all Stepping Numbers between \$A\$ and \$B\$. While you could generate the Stepping Numbers strictly between \$A\$ and \$B\$ without filtering at the end, doing so would either require you to either maintain two separate lists or generate unsorted output and then sort it later. Generating the extra Stepping Numbers outside \$[A, B]\$ is not a big deal since there are not many Stepping Numbers in general. For example, there are only \$3627\$ stepping numbers in \$[1, 2^{31} - 1]\$ which is the positive range of a 32-bit integer. Assume you already have a Stepping Number \$S\$ of length \$l\$ and you want to append a digit to \$S\$ to create a Stepping Number of length \$l+1\$. There are at most \$2\$ ways to do this depending on what the least significant digit (LSD) of \$S\$ is. For instance, assume \$S = 43432\$. The LSD of \$S\$ is \$2\$. In order to append a digit and have the resulting number remain a Stepping Number, the appended digit must be \$1\$ or \$3\$ resulting in either \$S_1 = 434321\$ or \$S_3 = 434323\$ respectively. It is important to realize that if you have all sorted \$n\$-digit Stepping Numbers then you can easily produce all sorted \$(n+1)\$-digit Stepping Numbers by iterating through each \$n\$-digit Stepping Number in order and, for each Stepping Number, appending digit \$\mathrm{LSD}-1\$ before \$\mathrm{LSD}+1\$. 

To accomplish the dynamic range we need to have a strict ordering. Here I will always assume \$b \geq a\$ 

is \$\mathcal{O}(n)\$. Assuming we have a string of \$n\$ distinct characters your algorithm could devolve in to \$\mathcal{O}(n^2)\$. Of course your strings are likely never long enough for big O to matter. In problems like this no matter what language you use it is often useful to build tables of characters. 

The code runs much slower with these bug fixes. Quick Optimization The algorithm cannot be performed in-place so you are using to store the output of applying your filter to . But then you want the output to be placed back in so you perform a deep copy. However a swap of the pointers would suffice so you could use this instead: 

You'll notice that if increases by , these column differences remain the same. The only thing that changes is that we obtain one additional column difference in . Hence you do not need to perform the function multiple times. Simply perform it once on the entire \$m \times n\$ matrix to yield a \$m \times (n-1)\$ matrix of column differences and take submatrices of this difference matrix. So the original code you posted: 

You are recomputing way too much in your code. Your general solution relies on iterating through powers starting at the first perfect square greater than \$\mathrm{n}\$. 

Since I do not know what the actual implementation will be I can only comment on the code as it is presented. From the algorithm it appears that you are applying a filter multiple times in order to monitor some propagation effect - as opposed to applying the filter multiple times to stabilize time profiling. From here on out I will assume that running times is part of the core algorithm. General C++ concepts