I'd add a default case. This makes it easier A better solution might be to store both entries in a database table that maps between them. Then you can just add new rows in the database when you add a new language with highlighting. 

This seems like this is not code that you wrote, so it would be off-topic for review. As a general rule, you should answer questions like those posed here before sending the code out for review. In particular, if you don't like variable names in code that you maintain, then why not change them? MITJavaWordNetInterface Your indentation is inconsistent here. A more typical form: 

Note that this code also handles the case of an empty list, which the original code did not (it would throw a if called with an empty list, as it would try to dereference the null ). 

Now we give a reasonably correct error in either case. This also exits and locks in the header. Your original code would keep trying to show the page. This is called early return. It has the side benefit of putting the error message near to the error condition. Your original version had the normal flow close and the error message as far away as it could be. You could then continue with 

This only checks against when you would be increasing the . When the is , we set to equal (which will be one greater than the index of the last element) and increment count. Your original version had a bug where it incremented the count first, which actually sets the offset just beyond the end of the array. Doing things this way gets rid of the and reduces repeated code. We do the same thing for either case. We just have to prime the if it wasn't explicitly passed. Note that this also requires a helper function: 

You also may want to consider the advantages of using a rather than a . In particular, if you use a , then you don't need to sort before using them. The insertion will automatically maintain sorted order. 

I have two comments of the tweaking kind: 1) any variable that is shared between threads has to be . this is true even for static variables that have one value throughout the JVM (actually it is per class loader but this is irrelevant here). The reason for that is that threads can locally cache the value of variables. volatile variables force the thread to read the global value each time. You might also want to take a look at which is an int that is guaranteed to be incremented synchronously and that has the same value for all running threads. 2) while will work, Java concurrency package has several Lock mechanisms that allow for better control over the synchronization process. of relevancy here are , . 

AS you can see, this solves ALL three problems mentioned above. 2) Use Class names that reflect the scope of one instance an instance of holds the info of one contact. Same as an instance of so it should be named in singular form. 3) misleading method names / redundant logic The logic of modify and remove is fine but the method names are misleading: there is and which give the false impression that they are doing the same. In fact, is actually doing a search for the contact to be removed. same with and . and while we are on the subject, why do you require both old contant's name AND number to find it? especially since you have a choice to search for a contact based on name only. Now, if we agree on that, you can use when modifying and removing contacts. 

though it is arguable, Coding by exception is considered an anti pattern. Exceptions should be reserved for error conditions, not as indicator that a virus was found. EDIT: with regards to the question how to implement pt 2: First, I would create a custum exception that signifies a failed virus check 

Here you fully cuddle your while elsewhere you put the on a separate line. Try to format consistently so as to make your code predictable. Personally, I prefer the fully cuddled version, but either way can work if used consistently. Try to avoid numbered variables. Something like is preferable to as it gives some indication of what causes the two to differ. You use both and in that block. This is confusing, as I think that is an abbreviation for while isn't an abbreviation for anything. It's often better to avoid abbreviations, as they slow down reading. You will find that you spend more time reading code than writing it in most applications, so it's better to spend a little extra time writing now than waste time reading later. You don't leave any whitespace after the end of the block and before the comment before the next statement. Previously I suggested that you not use whitespace because it indicated separation where none existed. Here, there is separation, so go ahead and use whitespace to indicate it. Your comment says, "Let's update!" But what you actually do next is check for errors. I would have put that comment inside the block for that reason. Although in this case, I don't find the comment necessary. The in the SQL is obvious enough so that we don't need an additional notice. Rather than doing an , you would normally redirect at this point to clear out the POST (which helps avoid accidentally repeating the action). You can redirect to a success page. Typically the time when you want to comment is to explain why you are doing something. For example, why does the player's balance need to be greater than the sum of the limit and the rent? Is that a game rule? It's not an obvious one. Why are doing all these statements at all? These seem to be disjunct. You even have the capability of handling multiple errors, but you never generate more than one at a time. 

why do you need two loops with the same loop condition and same break condition and some other identical lines of code ? and why did you put the exit condition as a separate statement? why not (by the way, there is nodefinition for ) The code also lacks documentation. a comment for each statement would explain a lot. the whole logic seems overly complex to me. the requirement can be easily fulfilled using one loop and simpler code 

in my eyes, in the case of deciding between two options, the short form of the if statement can be used to make it clear: 

Note: the posted code does not specify how and which are mentioned in the statement are declared. note that these will have to be final in order to be included in a lambda expression. 

the quality of the code is indeed not very good. The first and foremost reason is that all the algorithm is coded in one, long, winding, spaghetti-smelling piece of code. in addition, the variable names a non descriptive and there is shortage of comments. Start by breaking up this code into logical pieces: , , (you will need to figure out the args) The three methods should be broken down further. furthermore, You need to use methods in order to give meaning to technical pieces of code. For instance this line 

I am not sure how many lines of code can be reduced but one thing is for sure: whenever you encounter a resource that can be closed, you should use Java try-with-resources feature (since java 7). Not only this feature saves you the operation (one line less!) but also ensures that the resource is properly closed by the end of the try block no matter if it ended successfully or not (the compiler adds a clause). in the current code, if an exception is thrown, the resource is not closed properly. I looked at the thrift javadoc and indeed from version 0.10.0, is auto-closeable. So the code on both methods should be 

It's probably in the code somewhere, but I don't feel like tracking it down now. A comment of why we are comparing to would be helpful. 

This checks if the character at position in the string has a closing match (i.e. is a key in the array). If so, then you know that it is an opening brace and add it to the list of things that you need to match. If not, it checks if has an opening match (i.e. if it is a key in the array). If so, then it checks to see if it matches the most recent unmatched open brace. If not, then it returns to indicate that the string does not consist of matching braces. The final case is if the character has no closing match nor opening match defined in the arrays. In that case, it's not a brace. Since the string is supposed to consist entirely of braces, it throws the exception. We don't have to check anything in this case because we already did the checks earlier in the and clauses. If you are only adding one element to the end of an array, the operator is more efficient than an . I changed the order of the checks to avoid repeating them. The other way you did two or three checks on a valid case and two on an invalid case. This way, you do one or two on a valid case and two on an invalid case. Hopefully the valid cases are more common. Note that I haven't tried to run or test this code. 

If you are using Java 8, you don't need to write out the second time. I also changed your variable to simply a . As a general rule in Java, the variable type should be just the interface. You should only specify the implementation as the type if the implementation allows some needed functionality that the interface does not. This makes your code more maintainable, as you can change implementations without having to change the type everywhere. 

You do no validation on the lines that the method produces. What if it did not produce comma delimited values? the method should give you and you write the line in the proper format (perhaps with the custom delimiter?). Instantiation In you create a new instane of the class for every input line and (also a bad name if you ask me) you accept a list of instances. from that I gather that the design was that a instance represents a CSV line. However, the usage contradicts the design. is supposed to produce an . Did you mean it to return an instance of ? in this case, a better approach would be to use a constructor. This is the proper way for a Java bean to populate its state. 

Here are my comments in order of severity: 1) Bugs 1.1) resource handling in you handled IO resources correctly with try-with-resources. You forgot to do it in . 1.2) parsing You split the line according to single comma. There are two problems with that: First, you do not accept cell values containing comma. Imagine the following line 

Second, although the acronym stands for "comma separated values", parsers (and writers) usually accept any single character as argument for delimiter. this gives clients flexibility that sometimes is necessary. Imagine if an api produces files in the following format 

However, you forget to protect the code from NPE (): at the beginning inside the try block, both handlers contain . You first open the output handler, and then . However, in the clause, the order is reversed. So, if an exception is thrown while opening , is never initialized and you might encounter NPE in the clause. it is absolutely essential to ask separately about each file handler before closing it: 

since I know Java :) I have the following comments to add to the previous answer: resources handling Resources, in this context, are the input files you are reading. Their lifecycle is not handled properly. In other words, you do not close the files, leaving OS resources open after the file was read and parsed into memory. This is not a big deal in your program since you only open two files, but it is still a glaring omission. Since proper handling of lifecycle of resources can be tricky, starting with version 7, the Java compiler gives you the feature of try-with-resources, offering automatic closure (and better exception handling)