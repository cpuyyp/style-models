Is it worth having? If your goal was to implement your own object pool, than it's fine. If you have it for some other reasons (like performance or convenience), it's probably not. Firstly, it's definitely less convenient that a standard C++ container. Secondly, it may not be faster than a standard allocator. It might be even slower. Did you measure it? Did you have any performance issues in the first place. Anyway, implementing a custom allocator is the last thing I would do to tune the performance. Even if profiling shows that a standard allocator is too slow, I'd recommend to use an open source library with a custom allocator instead of implementing your own. 

Actually, there is a much easier way to deal with this issue: do not use pointers and dynamic memory allocation. I do not see any point in being allocated dynamically. Using an is much better(). The same holds true for the member-variable. One more thing: you should try to keep the scope of variables as narrow as possible. There is no need to declare the at the beginning of the function. You can do it just inside the for loop where it is used. The last thing: is a bad practice. It pollutes the global namespace. 

That's it. No need to update vertices or having several sets(visited, inQueue and so on). Whitespaces: there should be whitespaces around binary operators, before and after curly brackets, after the , and keywords, between method parameters. For instance, 

I don't see the point in using here. There's no resource clean up or any other strong reason to resort to it. It just makes the control flow more complicated. How to fix it? In the function, you can just return the value immediately in case of an error. In the function, you can run the loop with a condition . It'll make the code easier to folloow and eliminate a corner case . The error message seems too generic to me. It would be more helpful if it were more detailed (too many and missing arguments are clearly different cases). An LCM of two 's may not fit into . I'd recommend to document that your program has undefined behavior if the LCM is too large or use a wider integer type. 

There're a few more problems with code: for instance, it crashes for (which is a valid input). You implementation is really hard to follow: it's not clear what the arguments , and stand for. They're way too generic. : What kind of index? Sure, it's a position in the original string or list. But what does it represent? It's not an arbitrary position, is it? It's the index of the element that should be changed, isn't it? Why not call it , or something like that? The same goes for : what kind of limit is it? There's too much stuff going on in the function (like choosing the next position, generating a new combination and so on). I suggest splitting into a few smaller function with meaningful names. I didn't fully understand your code, but if you need to keep a to avoid duplicated, you're doing it wrong. I don't see why you need to recursion here either. Let's go back to the algorithm: 

When we check if a number is a prime, we need to test all possible divisors up its root inclusively. If you print the list, you'll see that 9 is there, which is obviously a bug. should be . However, this bug does not affect the correctness of your factorization algorithm. It does not scale well. In the function, all primess up to are checked in the worst case. That's why it works slowly even for moderately large prime numbers(for instance, ). 

I prefer the first option as the type accurately reflects what may happen: there's either a value or nothing. 

There is a bug in your destructor. is not correct. It was allocated using an array form of the operator, so it must be deleted using an array form of (that is, ). The current version of your code invokes undefined behavior. But simply changing it to is not enough to fix it. There is still a memory leak here. A correct version of the destructor should look this way: 

Pretty simple, isn't it? Now we need to learn to generate the next combination. This part is already described in your post. So let's just create another function that does it. 

The code is broken. If a number is greater than 20 and ends with 0, will not do what it should. Don't mix the logic with the output. I'd change the return type of your functions to . It'll make the code more testable and reusable. Don't just print something to in a case of an error. Throw an exception instead. Declare each variable as late as possible: 

The weight of the neighbors should be , not (because we need one more step to reach the neighbor from the current node). And I would call it , not . The method is redundant. Nodes are never updated in a breadth-first search. You can get rid of it. A map that maps a node to itself doesn't make much sense. I would use a here. And I do not see the point of having a . The entire algorithm is implemented in a pretty strange way. Here is pseudo code of a standard BFS implementation: 

Pick an arbitrary vertex . Find the furthest vertex from (let's call it ). Find the furthest vertex from (let's call it ). The distance between and is the answer. 

First of all, you're using a wrong algorithm. A depth-first finds some path, but not necessarily the shortest one. What you actually need is a breadth-first search. You can just use a queue instead of a stack to fix it. Storing everything as a string is bad idea. You code'll be much better if you use appropriate data types. The position on the board or a shift vector for one move is not string. I'd suggest to create a separate class that holds a pair of integers to represent a position on the board and has a and an method (to get the next position after one move and to check if a position is valid). I'd also recommend to separate the code that reads the data and prints the result from the part that actually runs the computations. Fixing the indentation and spacing of code according to the Java coding convention would make it more readable. The names of the variables are also not very descriptive. For instance, what does mean? What is (which is, in fact, not really a string)? I have no clue. It should be something like and because that's what it actually is.