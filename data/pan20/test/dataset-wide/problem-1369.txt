I have implemented generic doubly-linked list class, which supports , interfaces. is fully compatible with standart BCL classes. Targets: 

I understand your idea. You have to use both patterns: singleton pattern, and load/save pattern. You can use class implementation, with load/save functionality, inherited from the class. Example of using singleton class in Windows Forms Application: 

How can we compare the performance for that class compared to the BCL classes and other implementation? Will you provide the C# code to compare to the BCL classes like , , ? Unit tests (code coverage - 100%): 

You can use SSE2/SSE3 minps / pminsd or relevant instruction set for your processor/architectoure since it is supported directly in GCC / MASM / TASM (In case MASM or TASM is not supported such SSE2/SSE3 instruction set there are also the .inc files to create macros simulating instruction sets on the web for MASM), create .OBJ file by your favorite linker then link it as usual and use in you favorite IDE. You will get from 4x to 16x performance boost compared to the traditional "classic" algorithm. It depend on data size (old compilers treats double not in IEEE format, bout like float in several configurations, on 16x systems, particularly, double means 32 bit data structure, not 64 bit data structure, in modern languages it is correlated to "double" and "long double" data structures, respectively) The idea is simple: if you have k elements, [k=4n+p, 4>p=>0], complete it with n-p elements or just load last 4 doubles resetting to 0 last p elements, so you can fast evaluate n candidates. evaluate candidates n times comparing to the accumulator, you will get a minimum. If your processor supports SSE5 or is a brand new, most likely you also will be using one of the HD instructions, which really handy, because it can find maximum (not minimum yet) in array of double values. Sample of using SSE to calculate peak values of a float array: 

I think it is good idea to use existing classes, I've already made some of the refacorings along with some design choices. For additional info, please read this book: 

EDIT: I think that explicit command calls (open log, write something and close it) before dispose the log object are much more readable, easy to understand and maintain later, than impementing the dispose pattern in another object (so you will get at least two objects to control lifecycle: custom class, and class - that will break the Einstein rule, - it's just not good to control 2 objects, when you could simply control one). In particular, that is going to be true when the new contracts will be applied later to the code. Disposable pattern is to heavy for such simple task. Additionally, as an advantage of using one object to control, and - consequently, - very simplified logic, it's easier to control log writer object's lifetime. At second, simple class with a good and clead design can be extended easily to supprt for an additional logic and do will not likely contains any of the caveats in the future. 

Build data structures to generate more tests instead of writing more test code. It strikes me that the amount of test code explodes with the need to test more involved graph complexity. Test code must be as thoughtfully architected as the target code to avoid all the bad things about poor OO design. Looks like your tests are basically the same except for hard coded method parameters. Make the method parameters variables then you can have a single test method. 

I'm going to borrow @CodingYoshi's idea of an class. However transform the OP's parameters so as to make a consistant class so every can be instantiated, and subsequently called, the same. We have all needed parameters already at the point the is called, so let's use them. This helps future-proofing too. 

Warning! Arm Chair Quarterbacking in progress. Given that I offer this. Game Class Why is this in the ? You need a "driver" for a chess game and that would be a class. "A game consists of (has) moves" makes more sense. The gives us a conceptual framework for a richer chess game. A has players, may have a timer for speed chess, and can keep track of pieces removed from the board; and of course records the moves. Board Class The chess board is a data structure. Don't make more of it than it is; nor less. In the Visitor Pattern the data structure has-a element that has an method. That element seems to be a . I'm not certain if it's better than the being visited, but certainly the point is that we're evaluating the state at that one square? I don't see a big deal in giving a board reference to each square. OR .. maybe the s are visited. To test if the piece is "inCheck" for example. This perspective makes more sense than a square is in check. Is this why your board is and not ? Whether we are visiting the board and iterating the squares; or iterating the board and visiting the squares; or iterating the squares and visiting the pieces may be more than semantics. I vote for whatever best reflects intent, gives me good code expressions, and sensible building blocks. In any case I agree with @bowmore about refactoring to . Pieces Even given a rich class, I like the idea of using an enumeration for names. This makes for nicer coding and expressability overall (and my pet peeve - it avoids strings). Maybe two enumerations. As in and ; or , And a value to represent an empty square might be nice or . Maybe has a reference so it knows where it is. This may have a nice effect on the code. Visitor Pattern Nice call. I agree with @MarcoForgerg, the visitors do not need to keep state. Just pass in the needed parameters and forget-about-it when done. And, instead of Singletons perhaps just static. Nested visitors? Ok, so the board gets "visited" which in turn "visits" each square, which in turn, finally gets to . Visitors, by definition, understand their visited data structure so I'm thinking board iteration is wrapped in the board visitor, and the square visitor knows to check for an occupying piece and knows what Evaluator(s) to pass to the piece. It feels like nicely layered (code) logic to me. And note how the iteration logic is in the visitors, not the board (data structure). And subsequently all the business logic is in the visitor as well. SO instead of this 

Now, according to your requirements you don't want multiple values used, but it's not clear to me if you are only talking about not using the same array element more than once (ie a[i] can appear just once for each i in each solution) or you are talking about using the same number more than once (ie the number x can appear only once in each solution), or you are talking about using the same set of added numbers more than once (the solution x,y,z can appear just once). If you want to handle the other cases, such as to prevent solutions with duplicate values then just check the existing solutions before adding another. Using a HashSet is ideal for this: 

You appear to be new to Java. For one thing, you are using integers to store ones and zeros to be used as flags. Java has a boolean type to handle that. If you need to store more than true or false, then you can use an Enum to signify the separate "states" you wish to convey. You might consider using separate threads for reading and writing to and from the server. However, your current design does not really need this, since it's a simple back and forth of messages in pre-ordained sequence. More complicated scenarios could be handled by having separate threads, one reading from the user, another sending messages to server, a third reading messages from server. Your while (sTalk == 0) loop should not be a loop. In fact, it is a common pattern in your code for you to put in loops that never actually loop. Most of your "while" loops do not need to be there, none of them will ever repeat the loop. They are really just "if" statements. You use a the scanner class in this case, a more robust solution would use a messaging library like protobuf, or JSON, or http, or use some sort of protocol to organize data being sent into messages. Those three I listed are popular, but the basic idea is that you define what a "message" looks like and you always send data as a "message". That way you would not be making assumptions about what is being sent over the socket (ie you magically know when to expect a string or an int or whatever). A message would have a format, perhaps a header, a length, and you would read each message all together as a unit. You would also not need the magic" character 'a' to have a special meaning. Having a protocol defined allows you to avoid making such assumptions. JSON is a message type that does not even require a header, you might look into that one, it is a very simple protocol and very popular these days. You should probably not catch "Exception", catch "IOException" or whatever is specifically thrown, and you should have try/catch around the different places you do I/O to be able to differentiate the different issues that occur. Overall, I would say that your code is long-winded and not broken up enough into individual pieces. It also makes too many assumptions about the ordering regarding who says what and when. A simple client design would simply be like this: 

If you're wanting to encapsulate for the sake of testing per-se take a look at the NUnit CustomConstraint 

Poor domain space modeling - Data Structures The "items" are tax categories. We really don't care what it is but rather what its tax rate is. I think of not just the classic things like trees, linked list, etc. but I tend to think of any class I create to make data (class properties) easier to manipulate. Data Structures significantly reduces code complexity. 

Talk yourself through your "problem domain" and write it as you go. Say a little, write a little. The details will come along. Don't worry about them all at once. Make sure the little you write each time compiles. For example Well, there's a Person 

Resizing? I thought this is what we're trying to avoid. Where is the "resizing"? I assume it will be in and . If there is no resizing - the size is fixed at instantiation, then the class name is wrong. The conventional wisdom says resizing is less performant than resizing a . In fact the team went to great lengths to make sure automatic resizing performs well. Do you have the time and other resources to make your home-spun resizing worth not using what the .NET framework already gives you? Wrong Perspective I see the client having to write his code in terms of s and array elements when it should be in terms of your business objects - , for example. The structure - the array - should not be the emphasis in your design. If you keep going down this road you are in for ugly maintenance problems over time. Give the business classes "collection friendly" capabilities I imagine sorting, searching, preventing duplicates, uniqueness, etc. might be important qualities when we make a collection of things. So should implement and . , or any other user's code, should not be doing this: 

You have managerId and employeeId as local variables. Are these not already part of the employee class? You will find in the long run that it is a mistake to gut object properties and "lay them out on the table." You are corrupting model integrity. You now have to keep redundant properties in sync and for each layer (M.V.C.), that's 6x the work per property. The whole thing is very un-Object Oriented. Make your methods do their jobs should know how to handle a null employee. Its a cruel world and methods must not rely on the kindness of strangers to pass valid arguments. As is the method is not at all reusable. Every client will have to know 1) don't pass in a null 2)I'm supposed to get a zero in this case. You'll re-write the exceptional handling over and over and .... That's like the customer - every customer every time - having to tell the restaurant staff where they keep the french fries. So, not this: