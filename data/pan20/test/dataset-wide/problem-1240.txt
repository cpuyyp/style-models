It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

Alternate Implementation Another alternative, which is arguably simpler, is to implement this as a case class with function arguments. This implementation is exactly equivalent to the refactored version above, and is arguably simpler and easier to use. 

If the block throws an exception, give priority to this exception. The exception thrown by is added as a suppressed exception, and the modified exception is thrown. If the block did not throw an exception, allow the exception from close to propagate upward. 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

I found about 5 things that can be improved, or maybe it's more accurate to say that I did 5 passes over the code in my efforts to improve it. Here's the changes I would recommend, in the order that I encountered them. Better Names The first change was mostly cosmetic, but it was very helpful laying the groundwork for more changes later. 

The biggest thing you can do to improve the code is to find ways to make the relationship between the game flow, the data, and the code more concise. Right now the whole game is a series of if statements, and you're using variable names as the equivalent of old-fashioned GOTOs to jump around the code. For something this short that's bearable, but it won't scale to any larger size. Moreover, your structure is going to force the user to make one-time-only decisions at each point - you don't have a way for users to, say, go to the window and THEN look at the wristband. Or to go back, for that matter. That might be your design intention but if you change your mind the current structure will be a lot of work to fix. Last but not least, you don't have any error handling - if the user enters a wrong choice, the program will just move on to the next prompt without assistance. On a very general level you need to establish a structure that reflects the nature of the game. Most text adventures are really a series of linked containers; the container (a 'room' in the old school dungeon game, a 'scene' in a conversation based game, etc) contains a descriptive text and a set of options for the user which link to other containers, and so on. The contents differ but the structures are basically identical; it's a good idea to write the code in a way that reflects the way the game actually works. If you're familiar with object oriented programming, this is a perfect problem to tackle with classes. If not, you can still make your life easier by creating a function that handles the repetitive part and putting the data into clearly labeled variables. Here's a very rudimentary example that uses dictionaries to represent each room and a dictionary of rooms to represent the map. The 'code' is just to keep calling the same function on whatever rooms the user gets from their choice of actions. 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

Normally, I'd suggest trying to get rid of as much mutable state as possible. That's not really possible here, the circular reference to the parent pretty much guarantees that something is going to need to be mutable. Vanilla Version Without deviating much from your original design, there are a few cleanup suggestions that I can make. First, as suggested by @Carcigenicate , could use some naming fixes. In the version below I used , but it could have been any number of choices. I also inlined the creation of . 

Now that we are using a more appropriate data structure, we have regained the simplicity we had before, and don't run out of stack space. 

If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

This would let you compose and reuse a collection of funcs into a DefaultFuncs and then reuse it -- default funcs is really just an elaborate Tuple tricked out so you can call into the functions from the owning NeuralNet instance All of these are functionally identical approaches (it sounds like you've already got the thing working and just want to clean it up). The main reasons for choosing among them amount to where you want to put the work #1 is good if the functions correlate and you want to easily tell when a given net instance is using a set; #2 is just syntax sugar on what you've already got; #3 is really just #2 except that you compose a function set as class (perhaps with error checking or more sophisticated reasoning) instead of a a dictionary 

This has a couple of advantages 1) not hitting the disk for every query will be much faster 2) the dictionary lookup faction is much faster than straight for loop comparison, since the dictionary uses hashed values instead of more expensive string compares. As an aside, you should look into readlines, which the usual pythonic way of reading text files with info on lines. For the longer term this is a great application for Python's built in database functionality (with the sqllite module). You could convert your existing text files into a sqllite database and then your lookups can be much more flexible and precise ('find spectrum and power for stars with id > X and < Y' sort of thing). You probably also want to set this file up so you could call it from the command line, which would involve using the argparse module to grab command line arguments and out them into known_stars, master_list and output_file 

Along those same lines, became because that's really what it does. I also moved the helper functions into 's companion object. It's a good default organization strategy. itself had mostly structural changes. I changed the visibility of , so that mutating it has to pass through the helpers. It also became a Set, as the OS doesn't generally make guarantees about listing order, so I wanted to avoid implying that the order was something that could be relied on not to change. became just and passes a defensive copy of the internal set. That gives us this final version, with a small driver to make testing easier. 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1 

Python has a neat built in called 'zip' which creates a pairwise list from multiple iterables. So you could do: 

I'd second @michaelUrman's point about the room constructor- the long list of params makes it hard to follow what's going on. Since you don't do much with the constructor - you're not processing or otherwise mutating the incoming data - you could just create empty lists/dictionaries as needed and then have separate methods such as 'add_wall' and 'add_person' which would make the code read more legibly. I'd be more aggressive about pushing the logic down into the different pieces. For example, you have a lot of logic in Room.display_Room() which depends on knowledge of what the state of different items in the room is. If the room simply called a standard "display" method that gave back the description of things in the room based on their own code the whole setup would be much cleaner. This is the much-discussed 'single-responsibility principle' You could combine that with generalizing the various types of room contents into a common base class so you don't need to manage so many types of pieces in different variables. This would make it easy to inventory and search through room contents and also make future expansion easier. Here's a very simplified example. 

This would work well if there is a high correlation between the optional functions: if they tend to cluster together they'd make a natural class hierarchy (and you'd have an easy way to see which nodes were using which function sets just by looking at their concrete classes). OTOH this won't work well if the functions are not correlated. Kwargs to the rescue You can simplify the constructor logic by using kwargs and by including the defaults in the init method (for sanity's sake I'd move the pure data into required parameters, but that's just aesthetics); 

Now you can keep variables and methods private within your and only expose what you need to access from the outside. This is just a small sample to get you started. Are and already defined in the global namespace? If not, you probably want to pass them as arguments to the methods. It's hard to say from your two examples. Some other comments: 

Since all my work is done in the method (similar to in a regular generic handler .ashx), I thought that I add a method there which can be overridden. However, it never seems to get called. What did I miss? Do you have any other suggestions on improvments? 

No, you will only benefit from using the prototype when you create a lot of instances of a constructor function. I won't go in to the details of that, since it has already been discussed a lot in various SO posts. Without more context, I suggest that you create a revealing module: 

I would like to execute a certain method at a given interval. The reason why I can't use a timer + its event handler right away is because I want to add an offset to each tick (100ms in my example below). It seems to be working just as intented. The reason why I'm starting it manually is because if the takes more than the given tick time, I want to let it finish before starting a new "tick". Perhaps this could be done in a much simpler way. I would like your thoughts on the code: 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Much simpler. Premature Optimizations If you ever have enough members in a room for the optimization to gain you anything, you'll probably be exceeding the length of the Mongodb query. This needlessly complicates your code. Ironically, any gains are lost when you forgot to use rather than , which needs to iterate through the lists you just made to avoid iterating through the lists. It looks like the accessors for the attributes already return values, so this can be much more readably rendered like this: 

You've got a nice idea, planning for extensibility. There is one issue that I see with the way you've implemented it. 

There's really not much we can help you, given the low level of detail in the question. There are somethings you have in this code snippet that are generally considered a Very Bad Idea, so I'll give what help I can in that regard. Null Checks There are a bunch of these types of checks in the posted code: 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

which will except if dist is not a number; most python coders just try/catch around it. Without try's you'd have to provide a way of checking for floats that doesn't require a try/catch; maybe it's the point of the assignment? Apart from input validation, it's just doing a division otherwise. To get a float from a string without a try, you could do: 

You're doing three things here: splitting up the listing into sentences, parsing the listing, and recording the results. You can clean this up by separating these out into separate functions functions or classes. This keeps the code less nested and easier to follow. To keep things simpler I'm using regexes for the room names as well as for the dimensions. This will actually be a bit slower - "in" is really fast - but it is more flexible (for example, if you have to support plural endings or something else besides string lookups). I'm compiling the regexes using re.compile to make them faster and re.I to make them case-insenstive. Lastly, I'm returning the results as a list-of-dictionaries, where each dictionary includes the room, dimensions and the sentence from which they came. This lets you keep the printout display separate from the parsing. In practice I would probably use instead of a dictionary but I didn't want to get too far off topic 

If you've learned object-oriented programming, you might see how the residential and business functions could share code by becoming classes (or more likely a class and a subclass) If you haven't looked at OO, think about refactoring the way 'business' and 'residential' work to avoid having methods which differ only in hard-coded constants.