Be aware, however, that this may be a very costly operation that may involve physically moving most or all of the rows in the table. There is a chapter in the Database Administrator's Guide on reclaiming wasted space that discusses this and related issues in much more depth. It also walks through using the Enterprise Manager GUI and the various advisors to reclaim space either manually or automatically. 

Yes, if this was to work, it would generate an infinite loop. But more than likely, it will throw a mutating table exception first. What is the problem that you are trying to solve? A trigger that updates other rows in a table when one row changes is unlikely to be a reasonable solution. If you have cross-row dependencies, that almost always indicates that you have a normalization issue that should be fixed in the data model rather than being coded around. 

If, on the other hand, you are trying to say that if = 1 then must be unique but you can have duplicate values if the is something else, then you'd want a function-based unique index. 

This leverages the fact that Oracle doesn't store completely NULL rows in the index so only the values that are part of transactions will be stored in the index. 

If you are asking how to call the procedure, the answer is that you have to declare the variable in the caller. 

If I saw a data model where a table had 2.1 million rows, one of the columns had only 5 distinct values, and I knew that people wanted to get a listing of those distinct values on a somewhat regular basis, I would strongly suspect that the data model was missing a lookup/ dimension table. Rather than trying to tune your current query, I would bet that the better answer would be to create a separate table that has just those 5 distinct values, create a foreign key relationship between your current table and the new lookup table, and then modify your query to hit the new lookup table instead. 

In general, extents are allocated in a round-robin fashion among all data files in a tablespace so long as those data files have enough free space to allocate the extent. So if you add a new data file, you would generally expect that half of the new extents would be allocated in the existing data file and half of the new extents would be allocated in the new data file. Assuming the two data files are the same size, you would generally expect that by the time the first data file got to 100% full, the second data file would be roughly 50% full. I'm not sure, though, how this helps you deal with increasing tablespace size without wasting physical space. I'm hard-pressed to imagine in what circumstances knowing how extents are going to be allocated is going to help you use less physical space. It shouldn't matter from that perspective whether you double the size of the existing data file, add a new data file, or add multiple data files and it shouldn't matter whether one data file is filled up before the next one starts being used. In any case, you've allocated the same amount of space at the operating system level, you've allocated the same number of extents in the tablespace, and your segments are all the same size. You would decrease the amount of space allocated at the operating system level by letting the data files autoextend rather than allocating fixed size data files but then you have to monitor the free space at the operating system level to ensure that the data files all have enough space to grow and you may complicate your ability to move data files to different mountpoints. You may also decrease the amount of parallelism you can get in your backups forcing the backup job to run a bit longer. 

Our guess was off by ~20% and that was when we were perfect on our estimate of the size of a row. That's because Oracle allocates space to tables in chunks called extents that we've ignored. There are different algorithms for this that depend on the setup of the tablespace. Assuming recent Oracle versions where all tables are in locally managed tablespaces, you would be choosing between uniform extent allocation and automatic extent allocation. In my example, the tablespace I'm using is using automatic extent allocation. The exact algorithm for that, in turn, may depend on the version of Oracle you're using. In my case, though, the first 16 extents are 64 kb, the next 63 extents are 1 MB, and the last extent is 8 MB 

Is it possible? Sure. Is there likely to be an improvement in performance? No. If there is a change in performance (barring cases where you discover that a join is missing or otherwise fix a query), it'm more likely that the old implicit join syntax will be more efficient. But that's pretty unlikely. Behind the scenes, when you have a query using the SQL 99 \'left outer join` syntax, Oracle actually transforms that to use the old style syntax before optimizing it. When Oracle first introduced the SQL 99 syntax, there were occasionally bugs in this transformation process. By the time you get to 10.2.0.4, the odds that you'd encounter one of those bugs is pretty low. But if you look at enough queries, you might find one that is more efficient using the old syntax. 

Since the data is stored in a column, you cannot automatically convert it. You'll have to write some code that tells Oracle what time zone to treat the data as being stored in the time zone and tell it that you want it converted to the session's time zone. You would get the automatic behavior you are looking for if you used the data type instead. If you used the data type, you would avoid having to tell the database what time zone the timestamp comes from when you write the conversion. Assuming that your session sets its time zone properly 

The problem is that the variable that you declare in your declaration section is not the same as the variable that is declared in the context of your loop. You've declared two different variables named with different scope. If you run your block without a declaration section, you'll notice that it works even though you aren't declaring a variable in the declaration section. When you write a loop, your counter is implicitly declared and is in scope only within the loop. After the , you can no longer reference the variable. 

Depending on why you are doing this, however, keep in mind that you may miss data if you're running every 2 hours. If I insert a row at, say 3:59:59 pm, your job starts runs at 4:00:00 pm (looking for data between 2 and 4) and at 6 pm (looking for data between 4 and 6), and I commit at 4:00:01 pm, then neither execution of the job will return this row.