Based off of the logic however it wont try this if you dont tell it to print a banner. Its trivial to avoid this problem by invoking like this: 

The same behaviour occurs if you are using IPC shared memory too. 'file' really is whats file backed, 'anon' is whats not got a file backing it -- like your mappings. 

Unlikely to really pose any significant impact unless your talking tens of thousands of vhosts. The biggest things you'll be worrying about is efficiency of the code to render quickly, the number of concurrent connections your handling and the efficiency of any database at the back. Having handled servers with over 5000 vhosts, the issue was literally managing the vhosts content itself, rather than the pure number of vhosts being ran. 

Because of the uninterruptible sleep state, this does muddy the load value as a pure scheduling score of work - but gives you some indication of how much demand there is on the disk (its still work that needs to be done technically). Load also offer clues to anomalies on a system. If you see the load at 50+ it suggests something is amiss. Load additionally can cause people to be concerned without reason. 

You can clearly see that there is no kernel distinction between threads and processes. I've no idea what you're doing but whatever it is doesn't conform to the way Linux works, at least for me. 

No flushing there either.. It might be plausible that on the new system it really does write dirty pages to disk after getting the POSIX_FADV_DONTNEED whereas on the old system it does not. This needs to be eliminated from the test and test made fairer to avoid any possible issues relating to how the two systems might treat the disk. Note that using this way is stupid, and asking for the pid every time instead of saving it is also stupid, but I digress.. Now, in all honestly I expect similar results to what you were seeing before; but this is a test which actually will flush to disk, unlike what your application is doing.. 

If the problem is with the o/s configuration swapping out the drive does nothing. You cannot alter the state of a running O/S that simply without doing something like at least restarting services. With regards to replacing a faulting drive with a new one on USB for example that is possible to do. IF you create the USB disk as a volume group in LVM2 then you can use the pvmove command to achieve this effect. The process would be: 

This will give you a quite detailed outlook of the running of the system at ten minute intervals. I would suggest this be your first port of call since it produces the most valuable/reliable data to work with. There is a problem with this, primarily if the box goes into a runaway cpu loop and produces huge load -- your not guaranteed that your actual process will execute in a timely manner during load (if at all) so you could actually miss the output! The second way to look for this is to enable process accounting. Possibly more of a long term option. 

I do find it really nice tool for application level containment however. We use namespaces and cgroups directly to contain network and IPC resources for certain user-ran web applications. We provide our own interface to control it. In RHEL7 I'm considering moving this functionality to as the newer revisions of support the concept of user ACLs. For virtualization in terms of a fully initialized system I'm waiting to wee what is offered in RHEL7, but in all honesty, I feel we might only see a good enough solution once we're on a later minor release of RHEL7 and then perhaps only on a technology preview state. Keep your eye out on something tells me in the next 18 months or so it might take its place is the best tool to do fully linux contained virtualization, be it that the systemd authors make it clear its not secure right now! I wouldnt be surprised if drops eventually and just offers a wrapper around with systemd slices defined. Also, be wary theres been a lot of talk over the last 6 months in regards to re-implementing cgroups as a kernel programmer interface rather than a filesystem interface (perhaps using netlink or something, haven't checked) so systemd should be very hot on the tail of getting that right very quickly. 

I would suggest trying the HOME_DIR option first (which is the actual way in policy you should implement it) or alternatively use a local override. 

This functionality in redhat based systems is provided by arping. They use the command (line 261 in /etc/sysconfig/network-scripts/ifup-eth) 

Copy the file somewhere new, then have nginx produce a redirect to that contents new location. This is only a temporary measure but sending 302s from the webserver versus parsing and executing PHP every time will be much much cheaper. Genuine users browsers should just honour the redirect. 

Because we consider who is performing the request before allowing it, we can perform more intelligent decisions of who gets to do what. 

If you do not want the content of your emails to be read, encrypt the contents body, not the means you use to transport it (SSL). Even if you do as @SYN says you lose control of the transport of the email as soon as it leaves your relay and hits someone elses. They may secretly relay it elsewhere and store it, for example. Email in its default form has never been secure and offers no expectation of privacy. Dont send anything through it you wouldn't be willing to shout down the street to someone. 

Newer versions of python introduced a default behaviour of adding the property on all file descriptors to avoid this behaviour. You can do the same yourself on the listening socket too using the module, but that may break other aspects of your application so you would need to test for this. 

Meh, just provision or as the big partition instead. I do not mean to sound harsh, but in my travels I have discovered that other people tend to get the hump when they see sysadmins doing things like this. I dont mean 'major problem alert' but it tends to be the thing you'll be remembered for that nobody told you about, which might end up discrediting you in the eyes of your peers. 

Assuming this is RHEL or some derivative, if you have SELinux on it probably wouldn't appreciate you running haproxy on a port the policy is not familiar with. Try restarting the process, let it fail. Then run . If its coming back with results (text), then try doing these two commands. 

The reports standard SELinux permission issues, such as when the policy does not allow it, reports userspace AVC errors, such as dbus or systemd and reports errors with 'superpolicy', such as where the type is normally allowed, but the role is not allowed for the type -- or the role is allowed but the user is not allowed in that role. Roles and users are generally glossed over in SELinux as they are often not utilized, but there is a faint possibility that an issue could crop up because of them. So, if you feel the problem is SELinux related - this will help identify the problem. For the total avoidance of doubt (and where the system is insubstantial enough to warrant it) you can run to disable SELinux and retry to know for certain if the problem is SELinux related. You can when you have finished. But note, 'superpolicy' problems will still fail in this case as it is caused by runtime errors of the policy attempting to set labels that do not exist. 

So - do nothing and let the operating system sort it out. After a while of your instances running (and if they really are CPU heavy) you can run the command and you'll see that each resource is being divvied up correctly on the CPU. If you want to determine if each process is getting its fair share, and how much you really are utilizing in each program you do the following replacing the process name and get the following results: 

I thought I'd put an answer with my observations because there are a lot of comments. Based off of your output at $URL$ We can determine the following: 

Which will remove all the subdirectories inside of those paths. This works because matches the entire path evaluating it as one string but still honours globbing patterns. The will perform the necessary removal mechanism for the file that matches (rmdir or unlink). It should not need special treatment (spaces, etc) because you are not passing the request to the shell (which would normally expand characters like spaces or stars).