but I think that's a bit short-sighted. Ignoring for the moment the inputs we know we're going to call this thing on, we've observed already that there's times when there's no good answer to return, and there's times when there is a good answer to return, so seems like a good start, but there's also times when there are two good answers -- or more! So let's use a type that reflects this scenario instead: 

Whoa, whoops! Can you figure out which refactoring above was the culprit? =) Now we have to decide whether we like the old behavior better or the new one. I think in this particular case we should like the old behavior better, since the goal is to show a number, and we'd like to show up as rather than as . It's a bit ugly, but we can special-case it. Since we like our future selves, we'll leave ourselves a note about this, too. 

Actually, most of the changes we made to can be done here, as well. In the interest of totality, we'll change the type, too; it will return a (which we happen to know will be a singleton list, if anything) instead of a . 

Chasing the tail. And the ever present problem that you face when doing deep searches is you have no protection against cyclic references. It`s a little tricky as i was sure a simple cyclic reference would overflow the call stack, but that did not happen. With a little experimentation I did find a way to make it crash. 

Some extra points. I was a little slow and Sam beat me to the answer, and he has covered many of the points I had. However I can not agree with , it is much better to use to convert a if you know it is already an int. Your naming is very bad. Prime example is much better as The whole thing encapsulated would improve portability, see rewrite. Use object literal declarations to define objects. You had something like... 

Sorted version Just for the exercise I have included the more efficient code that assumes the array of numbers is sorted or that numbers are in groups. 

Summing up. You need to ensure that you test as many possible inputs to a function as possible. Don't cherry pick inputs (as you did with the function) that you know will work. The aim of testing a function is to find out if you can break it. 

Personally, I often prefer to , and the is complicated enough that I feel like it should be named, so I'd write it as follows. But this is an aesthetic choice that you may or may not agree with. 

It's common in cases like this where the trailing arguments to the function you're defining are also trailing arguments to a function in the definition to omit the arguments entirely. The technical term for this is , I think. Whether you choose to do this yourself is primarily a stylistic choice. 

Now, we have this branch primarily because still isn't total (it can't handle an empty input list). Instead of protecting ourselves from calling in this case, we should just let deal with empty lists correctly. So: 

My only complaint now is the name, for two reasons. The first is that isn't capitalized, which is inconsistent with the naming of the remainder of the file. The other one is more of a philosophical one: our input is an integer, not a base-ten integer. If anything, the base-ten-ness is being imposed on the output. So: 

We could create an even more complex RegExp that would vet things like "1+1+2" but baby steps first. Now that we have removed most of the invalide expressions on to parsing the string. Remove irrelevant content First remove any irrelevant content. That would be any spaces as they are not needed. Again a RegExp comes in handy. this means find " " space and the means global (all) 

Random values. There is no real way to test random values. You can only say how random it is and what type of distribution it gives. Eg the string "aaaaaaa" could be generated by a perfect random generator, that is the nature of random. (as the infinite monkeys randomly typing can produce all the written works of man, and if possible a perfect random number generator) Also take it as a given that scaling a random value does not affect its randomness. Just as you don't have to test code that adds numbers ( needless testing) the same applies to a scaled random value (within floating point limits that is). For most applications is still as random as Testing random First of 

In fact, there's even a function that squashes those two things together. Veteran Haskellers will prefer to spell this function in its infix, polymorphic form as 

(I've added a little creative whitespace to show parallels between the branches.) The only thing I'd change now is to pick a better name. For example, might be an okay name for this. I'll mention one more thing, which is that this can also be implemented quite beautifully as a list comprehension: 

The report here says that it passed the test, but that QuickCheck didn't run as many tests as it wanted to because most of the random inputs it generated weren't in the desired range. (In fact, perhaps it's questionable to use QuickCheck at all for this, since there's only ten inputs of interest anyway!) By the way, this function (a partial version! boooo) exists also in : 

As with waaaay back at the beginning, I find the choice of base case a bit odd. Let's try the trick from before of letting the "loop" run one more iteration (and this time hopefully the refactoring isn't wrong!). 

However there are only 23 valid answers so the best way is via lookup rather than the dangerous and slow recursive solution. 

When an object (an array is an object) needs to be converted to a Javascript calls its method. For the array the method does the same as the function. Each item in the array is also converted to a string, if needed, and using its . So an array of arrays will be converted to a string by just assigning the array to a string. outputs This means all the work your function needs to do is mostly done for you. You just need to make sure that you add the line break tag at the end of each array. For that you can use the function directly. Delimiting the output. There remains one problem. If you call it will put a break between each item. So you need to still have the test. Creating a second array is overkill as all you need is what delimiter to use. This can be done with a simple expression. 

Now, as we all know, building up a linked list by repeatedly appending to the end is a bit inefficient. Probably for such small lists as you'll be using in test cases here it won't matter, but it's a good idea to get in the habit of paying attention to some of the easiest stuff, so let's try to improve this a bit. We have a choice here: either we can keep the interface of this function as-is, that is, always output a list in the right order, or we can choose to change the interface, and change all the call-sites of this function. I think for this case we can keep the interface. The idea we'll take is to build up the list backwards, then reverse it at the very end. The name is traditional for local workers. 

We first need to fix up some typing issues, since we've changed the interface to and this is a caller. As before, we can do that just by putting in a ; as before, we'll spell the combination of and as . 

Avoid placing javascrpt inside the HTML content. It makes it much harder to manage your code. Use an unquie Id to identify elements for direct or queried access from within your javascript. 

Hard coding outside data source should be avoided. Hard coding outside data sources will present an ongoing workload. This will be compounded by the fact there is no validation of data. At anytime the data source may change, add, or remove properties. You will not know about the change (if you don't personally follow the source doc feed) until it fails or a customer/consumer reports the problem, or worse just stops using it. Testing for a valid response will not protect against modified data. Even if you validate the data it will just improve response time for the fix / update but not the underlying problem. The cost. Every change will require an update, test, documentation, deploy, monitor, release, and pray cycle for the life of the service. As a business I would have to pass this cost/ risk on to the client or revenue source, and having a programmer on call is very expensive. In other words this type of design can kill a service. For the sake of auto complete it is not worth it. You are best of generating something that Vs2017 can read (I don't use it so you will have to look in the docs) and hard coding as little as possible that is outside your direct control. 

First things first: you'll definitely want to learn a bit about precedence! Normally I'm in favor of adding some unnecessary parentheses if it helps disambiguate a strange situation or if the operators involved aren't often mixed, but too many of them can get in the way of readability. Also, take advantage of that sweet syntactic sugar for lists that the language provides! So iteration one of this function is 

This name sure leaves something to be desired! And it leaves another important thing to be desired, too: there's lots of inputs where it just crashes. Nasty! It turns out that you never call it on inputs of that form later, but totality is another good habit that you should get yourself into. It's just another tool in the mature programmer's defensive programming toolbelt. In our case, we'll want to handle cases like , or , or , etc. where there's no good answer to return. What should we return if that happens? One simple and quite common choice is to change our type from 

Create the object We can put it into an object with the method and then run a good set of tests. You should always test for errors not just for good results. 

Suggestions I would normally do a rewrite, but in this case there are too many issues and a rewrite would look nothing like your original. 

The reason is that numbers when used in computers have a limited precision. Once you go over that precision you can no longer add numbers that are smaller. For example adding 100 to the hash number does nothing the returns true. 

Drying out the code. You don't need OCD to want DRY code. It is a fundamental requirement of any good code (with a few special case exceptions) that it is DRY. Looking at the code and first impression is that its "OMG bottom of the pool soaking wet." How to dry code. Look for repeating code. Yep obvious I know but look at the following... 

Now you can add to the HTML as many episodes as you like, and don't need to change the code saving you a lot of time, and reducing the chance of bugs creeping in due to typos just because there has been a content change.