Set everything to as you don't know if anything is a composite. This isn't really required as in Java is by default. Starting with to , if , loop over for while in increments of and set . You now have an where anything that is () is a prime. 

So now you can easily add new "transformations" to the list. In order to transform an to the correct in Scala we would simple use as is also a collection. No such luck in Java. I came up with this thing, it's a little ugly but I think it's clear: 

Your first version is unreliable if there are numbers that consist of more than one digit. For example, the method would count only two distinct numbers in the array , and only one distinct number in the array . Apart from that, you could also use a stream: 

Judging by your comment, you already seem to be aware of the method , so there's no need to explain how to chain those comparators using this method. Unfortunately, the forth comparison stage does not fit into this pattern. Of course, you could ditch the nulls-first comparator and write your own generalized version of it which, instead of comparing the two values with , checks a given against the values: 

You're close to a sieve, but you're missing some points. First and foremost your is incorrect - this should step though the range in steps of ; this very fact precludes the use of a . The usual approach uses a , on which you carry out the following steps: 

Are horrible! If you need to label a variable declaration with what that variable is, you have picked the wrong name. Further, if you are going to use inline comments, avoid the case where the comment makes the line so long that it's illegible. 

You can reduce the code duplication by moving the logic of comparing two values of which at least one is to a separate method and call this method like this: 

A final remark: It is usually not necessary to declare variables or method parameters as interface implementations (e.g. , ) rather than interfaces (e.g. , ). For example, the method in your first approach only depends on the functionality of the interface and not on how this interface is implemented, so it might as well accept any instead of only an . 

it's recursive - Java doesn't handle tail optimisation and recursion is slow It makes a rather large number of copies - copies the underlying it's very long 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread. 

Your code still wins. The differences are even more significant in some cases than when the arrays only contained 10,000 integers. Next, increase the array size to 1,000,000 integers: 

A final comment on using . You list the fact that it has a built-in method for calculating the greatest common divisor as the only reason for using it. But a method for calculating the gcd is easily written in a few lines. If this is really your only reason for using , then you might consider writing a simple method for calculating the gcd of two s (or alternatively s, as ponomandr has suggested), and reap the benefits of using primitive values instead of s (e.g., as you have noticed, the use of operators). Of course, on the other hand, you would also have to deal with their limited range. Update 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

This should reduce the amount of time the spends resizing itself. This reduces the runtime by about for - so has little effect. These sort of micro-optimisations should always be tested using benchmarks to see if the additional code complexity warrants their addition. A few comments on the code: Use of You use sometimes to delimit references that won't change: 

After spending more hours than I'd like to admit on trying to figure out your algorithm and why it is slow, and after multiple false epiphanies, thinking that I have finally discovered the weakness in your program, I believe that, now, I have really found out where the problem with your code lies. Considering all the drafts I've written for explaining where your algorithms wastes performances, trying to format it so that it is easy to read, and even trying out some LaTeX expressions, the emphasis on the word "painfully" becomes all the more justified when I say that the explanation for your algorithm's unsatisfactory performance is really painfully simple. So here goes â€¦ the reason your code is slow is: $$...$$$$...$$$$j$$ Seriously, when the loop that introduces is executed after the first time, it does nothing it hasn't already done the first time around. All local variables declared outside the loop except (i.e. the method parameters) have the exact same values as they did during the first execution of the loop. I can't believe I didn't see this earlier. But now that I'm writing an answer to this question, I will also tell you what I did to make the code a bit more read-/understandable (in my opinion). Since, inside the method body, only elements from with an index larger than or equal to are queried, and doesn't serve any other purpose than to mark this index, I've eliminated altogether and adjusted the recursive calls so that they only pass a sublist of the array with the relevant elements: 

never create a in a loop, and always close resources. never write this is ugly and error prone ( also compiles). you only need to check once; after reading user input. 

Essentially we take each and we it that gives us a . I then you the method to append all present instances to a . If the `StringBuilder is empty simply append the current integer too. An alternative, not sure if it's better, is: 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

You are horrified by "the type of that thing" because you are using stream operations for something they were not meant for. The purpose of streams is to perform pre-defined operations on an arbitrary number of elements of a kind. However, you have a scenario where the operation you want to perform depends on the nature of the stream itself. I did not really inspect your code in detail, because, based on your description of what you want to do, my suggestion would be to use a different approach altogether: It is possible to obtain an iterator over the elements of a stream by calling on a stream (which is a terminal operation, so the stream will be consumed after creating the iterator, which means that you can obtain the iterator only once). Using that iterator, you can simply accumulate the elements inside the encountered s in a as long as they are all right eithers. If you encounter a left either, you stop iterating and return this left either. If the iterator is exhausted before you encounter a left either, you just wrap the now fully populated list in a right either and return that either. 

As runs in a separate , we need to consider visibility and atomicity of any variables used to communicate. So an seems the natural choice: 

You don't use any of the properties of . You do not need to know that it is a . I would specify the argument as and leave the invoking class to decide on an implementation. Brackets There are two styles of using curly brackets in Java, and either are valid: 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: