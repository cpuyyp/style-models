I was just playing around with some code and had the idea about writing some kind of manipulator to delay the output of characters in a typewriter like style. The focus was mostly on how to use it and was inspired by or . Overall it works pretty well. I just want to make sure that I didn't miss anything that may backfire any time. The code is just for playing around and doesn't have a real use case (yet). 

The same way you can "prepare" the values of and . If the user wants to be inverted you use otherwise you use for both calculation and output. 

Comparing the new code to a normal for loop with the same range actually shows us no difference in compiler instructions: 

So I came up with a solution that should be as fast a "normal" loop. As already discussed your main problem is the function that is called on every iteration. I removed the check (see comments) and instead added a function to calculate a range that is compatible with the size of (see comments). This function is now used instead of just using (see comments). Also: To prevent someone from messing around with the iterator I made the constructor private and added as friend class (see comments). 

You could and should read the user inputs into variables of types that represent what you are doing with them best. E.g. whether the user wants to invert or should be a boolean. For the operation I would recommend declaring an enum. I would also print messages about input errors directly where they happen. If a user already enters a wrong operation (e.g. "XOR") in the first question, why should you let him enter two additional values before you tell him. Additionally your messages can be more specific. Checking/Comparing user input that is not required to be case sensitive is easiest done by making the user input upper case (or lower case) and compare against the wanted/required values in the same case. This method is also less frustrating if you don't need to retype as you accidentially typed . If the user enters something invalid you can also force him to enter a valid value by using a loop that doesn't quit until something valid was entered. And last but not least you output. You can completely stream line the way you do it by "calculating" the values depending on the user input beforehand and output everything later. E.g. this line: 

As mentioned in the comments the question that you are asking is actually off topic as you have not implemented it yet and there are many solutions (you could for example do everything as percentage or vh/vw units rather than pixels). What you're asking for is a concept known as responsive design. I will however review the code that you have. First problem I see 

Ever since LINQ came out I've been talking about how the syntax is really awful. It looks friendly at first but it completely hides what is really going on which is really useful to understand. Here is the much shorter way of writing it with the extension methods off of IQueryable along with a few other adjustements. 

First, unless the module is about force times distance in a physics simulator, it is a terribly over-generic name! What does the name communicate to someone who is sitting down with your application for the first time? Name modules after what they do and be as specific as possible but not more so. Second, if you're only exposing a single method in that module just return that method directly, no need for an object. Next, won't your scrolling handlers depend on a specific structure being present already? You might want to make it explicit. I can't really make a recommendation how without understanding better how you plan to use this (I'm really confused what could possibly do). As for where key navigation should go, it really is all about naming. So if you view the arrow key navigation to be a part of the grid scrolling then yes, it should be in the module that sets that up, otherwise it should not be. Finally, What if you have two grids on the same page? seems like you're trying to apply a lot of stuff globally? Perhaps your modules can accept the grid you want to modify as a parameter? 

One comment on the code: you will find your constructors easier to maintain if you use constructor chaining protected BaseCache() : this(Guid.NewGuid() ) { } Now my possibly ignorant comments on other things. 

This is of course fairly advanced coding but it is possible and probably only about 10 lines of code. Like I said you can look at Automapper for some of this functionality out of the box (though I don't know how well it would do with windows/web forms). I will say that what you're looking for is similar to the functionality provided by the MVVM pattern so if you're doing windows forms you can look at Truss. If you're doing web forms...well I wouldn't do web forms, this functionality is already in ASP MVC and silverlight which are both like a million times easier to work with but I remember there being some buzz about the ASP MVP project that would help with those issues. 

Coupling seems to be yet another repeating issue in your code - it limits the reusability. Your code made a lot of assumptions on how it is going to be used. For example: You seems to believe that's the code will only be executed in a context where you do have a Console? What if you don't? Like when it is ported to become a service, or a GUI application? Environment.Exit() is another. Why don't you let your caller to choose what to do when the file is invalid/not found? The path is yet another. What if it is used in another environment without that particular path? The general principle is as follow. The less policy you put in your code, the more reusable it would be. Of course, more effort on the caller side to specify them. For a utility class like this, it would worth the effort to make it reusable. 

Whoever got access to the Container object instance can call this method, which means you basically have a global variable that anyone can access. That's a bad idea, because it will makes debugging really difficult. From these classes, it appears to me that all you needed is to let the app name and app owner initialized once and get access anywhere, you can make that by simply having a Configuration class with a static property. 

Since you didn't specify a particular aspect to code review for, I would review the code and comment and whatever I see fit. Inconsistency seems to be a repeating issue in your code - inconsistent code confuse people. In particular: Why do you use Pascal casing for one field and then use _ prefix for another? 

You print out "Start" to the standard output. This basically restrict any usage of this class to have access to a console. What if it is used in a GUI application? What if this is used in a server application? Also, "Start" what? Whoever read the console will have no clue what is started? The object is constructed as a static field, and Java did not guarantee when these static constructor are run (they only guarantee it is run before the class methods is run, so it is basically you have a console print that is shown in non-deterministic time. This is not great too. 

Congratulations to the completion of your substantial project. It is really smart and brave for you to ask for feedback. I am going to tell you what is not so perfect about your code, after all, that's the whole point, right? But don't be discouraged, for you have done a decent job! Let's begin with the high level algorithm: The first thing I would like to point out is the usage on memory, in various places you make deep copies of all the cells. This is pretty convenient to do, but it also take up a lot of space. For the unique/elim/subset functions, you can simply return a flag if the board is changed, and save a copy in the solve function. It might be difficult to remove the deepcopy in the guess function, and that's probably fine, as you might be making a lot of changes. Try save some space, you should notice a performance change. Then let's talk about the code: The checkpuzzle function and the backgroundcheckpuzzle is almost identical, why don't you just parameterize it just like you did in unique? A lot of the code have the structure of going through each of the row/column/squares. It looks like a lot of duplication to me. What if you abstract them into a concept called block, and just iterate through all blocks? Last, and probably least, you made a few typos, 'recieve', 'posslibles' 'indicies', and I highly doubt the word 'possibles', although Wikipedia say it is a plural of an adjective.