The way you arrange the code by columns makes it (marginally) easier to read, but over the lifetime of a project, you will either get some tokens out of sync with each other, or have to realign entire lists of functions when you change the length of an identifier; it is debatable if the extra ease in reading the code is worth it - because once you get used to reading untabulated code, the extra alignment adds nothing but extra maintenance effort). 

You should probably also add a using directive with a local alias for and . I only focused on the safety and ease of (mis)use of the public API. Will probably post some more on the code, later. 

It should populate a result and return by value. Other issues: class interface is ambiguous (actually, you have no public interface). What can you do with a server? Does it always start listening? constructor does too many things. If it fails to run all operations, the object is not fully constructed and you have resource leaks. A constructor, ideally, should only receive fully constructed values and set them as field members. Aditionally, a constructor should (ideally) perform no computations and be as close as possible to code that doesn't fail. If you have computations to perform for initializing the values to be passed in an object instance, these computations should be performed in a factory function. Start using RAII (for example, the call to should be placed in an object's destructor). Note: this list is by no means complete. 

End second edit. You are writing client code assuming that your Figure class hierarchy supports polymorphic behavior (i.e. assumes that the return type of will support a function). This implies you should write the base class to support invalid operations on compilation: 

The function as it is, depends on the client to check for errors on the stream (either by calling or by checking the stream state, after the call to ). Ideally, I would want to write: 

Some observations: Your data should (probably) be private. Otherwise, an enterprising developer will do this: 

Naming things The names you give your classes and variables could be improved. Consider telling a colleague that you "have a linked" in your code (will they understand that?) I would simply call it "list", "linked_list", or "forward_list" (but not "linked"). Same goes for: 

establish speed requirement for the code (i.e. "how optimized do you need it to be") measure the current efficiency of the code. 

I am not sure this is a good idea (nor do I think the cpplinq in @MichaelUrman's post is a good idea - though it's definitely workable). Basically you are writing a fully templated hierarchy of classes, to replace (existing, stable and presumably tested) functionality in std algorithm: Your code: 

Otherwise (if you want to write C code), you will have to iterate over the entire data once and compute it's resulting size, then allocate memory for the result, then iterate again over the data to create the buffer contents, then sent to socket and remember the result in a variable, then free the allocated memory, then deturn the stored result. If it sounds ugly, that's because it is :D. Edit: The HTTP standard states that you should send at the end of header lines, not . It may not matter much in effect though, because both servers and clients are mandated to receive and parse both variants - as developers tend not to respect this rule (I may be remembering it wrong though). 

The code is not only long, but also repetitive in some cases. These repetitions should be grouped by type and purpose (i.e. add some structures/classes to it, encapsulating data with the same purpose). That means, instead of having: 

You use ushort for the size of the string. This will allow a size of max 65535 bytes in your string; Is this by design? Consider using standard algorithms: 

It is done correctly (i.e. it does what the contract of it's API should), but not efficiently. The operator iterates twice (once in has_key and once in the operator). You can replace both calls with a call to std::find_if, and remove the has_key function completely. 

Otherwise, nX and next should be private data, with getters to read the values and setters to validate and set the values. Line (3) is a bad implementation for a constructor, because it leaves a new instance in a partially-initialized state (it should initialize nX, next and head, explicitly and in this specific order). Better implementation: 

Now, you can write a chart that combines verification and identification information, or a chart that is "different for regular print" (as you said). You can also add a different specialization for reports (say "multiple_charts_report" that uses charts differently, or in different positions in the report). This could implement verification and identification reports as two separate units (maybe different charts in different places in the generated report?). (sorry for abusing the word "different"). I chose this architecture, because now chart development can continue without touching the report hierarchy (it is orthogonal to it). Also, if initializing a report becomes more than 1 LOC long, consider writing a factory function for creating report objects. Client code (assuming you implement a ): 

As a general rule, never use macrodefinitions to write code. In this code, you are better off writing the output code directly. Also, you never use err macro (so you might as well remove it). You should also refactor this code: 

This is not a lock-free queue, but a locking-agnostic queue. That means, it is not safe to use on multiple threads. The reason this works in your implementation is because the push calls alter the end of the queue and the pop calls alter the beginning (so conflicts are more or less, avoided). If you tried adding elements from multiple threads at the same time (for example), you would leak elements. Since is never changed in the destructor, if it is initialized, you will always get to throw the exception. Consider splitting into a and a ; This would allow for an exception-safe implementation of the operations. 

You are falling into a trap with this. Instead of attempting to create a String class for generic use that is "very optimized", set concrete requirements for it beforehand (e.g. "should be able to perform X instantiations in 10 seconds"; measure these on the machine you need it to work on, and optimize only when the implementation doesn't match your target; most other approaches to optimization are forms of premature optimization). 

The code is a bit bigger, and some syntactic sugar is missing (stuff that you added in your example, like chaining calls and multiple keys per entry) but the code is semantically the same. My point to adding this code: your class only makes sense if you use lots of switches (on strings) in your code, and usually in OOP, if you do have big switches in your code, you should extract them as a hierarchy of classes (or a table of functions) anyway. 

I renamed the APIs you used from callback1/2 to on_data (same name) and unified the implementations of fireCallback1 and fireCallback2. 

Please stop doing this. when you add directives in header files, any file including that header will have potential namespace clashes (which is the problem namespaces are trying to prevent). 

This will shorten the code in main and make it easier to update (because it centralizes the output operation to a single place): 

First (1), don't use in C++. There are (arguably) places where it improves things, but in this case, you can simply replace it with a (or ) loop. Second (2, 3), you are throwing a dynamically allocated ERR instance, which is bad (because it won't get caught) and unnecessary. The code should be . Third (3), you should catch a exception reference, and it would probably be beneficial to make a specialization of std::runtime_error. 

They are more efficient and more idiomatic. The first takes the argument by value (constructs a string copy when it receives an argument) , then moves the constructed value into Student::name. The second is marginally faster than the first (but this speed difference should not matter in most use cases, so which you choose is a matter of style), but it doesn't express as well as the first, the idea that Student gets it's own copy of the string (passing by value means "the function gets it's own copy of the value", or "the function takes ownership of the argument"). 

If you want two versions of the code, consider using templates (instead of conditioning the code to the macro): you will only compile once, and without imposing flags on the compiler/build system/ide. 

Yes (but please refer to it as "template method" - "template function" makes most c++ developers think of ). 

All these can be avoided by not returning a raw pointer from your class. Consider returning a instead, and using other means to edit or set the buffer, than this API. You say: 

This API returns a , which is among the worst possible ways of returning data in C++ (you are removing type information from the result). In order for client code to know what is actually returned here, you have to look at the implementation (a big no-no), and the runtime configuration on the system (this is even worse). Consider returning a custom structure that holds the information (preferably as a string, or something that does it's own memory management). Stop using C-style casts. They introduce points that are inflexible to change and difficult to find (a nightmare for maintenance and extension of the functionality). 

The code is incomplete (you'd need a specialization of sync for const access and so on) but it should be enough to give you a picture. Advantages: 

Regarding the first way (generic optimizations in written code), your code could use the following improvements: 

The algorithm is a shallow comparison between the documents: it is possible that one of the children of site_entries has a corresponding child in the other document (by name), but other changes are present between the two (like subnodes). Was your intention a shallow comparison algorithm, or is your implementation incomplete? That said: 

If you remove the calls to (it's not standard anyway), you can also remove the calls to (because their purpose is to keep the data visible before the next clrscr call). consider having at most one instruction per line. For example, this code is difficult to read: 

Edit: here's some client code, that is possible due to the separation of the parsing and the construction: 

That said, you should only need one retrieval of the size in this function, and that is for preallocating the result (so you need no len variable at all): 

Do not iterate using indexes, unless you need to keep track of the index for another operation. Iterators are more idiomatic and safer - because it is more difficult to make a mistake). That said, you don't need iterators either - you need std::transform.