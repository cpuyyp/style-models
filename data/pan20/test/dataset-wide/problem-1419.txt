Basically, you're slowing down your code by checking the time. The generating of random numbers takes some time, but and are surprisingly fast. The real bottleneck? Your OPC connection. And I'm not sure whether this can be fixed at all in code. 

You really don't want to name a variable . It's ambiguous. So how about a containing all the relevant information of a ? 

Note to potential future reviewers: This code appears to be suitable for Python 3 only. Let's structure your code a little and see if we can fix the timing problem. I propose the following order: 

Your function kind-of works as intended, except the obvious deviation occurring at the crossings of rings. However, you can only draw the logo at one specific size and you need a heck of a lot of code to do it. Let's start with a little clean-up and I'll explain the how and the why afterwards: 

Please name your variables appropriately. Single-letter variables are in most cases sub-optimal and make it needlessly hard for the you-in-six-weeks to figure out what it does. I'm fairly sure your algorithm is sub-par as well, although I'm not that proficient in algorithms myself. I suspect a function like this already exists in the Python library, I'll update this answer when I've found it. The following is double work: 

Don't be discouraged by the length of the review. Most of the points mentioned in section 2 and 3 are only there because they'll hurt when you start writing larger programs. At the end of the review a partially fixed piece of code is included to illustrate some of the points. I'll leave it up to you to find the differences and implement the rest of the points mentioned. 

If you're interested in learning OOP and don't have the ambition to work with embedded electronics (roughly everything smaller than a phone), you're really more interested in C++ than C. This review is written based on the assumption you want to write C++ and ignores C. Your current method of reading a file is odd. While checking for is a relatively easy method to check whether you've hit the end of a file yet, it's not the only thing you should check for when reading a file. C++ can check whether the input is still 'good'. You could do so like this: 

You got those as function and variable names. Don't. Consider naming something after a built-in illegal. Functions and variables Function, method and variable names are all . Lowercase with underscores as separators. If you feel the need to indicate a function is part of a group of functions, like you did with the dealer functions, consider making them methods part of a class. Problem solved. Global variables which will never changed (think constants, except Python doesn't have them) are in . I don't know what and are doing in your program, but names should be effective in telling the world what they mean. Those don't cut it. 

The mathematically inclined can probably tell us what such a sequence is called, but it should be obvious to the rest of us that the first 7 characters are always the same and only the 8th varies. Now, there's an achievement for lighting up all 8 dots within 60 seconds. Since it's already 128 clicks for lighting up the 8th one alone, I decided to automate the process using SCAR Divi (manual), an environment running Pascal scripts which allows you to automate keyboard presses and mouse movements. Code The resulting code is ugly, but I was mainly looking for fast code. This means it may not be up to par with Pascal-style and I took a short-cut wherever I thought it would influence the execution speed. I'm looking for improvements on readability wherever this does not hurt the performance in any way. I've written a fair bit of Pascal but I've always been a little fuzzy on what did and didn't impact performance. General tips about this are welcome. The most used procedure is , short for Move'n'Click. It moves the mouse to whatever coordinate you give it, clicks once with the left mouse-button and halts in between to give the rest of the computer time to catch up. Or whatever it does in that time, but it breaks terribly if it doesn't wait long enough. All values are hardcoded. I'm aware I can put them at the front of the program as global variables, but I wasn't sure whether the additional look-up would penalize performance. Current script manages to win in 21.86 seconds :-) virgilwBrain.scar 

Your menu could be replaced by a switch instead. Switches are more readable, faster, easier to maintain/expand and the idiomatic way of doing such things: 

Right? Because your code isn't exactly structured. Part of that is due to incredibly large functions like these containing abominations like these: 

If that should do what you want it to do, create it before the first . But since you overwrite it anyway, why not toss it? Which leaves the following: 

No, you don't. You really don't want to do that. I was going to leave this as a comment, but it's too extensive and too important for that: Security in a program should be incorporated before making optimizations. With every security feature added you risk breaking those optimizations open again, rendering all work you put into them null and void. Make it work first, make it pretty later. In this case, I'd definitely consider adding the security a mandatory feature of the code. SQL injection has been around for a long time and the single reason it's still a thing is because code like yours is still around. Nobody wants that, really. In this case, you'll find parametrized queries will solve your injection problem. However, those can't be optimized like ordinary strings. They got their own rules and tricks. 

And yes, that's quite a mouthful. And longer than 80 characters. So, for small programs which only import from 1 library this way, there's no problem. Import 6 different libraries like that and you're importing a lot of stuff you don't need. What would happen if 2 or 3 libraries have a function? By writing out which ones you need, you immediately realize the problem should such a thing happen. Of-course, the obvious solution is simply importing like this: 

This isn't your bottleneck (not by a long shot), but that second reeks of bad time complexity for something simple as telling the user where the images are. One of the major time-consumers appears to be the downloading itself. I ran against your code to find the bottleneck(s): 

However, that's absolutely unreadable. Please re-consider what's really important to you. If this would be code for the company you work for and they'd review your code (and any company-code should be reviewed before being used in production), they wouldn't ask it to be shorter. They'd ask it to be clear. 

Way too much code indeed. Java is verbose, but it doesn't have to be this verbose. There are also too many magic numbers. Code should be self-documenting and yours isn't. The variable naming is iffy at best and the case switch should've been a map, or at least an array, of sorts. You have created a , but it's unclear what you mean with this. Magnitude is about relative size. That's good. Roman numerals are a relative system. But your is a mess and extending it with only makes it worse. I'm going to be harsh here, but if you'd present this in an interview, you would not get the job. That's ok, you simply weren't familiar with the in-built constructs of the language. But those exist for a reason and you should show at an interview you grasp their basics. That's one of the things an interview-question asks of you: to show you know how to get something simple small done using the tools the language already provides for you. Don't re-invent the wheel unless specifically asked to. Now you've tackled the problem, consider looking at how other people have solved this problem. Their approaches and the answers provided can teach you alternative methods to familiarize yourself with. 

Comments After the to start a comment, leave a space before writing down the actual comment. Leave (at least) 2 spaces before the . 

Book name: 122 characters. File name (incl. extension): 160 characters. There can be a lot of authors: 

Yes, there will only ever be 7 in a classic Tangram. Yes, it still looks hideous. A piece is called a by the way, so you could use that in your variable naming. is a construct I expected to see in your solver. 

There. Done. I just threw out 50 lines of code. Instead of adding something to , you now add something to .Instead of adding something to , you now add something to . The following makes me think you really wanted to create a object instead: 

and out of the after handling the first successful hit, but since I'm not sure I'll ever do that the current, simple version will suffice. All PDFs should be in the following format: 

Where is the amount of spaces to print. Of-course you could extract this number to a which would make your code easier to maintain. That said, there are many things you could extract into and other variables for increased maintainability. Note we need to include for this to work. The following code has all the above implemented plus one inconsistency fix. I leave it as an exercise to the OP to find it. Inconsistencies in writing style can lead to confusing code in larger projects and should be avoided. 

Much neater! Easier to maintain, you're not needlessly repeating yourself (those are more like parentheses in this regard) and it's immediately clear all those conditionals rely on the same variable. The ease of understanding your code just went up a couple of points. 

HackerRank currently has '7 days of JavaScript' going, a quick intro into the JavaScript language. Every day a couple of challenges will be made available. One of the challenges of today was this: 

The following pascal script needs a bit of context for it's purpose to be understood. For those who don't give about purpose, feel free to skip ahead. Background A game I'm terribly fond of has a couple of levels which have nothing to do with the rest of the game. One of those is a puzzle: When you open the game, it looks like this: 

Explanation: The print statement in Brainfuck is . The resulting Brainfuck prints the original string character-by-character, so there will be as much as there are characters to print. Between those there will be either if the ASCII is higher than the previous character and if it's lower. The Brainfuck doesn't think. It increments, decrements or prints. Example usage: Input: 

The following code transforms multi-line input into the the Brainfuck equivalent. One line turns into one program. The resulting programs are split by newlines for readability. Brainf.cpp 

I'm not certain whether adding shebangs is a standardized practice in libraries and their example usage. I suspect it's not for the former but is for the latter. Any input on this during a review would be great. 

You're only interested in the value of , not in the variable it produces itself. Have you tried using instead? is much faster than . Afar from that, I cut-out the OPC parts and ran the rest through a profiler. 

Comments should explain why, not how. Also, your spacing is inconsistent. The following would be more readable: 

You may want a construction that keeps asking the user for valid input unless he enters a given exit sequence. Challenge 1 and 2 can handle different amounts of input. While it's not required for challenge 3, it would clean-up your code considerably. The moment you start using variable names like and you should ask yourself whether those are descriptive. Descriptive variable naming helps a lot when adding features later on or trying to understand what you've written a long time ago when looking back on it. 

Yea, and that's where my "magic number" alarm goes off. Why is it ? Why not one more or one less? If you intend to convey the function failed (the did not hold), use a negative return value instead and make sure the function calling it understands what that means. Now you're simply suppressing the error and using the as part of your calculator. Your is doing things it shouldn't be doing, even if it looks like it's doing next to nothing. True, but it's doing the wrong things. 

You got a great project running, but it's far from finished. If you leave it in it's current state and take your mind of it for a couple of days, can you still understand what it's doing and why? How about multiple weeks? Lack of structure is how good projects die a silent death. 

Python has an official style guide, PEP8. It won't hurt getting familiar with it, since it helps keeping your code readable, consistent and ready for others to mess with. Combining Italian and English gets confusing fast. It's also unhelpful for those of us that don't read Italian. There's also a distinct lack of whitespace between blocks of code and one-letter variable names are not helpful. Your class uses a where . I don't like globals, especially in a class. Consider the following: 

Yes, I know 1 of my lines is slightly too long according to PEP8. That's the result of the function failing the Single Responsibility Principle and lack of helper functions. If that gets fixed, the offending line will probably be fixed in the process. That's also the reason there are no docstrings yet. The function structure as-is is flawed, even though the current function names are very descriptive. I've tried putting the results in a dictionary, like this: 

The writing style gives away they're supposed to be constants, so the only comment on it is unhelpful. Why is there a blank line between and , but not between and the loop? Why are the constants being defined inconsistently? Whatever you do, be consistent. That entire for loop is usually replaced by a generator expression in modern Python. Although might be even faster, I'm not sure. But say you want to keep the loop around, is there anything to improve? Plenty. 

Indentation Your code isn't indented. Indentation is a major step forward in readability. Spaces A single space goes before and after operators. There are also spaces after commas. Semi-colons You are missing a here: 

"But let's assume that the entered three numbers have to be summed up and that one has to use xor in some way." Read the instructions again. You're explicitly not allowed to actually sum the numbers. This can be done using XOR as suggested. Your first part of the solution uses , disqualifying your code. The keyword to the actual solution would be checking for parity. Keep in mind you don't have to add the numbers to know whether the result of a sum would be odd or even: