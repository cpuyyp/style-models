Thanks to this pattern any new formats can be added as separate classes (supporting the interface), so the system is open for extension, and they can be registered within the factory. The base routine () is closed, which is what we want. The factory only carries one responsibility, which is to match any given file type to respective behavior, or file processing strategy. This means there is only one ever one reason to modify the factory: when this logic needs to be enhanced, or modified. 

And again this is subjective, but I see these as a (common) anti-pattern. It's code, not a painting or a poem ;) We've got version control systems for that. 

A red flag goes off for me every time I get to hear "this class does this, and that etc." - this is at odds with Single Responsibility Principle, stating that class should only have one. Do one thing, do it well. The infamous suffix is a code smell, too. How vague is that? All too often it actually means "I had no idea how to call it". In this case it's more of a naming issue, really - your doesn't really manage anything, it just builds database connections. Not connection strings, but connections themselves. Correspondingly, I would rename it to or perhaps - since it's not parameterized - . It describes what it does way more accurately. I would also try to be consistent - if you have: 

for reasons that I hope you can see. is always initialized to the same value (). You could use a field initializer instead, and get rid of the parameterless constructor. Same effect, less lines of code. When there is no ambiguity (like a parameter named the same as a field), and there isn't any in this code, you don't need to refer to fields by , as in . Especially since you're not consistent about it and this code sometimes does it, and sometimes not. Consistency is a highly valuable trait when it comes to code. Other concerns 

Shouldn't this be a , or ? And why is it defined in ? It feels wrong if a parent class knows about its child class. 

and are . Did you test what happens for very large numbers? All your tests use trivially small values, certainly not the ones that would warrant the use of . Lagging constructors are a big no-no. I would aim for lazy evaluation here, or at least replace the constructor with a static method, with a name indicating it's triggering a process (create, evaluate, convert?). Constructors should be fast as lightning. 

These switches are identical. It bloats the codebase and hurts readability and maintanability. Aim for code reuse instead. In this particular case, you could create a method converting factors (expressed as 1, 2, 3 etc.) into actual values (0.001m, etc.) and call it twice in your code, cutting down on needless repetition. Nesting constructs isn't good practice, either - it's not very readable. Try to refactor your code into methods. Having the entirety of your program in is not recommended. Also, as @Michael has already pointed out, you're not validating user input at all. One typo and your app will crash, or fail to work as expected. 

It's a matter of taste, but here I would ditch the "Method" suffix, as these aren't necessarily "methods". Note that you didn't name the class . Why not just and ? 

There, I'll say it: it can't be done. C# doesn't allow identifiers to start with digits. All workarounds either won't meet all your requirements (eg. @radarbob's answer, while clever, doesn't let you narrow down numeric values to a predefined set of legal ones, which I understand to be your main goal) - or will get you on a ride that ends up back on square one (if you use a dictionary as @Malachi suggests, then the name of this dictionary will go upfront, and it still doesn't start with a digit). Underscore prefixes are as close as you can get. Abusing Unicode a bit might work to a degree: 

You have not implemented exception handling (the last requirement). Eg. if calling code passes to or , it won't crash straight away, but as soon as you call , it will result in an unhandled once it gets to this null "fruit". Also note that we don't know what calling code may pass in as an argument - could be some object that implements one of the interfaces, but actually explodes once our code calls its or ... The requirement states that it's the responsibility of this code to handle exceptions, so if this was my homework, I'd prefer to be on the safe side here. Less importantly, you implemented as a property of rather than a field (which is what the description asks for), although public fields actually are considered a bit of a code smell, and a backing field is automatically created for properties, so I would leave it. Aiming at good code style you could make it immutable though (as a field, or a property with a private setter), and set it in the constructor - it stands to reason that name of a given fruit isn't subject to change. and could be too, but that's nitpicking already. Apart from the lack of exception handling, it seems okay to me. I like that you used some modern C# features to cut down on verbosity. 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

What's the point of catching a ? When do you expect it to happen? I don't really like that this method mutates the list passed in as a parameter - and then also returns it, even though the returned value is actually redundant as the calling code already has a hold of the now modified list. You're kind of sharing the result of the operation in two ways at once, which feels redundant. And I know it's often done that way, but I think it's bad practice nevertheless, and can lead to confusion. Personally I'd prefer to be more explicit about what's going on, and either a) make a deep copy of the original list, and return an independent version of it (with entries removed), without affecting the original one - or b) make this method , like Collections.sort(). See command-query separation principle. Making a method look like a query can lead me to believe it's a pure function, with no side effects, whereas it actually does cause side effects, mutating the input data. The name is very vague - "remove", remove what? Is the blacklisted data ("FIRST", "SECOND", "THIRD") likely to ever change? In the spirit of making this code more modular I would consider extracting that list to a separate parameter. Single responsibility principle indicates that a method should have one clear responsibility, and one could argue that filtering out certain entries and knowing the blacklist are two responsibilities. Your mileage may vary though, depending on the cnotext - which I don't know. Not a biggie, but whitespace is out of control (, ), not to mention it's , not . Depending on how class is implemented, which I can't see - if it's a light-weight object and if its method would compare instances by their value ()... then we could leverage Collections.removeAll and save ourselves writing the iterative removal by hand. 

It's obvious that it's a class - which implements/represents this, that or the other... and it's obvious that the comment refers to this class, not some other one a mile away. This is just fluff. (I know there are APIs in Java that do the same thing - in my opinion it's not something worth mimicking). 

So how on earth is it able to correctly detect whether is present in the collection? Standardization Custom collections should support standard .NET interfaces such as IList. Otherwise other code can't really use it (other than as an ) unless specifically refactored to do so. Besides, your implementation doesn't allow inserting an element in between pre-existing elements, which pretty much defeats any major benefits of implementing a collection as a linked list. Generics As @MatsMug remarked already, it's supposed to be generic, yet - same as your previous implementation - it doesn't support , only its non-generic, legacy version. Documentation It's good that you now use documentation comments (at least for a class that's supposed to be of general use). But this "this is" (as in "this is a singly linked list data structure" or "this is the Node class") is unnecessary. It's just fluff. We understand that it's a class, and that the comment must refer to this class, not some other class elsewhere. Typos don't make great impression either ("Implementatoin"). If your class is opinionated about nullability (which is an improvement over your previous submission), this should be described in documentation comments. As of now, your comments are stating the obvious, for example: 

the else-return bloc doesn't serve any purpose. The same with calls at the end of methods (, , , , ): redundant. These methods are exited anyway. You don't need to use both and clauses. It's one too many. Eg.: 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

doesn't make sense to me. When your code is conditional, DRY (Don't Repeat Yourself) and try to extract whatever is common for all execution paths. Eg. 

The last trick I can think of would be to convert these conditionals into instances, and pass them to the LINQ chain. I haven't got a C# IDE on this computer, so this code could be syntactically incorrect, but you get the idea: 

Agreed again. I would extract the inner part of the loop in (). Whenever there's a loop wrapped around a large block of code, it smells of violation of Single Responsibility Principle to me. Because iterating through entities seems to be sort of a responsibility in its own right, separate from doing whatever the body of the loop is doing with them. Also the code that handles in both these methods is repetitive and could be encapsulated in a separate, parameterized method. 

We've cut on verbosity, but it's debatable to me whether it improves readability. It's harder to achieve the same thing for , although you could pull it through if you added a helper extension: 

Is it worth it, or over-engineered? This is subjective and a matter of taste. Some find verbosity more readable, others prefer terseness/expressiveness. I would let both solutions slide in a peer review, although creating a single-use extension method () looks like a minor code smell. Another way to avoid repetitive overwriting of , which you're uncomfortable with, would be to introduce temporary variables: 

Both approaches are acceptable, but the one using a feels cleaner to me, and brings some advantages at no significant cost. 

As explained in comments (in which I pointed out a few possible edge cases), even though it's not optimized in terms of performance, this is about as clear as it gets. A more clever algorithm - calculating the number of weekdays without iterating through all of them - is probably possible, but I bet it would be much less readable. If performance isn't a concern at this point, I'd leave it. You could maybe replace the loop with a LINQ-based solution. 

PS. Note that in C# lower-case names should be used for parameters and variables - so it would be , , etc. And I believe you don't really need . 

Having said all that, I have to say this code is quite decent and promising for someone who have only been programming for a few months. There are slip-ups, but it shows you have good capability in structuring abstract concepts, and that's the core skill in programming.