It feels to me that 8 DOM changes are trivial to do by your browser; but the thing to do here is to actually figure out how many requests your code needs to be capable of handling. A bad option would be to update the DOM on each X-th response, because you are introducing the timed-out problem again. So, a better option is adding your responses to a queue and updating the DOM each X ms. That way you have the best of both worlds, and it doesn't matter how much feeds you'll be adding because it scales pretty well. There might probably be other problems at the high end, like updating too much DOM at once, but that's out of the question here... 

The program below is just for fun. Since the program asks for recursion, then in principle, recursion should be the sole iteration technique. Assuming that the requirement is to only implement a single function, and that is terminated, the following program illustrates how this is possible. Basically, the technique is to use the value of control the mode of the function. There are three modes: initial call, reverse each word, and reverse string. A positive signals the initial call, and represents the length of the string. On initial call, the program follows the algorithm recipe of: first reverse the input string, then reverse each word in the input string. A value of zero causes the function to find the beginning and end of the first word in the string, reverse it, and recursively repeat the process beginning after the just reversed word. A negative causes the function to reverse the string assuming its length is . The off by one length is used to make sure the string reversal case does not run into the word reversal case. Thus, a count represents an empty string. 

Generally speaking, I like your code. I think it's well planned with few inefficiencies. I'm also impressed by your use of PHP's class. When creating XML via PHP, I usually opt for loops and output buffering. I've been aware of this object class, but your example is the first I've ever seen it put to use. +1 for showing me something new! :D 

The general theme I'm going with in this example class is that on construction, html is stored in a variable via output buffer and then returned by a public method. When evaluating this code, consider that the html will not be static. Page title, description, keywords and the such will be subbed out with dynamic property references. My overall question is: In object oriented programming, ideally where should the output be stored? PHP's class, however useful, doesn't really answer this question for me. Also in this instance, is there any best practice trade-off between using an output buffer and heredoc syntax? Thanks in advance for your guidance! 

We can then hypothetically assume the existence of APIs that allowed a binary tree consisting of s to be created, even though the APIs manipulate . can be used to implement a stateful callback. It is not as useful for a stateless callback where a simple callback function pointer would have been sufficient. However, consider the case where there was a threshold to decide whether or not to delete an element, and the threshold was decided at runtime. 

assumes the current node is already discounted for pruning, and prunes each of the left and right subtrees of the current node. 

Example This is a generic binary tree interface. The usage would use membership of into the client's data structure. 

From here on, you could look for things that are already implemented in Powershell to make the code even more simple, as well as adding documentation to make some less obvious things easier to understand for fellow readers. 

When you need this amount of spaces in front of your code, I'd say no too. This is clearly a sign that what you're writing could be extracted into a function call, our main could be a chain of function calls instead of a big clump of code. 

It's unclear to me why the requests are timing out, but you could simply store the results of the responses in memory as opposed to what you might be doing; synchronization logic is not necessary, you only need to know when all requests ended. However, the downside of this approach is that time outs can make your application show nothing to your visitors, which is something you really don't want to do... 

PS. I wrote this script in haste to accomplish a task. I can understand if you wouldn't consider this script distribution worthy. EDIT: So I arrived at work today to find my script at some point exceeded 536MB of memory and quit on fatal error. I had already increased my ini file's parameter from 128MB to 512MB. This doesn't necessarily reflect an issue with the script itself. I just wanted to share my frustration with the task. 

I've been rolling around several ideas or approaches in my head, and none seem any more useful or "right" than another. I'm sure this is extremely objective but I'm looking for a close-to-definitive answer on the object oriented approach to large block string storage and output in PHP. Given the following example, how could I change my approach in a way that might cause Zeev Suraski to pat me on the back and say Mazel Tov (beside using HTML5)? 

Note the lack of looping structures within the function. All loops are accomplished with recursion or hidden by standard library functions and . 

This is a class I implemented that can be thought of as a highly specialized version of for pointers. It provides the additional feature that the elements can be removed in constant time with the element alone. This is accomplished with an to associate list elements with their . I would appreciate any suggestions for improvement. I am particularly keen to know if there is a better way to enforce that the template parameter has to be a pointer type. The class currently does not work for , so any thoughts on what needs to be done on that front would be great. Also, if there is just a plain better way of doing the same thing, I would welcome those thoughts as well. 

which can be improved to not add multiple spaces by restricting the match or by doing another replace where you replace by . Of course this example might not be worth it, but if you've got to do heavier duty then you'll quickly want to resort to a regular expression instead of much longer trial-and-error code. Conditions can be functions, too. 

Of course, this won't work out of the box; that's what object-oriented programming will help with. Also, if you need to map one-to-one, use list comprehensions or functions like . Regular expressions might sometimes be valuable. 

A first thing to note is that you are creating a lot of COMObjects in a similar manner, we can simply extract that behavior as a separate function. Then, we note that you are expecting file names as parameters where you could expect an item instead; that allows you to pass on items to Create-List3 instead, thus allowing for piping Get-ChildItem into rather than doing extra conversion calls back and forth. As a result of this two things we're left with a lot of Split-Path calls, we can simply port them over to extracted function as well, it appared that you only needed one of the Split-Pat calls only once. After that, some small cleanup has been done (removing $test1, adding extra newlines and spaces for readability) and we already have much cleaner code to continue from: 

I should preface with the fact that I don't know python. It's likely that I've made a very clear error in my following edit. Generally though, I prefer your second function to your first. If python allows, I would break it up a bit for readability. Why do I like it? It doesn't need the keyword and it's less nested. 

I'm just waiting for this answer to get flagged as not being helpful. Serves me right for putting my two cents in when I don't even know the language. ;) 

For someone who is just picking up the language, I'd say you're off to a great start. Don't be afraid to abstract the different pieces of your program logic to many separate files and including them only when needed - It will make future revisions much less of a headache. When you are dealing with large blocks of output data like in your switch statement, PHP's output buffer can be your greatest friend. Your program also presents a great opportunity for you to get acquainted with the extension - its relative purpose is structured output. Referencing what @php-coder suggested, once you get comfortable working with a database, you can start abstracting your application into purpose-driven layers - The Model-View-Controller design pattern is a pretty common method among popular PHP frameworks. PHP 5.3 and its common extensions host roughly 1,300 built-in functions - Have fun with it; it's a great language! +1 for your first review. Edit: How to style your code is normally a matter of personal preference and readability, but if you are looking for some general guidance, take a look at the Zend Framework Coding Style Guidelines. It's mostly just a reference for ZF extension authors, but it's none the less helpful for general interests.