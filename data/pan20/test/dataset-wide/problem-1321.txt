Be careful with your map, I don't know what unload resource does, but it better call delete if that's (dynamically) how you're allocating your resources. However, a better idea might instead to use with a custom deleter. Here's a mock implementation: 

Some implementations (such as VC++) of will ignore the specified alignment template argument if it greater than and default to said value. If you want to support over-aligned types in a portable way, you should specify storage alignment manually: 

Demo Note: The public interface should be based on as defined in the C++ standard. This implementation is purely for demonstrative purposes. 

Use integer types with well-defined widths In the header, you are provided with fixed width types. Currently, your structure assumes that is 32 bits, however, on some implementations it will be 64 bits. Simply replace with . The latter type is guaranteed to always be 32 bits wide. 

You can similarly apply this to all your other applicable conversion operators. It will greatly reduce the amount of code inside your class. 

I don't know Python, so this is a purely C++ review. 1 PYObjectBase 1.1 What is a const rvalue? Move operations ownership of some resource generally, so how can a move operation's parameter be ? It logically does not make sense. Your function... 

Consider the rule of 5 when your class manages a resource. Whenever your class manages a resource, it probably needs to implement the destructor, copy and move operations. You definitely do not want pointers to be copied when a copy of is made. Possible issues: 

It simply returns , it should return . Note that this is a source of a bug in your code. You end up creating a temporary when you assign by using the dereference operator. This can (and did on my system) result on a crash due to the memory access violation. Only align to alignments that are powers of 2. Your test code aligns to 7 and 13. From [basic.align] in the C++ Standard (emphasis mine): 

Storing the whole path as to be used later. Stripping the prefix, domain components, and OU individual prefixes, splitting into an array of individual OUs, and flipping the array (LDAP paths are "backwards"). Creating an for each individual OU, and assembling into a tree. 

Some of these do feel odd, like they are too Linq-heavy or just unnatural ways of accomplishing the goal. The top method has an array cast to avoid "multiple enumeration" as ReSharper says. Is that really necessary? 

I have statement that is switching on an to build a depending on what the selected value is. While the various values require different operations in their s of the , some of them require some of the same operations. All of the s are declared as and initialized in the constructor of the class. This method is called whenever the value changes, and is set to a property that is bound to by a in my view. Switching to would allow for 'circuit simplification' per se, but at the expense of some readability (and the ease of ordering the s). 

Whenever you declare and assign a variable in a single statement, if you are not going to assign it as , use the keyword instead of the type name. 

During the launch, the host AD server is contacted and a list of all OUs is retrieved. The OU list is parsed into a . Since the OUs are in the form of LDAP paths, this process involves: 

I have a MVVM application that fetches data from active directory and displays it in a . The exact data displayed is determined by which query a user runs, and there are multiple available queries. Each query requires slightly different logic, but they all have the same general idea. These methods are all in my . is a property that is bound to the in the . If you would like to see any additional code for this review, please let me know. I am attempting to divide this project (several thousand lines long) into reasonably sized chunks for review. These methods are contributing greatly to the length, especially considering I intend on adding even more query options in the future. As of now, the whole class is 1000 lines long, with these methods being close to 400 lines. 

Part 2 consists of manipulating an integer pack: shifting the pack left or right (where values wrap around). Overview 

As my comment states, you cannot modify a value. Your compiler should be giving you an error. Simply remove the modifier from to make it valid. 2 PYArgs 2.1 Those are not universal references! has this constructor: 

There is a small subtle bug you can avoid by doing it like shown above, but I will describe it so you can be on the look out in the future. The bug is that the elapsed time is stored in a , but basically returns . How is this an issue? Well, must be represented by a signed integer type of at least 64 bits (see: $URL$ While a does have 64 bits, it's certainly lacking the ability to represent values from the integer point of view. This would result in a loss of precision/erroneous results. 

Performs the set intersection of two integer packs. The output set is sorted. The output set will have the integer type returned by applying to the integer types of the left and right integer packs. 

Factor out repeated code. Your overloads and have the exact same block of code being repeated; this block is a prime candidate for being extracted into a private function: 

Make an type where is the values in the range \$[from, to]\$ using an increment/decrement of . will be subtracted if \$from > to\$. Tests 

The variadic template is not a pack forwarding references, it is an rvalue reference pack. For it to be a forwarding reference variadic template, the variadic template must be a function template parameter: 

Do we really need and ? No. Here is an alternative solution: You currently allocate bytes. This is wasteful. You can use exactly as much space as you need by declaring your storage any of these two ways: 

Silent bug: Bad move constructor Your move constructor will perform a copy because your parameter is ; you cannot move from a value because moving implies modifying what you're moving from. Simply change the signature to: 

I am making a kind of form, and I want the user to be able to enter a dynamic number of string inputs. The idea is that a single will be displayed, and once the user has filled that out, they will be able to add another one, and repeat the process as they keep filling the text boxes. Once there are multiple, they can remove any text box if they no longer want it. This is accomplished with a containing a custom which is a with a and two s. XAML: 

Your conditional statement using the variable reads very oddly. Granted, I normally wouldn't be using a loop over a collection with a randomly generated number as the conditional, but maybe that's just me. Outside of the code itself, I don't understand what "problem" you are trying to solve. I don't see how this type of transformation would be useful. In your example, the code will actually do nothing, as the first list is initialized empty and nothing is added to it. 

This class represents a single query on an Active Directory. It is given the type of query to run and the types of data to return, and performs the query and returns the data when it is commanded to do so. The goals I had with this class were to ensure that the query is run async so it doesn't freeze (and crash) the UI and to be able to create the query without executing it immediately. The queries also support cancellation (it is handled farther "down" the calling tree in the and classes). Questions I have: 

I have created a few extension methods to get the direct reports of a as s themselves. This saves the user of the API quite a bit of typing. 

Right now, the only way I see to do this is a multiple iteration of the results. I must go through the file system to fetch all the directories and save them, then find the longest path, and then format them all into a string. Needless to say, this takes a very long time on large file systems, such as one of my company's network shares with over 200,000 directories. It takes over a day for the program to run on this share, but if I make the path print in a single cell, using only one iteration, it takes minutes. For more narrow queries, the program runs acceptably well, usually within a few seconds. However, I'm sure there is some way to reduce the multiple iterations so that the time required is reduced also. PermissionsChecker 

Every two iterations, the digit length of the reduction must be smaller. Reduction 3 will give us the same value as reduction 1, so you could check against that as well. 

This finds the number of doors that can be opened by key \$K = 1\$ in the range \$[10, 32800]\$. As a general note, please note that identifiers that end with are reserved by POSIX, so be careful if you're including POSIX headers (if you are, remove the part to be safe). 

This implementation is missing a range based erase operation. However, the building blocks to build such a function are already present. 

Unaligned memory Your storage is aligned for , which will lead to performance issues in most architectures and in others it just won't work (crash). Replace: 

Note 1: I've renamed the function to to keep consistency with other similar functions such as . I've also reordered the initial condition to take advantage of boolean short circuiting. Note 2: As Rakete1111 points out, if your compiler hasn't caught up to C++11 yet, accessing the first character of an empty string is undefined behaviour. The condition should be modified like so: 

Note the consistent use of the same construction approach (placement-new) which looks nice and prevents syntax issues with primitive types. Mark functions as when appropriate. Non-throwing functions of yours include , and a few more. This will help programmers know that certain functions do not throw, which can help with optimizations. For compile-time conditional marking, use type traits. Here's a sample: 

Performs the set intersection of two integer packs. The output set is sorted. The output set will have the same integer type as the integer pack specified as the left template argument. Tests 

Destructor Here, we notice that your only usage of is in the destructor. You don't provide any query member functions, so let's just go ahead and remove altogether. This will make the class smaller. You also want milliseconds, but first take seconds and then multiply by 1000. You can directly get milliseconds by using . 

Converting user principal to dictionary entry. Getting direct reports property of dictionary entry. Casting property to string enumerable. Using each string (distinguished name) to search for a user principal. 

Is there anything I can do to reduce the number of blocks? Am I even disposing of everything properly? 

After much frustration and leaked memory from working with s and s, I have made a wrapper to get the relevant data from these objects and then dispose of them, keeping the data in a form that will be dealt with automatically when it reaches the end of its scope. Side Note: As it stands, I can't use this code. It is far slower than using , and while it might do a better job of cleaning up, it is currently using more RAM. This takes 281 seconds and 104MB to handle 58 items, whereas the other way with takes less than a second and 101MB. 

The code is executed by creating a new and calling . Like I said before, if I change the program so that the string building is handled inside the directory getting, thereby only iterating over each directory once, the program runs many times faster, but at the expense of being able to split the paths and then "right-align" the permissions result. I thought about displaying the permissions first, and then the path, but that goes against the spec I was given to work by. 

which is far simpler. The odds that someone will be randomly working with are pretty slim in my opinion, so you should perhaps consider changing your method(?) to accept a if not a or even an instead. Speaking of "method," it seems that this code should be one. It effectively takes an input and produces an output, so why not isolate it to be its own piece of code that you can call wherever you want? You could also get rid of that statement in favor of a proper . It would look something like this: