This copies every string in , at the very least write . Even better, use a standard algorithm. In general, whenever you write a loop, especially a for each loop, look for a standard algorithm. In this case, comes to mind (this would make it so that you would take by value, as it modifies the range): 

Consider using void functions Your functions all return an . It's not very clear what the return value would mean, so I was puzzled over that for a bit, but then I noticed that they all returned : 

You can reduce the requirements on your iterator. You declare that you want a , but you really don't need that. Just use and : 

This function is really big. It's 97 lines long. Break it up into smaller functions. Notice how you have comments for several small sections of code? Those are ideal for turning into functions. Yes, you will have many functions, but the readability greatly improves. However, many of your "functions" can be replaced with standard algorithms. 

C++ doesn't supply a , so I decided to implement one. However, I was viewing this as more of a hash library than extensions to , so I placed it all under the namespace . This was my first time seriously using template meta-progamming. I tried to make my code work no matter the cv-ness of the variable, or whether it was an rvalue or an lvalue. I'm not sure on the efficiency of execution, but I believe the compiler can optimize it down to simple arithmetic on hash values. hash.h 

If the body is a let binding, I take out one definition and append to the let bindings, and recurs. (This implies the where definitions appear in front of any existing let definitions in the result, and the order of where definitions will be reversed). 

(We could have a data constructor that have two fields, however I prefer to use the more efficient keyword so have to have only one field as a tuple) To parse a list of tokens, we define the function as following: 

The naming. Are there a better name for ? Support for similar bindings like , , etc. All of those seems to share the same pattern and so I can just replicate the code to do so but there are quite a few variations (6 in total if I was right). So are there any way to eliminate the code duplication? Are there any other ideas to improve the code? 

Finally, if the body is not a let binding, I need to take out one definition and make a let binding. 

The above works perfectally fine, and although it does not make sense to make it an instance of (in ) as we don't allow trace back, the other combinators that only requires worked perfectally fine. However, the performance seems to be too bad. It is possibly as it keeps all possible parsing path and so consumes too much memory. For example, a simple will return 8 results, with all combinations of dots. But I think there should be some way to improve the performance. Please advise me how to improve on this. 

You don't need to copy the entire matrix. For an matrix, copying takes extra space. You can get by with space, or copying only a single row. The idea is to modify the matrix in place, using a single-dimensional array to hold the old values of the row you are working on. Then, you simply use that array when you get the old values for computing the new line. You will need another variable as well. Something like this (doesn't completely work and I don't recommend this code style; this is just to get the idea out there): 

You should really put the operators in a namespace. I would recommend not even using operator overloading, and instead making a , but if you want to do the operator overloading, putting it in a namespace makes it easier for a user to opt-in: 

This does mean that your will have to change, but I find it much more readable to just keep an index/iterator separate from the for loop. Alternatively, I would loop by index. Iterator loops are just hard to read. On that note, though, you should write this: 

requires that its iterators are Bidirectional Iterators, so that could be your requirement. Do note that a different iterator class may have a different algorithmic complexity, so you'd have to evaluate if there was any change. 

and ; those names are very similar. I can't tell what they do differently just from the name. You should name them based on what they do. would be better named something along the lines of . 

Dead code does nothing, except take up screen space, and confuse people who don't know why it was written and removed in the first place. Braces This is a bit of a holy-war. However, at least one bug (the Apple SSL bug) was caused by missing braces. Personally, I use them: 

I really like how you use the HTML5 element instead of using the old style When people write CSS, they often format it slightly different, like this: 

I don't like the required length in the ctor for . Allowing the user to provide an array signals that you don't care about the number of cards provided. If there must be a specific number of cards, you should make the user provide them explicitly, and if you need to, concatenate them into an array in the constructor. If this was a public library, this would probably be quite the pain point for your users, and when it comes down to it, you are basically just a user 6 weeks/months after you write this. 

One thing is is not only checking the prime, but also printing it. This could be moved into , or I could write another function to take care of that. After profiling my code, these are the results I got: 

My views are all either static information or a simple iteration over a list of data; here is my view for the above model class: 

Sure there is. Check the input and notify the user, and let them try again. And do it in a dedicated method. Maybe you can modify the stub method I gave you into and make sure it is within the ranges provided. This is a perfect example of extracting similar logic into a more generic function. 

The keys are the first two elements of each list, still in a The values are the 3rd element of each list. 

is more well known as "apply". You take a meta-function and an argument list, and apply the function on the arguments. 

Don't use comments to show flow of the methods. , , etc are not useful comments. If it is necessary to include such comments to be able to figure out what is being closed with the , you should refactor into yet another function. In this case, it is perfectly clear that you are ending the function. 

But this also disregards - which could be called an edge case, so you need to test zero as well. Not too bad. If you tested these cases, you'd cover most possible bugs. There are a couple more edge cases since we are working with floating point numbers, but from someone learning to code, I wouldn't be upset if they didn't cover them. 

It is a bit strange to use a class for sorting. That your sort function is in a class implies that there's state, which is unexpected. You could use a namespace. 

While we are discussing iterator categories, it's useful to name after the iterator category you require, so or would be better names. 

These functions imply that there is some setup needed to actually use a . However, it is a good idea to have all setup be finished at the end of your constructor. These functions should be removed in favor of an extra constructor parameter of ; to import from file, you can have a free function: 

I have tried out different ways for the instance of , but finally I believe the best way to give definition of is to define (or in the monad library) first. 

I hav tried the same thing in G++ (version 4.5 from Ubuntu 11.04 original), and the result is quite impressing me. We now do have a lot more features to generise the solution. 

Instance of is more tricky, but the easiest way is to make it depend on the not yet implemented instance of . 

A new scheme user trying to use to define something like the Haskell keyword. Sometimes this is useful since when we do programming, we first design in the high level, where all the names left undefined. In later steps, we define those names and complete the program. keyword preserves the order of definition which keeps the last name defined first. The idea is simple. I start with a 

This allows back tracking and multiple results. However I think it would be good to have it in "push" style, means the parser will have a set of result when no more input given, and have a transition function that for a given token, results in a new state of the parser. This results in the defintion 

I also tried write a free template function to access the internal function. And the result looks good. I just wanted to say: it is elegant! 

we can now support any number of parameters without modifying the code. the t2t class is no longer needed as G++ lambda supports accessing all identifiers in scope, including global things. 

In this block, you are catching the exception, then returning the exception to the user as a piece of data. A better way to do this would be to just not catch the exception and let the caller catch it: 

Third, it is good practice to use braces around one line statements to help prevent errors. Fourth, you should keep your indentation at the same level: 

First, split your methods up into smaller units. For example, should have this general structure (and PascalCase naming): 

Please tell me the good, bad, and awful so I do, don't, and don't do the same in my next venture into VB land. 

Don't store information in strings. What happens if you want to check this value and type ? Or what about ? Those checks will both fail. Create an enum with these values. 

The next post in my Checker series: The C# wrapper for my F# library to make it cleaner for these methods to be called from C# code. GeneralTypes.cs 

Second, rather than creating a new variable and iterating backwards, I would write my second loop like this: 

Then, you have the same code run with different values in each of the statements. Why not separate that into a method, and pass the values needed to calculate the required values? If you do this, you would be able to change your into something like this: 

Passing the configuration needed to be updated into the method ensures that the other settings are saved as well because the only settings updated are the ones related the unit test settings. Because the configuration passed in has reference semantics, the parameter passed in keeps the changes.