Or better yet, build the initial list based upon content in a dictionary. That way you don't run the risk of having typos in the switch or the initial setup: 

Entity Framework implementation assembly References Model and the Entity Framework / System.Data.Entity assemblies 

It is very confusing to set a property just to discover that it returns something else just after you set it. Properties are supposed to keep the value you give them. (At least logically) And since your SkipSomeStuff property is public, you have no guarantee you won't access that property by accident before the intended recipient accesses it, and the stuff isn't skipped after all. How about keeping the skipSomeStuff member, but set it using a method called SkipStuffNextTime() or something like that? Nobody will misunderstand the intent of your code that way, and only the code it's relevant for will access and reset it. 

Even though the code is short and pretty enough, I think you'd benefit from reading about the strategy pattern and state machines. Go ahead and google it for a wealth of resources on good programming techniques. You'd also be much more confident in how it works and how to arrive at those patterns by employing unit-testing and test driven development. (JUnit is a good start) Good luck with your assignment! 

here's the output of this program. [a, b, c, g, k] [1, 3, 4, 5, 5, 7] And as I mentioned before, you could write some code that looks something like this. 

Another technique that we can use to make code more readable and easier to write (once you get used to it) is by using classes. Consider this partial example of what your code could look like 

this is a violation of the Tell don't ask principle. Here, you are asking the object to tell you what its health points are, so that you can perform some calculation with that result. Instead, you should tell the object what you want to know. For example 

thanks for sharing your code! I want to start by saying that I think this looks pretty good for someone only having been coding for around a month, but I think you're getting some concepts mixed up or not quite sure how/where/why to use them. The other comments and answers have already pointed out flaws with the class, so I won't repeat those 

An here would be the programmer's mistake, you should make sure that your code can't even raise an in the first place by using correct conditions in your loops. You can also removed the try/except sections completely and your code still behaves the same way. 

I just re-read some comments and realize you need paging too. Add a private int page, and a private int pagesize, then add the multiplication of those to foods[i] in CreateButtons, and swap foods.Length with pagesize. You can have as big an array as you want then. 

Not entirely sure I got your schema right, but something like this should be possible. (omitted a bit of ordering, and I assume you only have one current year) 

As a sidenote, I'd look for another name than "BaseClass". It doesn't say anything about what it does. 

I wouldn't presume the metadata information gathered from reflection as mentioned by w0lf will be handled completely if you reference the Model property directly from the lambdas. 

Instead of wrapping the proxy creation in a concrete service proxy implementation, I'd write a concrete service factory instead which in turn uses the ChannelFactory. The service factory class could also use an interface for creation, so you can have multiple concrete factories. $URL$ That way your code can continue to depend on the interface only, and you can change the way the proxy is created without writing concrete proxies. You could also have a "local service factory" which doesn't go over the wire. Usage would be something like this instead: 

I'm not sure why you do a check for null in some of your add methods. The only time the list can be null is if the caller sets the list to null. If you want the setters, I would maybe throw a when trying to set one of the lists as null. (another danger of providing a setter) I don't think there's a good reason for providing a getter/setter for any of your lists, instead you should provide an and method. If you just do this, your List can never be null, provided to initialise it in the constructor (like you do already). As for your actual question, I think Mibac provided a good alternative, just make a copy constructor instead. 

The presence of a variable is a bit suspect. This usually indicates that maybe you should be using a class instead. Perhaps a object. It might be nice to be able to instantiate a slot machine object and call a method on it. 

so we don't need to do any if-else checks here. Now I haven't added in any checks to make sure the user enters a valid value. This is a problem that was pointed out in the other answers. I would like to also add that I don't think recursion is necessary and only adds complexity that we don't need. A simple loop to keep prompting the user to enter a valid turn would be better I think. I don't like and 0 and 1 are magic numbers here and should be avoided. this would be a lot more readable if we have a meaningful names instead. 

You should use as predicates on your interface and have the implement that interface. By only using , you won't get translation to L2E etc, but will have to enumerate the entire DB table before you can evaluate the . The interface can be mocked, hence unit-tested without a physical db and also used with other ORMs. It's generally prefered to keep and the in a separate implementation. You can pass the to the repository constructor, which can access an internal property on the UOW exposing the . By doing that you can share the same between repositories, and batch updates to several entity roots of different type. You also keep fewer open connections, which are the most expensive resource you have when it comes to DBs. Not to forget they can share transactions. :) Hence you should not dispose the DbContext in the Repository, the Repository really doesn't need to be disposable at all. But the UnitOfWork / DbContext must be disposed by something. Also, ditch the predicate to . Since you return an , and use an for the predicate, you can keep building the Queryable after the call. For instance . It will still be translated to "select [fields] from [table] where [predicate] order by [orderprop]" when enumerated. Otherwise it looks good. Here's a couple of good examples: $URL$ $URL$ $URL$ And here's how I do it: Model / Common / Business assembly No references but BCL and other possible models (interfaces/dtos) 

now there can be no confusion with who won the game. I also don't like itself as a function name, it doesn't really say what it's doing. I would prefer , or or something more along those lines. Don't worry about trying to keep names short, make them as clear as possible. 

At the moment you're offsetting in 2 places, when in fact you don't need to do this anywhere! This is making the code more difficult for other people to follow. In your display method 

Now here, we're still using the same number of lines (1), but this gives more meaning to the code. Code can now look like this 

Now, in order to be a , we just need to implement an method. So instead of maintaining booleans which describe the concrete class, we can make many smaller implementations instead. Let's have a look at a potential implementation. 

If you're not used to Java streams this change may look a bit complicated, but really all we're doing here is getting the Stream of the list of employes, filtering out based on the isFree method, and sorting by the getPriority value. So now we've deleted some unneeded methods in the form of addX addY. We're now just handling a single list, not a list of 3 lists. It's open to modification in that we can add any other Employee type in the future and this code will still work! With this new code, this is what your main method can look like. 

This makes closed for modification (cannot change price / individual price), but open for extension (can add to price). (Naming and structure in my example could probably be improved, but it serves the purpose) The behavior is still possible to modify, though, so an even better solution would be to have some collection or set of rules you can add to, so you don't accidentaly override without calling . 

You aren't renaming it either, you're naming the parameter for the anonymous function the lambda expression represents. But if you don't like the lambda syntax, there's also overloads taking the property name as a string. 

Overriding the property in modifies the behavior of . Which means you've broken the OCP. Besides, what do you expect to be if you have just set it to 10.0? (Does it even compile when you only override get?) What you could do is employ the template method pattern: 

You don't have to use x as the parameter name for the lambda. You can call it model with a small m for instance. 

If you do this, you'll probably see some pattern emerge. I can already see two classes, or rather instances of a- instead of one. Maybe something like Strategy?