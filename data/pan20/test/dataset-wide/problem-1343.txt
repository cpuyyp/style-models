I like more the first solution because it visually groups together the variables on the left side of the and the value on the right side. Unfortunately I can't back this preference with a strong reason other than personal taste. In your situation I'd struggle for uniformity across your codebase and define a single convention that every programmer should follow. It seems that you and your colleague are already trying to agree, but I wanted to point it out explicitly because I think that it is very important. 

Let's start with an alternative, more object oriented design. Then I'll make some comments about things you can improve in your code. You should try to clearly separate your game logic with what you need to do for handling input/output. Consider for instance the following class sketch to represent a game. 

You can read the choice of the user as you did, but you should change how you handle it to use the function we defined earlier. 

I also noticed this comment and it is a bit of a red flag to me. It is the only statement in that method so you should have it to actually return something, not only to make the compiler happy. 

I think it is worth it, even if you're implementing a simple mathematical function like this one. I'd also try to make it clear what you're doing with the expression. What about introducing an variable? I think introducing it (or an equivalent function) would make your code more readable. I'd also rename to something like , which would make it clear that you're computing the factor corresponding to each binary digit and deciding whether to use it or not according to . I'd also recommend you to do some validation of your input values. What happens if you get passed a negative value for ? You can either make it an exceptional case and throw an or handle it knowing that 

Return or Output I feel like should either (a) simply tell you the max value or (b) give you the items that it used. Right now, you're returning (a) and logging, incompletely, (b). (Incomplete because if you use a fractional amount of an item, that's not indicated). I suggest you pick one or the other. If the former, basically just drop the s. If the latter, you'll want to return something like a: 

You don't need an assignment operator to . Just copy assignment and move assignment suffice. Similarly, you have two constructors taking a and an . The latter isn't really useful since you can't move out of an anyway (the elements you get back are of type ). Just have the one constructor: 

This is wrong for several reasons: (1) you don't need the initial (2) The ending is meaningless (3) is the wrong construct (4) you reference at the end of the loop when you really want . Prefer the following: 

That's inefficient (you're copy constructing a pair instead of in-place constructing it) and just a bunch of extra typing. Also is , so the above line is logically exactly equivalent to: 

Note that I'm using (which just gives you a generator) rather than (which must give you the full list). Furthermore, why do we need a ? We only care about those words which match the given frequency. Why not just keep a list? 

That class should contain a reference to an InputStream and to an OutputStream and it should completely handle input validation and the rendering of the game state on the screen. should represent an action of you game such as create a new game, exit, ... I don't think it is responsibility of your application to maintain a list of words in an external file. You can use a class to read from the file, but you should not write to it. You should just have a implementing a method. Finally you need to put everything together. What about this simple game loop in the method. Note that you should really decompose it in some sub-methods but I think that for now it would be ok if you manage to get to an implementation that works in this way. 

Why do you have commented out code? If you do need it please throw it away. Leaving it commented out does not help. I'd also replace all these constants with an to improve readability and maintainability of the code. With the you can also rely on the compiler to check that you use a valid value. 

I don't understand the reason why you need . What you need are concrete classes imlementing your interface for your specific types. Imagine you want to map a to a . You need something like this: 

So we're almost done with our nice algorithm, when suddenly... we start over and do a whole new search from scratch throwing everything away? Why? Let's examine such a scenario: 

isn't a good name for that variable. Perhaps ? Consider something like as the return type to more clearly indicate failure. Don't write expressions comparing to booleans: 

And you should actually use that metafunction as part of the signature of every function! That is preferred to a simple since any reflection-style operations on your class would actually yield the correct result: 

That will automatically handle file closing correctly in case of exceptions and the like. I also find it clearer. Also, why ? Prefer Generators reads the entire file into memory. Prefer to just go a line at a time by iterating through it. gives you a full list of all the items. But you don't need them all at once, you just need to iterate through them. For that there's . Use the tools at your disposal You have: 

isn't comparable - but this code would still compile via the conversion, which may be surprising! We can instead write equality like so: 

Finding the best ranking I said before the should yield something more complex than just an enum. But it should yield something comparable. This will let you reduce this loop: 

Generally it looks ok, but there are a few things I don't like. Do your really need you to contain mutable , , , and ? All of them would look better to be read only fields set by the constructor. What's the difference between and the value returned by method? In general, I think that a more even driven approach could be beneficial. What if you have an that allows s to subscribe for new messages? As soon as you have a new message you can feed it to the , which in turn it will be able to add the relevant information to . Note if you do that you will have a much simpler because it will not need anymore to poll queue. Basically, the idea is to have a that gets twitter messages, a that just has the responsibility of analysing them and to just store the processed data. Does it look any better? Finally, you decided to run two threads in parallel. That's fine but I think you should pay more attention to concurrency related issues with your queue. It is not synchronised so you could possibly have one thread reading from it and another modifying it, which could lead to crash or to inconsistent results. 

In addition to the comments in the other answers I'd recommend you to create a function to print the sentences on the screen. Something like