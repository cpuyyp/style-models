Design problems is a queue fused with a single consumer, so there will never be more than one consumer for the queue!. If the consumer is not required to run on its own thread, the implementation could be simplified to: 

Design It's simplicity of usage is great. However, you have no way of enforcing that it will be used at all possible call sites (where appropriate).Another possibility that comes to mind would be to use the State pattern to provide access to the OpenGL functions in form of a member, with 2 states: One that records the OpenGL calls and one that simply forwards them. The call to then switches state from recording to forwarding, executing the recorded calls.Though also not foolproof, but which is harder to forget: "I have to use OpenGL calls in a lambda passed to this function." or "I have to use this member to get access to the OpenGL functions (as they aren't provided directly by default anyways)."? Example (rough outline, as I currently have no Qt install at hand): 

is used in several places, both as a integral value and a pointer value. Try to use more explicit values (especially the more type-safe for pointer values), as currently every time is involved, I have to double check whether the value represented is a pointer or not. 

Note This could maybe be enhanced by strategic use of atomics. However, that would require more knowledge about the members and usages of than I could gather/guess from the code given. 

TL;DR: MSVC does some extra stuff and really doesn't like the call to . To elaborate: The functions in the original examples only takes 16 instruction (GCC) or 23 (+8 inside ) instructions (MSVC) respectively. GCC inlined everything it could, proved that and don't change (so they are basically constant), elided the branch and variable allocations, and just calls directly before exiting. MSVC, however, only inlines the destructor of into and the constructor of into . MSVC seems unable to inline the call to or to prove that and don't actually change values (so it has to create them on the stack and generate instructions/calls for them). But this can be improved! Changing the macro so it doesn't call suddenly allows MSVC to come to the same conclusions as GCC and remove the checks and thus the stack allocations. 

You can use a FOR /F to parse out the command from the arguments. I would define a variable containing a delimited list of all valid commands. Then you can use simple search and replace to validate whether the user entered command is valid. Addition of a new command is as easy as adding the command to the list, and creating a labeled subroutine for the new command. I would use CALL instead of GOTO so that each routine can easily parse the arguments. The only disadvantage is CALL will double up quoted carets ( becomes ) Here is a basic framework that can easily be extended. Note that user entered will be corrupted (or expanded) because of delayed expansion. There are simple ways to get around this limitation with additional code. 

6) You do not need to create an label and GOTO that label. Instead you can do either of the following: or . They are identical, and neither form requires an explicitly declared label. The only difference is that can take an optional argument specifying the returned errorlevel. 7) You should encapsulate the logic for writing an email into a subroutine that accepts the variable portion as arguments. It reduces the amount of code, and eases maintenance. 8) I've simplified your ERRORLEVEL logic by using an extra variable to store the return code. I also make use of the conditional && and || operators with FINDSTR - I find them to be more convenient then checking the ERRORLEVEL. But I didn't use them with WinSCP because the logic is a bit complex. Note that if the last command within a block raises an error, then it would cause the block to fire. That is why my :sendMail routine explicitly exits with a return code of 0 (success). Using the above principles, I would write the code as follows: 

You could even parameterize the two divisors, but then a different algorithm is needed. Here is a fully parameterized solution that is efficient, though perhaps a bit obfuscated. I still use a modulo operation to test if divisible, but instead of an IF statement, I intentionally divide by zero to raise an error and trigger the conditional execution of the SET statement. Of course I redirect error messages to NUL to avoid unwanted error messages.. 

Boundary checks You never verify if is actually a valid position in the list. checks You never check if any call to returns a . Without one kind of check, your code will very likely try to dereference a if is greater than the number of elements in the list. Wrong condition sets to , and if unequal to , executes the branch, deleting a wrong node from the list (it's only the right node if ). You probably meant to write . Memory leak At the begin of the function, you allocate a new node. This node will never be deleted (it either crashes because of nullptr dereference, or another node pointer gets assigned to before gets deleted. Unnecessary nesting The check inside the loop isn't necessary: Just run the loop until ( will then be true after the loop ends). 

Contention There is only one , and every thread is permanently in contention for that same lock for every small partial operation. Thus, all the threads are permanently in contention over that lock, and at most one thread at a time is actually doing any work. A single threaded implementation should be faster - it has to do the same work, but doesn't have to fight over lock control. So, how can this be fixed? 1) Separate independent data per thread In the usage example, elements of are split between threads so that no two threads are accessing the same elements. So, accesses to elements of don't need a lock - if this convention is followed strictly. If this is possible, locks aren't needed for those parts! 2) Finer granularity locks Right now, taking the lock stops every thread from doing any work at all. Even with the improvement of option 1, only one thread at a time can access elements from . This can be improved by introducing locks at a finer granularity: 

So, time to explore the scary depths of template metaprogramming (well, scary for me, anyways). This library basically provides 2 different lists, a list of types and a list of sizes. Both lists support: 

Algorithm allocates a new buffer of scratch memory for each recursive call. This means sorting an array has to use \$O(n \log n)\$ allocations total, with \$2 * n\$ peak memory usage. This is double the amount of memory usually required, and if s runtime complexity is worse than \$O(1)\$, the whole operation will perform worse than \$O(n \log n)\$. Also, every call to unnecessarily copies all of the elements of the previous buffer into the new ones. These copies can be completely skipped with appropriate management of the already existing buffers. The operation isn't stable, though it can trivially be made so by changing to . Stability is usually a major factor for choosing merge sort! Implementation 

Semantic elements are completely supported by almost all browsers except some versions of IE which does not include support for element. Going by the flow chart here: HTML5Doctor Semantics Flow Chart, you can replace the images with tags and associated . You can also make appropriate usage of wherever needed. Remember that we will be/are using semantic markup in order to feed the browsers to read the page more accurately. 

You have used JavaScript code to load the images in middle of the page code. The readability is disturbed. It is better to create a separate file say , write the program inside a function and load it into a div specifically in the file. My edit on your post was rejected because I tried to modify the white-spaces in your code. I would like to add one more thing here. Please try to avoid using so many white-spaces in your code. Although it maybe useful for you in development version for editing, it adds to the bandwidth in your production environment. That is why CDNs serve minified version of the code. Same applies to your HTML as well. Even if you want to implement in dev environment, use the code guidelines I mentioned above. 

Yes, it is fine. Regarding CSS, the difference between ID and class is specificity and uniqueness. You can also link to a div with its ID. Seems more of a personal preference and varies from a developer to another. 

I think it is better to just use . It does not matter now, but when you code for bigger projects CSS performance matters the most. Descendant selectors are considered expensive and you can normally avoid it here by selecting direct element. Both do the same thing. You can use if you want to override some CSS properties only for hosting image containers which are under index pages container. Because CSS specificity will work on it here. Let's say: I have a multiple items with certain class and want to override the items that are within a container. 

But the above code seems to carry little logic. I think you were looking to nest the color classes after parent element like this: 

Try to avoid using underscores and use dashes like to break the class names. You can check the Code Guide written by one of the Twitter Bootstrap core team members. Combinations of underscores and dashes are more suitable in CSS BEM methodology. But in the end what matters is consistency of using the syntax. 

Other possible changes: I didn't make any of the changes below because you said your code was working, and I don't know those programs enough to guarantee the changes are an improvement. A) I don't see why you run WinSCP via START. I believe you could simply use: 

Use FOR /L to iterate a range of numbers - much faster than SET /A with GOTO loop. Use SETLOCAL to localize variables so no need to undefine them. The EnableDelayedExpansion option does just that so that you can use within a FOR loop. A minor optimization - it is faster to combine multiple math computations into one SET /A. 

B) Your sendmail arguments look very suspicious to me. Normally values that contain spaces should be enclosed in quotes. Note that the routine above preserves the lack of quotes by using and instead of and . C) I don't know WinSCP, but I suspect it will overwrite any existing log file, in which case you could remove the prior DEL command. 

You probably want to localize any environment changes. You should initialize your variables to a known state at the beginning, otherwise you could get the wrong result. You have a lot of redundant code that can be eliminated by using a CALLed subroutine You can use the operator to conditionally execute code if the previous command failed. I find it simpler than using IF ERRORLEVEL. You can save a bit of typing by storing code in a variable to be used as a simple macro. 

I can almost guarantee it is not doing what you think. The most it can do is set the ERRORLEVEL. However, The EXIT command expects a numeric argument, but you pass . The EXIT command returns 0 if it does not receive a numeric argument. I doubt you have a variable with a name of "0", so the EXIT command sees a string literal value of , which is non-numeric. It consequently returns 0 every time. Your very next command (FINDSTR), is an external command, so it will set the ERRORLEVEL anyway. There is no need to initialize it. 2) It is generally a good idea to enclose SET assignments in quotes. This guards against poison characters, and inadvertent trailing spaces. (There are some exceptions, but it is a good rule of thumb). 3) It is generally a good idea to always enclose file paths in quotes if a portion is a variable. You never know if the variable may contain spaces or poison characters. The value normally does not have spaces, but it certainly could. 4) There is no need to delete "%temp%\rdcto.txt" when you immediately turn around and recreate it. You can simply redirect using overwrite mode () instead of append mode (). This will guarantee you start out with a fresh file each time. 5) Why do you write the value of %MailDst% using a FOR statement? You can simply echo the value directly.