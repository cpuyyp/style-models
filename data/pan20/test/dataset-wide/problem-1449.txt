You need to check if each letter occurs the name number of times in both strings. One method would be to sort the letters and compare the lists of letters for equality. Here is my approach: 

I think you can improve the 'Inverse rotor pass' a lot by hard-code the inverted rotors instead of searching the inverse function every time. Your is never below so you could try to replace 

If possible I would try to avoid a method like . If someone manages to manipulate the this becomes a classical injection problem. If you do not need the flexibility to make any kind of db requests, use prepared statements for specific requests which only get some parameters. 

I think this method is not that long that you really need to refactor it, but you could do something like 

OpenMP is not a magic box that will automatically make everything faster. You still need to think about synchronisation and proper algorithms. Also starting a thread does have some overhead and if the work done by the thread is small in comparison to the overhead, then you're slowing the program down. There are plenty of resources on parallel programming on the internet, I recommend starting with doing your threading manually until you know how it works and then start using tools like OpenMP. 

Note that the width of the grid at level is (example: 1, 2, 4, 8). Here is an optimized integer power function. If proves to be a bottle neck, you can use a LUT for the powers of 8 and 2. Benefits 

To see where the bottleneck is, you need to profile your code! Here something which may be a little improvement: replace: 

to a method passing 1330 or -25 as a parameter and reuse it instead of having nearly exactly the same code twice. 2. You can extract 

I recommend to do the in a separate method (or simply use I recommend to use instead of I recommend to return an array with the size matching the new number of entries. even if might be cheap to compute, you should avoid computing the same over and over again in the loop-condition. 

If shape and number of polygons do not change (or at least not often), I would add an extra step (the new first step) to your algorithm. Calculate the center and radius of the smallest surrounding circle for each polygon. This way you can calculate in a minimal and maximal distance of all vertices from the given position in one run without iterating through them. If the minimum distance for a polygon is greater than the maximum of an other polygon, no vertex of that polygon can be the nearest => we can ignore this polygon. Than proceed like you did before. 

Okay so this becomes . Note that is easily achievable by other algorithms. This is why you get TLE. Better algorithm We can easily reach time complexity. We need to find all , , such that . Note that this is equivalent to . Hence if we can check if exists in the input in time, then we just need to try each pair of and and see if a matching exists. Since there are pairs we have time. A hash set provides the necessary check if is present in the input. (I'm not going to handle the three zeros, you can figure that out). Pseudocode: 

Morwenn has already done an excellent review. I will just add one example on how to handle the many combinations of order of arguments for the intersection of the shapes. A call to should have the same result as a call to . But that means you'd have to implement quite a few signatures. Luckily there is a function overload resolution rule that essentially says that a non-template overload will be preferred to a template overload. Which means that if you define for one combination of shapes, you can have a template overload which will just swap the arguments. Attempting to call the template overload for two types for which a non-template overload isn't defined will result in a infinite recursion in runtime. This isn't really desirable so one can use SFINAE or some other technique to create a compile time error should the template overload be used with types for which a non-template overload doesn't exist. In the example code below I choose to use a simple dummy argument that is always (note is slightly better than here because zero is the easiest value to generate and compare against for many CPUs, but it's a matter of a few instructions at most). This technique has a slight runtime cost: Passing one extra argument, which if the compiler inlines the code might be removed; But it is the easiest to understand. With a little work you can make a zero-overhead compile time check (left as an exercise for the reader). Example code: 

But only profiling will tell you if / how much speed improvement that brings. Also you should always profile before trying to optimize. See were the bottleneck is. 

to a method passing true or false as a parameter and reuse it instead of having nearly exactly the same code twice. 

In my point of view you cannot implement and any clearer or simpler. In the method I would somehow separate the values and also not print two times and not at all. Here is my suggestion: 

So binary search should be faster, if comparison is the main factor, for n > 4. If n is constant (its seams 64 in your case) you can even hard-code the binary search to avoid the overhead of a loop. (that is also possible for linear search.) As an example how to hard-code a binary search: [for a array with 8 entries] Code will get quite long for 64 entries, but it will be fast. If your intervallBoundary array is intervals[0..7]: 

If input isn't limited to ASCII, simply use a HashSet instead of the boolean array but the array is faster. 

There are some ways that you can avoid this: Use a connectivity matrix Create a VxV boolean matrix, where is if and are connected and false otherwise and is the number of vertices in the graph. Note that this matrix is symmetric and you only ever need to compute the upper right half. Note that you need to adjust your function so that you iterate over one row or column in the matrix depending on how you structure it. Now that the original question has been corrected from to this is no longer feasible. Use a HashMap Create a map that contains the adjacency lists that are created when needed: 

This algorithm is far from optimal runtime O(n*logn), but I have chosen it because of its simplicity. For an Efficient algorithm see the comment of @corsiKa for a quite simple O(n) algorithm. 

Simplified tail-recursive code: end-recursive methods are likely to be detected by the interpreter and transformed to a loop. So this code might be faster and may nor waste memory. For more information see wikipedia Tail call 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

How to compare the the Algorithms: Either determine the complexity of your algorithm and the complexity of the solution in the tutorial. If you want to avoid to determine the complexity based on the source code you can simply implement the tutorial solution and compare the runtime of your algorithm and the runtime of the of the tutorial-algorithm. To get a good idea of the complexity behavior of both algorithms you need inputs of different lengths to approximate the runtime related to the size of the input. How to improve yours If your approach is very different you might not be able to improve your algorithm by looking on the tutorial-algorithm because they are too different. If the Tutorial-algorithm is better at all, you can try to understand the steps it does and try to memorize the general idea of this steps for your next algorithms that address similar problems. 

It is clear that when then and your algorithm will cause your branch and bound algorithm to prune sections of the graph that could contain the optimum. If you are uncertain of the above inequality you can let approach from and let approach from and see that the limit is trivially: 

We have visited all indexes exactly once in 8 steps. What would the next index be? Well \$i_8 = (1+11) \mod 8 = 4\$ and the cycle would repeat. Want another cycle? Pick another \$p\$! Previous index Getting the previous index is a bit more difficult. Consider the modulus of a positive number: \$ R = a \mod b \$ then we have that \$\frac{a}{b}=Q+\frac{R}{b}\$ for some integer \$Q\$. In our case: \$R=i_j\$ and \$b=k\$ and we're interested in \$a=i_{j-1}+p\$. So solving the above gives: \$i_{j-1} = k\cdot Q+i_j-p\$. We then have \$0\le i_{j-1}<k\$ and there exists only one \$Q\$ for which this is true. Just assume \$Q=0\$ for starters, then \$i_j<k<p \Leftrightarrow i_j-p<0\$ then we have \$Q=\left\lceil\frac{i_j-p}{-k}\right\rceil\$. So finally: \$i_{j-1}=k\cdot \left\lfloor\frac{p-i_j+k-1}{k}\right\rfloor+i_j-p\$ Example reverse Here we go: \$i_6=6 \rightarrow i_5 = 8\cdot \left\lfloor\frac{11-6+8-1}{8}\right\rfloor+6-11=3 \$. The others are left as an exercise for the reader. :) Caveat If the number of items happens to be prime, then this will "shuffle" to just a plain reverse. You should detect prime sizes and then padd the size and just skip indicies outside of the range. Note: I don't remember the name of this algorithm, if some one can help me I'd be very happy! Edit Couldn't stop myself, here's an implementation. :) 

I have never written any Lua code before, but a short view in a tutorial at $URL$ let me come up with this: Extract a method which returns 3 values: 

calculate distance to each polygon surrounding circle and eliminate all polygons which are too far away to be a match Entity: performs a loop through all not eleminated polygons. Polygon Loop: loops through ALL vertices of the polygon in the current iteration. Vertex Loop: if the distance between the entity and the current vertex is lower than the distance between the entity and the previous vertex, save the current vertex and the ID of the polygon the vertex belongs to. Once all loops are finished, take the nearest polygon/vertex and get the vertex of the polygon to the left and right of the nearest vertex. Check the left and right vertices to see which is closest to the nearest vertex. Doing so, finds the nearest line of collision to the entity.