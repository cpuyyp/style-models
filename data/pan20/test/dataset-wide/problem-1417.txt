Here's the issue I find with this structure: if I want to change how things validate for an then I have to create different classes that work off different validators, add them to the configuration and hope for the best. I really fail to see where this would save any time/effort, especially if I want to validate something like a where you cannot select an larger than the max user ID, I'd have to either add it to the constructor (which means load from the database each call) or add it to the (which means load from the database, and I have no idea how many times that will happen, I'd hope Autofac would only use one instance of the , but who knows. Certainly not I) and hope for the best. This just seems like a lot of overhead for largely simple tasks. Oh, and I have to register my and with Autofac. 

So, I have another suggestion, to work on top of the suggestions by Heslacher: Eliminate the work. This is easily done with boolean operators (most specifically the shift operators). 

It's been a while since I've touched ASP.NET MVC 3, but in 4 and 5 you can directly manipulate the , and use or . I do this on various validation methods to remove that responsibility from the controller, and reduce the call to: 

This is another pretty basic class I wrote for a library as I hate the way the default in .NET works. Essentially, I wanted to have the operator, as well as implicit conversions to strings. (Rather than needing all the time.) It's pretty small and simple, so there may not be a lot to critique. Also, before you say "just inherit and extend it", it's . 

The suffix on the tells C# that I want that to be an unsigned long or . (Similar to the suffix indicating .) This allows the implicit type engine to appropriately determine what type that really is. The tells the compiler to increment both of those variables each time the loop iterates. 

This is largely not pleasant to read. You have hungarian (IIRC) notation, and you have everything aligned funky, and it's just visually unpleasant. Let's fix that: 

You can't bork a string name this way (you can, but you don't need to). You can just say to get it. Awesome! It also means if you want to change a setting value from the default you can just grab and manipulate the . Excellent! This obviously creates the problem of all values being a string. So I have an extension for that: 

A works here, and it's functional, but it does come with some drawbacks in this case. If you and I both submit the request at the same time, one of them will be delayed even though there wasn't actually a reason. Now you've introduced a potentially hazardous situation, what happens if a lot of distinct persons submit requests at once? The best option here, is to block only those who violated the key sanity. The easiest way to do this is actually to the appropriate exception. There's a nice question about this on Stack Overflow, which I would like to borrow some information from: Duplicate key exception from Entity Framework? 

You don't handle input errors well (or at all, but that's alright, you are a beginner) so I'm going to take this moment to shamelessly promote a class I wrote which can help you with a great deal of ease here. You should consider grabbing all the files in this folder on GitHub and using the to handle your input. It's extremely simple to use, just create an instance of and call on it. You'll also need to grab the and at the very least the from this other folder on GitHub. (Or remove all references to , but that's much more difficult.) I've linked to both of these as of the most current version of the writing, just in case I make any changes after this answer is published. 

We're going to put this before our statement, since C# and EF behave in a very predictable way. If there is no record matching the ID, will be null. We're going to modify our to account for that. 

If you are going to prefix one field name with an underscore, you should prefix all field names with underscores. I.e. refactor to . 

Currently working on improving the form building, but it's still pretty easy. So, realistically, it's not a lot of work to make this happen. If you don't use the version (which requires ), you can set in to , and then links and URL's will generate from the class without the bit, and will be a regular URL (). You can comment on everything except the quoted blocks, those are just examples of usage. 

Just change . Once we do this we'll see that on we get a failed result. No big deal, we just need to make sure we fix our method. (Easy fix too.) Our bug is the offset, on Sunday you'll get Monday-Sunday for the upcoming week. (So on 7 Aug 2016 you get 8 Aug 2016 - 14 Aug 2016.) That's fine, to fix it we'll just check if and if so we'll subtract from it. 

Comments on 'Magic Values' You should also consider specifying what some of the floating values are set in the manner they are for via comments. I.e. on the line it would not hurt to add a comment indicating why the of the is . This is merely to help remind yourself in the future for if (when) you come back to the code. Hardcoded 'Magic Values' You should also consider adding a custom property that defaults to to remove those hard-coded values. This will also increase extensibility and reuse-ability greatly for the future. (We want to reuse this class in another programme, don't we?) You could then write an extension method to add two rectangles together or similar. This bit is up to you, but it could definitely ease maintainability and reuse-ability. Field Naming I also, personally, would not name the field . Generally speaking, fields should be the camelCase variant of the property they back ( in your case). Though, personally, I don't use that idea, and instead I use the backing field name as equivalent to the property name but prefixed with an underscore ( in your case). Both these options are open, and generally increase meaningfulness. 

So you should get the point, go through the ASCII spec line-by-line and put a line for each record in the spec, then a label for each of those lines. For the ones you don't wish to implement yet, simply have a label or label that ignores the input. Once that's done we now know how to implement EBCDIC, just build an EBCDIC jump table. What you might not realize is that having 128 (because eventually you want to support all codes/keys, right?) statements will cause negative performance because is compared up to 128 times for each key press, that's a lot. So we build a jump table that might be more work to implement initially, but in the end we'll end up with a much easier to maintain setup, and performance will not degrade. When we call , it jumps to the label, then to the line identified by . Easy stuff. 

Please do us all a favour and format your code more appropriately. C# does not use Egyptian braces (at least, not by any best-practices). (Java and JAVA do, but this is neither Java nor JAVA.) 

And not even at any conventions, but at what does and doesn't make sense. You have a inside the ...that's fishy, really fishy. The great thing about Razor, MVC and C# is that you don't need to do that. I can see why you're doing it, but we're going to remove the from that and rename it to . 

You're using the stack backwards. Not only that, but it's not a true stack. (Which is fine, we'll talk about that now.) A true stack cannot have elements directly modified. In a stack there's no sense of an "index", elements go in the top and come out the top. With that said, the easiest way to fix that is to rename this from to . (Now the name is more meaningful - first-in-last-out list.) It's far more performant to insert items at the end and then remove them from the end. 

Whether or not you want to actually use LINQ is up to you, but I'll give you a nice example that you can try to apply more generally: 

Now the only part we need post-loop is , so we'll deal with it last because it's more complicated (but barely). In regard to , there are two things I need to make blatantly clear: 

I don't know how WorkflowInvoker works, but I assume that it has the capability of throwing an exception, which means that your line would not be reached, and I wonder what other issues that might cause for your application. (Looking for operations that aren't there, for example.) I would consider a / block, or decrement before your operation gets invoked. (You can probably consider "In Progress" as a non-outstanding operation.) The other issue I see with your Lambda method is regarding the idea of "closures", and captured variables. In .NET the and variables are still part of the local method and are simply referring to the local copy, which means if you modify either variable after queuing up the worker, you could end up with a different result. This may not be an issue with your infrastructure, but I feel it's worth pointing out none-the-less. 

So your threw me off, initially I thought this class was doing something, but it was doing something else (not your fault, totally mine). Here's how I would handle this: 

First and foremost: testing in Debug - Any CPU mode is bad. Debug configurations have a lot of extra overhead and Any CPU is a non-native instruction configuration*, both will cause you to get poor measurements. Next, when you do your testing you should consider (I say consider because when doing simple comparisons you don't need to, but when trying to prove something you should definitely do so) using a proper benchmark tool like BenchmarkDotNet. (It's in NuGet so it's simple to install.) However, if you choose not to (I'm not going to judge you for that) you should not measure the first execution of your code. You should loop it a few times (I usually use 10-128, depending on how fast the code is) and then discard those results, then do it again and keep those results. Take the average as your metric. Why? The first time you execute your code, the JITter (Just-In Time optimizer) will optimize your code another time. This adds a substantial amount of overhead to the first execution. Sometimes a lot of it. This can (and will) skew your results substantially. * This is heavily debated and may or may not have any effect. In some testing in my environment x64 is faster, and in some testing Any CPU is faster. 

Your code doesn't look too bad, you should fix your whitespace though. Generally a maximum of one line where it's necessary. 

Before I write the tail-call recursive example, I want to go over some issues I see with how you do things. Your and can be far improved, and you can stop relying on that exception to fix your up in : 

Your SQL should be parameterized queries instead. As it stands you are very open to SQL injection. (What would happen if I specified a of ? Not good things, I suggest.) Usually I tend to favour immutability over mutability. 

This means you won't change if there's nothing to change, and you won't notify that has changed (because nothing changed). This also means the following method will simplify: 

Output information regarding programme definition to user; Accept and process user input; Call appropriate method(s) based on user input; 

The nice thing about this, is that you can override the and methods within the sub-classes of , to do other things specific to that item. The problem with this implementation method is that it could be a bit difficult to separate out the strings. Having multiple methods like this that all rely on the same string is less-than-ideal. There are surely other ways to do this which are more effective, but this is what I could come up with fairly quickly. 

This is code that's part of a library (closed source) that I have that generates a unique value for Twitter OAuth. Essentially, it generates a random number, combines it in string form with an string separated by a pipe, computes a Sha-1 hash, and then repeats the process if the Sha-1 hash (when converted to Base64) contained any non-alpha-numeric characters, which are subsequently stripped. 

All three of these have the same response: Properties exist to allow is to idiomatically access information within them. By not using/creating properties, you fall into the trap of having to remember just exactly what the operation means. So, for: 

Obviously this bit is easy, but then you should have a method (or for ease-of-use a constructor) in it: 

Disclaimer: I wrote this entire answer with no testing in the IDE, the code may not be 100% correct, if not, please let me know and I'll try to correct it. 

Of course that's huge and does a lot of stuff. We obviously want to break it down. So we'll extract our to use some methods, function composition, etc. It's still long, but it's slightly more maintainable. 

Also: I apologize if anything came off harsh, I mean no rudeness I just happen to be really tired (reviewing at 01:45AM may not be a good idea) and I think this is a very good start. Hopefully you explore more with C# and become a great programmer in it! :) 

This is the exact same as specifying a read-only field that backs the property, and initializing that field. The difference is that you no longer need to explicitly initialize the field (in the constructor). This works exactly the same as a read-only field backed -only property. (I know, that's a mouthful.) You can also use the null method-invocation syntax. 

Now, you might say "why would I want to write a sequence generator for an array?" Consider you have a huge array: 

This reminds me of the C/C++ days and when I did DirectX programming. Every single method had the parameters listed out like this because we didn't have the powerful Intellisense then, and it was easy to lay them out in headers like this to allow us to reference easily. But it's 2017, and this is C#, we don't need to lay things out like this, it should be a red flag that we're doing something wrong. And what may be that 'wrong' thing? We're not encapsulating our data. The fact that we have three variables with a suffix of or tells us that we could encapsulate those and save ourselves several parameters, since they're co-dependent. 

Essentially, I'm not convinced that the , , and properties should be, erm, well, properties. I'm curious, especially, on feedback regarding that. Otherwise, pick away. All constructive comments/critique welcome. 

I would consider changing the name from to something like . It doesn't matter how it does it, only that it calculates statistics of the data we're working with. 

This allows you to break responsibilities away, and if in the future you wish to log messages directly to the Event Log instead, this allows you to make a class: