Since that is tedious, error-prone, and unmaintanable. You want to make the compiler do this for you.You can start with reading about automatic prerequisites, but rather than follow the guidelines there, note that gcc can both build the files and generate the files concurrently with (check out all the arguments). Targets and should be targets. I also like to get in the habit of setting instead of just making sure that is at the top. You never know. Comments Very helpful for the most part. But I would omit these: 

Find the slot Your loop is all about finding the slot where the is at. The body of that loop isn't really a loop, it's a -type algorithm. So let's rewrite it like one: 

Single Responsibility Principle should do one thing: get the player's choice. It does three things: gets the player's choice, picks a choice for the computer, and then plays. If we just drop the other two, we'd get down to: 

And we no longer have name pollution with cryptic names. is a lot easier to understand than . Goto At a first approximation, never use . It makes it more or less impossible to follow code. Without , you also don't need labels. Instead, just call different functions. Or keep an internal state machine. Or really any possible other solution. Code with like this is incredibly brittle - what if you want to add more states somewhere in between? Good luck keeping track of everything. Use Enumerations Right now, you have ten s for race. But only one of those is ever going to be on, and that might prove difficult to ensure long-term. Prefer to instead use an enumeration: 

isVertex() What you wrote is an antipattern. Anytime you want to check if an expression is true or false, you want to simply do: 

is not going to make you a lot of friends. If you want to check multiple conditions, use the logical and operator: 

A way to iterate from to A way to take the and of lots of things at compile time A way to add one to a type 

It'd be easier to separate this into two parts. First, we can do all the word transformations using and a single word switcher: 

That way, our path is local rather than global. Then we just walk the rest of the words as you're doing: 

Severe code readability issues Honestly, your code is extremely difficult to follow and I gave up. The most important part about code is readability. Readable code is easier to reason about, easier to maintain, easier to debug, and, especially relevant here, easier to get other people's opinions on. I would very much like to give you advice on how to improve your functions - but I can't. I have no idea what they're doing now. They're simply inscrutable. It also isn't enough that you understand what this code does right now. What if you need to go back to this code in a week? In 3 months? In a year? Will you remember what it does then? Even well-commented code with good names sometimes becomes hard to understand once you forget the context of when it was written. Poorly named, uncommented code is just setting yourself up for lots of confusion and frustration. At best. I cannot stress this enough. Read up on the python style guide, especially for its conventions for naming and comments. 

I'll leave as an exercise to the reader, but note that it needs to follow this signature and should not use any global variables: 

Your code is fine. I don't know what you're so worried about. But there's just some unnecessary stuff. For example: 

We can start at for , since every lower multiple of we already know isn't prime (because it's a multiple of some other number smaller than and we've already done those). With that, our function in its entirety is: 

And this way, you can store the results somewhere else for further analysis later. Avoid : The less weird hops your loops make, the easier it is to follow along the logic. Right now you have: 

You'll note that I changed your variable from to . is a terrible variable name as it's very easy to mistake for . So easy to mistake that you probably didn't notice that I wrote one the first time and el the second time. 

That's the full signature you need. In the OP example, scores the first go will be so this should return , indicating that that is the loser. You don't need a variable - what if we were doing this for all of Australia and each candidate had over 5,000 votes! Your code would break. In fact, that's likely the source of your bug. The algorithm here is simple: for each score, if either we have no losers or this score matches the losers' scores, append it. Otherwise, if the score is worse than the losers' scores, replace the losers with this one. This also has the added benefit of not needing to main a separate losers structure that you need to remember to clear. Also you may find it helpful to remove all instances of votes for a loser whenever you drop one. For instance, our rankings initially started as: 

Whenever your code adds to a Group, it always adds the next element to the back. And we always go in order. So your structure actually guarantees that each group is always sorted. Thus: 

So let's avoid that check. Let's structure our loop such that we're back-comparing. That is, instead of comparing index to index , we compare index to index . That way, if we start at 1, we'll always have a valid comparison - since otherwise our loop invariant would've triggered: 

Of course this is trading readability (your original code is very easy to understand, verify correctness of, etc.) for what is likely to be a very marginal gain in performance. But hey, sometimes that matters... 

Memoization Now, you're kind of memoizing, but then not really, since the first thing you do is wipe . If should definitely start with: 

Refactor when you need to, otherwise you're just overengineering everything. Should the be an argument? What if we need at least 2 to match the func instead of 1? There's so many arbitrary other features we could add - so let's worry about those only when they need to. 

In addition to the double free, you get the other issue in that the user might expect a deep copy but actually is basically just a Java-style reference to . Fixing this is an absolute must. Resizing This is definitely non-functional. You delete your member , then, separately from that, you create a locally scoped array that you write stuff into. At the end of , the object will have a deleted local array! The correct way to is to allocate a new array (only have to do one!) of double the size, to copy/move from your member into the new array, and then simply change your member to point to the new array. This should be one allocation (of the doubled array) and one deletion (of the old array). Off-by-one The first writes into . What goes into ? 

What is actually? What is this class supposed to represent? It has a for the individual test grades, which leads me to believe that based on your example, we might have one for containing and another for , etc. But then you also have a for the students. So it's unclear what the usage of this class is. It's trying to do too many things - that's bad design. This is made all the more confusing by which alters the contents of to be something else entirely. You also have issues with integer division - you have no way of being able to print since nothing is ever a or . A better design would be to separate your concerns. Have a class that is an individual student. A student has a and some (don't keep reusing the word "grades" to mean different things): 

Unique or Shared Why as a design choice over ? The latter would let you be able to take shallow copies to your lists without having to have references everywhere. I'm not saying that is strictly better, more than it's something worth considering if you have not already. Either way, both are strictly better than raw pointers, so you're already on the right track. 

I like the idea, but your condition is overly restrictive. What if I want to construct an from a ? Or even from a ? There's isn't anything about that operation that's fundamentally unsound. So instead of requiring the same and that we're only constructing from iterators, prefer any reasonable iterator: 

Your assignment operator is misleading. First, it is not the copy assignment operator (that one will be defaulted by the compiler, since the copy assignment operator is never a template). And why do you want to support assignment from arbitrary other zippers anyway? Is that ever going to be viable? Let's just default it: 

Now we just need the number of stars. It starts at for the first lines, then we get one line of stars (for odd stars), and then we go back down the pyramid. As a first go, we can just split it in 3: 

And for the rest, we just have to check the return of every time. Note that there's no reason to copy the full list of every time! That's expensive. You can just append to the end before the call to solve and pop afterwards: 

Excessive Comments Comments are good, and many of course comments are quite valuable. Some are completely unnecessary though. Clearly the default constructor for should construct a new empty scene, and the destructor destroys it, and so forth. When you're writing comments, ask yourself if somebody reading your code actually needs the comment. Another example: 

You'll note that is , which makes more sense for centimeters than . Use integral types You'll notice I used instead of or . Prefer using integers whenever possible to simply sidestep the issue of floating point arithmetic altogether. 

Why an inherited class? I don't see anything about this problem that requires an inherited class. could just as easily be a free function: 

First of all, let's not beat around the bush. Clearly your filenames should be Brainfuck.hpp and Brainfuck.cpp. Let's not be shy. Now for the real reviews: Input 

After all, your design is about adding data members. That's something that you probably don't want to expose to the outside world. Secondly, what happens if you want to potentially have multiple different members of the same type? That's definitely going to come up and so should be supported. In order to do that, you might want to add some kind of to differentiate them and then additionally wrap the non-empty case. That is: 

In addition to not really being a hash table, you're seemingly limiting the possible valid keys to exclude something like or or whatever the value of is. May be worth separating the key from the empty concept. 

That looks mostly right to me. I'll suggest two things. First, there is nice syntatic sugar for defining functions: 

That should yell antipattern to you. You're not holding pointers to existing objects, this is actually owning that memory. You use to add to it. I don't see any s. So you're leaking memory. Doesn't matter so much in this case, but this is exactly what RAII is for. Prefer: