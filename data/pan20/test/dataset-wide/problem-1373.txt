You are right in the concern about the concurrent access to FileWriter if only because you rely on this class to be thread safe. a quick google showed me this and it seems (on the surface) that this is not correct assumption. I would design This differently, although I do not know if the new design is faster: I would have the tasks only do the url look up. This is based on the assumption that this is the bottleneck in the whole process (seems reasonable to me...) So each task gets a url from the queue, does the lookup, gets the response string, parse into xml doc and put that into a separate xml-response-queue. the main method is responsible for listening to the xml-response-queue, doing the file writing and populating the url queue with child links. 

taking the classic OO approach, Let's look at the data classes and the relations between them: : properties: , has list of favorite s. can browse the list, and add/remove a from the list. This relation is represented as has list of rented ies. Each rental is valid for a time period. can browse the list, and add/remove a from the list (rent/return Book) This relation is represented as (it is possible for a user to rent multiple copies of the same book. book copy is identified by copy-id) class is responsible for maintaining favorites and rentals. operations: will return true/false if operation succeeded will return true/false if operation succeeded will return true/false if operation succeeded will return true/false if operation succeeded 

holds list of s holds list of s is able to identify by its or + This relation is represented as and is helper class that holds + and is implements is able to identify by its or (putting aside for the moment that multiple users can have the same name) This relation is represented as and class is responsible for maintaining lists of s and s. that includes adding and removing items fron those lists (maintaining the maps) so here is the flow of renting a book: 

You make yourself vulnerable to typos. what if you mistyped an option in one of the places? you will only discover this at run time. What if you want to "insert" or remove a choice in the middle of the list and as a result need to assign new values to the other choices? The literal value gives no clue to the logical meaning so you are forced to keep going back to the to remind yourself of the meaning of a certain choice 

in Jackson, you have the mixin feature. This allows to add or override annotations at run time. so we have one target POJO 

properties: , may be rented to one for a time period. This relation is represented as and , class is responsible for maintaining its own rental status. it should be able to answer if it is available for rental for given period 

There is one problem that I see with your API and that is that the columns are referred by an int index instead of by name. Not only you have to remember the (arbitrary) position of the columns, but think what if you add or remove a column from one of your tables? considering that already holds a list of the column names (and does nothing with it except print it) it is trivial to change to receive a column name (or at the very least add an overloaded version). My next point is not an exact "Code Review" answer, However, I believe this is a "trying to invent the wheel" case. What you did here was develop a kind of an ORM (Object relational mapping) library that maps DB tables to of s. There is a small Apache library that does exactly that : Apache Commons DbUtils You can still have a class for the purpose of the type-safe 

there seems to be logical falacy: what if returns false but no exception is thrown? there is no else clause there, and would return no virus found. instead of returning , why doesn't re-throw the exception? that way, it can also return a String of a virus name (or whatever is produced from ) instead of passing the String, make it public. then any class can refer to it as better still, make an enum out of the constant. that way, you can add values to the enum (like ...) 

this way, a string that is longer than 1 letter will pass the condition without any examination of contents. 

those variables: not only do they seem redundant, they actually breach thread safety. variables are used when you actually want the variable to be accessed by multiple threads (for example, when you want one thread to set a boolean and then have another read that variable). as far as I could detect, the two variables can be replaced by local ones. those calls: they are mostly redundant. the method is only useful if a client thread has called . that is usually the case if the queue is empty and a client wants to block until a new item has ben added. if the list is not empty, the client usually pops an item and goes about processing it. so you need to understand when clients will want to wait for an event to happen and get notified about it. Secondly, calling only makes sense if you release the lock immediately after the notification. calling in a loop without releasing the lock will not do anything. as an exercise, this solution will work. However, it is not efficient. synchronizing all the methods mean that any access to the queue will prevent all other access. for example, if one thread calls it has locked the entire queue. you may think that is such a small method, but what if the thread just entered the wethod and got a context switch from the OS. it can wait for 2-3 milliseconds before releasing the lock (and that is a long time in the computation universe). so in order to be more efficient, you need better granularity on the scope of the locking. For example, set a boolean if the queue is in the process of being modified and only at these times lock the reading methods. and you can get more efficient with more sophisticated (and complex) mechanisms (like locking only part of the queue this is being modified etc) ALL_CAPITAL names in Java (and other languages), are used for constant variables, not for those that hold state. (i.e. recevied from arguments). even if they are immutable. 

I do not understand why you have and variables. they seem to serve the same purpose of variables in the super class. You do realize that s does not override s ? 

So If I understand correctly, clients get an instance of from the factory, call and get an instance of and then call and get an exception (or nothing). so you replaced an block with a one. the client still have to check the return value to figure out what to fix. and if you ask me, it is more clear to ask 

and there you have it: the enum and its counting implementation in one line. This will not always work. For example, with you need to keep state between invocations so you still need an instance of custom class. 

Regarding complexity, I admit this is not my expertise. However, I do not see any signs of exponential iteration on the data structure. Your algorithm may improve upon the performance of classic bubble sort, but complexity is about scaling: comparing the performance of the same algorithm on input that is increasing in size. I'd say complexity here is the same as classic bubble sort, which is O(n^2) Note: a more robust and extensible design will say that you need to decouple the data structure from the sorting algorithm (much like the Java Collections framework) so that you can apply your improved algorithm not only to array of integers. But I think that is an "advanced" topic that requires deeper study of advanced OO principles. 

This representation is both clear, concise and is portable (can be passed to another program, web service, stored in DB etc) So welcome to the wonderful world of Object serialization/deserialization. There are many libraries and documentation/tutorials on the subject. I will point you to Jackson Json parser that is considered one of the most popular. 

here are my comments: 1) instead of having a method for objects, why not have classes that you can instantiate? seems more clear to me 

The design needs overhaul. Specifically, the design of the class (and concept) Skills have properties and behaviors (=methods) that are related to the skill regardless of the caster. for example, each skill can be either casted on an enemy or on the caster himself. each skill has base power and mana consumption values, etc. Your code needs to clearly represent the properties and behaviors that define a skill regardless of the caster. You have in your game four types of Skills. if you have a finite set of values of the same type, the best way to represent this is using . So, if we make class an and remove the reference to , the design reflects the concept of Skill in the best way. For instance, initial values for the different skills are no longer defined in , but in , the "name" property is redundant and I found a new attribute that is related to this type: 

The majority of the code deals with creating (many) instances of with the correct data. As you observed, this creates code that is is both long, obscure and error prone. Data is best represented as text in a in text file and then all that is needed is to load the file into memory and parse the text into the list of instances. You do not need to invent the wheel: There are several established text formats that can represent the data, and there are libraries that will do the reading, parsing and even create the instances for you. In software engineering, this is called Object deserialization . The two most popular text formats today are XML and JSON. JSON is more compact and supports data types other than text. So we can design the JSON representation of a object like this: 

so we see that the method is responsible for quite a lot of processing. This has several issues, the most obvious one is breach of the Single responsibility principle. There are other issues here that need addressing: 

First of all i have a question: How do you know that all the days that have same count also have same colors? For example, day #1 has 3 events from Dept #1, #2, #3, day #2 also has 3 events from Dept #1, #2, #4 so there are 4 colors from two days? Anyway, looking at the processing that you have, this is how I would do it: 

According to the numbers you provide, it just might be that you are trying to hold too mauch data in memory. Perhaps you need to persist the queue. There are many solutions for persisting a queue. Simply googling "java persistent queue" will give you many options. Another popular solution is to use some no-sql database as replacement for the queue. why no-sql and not rdbms? no-sql is better suited for high load apps and scales better with workload 

here is what I did: I focused on the statements since it seems they are almost identical. it turns out they differ in one letter in the resource name. So it makes sense to create a method that recevies this letter. There is also duplication in the clauses, so I replaced the with an that separates clause from the rest: 

Regarding reducing duplicated lines, I can offer that you make a method to create the map. so if the contents of the map need to be modified due to modifications in the requirements or API, there will be only one place to modify them. creating constant variables instead of embedded literals is also considered best practice. This can apply to other literals used in the code 

According to this, is a costly operation, which makes sense since the format has to be parsed (each time it is called). I would seek the help of some libraries like Apache StringUtils or Guava to do the necessary padding and then replace format with concatanation. Also, I did not analyze the code, but if the big list can be split and parallel processing applied to it (perhaps using fork-join DP) then that would provide a big boost 

then, instead of returning the exception message, throw the custom exception. the return value is freed to return more rich data from the scan (if possible): 

I believe what you describe fits the producer-consumer pattern: A player who wishes to be matched is a consumer of another player from the lobby. when players join the lobby, it should produce them to consumers. Therefore I think a better data structure for your requirements is . The most advantageous feature is the blocking of consumers. this eliminates the need for the timer. you can have consumer wait forever for an item (another player) or have it timeout after a certain time. regarding rank, you can still use a with rank as key, and the queue as value. which brings up the question: in its current definition, the can hold only one game per rank? However, as long as the solution is confined within one JVM, you will have a scalability concern. To fix that, you will need to externalize the queue and use a messaging system (like RabbitMQ) and then rank becomes a topic where consumer register for. This is a much more complex solution but it has the potential to grow to social-network scale. One more comment regarding readability: 

remains too obscure because it is hard to see where the plus sign is among all the other punctuation symbols. one way to solve this is by breaking the line according to the plus signs. However, if we look at the "big picture", what you have here is a template of an SQL statement where you want to embed table and columns names. embedding values in String is the expertise of style formatting: 

I figured out a solution that improves on time complexity: So here's the thing: the solution is actually a rearrangement of the matrix, meaning O(r^2) should be possible: visit each cell of the matrix once, determinig its location in the solution. and it's straightforward: find the heads of the anti-diagonals, and for each one, find all its members. finding the heads: iterate over the first row, then (when you reached end of row) iterate over the last column. for each cell in above mentioned iteration, start gathering anti-diagonal members by advancing one row down, one column left, until either one goes beyond matrix' bounds. few notes on the posted code: 

So now, instead of individual variables, a has a of instances. (this means that instances should be considered equal if they have same ) This design allows for iteration over the skill set of one and of course, different s can easily have different skill sets. Moving on: as I understand it, the formula for the effect of skill casting involves the base value of the skill, related to the skill only, the power of the being, related to the being only, and the level of player in that skill. Perhaps in later version you will want to add defensive skills? also, in some RPG games, a random factor is added so that every skill casting can vary in effect. I would say that this complex logic merits its own that receives two s (attacker and target) and the skill that was chosen. If the is an interface, you could write different engines that evolve in complexity. the engine would apply all the above factors (including if the skill is casted on self....) and modify the s stats according to the outcome. 

here is my suggestion, regarding the if conditions: should be replaced with it looks technically the same. but there are two reasons to prefer the replacement: 

count occurrences for each day: create a that holds as key and of colors as value. the size of the list shows how many times the day appeared in the input. after iteration on input is complete we have the required information per day. now we iterate over the map entries and build the collections per count. instead of array of ints I would create a in order to collapse duplicate colors. 

this calculator is not very useful for the user since it cannot take any user input. test data, as well as "real" user input, should come as run time input. this may be from the command line, from an API call or from some kind of UI. havong the input specified at run time will allow you to modify the test data without need for recompile. if is applicable only for division, then perhaps the operator needs to determine which s to apply? another approach can be that each can say whether it is applicable for a given calculation? so I believe the order of validation procesing should be: first parse the String expression into an instance that holds operand/s and operator/s (that can perhaps be defined as enum?). then apply further "mathematical" validation. there should be a clear separation between the validation and calculation steps. This will make things clearer and also allow for modifications to one step without affecting the other. you should consider having the validators throw a custom exception. this is a perfect fit for that mechanism. Java even have some predefined exceptions that you cen reuse like and . the benefit of throwing java predefined exceptions is that they already have documentation and users of the calculator will be able to know what went wrong. other areas for separation of concerns can be output production, validator instantiation, etc.