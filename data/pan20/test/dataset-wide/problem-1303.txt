If it's faster to avoid computing a substring in your replacement, you might think of doing the same thing when you're finding the suffixes in the first place. In other words, instead of calculating all the suffixes of a string in , just make a list of tuples to represent the suffixes. Then whenever you need to actually compare two suffixes, instead of taking a substring of the original string, you just start comparing characters at the required indices. There are two problems with this in practice: first, Python isn't well suited to iterating from an arbitrary point in the middle of a string. In a language like C, where strings are character pointers, this would work out quite well, because you can jump into the middle of the string by advancing a pointer. But in Python, iterating from the middle of a string requires you to either start from the beginning and just skip the first several characters, or bypass the whole iteration mechanism and use a loop with an integer index to access characters inside the string by their indices (which typically involves more Python code that is relatively inefficient). And besides, the other reason is you need to create the substrings anyway to sort them. If you try to do it so that you use the substrings as comparison keys without actually storing them, the program spends a lot of time converting between a substring and its index. 

General comments Your code is pretty clean, but it's unclear what you imagine it being used for, except possibly just to illustrate adjacency lists. If you're looking to build something actually useful, then I suggest coming up with a few model applications, and thinking about what you need to provide to serve those applications efficiently and easily. For example, how would you model a shortest-path problem with your graph, and how would you implement Dijkstra's algorithm to solve that problem? Or how would you compute (and represent) a minimal spanning tree? graph.h As to specifics, I'll start with your API definition, as presented in the header file: 

See also below. Flawed implementation Your code can easily be made to overrun the bounds of the array. In fact, that will happen if the number of usable key characters is smaller than the number of letters in the message. To (partially) fix this, you need to wrap around the end of the key inside the loop, rather than at the end of the loop where you now do that. That will, however, expose another flaw in your implementation: it does not handle the case where there are zero usable key characters. Your current implementation will just immediately run off the end of the array in that case; after the fix, it will loop infinitely. See below for a suggestion that will help. Error handling does a decent job of noticing when memory allocation fails or nothing is read from the input. It helpfully returns in those cases. , however, ignores those signals and unconditionally passes the result to . For its part, assumes that its argument is always valid. Either 's behavior or 's could be ok in isolation, but together they constitute a flaw producing undefined behavior under some circumstances. Similarly, returns in some failure conditions, but pays no attention, assuming that the return value is a valid pointer, in attempting to print it. Implementation improvement If you have (which is standardized by POSIX, not C itself) then it is a convenient alternative to + + . calls before prompting for the encoding key. This is useless. Move the flush after the prompt, or remove it altogether. Since the prompt ends with a newline, it is probably unnecessary to flush even after printing the prompt. I remarked above on problems with your key handling. I observe also that you handle your key inefficiently if it is short relative to the phrase to encode. You shouldn't need to check on each pass through the key which characters are usable. You shouldn't need to account for upper- vs. lowercase on each pass, either, if indeed you make them behave the same way. Instead, process the key once, before the encoding loop: remove characters other than letters, and convert all the letters to a standard case. Then it's also easy to validate result to ensure that there is at least one (or two, or whatever) key characters. It doesn't make sense to me that your encoding code is not parallel for upper- and lowercase key characters. The code for uppercase keys looks equally applicable to lowercase keys except the computation of , but you use a more complicated and difficult to follow scheme for lowercase key characters. Indeed, one of the alternatives for lowercase keys cannot even be exercised, because and cannot be true at the same time. Design improvement Your function modifies the input string in-place, but also returns a pointer to it. On the other hand, the function's name suggests that it will create a new phrase. I suggest changing that function's signature to 

For complicated sequences of code, you have to make a subjective judgement about where to use variables and where not to in order to make the code as clear as possible. But in this case, I think most programmers would agree that the variables are fairly unnecessary. Let output formatting be controlled by the formatting routines Evaluating an RPN expression doesn't include formatting - in particular, deciding whether the result is an integer or not is a separate task from just getting the result in the first place. So at the end of , just return a . When you print it, instead of you can do 

If you think about it, you don't even really need the common prefix itself, except for the one string you actually return from . You only need its length, so you can decide which substring is the longest. So instead of using a function that finds the full common prefix, just write one that will give you its length. You store the length, along with one of the strings, and at the end of , use the length to trim the stored string. 

tim's answer covers the most important issues, but I would like to put a bit more emphasis. First of all you mastered the first step towards secure code. You obviously know that you need to sanitize user input, that is already very good. Input sanitation However, while your code may not have sanitation issues right now, it probably will not be once you extend/modify it. Arbitrarily throwing sanitation methods at input is not the solution. The solution is to use clean abstraction interfaces for output (e.g. template system) and database (e.g. prepared statements) and sanitize at the input to the abstraction. This way it is more feasible to actually get it right for non-trivial sites. Randomness / hash is not suitable for security-related randomness. This, and suggested alternatives, are also documented. Note: It seems the alternatives suggested by the php manual are not easily available... [insert php rant here]. The arbitrary restriction to ~30 bits (1,000,000,000) is certainly not helpful. There is also no reason to hash this value here, and most certainly not by chaining two weak hash functions. Remember that hash functions map arbitrary size data to fixed size. They do not generate entropy. You can use a hash function if you have non-alphanumeric random data. So lets say you generate a random token of sufficient entropy (30 bites are NOT!) and send that token to the user. Then you can store the hash of the token in the database. This way, when an attacker obtains a database dump somehow, he cannot reset passwords. This works the same way as with passwords, although its more important to apply it to passwords. You can use . Protect against phishing Emails with links are in general problematic, as both links (what is shown to the user vs. where the link goes to) and emails (sender address) can be easily manipulated. If you send an email to the user, especially when it contains a link to click on, it is customary to personally address him by name. This is at least some assurance, that it is not a phishing mail. It is of course not perfect as the name can often be devised from the email address. An alternative to sending a link, is to send only the token (in your case hash) by mail and redirect the user to a form where he can enter the token directly after he requests the email. Code structure As Tim mentioned, your code structure should be improved for clarity. This also has security impact. SQL efficiency If you do not intend to use the result of an SQL row, don't it, but instead. Use example.com The domain is reserved for this very use. Use it instead of a domain that is actually owned and used (domain.com). 

Evaluating This new function is going to do mostly the same thing as your function currently does, except that instead of prompting using , it will take a string argument, and instead of printing the result, it will it. Let me pick on a few things in that function, though. Let the stack just be a stack 

I leave it to you to figure out the best way to put / blocks around this code. Actually, the way I've done it here has a problem dealing with the case where is zero (this would happen if you include constants or zero-argument functions in the list of operators). To get around that, you can use the following: 

I'm not quite sure what you're asking for, but I was bored so I typed this up anyway. Hopefully it helps. ;-) Working from the outside in: Invocation 

At this point, you can spend a lot of time making little tweaks to try to squeeze some extra performance out of the program, but I don't think there are any major performance gains left. It's already something like 40% faster than the original, which is not bad. Of course, as dawg wrote in a comment, you can accomplish this task using Python's standard module . 

Your code exhibits some inconsistency about whether binary operators are separated from their operands by spaces, sometimes even within the same expression. I find code much easier to read when there are spaces around such operators, but if you choose not to place such spaces then at least be consistent about it. Personally, I prefer also to see space between keywords and parentheses (, , , etc.), but not between functions' names and the parentheses around their arguments. That's a bit easier for me to read and parse, but it is of little significance as long as you're consistent. 

I take you to mean that you want to tokenize a language similar to the one recognized by the standard POSIX shell (since you tagged [posix] and presented an example), or maybe even that exact language. You posited in comments that perhaps you needed a parser generator such as or for this job. Although these tools can indeed do such a job, code for such a subsystem -- a "lexical analyzer" or "scanner" -- is more often generated via a different kind of code generator; and its GNU variant are the canonical tools for this purpose. These two particular tools allow you to describe your tokens (and separators) via regular expressions, and from such descriptions they generate C code for a table-based DFA that processes the language character by character and splits it into tokens. This is certainly one plausible way you could proceed. On the other hand, depending on the language you want to recognize, it's not necessarily unreasonable to write your own lexical analyzer from scratch, or in favorable cases to use an available function such as to do the job. This affords the possibility of a better-tuned implementation than can be produced via a general-purpose tool (or not), it does not incorporate an additional language into the project, and the source might even be smaller. You ask, 

Do tokenization the easy way Your input strings consist of tokens (numbers, operators, functions) separated by whitespace, right? There's a built-in method to split a whitespace-separated string: . You don't need to bother with a buffer, or with iterating through the string's characters. 

All told, the changes you need to make to the code to use indices everywhere wind up hurting, not helping. Here's the timing result: 

I have no idea what's in the code (well, I could look, but I'll leave that as an exercise), but it's clearly heavily optimized for this kind of task. It's another 25% faster than my best version of your program: 

Iterating over pairs of consecutive elements is a common task that has a fairly standard recipe, , given in the documentation for the itertools module. You can use the implementation from the more-itertools package if you want. This also lets you get rid of the / block (which probably didn't affect runtime much, but it helps code clarity). Python has a built-in function, , to find the maximum value of an iterable. If you use it, then the nuts and bolts of the loop as well as the compare-and-store-if-greater process get handled internally by the interpreter, which should be faster than doing them manually in pure Python. Repeatedly accessing an attribute of an object, namely the method , is slower than accessing it once and storing it locally as a new variable. 

exceptions can occur and you will leak memory. This is subtle and difficult to get right. Therefore always* use smart pointers to express ownership, in this case . *: unless absolutely necessary and you know what you are doing. Otherwise follow the advise of Edward which is much more immediate. 

There are already and friends for . Avoid inconsistent state Instead of keeping track if your rng is , seed it in the constructor. Follow standard naming conventions I find some of your names to be too verbose and far away from common naming schemes (stl, boost). Especially . For instance . I would think is just fine. Avoid indirection if you don't need to Why do you manage the by inside ? This has negative performance impact. Use such an indirection only if you need to move the objects around often but cannot cheaply do so. The same argument applies to , but it requires more careful reasoning because the object is more complex. Is it required to often move around es in operations? (I don't think so) Is it expensive to move a object? (Depends on ValueType.) 

... and skip the initialization loop. (Elements not explicitly designated in the initializer get initialized to 0.) Comparative efficiency It's hard to be sure what to compare here. The two codes comprise slightly-different versions of the same underlying algorithm. Implementing fixes for the various shortcomings I discussed would bring them to pretty much the same place, which would look more like the second code than the first. There are a number of possible variations on this approach, some of which may run slightly faster than others, but I don't see room for anything substantially more efficient. 

Your inconsistent and unconventional indentation makes your code harder to read than it should be. Although Java accepts multiple top-level classes in the same file as long as no more than one is public, it is poor form. Every top-level class, interface, and enum should have its own file, whether public or not. Among other things, this makes it much easier to find all the classes, both for you and for the compiler. It is a bit questionable that you're willing to destroy the list in order to test whether it's palindromic, but inasmuch as you are willing to do so, you could perform your palindrome test more efficiently. You would use two primary Node references, one that advances one position for every two that the other advances. Using the trailing reference, you would reverse the front portion of the list as you go, so that when the lead reference finds the end of the list, the trailing reference is at the midpoint, with a reference to the reversed first half already in hand. I'm sure you see how to proceed from there. You could also consider using an auxiliary data structure to build the reverse half-list or an equivalent; in particular, pushing the nodes one by one onto a stack would have a comparable effect. This could be done in a way that does not destroy the original list. Or on the third hand, if you were willing to change to a doubly-linked list, and especially if you were willing to represent the list itself with a separate data structure that contained a reference to the tail in addition to the reference to the head, then the palindrome test could be performed much more simply. You would just start at both ends and work towards the middle. That doesn't modify the list, either. 

In general your reasoning is ok I think it is very valid to try to optimize the time complexity for certain operations if you do not know the size of the structures beforehand. That said, of course it helps to have actual use cases for performance comparisons. Provide the full code It's hard to provide feedback without the actual implementation of your methods. For instance I would think your implementation of is probably inefficient based on your data structures. Improve your documentation 

First: you leak memory. Terribly. Never use unless you know what you are doing. Use smart pointers, or in this case just objects on the stack. The visitor pattern is meant for separating algorithms from an object structure. There is no object structure / composition / hierarchy in your code, so there is no use for the visitor pattern. Following your example, there should be a class with an method, that iteratively calls accept for all elements in the cart. Also the visitor pattern is supposed to prepare for unknown algorithms operating on data structures that should not know about the algorithms. So it does not make sense to use a return value here. If you want to accumulate a prize here, you would have to do it in the state of the visitor. Also: Use consistent spacing between etc. Use consistent capitalization of methods (). Avoid redundant newlines. 

(Note that typical implementations of , like , do not evaluate their operands). That approach will not work for , however, or any other macro that must expand to an expression, because declarations cannot appear inside expressions in C. Error handling Several of your macros afford the opportunity for memory allocation failures. You appear generally to have reasonable handling for those cases, except that there is no mechanism for informing the user that a failure has occurred. A user who delved deeply enough into your implementation could probably figure out per-macro means to check whether each macro succeeded, but the macro set ought to provide a standard mechanism. Perhaps you could provide a member in your dynamic array structures that serves as an error flag, and macros to test and reset it. (Lack of) memory management The code does a decent job (modulo my preceding comments) of managing the memory associated with each dynamic array itself, but it has no provision for managing memory associated with array elements. That becomes important when elements are pointers to dynamically-allocated memory. This might be acceptable, and certainly it leaves your code simpler, but it would be well to at least discuss the topic either in the general documentation or in the documentation of macros that can cause elements to be lost. Specific Comments Don't rely on pragmas Other than a handful of standard ones, pragmas are implementation-specific. Do not rely on them in code you want to be portable; specifically, in this case, use standard guard macros to protect against multiple inclusion, not . is misleadingly named This macro takes a declared dynamic array structure as an argument. It does not create a dynamic array, as its name suggests; instead, it initializes one. Personally, I would name such a macro . should set the pointer to NULL Since does not, in fact, destroy the dynamic array object itself, it should do its best to leave it in a consistent state. That would involve setting its pointer to after freeing it. This leaves it in the same state as would a failed allocation by , but more importantly, it avoids undefined behavior in the event that the dynamic array object continues in use instead of being discarded, for is a valid first argument to , whereas a pointer to space that has been freed is not. You might also consider renaming this macro, since its name doesn't quite fit. No especially appropriate choice of name immediately occurs to me, however. The best I've come up with is ; YMMV. Surprising behavior of will shrink the allocated space if the requested reservation is smaller than the array's current capacity. This is not what I would expect based directly on its name, nor is it analogous to the behavior of . Moreover, it is unclear why you need this, in its current form, in addition to . Macro overkill The and seem a bit overkill to me. Just make it clear (for C types; C++ folks will already know) that the iterator type or each dynamic array is one that is suitable for use with the dereferencing and pre- (and post-)increment operators. While you're at it, there's no need to hide that other standard pointer arithmetic works, too. works only for scalars Because of its reliance on comparing elements to the specified value via the operator, is unsuitable for element types other than arithmetic types and pointers, and for pointers it tests pointer equality, which may not be what is expected or wanted. Consider, for example, if the element type is -- how does a user count based on the contents of C strings to which the elements point? And it's worse for some other element types (structure types, for example), for which expanding this macro produces invalid code. At the very least you need to document these limitations, but it would be nice to have a version that relies on a comparison function. Unneeded reallocation in and These macros reallocate space if the new size is greater than the current size, but they need to do so only if the new size is greater than the current capacity. Problems with printing The given implementation is workable only for certain element types -- mainly C strings and scalar types. It cannot be made to print the members of a structure, for instance, if the element type is a structure type or a pointer to such. If this macro is supposed to provide a general-purpose facility then it probably needs to have a parameter by which an element-printing function is provided.