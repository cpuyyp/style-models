There are a couple of potential "gotchas" in your markup. These things will come back to haunt you (or someone else in the future) when you need to maintain and update the site. Let me explain a little about the Bootstrap grid so that you'll understand why I'm recommending the changes that I am. The grid works with 3 parts: a container, a row and column(s). You already know that, but take a closer look at how and why it works like that: The container, both in the .container and .container-fluid, has 15px of padding. The row negates the container padding with -15px of margin. Columns have 15px of padding, which pull the content away from the edges of the container and create a consistent 30px gutter. The purpose for adding 15px of padding that is only negated by the negative row margins seems silly, but it is essential to allow for nesting columns inside of other columns! Note in the diagram below how the nested columns indicated by the red outline fits neatly into the enclosing column without getting additional padding applied. 

All of these recommendations will result in much cleaner, easier-to-maintain, and more semantic markup. I hope you find some or all of them to be helpful! Much luck to you. 

Oh yeah, and you don't have to worry about it when the nav isn't collapsed, so you don't have to listen for the resize event or anything. 

For this reason, in my mind, it makes more sense to add the additional padding to the body. Then both the container, and container-fluid class work as normal. Also, you can eliminate all of the extra unnecessary container-fluid divs on the page, only one is needed. This will make it a whole a lot easier later if someone else with Bootstrap knowledge needs to work on your site and it will keep the markup to a minimum. The next thing you can do to streamline your markup is remove all of the col-sm-12 classes from all of the places where you have both col-xs-12 and col-sm-12. This is unnecessary. Think of classes as additive. If you want your design to behave the same from one breakpoint to the next you don't need to add a col class for that breakpoint. While you're at it, you can remove some of the extra rows. The only purpose for the row is to break up the content where you need to ensure that the floats are cleared. So, in this case, you can use one row for your main content and just add the row class to your footer tag. In keeping with the some of the key recommendations as the previous post, you should also remove the invalid markup, use the proper semantic tags for headings and style the html selectors instead of adding unneeded classes. So now we're down to what to do about those images. Two things need to happen: 1. At all breakpoints images need to expand beyond the padding and touch the edges of the screen; and 2. If the images are set into columns that don't span the full width of the screen, the far left and far right images need to retain their inside gutter. To accomplish this you can wrap the images in a containing element and give it some negative margin, just like how rows work. In keeping with the mobile first approach, I created three classes: .col-img-full, .col-img-left, .col-img-right, all with margin: 0 -35px; applied. Then I added a media query, to remove the inside margin for just the right and left images with two rules where the left image gets margin-right: 0 and the right image gets margin-left: 0. This makes your design much more flexible! In the event your client/boss/whatever, wants to make a small change and add a third column to the design. No problem and no extra markup or css is needed, just drop your column in the middle with your image and everything still lines up nicely. Okay, finally, let's deal with the navigation. The container-fluid in the middle of your nav was making a mess of things. This is partly why you were getting the scrollbar at the bottom of the screen. Plus, the extra markup was potentially limiting your ability take advantage of some of the core Bootstrap nav features, such as adding navbar-right or navbar-left classes if you want to change up how the elements float. So, I brought everything back to basics and just styled the markup to match how your existing design looked on my screen. I didn't really understand what you meant by "centering the menu" because I see your codepen with the uncollapsed navigation floating left. I made two additional small adjustments to your css for the nav: 1. On my screen the arrows after the links were unaligned. A better way than trying to tweak the padding for those elements from the top and adjust for margins at different resolutions is just to position them absolutely from the bottom. 2. Also, I found that your navigation was breaking onto the next line at certain resolutions, so I added a media query to make sure it stayed put at all resolutions. Here's the final markup: 

then I read that Haskell people prefer to compose functions and then pass the parameter, not doing the forward thing. What do you think about that? Also, I searched over the Internet, and I found some divided code, more like that: 

Explanations: gives you a shifted string. makes the iterator cycle infinitely, remove the first (replace it with for the second part. You the zip the two iterators: one on the string, one on the shifted string. Then you keep the pairs with same numbers: Then you convert each to and you discard the failed conversions. Then you make the sum of all the numbers. If you want to do the two days in one like in your code: 

My question is not only about the algorithm (I think that it is ok, and the problem is not that difficult) but also about the "haskellish" style. Because I am used to Rust/Ocaml/Elm etc., at first I wrote: 

Not sure if my explanation is legit, but when you give a thing to another function, this function can do whatever it wants to this thing: it can take it as mutable or not. That is not anymore the problem of the previous owner. 

This cannot work as-in, because cannot be borrowed twice, but if you rewrite your data structure differently, this could be ok. Do not use Use instead. Be careful about code formatting This could seem meaningless, but people can be embarrassed by missing spaces, or other badly formatted things. Do not be afraid to use the official code formatter. 

You better express your attempt with this. Also, you do not need to put the type of depth, this is by default. If you want to run at least one time the block, this is better (in my sense) to write this: 

Suggestion Don't run your checking code and wait for the result. Better have your checking code run in the background periodically (e.g. in a dedicated or a ) and have that code post its result back to any interested party. You can use a to send a message from a background thread to the UI thread. For example, send one message each time the connectivity state changes. 

You create a new, private each time the method runs. The intention behind s is that they're created once and then used over a longer time span to execute multiple (short) tasks. This should save you from having to create a new for each task, because the executor manages a number of threads which get re-used for multiple tasks in succession. You don't need that . The usual idiom of the is like: Callable myCallable = new CheckConnection(...); Future future = service.submit( myCallable ); ... Boolean result = future.get(); It does not make any sense to a (single) task to an executor and then start waiting for completion immediately. This will block exactly as if there was no involved at all. In your case, you could just write with the same effect w.r.t. concurrency. 

Does not work reliably. is assigned when the corresponding thread executes that line; if it does or not before the next iteration changing is undefined and hence not guaranteed. 

Doesn't work because you do not in the worker threads, i.e. the worker threads don't care and still access whenever they want. Plus some more issues which affect the functional correctness. I suggest you try and fix those first. You may want to have some read on Java's threading, especially about how and relate, what thread-management routines there are in (mainly thinking about , , and ) and when and how to use . It's actually not very complex, and pretty straight forward to use/implement in a simple case like your's. To improve your solution you could then familiarize yourself with and for inter-thread event signalling and/or ready-made data structures like s for data exchange between threads.