I know this violates the SRP, and it might look to be introducing some coupling between the Presenter classes and Spring, but it seems to me that it's not really coupled any more than it was before, it's just now type (and typo) safe, while living in a somewhat weird place. If I stop using Spring, I simply replace this call with whatever else gets used instead. Am I missing something that makes this a really bad idea? Is there a better way of avoiding the usage of strings? Should I just suck it and make sure I don't spell "clsPresenter" as "classPresenter"? 

Whether you should use inheritance (either of a concrete base class, or an abstract class) or not or even whether you need two classes, depends upon a lot of factors, and there's not enough details here to say. But there is an alternative...extension methods on an Interface. They would allow you to have just one concrete implementation, that acted upon both. 

I assume that the part that you want to improve is the key.StartsWith.... I would replace the anonymous function with an Extension method String.StartsWith(IEnumerable<string>) -- then create a list of special keys (perhaps even load them from persisted storage, depending upon your usage), to be used in the extension method. Basically you add the over head of list creation, but your code now more precisely reflects the INTENT, making it easier to understand and modify. As middle ground between using persisted storage and creating the list in the middle of the your function, you could create a static function that returns your specialKeysList. As for performance, you should always keep performance in mind, but don't worry about it unless you have to -- you should only worry about performance when you have to ask "how can I improve the performance when doing this". At that point you have an identified problem, and you need a solution. If you don't have a problem, then don't do things that you know will cause a problem, but don't spend time trying to make it faster, that time is better spent either writing more code or making it more readable. 

The key thing you need to keep in mind is that a method should do just one thing. I could have combined sumInts and multiplyInts, but they are mostly independent concepts -- so, keep them separate unless there's a performance problem or you need something a bit more abstract (ie you have a list of operations you want to apply to the elements of the list). I would suggest that you consider variations on the above revolving around "reportResults"...there are two variations that should be fairly obvious. 

Not really recommending this, but you could use the fact that you are always using both variables to generate a string representaion of the four states, and then have either a dictionary or switch statement return the correct value. 

None of the other answers touch upon this... Your main function does too much. Specifically, the main function should ONLY do your initial validation -- do you have the right number of parameters? If possible verify that those parameters are valid. Then call a method that does the actual work. Code reuse, whether that is done via copy/paste, inheritance or a library, works best when you have discrete methods, that have little to no dependencies. In addition, given your usage I would change your writelog function to TryWriteLog and have it returns success or failure (ie it eats any exceptions and then returns an appropriate boolean). Exceptions should be handled at the earliest point that knows what to do in order to recover or continue. Given that you aren't doing anything with it, handling it in the logging function makes the most sense. 

It is then clear that the action is the same. Always try to do as much as possible in the common code, and not duplicate code between branches. 

Totally new to MVP and Spring, and I have what seems to be typical MVP application that uses Spring, where the presenter is instantiated like: 

What kind of performance are you getting? Is it acceptable. If it's not, then I'd look for changing your algorithm, and not minor tweaks. In particular, I'd look into NOT splitting the string and recalclating each time. Instead keep track of the state (what line and the number of characters on that line, whether it's a paste or a delete), and do the right thing based upon that. Adding an additional character at the end of a 5k block of text, adds one more line at most, if the last line was 1 character long, then unless the key being pressed is the enter key, it doesn't even do that. But before doing anything, sit down and see how well your existing function works, for your typcial data, and then for some extreme data. 

Now the 7 lines are 4 lines, and it should also now be obvious that a further reduction can be made -- just do the final 3 lines once, outside of the conditions that determine what to print. Whether you print a newline or not, is unconnected to what you print, there's no reason to combine them. Fixing the above moves it out of the "works but horrible implementation" category. But as a general rule, I dislike mixing output and logic, and to a lesser extent loops and logic. If you extract the logic in the loop out into it's own function, that returns a string, you make it easier to read, maintain and test. 

Your first loop is unnecessary, you add more code, and more complexity, by making it a loop, and remove nothing. A loop where the loop control variable is unused should be suspect. You are repeating yourself, and in the process making your code harder to read. 

I agree with Knais that the key question is whether you really need to indicate failure. If you do, then either a tuple or an out param in the form of a TryGetChildren function would be appropriate. I disagree with him in that I don't think that using an out param is a bad idea, at least not if done in the TryXxx pattern. I would NOT suggest using an out param for error message, as that is a bad idea - if you need more than the bool returned by the TryXxx pattern, then you should be using an object that is acted on, not a variable that is changed. It's just as easy to do the simple stuff, and it makes it possible to do more complex scenarios if you need to. And you should be doing it as a separate validation check, not an exception. But in 9 out of 10 cases returning a valid but empty collection, is the right thing to do, as you don't really care why you're not finding what you are looking for, you just want something to use in a for each loop. 

Not that familiar with C++, but that certainly looks like recursion to me... The variable gcd contains a function, which then calls itself. The very definition of recursion. But I would ask what you gain by not making it a regular function? 

into all of the presenters. So that instead of the the two lines above which use a string to find the presenter, it would be one line using the static method: 

That isn't OOP, that's procedural, with a thin wrapping that looks like OOP. OOP will require that your validation be done on objects that share data and behavior. Depending upon your file, this may or may not make sense. OTOH, good procedural code is definitely better than the common PHP "just run it all together inside a single page" that frequently gets used. EDIT: Expanding my answer after a comment. First off, I should be clear that I wasn't criticizing your existing code, just saying they don't make it OOP. OOP is about data and behavior not just having things called classes and constructors. Secondly, EDI probably means transactions of different types with well definined behavior for the various types -- that would be an opportunity to use/benefit from OOP. I would try to design a base class or interface that can be applied to all lines/transactions and then have derived classes for the header/footer and body lines. You need to focus on the similaririty of your data and your process for handling/validating it, your OOP implemention will come out of that. It's a little to early to be asking about OOP. 

Stylistic comments. You have a class, it has a public static main method and a public static method fizzBuzz. They do exactly the same thing. After moving the calculation out into it's own method, I would eliminate the fizzBuzz method, at that point it's just a loop and a println, well within what I would consider acceptable for main to be doing, and just as importantly, acceptable for another class to do if it wants to take advantage of your class. Main is as "pure" as it needs to be, it exercises the capability of the class in a simple straightforward manner. 

This is totally unnecessary on the %3 and number branch as those can never be executed when %25. It is also unnecessarily long. 

First off, it's not a stored procedure, it's a view. That said, the main change I would make is to use a CTE, once you have upgraded. 

No, not really. You want a third parameter that gives an acceptable difference -- this can be number of decimals, percent of value, or a fixed value, but it needs to be coming from outside to really be useful. A function that does it with a constant diff, might be useful in some limited circumstances, but not generally. 

Not related to the idiot-proof aspect of your code is the fact that it is structured badly, more precisely, it is not structured at all. At the very least your main function should be broken down into several smaller functions. Given that this is java, you should probably create one or more nested classes that handle input and/or validation. Related to idiot proof, you should create a generic method of asking your question and verifying that the answer is acceptable, you do that and it will be idiot proof. 

Not necessarily shorter, but you could create an object that takes the two arrays and does the merge for you, possibly using something like array_walk or array_map. 

You ask if moving fizzbuzz outside of main is overkill, I would say yes and no. No, because main should not be doing complex logic, it should be short and simple. If there is complexity, that should be handled elsewhere. Yes, because you moved the WRONG THING out of main. Fizzbuzz has three components, a loop to be executed some numbers of times, a calculation on a given value, and printing the result of said calculation. You move all three of these out of main into another function, but you don't actually gain anything by doing so. Turn the calculation into a function that returns a result. At that point, you will probably want to have the loop stay in main, but either way, it will be a better program.