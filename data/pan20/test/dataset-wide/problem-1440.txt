1 You can do this without using , but using here is the Ruby way. You can think of , for example, as a more compact form of . 

's block is not used here because the key is not present in . The next value of the enumerator is now passed to the block: 

This is a variant of @Flambino's second suggestion, which starts with an empty hash, to avoid the step of deleting keys whose values are zero. 

I have assumed that, in both and , the values of are unique. Here's one way to extract the desired pairs. Code 

This array is returned by the method. If you would prefer less chaining, go ahead and add temporary variables and/or additional methods. The more you work with Ruby, however, the more chaining becomes the natural thing to do. It's no more difficult to debug, as you can do what I did in explaining what I've done. In deciding the proper balance between conciseness and the use of temporary variables and separate methods, I'm always thinking about how the code reads. Aside from performance, my main objectives are to make my code read well and read fast. I want an experienced Rubyist to be able to read and comprehend it in minimum time. Personally, I much prefer reading tightly-chained code to code that is all spread out, uses lots of very short methods, lots of temporary variables with highly-descriptive (and accordingly, long) names, and so on. It would take very little time (well under 30 seconds) for any experienced Rubyist to scan my code and have a general idea of what I was doing: creating an array of directories, converting that to a hash, sorting the hash on its keys, transposing the resulting array, extracting its last element and flattening. Yes, they would have to look more closely at certain parts, such as the regexes, sort criteria, and so on, and for that I would help by adding a few comments. Comprehension of some parts of the code, including , and would be virtually automatic, so it makes perfect sense to express those three operations as compactly as possible: here, three words separated by dots. What I've just said is the opinion of one Ruby hobbiest. I invite others--particularly those who write Ruby code for a living--to weigh-in on these issues by adding comments. 

I have formatted the numbers to make them easier to read and also added three statistics I thought might be of interest: 

I have assumed is not needed for some unspecified purpose. This is a way of achieving the desired result with a single pass through the array. 

These two expressions cover all the products. If is even, the situation is slightly more complex. Suppose and , so and . In this case we will perform the same calculations as above, but for and . We must then add the combinations involving the midpoint, . An efficient way to do this is as follows: 

If , or is entered as a string, rather than an array of strings, it is converted to an array containing itself. constructs an array of strings, one for each combination of strings taken from , and . 's arguments are as follows: 

Initially, ball is at offset in . If , it is offset zero, and therefore will remain at that location. For any other ball , after one rearrangement if will be at offset: 

Where the first zero equals 's memo (or accumulated value), represented by the block variable , is the first character of and is that character's index in . By writing the block variables as , we obtain, using disambiguation and parallel (or multiple) assignment, the following: 

As soon as is non-nil, and the memo is set to that value, will remain unchanged for all subsequent values of (and will not be computed for any of those values of ) and will be returned by . 

Edit: I've made some changes to try to improve the readability of my answer. You could just create a few simple helper methods. Here's an example, based on the assumption that ordering is not important. Rather than the usual approach of presenting the code and then showing how it is used, I have reversed those steps, as the code is so simple that most readers will be able to glean it merely from its application. There are two helper methods, and , The variables , and refer to "first name", "middle name" and "last name". The first, middle and last initials are: , and . The constants should be self-explanatory. (The application of the code is best appreciated when one of these is playing in the background.) Application 

Let's try it out. First, write some words to the dictionary file and to the file containing the prepositions: 

To my way of thinking, the shorter the method, the shorter the variable names can be. If a method is short, and you understand what value a variable holds, you don't have to remember its name very long, so it can be short. Here I used (and ) for "number" because I always use that convention. obviously is a method that calculates 's triangle number. I can use something short like because the expression says what it is. Same with and . If you want to get fancy you don't have to begin with the number . Instead, you could calculate a lower bound on numbers that have triangle numbers with the given number of factors. Calculate triangle numbers Next, in order, the method . Your method is fine, except doesn't add anything to the name and there is no need for an instance variable. Just return the triangle number, which also helps with the self-documentation of the method: 

Examples Actually, I am not 100% certain this is working, because I am not familiar with JSON, but I expect it will not be difficult to repair if there are errors. I did a poor-man's test by commenting-out and running: 

That looks pretty good. You might consider using an enumerator and block to avoid the need to write: 

It follows that for , the odd expression of applies and for larger values of the even expression applies. We form a hash that maps into and then invert the hash to map into . 

This time, both hashes being merged have the key , so the block is called up to determine the value of that key: 

Matthew, it appears to me that you are only making use of the two elements of whose keys are the top two in the sort. Please correct me if I am wrong. If that is the case, I believe your code (after "edit") can be simplified to this: 

I tacked onto the end of merely to display the hash in order of increasing keys (positions). Explanation Let 

Not hardwiring "500" makes the method more general, facilitates testing and helps explain what the method does. In general, hardwiring is bad and doesn't buy you anything. Perhaps we might call the method . Make the main method simple, showing how the calculation is made is the simplest of terms: 

Here is another way of doing it. (I have omitted comments on your code because I have nothing to add to @Uri's excellent answer.) Code First define an class. This allows us to keep intervals as single objects in the main class, without having to fuss much with end points of intervals. 

This is quite straightforward, similar to what you would see when using a procedural language. Here's a recursive approach: 

That's up to you, but you probably want to use the first form at least while you are debugging and testing. Calculate number of factors from prime factors Now let's go out of order and look at the method . This one is actually quite easy, as we can employ a version of the Tau function. Suppose we have constructed to return the array: 

Incidentally, I made the number of elements whose product is to be maximized a variable because it wasn't really any more difficult to do that and it facilitated debugging. 

You can also use Ruby's Matrix and Vector classes to see if player wins. In the following, is the player in row , column . Code 

is the given positive integer. For any , the hash contains keys , where , being the minimum number of steps from to and being the previous number on the shortest path. initially has keys , then is added, then , and so on up to , at which point the shortest path to is available. The shortest path is determined in the code that precedes ; the remaining statements merely extract it from . 

Another way uses the form of Hash#update (aka ) that uses a block to determine the values of keys that are present in both hashes being merged: 

I suggest that you only introduce instance variables when you really need them. For this problem, I don't think you need any. This problem concerns natural numbers, so I think is enough. (Nobody will ask, "What if is negative, a float, a complex number or a Roman numeral"?) You could instead calculate each triangle number from the previous one, but this is a quick calculation relative to the other work that must be done, and stands alone, so I think that's fine. Calculate factors Next up, . You are doing that calculation in two steps, so again, keep the method short to give the reader the big picture: 

Main method You want your code to tell the story of how you are solving the problem, starting with the general picture and then working down to the details. Your main method is . I suggest you change the name slightly: