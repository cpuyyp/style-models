Instead of sending a new network request every 2 seconds, I'd send it 2 seconds after the last one was complete. Put a method in to initiate a new request in 2000ms. You also don't need to run your time like that - has methods like and that'll handle that for you. I'd probably use a networking library like Volley or OkHttp instead of doing it manually, but honestly what you have is probably fine (although you should probably do more to anticipate and handle failure) 

Your friend is suggesting you have a class that does the common work, and then subclasses to handle specialized work. This is really core OOP. For example, your base class (say, ) might have an method like this: 

Eager load is recommended to avoid separate queries generated when Chart object properties are required (less SQL verbosity, significantly faster for large collections). will automatically map properties having the same (and type, if type is different and no implicit conversion can be done, it will throw an exception) and not ignored ( attribute). 

This solution should be easier to understand, but uses extra memory for the result. This can be overcome, by reusing the same documents: 

It is also recommended to use enums for your units, so that unitConvert caller cannot provide an invalid unit: 

Your variable convention is inscrutable. Why is private? Why are the next three package-private? Why does look like a constant but is neither static nor final? Why are some member level and the rest static level? Variables names like , , are not clear and should be reconsidered. Your static variables are A) created whenever the class is first referenced, and B) may outlive the Activity. I don't see any reason in the existing code for these to be static. You should probably coordinate your thread with your activity lifecycle. For example, check if the Activity is still running in your download while loop, and exit out if not. In your , see if you still have a UI to modify. You might want to cancel the during or . Your code style is inconsistent. The whitespace convention changes throughout and is hard to follow. You have some single-line blocks without braces, and some with braces. You have some blocks with a brace on each line and some with 2 braces and a statement on one line. You don't test for null in when examining the String returned from - it's very likely that http connection could fail (server down, interrupted connection, etc), and you'll end up throwing an NPE if that happens, rather than managing it. is probably better as is not clear. I also don't see it referenced anywhere. Add javadocs. 

Question: Can any of the above be improved in terms of architecture? Performance-wise, the initial Excel package creation and other initializations may take even 2 seconds, but after that, getting changes usually takes 100 ms (send changes, process + get changes back in browser). There will be only a small number of users to access this functionality (maximum 20 concurrent users), so I do not expect any performance issues. 

3. Checking for duplicates - The algorithm itself can be improved by thinking in terms of set. I am not very familiar with Java language and I have used data structure, but the bottom idea is the following: if current element is already in the set, it is a duplicate. Else add it to the set. This solution also has the advantage that avoids hardcoding the number of allowed characters (26). 

The Problem: My C# code that renders the mandelbrot set does so in ~450ms, while my c++ code using MPFR and MPIR takes ~10,800ms at 5 iterations. Both of these times are fairly slow, but 10 seconds is glacial for rendering the set. I am aware that this question, this question, and a slew of other questions exist regarding the speed of mandelbrot rendering, but my question focuses on the differences in speed between C# and C++ render times. I also know that Ultra Fractal can render the mandelbrot set using MPFR and MPIR at iterations above 5000 in less than a second (atleast on my computer), meaning that it is possible to speed up fractal rendering. I know that Ultra Fractal uses many different algorithms for optimization, so I'm not expecting that kind of speed, but I find it hard to believe that their base code (their code without things like guessing pixel values) would take anywhere near as long as mine at 5 iterations. I want to know why my C++ code is so slow and how to optimize it. I don't need to optimize the C# code, because it won't be in the program when I'm done. It's just for testing. Some help speeding up the image saving would be nice since it takes ~600ms, but it is not included in the timings. Timings Note that these timings vary a little between tests. Also, the tests were conducted at 1440p C# 5 iterations: ~450ms 250 iterations: ~1,100ms C++ 5 iterations: ~10,800ms 250 iterations: ~102,400ms (102 seconds) As you can tell, the time it takes to render also does not go up at the same rate between the C++ and C# code. The time it takes the C# code to render at 250 iterations is ~3 times longer, while the C++ code takes ~10 times longer. I am not sure why this is the case. Code C# 

I will try to cover several points: 1) Naming Try to use homogeneous naming. Pascal/Camel case seem too be used most often, so stick to it. E.g. should be , should be . 2) Improve readability of your declarations Your table variables could be declared like this: 

in $configFile = !isset($configFile) ? $defaultConfigFilePath : $configFile; Hopefully, they will introduce a coalesce operator soon to simply write: 

4. Tests - it is a good habit to accompany a function with a test suite. It is particularly efficient when the code changes much (regressive testing) and helps to cover scenarios that are usually missed when developing (developers have a tendency to think in terms of making it work, not making it fail). 

There's really not a lot going on in what you've posted, so there's not much to pick apart. Really the only functional change I'd mention is that there's a class available that you can use that provides play, pause, and seek functionality (including a standard UI that Android users are familiar with) that you might want to check out. That said, it's 100% find to use your own UI if that's a design decision and not just the result of being unaware. Also, you don't update the play/pause UI the first time the `MediaPlayer is started. Other than that, it's mostly code style and convention issues that I see. 

The advantage is that you avoid fetching lots of s from SQL Server. However, the query is more complex and does not allow to easily change it. Also, result is obtained as a concatenation, not a list of objects, so it must be split, if a list is really needed. My opinion is to stick with 's approach, but I felt like sharing this alternative. 

Complexity should be as all dictionary operations are done in . If your documents were copied from some other data structure to your response, I think it is better to construct the dictionary from that data structure and obtain from the merged data. Otherwise, you have to use a loop to remove documents already merged (somewhat more convoluted than version). 

Classes are usually named using PascalCase (you have lowercase). Also, convention is to use the word "Activity" when extending an Activity, so your class should probably be . The prefix is generally reserved for setter methods - methods that update a variable value and often do some pre- or post-processing work around that update. I would probably call something like or . You could break into multiple smaller methods. You probably don't want that whole method body in the block - figure out what's going to potentially and move the rest out. This is a bit of a nitpick and isn't critical for a fairly small function like this, but it's a good habit to get into. is a bad variable name - it's not clear what kind of object is being referenced. Your code might be a little easier to read with less nesting. I'd probably move the functionality in the to its own method, and call that method in the . Why is the variable and not a member variable? It's OK to do this, but there doesn't seem to be clear reason - you're using member variables elsewhere. Again, not a critical issue, but Android convention is to prefix variables with , so would become . Why is public? Always be as restrictive as possible. will default to so you don't need to set it. If an error is thrown, do you really want to print the stack trace? This might be fine if that's what you want, but I suspect that's either the IDE's decision or the result of a copy/paste... What error might be thrown here? What could be a possible source? What do you really want to do if that happens? If you're not using any methods, you don't need to cast it - returns a , which has a method, so the cast doesn't do anything. 

Multi-threading: I am going to handle multi-threading through a different method in C#. I just want to get my base code sorted out before that. Using double precision at the beginning and switching to arbitrary precision: I plan to do this, but I want to make sure my arbitrary precision code works fine before I do that. xZoomPoint and yZoomPoint can be doubles: I am aware of this, but in the future, I am going to implement an autopilot function, which will need more precision than double. 

Clarifications I'm using the CImg library for drawing and saving in C++. I've left my method of timing the program to make sure that everyone knows what is being timed and what isn't. I've also left my comments in to improve readability. That being said, I'm not very satisfied with my C++ code's readability, so suggestions for readability that don't affect performance are appreciated. Also, the temp values in the c++ code are there because, as far as I can tell, MPFR doesn't support doing multiple lines of calculation at once while mixing doubles and mpfr_t types. You can look at the C# code to see the expression in one line (it's a lot easier to read there). A solution to having to use multiple variables for intermediate calculations is appreciated. Interop The C++ code isn't actually called from C++. I don't know whether this is relevant, but I thought I'd mention it, because I'm fairly new to C++/C# interop and I don't know how that affects performance. Basically, the C# code calls my C++ /clr project. Then that calls the code below, which has /clr turned off. The whole process takes 20 ms, and I've taken care to not include that in my timings. You can see my method of timing my code above. Optimizations That I already Know 

What happens if your dice changes into a larger polyhedral one? Your ifs statements will not handle the value at all. So, a reasonable version is to use something like 5) Encapsulate your damage simulation in a class Since main is much slimmer now, we expect that everything is handled by a special designed class: // created new class to separate things 

1. Functionality extension - besides already mentioned answers, I would extend your functionality with a back-off mechanism which can prove useful in some situations (e.g. a SQL deadlock). Since the options are quite a few now, these can be contained into a special class: