This will automatically and automagically create a working comparator that works by comparator the field of , which is inferred to be . Now this line: 

You are using some random object range in , I suppose you wan to use such that it scales with your input. Please try to use meaningful variable names. and are utterly meaningless, for I do not know a replacement right now, for I suggest . Your code currently only works with s, consider making it generic and providing primitive overloads. 

The explicit is ugly, but neccessary to not result in type casting, which is even more ugly, it is a limitation of the current type interference. It might be only an issue in IDE's and the javac compiler might actually compile it though. The usage of is pretty bloated, but our most reasonable option, besides creating a class ourselves and using . This will hopefully be easier if Java 9 includes tuples (which logically include pairs) as more or less first-class citizens. In the whole method we end up storing all the entries in memory once, with the , I am pretty sure there are ways around that, but not worth the effort here, only optimize this if it becomes a real bottleneck. I was hoping to use the method when processing the results, however this is not possible with the requirement that you want to have a counter. Again, more possibilities open up in Java 9 when we hopefully have s and tuples. 

For a game I am playing, OGame, I am trying to calculate the fastest strategy to reach a certain state in the game, relevant parts of the game for this question are: 

Overall your code looks okay, nothing much to comment on it as a whole. I'd like to add the following comments though: 

Your method call is in Dutch and not in camelCase, it should be something like . Lastly, your is not an error, it is an or an , please name your variable like that. 

The specific question is about the for example, should I there enforce all other conditions which could make a test fail? In this case it would be setting the other monsters on the field, as that might cause the test to fail. Few extra notes: 

My additional question is whether the filter part can be written more succintly as I'm duplicating code right now while all I need to actually to is dos ome operation on and . 

You need to give a as argument, and that is exactly what is. Reduce logic involved in In my opinion too much is going on is this method, there needs to be a way to write it in a cleaner way. An example is the following, though it still does not eliminate all increment and decrement operations: 

Make an class that can operate on it's own, you tell it what to do, what the inputs are, and you can call methods on it that give you output. One candidate for refactoring is the input file, this should be an input argument. Another point is that you request user input inside your processing, the user input should be asked beforehand and also be an input parameter. The prediction which gets printed while processing, should be an output. 

You could remove the dependency on in your class by adding a dependency on a , now your instance creation could look like: . While your styling is in no place bad, it still has room for improvement. You inconsistently sometimes have two lines of white-space between methods, this should be only one. Your statement lacks breathing space, it should be of the form , not and in one case you have unnecessary spacing in a method call, see the call. 

As an exercise to learn Rust I've decided to write a Bit Vector library, furthermore I also intend to use it later because my version can share slices of the bit vector between threads whereas the existing bit_vec library cannot do that and development does not seem to be active anymore. The library has the following functionality: 

Your is currently a package-private variable, it is better off just being a private variable. Your could could use some extra room to breathe, consider adding blank lines between the method calls. Your copy-pasted is a real copy paste, you should really change the to there. Always use braces around the relevant control structures! This means that your for loop needs to be along the lines of . You should use descriptive variable names, I know it is tempting to write , but I would really advice you to just write , such that all code is much more readable. 

Which in turn makes it a lot more readable. There is even another enhancement we can make, that is we can return a containing the name of the Fizzer if and only if it can divide a number, else we return an empty stream. 

Last week I started learning Haskell, and since I have some experience with Brainfuck already, I decided it would be a great idea to implement an interactive Brainfuck interpreter in Haskell. I'll first list the code and then add some remarks on it. Main.hs 

Inspired by some older questions, I decided to create my own postfix calculator using Java 8. I'd like to have all aspects reviewed. 

Normally one would use method references in case of , if had a method, then you would write it as . Upon further inspecting your code I see that you possibly intentionally have made your comparator serializable, if you need that for Apache Spark, then you can do that as well, though the solution does get a fair bit uglier then: 

For this it also holds that should be changed to if possible. You can now get the values with versus the old (Small note: I barely use Java 6, so hopefully I have not accidentally used a Java 7/8 feature) 

Then you start at the method, which returns a , again to offer the flexibility to do what you want with the results, they are not stored yet at the point where it gets returned. First I added some error checking. Then I obtain a that will compare what the entry is with the lowest number of occurences. This is done by using a on the value of the entry, which is obtained with the method reference . Then I start the chain of operations on the input : 

I'd say there is no reason to add them, it can even create confusion as now I start to think about the reason of the blanks, this is more clear: 

The others have already posted out most points, so I'll briefly recap my opinion on them and provide an easier example: 

In general the code seems fine and it is not horrible or anything, but I think you could surely have improvements. High level Currently your code returns if , I think this should be an exception, possibly an existing one, or a custom one. I'm not exactly sure what it does, so I cannot give more advice. General coding style I suggest you to change your coding style to more consistent and I think you can enhance readability with some simple changes. Take a look at: 

Your code looks at first glance quite complete and professional, so onto the points. I hereby assume that you are using Java 7, since you have not made any restrictions and it is the most common version, though I may be wrong. 

You'll need to obtain the the backing source of a , such that you can apply operations in constant time. You can obtain a both readable and writable backing source via: 

I'm completely new to Groovy, but have many years of Java experience, and recently I have started working on a Grails application, currently it contains the following: 

You have your phrases first, you want to simply have an object that holds your s. Here a is a suitable object, because you only need to have a view on your object, there is no point in actually storing the new data. You do this by calling . 

Beware that the line should really be , but type inference is having issues with that and for some reason it will not compile. I hope the Java 8 way can give you interesting insights. 

I agree mostly with @200_success' answer, though for simplicity and maintainability I do suggest you to use the following, which is only possible in Java 8. It functionally does the same as @200_success' answer. The code with explanation below: 

Just a quick observation I have made here, and this is by no means a full review, but you have some dead code here: 

I'll go with the second option as this is the most straight forward one, but you should really look into this. Our first revised code will look like this: 

In the game Factorio there are string-encoded representations of blueprints that I wish to decode. The implementation according to their wiki is the following: 

As others have pointed out the most obvious improvements already, I would like to talk about Java 8. Maybe you cannot use it yet, but I would recommend looking into it and this answer should proivde useful for anyone reading this. My main focus point here will be designing the code such that it will logically do what it is supposed to do. You have a method in which you take a as argument, and you want to return the top x occurences, that is all you want, in order that means: 

First I would change to , to denote that it is about an exception. confuses me to no ends, hence these suggestions: 

I decided to implement it using an is-subset-of approach, leading to the following stored procedures and functions as solution (I know about the 'missing' delimiter calls, but I think HeidiSQL silently inserts them): : The main stored procedure in question 

When forcing this word to abide regex , it has to return , here I am denoting the objects as strings. I have a solution, however it is not fast enough, more details after the method: 

This solution also reduces the lines of code used, hence it should in theory be easier to maintain. Use underscores in numeric literals For clarify you might write the following in the method: 

The most important external libraries used for dealing with the XML data are JDOM2 for the preprocessing and Jackson for the deserialization. I can give you the names of the tests to give a hint about for which things I test: 

First group the results by their identity, which normally produces a . The trick here is that I also used a downstream , which counts the number of times the string occurs, hence it is called . At this point I have a denoting the word and the number of occurences. It uses a , because this is what returns. Then I obtain a and convert it into a stream. Then I call on the with the reversed comparator. This is done here, because type interference is not strong enough to use . Then I the stream by the top x elements. 

This is my personal preference on how to format it though, the only real change is to rename to , as it is simply a and nothing more or less. You've done a good job overall. 

Reflection is not the correct way to do this. You will need Serialization for this. Another option is to use XML marshalling and unmarshalling, but I am not so familiar with that. For serialization I suggest you to pick up a copy of Effective Java, and read the last couple of items of the book, which are all about Serialization. You really need to take care of the following, since you are dealing with a game and network: 

I've been interested in writing something meaningful in C++ for a long time, yet I had a hard time not picking Java or C# for a new project... Now I've found something for which C++ seems to be the right tool: Writing a Database Management System. I'm going to show you the code for the first step: Storing databases. The code is written in Microsoft Visual C++ 17 and I'm trying to have code that is as modern as possible. I also didn't intend to build a serialization library, it just happened. This library exports its methods through a DLL. 

Let be the number of combinations possible, calculated as the product of the size of all symbol choices. In my example that would be . For I observe it to run very quick, however with for example it takes a few minutes to process. I also spot here another case of and have a feeling that it will never finish. What can I do to solve my problem efficiently? I need to stick to Java 6 for Android compatibility. (Bonus points if someone can calculate the asymptotic time my algorithm takes) 

If every catalog also has a generic relation with their repository, then even more interesting patterns can be thought of, but it is always a question of whether you need so much compile time protection. Then you need to store your mappings somewhere, I suggest a singleton enum for that: 

I'd like to get a review on all aspects. The class for example has been refactored a few times to incorporate new constraints and I am intending that the refactorings do not leave their marks on the source code. 

Calling for every method call is most likely a bad idea. Your idiom is that you will need to your data once at the first method call, and therafter you should not it anymore, therefore you should do the following: 

(For reference with respect to variable names: The 29 DR item is called a "Le Noir" Armor) When testing this application, you can use prices in the range of 300,000 to 1,000,000, that is the regular market value in the game. 

For this you might need to implement yourself, I cannot tell if that is possible. That leads to the end of the review, unfortunately I am only able to touch the basic concepts and not the low level concurrency stuff as I consider myself not experienced enough to give advice upon that yet. 

Where expects an argument of type . It seems to be working, the only thing I am left off wondering is: 

In response to your German overengineering™, I raise you some Dutch overengineering™. I have managed to get rid of almost all unsafe things, like creating instances via reflection etc. My implementation has one unsafe cast, but I'll explain that it's no issue as we go. I have decided to re-implement your solution as a whole, so this will not be a review about existing code. Your problem statement, according to me is that: 

Please note that this is a rough prototype, but by all means do write critique on it as creating rough prototypes as good as possible is also a valuable skill. My main concern with this program is the performance, if I query it to calculate the fastest strategy for for example Metal Mine 1, or 2, or 3 or 4 then it is fast, but for Metal Mine 5 it takes forever. The problem lies in RAM usage as for Metal Mine 5 it takes at least 6 GB of RAM and this is obviously a big issue. On the other hand, I am restricted to doing a Brute-Force search as I cannot think of any good heuristic which would let me allow a more efficient algorithm. 

Problem statement I've tried to solve the following Euler problem in a very straight-forward way, ideally avoiding recursion if possible and writing it in a functional style. 

Use , as the array may be of any type and you cannot use generics with arrays. Check if the is not null. The code would have thrown the exception either way if , but I think it is better to throw them upfront. Wrap the in a to convert it to a . 

I wrote this code to parse dates from the output of the OCR, which means that the obtained date can be literally anything, so I put some restrictions in place: 

I would recommend all your classes to implement a static inner classes called and implement the Proxy Serialization Pattern on the classes. Some other ad-hoc review points of your current code: 

The argument should be checked for possibility of being null, with preferably , which will throw a if the argument is null. I would strongly recommend to leave one white space before and after every and . I would only use one statement to check the length, and report back the given input, thus the string. The same holds for the last place where the exception is being thrown, I would echo back what was.