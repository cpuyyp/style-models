Note that the function is now a method on a pointer to a . Now, what reason would you have for exported fields in the struct? The struct should never leave the package in anything other than interface form, so make those fields lower-case (exception is if you serialize with or something). I would also shorten the struct name (I do that sort of thing...) The full code would be something like: 

Sometimes, when doing left-join aggregation with a simple function (), it is easier to move the aggregation to be part of the select clause instead of as a subquery on the from clause. As long as you are only pulling one aggregate from the sub table, it's easy. Also, I presume there is at least one index on where the is the first (or only) column. 

Now, that's a bunch simpler, especially the reduced error handling, and the reduced content in the client. There were a few things to hammer out here. We shifted the printing of messages like and in to the and methods respectively. This reduces the mixed logic of handling a client and also reporting activity in this function, and shifts it to the more logical place where we are actually adding and deleting things. We used defer functions to handle cleanup of resources at the same time/place that the resources were created. We used a scanner instead of a reader. messageChan Let's cover that concurrency issue I mentioned earlier. It comes down to the . The problem is only one client is busy at a time. Let me explain... this code here: 

How does that work? It gets details about the instances, if they compare as "equals" then the next test is run. You can sort nulls to the end, and you can go from there. If you still need your comparator class, it could be: 

This script has been in use now for close on 10 years.... it has been extended, modified, and 'fixed', but has never been reviewed. Because of its age, it does not use the latest perl goodies..... sorry. The output from the program looks like the following: 

Note that this is an O(n) operation, it scales well, and it tolerates working palindrome input too. I put this in to an Ideone here. 

Note, in the code above, I have added spaces to the expressions to make them more readable. Now, with that value, if your position is 0, the sum to the left is 0, and to the right is . If you move your cursor to the right, the sum to the left is now the value at element 0 , and to the right is the . So, you can loop until you find the match..... 

Alternatives There are two alternatives I recommend, the differences between them will depend on the number of letters in the input word. The one solution has a runtime performance of \$O(1)\$, but a memory consumption of \$O(n^2)\$. The other has a runtime performance of \$O(n \log n)\$ and a memory consumption of \$O(n)\$. Note that your solution has a runtime performance of \$O(n)\$ and a memory size of \$O(n^2)\$. What does that mean? It means the one alternative will have slitgtly worse performance than yours for larger inputs, but will take much less space. The other alternative will be much faster than yours for larger inputs, and will take about the same proportion of space. Each alternative has merits over yours. In your solution, with \$n\$ being the number of letters in the input word ("bananas"), your runtime performance requires you scanning the Node tree for as many as nodes (one for each letter), which makes your check performance proportional to the number of characters in the input word. The number of nodes you have is proportional to the square of the number of input letters, so if you double the number of letters, you quadruple the number of nodes. The two alternatives I suggest are different, in that the one alternative will have an \$O(n \log n)\$ search performance but an \$O(n)\$ memory performance. Because of the way the data is stored, though, for smaller input strings ("bananas" is small), it will likely be much faster though, than yours. The other solution is much faster (essentially constant time - \$O(1)\$ ), but has a higher memory cost - about the same as your code. Fastest - and Largest The fastest solution is to take all possible substrings from the input and put them in a . The input processing is simple: 

Notice how I have also removed the redundant braces you had around the conditions. The operator has a higher precedence than so it does not need to be elevated. 

I know there's no StringBuilder in there, but the performance benefit for something that's seldom used, will be negligible, and this is more readable. Note that the code above adds a space after the comma, which your code is missing. 

Then, your variable is useless. It's never set to . Instead you return immediately if it's not a palindrome (which is a good thing). Further, consider that your input is a which is a double-linked implementation (as you pointed out) which means a reversed iteration is "easy". 

The way the regex works is that it looks for two things (the regex is in two parts - using "lookaround" expressions).... 

Put them together with an or condition, it says: split the input on the gaps before and after or . Now, you can just initialize the result to index-1, and then loop through the rest.... : 

What you have implemented is a back-to-basics number-system in base 62 Your List is a mechanism of habing the equivalent of "units", "tens", "hundreds", except you are in base 62 so it's "units", "sixty-twos", ..... When you increment a value, and it overflows, you then set it back to zero, and increment the next column instead. In addition, you have a special case for the first time around, where you have to bypass the logic to ensure you have the right initial value returned. So, there's a trick for the first time around that's easy to implement. The trick is to think of the array as holding the "next" value to return. Your code then becomes: 

For performance reasons, in Merge Sorts, it is common to have just one temporary array for the data, and then you use positions and lengths to work inside the relevant parts of the data. The above is hard to describe without a code exammple, so the following will have to do.... a typical merge sort algorithm has a recursive method that looks something like: 

Your current solution is actually pretty good, conceptually. There's nothing wrong with the variable. I am not sure why you want to remove it. The loop is logically a good solution, but there's a better way than that, though (better because you can make the system do it for you....). 

Finally, does the control loops. I have added some validation, and other controls. Note, it is now only a single main method. 

I believe there's race conditions in your code, Specifically, if you call asymettrically (more times than you call ) then you run the risk of a few things: 

So, performance, and Swing, and Println..... there's the problem. println is a great debug tool, but it is shocking for performance. There are a few things that go against it.... 

Part-way through an answer, and another answer pops up. My answer is slightly different to Prizoff's, so I'll keep it. In an interview, the trick is to take a moment to think about the problem, and what the requirements are. In this case, it feels like you have taken the wrong path to getting the results. The simplest solution is to keep a running tally in two loops 

Your code is interesting, in the sense that it appears to have been pulled from about 4 different text books all related to Java about 4 versions ago.... actually, make it Java 1.3. It is consistent code, but everything is just.... old. In some sense of order, the following strike me most: 

are misleading. Why are you debugging in a method like this? Is it debugging, or is that a core output of the program? Is the only thing needed to do a println? The method should be called as well, with a capital S. The methods: 

Hate to say it, but you have chosen some pretty slow data structures to use for your code.... Your input data is in an array. This is a great data structure. You convert those values to a List, which is not as nice (more memory, slower because of data conversions, etc.), but, the real kicker, is that you use a .... The implementation has an O(n) access time... so, doing things like and require a scan of the list to find the position. next up, I don't think your solution using recursion is the easiest, or the fastest. In your case, there are really two strategies for this. The first strategy is to sort the data ( O(n log(n)) ) and then do some smart looping. The second is a naive approach. The naive approach is actually quite simple to understand: 

All in all this code is decent for a beginner attempt at what is actually quite a sophisticated operation. Importing multiple libraries, logging, buffers, etc. Good job on just getting the job done. There are a number of improvements though that you should consider. There are easier ones, and more complicated ones. Function names is not a great name for a function. You may as well call it .... ;-) Choosing a name that represents the functions activity is a good way to confirm the function is doing just one thing (which is a goal of the SRP - single responsibility principle). A name like would be closer, but that shows that the function is doing too many things, it's cropping, and resizing things. Consider splitting it in two, and calling both parts from the parent: 

There is a bug in your code for those times when the two input values are not prime. Consider an instance when the input values are 4 and 6. In this case, your code will output F for multiples of 4, and B for multiples of 6, and FB for multiples of 24.... great... but, is it? No, 12 is a multiple of both, but will only print "F ". If you want to use the optimized cascading-if-else version of FizzBuzz, then you need to ensure the inputs are both prime, or have no common factors. It would often still be faster to compute the common factors and then after that do the system you have. 

See how much better it scales \$O(n \log{n})\$? When you have the appropriate algorithm for the job it makes a real difference. 

use a logical frame of reference. get familiar with bit-wise operations. pre-computing results at compile time is very efficient at runtime. switch statements are high-performance lookup tables 

This will convert valid input characters to the characters through (except for the valid input characters and which it converts to So, we end up with the following function: 

Java features Your use of Java features is OK, but you are not really doing a whole lot. Bugs Your spec says the strings will contain ASCII characters, and, to me, things like spaces and punctuation are all ASCII. Your code subtracts the character value from the string's character to get the array index. This will fail for the spaces and punctuation. Why do you need to do the subtraction at all? The code would work for all ASCII without that anyway. Algorithm My biggest suggestion is about the algorithm, anyway. Your code counts each character and compares the counts. A much simpler, and intuitive algorithm, is to sort the characters and compare the results..... Consider: 

Results I have put this all together in a test harness, to measure the performance, and included two additional tests for you to consider: 

The logical reading of that order is better, take this collection, map to that collection, and use this function to do it..... maybe it is not such a big deal...? The use-case seems to read better for me: 

This is generally good code, with standards-conforming names and style. It appears that is an afterthought variable. It is not scoped as being 'private', and it is not decreased in the method, so it is buggy in two ways. Additionally, even in the inner private Node class, I would recommend declaring the and as private, and also adding getters/setters for them. Otherwise, this is good code. 

There are a few problems you have here. The first, is the concept of getting the usage at a point in time, which is not possible. But, you can get it for a span of time. You are using which will get the usage for the span of a second. Since you are accessing the system to get the number of CPU's, you may as well use the right file for what you want: : 

That function (not a lambda) takes a partial solution, it generates all positions on the next row, and, if the position has no conflicts, it adds a new (extended) partial solution, and outputs that. The outer part of your qu method loops through the partial solutions so far, and then 'calls' the inner part. Taking the outside part, and making it functional, I came up with: 

the temp table probably does not have statistics up to date, and is not indexed at all the primary table probably has some indexes on and/or when Oracle optimizes the query, it will likely decide the temp-space required to store all the name-concatenated values will require too much memory, or even physical IO 

As per Bobby's comment, Vector is your problem, but not for the reason he says... Vector is a synchronized class. Each call to any method on Vector will lock the thread, flush all cache lines, and generally waste a lot of time (in a situation where it's usage is in a single thread only). The fact that you use Vector indicates that you are running some really old code, or you have not properly read the JavaDoc for it. A secondary performance problem is that each value is being converted to a Object. In cases where you have large amounts of data, and where there is a primitive available for you to use, it is always faster to use the primitive (in this case, instead of ). You should also be using the Java7 try-with-resources mechanism for your . My recommendation is to change the signature of your method to return a List... actually, no, my recommendation is to return an array of primitive .... if you are interested in speed, this will be a significant improvement: 

what's for? That's just an infinite loop.... and your code makes the loops hard to see (yes, I use loops as a plural there, there are actually 2 loops you have merged in to one....) you have a bug with , you have , but that should be . Instead, you are doubling point each time. 

preserving input format is generally a good idea. it saves having to chomp every line it allows the data to be processed 1 line at a time, instead of batching it 

I would strongly recommend a use of Java 8 features to make your library (which has an API) an easier to use system. Your Task interface should be a . It is one already, but you should make it formal with the annotation: 

Well, that is, actually, not a horrible comment, or code. But, it could be better, if we gave it a decent name: 

90% of your random values will be >= 10, additionally, 9 % will be between 1 and 10 %, so, 99% of your tests will have to check.... 4 roll conditions (, , , and ). So, 99% of all your rolls will check 100% of your conditions. If you reverse the logic, and do: