Error Handling Why not use (by way of , which - as @Pimgd noted - is better done using Objects.requireNotNull(Object, String). An NPE is, very commonly, a specific kind of invalid argument. The exception heirarchy isn't set up that way, but semantically they provide clear information: "Actual argument must not be null for 'abc' in method 'xyz'" is preferable to "Actual argument is (somehow) invalid for 'abc' in method 'xyz'" - no? You get this just by using - when checking, only indicates that "some" duplicates exist, but doesn't provide even a single specific duplicated key. Providing that level of feedback would be nice, but requires either a different map collection logic and/or extra logic deferred to when the "must have had at least one dupe - let's find one specific item to report" is being done. Such extra effort should only be done once the error is detected, when it's already known to be worth the richer error reporting effort. If you are going to validate args (vs. null or otherwise), you should do so consistently in all API methods - even when you "know" that validation would also done by other methods called in that method's body. True, such checks will be redundant, but I would rather be sure that it's done consistently than have to think about if the called function validates (and reports) a violation in the way it should. This is especially true when argument names change from what the API client used to what is reported at failure (assuming you were to follow something like @Pimgd's suggestion). Unless this is a "high-performance" utility (which I don't think it is), you shouldn't bother about any inefficiency due to argument re-validation. Even so, even if this were an HP utility, I prefer to validate arguments at the class surface (API / public methods) and then transfer control to private methods that can blithely (efficiently) continue without further checking, knowing it was done at the API level. (Simple check-then-delegate API methods would likely be inlined, and would be fine even for HP. If you're still concerned about efficiency, then you should be writing micro-code...) API Names Why and ? Perhaps and Sometimes sometimes ? How about consistently ? Use established language from mathematics about function inverses, where a is considered a discrete finite function: should be When a name part is , it should refer to the already existing class , not merely "some map with enum values on one side or the other." When you mean "Map of Enum to T" you should use (which may, or may not be, an ). Conversely, for a map (not necessarily an , which would under this naming imply an enum-to-enum mapping, where the two enum's might (not) be the same Enum). Why This Way? What purpose would serve? Rather than why not ? I suppose there might be times when some existing code wants such a mapping (and it's not open to refactoring), or ... hmmm... when? (Actually, I can see the point to such a converter, even in a green-field project. I would like to see the JavaDoc suggest that such a mapping be avoided in favor of the already-available when that is sufficient.) Ditto, re: Also, the reverse situation with a is also of uncertain value. Isn't that what is for? If you don't like client code dealing with exceptions, then a utility class which swallows and/or and merely returns seems right. BTW - such a utility method wouldn't belong to the class, but rather an or class in a utility package. I know you're playing with Java 8-isms, but seems overwrought. Why not just (I made this modification to your code and all tests continue to pass.) Since takes a merge function, why not expose that capability to the clients of this utility class? You might still default it, if you like defaults, but for clients that need to keep the first item in a merge, or the greatest, or the closest to a reference, or ... - they can't use your utility as it stands (making it less utile(?)). Documentation (and related type) When a method is documented as returning an (or ), the return type of that method should be specialized to match. If you don't want to specialize the return type, then you shouldn't mention it in the JavaDoc. The doc describes the contract - and the code should be as close to it as possible. Thus, as per the current JavaDoc, I prefer: I like your use of the right-arrow in the JavaDoc, but the "raw" docs are much more readable if you use rather than . 

That makes the program structure more organized, and allows to add test cases easily. I have used from . If that is not available with your compiler, replace it by . Next, your code to update the array looks a bit obfuscated to me. Actually you don't need that array at all: You already test all bit positions of in 

clearly indicate a code smell. The problem is that you have one single function doing all the work. It immediately becomes simpler if you separate the I/O from the actual computations (which is generally a good idea): 

Computation time: 0.02 s for 16 beads. Total performance improvement: 1.5 s/0.02 s = 75 times faster! 

constructor I would assume that it produces a sequence of all primes up to and including , but that is not true: It produces all primes below because 

First, I would suggest that the function takes a parameter for the upper bound, and returns the result instead of printing it (as also suggested by @user16547 while I was writing this answer): 

The reduced the execution time for my test code from 0.37 sec to 0.28 sec. The array in this function holds redundant information, memory can be saved by replacing it a by an array of booleans which marks all numbers which have been found to be composite: 

A Ruby string literal can be enclosed in single or double quotes. The difference is that the latter does string interpolation. Examples (from Double vs single quotes on Stack Overflow): 

But a better way is to cast the to a Swift array of Swift dictionaries in the first step. Then you can use array enumeration and don't need any casts later: 

I'll start with a review of your current code before suggesting possible performance improvements. Various comments in your code do not add information and can be removed, for example 

Scope It is a good habit to declare variables at the narrowest scope where they are used, and not at the top of the function. This applies for example to and , which are only used inside the while-loop. Input validation silently ignores leading whitespace and trailing non-digits, that might or might not be wanted. The parameter could be used to check if the complete string has been converted successfully. Also throws an exception if the input string contains no valid digits at all, you might want to catch that. Iterating too far In 

If you don't understand what this is doing just comment and I'd be happy to explain. We're taking advantage of the fact that Ruby handles collections of things incredibly gracefully. 

In our product, is a model that can have many Companies belonging to it; so some Companies are parents, some are children, and many are both. We have a helper method that has as its children all Companies that do not actually have a parent; in this way, accessing and recursively iterating over the children will touch every Company in the database. For context, 'branches' are just Companies with a special flag set (namely that they cannot have children of their own). We have a method that makes one SQL call per Company below the queried Company. This has abysmal performance on some pages, and for instance when we need to do Company validation we need to check other companies in the chain for a few different values to ensure pseudo-uniqueness (can not make the column unique). How can we improve this performance of this method? Can we cache the companies on the first call and use the in subsequent calls? Not all properties of Companies are in the database (some are computed) so I don't think we can replace the code with a (sufficiently complex) SQL query in ALL cases, but we might be able to do it for some. 

Although it doesn't appear to be in the scope of your project, ideally you would not call at the beginning of each factorial method. You would call it once, when you actually get , and THEN pass it in to the factorial function. Some last points; I recognize that this is a learning step for you, but do not use loops in ruby. They have bad side effects and you do not need them, there are plenty of ways to iterate over collections. Also the loop looks rather ugly but that's because it's the wrong tool for the job, so it's to be expected. All in all, it's pretty decent ruby! Good job on using reduce / inject, a lot of beginners don't use/comprehend what they do., however is an alias of so to have them both is kind of silly :P 

line is extremely long and should be split into several lines. The correct way to check for success or failure of Cocoa (Touch) methods is documented in "Handling Error Objects Returned From Methods" in the "Error Handling Programming Guide": 

(The only exception are and methods where the instance variable is accessed directly because the object is not fully initialized.) 

Actually I don't know of any case (in Swift 3) where this cast can fail. Things change a bit in Swift 4, as a consequence of SE 0170 - NSNumber bridging and Numeric types. Your code still works fine, and is equivalent to 

The explicit cast to is not necessary because the method returns and that can be assigned to any Objective-C object pointer. Actually your method to read the JSON data is too complicated: The file contents is first read into a string (using some encoding) and then converted to back to data (using the same encoding). This can be simplified by reading the file into data in the first step: 

Your variable describes the contents of the game board, so I would call it instead. Each field can be empty, or be occupied by one of the players. This can be modeled by 

You also have to decide what to do if reading the JSON data fails. Just logging the error is not sufficient because then the program will crash later. 

As it was already pointed out, computing the slope of the line segments (as a ) is problematic because the slope can be "infinite" for vertical segments, and because of rounding errors. My suggestion is to use a different algorithm which does not compute the slope. If the coordinates are integers then all intermediate values are integers as well and no rounding errors can occur. (I would choose the same algorithm for floating point coordinates because it does not need any special cases for vertical or nearly vertical segments.) The idea is to describe the line segment from \$(a_x, a_y) \$ to \$ (b_x, b_y) \$ in its parametric form $$ (x, y) = (a_x, a_y) + u (b_x - a_x, b_y - a_y) \, \quad \text{where } 0 \le u \le 1 \,. $$ Then the intersection of two line segments is a solution of the linear equation system $$ (b_x - a_x) u - (d_x - c_x) v = c_x - a_x \\ (b_y - a_y) u - (d_y - c_y) v = c_y - a_y $$ with \$ 0 \le u \le 1 \$ and \$ 0 \le v \le 1 \$. In the general case, the solution is given by $$ u = \frac {\Delta_u} \Delta \, , \quad v = \frac {\Delta_v} \Delta $$ with the determinants $$ \Delta = \begin{vmatrix} b_x - a_x & d_x - c_x \\ b_y - a_y & d_y - c_y \end{vmatrix} \, , \quad \Delta_u = \begin{vmatrix} c_x - a_x & d_x - c_x \\ c_y - a_y & d_y - c_y \end{vmatrix} \, , \quad \Delta_v = \begin{vmatrix} c_x - a_x & b_x - a_x \\ c_y - a_y & b_y - a_y \end{vmatrix} $$ If \$ \Delta = 0\$ then the line segments are parallel. Otherwise there is a unique solution \$u, v \$ to the linear equation system, and it easy to check if the solutions fall in the range \$ [0, 1] \$ without actually performing the division. This leads to the following simple function: 

Your code does a whole lot of exiting. Why not replace that exit with a call to the main menu? You can't do that at the moment because your Run module doesn't have any methods in it. Aside from the , throw all of that into a or method or something so you can reuse it. 

You can see how our indents move backwards and forwards by 1 every time we hit a scope changing keyword, like , , and . If you were to draw a ling hugging the left side of our code, it would be smooth as it moved back and forth between levels, with no large jumps. Now we can easily see that the code is split in to three sections, based on the answer to the question, and it will be easier to understand and improve the code. 

See a test of this here. Also I just tested it again with the option and it works beautifully as well (returning Stegosaur and Apatosaur but not T-Rex), so that's cool. That's a bit unreadable, so maybe make each option a hash like 

This doesn't even look like it works - where's the to the block? The problem is that your indentation is messy. Every time you change scope you should indent a level further, and when you return to a previous scope you should unindent. Or to put it another way, when you start an block, you should start indenting one level further until you end that each block: 

should both be making sure that everything being inserted into actually is a dinosaur, or your later methods that try to call methods like on will crash. 

Your and functions call each other, but this makes you call your validate function over and over. You should rewrite it so that factorial_r_recursion only ever calls itself, because you can ensure that everything it produces is valid already. (Same with the functions) 

Ruby style dictates we use 2 spaces per level of indentation. The style guide is here, if you're interested. Moreover this is needlessly wordy. You can replace the entire thing with this: 

to read the input. If standard input is a regular file then this will read the entire file contents. But if standard input is a tty (e.g. a Terminal window) then it will just wait until a single line is entered and return. You have to repeat the call until returns an empty data object. And if standard input is some other communications channel (e.g. a pipe) then the only thing you know is that it returns at least one byte (which may be a incomplete UTF-8 sequence). There is already a function for that purpose: reads from standard input and returns each line as a Swift (or on EOF). So your main loop would be: 

"nonatomic" is fine. For historical reasons, "atomic" is the default, but you seldom need that. "assign" is the only choice for properties which are not Objective-C objects and you can omit it. "myBool" is a badly chosen name because it gives no hint about its meaning. I would recommend something like 

The parameter is an array used as cache. But in , the same name is used for both the caching array and the computed number of steps. For more consistence, I would suggest to use for the number of steps only and a different name for the caching array: 

three init methods, two methods, etc. This would be greatly simplified by just observing a generic type , which in particular can be a : 

For each , your method stores a containing the complete sequence of intermediate numbers from to . Each list is created by copying the list from the optimal predecessor and appending . Even for a single , may be assigned a new list up to three times. That is a lot of copying which consumes a lot of time. It can be improved by choosing a different data structure: For each number, store only the "optimal predecessor". This requires less memory and less copying. For the final number, the sequence of intermediate numbers can then be reconstructed by traversing the predecessors from to , and printing the numbers in reverse order. More remarks: