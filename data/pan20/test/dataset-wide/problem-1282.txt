If returns you'll see that the s and s (all s) will be fetched into memory by two queries. Also, the is executed in memory, not translated into SQL. With , the whole statement is translated into SQL, making it far more efficient. (Assuming, of course, that both repos receive the same context instance). Finally There's always much discussion about the use of generic repo/UoW on top of EF's / that implement the same patterns. I wouldn't use them just because it's a "good pattern". In most cases they're only a thin wrapper around the EF objects. Maybe you have to reevaluate this. 

... you would pull all records from the database before the actual join is made. By returning , this would turn into a SQL query containing a and (obviously) far less traffic. 

... assuming that simply s the entity to the context. Now EF will see and as new objects and (try to) insert them on . So how to assign the and values? You could do that in a very generic way that will solve this for any you add, not only copied ones, even removing the need of this constructor. It's by overriding in your subclass: 

The second part is OK. Getting the most recent item from a collection always requires some ordering that defines "most recent". Note that using the improved form, EF will translate this into one query, because isn't materialized yet. It is an expression tree1 that can be merged with the second expression. If you want, you can create one statement in LINQ as well: 

Single responsibility: a controller shouldn't also have Unit of Work responsibilities. The context itself is the perfect Unit of Work. You don't always need Use dependency injection. 

So there is a redundant database roundtrip in your code. After this statement you know everything that is going to find out again. So you may as well do it yourself: if the record exist: modify it and its details, if it doesn't: add it. To modify the existing records, use : 

Another call to the family. This is a plain copy and it will copy all elements where I tell it to. In this case, all elements will printed to standard output, with a newline in between. They will show up from the longest to the shortest. And we're done. 

Good. Now, I have to read in s from the user, decide if they are palindromes and save them in my special container. The following lines of code are quite compressed. It's a single statement that does all what I just described. 

Again, I don't expect you to grasp this fully. Just keep it way in the back of your head and revisit this post in a year... Ok, so I have my custom-made comparator. I can declare my container that will hold the palindromes. As I add s to this container, they will automatically be kept in sorted order by length. But wait, here's an important detail, it's possible that I may have more than one palindrome of the same length! No sweat, use . It does the exact same thing as but allows multiple values where the comparison will say they are equal, i.e. of the same length in our case. 

Well, I have no shame to say that I just copy-pasted @MORTAL's code for that part. :) That's a , an in-place function that you don't need to write somewhere, you just write exactly where you need it. Apart from the funny syntax, the body is the same as the more mundane but equivalent function. So now we have all palindromes saved and ordered by length order. Let's print them out: 

I offer this code as something to look forward to be able to write in the future, not as something I would want you to come up with right now. What you have is great for someone at your level of C++. The most important aspect of this code is its use of . is a container that keeps its element ordered, even as you add more element to it. It's contents will always kept sorted. By default, will perform it's duties by comparing elements with a plain less-than comparator, i.e. . So, by default, a will keep a bunch of s ordered from the smallest to the greatest. Though that's the default, you can change the comparison function. The standard library already has some options ready for you to use. For example, to keep the s sorted from greatest to smallest, use instead of just . But what we want to do here is keep sorted according to their length, from longest to shortest. The standard library doesn't have something ready made for us but we can follow the example of . It would look like this: 

Now you get only one record per show in the result set and only the required fields are included in the . You'll still see a number of joins, but they don't cause any widening of the query, as s do. 

To prevent these errors you'd want to ensure that whenever is to be executed is eagerly loaded (using ). Two options: 

At the end of the day, only you can tell what performs best. But there are two things that in most cases will help improve performance. 1. Reduce the number of queries. Essentially, you do 

is a materialized list (for example, ). After running , a new enumeration of will produce the same, modified, objects. is an enumerable that produces new objects on each execution. After running , a new enumeration of will produce new objects. The changed objects are out of scope and will soon be garbage collected. 

Side note: Dapper's Multi Mapping Feature won't alleviate the first two points because it also creates separate object instances for "equal" entities. So all in all, I wouldn't do this. I would get the data separately and perform some sort of "relationship fixup" manually. 

... that is: the entire database table. Other than for small tables, who's going to want that? Don't save changes. Repositories shouldn't call . The Unit of Work is responsible for that. I know that you intend to wrap each repository operation into a , managed by the UoW, but if you remove these , the UoW doesn't need this : the single call in its method will be enough to save all changes in one transaction. 

If one entity is modified, the changes are reflected wherever the entity is referenced. Also, changes are unambiguous: there are no "equal" entities around having old values. (You're probably getting read-only data, so this may not affect you). Ability to perform operations that are based on referential equality. For example, in your case, grouping s by will produce groups having 1 item, because the language object aren't equal (sure, can be evaded by using , but still, it's a gotcha). EF can perform relationship fixup when it loads entities: loading Resources and Languages separately into one context will auto-populate the navigation properties. Your code won't ever do that. 

is a function from the standard library that takes a range of elements, applies a on every element and if the condition is satisfied, copies the element to some output. In C++, the word can take many strange shapes. My range here is the standard input! That's a range? Well, you can present it as such. This code will prompt the user to input some strings. Every time the user presses , that's a new string in the range. The end of the range is when the user uses the OS-specific end-of-input command, e.g. Ctrl-D in bash or Ctrl-Z in DOS. 

That's the output. That's where elements that satisfy the predicate will but copied. The function is how I tell to call the member function on my . Why do I specify ? That's make little sense. The multiset will keep the elements sorted according to the rules I gave it. It should not keep adding the elements at the beginning! Well, that function is a very generic one. It works for all kinds of container. With a , it would do as I wrote it. But with a or , that is just a hint and will be discarded. On to the predicate: 

I will add one last thing. The fact that I use a (or ) does mean that this code is doing a bit more work than what you needed given your problem statement. That is, you did not necessarily wanted to keep all the palindromes sorted, you just wanted to know which one was the longest. But I offered this solution as an example to leverage stuff from the standard library that can do a lot of work for you transparently. 

So, yes, I know that "you shouldn't derive from std containers" but by now it's more of philosophical rule in my mind than a technical one. I've googled again for the one fundamental reason one should never-ever-ever-ever-do-that-ever-ever-ever-or-you-die but couldn't find it. So, if there's nothing fundamentally wrong with the following and if we set aside performance considerations, can I a get a plain-old code review of this: 

That's one query for each . So you end up having 1 + 1 + n queries. No doubt, it's better to turn these into one. For example: 

It's not necessary to set the return string all the time. You can first look for occurrences of with an incrementing parameter of the function. Only after no (new) occurrences are found, or when the required max number of occurrences are found is it time to set the return string: 

Where's Commit? No, I didn't forget the method. The fact is, repositories shouldn't commit. Maybe this is surprising, but if you think about transaction management it becomes obvious. There may be business transactions in which several repositories are involved. When each repo has the potential to save all changes, it may be very hard to figure out which one is able to save at the right moment. That's the reason why generic repos always come with a Unit-of-Work pattern. This is all explained well enough in the link above. You can see this problem lurking in your code. At the end you have 

All other pieces of code that wrap this part can be deemed redundant. As the ultimate (over) simplification you could even write this code directly in an MVC controller's action method. No added layers involved and the job is done. Useful layers? Anything added on top of this base line should be carefully considered. Additions should be useful, not restrictive. Your proposed architecture is restrictive because it is "vertical". You seem to have a column of abstractions for each entity: , (as ), with subclasses like . Then there is a class, maybe part of a similar column. This architecture has the same drawbacks as Data Access Object: it will lead to multiple isolated queries and repetitive code. Alternatives? This columns-per-entity setup defeats the purpose of an OR mapper like Entity Framework, which is to work with object graphs that map to a relational data model. When you need orders and their related customers you can get them in one LINQ query. Likewise, when you want to save orders and customers, you can add them to the context and do one call to save everything in one transaction. This has made me move to API-oriented architectures. I usually create services that live for the duration of one web request. Each service has a number of methods that execute some business case, like creating orders. For this, the service has one context instance that can pretty freely be used inside the service methods. This works best in combination with dependency injection (or Inversion of Control, IoC), but that's not a prerequisite. This is, very briefly, what it could look like: