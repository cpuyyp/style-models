Small differences due to precision are expected and can usually be ignored. 12 shuffles like that are a bit much, though not necessarily avoidable, depending on whether there is AVX support. With AVX, it is better to literally broadcast from memory, rather than emulate broadcasting with a load and shuffles. Even though this means there will be more loads, the shuffles are a bigger problem: loads (even broadcasting loads) typically have a throughput of 2/cycle while the shuffles typically have a throughput of 1/cycle. This means that is actually the better option, as long as you compile with AVX support. That wouldn't use the wider width yet though. Also annoying is that MSVC apparently likes to reload those pointers etc continuously. There is really no spare load-throughput for that, despite the presence of 9 FP additions (which are also bad though, since they're 1/cycle pre-Skylake), there are 21 loads there, limiting the throughput of the loop to once every 10.5 cycles (which is more than 9, if barely). Fortunately it can very easily be convinced to stop doing that, simply by copying them into local variables before the loop. Next, I don't know what MSVC is up to there with its refusal to contract addition and multiplication into FMA, for processors that support it it should definitely be used. Using the corresponding intrinsic does the trick of course, but that makes it harder to compile for pre-FMA targets (Ivy Bridge and older). Anyway if I write the high level code like this: 

The unsigned average of two non-negative signed numbers neither overflows nor wraps. Converting the result back to signed is always safe. 

Now we can make the array. This makes everything else quicker. However, I also think it's worth changing how you find the biggest prime: instead of finding all the factors, just get rid of every smaller prime factor you can until you've gone through every prime factor up until the square root of the number you're finding. This will leave you with the number you want: 

Now, I'm sure a number of people will say you won't learn anything from this. And if you copy and paste it, that's absolutely true. But I tried to comment everything that I could, so if you read all of those, follow all of the code, and understand how it fits together, that will be very helpful for you. Plus, I left you one thing for you to do on your own: You'll notice that the check3 and checkDiagonal functions have very similar methods in multiple places within both in order to add one if it's a player square, subtract one if it's a computer square. I think it would be incredibly helpful for you to write a function that can replace these lines of code: 

I think Alex is absolutely right that it's helpful to be able to do your own code and to practice, but some people far smarter than I and most programmers have recommended reading others code, so I took a swing at it, and here's what I came up with. First, I added a few new arrays to hold the piece values and the jQuery objects: 

with just one call to that function. Also make sure you can use that same function in the other three places that code that's very similar to this appears. I really hope you found this helpful. Please let me know if you have any questions. 

Without context, it is virtually impossible to infer what they mean. This makes skimming your code very taxing. What does mean? I understand how it is related to its purpose but that is not clear a priori. The same issue exists with (except this is arguably worse, as one might confuse that for your program's entry point). Other This isn't really about your code directly, but when I tested your program myself, it was unclear to me what input you expected. The prevailing convention is to have something like this 

While it is good that your program works the way you want it to (after all, that is the goal!), your code leaves a lot to be desired. Use of global variables Firstly, is essentially a global variable. Even in your class you still use even though it does not ever get explicitly passed to the constructor, nor is it a property of the class itself. This leads to a lot of well-documented problems. Lack of procedural abstraction Secondly, your function should get broken up into smaller functions, as (in its current form) it has too many responsibilities. You do this for a lot of your code (i.e. you have , , , etc.) but you need to do it for all of your code. Hardcoding Thirdly, you hardcode quite a few things, especially string literals you are comparing against. What if you wanted to change the desired responses from or to something else? You would have to find all instances of those characters in your code (which becomes tedious very quickly). What if you wanted to change the delay between each statement? This is not as bad because there is only one place you do this (in ), but it could still be made clearer to others looking to maintain your code. Scoping Also, please do not define functions inside loops or anything else - it is poor practice. Simply define your functions and like all of your other functions. Naming Although minor, some of your functions and variables are named poorly. Consider the following: