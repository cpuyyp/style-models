Mutable ID is almost always a bad idea. I would remove this method form the interface and pass id directly to constructor. If you choose to keep this method, might as well make it into a property. 

Those are different concerns which should have dedicated abstractions. I'm not sure whether this is a real example, since it looks pretty simplistic, but if it is I would: 

should not have public constructor since it is only used in specific place with specific purpose. You can also consider just straight up using as your "builder". 

Do you need the reference in outer scope? I doubt it. After all, you already pass this same reference as parameter, so you should already have it. Also pay attention to . When you dispose it in block - you dispose the underlying stream as well. Accessing it later on will lead to exceptions. No, you should not, if all you do is writing to the given stream. implies, that you will assign a new value to passed reference parameter (meaning you will call at some point or something). Which is not the case apparently. It depends on use cases. I guess the best approach is to create multiple methods to cover them all. For example you can create another method, which would accept (file path) instead of a . And another, which would accept a . 

It is unclear how to use this class if I want to subscribe to two different objects that implement, say, . There is no way to tell which of the two values has changed. This looks like a pretty major design flaw, unless I am missing something. So you should probably either use regular events (so I can supply different handlers for different values) or provide "source" argument. Personally, I think first option is better. You should also consider using proper event aggregator instead of storing the list of listeners in values themselves. Also I think you should have an actual property instead of and methods. And you can make field read-only. 

You should only use bindings when binding to classes which do not implement interface, otherwise those bindings will leak memory. If you need a binding to your , then you should wrap it into . Same goes for collections and . Using plain ol' as will leak memory too. Singletons... just don't. Simply pass the service into constructors manually or using some container. You should avoid re-creating . Call and repopulate it instead, when you need to reload it. I think the simplest way to address your concerns is to share single of your games between the viewmodels that need it. This way you won't have to bother with synchronization. There are multiple ways to achieve this. For example, you could create a child view model to represent the list of games, and inject it everywhere its needed. Or you could re-organize your UI in a way, that there is only one place where list of games is displayed. Or you could even return from your service class, and expose it from your viewmodels (keep in mind the point #1 about bindings though). I think it is generally a bad idea to settings in property setter. Writing to disk can be expensive and it can lag. You should perform I/O operations either in background or when user closes the window. 

Some of those methods should probably be refactored into members (or extension methods) of class, but its hard to tell, without knowing the details. 

Which lookup is faster will depend on average array size and key type. Assuming this is still "work in progress", I don't think it matters at this point, honestly. Once you have a functional world model of your zoo, you can always come back, do the actual profiling and change internal implementation if needed. 

makes no sense. Why would method call internally? Shouldn't it be the other way around? Shouldn't method call instead? Those methods calling each other is the reason stack overflows. You can remove method, and call instead of . It will work just fine. 

Your recent questions give me impression, that you are purposely trying to to find new ways to mock C# syntax. :) You know this saying from MSDN: "code is read way more often, than it is written"? I think you have to keep this in mind, when designing those things. I would definitely have a WTF-moment, if I were to see in code. I then would have to go and look for and implementations in order to figure out what is going on there. I would rather have this: 

You shouldn't really create a inside your workers. Instead you should create single instance inside your queue and pass the same token to all workers. Then you can use inside method to send a cancellation signal to every worker. Also, instead of using , you should use flag. It is the other way around with worker threads. Those should probably be created by workers themselves, so you do not have to store them separately. Good job on actually ing the threads you create, that's a good thing to do. But the timeout smells. Are you sure that you are not hiding an error? If threads successfully join every time, then you should call regular without timeout, if they do not - that is something you should investigate and fix. Finally, you should pay attention to classes that implement . Nothing horrible will probably happen if you forget to dispose them, but still it is a good idea to clean things up yourself when you are done using your s or your s. 

If you manually specify all the test cases as in your example above, then I don't really see the advantage of passing multiple pairs to your method. Personally I find this version a bit easier to read: 

This will nicely cover both cases, and in my experience - that is how this patterns normally evolves. 

I don't see any obvious problems. I'm not a fan of extending though. It has enough responsibilities as-is, IMHO. Original implementation that used aggregation instead of inheritance was more straightforward and easier to understand. It took me a while to figure out how and interact with each other, pretty confusing. P.S. This type of consumer already exists in Dataflow: 

Check out MSDN documentation for complete list of LINQ queries. Note, that you can also calculate average value itself, using method: 

I don't "get" this whole syntax. I find it really hard to follow and maintain. I mean, yes, when you need to build arbitrary expression, based on some data (user-entered formula, for example) - class is useful. But in your case - you know the evaluation logic beforehand. Why use expressions at all? I would drop them while its not too late. A couple of regular methods will do the same job, while being a lot more... straightforward: 

Just make sure to do some actual profiling. I/O related operations usually do not go that well with multithreading. Also it might make more sense to refactor outer loop instead inner . The choice would depend on the sizes of and . 

This way one method should be enough in most cases. And you can either drop the class altogether or leave it as a pretty wrapper around or similar loop abstraction: 

I also would prefer extension method over other options. It looks cleaner IMHO. What I don't like is the word. Not only because the method name should be a verb, but also because its somewhat misleading. I think a lot of people will assume that class is the class that implements context object (anti-)pattern. But your class doesn't. For example, both sounds funny and describes what the class does. Win-win. 

It will throw a if was not enough to recieve the full message. You should handle this exception in outer code (where you call this method). If you need to wait longer - increase the timeout. This is bad code: 

If you convert your dictionary into directed graph, you should be able to do a topological sorting. Kahn's algorithm works fairly well, and is easy to implement, especially if you drop all the stuff related to actual sorting. 

You do not wait for inner tasks to complete, so it looks like you gonna be in trouble if they do not complete in 1 second, before the next tick of your "timer". I suggest you use instead, it will make sure that all tasks are finished before the next iteration. 

There is a lot of copy-pasting even inside class itself, let alone between the two implementations.You should move common logic to private methods. You can even create an additional class to represent infinite line. This looks a lot better, IMHO: 

I think you have some misconceptions regarding thread safety. Check out MSDN page about . Thread Safety section states: 

no longer violates MVVM and works well with DI. Also, prism uses plugin-based architecture. You define regions in your , and then implement independent modules, which are plugged into those regions at runtime. I don't see you doing any of that. I think you should spend some time reading prism documentation. If you do it right - prism will wire your views and viewmodels automatically based on convention and you won't have those problems. Personally, I hate convention-based design just as much as I hate service locators (including ). But if you chose to use prism, you should play by its rules. Fighting it or doing it wrong will only make things worse. 

Your code style is really inconsistent. As if you were copypasting code blocks from various places and didn't bother to refactor it. Part of the reason your code is hard to read. A somewhat accepted code style is: a) prefix field names with underscores, b) if possible use auto-properties for public members instead of fields and properties with backing fields what is ? what is ? no way to tell without digging into your code. You should use descriptive names. Using static fields in and setting them via non-static constructor is a mess. is not descriptive. What is length? If it is the length of , then why dont you expose instead? In my opinion is somewhat depricated. I would use and Linq-to-Xml instead. It would simplify your code. Though in a sense its probably a matter of taste. I think some light weight data base will do a better job in storing game mechanics then xml files. 

I think you need to implement a cancellation mechanism. In worst case scenario you will have to wait for almost 20 seconds for to return with no way to interrupt this operation, except for maybe aborting the thread (which is hardly an option). This might not be as important for server-side application, but it is extremely important for clients, who should always have the ability to close the application or cancel pending operation. In general, I think using is almost always a poor design decision, and it can always be replaced with a wait handle of choice. Edit: here is a simple example of cancellation, which uses tasks: 

No delegates involved and the code is much easier to navigate. Not to mention, that this will allow you to extract yet another massive code block from your oversized form. 

I think it is worth mentioning, that this design decision will bite you back as soon as you start working on localization. There is no easy way to localize attributes, because you can only pass constant string values to attribute constuctor. If localization is out of the question, then this design is fine, I guess. 

2) error is an error that your software cannot recover from. If you just swallow it in retry loop and keep going, then it is not fatal. 3) Delay duration should probably be a parameter and not a hardcoded value. 4) You can use operator instead of . P.S. I don't know what is and I didn't understand your use-case example, so I won't comment on those. 

Instead of using generic you can create your own small class to hold the data and give its properties meaningful names. Having instead of and instead of will improve readability. You can also add a property to represent the type of operation, instead of using as some sort of termination code. 

the name is ambiguous. Is it or is it ? Easy to get it wrong. I would just use regular - no ambiguity here. 

I'm not a fan of your usage example. The line looks really fishy to me. It looks like something, that should not happen in my imaginary web store, like some kind of error, which I probably want to catch and debug. However class hides this potentioal error completely and my application keeps working as if nothing has happened. Now, if is for some reason a valid value, then I guess its fine. Overall, class looks OK to me, even though I am having troubles coming up with a sceanrio, where I would find it useful. You could probably group public methods together though, it makes class easier to read. Also I think you are overusing operator. To the point where method's body becomes really hard to read. is fine when your function is a short one-liner (i.e. ). But you should probably use braces, when it is not (i.e your method). 

1) I would save constants (, etc.) as fields, so they don't take up extra space in already fairly large method body. 2) I think your use of is fine. However you can also rewrite it without . At first glance it boils down to: