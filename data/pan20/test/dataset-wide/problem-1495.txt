It might be suitable for something like a homework exercise in a data structures class, but my biggest objection to this is you've tied everything to sorting the entirety of a . One of the strengths of the STL iterator approach and what you might find in the header is that you can fairly easily replace the backing data structure. If you specify the data to be sorted as a "begin" and an "end" iterator, you get all this for free: 

According to comments in , correct use of the library requires the caller to initialize the member being called: 

This also brings to mind... Why a vague name like ? C does not have namespaces and this is a name that could clash with others. Maybe it should be . Also more consistent with some of your other function names. 

A few random points: I find it a little jarring that holds a as a member. In general when writing/reviewing C or C++ I like to be able to quickly answer questions like "who releases this object, and when?" By holding a potentially-dangling the way that you're doing, that ownership of resources becomes ambiguous, and handling deleting the objects in a safe way becomes tricky when you might have another thread working with it. I would consider a reference-counted smart pointer like . It's also a bit weird to me that is tied to method pointers. For more generality maybe should just be a template parameter that handles , then you can provide multiple implementations for this, including one that calls a method pointer. Maybe something like this: 

Interface critique: You should have the caller specify a maximum size for the destination buffer, and error out when there is not enough space. The mark of a good C programmer is to create interfaces which make this sort of condition unambiguous, rather than blasting away on the buffer, potentially past the allocation size. 

As you can see, shorter, simpler code and no allocations. It's also not so hard to implement your more allocation-heavy approach in terms of this, either: start out by duping the caller's buffer, then iterate through this function. 

Looks like you've successfully avoided the "leak on failure" issue that traps many newbies. (Update: Sorry, must have suffered temporary blindness, you do leak here.) But I think this is too verbose. Why do you need to maintain as a double pointer? You already have . 

My improved version follows, taking most of these suggestions. I've tried to keep your code mostly the same and follow the same style. 

Seems like you missed a potential here. If the buffer is exactly full when you hit that line, you'll write past the allocation. 

Others have told you how to exploit this. In the spirit of advocating the right way to do things, here is a good way to execute with user input and not have vulnerabilities (barring of course some bug in echo :-)): 

If you are not religiously opposed to (this probably makes more sense in C than C++), this approach is also common: 

On the topic of heap allocations... It seems like every operation takes 2 s and does a new allocation for a return value. This is a bit subjective, but that seems tedious. What about an interface which takes two operands, where one is also a destination? (Like many assembly languages..) Or perhaps 2 source operands and 1 destination. (Like RISC.) Each operation could see if the destination is big enough and possibly call to grow the buffer. But the caller would decide to free the operands, and you'd probably get plenty of buffer re-use. 

You're right to suspect the , lines, but I'm not sure "leaking memory" is the worst of your problems. If you pass one of these "offset from the original allocation" addresses into or , for example, you're likely to get crashes. The way it usually works under the hood is that at an address just before the buffer, and friends sneak in things like the allocation size, so it can maintain its own data structures ahead of "your" buffer. (It's not guaranteed to work that way, but this is most often the case.) The important takeaway is that if you call , save the original pointer so that you have something to pass to . For that particular issue I would recommend one of the following: 

The problem is that the object being used to synchronize is re-assigned. That means a subsequent caller will acquire a different lock. It's conceivable that two writer threads hit and each see a different lock, but end up adding concurrently to the same hash table, which is a harmful race condition. There are also more subtle problems if two threads are both calling and a third thread is inserting. You should do something like this: 

Technically the C standard says you can't name things with leading underscores. In practice your compiler will let you get away with it anyway. But personally I think it looks weird. If your intention is to hide internal functions from the outside would I suggest you declare them with and/or add some prefix to their names. Speaking of names, this brings me to another point... I would work on better and consistent naming conventions. Overall I would strive to have someone be able to read the header, as well as code that calls your library, and have some clue what the functions do. In C it's common to prefix functions from a given library or module with some common name, i.e. having to do with the type. 

This is a common portability pitfall. A cannot represent the full range of characters and also . Depending on the environment you may not be able to distinguish between and byte 255, or you may not be able to detect at all. Store the result of in an , because that's what it returns. 

Why do you need this? Your loop termination condition is already , so the check almost seems redundant... Now, it does seem like the upcoming and will create problems omitting this, but I would rather re-arrange those than make this loop look overly complicated. Just my opinion. YMMV. 

Not to mention, these rules could potentially be subject to change. Note that Win9X had different rules than NT. What if such a change occurs again and breaks your logic? Don't bother duplicating these rules in your code; don't second-guess the filesystem either. Just pass the name to . (Aside: If your filename happens to come from an untrusted source, then it probably is fair to be overly restrictive...) 

It has been commented that when working in C++ you should use . Assuming you want to stay with C style strings (or at least understand how you ought to work with them, in case you ever have to), I have the following suggestions: 

Note the only weird thing here is the ownership of 's allocation. If we succeeded in creating the thread, the thread routine deletes it, otherwise will. To make this sort of thing exception safe it might be advisable to wrap that allocation in RAII, but for this example it is not needed. Then notice with a quick rewrite of you can actually avoid the method pointer call entirely while still maintaining a lot of source code flexibility to change or re-use the thread creation routine: 

can return . In this case the next line will dereference a pointer and crash. You should check for errors, then return some kind of failure status to the caller, which the caller should also react to. You also have a which does allocations but no corresponding which frees it. Come to think of it... Does really need to allocate? Maybe it should take a caller-allocated buffer. For example an interface like: