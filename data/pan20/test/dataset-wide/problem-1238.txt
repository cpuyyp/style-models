If I were to improve on your original solution, I will use to eliminate one nested and inline the arithmetic comparison together with incrementing as shown below: 

You can create a to store the words in the your first file, and use operation to retrieve the desired element when reading your second file. Full suggestion (by breaking steps into methods): 

Pre-Java 8, only offers a handful of extra methods, more notably such that sometimes you may see it in use solely for that, in a single-threaded context. Now that you're on Java 8... 

The only value I need to store first is . It is a good naming convention to begin variables with . Inside the part, allows us to switch between the correct error description. As mentioned above, we will only encounter the 'Page synchronize failed' case when the condition holds for but for 'current page'. Or you can simply read it as there is no test data generated, hence that error description in the clause of the conditional operator. 

The first part is well-understood I hope, the "in this context" in the second part refers to whether to call depending if is . Should you have additional logic in the current code block that depends on that condition, then yeah I guess it is also ok to be doing the explicit check before calling . However, you may then want to consider how to better handle multiple checks... 

You can probably externalize as a field. I was about to suggest -ing the single-character instead, but let's stick with consistency when you have that. 

I don't have much to comment on your more specific questions, but I figured I can chime in a little on parts of the code. 

In addition, consider storing just the difference and the array index where you have the smallest difference, so that you don't need to remember . 

Inside your method, the code then becomes more readable (some small changes to your variable names): 

Assuming if we're talking about the same SDK, then perhaps the worry that you'll need to support 100+ s is unnecessary... or you should really consider switching SDKs if you/the library developers do get to that stage. s values are ordered (hence the method), and the ordering the SDK uses seem to be: 

Looping once, aggregating multiple values Inside , now renamed as , you are streaming twice on the argument. While this shouldn't be an issue for most cases, there is still an option to just loop once should it be one of the remaining places to optimize (hopefully with some runtime analysis/micro-benchmarking to prove it). This is achieved by creating the instance yourself (instead of relying on ). To avoid similar calls, you can also get a reference to it once. Putting it altogether: 

If a is not found, you can use your debug statement, else you can have the returned each and the given . methods On a final note, you may even want to reconsider the design of your methods for sending JMS messages. Assuming the only differences between them is a queue name, you can have just one method that takes in the queue name as a method argument, so that you don't have to manage similar code across many classes. 

(I have taken the liberty to change to to eliminate some auto-boxing.) Using interfaces or lambdas is still ok, but I can't help but feel that these will be overblown solutions for a small piece of logic. As illustrated, is used as a secondary condition after since is the encompassing condition for both. If an exact match is not required, the primary condition will satisfy, else we will also perform . The downside is that two comparisons will be done for , so if you have some really strict performance ceiling and this is indeed one of the last bottlenecks to eliminate, then you should just use a simpler statement to switch between the comparisons to perform. Step 2 The next refactoring step that you may want to consider is to abstract the double- pricing logic somewhere else. The other answers suggested putting them into a method, but can they be regarded as to sufficiently 'belong' to the class itself? If so, the body of the clause above can be simplified as such: 

Since the body of this method will only throw (most of the called methods) or (), I will suggest throwing these two specific types rather than a generic . First, other reviewers or developers will understand the exact nature of the possible s that can be thrown from this method. Second, should further changes in this method yield more checked s, you will get a compilation error first as a heads-up. 

There is no way around it, but is too lengthy... you should consider breaking it down. For example, you can consolidate your UI elements in the following manner: 

Checking for consecutiveness A simpler check is to make sure that the absolute difference of the cards' values is 1: 

is what I call a 'magic' method, as it is not clear from this usage how it is ensuring the object is usable on the next line. Assuming that you are already using the recommended practice of pooling your JDBC connections using a well-tested pooling manager, it will be better to make this less magical: 

Java 8 stream processing A can be your friend here, as you recognize you are doing something similar in both: 

Override Oh yeah, given how you want to print the contents of objects in the end, why not just override too? :) 

I should also use my to handle the display of inputs, for example I can have the following two helper methods in the : 

You can consider either restructuring how the method calls are made, and even the names themselves... comparison 

Rationale: Consider when you have \$n\$ products and a result for each of them. Your current solution will effectively be iterating through them, and iterate through the \$n\$ results for the one matching product. Therefore, you should start with grouping your results first by the product ID, so that the retrieval later via the interface will potentially be more efficient. Process the product list as the final step With the above map, it's just a matter of looping through your products and creating an instance of with the customer details, if present: 

Inconsistent use of braces here, I'll suggest using it throughout. Using to do logging is a poor choice here, as the logging feature should be abstracted away to a logging framework. With that, you can optionally turn on/off messages on a per-level basis (e.g. for development, but for production), or even change the formatting. 

A : Possibly simpler to understand, at the slight expense of not being 'resource-efficient'. This is a stateless operation. A : Appends the conversion result to a supplied to minimize object instantiation. This is a stateful operation on the . 

Is the use of a for storing the tokens deliberate? That's because you can only have unique elements in the , and the output of the following code snippet will be 1, not 2: 

I think @SharonBenAsher's answer is a good starting point for your actual question. I'll instead focus on a few other areas. :) Declare to the appropriate types, preferring interfaces over implementations 

P.S.: I usually prefer using TestNG's annotations for parameterized testing, but I figured that telling TestNG to iterate through all the dates since 1st January 1 AD may be too much... hence the manual looping in each test method here. P.P.S.: One very minor point, if I were you I will also consider putting the two validation statements in their own validation method. 

In these cases, you don't need temporary variables outside of the utility method to add them to the . Method and variable names should also be in , so that they are not confused with class names. This means can be better renamed as , and the class variables can be renamed as as well. Again, if you feel not using the short forms lend the variables more context, then you should use their long forms too. Miscellaneous I think there is room for improvement for your code formatting inside the method. For example, having indented lines makes it easier to understand that they follow the preceding line: 

This is arguably more efficient as both and are performed once on the arguments. The lesson learned here is that doesn't play ball with most control characters (seemingly is the only exception here). For some reason, -ing on 's output is still introducing minor quirks in my own testing, so I'm leaving that out for now. 

Do you need the two-liner comments here? It's quite clear these are variable declarations, and 'do not modify' seems superfluous. Java 8, and Swing vs AWT (both are related by the understanding of the language features you have here) You are using Swing-based UIs, but interestingly you are coupling them with AWT's mechanism of event-handling. I am not sure if this pairing is intentional. On this topic, you can also consider using : 

Instead of duplicating the code, you can introduce a method that accepts the relevant , the and the to standardize the lookup code. Again, instead of using a temporary variable in , it will be shorter to simply return the result of performing the operation. Also, as you should know, Java 7 supports type inference for generic instance creation aka diamond operator, so you should use consistently, where applicable. 

A is just a straightforward implementation of the interface, so declaring the return type of as a will work equally well. In fact, it is better in the sense that callers do not need to know they are interacting with a specific implementation, and that gives you some leeway to change implementations in the future (not a strong point, but nevertheless a valid one). Of course, by changing the method return type, you will likely encounter breaks around your codebase as a can't be casted into a reference, but I think this is a clean break to have. 

Instead of putting the logic inside , you may want to consider abstracting them to be part of the enum. This brings the logic 'closer' to where it is used with, i.e. the base/target scales. For example: 

Using the second approach as the foundation, you can attempt to parallelize the process by adding the , and if you are OK to drop the -handling, a tweaked solution can be just: