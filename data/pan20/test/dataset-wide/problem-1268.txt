The benefit is that if you ever rename text, your refactor tools will update the second example, while commonly, they will miss the string in the first example. by default As a general rule, I seal classes unless it has been specifically designed for extension. I could go into explanations why, but smarter people than I already have. Final code: 

Initially, I shared your concern over resource disposal. My assumption was that there was the possibility the command could be left hanging around in cases where you did not enumerate over the entire collection (as with something like FirstOrDefault). However, a few quick tests with a test project reveals that the using statement performs its clean-up as soon as you are done with the enumerator. A LINQ statement or a foreach loop may only partially traverse the results, but they both still clean up the enumerator when exiting scope. Keep in mind, though, that there is still potential confusion that might arise from the deferred execution of GetSomeData. The command doesn't execute until you start enumerating the result. If anything were to modify the data before between the time you call GetSomeData and when you enumerate the result, you could get different results than you expect. 

One aside to mention: you should split your UI and business logic code. For the sake of tossing it into a working example quickly (I'm doing this over lunch), I removed all the UI code and replaced any print-outs with calls. I also did a little refactoring to split method calls. Additionally, I renamed to so I could run it side-by-side with the original. Finally, I made some of the non-static method static, but only to speed up running the project. Pay no mind to these changes. 

Have you taken a look at the System.Data.SqlTypes namespace - particularly SqlDecimal? Building on some of the other answers, you can use and the operator as follows: 

If you are always using the default port, you can omit the assignment. According to the WinSCP API Doc, leaving the port to the default of 0 will cause it to use the protocol default (22 for SFTP). Keep in mind that always is not always always :) Session Creation 

Additional Notes Naming is one thing you may want to look at. The class is called , which only describes the data structure you used, rather than the purpose of the object. You are using it to store words, so my first reaction is to call it a Dictionary, but of course, that name's taken. Naming is hard :( Also, it seems a little odd that you scan for words with a method and you add tokens with an method. The latter bleeds implementation details to the caller - why should they know there are descendants at all? I would probably use and , but I leave final judgement to you. There's also the use of in your method I would love to replace. However, since I am out of time on my lunch break, I leave that to someone else. As far as performance goes: use a profiler. I could take a crack at the performance issue you mentioned, but all I would end up doing is profiling it myself. 

However, my suspicion is that the biggest gain you will get is implementing your own tag reader library rather than using TagLib, assuming you are correct that it reads the entire file. I/O is one of the most expensive things you can do on a computer. ID3v1 and ID3V2 tags should generally appear in the first X bytes of the file, so you only have to read until the end of the tag, rather than the entire file. As with any performance issue, though, you need to run this through a profiler. The results may very well point you in a completely different direction. For example, it may reveal that TagLib isn't actually reading the entire file. At the very least, it provides baselines to use in determining if you are making meaningful gains. 

(It was thrown together quick just for quick turn-around sake.) I then provided 3 ways of loading. One loads the data much like you did above: 

Implement IEquatable<T> Generally speaking, whenever I find myself writing overrides for and , I also make the type implement . It's generally pretty easy to do so by calling the method from the override: 

If you want them to retain the same organizational hierarchy they started with, you can do something similar to the following: 

Adding more test cases is just a matter of adding elements with new data and re-building/re-running. The How-To MSDN page can be found here, and some examples of DataSource configuration strings can be found here. Just to give you a taste of this in other frameworks: NUnit TestCase 

Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

Now, we'll need something to keep track of the inventory levels. We could use a simple for this, but let's go ahead and abstract it out into an class, so that we'll have a place to put some convenience methods. Since we know we'll need to be able to remove an item by name (not caring about the price), we'll need some help to find that entry. We can also add some convenience methods around adding a product. 

will exit at any key; you want to change your message or change that to to require an . AppCoordinator Your class is a major code smell; it's a (no offense) terrible name that really doesn't describe what it's doing, and is likely to become a "god object". I would rename that to or or something. Since this is your largest class, the meat of my comments are here: 

So, I'd suggest it'd end up looking something like (it's been awhile since I've written straight ADO.NET, so there may be some minor issues here): 

Ok - that pretty much gives us our product management functionality. Now, on to UI. You've got the right idea here - console input/output should be handled generically, so let's expand on that idea and write a few generic helper classes. A good way to think through this is figuring out what portions of what you need to do are specific to your app, and what is a generic concern. You should try to split those as much as possible. These won't have anything to do with , so they'll be reusable in a different console app. 

Ok, now we have enough to get to refactoring the class. Currently, your class has too many responsibilities - it's showing the menu, tracking the current state, and adding/removing products. We're going to trim that down to just showing the menu and tracking the current state: 

For file IO, the way you're currently doing it (saving after each add/remove) you could add it as part of : 

Now, each filter simply takes an input and transforms to an output. We need a pipe to tie to it all together: 

If you're familiar with inheritance, hopefully you can see how you could add that functionality into a 'PersistentInventory' subclass. Hopefully, you can see by splitting the functionality out cohesively both readability and maintainability. Think through adding the following functionality in v2 of your app with the various designs: 

Once you have the of the integer portion, you can use the format specifier to get the correct number of decimals, which would clean up the string building part. 

I think a plugin architecture would be a little overkill unless you're interested in versioning or deploying the sub-modules separately. You haven't shown the sub-modules (the actual solvers) but I'd probably define an interface for them and then use a instead of the statement. Really, it's pretty minor, but I see a couple of advantages of the : 

Note the weak typing of using - if these classes are used somewhere else, implementing as an explicit interface would probably be preferable. You could do generics, but that makes the chaining harder. 

This is basically a pipe and filter pattern - where you construct some number of filters into a chain and just pass the outputs to the next filter. If you control all instances, then the simple thing is to abstract out to an interface: 

You can over the directly, getting a . Or you can over and just get the . Either would be preferable to going over the just to get to the (and you don't check the return of ). I'd also change the name of your variable since the trailing implies that it's multiple dictionaries (FWIW, I'd probably go with just just so I didn't have to ever read a potentially offensive word over the phone; but that's just me!) 

Well, you can certainly make it easier to read by cleaning it up a little bit and getting rid of the extra () loop, and substituting a and for the inner () loop's concatenation: 

Ok - now we've got most of the pieces, we just need to put the actual program logic together. Let's move on to the method: 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

Couple of quick comments, since you don't really specify what you were looking for. Seems like everything other than should be ; I probably wouldn't make them extension methods either. I think the whole thing would be better suited to a rather than 3 or 4 coupled methods. Your recursive is an odd implementation that I haven't seen before. It looks like it'd work OK, but doesn't seem standard. Your method seems broken; it never adds the ; I'd probably just replace that class with a or something since it doesn't seem to add much value but could be a breeding ground for bugs. No reason to on ; just return the generic . What happens if or is ? Looks like a , when I'd expect a list of all the added or deleted instead.