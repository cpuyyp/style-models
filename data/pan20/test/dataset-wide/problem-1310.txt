You need to separate the logic of the game from all other things. Create a bunch of small, reusable, testable methods. For instance, you need to check if the player can go to a specific room. Good. Make it a method. Name it properly (for instance, ). Write unit tests for it. Identify the next small reusable component. Create a method for it. Keep doing it until the code becomes testable and readable. One class should have one well-defined responsibility. Your class does too much. It stores everything, including the location, items and so on. Move things to where they belong. Create a class that stores the current position and processes all movements. Create a class that represents a bag of items and handles all operations for items (like finding a new one or using an existing one). A rule of thumb: you should be able to describe what instances of the class represent without using the word and. The same goes for methods. Create separate functions or classes for displaying the information to the user and reading her commands. It has nothing to do with the logic of the game. Keep the concerns separated. Using expressions like is a terrible practice. If something is a bool, treat as such. It's just . Get rid of useless comments. They shouldn't tell what the code does. Ideally, the code should be self-documenting. Comments or are far worse than no comments whatsoever. They're litter. Burn them. It would be nice to load the game config (rooms, items and so on) from a file instead of having them hard-coded in your application. It'll make your app more flexible and readable (those long declarations occupy a lot of space and clutter the code). At least move them to a separate config file. Don't mix the logic with them. 

There is no need to use the keyword in the class. All methods are , so it is thread-safe(it is guaranteed that only one thread can execute only one method at a time and all changes made by this thread are visible to other threads that execute any method of this class in the future). 

The time complexity of the method is if the list doesn't support random access because each call to takes time. One can fix it by using two (one going forward and one going backwards) to reverse a part of the list. There's no need to create separate and methods. You can always take the shift modulo the size of the list (in mathematical sense, without negative results, not in a sense of the operator ) instead. 

Taking into account that it requires that an element is present in the graph, we could simply write it as . And here: 

Your algorithm is very far from optimal. In the worst case (if all numbers are equal to in the input), it does operations, which clearly way too much (not just for python, for any programming language). What they're asking to compute is , where is the Euler's totient function. Using the fact that the function is multiplicative one can derive a formula . Using this fact, we can compute it efficiently in time for all using something that looks like the sieve of Eratosthenes. After that, we can answer each query in . A C++ implementation is ridiculously concise and easily fits in the time limit: 

There's a very serious architectural problem with your code. There's essentially no separation of concerns. The logic of the game is intertwined with user interactions and the game configuration. It makes the code: 

That's actually wrong. Let the array be . Your solution would take the whole array as the maximum during the first step (the sum is 11) and remove it, leaving an empty array, so it would return 11. But that's not correct. Two subarray [0, 1) and [2, 5) add up to 12, yielding an optimal solution. It also implies that your solution to the stock selling problem is also incorrect (a counter example can be constructed in a similar manner). You can use dynamic programming to solve the problem correctly. There's a constant number of states in each layer, so the extra space complexity is constant (the code is in python, but it should be easy to implement this algorithm in any other language): 

is kind of useless. There's , which does the same thing. You can make the design more flexible (and more standard library-like) by passing an output iterator to the and function instead of creating a new container inside the function. It's useful if the user wants to write pairs that represent groups to an existing container or to a C-style array. 

First of all, using a pool to make it easier to work with memory is a bad idea. It definitely doesn't make it easier. Your code is quite non-trivial. If you want to make it easy, just stick with standard containers and smart pointers if you really need them. Odds are, you don't need any pointers at all. For instance, why can't be a map from an to ? Why can't you just create items without dynamic memory allocations? It's not clear from the code you've posted. A valid reason to use a custom pool would be performance. If standard containers are too slow for your application, you might need it (but again, I'd recommend implementing it without manual memory management and measuring the performance. You'll save a lot of time and effort if it turns out to be satisfactory). You also seem to maintain some kind of linked list of free items. Why not use instead? Are there any good reasons not to use it here? I don't see the point in reinventing the wheel. This part: might be incorrect (I can't say for sure as you didn't post your class). Not all objects can be copied byte by byte. Do you have any reasons not use instead? To sum it up, I'd recommend to start with standard C++ containers and algorithms first (they are efficient for most of the practical purposes) and try to change something only if you run into performance issues with them (Again, measure it. Don't assume that they'll be too slow). It would be great if you can avoid manual memory management altogether. It's very easy to get it wrong. It's also quite possible that your custom solution turns out to be slower than standard C++. 

The code is much simpler and more efficient. To find the path itself, we can just iterate starting from the destination vertex and going to the current vertex's parent until we reach the start vertex. This way, it requires a linear amount of time and space. The code itself is rather obscure, in my opinion. Why do we multiply something by -1 here: (probably you do it to "reverse" the order, but it's not that clear when you read it for the first time)? The fact that is actually a weight of the edge is also confusing (I would expect to see something like distance or weight in the name of the variable if it stores the length of the edge). By the way, depth-first search works with unweighted graph, so I don't see the point of storing the weights, anyway. 

About thread safety: it is not thread safe. There is nothing that prevents member-functions such as , and others to be executed by multiple threads at the same time. Inside these functions several variables are modified. Modifying them from multiple threads without synchronization is an undefined behavior according to the C++ standard. How to fix it? The easiest way to do it is to use one for the and member-functions of the class(acquiring it in the very beginning of the function and releasing it in the very end). It is convenient to use an for this purpose. Something like this: