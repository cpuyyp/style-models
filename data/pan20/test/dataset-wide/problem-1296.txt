There are times when it makes sense to have some sort of class whose instances are objects that can perform a bubble sort. This is typically when the algorithm might need access to some precomputed data, or maybe to acquire resources that will be reused through several invocations of the algorithm, or hold configuration options, or is keeping track of performance metrics, or other such things. (but this pattern has its own advantages and disadvantages and there are other patterns that can be used to achieve that effect) However, this implementation is very much not one of those times. 

Note the use of and for yielding results. Using generators has a number of advantages including: you get to see results as they're created, you can stop iterating when you're happy with a result, rather than having to wait for the entire recursion to finish, you don't waste memory/time creating a list of all the results. Generators take a little bit of time to get used to, but they're well worth it, and should often be preferred to returning lists of results. Finally, one last neat trick; the general pattern of "make a change ... do stuff... undo the change" can be error prone; it can be easy to forget to undo the change, or an odd code path (e.g. an exception) skips the change. The other answers suggest making copies; however, backtracking algorithms like this can often suffer massive performance penalties from such a change, so it's worth knowing a pattern that mitigates this problem without introducing copies. We can use a context manager to do this automatically, such as below. (this post is not meant to be a tutorial on context managers) 

The 'click' can be replaced with any event of you're choosing. This gives you enormous power and control when setting up custom events. 

That just makes the syntax so easy to remember as well as provide you with enormous control over your events. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how they are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you understand how it works and you can contribute to jQuery. 

Here are some quite general pointers on your code. If you put up a fiddle with everything working, I might be able to play around and re-write this for you. But anyways, I've included my comments directly into the code to provide some context: 

would be better. In fact, you might consider doing something different: you could pass around by value rather than by pointer. Passing these objects around with move semantics may turn out to be more efficient. (you should probably explicitly deleting the copy constructor and copy assignment, to indicate that they shall not be used that way. Although this will automatically happen implicitly if you follow my advice and change to be a ) 

This advice is likely to be somewhat controversial, but Explicitly flush when output should be available 

Making a local variable will likely result in a performance increase. It would also allow multiple threads to safely invoke concurrently. Similarly, making static will increase performance. Not directly, but because the current design will tempt an application to create new objects all the time whenever it needs to perform a sort. 

You are using a reserved name due to the double underscore; you should adjust your naming convention for header guards (e.g. only use a single trailing underscore). The relevant passage from the C++11 standard, 17.6.4.3.2 , says 

- Save a function calls: If you read the jQuery source code you'll see that shortcut methods like , , and etc. all reference the method. All they do is basically call the method with some parameters. Well why not just go straight to the meat and potatoes? Check this out: 

The way you have your function set up, you're appending and changing the DOM each time that loop goes around, and it goes around for every image. That's not good because DOM manipulations are quite expensive performance wise. So if you have 100 images, you're append one at a time - 100 times. The better way to do that would be do all your stuff and save to a variable, string, or object, then append once outside the loop. Here's an example of what I mean: 

That just makes the syntax so easy to rememeber as well. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how you are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you know how it works and you can contribute to jQuery. In your click functions you also might want to prevent the default browser action on a link, which is to direct the page to that link. Since you just want to perform something on your page and don't actually want the browser to leave the page you should prevent that action. You can do it by passing in for and running . I see you've used which does that, but if you want to read more on the difference between the two I would suggest [this article by Chris Coyier][1]. -Playing with visible elements: You're if statements from what I can tell are trying to detect scroll position and etc. I highly recommend you check out [this tiny plugin][2]. It basically detects if an element is visible or not at any given time. This may or may not help you out but I just thought I'd throw that out there. -Performance Wise: Focus on the event for now. The way you have it now, the code runs hundreds of times since it is called each time the window scrolls, even if the user isn't done scrolling. That's an increadible ammount of times your code will run for no reason. Not only that but then you run code on each element with the class of - more code that gets run. Now we don't want to do that since it can really slow down the browser, if not crash it all together. What you'll want to do is wait for when the user stops or is done scrolling, then run the code. 

Finally, one may dislike the fact that useful functionality is buried in nested functions; we can pull the nested functions out: 

There is a better way to implement the design you seem to be using. Rather than generating numbers and storing them in a list, just generate the numbers: 

I'm going to focus on implementing the recursion. First, let's avoid the globals. The easiest way is to keep the same structure, but move it into a local namespace: 

One issue is that your function is four functions in one. The problem is that they are four unrelated functions — yes, they all have the job of displaying results, but: 

Generally speaking, buffering is good for performance, so it's better to write newline characters rather than inserting when you don't actually need flushes to happen. As a bonus, they're less typing and usually easier to read. Of course, I/O performance is basically irrelevant here because the human delay far outweighs any other concern — but it's good to get in the habit of writing what you mean early on. Thus, the above code snippet demonstrates the general pattern: I use newline characters to write newlines, and I do something to flush the stream at the point I want to ensure that all of the output has been written. Using to do the flush isn't an option here, if I want the flush to happen at the right place! 

Depending on when you want to make the ajax request, you'll need to modify the first line of my example. Currently it just gets all of them. You might want to change it so that it gets only the div that was clicked, or whatever. Anyways here's one way you could do that: 

It was fun going over your code. I haven't played with 1.4 for a while. Well here are some suggestions: 

I wouldn't rely on to protect your code from other libraries that use the as well. - Click Event Handler: As was mentioned before, there are several ways to set up your events. The ones that were mentioned were and . The method simply calls the method and passes in the click. The method is incredibly useful since you can use it to set up almost any kind of event - not only clicks. So yes, the one you are using now is "the best" because it saves you a function call. Now saving a single function call in your app won't be a significant increase in performance and you probably won't even notice it. Although arguing over such a small and possibly insignificant changes is really what we developers do best. Using the method directly is hands down going to be faster, but there are many other things you could be spending your time on that will generate more significant performance results. - Don't re-invent the wheel: I strongly believe that if there's a working solution out there by all means use it. There are tons of tabs and accordion plugins available I'm sure you can find one that fits your project. If you can't find an exact fit, you can still always tweak it and make it fit. jQuery it self has an entire UI package with tabs, accordions, sliders, and all kinds of cool stuff just ready and waiting to be used. Also the jQuery UI will let you use your own CSS files and customizations really easily. Making a whole new app from scratch should be done if absolutely necessary, or if you're trying to learn (which is your case). Back to the subject of learning, like you said, you are just starting out with jQuery, and with that I highly recommend this screencast by Jeffrey Way called 30 Days to Learn jQuery. He does a really good job of explain some basic principals as well as some more complex concepts. One thing in specific I'm going to point out is the following: 

If you feel it's important to write the code so as to start with an empty list and extend it, you could instead use 

While some would advicate relying on the implicit flushes coming from being tied to , my own observations are that: 

In the source code, you can collapse a lot of the output statements to improve readability and so that they take up less vertical space. For example, 

I've mainly just made a function sets up the right arrays, and then converted the original implementation into the nested function . Notice I've created a array for storing the results. Also notice the need to make a copy of the potential answer when storing it as a result, since we will continue to modify . I've also modified the list of words so there is more than one result. I assume you want to obtain all answers; it shouldn't be hard to modify this to end the recursion as soon as an answer is discovered... however, a better approach will be described below. Given this change, the arguments to are redundant: it can be changed to the following. (if you're really serious, you should profile this change, to determine whether it actually makes things faster) 

When you have code that repeats itself like that, you want to try and separate the logic from the values. Something like this would work, and you just have to add more to the settings object when needed. It's not jQuery that's badly written, you just have to change the way you're using it. $URL$ 

In other words, if you have content that is related and goes together, put them in a section. Example is a heading section. Do this as long as you have actual content that will go in the element and you're not just using it to style your page. Now for the article element: 

I'm going to go through a few main points here about your code but don't be overwhelmed by the size of this book, I prefer to be on the side of too much information than too little. - Cache your selectors: Probably the most important thing you can do for your code now. As a rule of thumb, if you use a selection more than once, you should cache it. What happens when you use is jQuery queries the DOM to try and find elements that match. So imagine that every time you do that it runs a search. Would it be better if you could save the search results? This way you can look and play with them whenever you want without having to look for them again. Ex.: 

So, in my opinion, the better habit is to flush explicitly rather than relying on implicit behavior. (the opposing opinion is that one should be much more afraid of the second bullet than of the risk of confusing/erroneous output in the edge cases) This program, I'm pretty sure, is an example of the first case, where it doesn't actually matter. 

and let manage the allocated memory, rather than managing it manually. Similarly, in , you have declared 

The usual way to implement the algorithm you're using (the sieve of Eratosthenes to find all primes up to a chosen bound) is to make an array of boolean values, so that means is in the list, and means that is not in the list. The point is that removing an element from the list only costs time, so it can be done much faster than erasing an element in the middle of the list. (and also, you don't even have to bother checking if the element is in the list before you remove it) 

You're on the right track by setting up the options variable. This concept will be vital when you start to develop plugins, if that's what you want to do. - IIFE's: If you have your code in the footer (which you should be doing) what you'll want to do is wrap it in a IIFE. "What the hell is that?" you may ask. A basic syntax looks like this: 

OK so use an article when you have stuff that goes with your site but is independent from the rest of the page. If you use an article element within another element, that article element's content should be related to the parent element's content/stuff. From what I can tell your it for styling and positioning, so it should remain a . You got that sidebar element well, and the content inside is should be in the element itself, or if you have content that is groupable and related, then a element inside that would be appropriate as well.