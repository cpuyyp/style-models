There are already great answers that focus on code style and trip-ups, so I'd like to approach from another angle: as a potential user/debugger of your code. Add/Subtract are not inverse operations While clamping the values is attractive for the security it seems to give us, it also endangers the Principle of Least Surprise. If I have 500p and I add 800p, I end up with 999p (and 99g99s99c). If I then subtract 800p again, I do not have my original 500p; rather, I'd have less than 200p left. If you're concerned about how to display large amounts of money in a limited space, the component in question can figure it out. Perhaps it could progressively leave out copper / silver / gold coins if it needs more space. If I have that much money, I wouldn't be worried about how many copper coins I have. ;) No feedback on failure (I am not a C# programmer so I may have this wrong.) It appears that I can subtract 50 coins from 20 coins and end up with 0 coins. This surprises me. If a function cannot do what it claims to do (or seems to claim to do—tricky), it should signal the fault in some way, like by throwing an exception. HasXYZ vs GetXYZ In the case where you have 200cp or 2sp, which is the same here, HasCopper() will return because it also checks HasSilver(), but Copper() will return 0. It feels to me that HasCopper() should imply Copper() > 0, so either HasCopper() should return or Copper() should give the total worth in copper coins (200). Simplify or Go Big My base advice would be to either: 

Once you have potentially valid types, it's time to figure out how to instantiate and present them. Reflecting on what you found So suppose you have a list of classes that extend and we may or may not be able to accommodate. Unfortunately, won't help us here: to be overridable, it needs to be an instance method; to use an instance method, we need an instance. Egg, meet Chicken. Much like we'd do with JavaBeans, we can gleam some information from your classes using reflection and convention: 

1 (Note that I opt for interfaces here; I tend to go with interfaces when I'm designing/freewheeling, and later on decide which ones will become classes. seems to be duct tape holding related values together, so it's a good candidate for being a class.) Now, if we later decide to add functionality--say, we add a flat addition bonus--we won't need to rewrite our Hero interface and add three or more methods. But if we want to add another attribute? We'd still need to change the Hero interface. Hrmph. This is where enums will come in handy: 

Depending on your use case, you can also consider a different approach (*). Right now, you generate all possible combinations before returning. If you don't need all combinations at the same time, this may be overkill. (If you do, then making them all in one go is probably the most efficient.) 

[1] Oh, how sweetly I loathe you, , for your 1-based indexing. [2] Fixed record length + multi-byte encoding + JNI. It was glorious. [3] Personally, I lean towards "fail early, fail hard," (i.e. throw) but this depends on your intended audience. 

These questions try to test how you translate problem information into your solution. Brute force, while sometimes the practical answer, is rarely a good interview answer. The recursive approach is a good way to go about it: the solution is simple and efficient in terms of operations performed. As an interviewer, I would be content with the code given. I would, however, ask about two things, just to probe: 

Going through 10 million randomly generated activities took about 4779ms versus the initial 71183ms, sorting included. You can shave off some more time by giving the roster an initial capacity (like the 40000 you mentioned). With many activities and many time slots, we may need to set up a balanced interval tree. I'm not sure if this is within the scope of your course. 

The two main issues I see are not really code flow related. One is that you don't really have a protocol to communicate with your clients (as in, reporting success or failure, interpreting commands, et cetera). The other is that your server may be prone to stalling. Your serving loop looks like this: 

There are solutions that take fewer steps. One could attempt to improve the current solution by shrinking the possible ranges. Given: \$c^2 = a^2 + b^2 ; sum = a + b + c\$ Neither a nor b can be larger than c. This also means that neither a nor b can be larger than half the sum. For c: it can't be smaller than any other term, and it must be at least one-third of the sum. 

Anywhere you repeat yourself, you can create a method, and then call that method. Try this for reversing the strings and for finding occurrences. You have a lot of variables, which makes it harder to reason about your code. Extracting code into methods will limit this. The next helping step is using function returns: 

This approach has the added benefit of being thread-safe: no need to fence access to , and no risk of having a bean in an inoperable state, or filling the log with errors. 

But now has multiple responsibilities. It parses input, determines a reply, and sends that reply. We can filter some things out: 

This is it for data, but what about the code / behavior? We'll go back to the problem statement and refine it: Quarantine simulates the passage of time. When time passes, (a) treatments applied to patients take effect, and (b) patients are affected by their ailments; some ailments, when untreated when time passes, will kill patients. Treatment is applied to patients. Some treatments include medication. When medication is applied to a patient, it may cure them, have no effect, or kill them, depending on (a) the ailments of the patient, and (b) other medication applied to the patient. Some behavior looks straightforward. Quarantine controls the passage of time. Time passing is when effects take hold. The rest is trickier. Medicines may interact with each other and affect the patient. Medicines and ailments may interact and affect the patient. Who gets to decide what? 

It writes to rather than using the result set as a local. It then loops over these results, but returns only the last row. You appear to use as a type; consider making a separate, named type for it. 

Entity manager factories are usually pretty expensive to create, since they must parse their configuration and mapping files, and possibly set up a connection pool to your data source. Factories are thread-safe, so it's safe to have only one per persistence unit in your application. Recreate the factory only when it fails to create an entity manager (and log when you had to do so, because it may be indicative of problems). Close the manager when your application shuts down, to give it the chance to shut down and cleanly disconnect any database connection pools. That said, my experience is that this manual managing leads to bloat and maintenance overhead. If adding a library or container to help you is out of scope for your application, consider creating a template class so you can focus on the what instead of the how-with-resources. 

The damage values also seem to be groupable, so let's huddle them together in a class or interface of their own; same with life and mana: 

That's... quite something. Only list exceptions that you expect clients to handle/catch, and see whether built-in, available exception types like suffice. If this is not feasible, document when exceptions are expected to be thrown, and when the return value is true or false. I could not make this out from the method signature. Compare with: 

Factories are an abstraction for how to obtain instances, as distinct from explicitly pooling, singletonning, or creating instances (through constructors) from client code. Exactly how far into this abstraction you want to go is a matter of debate and, in some cases, ridicule, but this base abstraction is what you need to keep in mind when designing them. Because factories are a means to an end, it's hard to tell whether your factory will be helpful without seeing your use case. What will your use of the pattern help you accomplish? (As a hunch, I'd recommend you to look into dependency injection.) 

Phone numbers have a normal form, which is NNN-NNNN, with N being a digit. This makes phone numbers contain 7 digits worth of information. That fits in an . → Less memory usage, better cache usage. You don't need to retain the original form. → We can use destructive methods. Your incoming alphabet is limited: uppercase letters, decimal digits, and the hyphen. → and/or table parsing are viable. You need to output only the duplicates. → We don't need to store everything, but we might end up having to. You need to output the duplicates in lexicographical order. → We don't need to keep everything sorted; only the duplicates. 

Yes, if you supply the alphabet/element set as input to your function, and treat your output as indices into that alphabet. Right now, your output is a list of numbers per combination (rather, a string, but see later). This makes them feasible to use as an index into an arbitrary list. In the least intrusive form, without modifying existing code, you can add this function that will do what you want. (It's not efficient, though.) 

Exception Handling Clean-up on aisle three I/O needs to work with either the try-with-resources construct or with try-finally, or you risk leaving dangling resources. Let's look at the Client class: 

The code is a good first attempt at translating the specs, but it is open to refinement. Consider the edge case on line 80: can never be true because length is of type ; instead, it will overflow to . To solve this the easy way, have a look at , especially its method: 

In its current form, the used comparator cannot return 0, and returns 1 for equals elements. Does not solve problem? The example input gives this as output: 

I see no clear algorithmic reason why the time limit is exceeded. Ralf Kleberhoff points to the probable culprit : 

You're right in sensing there has to be a better way to do this. Right now, you're setting static fields from within instance methods, which is rarely a good idea. Luckily, your code is already sufficiently structured that fixing this requires very little work. Explicitly pass an instance containing a and as a parameter in the method. This keeps your algorithm as it is, but it limits the scope of changes so that they stay within local execution: 

The use of s also helps you impose time constraints and handle exceptions thrown during execution. (Note that you'll typically want to use or as is a minimalistic interface.) To paraphrase your example: 

The harm lies in that you have no way of enforcing that these subclass instances are themselves immutable. Depending on what properties of immutability you rely on, this can throw off otherwise working code. 

Depending on your needs, there are ways around this but, sadly, none of them will work automagically, and they may require some effort. Only you can decide what's warranted and what's overkill. From what I can see, you're building a GUI for chips or circuits. I imagine you want to provide a component that lists gates for your users, much like the component buttons in WindowBuilder or Matisse. Let's see how these solve the problem. Asking for directions WindowBuilder comes with the standard Swing and AWT components out of the box. Since these will be in pretty much any Java distribution, they can just add the components manually once. It's a bit tedious to do, but you only need to do it once (and maintain forever). What about components that aren't standard, like when your users make stuff of their own? Well, there are three main ways that jump out: 

...and end up with I'd expect the method to throw a NumberFormatException, and possibly shake its head at me for misquoting Batman. can be briefer. You're taking some responsibilities out of the hands of , which is not necessarily a good thing. If you can't go to Java 7 or import the excellent Guava library, you can copy their implementation: 

Looking back at this, there is a better way to deal with it than I initially envisioned. The nodes are a bit hackish. You only ever have two lists/queues to keep: nodes that you are currently processing, and nodes you will have to process on the next run/level. So let's keep them in two seperate lists: 

You can shorten / simplify your StudentStatus implementations. Both and have a fixed return value for . You can leave out the field and add the value directly in the method. copies what the constructor already copied. You can simply return . Domestic students have no documents, so can return the empty list. 

Find a public static method matching a specific signature, e.g. a factory method. , , and so on, are good candidates. Document what you accept, and in what order you search. Find all public constructors, and try to invoke them with 'default' values. What constitutes default values depends a bit on context. We may need to ask our users to provide values for us. Again, document what is supported, and how you will try instantiating. 

Bubble or Insert? #1 and #2 are both implementations of insertion sort (*). The way you insert the element is not so important: whether you copy one by one, use , or bubble it down is up to implementation. I'd imagine to be the best for larger inputs. #3 would be closer to selection sort, a relative of insertion sort, though there's no advantage in allocating a new array. (Or maybe I misunderstand.) Both build a sorted part in the array, guaranteeing that at step , is sorted. Both do their sorting in-line, not requiring extra array allocations. And both select an element from the unsorted part and then insert it. The difference between insertion and selection is in how they select the next element to be inserted. Insertion sort doesn't care which element is next, so it selects whichever. Selection sort specifically select the littlest element from the rest of the array. This makes it more costly, but adds the additional guarantee that not only is in order, but it also contains the littlest elements of the entire array. (*) Though #1 is related to bubble sort in a way his parents won't talk about. Optimise? A strong point of insertion sort is that it performs very well for input that is already (mostly) sorted. #1 unconditionally runs in quadratic time: , which is in the order of steps. #2 is smarter about it, and doesn't run back comparing if it won't need to. This means it has the potential to run in close to linear time. Specifically, it will be in the order of steps, with being the number of elements out of order. #1 can be 'fixed' with a simple addition: 

should be guarded Currently, the instance if filled in via the Main thread. If the GUI (on the EDT or through the timer) later requests the instance, there is no guarantee they will see it, or they might see it in an inconsistent/incomplete state. This can be solved by either making volatile or, perhaps better, making a synchronized method. is on a best-effort basis It looks like this is the basis for a game or other graphically heavy application (judging from FPS). Swing (and its timers) may not give you the timing guarantees you'd need for things like game logic. Consider using a game loop with a Canvas and a BufferStrategy, disabling redraw requests, and taking over from there. Isn't the Timer good enough? I'm tempted to say, yes, it might be good enough, if the game logic is simple and not intense. Though you're no longer blocking the EDT with Thread.sleep (big win), the actions that the timer calls are still executed on the EDT. This makes handling GUI elements and fields much simpler (no sync needed), but heavier stuff may result in jitter. Worse: heavy stuff on the EDT may make your game loop jitter. In short: the timer is simpler and probably good enough. The game loop in a separate thread (say, your main thread) is more heavyweight but also more reliable and more likely to benefit from hardware acceleration. 

Ideally, remove the field. If you have a clear and compelling use case that can not be reasonably solved otherwise, keep the field for now, but clearly document the why and the how (and use the pseudo-tag), and consider adding it to your project's to-do list. This really feels like a bug waiting to happen. It should not be a factory's duty to keep track of what type you are currently interested in. Either the container (configuration) or the client code should know what it wants/needs (and pass it into the factory method): factories are middle men.