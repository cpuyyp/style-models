So try to condense your logic as much as possible (as long as it stays readable). Learn about the laws of logic (e.g. de Morgan's rule). I think you could improve speed by collecting bigger chunks of output in a , instead of spitting out single chars one by one. Last but not least, follow good coding practices: 

Just a little remark as an addition to the other excellent answers: Don't repeat yourself, always try to to find an abstraction for common tasks. E.g. If you need to time methods, don't do it "manually". Of course the "right" solution depends on your needs, but I would suggest something very simple as: 

I shot myself in the foot several times when I hard-coded file names etc. Now I put such "static" data usually in property files. That way it can be injected easily, too, e.g. using Guice. 

The other answers are excellent, I just want to point out a handy way to split positive numbers to digits: 

If you are really sure that an empty method body is okay for most sub-classes, you could follow the example of Swing listeners (e.g. / ): Make the methods in your class abstract, but provide an abstract class called extending , which implements that methods with empty bodies. That way you document your intentions: The methods must be implemented, but by extending the you say that you want for most of them the default implementation (which happens to have empty method bodies). Update: Of course, if you can use Java 8, you can write default methods in interfaces, hence an abstract class isn't needed. 

A function makes sense when there's several places that call the same exception-throwing function and they all want to immediately catch and handle a single kind of exception said function may throw. For example, often makes sense as parsing may be common and may have only one failure state (no parse). It makes sense to do 

First of all, I would specify that your stack is using a "dynamically allocated array", as opposed to just an array, as I at first expected a C array when looking at the title. That varies from person to person, though. On to more important things: 

First of all, please make sure that your indentation is correct, especially when posting Python code. Also, take a look at PEP 8. You are violating it in at least the following places: 

I don't see how wrapping a single identifier into parentheses is ever going to make things clearer. On the other hand, I also don't see myself immediately understanding how parses for every possible operator , or what will evaluate to. There's also plenty of cases between that, especially when you add operators with (imho) unexpected precedence, like bitwise . All in all, I advise to allow your coworkers to decide which form to use where, and to spend code reviews checking code for correctness, not for compliance to formatting standards. 

If and are so tightly coupled with the feasibleNeighbor-calculation, maybe you should have something like a class which is holding all of this stuff, and which you can ask for the next neighbor list? 

is the same as simply . Use API functions where possible. E.g. there is for s. What is with the empty {} in and ? [Suggestion] 

If you don't use such tools, you clutter your code, and after some code changes you might even end up measuring something you didn't intend. Further it is much easier to change behavior afterwards (e.g. printing the timings immediately, or log the timings instead) if you have only one piece of code dedicated to that task. 

I'm not sure this is faster, but it's worth a try. Concerning lower-case variable and method names I thought about things like . 

Of course, you could add some error handling, e.g. ask again when the user misspelled an operator. Also keep in mind that division by zero results in "Infinity", which is fine here, but may be a problem in other contexts. 

For a "scalaesque way" to deal with , study Tony Morris' Option Cheat Sheet. Additionally you can use for comprehensions as well (if you don't want to do anything in case of ): 

To summarise, if the user of your class sees a single pointer, you can be sure you're doing it wrong. 

When there's only one function that calls the function, the added benefit is significantly less; we end up obscuring what exception is thrown and losing the ability to rethrow if necessary. If this is all insignificant, a try function may be worthwhile; however, I'd use it in reaction to a common pattern, not in anticipation of one. 

If this is C++, you do not need to typedef enums; will do. There's also no need to place at the end of a function that returns , or in the parameter list of functions that take no parameters. As Loki Astari remarked, you should not the joysticks unless you have a good reason to; even if you do, though, and don't use smart pointers, you should make a destructor that deletes the two pointers, and should either implement or make private the copy-constructor and assignment operator. 

I had to replace all instances of scientific notation with fixed point, and wrote a Python script to help out. Here it is: 

Yes, if no whitespace is added, the longer variable names make a wall of text a bigger wall of text, and convey very little meaning. However, with just a slight increase in the amount of whitespace, I find that the longer variable name is no less clear and makes it clear what is being done. (By the way, I think this is partially a language problem: as things are, it is used three times, while a proper for-each loop would mean it would only need to be used once.) I do not agree with or offering that clarity; would do, too, and is down to personal preference. 

Your names could be improved, e.g. isn't a good name for a member variable. You could replace the by a multiset implementation, e.g. from Google Guava. Then you get for free. The (and its ) should be generified. Further, it seems to be plain wrong, as it never gives 0 as result of , but that is the expected outcome if two values are "equal" (whatever this means in the actual context). Without looking too deep in the code, it might even be that a simple priority queue could replace all the and stuff. The method is too long and should be split in logical parts. Probably it would be better to avoid static methods, but to create a instance which does most of the work. If you can use Java 7, try out the ARM block feature for your file access. For your question you used the tag "clean code", but it looks like you didn't read the book by Uncle Bob. Check it out! [Edit] Based on your clarification I would write the class as follows: 

Your implementation is not threadsafe: Imagine the queue is empty, and several threads which want to remove an element are waiting. Then an element is added and all waiting threads are notified. Then they all try without further tests to remove an element, which will work only for the first thread, the next one will cause an underflow. Same scenario for several threads waiting to add. So either fix the problem or add a comment with a "not threadsafe" warning. 

I could be missing something, but I think you meant to have one of these. (They are likely the same in memory, by the way, it's just a matter of different types.) 

You instead could use a list, but then the indices would start at 0, which I don't think you want. Thirdly, although your functions are all short and fairly self-documenting, I would suggest adding docstrings to your functions, as well as comments whenever you feel like you have to make an important decision. Even if you don't expect the code to be read by anyone at all, spotting similarities may be simpler in text than in code. You may also want to name your constants -- the aforementioned 100 is a good example, as well as the point you use in (why did you choose that point?). Speaking of which, may be better-named , if I understood the purpose correctly. In general, you may want to have function names start with a verb. 

Indentation is generally done in powers of two, and should in any case be consistent. I'm switching to four-space indent everywhere, as you don't seem to be following any style. This is also a great chance to use pointer containers. Each node owns all of its children, so use something that will enforce that. (In some cases, an of s would make more sense.) You do not need any of the globals you've defined, and are definitely bad practice. You should also strive to be more const-correct. 

Don't use arrays as representation for binary numbers. could save you a lot of work. Except from that, your code is very repetitive. An example: 

I see some problems with your code: It is not DRY, you calculate results that you never use, and you do "too much" in the -cases. Also, try to find expressive names for your variables (not based on the type, but on the function). I know you're just a beginner, but maybe this is a good opportunity to learn about lambdas. There is an interface for the kind of "operation" you need here, which is called . You can easily create instances by using lambdas, pass these instances around, and call them later. This split between creating some kind of operation, and actually using (or reusing) it is an incredible powerful tool. Have a look: 

I can't find much to critisize here. You could use (e.g. for ) and . I find it a little bit strange to have no graph type which holds both nodes and edges, just nodes and the weight function. It would be easy to get "out of sync" between nodes and weights in your demo (e.g. when making a copy-and-paste error). Edit Here is my take: DefaultKShortestPathFinder