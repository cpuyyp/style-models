If there is no formula to calculate shoe size from one unit to another i suggest you to put sizes in some data structure and map them together. For example in Map. Then you just query the map instead this if-else hell. Same applies to the mapping. Also i see you use Strings a lot as a constants. Consider creating enumeration of some of them. 

EDIT Also do not put on your DAO classes but on Services. Service method describes unit of work which should be done whole or rollbacked. Consider this simple code 

And don't mix classes from primefeaces and dao as suggested in axels comment. When creating this wrapper convert this view classes to some custom backend classes. in some object. I have class. It is much readible and convenient to use. Instead of use CollectionUtils.isEmpty I recommend you to extract nested ifs and loops to methods. Maybe when you extract them you will find some place where you can remove duplication. 

Your method is very long. This is code smell - if method is long it maybe do a lot of thinks, but method should do one thing. I suggest you to split method into smaller peaces which defines smaller units of work and are reusable and easy to read. If you put piece of code into method you give name to the code which work as a hint to he programmer what code enclosed in method does. Also use full name of variables, not some abbreviation like . You write them once (if you are using ide) but read it multiple times so you invest the effor into the writing the proper name. I did not checked your logic. Your logic should be captured in unit test - if there is no unit test i would hesitate to refactor some code. If there is no unit test dont write them now if you dont have business requirements, but you ca try Characterization testing to capture current behavior of the method. Because without any test you cannot be sure if you did not broke something when rewriting the method. 

Try not to use with and conditions because it becomes confusing. It's clearer to use negation: . Some people are boolean impaired, including myself. I'm not sure under what circumstances the hash does not exist. So checking for its presence may be redundant. 

I wrote a sample app based on the ReactJS tutorial, and I would like some thoughts on how idiomatic this code is. Unfortunately there's no ReactJS integration with Stackoverflow snippets, but I do have a working JSFiddle. You have a phases box, and inside it we have a list of phases, and a new phase form to add a phase to the list. There's a link to show the form, and another link on the form to hide it. There's also validation on the form. I'm curious to know how idiomatic this is. Some things to consider: 

It depends. I prefer the newer syntax because I feel that it is more readable. As others have pointed out, however, the newer syntax is only compatible with Ruby 1.9.2+. You should be aware, however, that the new syntax does not entirely replace the hash rocket syntax. This is because you can only use the newer syntax with symbols. 

Finally, should you add more classes to User, Series, and Lessons, you must modify your method, and add the necessary conditionals. So ask yourself if this code really belongs in the method. My two cents. 

Just taking into account the code that's present in the question here (and not considering a possible extension scenario in more tasks): Being that you have to wait for anyway, I'd suggest to rewrite the code in the following way: 

Reduce the space between the lines of code. Right now is a bit too much. Reduce indentation. Reduce width. 

In my opinion, there are a few improvements that can be made. I'll address only some readability issues here, not the performance or algorithmic ones. Remove regions There are a lot of discussions on this, just google it and you'll find a ton of discussions. The methods are too long Try to reduce them by using already existing object or methods. For example: 

and, by taking a look at the delegate, you could transform it (but it becomes a little less readable/understandable) into something like: 

There's one thing that is particularly disturbing me: the last block. That's an example of Busy waiting and that's something that should be avoided IMO. A possible solution to this problem could be to store the objects to a and once you have created all the threads you run a for each thread on such list. That being said, I'd suggest to take a look at PLINQ and TPL. One last thing: I'd remove the in the block also. I'd say that the instruction should be used only in a method. See here and here for ways to handle exception when working in an async way. 

What about having generic abstract dao class which will contain these methods? You will most likely have to create some concrete dao classes anyway to have specific methods. We are using this approach in our projects (behind JPA facade) 

Classes in model layers should be aware only of interface of underlying layers (DAOs or something similar). If it contains than you are telling your business model what view you are using. Send text from textfield directly in you service (model) methods. Or better send them some DTO wrapper object. You misused and . belongs to the controller or view layer and belongs to the model layer and check the business requirements. Also you duplicate the name of the cities. When you want to add new city you have to change the model and the view. Put them in one place (maybe something like CityRepository accessed by the Model layer classes) and get the cities from there. So to recap Model is businees view. It should contain validation and perform your business task (in your case some traint icket processing) and should be aware only about data model. View should be aware only of controller and provide interface to interact with and methods how to get the data from the user Controller Drives the flow - it gets the data from view, wrap it in some business objects (like TrainTicket, User, etc...) and pass it to the model, takes output from the model and present it through the view. 

I suggest you extract two methods: to check if the user is authorized, and to handle behaviour. You would then end up with this: 

Is there a better to test this requirement other than to iterate through all the possible scenarios? I'm doing something like this. 

I wrote a Ruby gem to analyse strings for word length, word density, and a few more hand methods... The class accepts a filter (String). The class will remove any words from the original string that you include in the filter. Spec: 

Ideally you will want a nice helper for this. Now you can helpers from inside the decorators using the context. 

Your view will be simplified too. Instead of calling you can treat the decorator as the binder object. 

I was not able to get @Jerry Coffin's particular implementation to work, but I used his idea to create this similar \$O(n)\$ implementation. As he describes, we reverse the array at \$A[0..S-1]\$ and \$A[S..N-1]\$, where \$S\$ is steps and \$N\$ is the length of the array. We then reverse the entire array. 

I started out with this solution. It's iterative, and not very efficient. It multiplies all number combinations, adds the products to an array, finds the palindromes, then chooses the max. 

This class is used in the following way in a second class which should be the class that is used from the various gates: 

In addition to what has been said by the others, and noticing 3 distinct blocks of code in the original method, I'd suggest to split into distinct methods, and also use where possible (for readability's sake, being that it changes very little from the performance point of view, unless - of course - this method is called a lot of times). So, the original method becomes something like the following (this is not tested): 

I'd go with the built-in control. Here you can find the documentation and some examples. Also, I'd suggest to use the and for the other operations. Usually, if you have to manually insert some HTML code in the page some bug is pretty sure to show up. 

Cycle conditions The main cycle has two internal paths that cause it to interrupt through the instruction. It could be better to refactor the code in order to include these conditions in the cycle's one. I mean, changing this: 

Without even looking at how the code works, I see some serious readability issues here, among which: To or not to Be consistent on your coding choices. For example, sometimes you choose to put brackets even for single-instruction-body s and sometimes you don't. Make a choice on which style you're adopting (personally I'd suggest to put even for single-instruction-body s) and stick to it. Naming Avoid single letter variables/fields. Give them a meaningful name. Methods should have meaningful names also. What does do? Indentation The same as the first point. Be consistent in it. 

I'm building a JSON API. I'm writing my controller tests so that they compare the response body to actual JSON I'm generating in my tests using ActiveRecord. I wrote two helper methods that make the process easier. The first simply parses the actual response body and returns it. 

The best way to ensure a bullet proof implementation is to avoid having a square contain more than one object. For example, there's an edge case where a square can contain a ladder's head and a tail, causing you to progress even further. To do that, the placement should be delegated to a method that checks if the square is occupied. This requires tweaking the initialize method, but it's worth it: 

Doing so means the placement methods for ladders and snakes only have to worry about working out the range and populating their respective hashes, which are the only two differences between them. This reduces duplication. 

The first check is for the length of the string: If it's odd, the can't be balanced. I then iterate over the chars of the string: 

Is this a good way of testing me controllers? The part that makes me think is where I'm generating the JSON using Rails helpers instead of explicitly writing the JSON myself, or looking for keys in the response body. For example: 

When second dao fails to delete and you have transactional daos not service, the first entity is lost. And you method should not return boolean, but let bubble the exception up into the service layer and let service handle the exception. 

In Option #2 you cannot be sure that user of your class will pass new Object as a parameter. If you really want to create a clone of parameter you should create on yourself or implement some method on MyReferenceType 

It is a bad idea for a constructor to contain non-trivial code. Constructors should assign values to fields or another simple actions. If you need complex initialization, you should use factory object or factory method 

I also think that methods like Should take a File instance as an argument - it should be responsible for writing to the file not opening it or creating some directories. Same for readFile method. 

I would separate calculations of shoe sizes and distances into separate classes. It is called SRP Name your variables properly is just a random letter not a name for a variable. For methods with a lot of arguments you can use some wraping object 

First of all name your variables properly. Name of the variable should describe what it is, but is just a random letter not a name for variable. Consider using logger instead of printing to sout. Stream closing should go to the finally block not in try. You are nesting a lot of loops and ifs. Try to separate it into methods soo you and up with 

I'm developing a web application for simulating electronic circuits and I'm trying to add backward propagation options (guess you can immagine why). During refactoring I came up with a base class for logic operations and wanted to ask for some feedback (whatever pops up in your mind) on it. The class code is the following: 

Regarding the complexity of the algorithm we have that time complexity is \$O(AvgBagCapacity^{NumOfBags})\$ (that is reduced a little by breaking the computation early). Regarding the space complexity depends on the approach used to expand the tree. Personally, I'd suggest to use a depth-first approach as it reduces the space complexity to \$O(AvgBagCapacity * NumOfBags)\$ (if you don't keep the already expanded nodes in memory). If you want to furtherly reduce the space complexity you could use lazy initializations of the nodes so you use only one node at a time. By doing so, the space complexity is \$O(NumOfBags)\$. For the sake of clarity I wrote some code which does what I described. Obviously it has a lot of room for improvement (starting with the naming :P ). I also included some tests (the first two are the same as two of your examples) so you can do comparisons and play with it. 

Once more, I've opted for keyword args in . I've simplified the method. It plays a turn, moves the player, then checks if the player has won (landed on last square). If the player does not move (no where to go), it checks if the last roll gets him in excess of the last square. If either of those things is true, it sets , otherwise the turn ends. 

I added a feature that allows you to send in a Regexp filter instead of a string. It's my first use of Procs, and I'm sure it can be done better. It's not very readable, and probably not efficient. 

I want to offer an alternative to helpers because I believe in this particular case using a presenter to isolate view logic is better than using helpers. As stated yourself you have many more attributes, so having a presenter class avoids having to write generic methods and gives you a scalable way to handle view complexity. You can use a gem like Draper, or roll your own, which I prefer. 

I wrote this short, plain Ruby lib to handle email address validation inside and outside of Rails applications, and I would like to know what you think.