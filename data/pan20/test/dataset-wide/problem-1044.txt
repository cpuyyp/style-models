which doesn't seem to be legal. I was able to circumvent the first to placeholder by using dollar sign escaping, but still the second occurrences seem not to e legal in those positions!? I also wasn't able to use dollar escaping in that place, because the names are use as literal there. My question: Is it correct, that placeholder in prepared statements only have special uses? (And can be used in arbitrary positions like string interpolation in programming languages.) If so, is there another, secure, way to put that statement together? Robin 

I have been reading up on innodb as a storage engine, mainly because I have recently moved to AWS and they do not recommend myISAM which my databases current run on (and have for about 10 years) So moving to a new engine is a little bit of a scary operation. I am apprehensive about the move, as it has been on myISAM for so long without issue, but if it gives me peace of mind long term, then it is better for the DB. I have read the whitepapers on InnoDB and it seems fairly straight forward, The one thing that I want to clear in my mind is the innodb_flush_log_at_trx_commit option By default this is set to 1, however from my reading this causes additional overheads, if the data was credit card transactions or something like that, I can understand its needs to be there, but it seems when dealing with non life changing data, that innodb_flush_log_at_trx_commit=2 is a better option. What I want to know is, this does not affect the time that the query is actually committed does it? It only affects its recovery ? I just want to make sure that when I do an insert or update that the query will run right at the time of processing and not 1 second later, no matter what the flush_log is set to. My understanding is that in the case of a crash , setting to 1 will allow it to recover all queries run on the server, where as setting it to 2 may lose the last second or two of data when trying to recover from the crash, is this correct? Also, if there is slow periods of updates/inserts (ie, not much happening on the server) does setting it to 2 add additional overheads on the server, or is it a case of the benefits of applying innodb_flush_log_at_trx_commit=2 to the database when the database is busy outweighs any additional overhead caused during slow times? 

You are correct in your description but the conclusion is not correct. It may still be faster to use the index anyway even if it has to go off to the table for the rest of it. The data pages contain many fewer rows than the index so there's lots of extra I/O when scanning. Generally the index will tend to give you benefits if it selects few rows even if it's not a great fit. 

If you're worried about not having SQL support, just wait until they realise you're hacking data into the DB. I'd put money on them refusing you any other support from that point on. That said, it sounds like somewhere there is a "max ID" table for all the other tables and you're hitting a problem there where its idea of "max ID" is wrong because you've taken it. Of course that's just a guess. Also, the max+1 is really the wrong approach both from you and the vendor. It causes contention if you can do it right and duplicate errors when you can't. The best way is sequences or identity. 

This way I have control over the order. And if anything changes I have to add it into the statement nevertheless. I don't want to eliminate the possibility to use maybe another special purpose table to control this mechanism, but for now this would be ok. 

This functions checks, if a particular object/attribute-combination is not yet present in the table (). This works fine against inserting unwanted doublets. The problem however is, that it doesn't allow updating such row. The updated row seems to be considered a doublet. Is there a way to fix this or is it a conceptual problem CHECK constraints just don't cover? Robin 

The answer is kind of "no" but more "your question does not have an answer because it's based upon incorrect assumptions". 1) Tables are not really stored in a particular order. 2) Even if they were, how would the DB know that the question had been answered until it had finished reading the entire table. Putting things "up front" would not help. 3) What you ask (range of values) is in the realm of an index. An index has more structure and roughly the concept of "beginning and end" so would be the way to go. Build an index on the values you intend to query. 4) The way indexes are structured means that individual rows can be selected from billions with just a handful of I/O reads. However you need to have the right values indexed to match the queries. Look at the plan to see if it's working for you. 

I have the task to create an EAV table with some constraints. Attributes are foreign keys and some values are also from other tables (not realized as foreign key, but as a CHECK constraint). On this table are some constraints to be realized, one of which is that some object/attribute-combinations must be unique, while others don't. Example: A photo can have multiple persons in it but only have one person who took it. So I wrote a function to limit object/value-combination to max. 1, if a certain boolean is set for that attribute. (As I said, the attributes come as foreign keys from a different table.) 

I am in the process of moving my servers from stand alone hosting to AWS using RDS (MySQL) for database usage. One of the first things RDS states is that in order to use their backup, and snapshot features of RDS the tables must be using InnoDB. My site has always run on MyIsam, probably mainly because 10+ years ago, it seemed like the right choice. Because of this, my database structure is quite simple, and quite separate, there are no join queries on the site, so every select is only getting data from one table. some of the tables have quite a few indexed fields, The site requires, frequent inserts, regular updates and many reads, I don't use full text searching, the majority of queries revolve around either the UserID or the tables autoincrement ID So, my question is, what to expect if i was to move to Innodb? I am not that worried about the transaction side of it. and for this reason MyISAM is ok. I am more concerned about backup, previously I had a cron job that would automate the backup , but of course this came at a price of lockouts while the backup was in process. MY understanding of InnoDB is that because it does row level locking, this would not be an issue. But what about performance? I have read so many reviews and bench tests, but i dont know how they relate to my situation. Can I move over to InnoDB without worrying about setting up foreign keys etc, can i keep things as simple as they are now, or would that negatively affect the system if using InnoDB. I realize that InnoDB has become the default option in MySQL these days, which makes me think that all dbs should be running on it anyway. What I dont want to do is have my database fall over because I didnt set up innodb properly. Is it even worth moving my tables over to it, given its been running just fine on MyISAM for years. Or is it a case of, this is good cause to change? 

I try to have a view created on the fly. In my case it's a pivot view on a EAV-style table. Assuming a table which contains two attributes I use a statement like this, executed inside of a trigger function (written in PL/Python): 

Ok, I might have found an answer myself. I learned that I can "emulate" the table generated by the second query by this: 

But I'm aware that this is highly insecure, because input is executed. I tried to use a prepared statement like this: 

Every R (relational) DBMS I've used has. MySQL is peculiar in so many ways I struggle to put it head to head with any of the "normal" RDBMS for anything other than a basic data dump for a simple application. There are plenty of DBs that are not relational that don't have the concept. As far as I know though, there are none other of either sort that support the syntax without the functionality. 

for a blob of text use varchar(max) if you're storing XML use XML There are BLOBs for binary data These are often stored off-table (automatically) for various performance reasons. So yet you can, but nevertheless, you might be doing something a bit wrong. If you share what you're trying to do, we can be more specific. 

whereas I want them in order MR_Type, groundTruth, origin. Even if I change my order, I can't be sure the query always gives the identical order, right? I could order the query and my list. But then the order might not me as wanted (and it makes it harder to extend the attributes list later on). Is there any common use? Robin 

But now given I don't know the names of the two attributes at creation time. I will have to insert them at runtime. I can build the statement on the fly and execute it. Actually that's what I do at the moment: