Using a constructor-like function is the idiomatic way in Go. See Effective Go: Constructors and composite literals. Also relevant: Effective Go: Package names: 

Add +1: (this is why we stored powers of 10 -1) Multiply with the digits count: Add the total number of digits of all the numbers having less digits: 

If we have a sorted slice of the power of 10's, we can use binary search to find the power of 10 for our input number. However as this slice is small (~10 elements), it is faster to just loop over it in a sequencial way. The total number of digits of all numbers having the same width (same amount of digits) are also constant values. We will precalculate these and store them so we don't have to repeat this constant calculation. For the first 8 digits: 

Now an explanation why your original didn't work as the key. When you want to find an element in a map by key, Go uses the comparison operator to test for equality of keys (hash code is generated and used under the hood to speed up the lookups, but that is irrelevant now). This is how the spec defines the terms and the result of the comparision. Quoting the relevant part from Spec: Comparision operators: 

And if you want to iterate over a whole "collection" (e.g. slice, array, map, channel), the For statements with clause is the clearest way. "Unfortunately" your type does not expose such values, so it's not possible to use here. It can still be improved to call once: 

Compare manually (byte-by-byte) We can also do the comparison manually, it's relatively easy and straightforward. But first to do it manually, let's create a simple helper function which tells if a hex digit (the text representation) equals to the raw data: 

By doing this we also got rid of the package dependency (so it won't have to be added to your compiled executable; and was already used, so that's not a plus). Next on to your utilized as a Set. This is how you check if something is in your : 

Your type is a struct, and 2 values of the same struct type are equal if all their fields are comparable and are equal. So you will find a value in the map if they match by and . is an interface, so a different comparison rule applies here. At runtime interface values can hold values of different dynamic type. Both the dynamic type and the value must match in order to claim 2 interface values equal. (You can read more about the representation of interface values in blog post The Laws of Reflection: The representation of an interface.) The dynamic type of the values stored interface is a pointer, a pointer to the unexported type . So now we need to apply the comparison rule for Pointers. 2 pointers are equal if they point to the same variable. So 2 values of will match only if the pointers stored in them match. You used to obtain the slice of s, and whenever you call it, it creates new pointers and hence they will never be equal, meaning the wrapper interface values will never be equal, meaning indexing the map with these values will never yield any results. 

Before even addressing the actual question, have you actually proven that database queries are harming your responsiveness? Since the queries are to local storage it's possible that they are fast enough to not require using asynchrony, particularly if they are simple queries or the database is small. Next, I notice you've assumed that the database itself is not threadsafe, i.e. that you must only allow access from one thread at a time. Are you sure that's actually true? Many (most?) database handle concurrency themselves, so you may be adding an unnecessary layer of synchronization. I looked around a bit, but could not find anything specifically documenting concurrent access to isolated storage databases. I would start by researching that, or possibly asking a question on StackOverflow. If the database does allow concurrent access then you just need to worry about update conflicts, which you could hopefully avoid in a single-user phone application. What I'm getting at here is that multi-threading and locking is hard. Don't do it unless you're sure you have a good reason to do it. If you really must to multi-threading, then the C# keyword is a good place to start. Unfortunately, your example probably will not work properly because each instance will have it's own lock object - so if you create more than one instance they could conflict with each other. You "Current Variant" actually gets this more right, because your is a static variable, so there is only a single instance of it across the system. However, as I understand it lets you use Linq statements against the database, which will not know anything about your lock and hence will not be synchronized. I think you'd have to create a separate application layer to wrap the and expose just the certain operations that your application needs. This is generally called the "Repository Pattern". Inside the repository you could create a single lock object, wrap a around all accesses to a , and use inside each of the repository methods to make them asynchronous. 

So now we have a nice, clean list of the data you need to output. Basically we've handled the first and second bullets from my list, so all that's left is turning that into XML. There's probably a cleaner way of doing this than using s directly, but let's just stick with it for the moment. But again, let's stick all the logic in a nice clean function. 

2. Convert the first to raw bytes Compare slices () We may choose to convert the text checksum back to a which holds the raw bytes of the checksum (NOT the bytes of the UTF-8 encoded hex representation). We can parse the hex representation simply with . Or even better: since we have the text checksum as a , we can use which takes input as a . As an extra gain, we don't even have to care about lower or upper case: handles that for us. And we can convert to by simply slicing it. Once we have 2 , we can use to compare them (in Go slices are not comparable unlike arrays). 

Also it's just a matter of taste, but I find it easier to read if you use the index instead of the length (which is ): 

If we look at it, is the negated value of (if they are equal, no need to swap). So we can rewrite the rule; swap elements if: 

Implementation Things to note: To determine which power of 10 preceeds the input , we may use a loop always multiplying the previous number by . These multiplications (the powers of ) are constants, we don't need to do this in the function, we can precalculate them and store them in a slice beforehand. Note that for practical reasons, I will store the power of 10's -1. See below the implementation for details. 

I think both your solution and your testing are fine. A couple of test cases I would add (but your solution also passes them): 

Your code looks ok to me, but here are a couple of points to improve: You used the package to obtain the arguments to your program. The original intention of the package is to process optional, named arguments to your program and store their parsed values into variables (designated by pointers). Using it just to obtain a list of arguments is somewhat "overkill", better would be just to use a simple variable in the package: . holds the command-line arguments, starting with the program name. Since you don't need the program name, skip that by re-slicing this slice. Your new function: 

(disclaimer: Glenn's a friend and former colleague of mine, but he is really good at this stuff. I don't get kickbacks. Maybe a beer, but probably not.) 

Now, let's write a function to parse the database records out into a list of objects. This is basically doing what I said earlier - tracking until we hit a new or . We're using C# iterators (that's the syntax) to make this a little bit cleaner. 

I'm not sure if you're interested in better algorithms, but if so here are some. In this particular implementation, I would consider changing how you handle substrings. You're currently doing a lot of string concatenation, which can be slow as a new object is allocated each time. Since you're just tracking substrings anyway, you could instead store the source string, start index and length of each match. That would save you potentially quite a bit of memory, and run faster as well. If you're really attached to having separate string objects, at the very least figure out the extent of the match and then do a single to extract it, rather than building up the substring one character at a time. 

Making a copy of an object has a benefit: safety from unexpected changes. It also has costs: it takes up more memory, uses more CPU cache, and adds pressure to the garbage collector. Making copies that won't be modified is a waste - you're paying the cost with no benefit. So you should only make a copy if you know that you'll need it. The only code that knows for sure that the parameter will be modified is the code that's going to modify it. So whoever is going to modify that parameter should make the copy. Otherwise you risk screwing up shared state, or making a bunch of unnecessary copies. So: Option #1 if the child object is going to modify the parameter, Option #2 if the caller is going to modify the parameter. If neither is going to modify it, then don't make useless copies. 

Admittedly it's a lot of lines, but they're very easy to understand. Also, the test method itself becomes dead simple. Since I'm on the topic of tooling, you might want to look into the TestDriven.NET Visual Studio plugin, which provides very nice "right-click -> run test" integration.