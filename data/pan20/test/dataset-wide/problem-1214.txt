Replace all by . When you're not using the second argument, you don't need to discard it explicitly. 

Yes, this is the way to do error handling in Go. By design, you can't let exceptions propagate to the callers "silently", you have to consider what makes sense at each step. I found that on large-scale projects, it makes it significantly easier to predict and test the error handling behavior of your code. It also forces you to put the error handling first, which (imho) results in more readable, less nested code. Truly global variables don't exist in Go — if a package exports a variable , other packages will have to call to access it. That being said, it pretty much never makes sense to do that. In the example you gave, cmd.go and project.go are in the same package, and all package-level variables are shared, so identifiers conflict. If you want this variable to be shared, it's more readable to put all functions that use it in the same file. When you want to mock some of your functions, it's the sign that there should probably be an associated interface. You can then "mock" an interface easily, by re-implementing your interface in your tests and making it do whatever you want. I find this more readable and idiomatic than using complex frameworks. 

→ . When a function returns and you want to return an error, you usually return the default value of along with the error. So in , you would return rather than . This helps you make sure that you're not going to use the return value when you return an error. Instead of printing the error with , you probably want to use and add an error message. Or not print anything at all and let the callers deal with the error (after all, it's why you return it), possibly returning instead of just . Close the file after usage. Add . Use a with option instead of trimming whitespace by hand. Your CSV file shouldn't have space after values (arguably, it shouldn't have spaces anywhere). On "does this look like Go", I'd say you have too much whitespace (empty lines in functions are seldom used), line returns (you never see them right after declarations () or assigments ()), and your variable names are Java-level verbose. In Go, you would use instead of , instead of , instead of , etc. 

(for simplicity, assume we have created 3 functions which implement your 3 transformations) then will still be untransformed in reality, waiting to apply all 3 transformations to any item you ask for. So if you then do 

In Java, the way to represent things which are essentially the same, only with different details, is though classes. Imagind a class which contains a field (a String) and a field (a object - an instance of the class). Imagine a class, which contains a field (a collection of strings),a way of printing the description (calling on each collection element in turn) and a collection of . The has a method which 

The one drawback is that it does create the risk of accidentally replacing a good, user-added set of parameters with the default. But 

at which point lazy Haskell short-circuits, because this can only generate and so there is no point evaluating . And the whole branch that led us to this point also collapses back to , because 

Option's fold evaluates and returns the first parameter only if the Option contains Nothing. Otherwise it unwraps the value and applies the function. There is much disagreement about which is better. 

Oh, what happened to ? Why does that work without it? The answer is that Scala's does an implicit conversion of the array to a list. Google if you want to learn something about Scala collection internals. Over-specific types Once those three functions are rewritten to use combinators rather than pattern matching, they don't need to take or return . They could take and return . This gives you more freedom abut what you pass in (could be , could be some other -based collection). No performance penalty (the appropriate filter/map/flatmap of the actual type will be called) and much more flexibility. OK, at the end you would have to convert the sequence back into a list (or whatever you want the final form to be), but this allows you delay that decision till it is important. This is that extra bonus I mentioned before. And I'm about to explain why using - or possibly could give a big performance boost. Multiple traversals and intermediate collections returns an iterator (a lazy, one-pass collection which only processes each element on demand). But you immediately convert it to a list, reading the whole (potentially large) file into memory. Then each transformation in turn creates an entirely new collection. So you actually create 4 collections in a row, traversing the entire contents of the file 3 times (possibly 4 if there are no empty or comment-only lines). But I'm pretty sure you only care about the final one. Even if you always want to process the entire file, that's expensive (the bigger the file, the worse it gets). And what if you only want to process the first lines or process the file in chunks, not wasting memory on processed and not-yet-processed chunks? There's a pretty simple solution which will give you all those options (but which doesn't force you to overcomplicate things just because you might want those options later). 

1. The tests are poorly covering the functionality (willing to bet there are significant issues in various places) and it is sorely missing even half decent documentation. 

If you must have an instance method to do this check then you could write this to keep your semantics: 

Without going farther I recognize this pattern as a depth first graph traversal with a little additional functionality. I would abstract that a little and see this helper function: 

Assuming is unique (if not then so you get the exception for more than one element). In both cases you should probably catch the internal exceptions and throw your own in its place to hide the implementation details (or specify in the method documentation that it will throw these internal exceptions, but I would think of that as bad practice). 

That is to say, when the garbage collector runs, all variables reachable from the current scope (and closure scopes) are marked; then a second loop runs and all variables not marked are freed from memory. Thus, if there is no way for the system to reach an object via scope then it is going to be collected. From a user perspective, there are a few ways to create objects that the user can not reach, but are still in scope. Some examples: 

Admittedly I am using a really old version of nhibernate, but I think this is still there (to replace a few lines): 

creates a pattern which is even more useful than because it only matches properly formatted lines with genuine numbers in them. Optionally, 

Improvements The first point can easily be addressed with iterators, since you only need to traverse each range once. As to the others... You could look for a way to start at the top of the range and work down, in such a way that each iteration tests the next lowest product of two 3-digitnumbers. If you could think of a way to do that recursively, you could safely return as soon as you found a palindromic number. But consider this: 

The recursive calls to are not in tail position, so the Scala compiler can not use tail optimisation and the stack grows till it overflows its alloted space. The modifier in is doing you no good at all, by the way. Scala can only do tail optimisation if the recursive call to is the last expression to be called and even then only if the value returned is not modified in anyway but simply passed straight back, all the way to the first recursive call to . To fix this, you could add a local helper function inside , which takes as parameters not only the two streams but also the state you need to carry forward. It would look something like this.. 

Now, despite my warning about the stack overflow risk, look at the size function. It works because an empty tree will return a size of zero. A non-empty tree will add 1 (for itself) to the combined sizes of its positive and negative trees. I want to make two points about this: 

and not implement any other functions. will "implement" , calling will do what you expect, and trying to call on it will panic (nil pointer dereference). 

In , you're needlessly allocating strings by modifying the variable. It would be a fairer benchmark to write it in the following way: 

→ , same for . is more readable. You can also convert everything that represents a time into a or a , rather than deal with Unix timestamps. There are functions in the package that do what you want to do (, , etc.). About that, why does need to do complicated things with times, checking when was the last time it was called, etc.? Shouldn't the caller take care of this with a simple instead? It feels like this complexity shouldn't be there. is a weird name for an implementation. maybe? Your package isn't very idiomatic, which makes the callers do weird things to use it. For example, why do you have a struct that doesn't contain anything? Why not simply have as a package-level function? Same for the other empty structs of this package (…). It's more idiomatic to test for rather than . I'm not exactly sure what you're doing with (this is pretty complex). Maybe add a comment for the line or refactor this part? Talking about refactor, is way too long. Split it in sub-functions. No need for an after . Rather than: 

Option is not an appropriate type to return here. There is no doubt about whether a particular input can return a result or not; anything below zero will fail, anything above it will succeed. For once, failing hard is acceptable in the case of invalid input. if...else if...else if...else chains are fragile and smelly in any language and really never necessary in Scala. Here, you are testing on precisely the same value each time. Use pattern matching. 

In the companion object. In this case, functions should use pattern matching to decide what is the appropriate option for the particular case class. Abstract methods defined in the abstract class (where appropriate) and concrete implementations in the case classes. 

EmptyBST.min Since can only return type , has to throw an exception. There is no logical alternative. You could consider also implementing , which gives the caller more flexibility. Then would return . Tail recursion None of your methods are tail recursive - not even the simple ones and . You can test this by placing before any of them. The compiler will give an error. min and search These cannot be tail recursive, even though the calls to or / seem to be in tail positions. Class methods (as opposed to object methods - functions, in other words) have to be final or private and have to call themselves, not - as you are doing - a superclass method. For these two methods, this can be solved simply. One way is to use a loop and a to descend the branch (this is how many methods in the collections library do it). Another is to use an internal helper function like this (for ): 

It's very simple; what you're saying here is "give me a , I can give you n random values from it". Option 2: 

the line containing your query is long and not easily readable, maybe skip more lines you can write the skeleton to your query once, instead of using successive appends — this is also more efficient if you have many services the call to can be avoided using a simple condition in your template you can replace directly by its value, that you previously computed in your Go code and you can get rid of the variable that you pass to & , just do all the substitution logic in the go code. 

I put zeroes outside the func, to avoid converting it over and over. You still have a few conversions & allocations, but there's no way around them. The other functions can be modified easily to accommodate the type change. 

In short: your method should be two lines long, your method should be three lines long, you shouldn't have more than 2 global variables, and all errors should be caught on . 

And, no, there's no easy way to have something more dynamic that , unless you have a specific use case in mind (and then, you would use an interface, but this is out of scope for this question). See this for a detailed discussion on why Go doesn't have generics for now. 

cache your jQuery objects reword your condition so that it is more readable parameterize the animations and pull them out into methods of their own move your initialization code so that it is all together 

Back on topic: In my opinion, it is a bad practice to force the Javascript engine to go looking for your globals when you are not in global scope due to leaving off the window qualifier. Thus everywhere you reference without calling it (and the same goes for ) or caching it in a local variable is wrong. In the event where you run this script outside of a browser that implements you will get an exception. is slightly less of an issue because it is a reasonably safe assumption that you will not run this from a browser that doesn't supply a global namespace. For this reason I always pass the globals that I am going to use into my IIFE: 

I am not sure I understand the question. What are these classes going to give me that a standard lock wouldn't? I would write that first class something like this: 

This resulting code looks to me like it has too many indents. I also notice that it fails on passing in an object that is an array or contains an array of arrays. Reordering some code we can check both of those cases at the root level: 

Use instead of ; it is shorter and faster in all cases I've ever bothered to test. Don't use inline, javascript doesn't have block scope (only function scope) so it is better to declare all necessary variables at the start of your functions. Cache to make code more readable. Use toString instead of a regex test for checking for the bool type simplify loop and store the upper bound in a variable instead of computing it every time Use a check on the loop.