Creating the DocXTransformer will load the file. Calling Transform, will execute a list of Transformer classes, which each implement the ITransform interface. 

Use buffered reads. If you actually read a line at the time it's pretty time consuming. Use buffered writes. Instead of writing each new line, collect in a buffer and write in chunks. 

So now you have divided you elements into specific entities like Quotation, Customer and Events. Adding more details to a Customer or adding a new Event type, don't require change to the Quotation class, but only changes to the specific entity. On the side, you might also find it beneficial to look into a simple visitor pattern for the events and provide algorithms to etc. calculate total price, date collisions, number of participants etc. etc. Enjoy. 

I would normally suggest consistent usage. In the example you provide, you use both constructor parameters as well as property initialisation. Depending on you options to change etc. the SubjectDto I would add another construction parameter to it and pass in a hasBeenAdded variable. When talking about improving the LINQ query, I think readability and maintainability has highest priority. Often performance optimisations degrade readability and enforces you to write some additional comments. 

A note on password verification PBKDF2 with SHA-256 should be restricted to 256 bits of output. However, that would still leave you with 128 bits. You could use this to verify the password is correct by including it to the ciphertext. The other bits of the key would still be independent from it, so this is secure. It has the advantage that you don't have to decrypt all the data - say a DVD file of 4 GiB - before you know that the password was indeed correct. It could also be used to distinguish between broken files (e.g. incomplete ones) and bad password / keys. Of course an attacker could alter the ciphertext to simulate either situation. 

I was afraid that you were implementing PBKDF2 yourself, but you seem to be correctly using the proper crypto calls. 

Yes, that's OK, if you use this to store password hashes. If you use it as a (encryption) key then you should avoid text, as it can be hard to destroy the result. 

, no need to define your own (note also that using that enum within doesn't generate an exception). Exception handling: don't just throw Exception but handle all exceptions locally, except possibly those that depend on the input. Use or one of its derived classes to handle code specific exceptions. Do not use Pok√©mon Exception Handling. All your constants are . Only expose those constants that are specific to your class and useful to the outside. Using and without braces is considered bad coding practice. You need inline comments in long methods such as to at least indicate what you are trying to do. use instead. Do not re-purpose local variables such as to mean message length in function. Don't leave commented out code without TODO: task or similar and always explain why it is commented out. Use Java New IO (NIO) and 's instead of and byte arrays. 

Without going into implementation details, I would suggest looking into the following performance optimisations. 

I think this make the different logic parts separate and you will get cleaner code, where it's going to be easy to add a new transformer, while still paying some attention to performance. 

The FastCollection contains an additional list and a dictionary of lists, so it's memory consumption overhead might become an issue. I would suggest that you look into representing your data structure (Product) in a data structure which is more optimal for searching than a list. If you into tree-structures or balanced tree structures, you will see that searching cost O(log n), where n is the number of elements in the tree. You can easily build the tree structure with a custom compare function, and thereby having a very fast generic searchable structure. Well, just an idea, which you might consider overkill :) 

Depending on number of nodes in your tree, recursive post-order traversal of the tree, might let you run into problems on the stack. If the number of nodes is huge, you might need to consider a non-recursive post-order traversal. Have a look at $URL$ which describes multiple solutions, both iterative and non-recursive. On think to keep in mind is that the non-recursive algorithms use more memory, as it need to push nodes to a stack. You might also consider doing a post-order tree traversal enumerator, but that might be for another day. 

Update 1: I have written a new method for the response handle to be used in 2 places in order to reduce repetition as suggested in this answer. Also for a similar reason I've written and methods to be used in and methods as they were very similar. 

Review Concerns It satisfies the test condition I am given, in the section of the code above. However, I am concerned that: 

In the below code there are two data frames given, and which represent a pre-defined available timetable for a service, and appointed times for a day in that schedule in that order. In , column represents the time of an available schedule and column represents the number of available appointments for a given time. In , column represents the time of the appointment and, represents the number of people that have appointment starting from the given time (there's a catch here). I am given a task to prepare a function, that returns a list of times available for a given free-schedule, already appointed appointments and a given size of people. There's only one catch: In a group of people making an appointment their appointment times have to be one after another, as in if there are a group of 3 people trying to get appointment for o'clock, then all three of , , needs to have greater than or equal to on the schedule. Code: 

Your code contains code to perform transport security and - what I presume is - in place encryption using passwords. It's therefore try-to-do everything code. That kind of code should not be written in the first place. Cryptography related code should be written with a specific use case in mind. Generic crypto code should be a very well written API so it can be used for those kind of use cases, and this is not it. Your transport mode security seems to contain key agreement but not authentication. There doesn't seem to be any warning about this in the comments. 

Your constant time function looks very much run-of-the-mill constant time, which in this case is great :) I don't think HKDF warrants a function where and are compared using a random key - but now you know about that neat little trick. Note that you may want to make sure that you document that the comparison needs to be done in constant time or include it in a verify function (beware of truncated values - you did this in your code, but you need to consider it in the calling code as well!).