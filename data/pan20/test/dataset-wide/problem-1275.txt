Concentrating on the method, I see three times so that is something I would move to a common place. In fact, only its last argument -- lets call it -- changes. The initial value for is actually the default for when the two -statements don't fire. So I would put that initial value as an to that -statement. Last but not least: accounts for most of the clutter. By specifying an alias ( at the top) it conveys more meaning and makes it all more readable. The end result would be like this: 

Are there any other reasons for using the -syntax without filtering, selecting or ordering that I might have missed? Which syntax is better and why? 

He said that while is an field, this is the way it is supposed to be written in Linq, and everyone does it this way. It also allows one to add -clauses later on easily. On the other hand, Reflector shows that a new delegate is created that is passed to the function on the observable, but that function always returns just , so it seems to me it also has a slight overhead. So I don't agree with him and would have written it as follows: 

In regards to the switch-statement: essentially there are four ways to accomplish what you want to do: as a switch-statement, as multiple if-statements, using inheritance, or as an index into a delegate array of functions. Multiple if-statements are probably uglier in this case than a switch-statement, and inheritance would require a complete rewrite of the Urgency enum to a class hierarchy. The index into a delegate array of functions would look like this: 

In response to your latest edits: I think that your method is quite short, concise and easy to read. Maybe the length of the if-conditions make you think it is ugly, but there is not much you can do about it. One important remark: in the variable should never be null, or you'll get a later on, somewhere else. I therefore strongly recommend that you throw a in the switch case and remove the from the line . Two reasons: if you ever add a new enum member to and you forget to add the appropriate to the switch, you'll get an exception right there in your switch instead of in some other method (e.g. ). If you then do add the case but forget to set the variable to something valid, you'll get a compiler error stating that might be used while it has not been assigned a value. This way you ensure that is never null and that your switch covers all cases. Further, on more personal preferences: I'd rename to something like . The fact that it is conditional is an implementation detail: you might later on change how the formatting is done and this should not require you to change the name of the method. And it formats only one row, so use singular instead of . You could also rename to just as that's what it does. Lastly, your method does not care about or , yet is asks for them. Your method cares about so that's what I would put in the parameters. This also makes your testing easier, as you can just put a single value in the method and see how it works. The conversion from and to an enumeration member may then be done somewhere else, and tested separately. 

Do you plan to extend this class? If not, I would mark it as . Given its nature, inheritance can open a Pandora box. 

Correctness Does it even work? Did you write unit tests for it? For example I can't see where the method makes any use of argument (other than to assert it's not null). 

No. ViewModel - as the name itself indicates - should only model the view. Business logic, such as validating a certificate, should be extracted to another class (a service), adhering to the Single Responsibility Principle. This includes handling any errors that occur. Extract elsewhere. 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

We're not overwriting now, but when I look at it, I feel it sacrificed too much readability just for that, and what's worse, it got error-prone in process: you now have to remember to always use the last variable so as not to skip a step. If another parameter was to be added, there's a risk of a bug slipping in: 

Beware of a lesser known gotcha. This may not work as expected for that's not "really" a (it's not in s inheritance tree), only has an explicit cast operator defined allowing it to be casted to . In that case while would return a instance, won't even be called because your check would prevent this from happening. Other than that, I'd have some remarks related to naming and code style (rather subjective, so treat them as suggestions or food for thought more than claims your code is incorrect) 

Not always. It can also return an error. Exposing crucial request settings as public properties (rather than eg. method or constructor parameters) is questionable too, in my opinion. It doesn't enforce calling code to supply the necessary minimum of information required for the request to succeed. So it's not a particularly friendly API, if I the burden of remembering which properties need to be set is still on me. Your method doesn't even validate it explicitly - eg. if is not set, I'll just get an exception from complaining about the lack of , and you're leaving it up to me to figure out that it translates to the not being set. Same with . Such mutability also introduces an inherent lack of thread safety - what if someone changes one of these properties (from another thread) while is being executed and is half-way through? We don't always need thread safety, but it's one thing not to implement it at all, sort of ignoring the issue altogether, and another: to throw it out of the window by design, for no good reason. Other things being equal, I'd say prefer stateless/immutable objects to stateful/mutable ones. Naming: if the class is named already, there's little point in naming all its properties , , etc. (with curious omission of - why not , then?). It's known as Smurf naming convention anti-pattern. 

A collection should be plural, and names should be in English. Here we see and example of what I said 

When the reader sees the first one, he needs to remember what "m_firstMove" meant. On the other hand, if you read "isThisTheFirstMove" you are given the whole information and you don't need to go to the declaration of the variable to see what that means. 

If a name needs a comment to explain it, it's a bad name! What does m_move mean? "cpu's move" isn't a good comment. By the way, there should be as little explanatory comments as possible and "cpu's move" does not explain what is the variable meaning. Does it say if it is the CPU turn? or does it say how many moves has the CPU done? No one can tell. 

Note that we won't need a comment to explain the variable because its name does it! One of the advantages of this is that whenever you see the variable you see the complete information. Compare 

If you did that with every awful-to-read if statement, the method would be less than 10 lines and would be easier to read. There is a LOT more to cover, but I would spend my entire night doing it. However, this hopefully gave you a starting point of improving your code readability, please take a look at the book and Happy Coding! 

you can sort of guess what is . Is it the position of the text area? why just don't just put and , not perfect (I mean, for sure there should be a better name) but at least it improves a little the readability. In the book "clean code" you can find "A name that makes you go into the code to see that it tries to identify, is a bad name" That's all I would recommend based on the book and experiences I've got as a developer. Happy coding! 

But I know that a constructor initializes a new instance of a class. This is true for C# in general, and it's in no way specific to this class. It may be a useful piece of info if I didn't know that sitting down to read this code, but it means these documentation comments become a C# tutorial for beginners now, which isn't their purpose. Or: 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

It's simplier. Alternatively you could use a regex pattern and get rid of all the injection chars in one go (with ) rather than one by one. I'm not too fond of the name - it's actually filtering the injection characters out. Personally I'd rename it to - somewhat clearer to me - or perhaps just , which is a widely recognized synonym for this operation. 

Looking for an element and finding out that it's NOT present in the collection IS a successful operation. Just because an operation renderered a negative answer doesn't mean it failed. The purpose was to find this answer, and this we did. Encapsulation I don't like that is public. Wouldn't a more restrictive visibility modifier do? Rendundancies As I pointed out before, after a is always redundant. 

Naming Unlike in Java, constants in C# aren't normally named with all caps and underscores (). Methods names shouldn't be lower-case (). Names such as are way too long, and they don't describe the method well. A method should be named for what it does, not when or why it does that. A method doesn't know who calls it and in what scenario or context it happens. That's not its responsibility. A method knows what it does itself. The calling code knows when and why to use it. That's how responsibility is dealt. A pickaxe doesn't need to know it's in a coal mine. When a method's name starts with "if", it's already very suspicious. Structure is a class field, and yet methods are passing it to eachother as a parameter. This is confusing: every method has access to all class members by itself, they don't need to piggyback on other methods for that purpose. Redundant clauses