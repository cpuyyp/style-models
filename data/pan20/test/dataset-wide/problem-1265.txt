It's petty, and doesn't really matter, but I might do this the other way round for consistency, or better yet, leave a single explanatory comment. 

You print all of the multiples of 3 or 5 below 1000. To meet the spec, you need to actually sum up all of the elements of . 

Well, if you don't think you could ever get there, maybe you should throw an exception? If you don't think an exception is necessary, or don't want to throw one in production, then consider using to ensure that you're aware of it if you ever do end up in this logic branch. 

As you can see, the Linq version nearly always outperforms your method on mostly invalid input. However, on mostly valid input, it performs roughly the same; it's sometimes better, sometimes worse. I suspect this is because the Linq version bails out of the check earlier on invalid input. Here's the final version of the benchmarking code. It exceed's .NetFiddle's memory limits, so you'll need to paste it into a C# console program to see the results of the higher sample sizes. If you're either uncomfortable with Linq, or really looking to just push the performance to the absolute best it can be, then we can just modify your original algorithm to return early when we know that the answer is false. 

Need I say more? What is ? It might be clear here where it's defined, but it won't be later when we need to select or join on it. Always keep in mind that code gets read many more times than it gets written. It needs to make sense to anyone who reads it (including yourself) 6 months or 2 years from now. 

Same goes for this logic, but it will take three parameters instead. I'll leave the actual building of that function as an exercise for you. Look for other places where you're repeating the same logic and create subs and functions for those as well. 

If you're going to insist on it, why bother using a variable? Just return it directly. I really do recommend being a little more verbose here though. We don't get any extra points for writing hard to read on liners. 

I understand that this is an educational exercise, but naming is important. One and two letter names are highly discouraged. When Mr. Maintainer has to map letters to meanings it becomes difficult for him to focus on what's actually happening, because he has to constantly remember that means element and is a . I'm not even going to mention how terrible and are. Oops, I just did. =;)- It's also standard in C# to put opening braces on a new line instead of using Java style Egyptian braces. A dev who swims in C# on a regular basis may have a hard time reading this code as it is. You were consistent though, so I can't complain a whole lot about it. I question the use of a statement in . Typically, switch is used when there are multiple cases to test. I think an statement would work just fine there. 

All in all it's the most readable bf I've laid my eyes on though. However, don't take my omission of commenting on the actual code as an indication that it was done right. Truthfully, I've no idea. I'd have to brush up on Turing machines and spend some time writing something simple just to get into the right mindset to decipher this. I mostly wanted to post an answer so that maybe it would prod someone else into taking a serious look at it. 

I've never implemented a binary search before. So, even though all of my tests pass, I'm not sure that I've covered all of the corner cases. It also doesn't look very elegant. How can I improve on this? I'm also still not sure that I'm unit testing in a "proper" way. How can I improve them? (Please keep in mind that Rubberduck automatically inserts boilerplate for new test methods.) Chop 

But, it's kind of hard to remember what all those numbers represent. I'd define a couple of enums too. Create one for , , and maybe even create one for your cards too. An enum for your cards isn't the best way to go, but it's a good first step in the right direction. One last note: sounds like a Boolean, but has at least 3 distinct states. I'm reminded of What is truth?. Consider finding a better name for that variable. 

This executes for each record in the table. You only need to do this once; outside of the loop. ...and then you split it onto an array. Which I guess is ok because you don't want to check the first or last records for some reason. There's something smelly here, but I don't see how to fix it. Maybe another reviewer can comment on that. Now we're into the third loop. Again, There's no reason to . Just call . I can't quite figure out what you're doing here, but you probably want a series of SQL delete & update statements instead. 

Which seems close at a glance, but really doesn't hit the nail on the head. An ArgumentException would be much more appropriate here. Even better, use an exception to perfectly describe what went wrong. 

So, first off, I like that you're correctly adding to the error number. What I don't like is if I want to add a new error, I have to manually look at the whole file to see if I'm reusing one. This is a great use of an . 

This is good. It means you can just swap out the color if you want to change the color. You won't need to hunt down each and every usage in your code and make decisions on a one by one basis. However, I don't understand why you're fully qualifying the path. You already included The namespace. So, you could shorten all of those assignments down to just . 

Reaching the default case here shouldn't ever happen. Right? Then isn't that exceptional behavior? If I'm wrong and the idea is simply to break, then a good comment is in order to let the maintainer know that you considered the default case and no action is appropriate. 

Doc Comments Well done! I rarely see a single method so thoroughly documented with XML doc comments. There's a catch though. Be careful about just how much you do this. It can really obstruct the readability of the actual code. I count roughly 20 lines of documentations here. Is all of that really necessary? I don't think it is. For example: 

The very first thing you need to do is make sure that your form is not responsible for retrieving the DataTable. You will never be able to test this code if the form is responsible for retrieving the data. It needs to be provided the data via a constructor or property. The Presenter should be responsible for providing it to the View. Most likely, it will delegate this responsibility to another class, but ultimately, the Presenter will pass the information from that class to the view. You'll also need to properly model the data. Right now, there's no concept of a in this code, but there's obviously a business object that is very much a Part and your form displays a list of Parts. I'd start with defining a simple class defining the data structure itself, and add logic to it as necessary. Eventually, this is where your validation logic will lie. 

And so on. With this method of creating new types of coloring schemes, you don't even have to open up the file. You just create a new child class and over ride . There is one more refactoring that should probably happen though. The "If style == alert then set background color" logic gets repeated in each and every one of these overrides. It could be simplified by extracting this logic into a protected method of your base class. 

We've lost the abstraction, but gained a ton of usability/maintainability by getting on the right level of abstraction and encapsulating the view's data. If we want to modify the view's data, we need to go through the view to do it. The best part, is that the framework handles the databinding and UI updating for us. Win. What's not so nice about this, is that is very much a WinForms thing. We couldn't create a WPF or some sort of web view that uses the same Presenter class, so maybe this isn't quite the right level of abstraction. You know what though? That's probably okay. There are two types of coupling: Physical and Logical. No matter what we do to physically decouple the View from the Presenter, they will still be logically tightly coupled. If the view changes, the presenter will likely need to change too. That's just how it is. Being that Rubberduck is an add-in for a desktop application, it's unlikely you'll ever create a web based view of this logic anyway. That said, if you're really concerned about leaky abstractions and the ability to easily move to WPF, you can define the lists of things in your interface to be s. Both BindingList and ObservableCollection inherit from , so defining your interface to return a collection, and backing it in your implementation with a binding list works perfectly well. 

That's not a very C# way to name private fields. C# is case sensitive, so we don't have to use those nasty prefixes. We just the names. 

But we have to ask ourselves if this is real duplication, or apparent duplication. The fact is, the business logic is extremely likely to be different for these two objects. They might be identical now, but in 6 months time, they won't be. The logic is going to drift apart and you'll be left wishing they didn't inherit from the same base class. The code is fine. Ship it. 

If for some reason that doesn't work, I would recommend switching from to . The latter forces you to assign some value to the arg before the method exits. 

Normally, I'd say that this is dead code and you should kill it, but I get why you've done this. It's good documentation and all the work is already done should you decide that you need any of these additional values. I'd leave a comment threatening a psychotic episode should anyone ever "be helpful" and remove it, because, let's face it, someone like me could easily come along and wipe out all this "dead code" without batting an eye about it. 

This is already making your code more readable at a high level. If anyone wants the details, they can dig into these private functions. We've also entirely eliminated a variable by doing this. 

In summary, this is a lot of work and complexity to add to your project. As you can see, it's a bit difficult to get the Disposable pattern right. Weigh your options here. This is really only worth it if you're calling this code a lot. Every time I've ever found myself thinking that I need to implement , I was wrong. Each and every time I was able to create a cohesive class that avoided keeping disposable objects as members. Instead, I found ways to kept each call to the disposable object short lived. I challenge you to see if you really need the to live for the lifetime of this class. I would try to keep it inside of a block in the method you'd like to call. 

Same advice here. These variables should be private to the script. Also, you're reassigning the same value to the same variable just a few lines apart?? Make it a constant and forget it. I try not to pick on names, but would be better named . The latter seems to be an idiom in the community. Generally, I don't recommend overly abbreviated names like this, but idioms are ok. VBA/VBScript developers will recognize both of these as a . 

What's the difference? Not much to be honest. The win here is that each instruction is on its own line, hence easily understood to be two instructions, not one. You also have commented out code in your method. Commented out code is dead code. Dead code is clutter. Remove clutter. 

If you need to create this same Moq for many tests, it would be better to use the attribute and have it set up prior to each test method being run. See this for more information. 

I kind of wish you had posted the elevator class as well, but it's kind of interesting how you much you can tell about the CUT (code under test) from looking at the just the tests themselves. First, your elevator shouldn't be responsible for getting what floor it should go to from the user. Your program should tell it where to go. If you inverted control, you wouldn't have to subclass the code under test in order to test it. Which brings me to my second point... If you have to mock the CUT, you're no longer actually testing anything. You can't have confidence that your real class is going to behave as you expect it to, because you've very explicitly changed how it behaves. You're not testing your elevator. You're testing your mock elevators, which is no test at all. Sure, you are testing the elevator. I know that, but certainly, this class has too many responsibilities. It shouldn't be getting user input from the console. How could you possibly reuse the elevator class in a GUI application later? 

Which means that you'll need to modify the signature of your method to be compatible with async/await. 

So, a file structure (at the level of abstraction that we tend to think of them on) is a tree structure. Now, I think your tree implementation is really pretty good, except you've gotten the reason you built it and what it is all mixed up. You've botched the abstraction and that is why you're confused about it.