As is a singleton it should be thread safe. ConcurrentDictionary is a nice fit for this. Using the code would look like this: 

Starting a task and the immediately block () is a huge antipattern. All the downsides and no benefit, the calling thread is freezing your UI now. Also there is overhead in creating running a task so it will block even longer. By doing this you open up the door for deadlocks and race conditions, all kinds of pain. When you start a task prefer it is shorter and you can't forget to call Start(). Normally you don't want to start a task to block for IO. If you use a task you should do all the way. 

One could get doubles for RGB by using a provider that returns at least 24 bits (such as ) combined with some altered sampling logic: 

Over the weekend this article inspired me to write an ASCII string implementation that avoids memory allocation during basic operations like and . It's still a work-in-progress but I think this is a solid foundation to build off of and wanted some help checking my logic/maths. The main method of interest is the overload of that accepts an offset and a count since most other methods are implemented by calling it. 

returns an instance that only has one method The method returns the same instance but as that exposes the 

Regarding Singleton Try to use the IoC-container for singletons. It makes it easier to test and makes references explicit. Avoid doing all over the place. Note that a class can still be implemented as a singleton but consumed via the container. 

LINQ does not add much imo, if the logic was more complicated the for loops are nicer to debug. One downside with LINQ for this is that it requires formatting to be readable. If you rename things the formatting needs to be maintained. With the foreach loops you get formatting for free. Edit: As per @RobH's suggestion: 

No need to implement on every DTO, nor is a common interface required. Use generics and a lambda to access a property of a given : 

If you're going to spend the time abstracting things then you probably want to invest some effort in refactoring a lot of your common logic into helper functions. Starting with the very first issue, a hard-coded connection string, we can create a function that'll build one out of components: 

Finally, we can add some helper methods to simplify the creation of commands, execution of SQL, and retrieval of single values: 

Ending here, really nice code, not much of a review. As with all things related to performance, profile first and profile after if you decide to optimize. 

Nice and declarative, you see what the code does at a glance. And you can compose with , , , etc. as you need. 

Nothing wrong with your code. If you want you can use linq if performance is not critical. PseudoCode: 

Putting the as single child of the grid is wasteful. Add to the grid. As a rule of thumb is almost never right. After writing WPF for a couple of years you will probably find yourself using ~95% of the time. Grid is a bit verbose but it is the panel you will not have to refactor away from. Also Grid makes reasoning about layout simpler. You can try this to bring down the verbosity a bit. You can add BindsTwoWayByDefault to EightPieceBoard.Selection but I don't mind being expliclit about it. The viewmodel should not know about the view: it makes testing harder and is smelly in general. Not a clean separation of responsibilites between view & viewmodel. 

There are an infinite number of ways to do this but one possible approach would be to use a dedicated hash function to compress your inputs; out of sheer laziness and convenience I chose to use the built-in for my example. To improve the performance characteristics of your code I hoisted the construction of the hashing class up a level and use so that we only have to instantiate it once per call instead of once per string. I then chose to sample the first three bytes of the hash result in order to come up with values for , , and . 

Same as above, don't add the grid as single child to the outer grid. This can hurts performance and is noisy to read. Better with a grid than a stackpanel though :) 

I would probably not have this as an extension method as it doesn't mean any real reuse of code. For cancellation you can use this: 

In my experience there is rarely a need for delayed invokes on the dispatcher, what problem are you solving? If you do something in a constructor that you want deferred until loaded there is already an overload for that: 

I also went ahead and hoisted up the into a static field since there's no real security benefit gained by allocating a new one on every call. Usage in your current function is straightforward: 

By taking advantage of the operation and avoiding the use of and (as suggested by the great answers provided so far) I have come up with a version that avoids having two different algorithms. I was really thrilled by the elegance of the answer given by @t3chb0t but, unfortunately, the state machine turns out to be roughly 5x slower even when I replace the calls with more efficient code. I also loved the thoroughness of the response by @Hosch250 as it gave me the idea that I could collapse the two algorithms into one and a solid foundation to work with. There are some gymnastics being performed in the variable assignment in order to handle the loop direction and but other than that this feels far less "evil" than the original and it performs twice as fast to boot! 

Again pseudocode unless it happens to compile. Thought of one thing that might be a pretty big smell: What is up with the property initializers? When the data is read from attributes it feels like it should be readonly. If there is not a reason that they are mutable you should make the properties readonly and use constructor. 

1) What overloads make sense and what are missing if any? 2) I'm really not sure about if adding composite formats like where is for the scalar value and is for the unit is a good idea. 3) Is nobreaking space the best choice?