Personally, I can't really warm up to either version. I guess that to me, reversing a sequence is so obviously a fold, that anything which doesn't implement it as a fold looks just plain weird. I would have expected to see something much more like this: 

There should be a space on both sides of the sign. This applies to operators in general. [Note: there are some style guides that advocate not using spaces around the sign for optional parameters with default arguments, but a) this is not universally accepted and b) not the case here anyway.] 

There are two different camps when it comes to block styles: one camp says to use / for one-liners and / for multiple lines. The other camp says to use / for "functional" blocks and / for side-effecting blocks. Regardless of which camp you follow: your block has three lines and side-effects, so it should use the keyword form. 

The lambda returned by above function cannot be used with your unroller. To fix it (as a user of your unroller), you need another (non-mutable) lambda which references the original one: 

Handling of special values Ignoring for now, that the choice of returning a special value instead of throwing an exception (or using some other means of indicating error) when ing from an empty queue isn't that great. Then, if you have a special value ("magic value") like which will be returned on an empty queue, then it's crucial that you cannot push this value into the queue. So check for that in and . Useful testing 

Here you call , discard its result (return value) and then call it again, this time assigning the result to the local variable. separate calculation and output Instead of 

only iterate once over the characters Instead of first going one time over the characters to filter out non alphabetic characters and adjust the case of the alphabetic ones and then a second time to count, do it in one loop: 

Here is the code for each item: 1 - First the data context stored in either the current HttpContext.Current.Items collection (so it only lives for the life of the page and only is fired up once at the first requested) or if the HttpContext doesn't exist uses a ThreadSlot (in which case that code most clean it up itself, like a console app using it...): 

Data Context needs to be stored in a common memory space, easily accessible Transactions should take the same approach It must be disposed of properly Allows for better separation of business logic for Saving and Deleting in transactions. 

2 - To support transactions, I use a similar approach, and also include helper methods to Begin, Commit and Rollback: 

3b - I'm building this in MVC, so I have a "base" Controller class that all my controllers inherit from - this way the Context only lives from when first accessed on a request, and until the page is disposed, that way its not too "long running" 

You could save yourself some hassle here by using something else than to delimit the string. This pattern, where you initialize an accumulator to an "empty" value and then iterate over a collection while appending to the accumulator at every iteration, is called a Catamorphism, , or . In Ruby, it is known as . However, in this case, it can also be done even simpler, with a . 

This is such a perfect match for the Replace Conditional with Polymorphism Refactoring that it even looks as if it was specifically designed to demonstrate the Replace Conditional with Polymorphism Refactoring. I mean, the field it is basing its behavior on is even called ! 

I.e. implemented as a left fold. After all, reversing any sequence (not just strings) is really just the same as 

Here you check whether the key includes the search string. However, from the documentation in the spec, it appears that the search string should be a prefix of the key. Unfortunately, there is actually no test in the spec to test for that distinction. 

Note that our tests would have revealed this domain knowledge, too. Try the code without the condition and see which tests fail. Finally: Tests pass. Fine. I hope this is of potential use for you. (Ideone link with above code) 

From a style perspective, I'd change the order of the template parameters to reflect the order in which the typenames appear in the parameter list (first the , then the ). Then there's one thing that's a bit odd: Functions in the standard library which accept function objects (like , , ...) generally accept those function objects by value. This is done (probably) because that allows those functions objects to have mutable state. Your unroller accepts only references to constant function objects. That makes it (a bit) harder to have mutable state in the function object, like when you get one returned by some function: 

I think you do this to clearly separate between local variables / function parameters / global variables and the data members of the class. I've done this, too. But I think it's a reasonable assumption to make that somebody reading your code knows that data members can be accessed without , and to know (at least roughly) the rules regarding name resolution. And, moreover, you already have something in place to distinguish between data members and "the rest": That prefix. I read that as ember, or alternatively as atrix. Having both just means more to type and more to read. And the long lines suffer somewhat from that "more". Compare: 

Indentation in Ruby is two spaces, not four. You have that correct in your specs, but not in the application code. Also, you create here a pair of methods, which you never use anywhere, and , which you overwrite further down, anyway. Either get rid of this line, or (preferred!) actually make use of those methods. 

You should never compare the class of an object like this. Ideally, you should use runtime ad-hoc polymorphism. If that isn't possible, at least use , , or . 

The other answers are already very good, but I want to point out one stylistic detail the other answers missed: should be called , there should be no bang in the method name. The bang is used to point out the more surprising one of a pair of methods, i.e. when you have both and , then is the more surprising one. However, you only have one method, so it shouldn't have a bang. Bang methods always come in pairs!