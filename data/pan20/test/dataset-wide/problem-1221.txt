If your destructor does nothing then don't declare it. The compiler generated version will work perfectly well. 

Yes it is a bad idea. TOTAL_TIME being a macro pollutes the whole namespace with its mess. In C++11 the ability to initialize these values in the class definition was introduced. Use that instead. 

OK. Personal opinio: . Best way to break your objects encapsulation ever invented. Also it tightly couples your class to always providing this interface in the future as somebody will use it and then you will have to maintain it. 

You allocate a buffer (str) of buflen bytes. This means you can index it (str) from 0 -> (buflen-1). Thus the accesses above is writing one past the end of the buffer and corrupting memory. You probably meant: 

This creates a temporary object then copy constructs it into the vector (you may get a move if you have a move constructor). But you can get the vecotr to build the object in place rather than creating a temporary then copying by using emplace. 

Comment on Style The problem I have with C programs is that people continuously fail to check if there system calls worked. You should always check the result of a system call. This is doubly true when getting user input. Users a re dumb stupid animals and will do the most random things. You should program defensively and validate all user input. Example: // System call and user input 

Prefer to use smaller than than smaller than or equal. This is a bit nit-picky but when working with array bounds you can then use the same number in the test as in the size of the array, wich makes it slightly easier to read. 

We can simplify that a lot. You are not really using RAII on the as you declare it in one place then initialize it in another. But is a type as you pass a pointer around. Why not simplify a bit: 

Also I see you don't normalize your results. You could have 1 foot 300.05 inches. When ever the state of an object changes where one parameter flows into another you should normalize the data. Have an explicit function to do so and call it each time state changes: 

Declare variables as close to the point of usage as you need them. Declaring them out here seems like a waste. Also it makes the code more complex as you have to reset things manually rather than let the compiler do it. 

This way in the tree code it can be referenced as rather than . Slightly shorter. More importantly the is an implementation detail that need not be exposed to the user of the tree. By exposing it you are leaking implementation details and binding your self to maintaining it. Side note on naming. User defined types usually start with an upper case letter. While variables and functions start with a lower case letter. In C++ were types are exceedingly important information it allows you to quickly visually identify a type and thus understand the meaning of the code quicker. I don't see the need for a member. It just makes things more complex. Why are you using ? Does the node own it's left and right children. What other object a node other than its parent? Seems like a bad choice in my opinion and you could simplify your code by using . In all your traversals you have a function to do the work on each node. 

Your member handles all this automatically. You don't need to define a constructor. Prefer not to be pass objects by value. 

Thats not a good interface for C++. Once the constructor is finished the object should be in a usable state. I would have a helper struct that has all the objects you need that can be filled out manually. Then a constructor that takes that helper object or a full URI. 

I believe you will find that you slightly pesimizing searches for big numbers but slightly optimizing searches for small numbers. The other things is if you have multiple values that match your key then you return a random one of these values. It might be more logical to return the first one? If you want to return a random one then you should definitely document that fact. 

All seems good. As you mentioned it is sensitive to trailing slash being missing. I would just force that issue and always append one between the prefix and the path. An extra slash will not hurt but a missing one will. Apart from not using C in the first place :-) all my other issues are simple stylistic ones that only 30% of people would agree (I always divide stylistic camps as 30% Side A, 30% side ~A, 40% don't care). A tiny bit more white space to make it easier to read. But let me just say your code is not bad in that regards (just slightly less than I would use). I don't want to recommend any particular style. But I can show you how I would have written it: 

Otherwise the web server does not know where the next HTTP request starts. This is especially important when the HEADER is passed as the connection from the client will not close and the next request will be written to the same connection. 

Style Please learn to indent your code consistently. This is really hard to read and make sure ti works. Algorithm I would expect both and to have a complexity of O(1). Unfortunately the pop is O(n) as you have to search to the end to remove the last item. 

Rather then specify the long winded and fully qualified type for the std::pair let the compiler deduce the type for you use std::make_pair. 

Depends on the goals of the competition. But I find that if you have a clear set of interacting classes then the it reduces the overall code size. This in turn will reduce the time it takes to write the code. 

Returning a copy is probably not what you want (especially for anything interesting). But returning a reference is not really an option either as that opens you to situations where you have race conditions (you have a reference to the top object and another thread pops it (destroying it) just before you call a method). So you need to provide a method for accessing the object while maintaining the lock (this will probably require the return of a wrapper object that maintains a lock on the queue) or alternatively removing this function. Other non C++ things that should be addressed: The mutex should be locked/unlocked using RAII. You are leaving your code open to exception handling problems. If an exception is generated by which you have no control over then you could leave your queue in an unusable state with the mutex locked and no way to unlock it (because the stack of the locker has been unwound past the unlock because of an exception). Yes this is correct: 

Prefixing the function name to prevent collisions is real old school C. We have better constructs for that. Use a namespace it prevents clashes. 

In your function counting characters in the path. You basically traverse the string twice. Why not combine the two traversals into a single pass: 

BUT not all the numbers have an even probability. Assuming RAND_MAX is 32768 (a common value). Then the number 1->68 have a slightly higher probability than the number 69->100. To get an even distribution you need to compensate for this: