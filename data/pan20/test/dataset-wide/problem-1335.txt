Algorithms and performances In the case of programming problems like the one you are trying to solve, the real issue is usually the complexity of your algorithm, how it behaves on large inputs. In order to see how your code behaves on larges inputs, you have two main strategies (and you should try apply both): 

it will remove the duplicated logic and make your life easier if you want to change something in that part of the logic. 

I have no idea what you are trying to achieve here so here are a full general comments : The pythonic way to check is (if is known to be a container). Also 

If your code can potentially be used as a module, it is advised to put the part which actually does stuff in a function and guard the call to this function behind a condition. In your case, here's what I have : 

Style Python has a style guide called PEP 8 which is definitly worth reading and and worth following if you do not have good reasons not to. In you case, your function name for instance is not compliant to PEP8. You'll find tools online to check your code compliancy to PEP8 in a automated way if you want to. API / Function signature Your function signature is a bit unclear. This situation often happens when recursive solutions are applied. A good way to solve this would be to define another function calling the complicated function with the right arguments or to use default arguments. If I understood everything properly, the point if to get the n-th performutation from a list. A simple way to do so would be to have a function taking the and the as an argument. Testing In order to keep things simple, it is a good option to write a simple (even if inefficient) solution to be able to see patterns and/or write tests to ensure that your more efficient works and is indeed more efficient. A very simple solution could be written like this : 

Tests It's a good thing you've provided tests and expected output so that one can check the behavior, it is even better if one can run the tests without having to check that the output is correct. Only a tiny bit of reorganisation is required to get : 

At the moment, your current code does not handle properly the fact that a short word can be followed by a long word. The input can show you what happens. Two solutions to this problem : 

An optimisation You are getting the prime factorisation testing divisibility of various numbers. You know that if you find a divisors that way, it has to be prime but it will also be such that ( being the "current" version of the variable, not the one passed as an argument). Thus, you can stop the loop much earlier : . A tiny bug Because this has no impact on your code, you have no particular way to identify this but the prime decomposition of 2 gives 2*2 which is obviously wrong. It could be interesting to add (in the debug version) some check that the product of the factors gives the original number. 

thousandUp: Once the code is simplified, we realise that as described in Janne Karila's comment, we could use to call , killing many birds with one stone : 

Now, there is quite a lot of code and I have a limited times so I'll just point out other things that could easily be improved. Basic logic By reorganising the code in : 

I think in your case, it would be more explicit to define a dictionnary mapping field names to function being called to set these fielde. It would make the code easier to search in. My first idea going too quickly over your code was "these functions are called nowhere", I was obviously wrong but you can see why I thought so. This could be done via the not-so-beautiful: 

Before anything, I'll let you search on the web why this might not be such a good idea and I'll just focus on the code. 

Code organisation On this kind of task, it is usually worth trying to split the input/output logic from the actual computing logic. Here, you could define 2 functions : one to initialise some object like structure from a string, one to use the structure to get the Kth character (K being the argument to the method). This would allow you to write unit tests which would help you improve your algorithm. Algorithm You have used the correct ideas : use the proper data structure to store the different values used. An improvement you could implement is to define a structure with the cumulated numbers that you compute once so that then you can get the kth element with a simple array lookup (actually as suggested by ChrisWue, maybe you'd need a binary search and not a single lookup). When multiple queries are performed (which is I think what is happening in your case), this should make things much faster. The idea of doing some ("long") preprocessing once to make (multiple) queries much faster is a pretty classic solution in real life and in programming challenges. 

As you have updated your examples, you can write some code to ensure the code we are about to write works properly : 

In your case, we can remove a level of function call because could take the function as a parameter. Ultimately, I am not convinced that it makes sense to have a at all. You'd get: 

As a simple comment, a function called should probably return a boolean. Then, the calling function can use that boolean to print either "Jolly" or "Not jolly". 

Warning Enabling your compiler's warnings would tell you that is unused. Variable declarations Following previous comments, I consider it good practice to declare your variable in the smallest possible scope and as late as possible. This makes things clearer (and prevent you from having unused variables). Using a "recent" version of C allows you to declare your variable in the loop. While/for Your loop over is written as a loop but could be written as a loop. i=i++ This is pretty weird code and according to my compiler warnings, might be undefined behavior. 

Not that it is much easier to understand which function is responsible for what. Once this is done, a few things can still be improved : your function names can be clearer and you can had documentation. Also, you should try to be more precise when catching exceptions. 

As far as I can tell, using like you did is ok. However, I guess you should handle values that could be out of the range you are expecting (I couldn't find easily something telling which range of values can be returned). 

Notice that splitting the code into small function somehow removes the need for some comments. Also, you can appreciate the fact that defining variables in a small scope makes this task much easier. Early break When you set to true, you can break, there is no need to go any further in the loop. This also applies to Also, if no was found, you could return directly from the function without going through the whole logic. Once again, this is easier now that we've defined our logic in a small function (when everything is in the , you can't easily "return" a partial result). Also, you can instead of having a goto and then you return whenever no possible modification was found. At this stage, the function looks like: 

In order to to this properly, you could/should a proper test framework. Also , it would be worth adding tests for invalid inputs... Back to Now that I have tests to protect me, I can mess with the function a bit more. It looks like the bit I did not get can be replaced by: 

Your code looks nice, well documented and is split into small functions. Also, you've used the which is a nice touch hardly ever found in beginniner's code. Congratulations! Let's try to see if the code can be improved anyway :) Style There is an official standard Python style guide called PEP 8. This is highly recommended reading. It gives guidelines to help writing code that is both readable and consistent. The Python community tries to follow these guidelines, more or less strictly (a key aspect of PEP 8 is that it provides guidelines and not strict rules to follow blindly). It deals with various aspects of the code style: naming conventions, indentation convention, etc. You'll find various tools to try to check whether your code is PEP 8 compliant and if is it not, to try and fix this: 

Rewrite your comparisons In Python, you can write comparisons in a very natural way : becomes . Use smart indices to get the last element of array You can rewrite with the much clearer . Rethink your logic You have and going from to (included). Thus, is not an interesting condition to check. The same goes for . Once this is removed, we have : 

Making things more simple First, can be replaced by . Then, you can replace with list comprehension : . Your code becomes : 

Style The name is pretty bad. One would expect it to create a card and return it. Making things easier to change At the moment, if you ever want to use 4 or 5 cards instead of 3, you have to update code in multiple places : , (3 times) and add tests like . This is just too easy to get wrong. Even assuming you can only use , you have various ways to achieve what you are doing in a less repetitive way. First idea would be to tell that once you've generated the position for Q with , you know you have 'A' cards before it and after. This becomes : 

For a start : your naming convention does not follow PEP 8 which is the usually accepted style guide for python code. 

To be continued (for instance because you do not need loops at all) but in the meantime, the code looks like : 

and then, becomes is known to be an integer at all time, the second condition will always be true if the first is false : we don't need it. Last details on this : the pythonic way to write is . It applies to because it will be a positive-or-null integer. Thus, you can write : Now, we can actually go into your issue : your function could return the number of picked apple and shouldn't print about the total number of apples and gold. 

Simimarly, the divisibility by 9 does not need to be checked because of the following rule (and the fact that the sum of the first 10 numbers is divisible by 9) : remove that check and you have yet another performance gain. However, for an actual gain, you could go the other wat round : trying to build number by looking at the different candidates of length 1, 2, and so on. Here is how I did it and it seems to be really fast :