Also please note that may not be the best name as I may lead to confusion with factorial often being called . 

Algorithmic trick A trick could be to say that if you have a current result of length , you don't care about any substring of length . Thus, you can check backward from position : as long as it is in descending order, you continue, otherwise, it gives you a starting position to start again. I am not sure if this is really clear. I'll tr to improve asap. 

subThousand: This function (and it might be the case for the others as well but I have to progress one function at a time) should probably be fed an integer and not a string. Operation on numbers should be enough for pretty much everything. 

This is quite easy to fix : just comment this part of the line or put it with the part of the code it goes with. Here's the result of the second run : 

This is much faster but I'm pretty sure there is a way to do better. For instance, substrings of same lengths could be considered together to perform a smaller number of divisions. 

Even after taking into account Cherubim Anand's good answer, you can still make faster using a better algorithm based on mathematical properties like: $$if n = \prod_{i=1}^r p_i^{a_i}, facts(n)=\prod_{i=1}^r (a_i+1).$$ Thus, iterating over number to identify prime factors and their exponents, you can easily determine the number of factors. 

You don't need an array You do not need to keep track of all the computed values, only the last 2. You could write something like: 

Purely personal but I'd rather avoid whenever it can be easily avoided. If your case, it's quite easy to put the whole block behind a (or even better : ). However, things could be even more straightforward : and could start at because first iteration won't do anything anyway because condition will be true. Then, as far as I can tell, the guard is not needed anymore. 

It looks a bit like half a solution but it is not so bad... Another more interesting way to handle this could be to take a more object-oriented approach and define classes (or a single class) to represent the multiple entities you work with and method to use them. For instance, a straightforward solution could be to use the values you keep forwarding from one function to another () as members of your class. Data type At the moment, cards are represented with a list containing a value and a suit. Even though this is technically correct, I'd rather use a tuple for this. I highly suggest reading Ned Batchelder's article about lists and tuples. Loop like a native In Python, you usually don't need to get elements from an object by index. What you want is usually to iterate over the different elements. I highly recommand reading/watching Ned Batchelder talk called "Loop Like A Native". (At this stage, I can confess that from my point of view, any article from Ned Batchelder, about Python or not, is worth reading, more than once). In your case, the functions becomes: 

Optimise memory usage You could optimise memory usage by not converting your iterators into list and by avoiding non-required steps (like ). Changing a few others details (formatting, adding tests, etc), you'd get something like: 

Also it is a good habit to put the part of your code actually doing things behind an guard. Style Python has a style guide called PEP 8. It is an interesting read and it is probably worth trying to follow it if you don't have a good reason not to. For instance, your code does not follow the naming convention. You'll find various tools to check your code compliancy to PEP 8. Final (untested) code The following code has not been tested, feel free to edit it to fix errors and typos I may have introduced. 

(One might also suggest using , I'll let you pick your favorite). Using the right tool is also choosing the right data structure. It would probably make sense for to take a list of tuples. Also, if you know that each elements contains 2 elements, you can use tuple unpacking like this : 

Disclaimer: I have never used or implemented Pollard's rho algorithm. calc_factor I think this function does not need to be a nested function. It could be a normal function on its own (and thus be documented accordingly). Maybe, its name and the name for its parameter could be updated for something that sounds more usual, maybe ... Instead of checking if at the beginning of the loop, you could check if just after updating the value of . Also, instead of trying to break out of 2 loops, you could simply return the value directly if and you realise you don't need to check the value of in other places. You'd get something like: 

About As far as I can tell, is interesting only in the method. You can propagage the relevant information (name and/or score) to the other method needing it. By doing this, you can again make things a lot simpler by just having a variable in . Extracting user interaction in separated functions It might be a good idea to extract the user interactions in separated functions. It makes input checking easier and make the game logic clearer. Here's what I have written : 

there is not point in adding a whitespace to at this stage. you do not need to use in all cases. as is "zero" only if , becomes as is never an empty string, this test has no reason to be there. (If you ever perform the change described above, will be empty when which is a case already handled). 

Different way to get the best result Instead of sorting all the results at the end, we could get track of the best result found so far. 

ÃŒ am not sure calls for list comprehension. I might be wrong but should do the trick. Same applies to other of your list comprehension. If you do want to create a new list out of the previous, does the trick but this is not required when using the slice operations as they return new list already. The is not really useful, is it ? is this any different from ? Then, I must confess I got lost in the middle of the code. Please have a look at what can be simplified based on my first comments. 

4) So far, the comments were about the php code and not the HTML output it produces. My last comment is more of a question but wouldn't there be a way to have your HTML defined in such a way that you don't need such a complicated logic. Basically, at the moment, the whole point is that your HTML code contains reference to your item in this order : 1,4,2,5,3,6. Things would be easier if you could have them in the natural order (1,2,3,4,5,6) in your HTML code and then update your HTML to display them in such a such a way. My HTML skills are way too limited to answer this question... 

Let's go one step further, please note that the deeper loop will not do anything if (this wasn't true before previous change but it is now correct). We can easily remove this pointless iterations (and the pointless check) : 

I reckon you should start by writing test cases and check that your code produces the results you are expecting. For instance, here is what I have written. I won't say it's bug free because I haven't spent much time on it but at least I have a bit of confidence because it seems to go through the different tests I have written : 

Bug I've found a bug in your code : the number of elements in is not , it is . If you want elements, you should use which can be more concisely written . Tiny improvements In your class, you do not need to have and . It is not needed and will only bring confusion. You do not need to convert the return for in . Boolean are integers with value 0 and 1 so everything will work just fine. doesn't need to be a float number, you could give it as an initial value (and not ). I guess you did this only to be able to perform a floatint point division. The best way to do so is to use because this is the default behavior for divisions in Python 3. This brings me to the fact that if you have no good reason to use Python 2 (dependencies on libraries using Python 2 only), you should try to use Python 3 to take the good habits. You have different methods to format strings which are all better than string concatenation. You'll find a lot of documentation about this. The plural for "try" is "tries", not "trys". At this stage, the code looks like: from future import division import math import random class RandPoint: def init(self): self.x = random.uniform(-1, 1) self.y = random.uniform(-1, 1) 

Shallow review seems to be variable that does not change, is the same for all instance and is used only in . You could define it as a "constant" or as a local variable in . The same thing applies to . 

Getting rid of magic numbers This in definitly sounds like a value I've seen in other places. Indeed, it is not just a random setting I can update if I ever want to : it corresponds to the maximum value can take. Its type is and the maximum value can be retrieved from limits.h : doing would probably make things easier to understand. 

Re-think your logic (ter) Nothing happens in the loop if as and are not changed. If this is really the case, we might as well just break out of the loop. However, things are even better than this : once again we are in a situation that cannot happen. This can be seen in two different ways : 

Making things even simpler You don't really care about the content of , just its length. Also, there's no need to check that it does not get longer that 2 at each iteration : just check when you update the list. Also, you can get rid of the list and make it a simple counter : 

Keeping things simple If you just want to write prime number on the standard output, you don't really need a temporary container for the numbers. Naming things 

Disclaimer : I am not quite sure how this is supposed to work and as far as I can tell the example you gave is wrong. Indeed, I don't have "right" in the output. I'll try give you a few advices anyway. Use the relevant type You are storing substrings in a dictionnary with a useless associated value. It seems like what you want to use is a . 

Some might consider the line in too long. I'll let you split it the way you want. A last detail would be a more pythonic name than . 

Style and tools Your code looks weird : you have line breaks in unexpected places but not in a few expected places (such as before defining a function), whitespaces are not consistent. In Python, you'll find PEP8, a style guide that can be quite helpful to you. Even better, you'll also find tools to detect problems such as pep8 and to fix them such as autopep8. You'll also find various other tools to check your code such as or and . They can be useful to find problems in your code. For instance, and (for your information, is the usual name for throw-way variables in Python). Finally, your variable names do not follow the convention. Once this is done, your code looks like : 

Also, you could return a pair of strings (stdout and stderr) instead of using global variables in a weird way b) Then later, do you need and even though they look quite similar ? c) In 

If you also use the ternary operator, remove the useless '== 1', store magic numbers in a unique place and factorize the mathematical expressions, you can transform this : 

Handle empty input You access the first element of the input without checking the length first. Maybe it'd be clearer to document this as an invalid input or you could handle it properly by returning . Removing duplicated logic When the empty case is handled, the case with 1 element doesn't need to be handled in a special way. With a few minor changes, you can write: 

Your loop can easily be rewritten into a more concise (and more efficient according to my benchmarks) way using : 

Style : PEP Compliance Your code looks nice and is well documented. You can use tools to check your code compliance to PEP 8 and PEP 257 : pep8 and pydocstyle (formerly pep257). PEP 8 warnings are about spacing and line length. PEP 257 warnings are about verbal form used (should be imperative and not declarative). Style : a step further A few details in your code are not very pythonic. The main one if the way you write loops. At a rule of thumb, any time you write in Python code, there might be a better way. Ned Batchelder's talk about loops might interest you. In your case, you could use zip or itertools.izip is what you need. Your code becomes : 

A more appropriate algorithm If you want to generate a list of primes (and non-primes) in an efficient way, you should have a look at the Sieve of Eratosthenes. 

things should be much faster already. Strange loop I must confess that really surprised me. What are you expecting from this loop? 

Disclaimer : this is not a proper code review. A different algorithm There is a O(n) in time and O(1) in space algorithm (and one can easily see that a smaller complexity cannot be achieved). You just need to XOR all elements so that the one in pairs cancel each other and you are left with the lonely integer. 

Before optimising your code, it is probably a good idea to write a few tests to ensure you don't break anything as you go. There is something quite good in your situation : your code is supposedly easy to test as you know the mathematical properties that your result should have : with . Writing something like : 

Loop with the proper tools Instead of using a convoluted loop to perform iterations, you could use a simple loop. Taking this chance to have initialised at the beginning of the loop, we'd have something like: 

Some more improvement (visible below) could be used (make go though and then only odd values) but the major point is to use the formula above. Benchmark: I've used the following code to ensure that the different functions lead to similar results (after some minor adjustment) and to evaluate the performances by counting the number of modulo operations. 

In a real life situation, I'd recommend exctracting the logic in the list comprehension into a function. 

Do less (again) From the code above, it is clear that elements from are already string but we have still calling on them. I expect this to be useless. Also, I expect the and tuples not to be useful. You could simply write: