Your code looks good to me, and I have only some minor remarks and suggestions. An Optional has an implicit initial value of , so 

(Remark: There was a language proposal to require self for accessing instance members, which was rejected recently. Also and will be deprecated soon and removed in Swift 3.) 

Then you use an auxiliary function for computing the second sum, but not for the first (and the name of that function is not very descriptive). In my opinion it is easier to understand if the shorthand notation is used for both summations: 

It would suffice to check only the rows which are changed by the last move. On the other hand, with 8 winning combinations, that does not make a big performance difference. 

because returns an optional. But this is not very effective. The method always traverses the entire array, but only the first (and only) matching tuple is needed. This can be achieved with : 

Now some remarks to your current implementation. First, I would put the computation into its own function and separate it from the I/O: 

and then is or a valid socket descriptor which is bound and listening. The more Swifty way however would be to define an optional 

so the "obfuscated" method is actually a tiny bit slower. But we can improve the performance. As you said, there is a lot of type conversions in 

and because it returns a non-optional . If you just want to return one of the two possible prototype cells then you don't need to cast at all. But there is no need to make an optional. You can even declare it as a constant, this allows the compiler to verify that it is assigned a value exactly once on each code path. 

The condition whether to insert the separator at an offset is quite complex and it is easy to make an error. A completely different approach would be a recursive implementation, which is (almost) self-explaining: 

you get rid of more forced unwrap operators. Finally, the textfield outlet is expected to be non-nil (otherwise you did not connect it correctly in the interface builder). That is the reason why it is declared as an implicitly unwrapped optional . There is no need for optional chaining in 

Here an "array slice" is created and then reduced. Note that this does not duplicate the element storage. Instead of appending a single-element array 

otherwise the result is not correct for ranges not starting at 1. With respect to performance: Your function counts all divisors of a number, but 

Spacing The usage of (horizontal) space is not consistent, you have a space after and , but not after and . I would generally use more whitespace to increase the readability, in particular after keywords, around operators, etc. For example 

With that change, your program computes all practical numbers up to 200 in 0.2 seconds, and up to 1,000 in 25 seconds (on a MacBook, compiled in Release mode, with optimization). 

then a piece table can be printed or used in string interpolation without explicit conversion to a string: 

Instead of a nested hash map containing the conversion factor from every unit to every other unit, it is sufficient to have a mapping from each unit to a single common unit, e.g. meter: 

Your calculations of seem unnecessary to me (and causes to more memory to be allocated than necessary). Here are some quotes of the C11 standard (taken from $URL$ 

The bottleneck seems to be the function. Since will usually be a small integer, it might be worth to use iterated multiplication instead: 

To address your "main need" first: Your algorithm starts with a single-element array, and then repeatedly calls to compute a new array, until the array is "constant". That can be done more clearly as 

would be stored as the vector . Binary multiplication of the matrix with a "string" (i.e. a 0/1 sequence of length ) is then simply done by XOR'ing those columns of the generator matrix for which the corresponding bit in the string is set. For example, the product of the above matrix with would be 

Here we know what the function is about, what does it do? Compute a happy number, check for happy number, ...? Code structure: The global variable is not used at all and can be removed. A global variable is used to "remember" the argument of the inital call to the recursive function, and the function (as a "side effect") appends to the global array. This is error-prone and not very elegant. I'd suggest to define a function instead, which takes a number and recursion limit, and returns True or False. The default recursion limit can be defined as a default parameter value: 

It is not apparent from the function name what the function does. Does is convert from or to ISBN-10, and from or to what? And why does a conversion function not return anything? You are calling at the end of the function: Whatever that is, it should not be part of the conversion. The validity of the input string is not verified. If the input is too short or too long, the result will be nonsense. If the input contains non-digits, the function will crash. A better function definition might be 

Generally your Swift code looks very good to me, and I could not detect something totally "unswifty". There are some things which can improved or simplified. vs You have defined as which is OK if you intend to pass references to a "Piece Table instances" around. In that case you can define instances as a constant (): 

Instead of named functions "fizzTest", "buzzTest", closures can be used to define the tests, and the entire rule set can be written as 

As observed in Computing the square root of a 64-bit integer, this can produce wrong results for large numbers, because an IEEE 64-bit floating point number with its 53 bit significand cannot represent large integers exactly. Here is an example: 

(This makes the hash obsolete.) The recursion limit of 50 is somewhat arbitrary, and might not be sufficient for large numbers. A possible alternative is to remember all numbers seen so far in a set: 

but I don't know if that is worth the hassle. (Note that the static property is computed only once in the lifetime of the app, not each time that it is used.) 

Calling the variables and could be confusing, might be a better name for the parameter. But what the function actually does is to map the numbers to their bit count. That can be done directly with a method: 

will crash if there is no key/value tuple for the given key, instead of returning , because accessing requires that there is at least one element. This can be fixed as 

Now lets have a look at the class. There is no need to assign default initial values "noname", "nocontact" because both properties are assigned to in the init method. Moreover, name and contact do never change, so they can be constant properties with : 

which is much simpler (no XOR operations and less memory reads and writes). It is possible to make the swap operation faster by using or as temporary storage, but this requires a careful check of the sizes and memory alignments. Here you can get rid of the subcripts by increasing the passed pointers 

I am (usually) not a fan of adding type information to a variable name, should just be named (as in the description of the challenge). Instead of starting with an empty array and adding elements one can create the array with . This also allows us to declare the array as a constant: 

but the dot notation is more concise and makes it clear that you set a property (using the suggested name): 

There is no overhead in calling repeatedly, because the UIKit framework already caches the image, as documented in the reference: 

Note also the use of in order to avoid defining the same closure type twice. Now you can observe a simple (boolean) value: 

The next step is to make the function generic. There is nothing which is special to colors or strings, so you can simply replace by a generic type :