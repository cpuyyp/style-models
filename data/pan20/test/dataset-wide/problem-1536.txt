Or if you want to use a double-quoted string literal for the query then the variable could be parsed without needing to end and restart the string literal: 

I don't believe there is a "better" way, though instead of using an object for the buttons option, an array could be utilized, which would allow more customization of the buttons. For example, the submit button could have a custom icon added to it and more custom event handlers, like mouseenter. See the code snippet at the end of this post for an example. Feedback Elements without ids Your example contains only one form input (i.e. ), though it is typically rare to only have one form input. As soon as other text/radio/checkbox inputs are added, the way that is referenced in JavaScript will need to change. I would advise you to always add an id attribute to the elements and use those when referencing them in the JavaScript. So that text input could have an id attribute like . Then the JavaScript can reference it using that attribute: . The same is true for the element that gets set with the text entered by the user. It would be wise to also give that element an id attribute and use it in the JavaScript code. This actually would prevent the title of the message dialog from getting updated with the name (see screenshot below). 

Then the condition for adding the entry in the XML can simply be whether the number of values in that array of valid values is the same as the number of labels: 

Yes - whenever the DOM is being queried (e.g. calls to , etc.), that might likely be a sign that the Virtual DOM is not being utilized properly. Use the React component state for storing values for degree values The styles can be added inline such that the degree values of the transform-rotate styles reference values in the state: 

And then could be eliminated entirely. Alternatively, the condition in the first nested loop could be negated and then the could be eliminated: 

Feedback Nice work using the classes and sub-classes, as well as generators and the keywords const and let where appropriate Suggestions Sub-class constructors identical to super constructor The sub-class constructors (for and ) appear to match the super constructor (for ). Unless you plan to add extra functionality in the sub-class constructors, I would remove those overrides. This is for multiple reasons, including but not limited to: 

Appears to look for submit buttons (using the jQuery :submit selector - so you might have to look for elements matching ) and adds a click handler to each. When the click handler runs, it removes any select list that doesn't have a value - and then apparently sets the disabled property to . 

While I don't think it is bad practice, it could be simplified. One technique to simplify it is using event delegation. For example, the array of tab options could be added to a JavaScript array: 

Looking at the and methods I see a lot of redundancy. I would abstract out code to save related data - e.g. 

Other Review points JS A lot of the suggestions below come from experience writing Javascript over the past decade, getting feedback from colleagues, and reading various posts online like this one. Bind methods and create partial functions to simplify callback functions Instead of adding a click handler with an anonymous function bound to that just calls a method: 

One could argue that the redundancies should be reduced. One way to do that is to only have the values that change inside the branches, and then the common code follow. Take the following re-written code for an example: 

PHP Variable names, excess variables, logic When iterating through the rows in , the variable is slightly misleading because that should contain the column name, not an index (typically an integer value): 

Sorting I did consider sorting the array of values in each row using Array.sort(), which works, but the values all need to be converted to integers first (e.g. using , or just a function that returns the number added to 0), which slows things down a little. But with that change there is no need to call and then - simply sort the numbers, then add the last element to the cumulative total and subtract the first element. 

Like Kokodoko's answer suggests, the common code can be abstracted. I would abstract the common code to a separate method like : 

Partial application One way to simplify the code is to eliminate the lambda/anonymous functions using to create Partially applied functions. For instance: 

Your sample code utilizes the 2.0 version of jQuery. Perhaps this is because the snippet lists 2.0 as the highest despite 3.1.1 being available in the same CDN, but if you are still using 2.0, it might be beneficial to upgrade to 3.0+ to take advantage of newer features. Closure/lambda function scope on click BenC mentioned you could use an arrow function and not have to make a separate variable to point to in the Cat constructor. Another approach is to use Function.bind(). As is illustrated in the code below, call after the closing curly-bracket and pass : 

But if you don't agree with that, then perhaps the simplification below will help. Possible simplification One consideration I had was to use a regular expression with named subpatterns- something like this: 

I'm not sure it needs to be much more efficient. The code looks similar to many examples one can find searching the internet for a clock in JavaScript. If memory was an issue and you really wanted, perhaps you could create only one date object and merely update that date object with the updated hour, minute and seconds values but you would need to do the bookkeeping manually, which might end up being less efficient. Suggestions global variables The variables created using are technically global variables, since they are not contained in a function. For a small script like this it likely won't make a difference, but in a larger application that can lead to namespace collisions. It would be wise to wrap the code in a function (perhaps in an IIFE) and use / instead of to keep the scope limited. Use Date method to get formatted time It could be simplified by using the Date method toLocaleTimeString() (or alternatively Intl.DateTimeFormat()). See the example below for a demonstration of this. Edit: I realize after posting it that the 24-hour format was still the default for the hours so I had to add to the options and an extra call to to remove the /. Also that doesn't apparently support the 2-digit format well so it also has to additionally add the leading if necessary. Apparently this code suffers from this issue. 

Storing coordinates in Google Apps Script, instead of fetching each time on client-side As was alluded to in your comment, yes the fetching of GPS coordinates could be handled on the server side. The function (or a different method) can utilize the Geocoder service. Then use the Sheet class to write the values back in the sheet. 

Cast to same type? The name and city local variables have data type nvarchar(50). Those don't need to be cast to nvarchar(50) when used in the INSERT statement 

The style attributes could also be bound to plain-old Javascript objects- this would be useful in case there were multiple in-line styles to attach. For example: 

Alternatives to , , I am not sure if it would work but you could consider using cURL wrapper functions or - that way the parsing of individual characters could possibly be eliminated. Reading characters in I haven't tested it but in theory the (outer) loop could be simplified to a loop: 

tl;dr The code can be re-written to first count the number of occurrences of each number, then return an array filtering out any number that occurs more than 3 times. 

Event delegation One could add a single click handler for the whole DOM using (or wrap the game board and new game buttons in another element), then check if the click event target is the new game button and if so, reset the board, otherwise handle clicking on an element. A sample starter is below... 

So the code appears to actually add a JavaScript call on the client side, instead of adding a element... Outputting JavaScript with If you are going to add JavaScript to the client side and echo the image path (i.e. ) it would be wise to sanitize that value so it won't break the JavaScript. One technique for that is to use or . 

One alternate approach would be to have the store the newly added user in a property (e.g. ) and then have the method look for that property - if it is set (to something other than ) then add the rendered template of the new user and clear that property. When the page loads, is there an existing list of users that gets added to the list? If so, maybe those could be stored in a different property and the existing code in could look for that property for rendering the existing records. 

And each time gets re-assigned. Thus if any of the array elements before the last one fail the validation, this code does not capture that. That could be remedied by returning false as soon as any element fails the validation.