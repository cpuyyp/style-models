Currently your method does two things. It searches the directory structure and anylizes the files at the same time. This should be separated so that you can maintain each feature separately without affecting the other. For example should you want to search the directories recursively you now only need to change the method without thinking about reading the files. 

This variable is not necessary. You can make the same decition based on the report. Create if it's otherwise skip it. 

This method (and the others) does not really change the image but it creates a new one which is not obvious and the user of this method would think he does not need to dispose the old image. I suggest adding another parameter for the result while changing the first parameter from (ref) to normal by-ref parameter. 

You should split this into two s and two different exceptions. The first one should only check the parameter passed and throw the because we don't throw the directly but some more specific ones that convey more information. The other one should be the which means that the object is in an invalid state which would be when the is . 

Alternatively you can attach the item that you process outside the loop to the entity collection and let the loop do the same job for it too: 

I need to evaluate some data that is stored in a database as . The objects themselfes are rather simple and will contain only basic data-types. 

Sorting needs to be fast, right? So how about using a dictionary for the oder lookup and not the O(n) ? 

Since is the actual value of an enum, and the string representaiton is just a friendly-name for it, I'd just use . Otherwise you have to be careful about the lower/upper case of the that would change its hashcode. 

You can use it for dictionaries, hash-sets, distinct and basically everything that allows you to specify an or just create an instance of it and use it without any collections: 

You've removed most parts of the application leaving only three one-line event handlers without context and a notifier that is not yours. There is nothing to review anymore and I don't know any reason why you shouldn't use DI. 

This is a very dangerous design. Especially the field that is shared by each method. If you ever use it in paralell then those methods will overwrite each other connections. You should use them locally only: 

etc... All of these are obvious! They are unlikely to help anyone -- even yourself! So get rid of them 

Comments Comments are good, but too many gets tedious. Only use comments when the code is doing something that isn't self explanatory. Example: 

I know it might not be very helpful, but in some cases, I think it can help readability if you ever edit it again. I used to put brackets in coming from c# but it really could confuse you - I spent hours looking for an error because of the unessential brackets. 

You're repeating , , etc... when you can just define them earlier on HTML5 has a attribute you can use - in which case you don't need the extra check in your JS code, but if you can't modify your HTML, an easier way is to use - an empty string is falsey, so it works. , , aren't defined... To set the values as empty, simply do - in my opinion, it's easier to see what's happening and shorter. You can significantly reduce the amount of code by doing away with all the variable if you empty the input fields at the end! 

If you're looking for an integer, look for an integer. So when you make the variable, to make it an integer: 

Why have you used ? It is used for running raw code from the input which you don't really need. Instead, do: 

I'm new, so can't comment, otherwise, would have commented. This isn't a bug, but you don't necessarily need the brackets in python for ifs and things like that: Instead of: 

Repetition I'd say half, if not more of your code is repeated. Make use of functions to avoid repetition! You're doing the same thing 3 times, the only difference being the variable: 

I've made a simple HTMLâ†’Markdown converter in Javascript and am looking for any feedback. For now, I've basically used Stack Exchange's as a guide as to what to convert, but I might look at CommonMark's spec later on. It uses and then goes through the child nodes to convert things. My test HTML string right now is: 

As far as I can see, there's no need to add to the rate because you're only calling the function once. So rate will always be 0 at the beginning. So instead, remove the and change the , etc... to , etc... 

don't bother writing a console or winforms or a wpf application. You should write a program and a library is also a program. Writing a full blown application just costs you time and you my do things wrong. Instead concentrate just on the actual algorithm and validating its results. Write a class that solves the questions and a few tests to show that it works. That's all. Do you know the KISS principle? Don't do things you weren't asked to do unless you feel quite confident about what you're doing and want to show more then asked. 

into this one. Each expression will resove either to or the actual condition if the variable was provided. 

The code is not only for the compiler. People need to read it and they need to know what it does (not only today but in a month too) so yes, a lengthy condition inside an is a bad thing. 

I want to make the creation of the pack Uri for WPF resources more verbose so they are easier to read and less error-prone and I thought I implement it using the builder pattern. 

Yes, because it seems that you think that you must use a builder because it's some kind of a cool pattern for everything. No it isn't. Strategy Pattern is cool. Builder makes things simpler. 

You call this a Queue but it does not behave like one. It's more like a strange dictionary that removes the first element that was added if the capacity exceeds. A queue would have such methods as and for adding and getting elements but in this queue I need to know the key of an element in order to get it so there is no way of getting the first added element. A name like would be more appropriate. Since this is a collection your class should also implement the interface so that it can be used with linq and loops if necessary. 

If they are, then this is a pure coincidence. You'll be safe if you use the SortedDictionary instead which: 

I would change the name of the method to as it does do it for the current and not generating them for an external parameter. 

In most of my applications I think my core code is quite good organized and uses only dependency injection for everything. However as far as the initiailzation is concerned I find it's a huge chaos that I'm not sure how to organize. As a consequence I can test every module but I cannot write a test that would simulate running the application or exchange any modules registered in the IoC container. In this question I'd like you to ask you for your suggestions about the below code. It's taken from one of my tools. Basically what it does is: