You are doing too much work here. Your limit of is too large, sqrt(n) is a better limit. Since 2 is the only even prime you don't need to test any other even numbers as divisors. For completeness it is better to check for negative values of up front. You might want to test your current code with negative numbers to see if it gives the correct answer. For my taste, you use too many single letter variable names. Better to use more descriptive names: n -> num; m -> limit. I also prefer more commenting than you do. YMMV. 

Atbash is its own inverse, so you do not need separate and methods: Atbash(b) = y; Atbash(y) = b for example. A single method is all you need. Neither do you need your and arrays, you can use the built in character ordering. A character is places ahead of 'a' in the alphabet, so its Atbash coding is the same number of places before 'z': . That can be simplified by gathering the constant parts: . My C# is very rusty and out of date, so this is in pseudocode: 

If you have the sieve in place, then you can use a similar method to test numbers between the limit of the sieve and its square: 

You are passed an integer parameter, and you have to return an integer. I do not see it as worthwhile converting to a string for the counting. Better to count the digits directly from the original integer. MOD (%) 10 will give you the last integer, and DIV (/) 10 will shift the remainder along one position. You may have to be careful with 0 and negative numbers with this method, otherwise you might get unexpected results. As will as finding the most common digit you also have to find if there are any other digits with the same frequency. As you look for a new higher maximum, look for other digits with the same count and keep a note if they exist. This is my code: 

As Simon suggested, here is a memory optimised solution. I keep track of the current best solution using only two variables: and : 

As a minor point, if you are going to check the given input parameters, it is probably better style to use a single method, given that the checks are so simple. 

The only even prime number is two, so with a little extra coding you can ignore even numbers in the loop. For even more speed use a sieve, though maybe save that for when you get a 'TLE' failure. A more formal code layout would be good as well, your statements need expanding to include . More vertical space (blank lines) a well as explanatory comments help. When you come back to your old code six months later you will thank yourself. I prefer to set 0 and 1 as and to make code easier to read YMMV. 

A prime number has only two factors, 1 and itself. However, counting factors -- as you do -- is not an efficient way to detect primes. A more efficient way is to look for factors in [2, n-1]. Any factor in that range indicates a composite number with three or more factors, so the search can be stopped at that point. As @Martin R pointed out, the search only need cover [2, sqrt(n)] to find the smaller of any pair of factors. In pseudocode this looks something like: 

That is Java, but the C++ will be similar (and I was upstaged by David while I was writing this: great minds think alike.) Your function also appears to have a lot of unnecessary code in it. The central loop of my Java equivalent looks like: 

I have not compiled or tested this code, so test it thoroughly before using it. Your use of is not good practice either. Let the code finish naturally, and reserve for exceptional situations, not for a normal termination. 

In my equivalent class, I find and to be useful, the first more than the second. They return the next higher prime and the next lower prime respectively. Using a boolean array is horribly inefficient use of space. Better to use a which only uses one bit per number. With a little extra coding you can reduce that to half a bit per number by only holding odd numbers in the sieve. Your fails to flag 2 as prime. 

This runs in about 500ms on my machine and uses a lot less memory than an array. I always run a timer on my Project Euler solutions; feel free to remove if you want to. 

You are right about user-selected passwords. A good password includes digits as well as mixed case letters. Better to include a few of those as well. Unfortunately, such passwords are difficult to remember. As a compromise, you could construct passwords on a pattern: "wwwDDwwwDDwww". The www are three, (or four or five) letter random 'words' with alternating vowels and consonants, as you currently propose. Though is would be better to include the pattern "vcv" as well. The DD are either two random digits or a single non-alpha character, like %, =, * etc. The first DD is one type and the second DD is the other. For capital letters, pick one of a few memorable patterns of capitalisation for the three 'words': 

Two suggestions. First, you are restarting your loop part-way through the string and resetting to 0. That means you are checking the first part of the string more than once. For input like "abbccddeeff" you will be checking the "a" five times. Instead, do a full pass with the loop and then do another full pass only if needed. Separating the loop logic into two loops seems clearer to me as well. Second, since most of the work will be deleting characters from strings, I think that using a would help, specifically the method. 

My original code was Java, so I may have made a few mistakes in converting it to C#. Check things carefully. ETA: Following @Heslacher's comments in his answer below, about stepping more than one. Yes, time can be saved, but the step is not constant. The size of step depends on the number of consecutive integers with four different factors found. The search loop could be rewritten: 

Rather than rewrite your code here are some pointers for your next interview. Yes, I have sat on the interviewer's side of the table a few times. Whenever you are taking input directly from a user, as here, a rule-of-thumb is that you need to spend about one third of your code checking that the input is valid. For example, you ignore multiple character input for the second line. If your user types in "armadillo" at least give warning that the input is too long and you are ignoring the "rmadillo" part. A few on-screen user prompts would have been nice as well. One of the things the interviewer is testing is how well you know the more common Java libraries. As @Adriano said, using would be both easier to code and show that you know the libraries. Another thing being tested is if you are aware of the memory/processing penalties of working with Strings. Java Strings are immutable so only the built-in methods can change things under the hood. If you are going to make multiple changes from the outside then do not make the changes directly to the original string. Convert the to either a or to a . Make the changes there and convert the final result back to a . Did the interviewer ask you to print a message if there was no 'u' present in the original string? If not then don't add extra stuff like that. In a programmer job you have to code what is specified, no more and no less. The method is the type of general-purpose function that is buried somewhere in a library. Library users do not want extraneous messages popping up from apparently nowhere. Unless otherwise specified, the only output from a method should be void, a return value or possibly an exception. Your printing is a side-effect, and so to be avoided unless specifically required. I would have written the method as: 

As others have pointed out, your perfectNum() method has some problems. It is also inefficient, a big sin in computing. First note that factors come in pairs: x * y = num. Once you have found x, you have also found y. That gets you two for the price of one. Further notice that for any factor pair, (x, y), one is <= sqrt(num) and the other is >= sqrt(num). That cuts down on the number of factors you have to try. For perfect numbers specifically, we have to treat the factor pair 1 * num = num differently, because 1 is counted in the sum of factors while the number itself is not. That means treating factor 1 differently. Easy enough as 1 is always a factor. Similarly, we have to treat square numbers differently. 8 * 8 = 64, but we only add 8 into the sum of factors once, not twice. That needs a tweak to the code to correct. I have included some other suggested changes, such as variable names, and added some explanatory comments. returns a double, and in some cases it will return something like: 6.99999999867923 for . Converting that directly to an gives 6, since the conversion truncates. Adding 0.5 ensures that the integer square root is rounded to the nearest integer. This code still has a hidden fault, though it works for the question your teacher asked. 

Obviously, most of the work is done in , which counts the number of distinct prime factors in its parameter: 

There is a further efficiency with even numbers. If any even number is a factor of n, then 2 is also a factor. Hence, once you have tested for 2 as a factor, you don't need to check any other even numbers as a factor. This will roughly halve the runtime. 

I haven't run any timings, but this has a simplified end-of-loop check and one less addition per loop so it might shave a little off the time. 

This avoids checking a number's factor count twice by stepping to the number after the first non-four factor count. As a disadvantage, the logic of the search is not as clear as with the original version. 

You have loaded all your code into the method. That is generally not good. You should aim to keep relatively small and have the workings hidden in other methods that you call from . Use more for flow control than for actually playing the game. Something like: 

Your question involves two tasks, extracting digits and reversing their order. One of the standard ways to reverse the order of something is to use a stack, which is a LIFO (Last In First Out) structure. Go through the target string, rejecting non-digits and putting digits on the stack. Then pop the last two entries off the top of the stack. I have added extra code to deal with the cases of only one digit or no digits. In general it is not good to return from any method; it is better to throw an exception. I am not sure if you have covered exceptions yet, but when you do you should return to this code and use them in place of the two returns. As a very minor point, your first omitted the space between the and the first parenthesis. Omitting the space indicates a method call. With language structures: , etc. distinguish them by including the space as a separator. 

You don't need to check for input lengths of 0 or 1; your initial values of "start" and "end" will catch that: in either case. @heijenoort's reworking of the loop condition is the same as mine. Better to avoid in the middle of loops if you can, and this one is easy to avoid. You are returning a so for symmetry it is better to accept a as parameter and convert to a internally. You can change that if you have already done the conversion elsewhere in your code. In that case consider returning a instead, so input and output are the same class. That avoids possible future errors from an invisible change of class, hidden behind a method call. I find it confusing that you call a variable "string", better to call it something like "text" or "sbText". Your code assumes that there is at least one vowel in the supplied text. Currently it will fail on an input of "zzzzzzz" as the indexes will fall off the ends of the array. If your input guarantees at least one vowel, then that is not a problem. If it does not, then you will need to fix it. Your "isVowel()" method does not recognise A, E, I O, U as vowels. You know more about the expected input than I do, so this may not be an error. You can always use on the character before checking. My partial code, with some comments: 

This is Project Euler Problem 14. Your solution appears over-complex to me. I solved it in Java, but even so my solution appears a lot simpler. The basics are the same, but you seem to go round the houses to get there. For example, you have two different methods to calculate the next number in the Collatz sequence, one for evens and one for odds. My code has a single function to do the calculation and count the length of the chain: 

That diverts all multiples of 2 and 3 before you have to set up your loop only not to run it: . I also find it easier to read, though YMMV. Your loop unrolling is a bit strange to my eye. You start at 3, which you have already checked for, instead of 5 and have to compensate in every repetition of your loop. Checking that every time seems unnecessary as you can as soon as any divisor is found. 

Again that is Java, but it looks a lot simpler than your version. It uses the function above. With Project Euler I tend to start with a simple and obvious solution to the problem. If that is too slow, then I try something else, but I like to see of the plain and obvious approach works first. This was one of the problems where plain and obvious worked. This one runs in 550ms for me. 

or similar. For four letter 'words', middle means capitalise the two middle letters: wWWw. You could use some real words to make the password easier to remember: oNe42tWo$thRee can be remembered as "one, two, three, 42, dollar". That just leaves the capitalisation pattern to recall. Using a pattern is a weakness, but it is better than pure lowercase letters. You don't have to incorporate all these suggestions, but you should use more than just lowercase. There are 26 lowercase letters, but 62 lowercase, capitals and digits. That gives you more entropy for the same length of password, or the same entropy in a shorter password. 

This will run faster if you have a method in your library, based on the Sieve of Eratosthenes. That will avoid having to check odd non-prime trial factors. My Java version runs in about 200 ms using the sieve to pick primes. There is one helper method, which finds the integer square root. This version uses Newton-Raphson and is taken from CodeCodex. 

First you need to read Schneier's Memo to the Amateur Cipher Designer. All amateur cryptography is faulty, not just yours. I too designed a cryptographic hash, based round RC4, put it out on the web and Scott Fluhrer was kind enough to show me the obvious faults in it. He is an expert, so he knew what to look for. I was not and I did not know what I had to protect against. Our conversation is probably still out there on the sci.crypt Usenet group from 2007. To design a good hash function you need to know the types of attacks that are used against hashes. For example, does your hash specifically guard against length-extension attacks? How fast is your hash compared to other current cryptographic hashes such as SHA3? For a first suggestion, learn how cryptographic hashes pad their input and why. Either incorporate the same technique into your hash or else find a different way to serve the same purpose. You are not the first person to write a hash. Learn so you can stand on the shoulders of giants.