Which isn't too far off of your last variant. But if you're already using notation, I would pair it with pattern-matching: 

The nice part is that regardless of how you mess up , will still work. That's the great part of modularity. 

That way you only have to create the mask once and then only use bitwise AND, which usually gets compiled into a single CPU instruction. When working with list, you want to add elements at the front, not at the back. Instead of 

As 200 said, the predicate should be first. Think of , , and similar functions. They take the predicate first. Also, it's usually a good idea to get rid of arguments that get repeated in every recursive call. GHC should take care of that, but we can help it a little bit: 

all structs share a common initial part of the members, namely the value, so as long as has been properly initialized, we can use or to inspect (not change) the value. In order to update a field, we need to use the active member, e.g. 

Getting rid of Now to your block. Don't. Use. . You want to repeat the block until you didn't get . We can do that with a simple : 

Note that you don't need a type signature on those local functions. Indeed, they can be misleading, because the in is not related to the in the outer function. Don't shadow library function names is a name that's already imported via . Since we now import our containers as qualified, we can simply provide our own function to get rid of : 

Since is linear in its first argument, that is going to be slow. However, we don't need to use at all, since we're constructing a list element-wise from the first to the last. So instead of an accumulator, let us have return the list as soon as possible: 

It's almost the same, and has the same algorithmic complexity as your previous , namely \$\mathcal O(K)\$. But this time, you're getting more information from a single function: you can define both and in terms of , without using the original map/list anymore: 

We can stop as soon as our needle is a prefix of our haystack. However, we're basically checking all tails of here. And there is again a function in that yields those for us: 

That's nitpicking. Some people prefer , since you cannot accidentally forget a , others prefer parentheses, since they are easier to understand for beginners. The generated program will behave the same. 

In case you don't know yet, that's a reference. A reference is an alias to an already existing object. A reference is an alias where we cannot change the value: 

Since you don't introduce additional characters in strings and never remove characters from the original JSON except whitespace (outside of strings), you've reached that goal. 

Boolean answers: Your function returns , but it only return or . A is more appropriate here. Early returns: As soon as you found the "pattern", . Every other occurrence will keep , so you can just take a quick exit. Early breaks: As soon as you notice that a character does not match, . You don't need to check the rest, the match is already broken. You also don't need to count the number of characters that match. A single boolean is again enough. If we apply those three, we end up with 

This approach also allows you to define your own evaluation function without worrying about the loops: 

Profile You can only improve what you can measure. So first of all let us run to check where we spent most of our time: 

is considered bad practice. So you want to get rid of that. Next, you should give you variables better names. and are somewhat descriptiveness. Both tell you that it's a file, but neither says what kind of file. Also check whether you were actually able to open the file. For example, the file could be write-only (and your works, but your fails), read-only (and your fails, but your works), or neither (and both fail). What's that , by the way? The number of elements in your is a magic number. It might change at some point, and you have to update it throughout your program. That's error prone. It's somewhat fine for a small program like this, but in greater programs, you want to give that number a name (see above), something like . Same holds for . You don't want to accidentally use the second time. Last but not least: use C-style cast as a last resort. You're looking for a . By the way, if possible, keep the scope of your variables small: 

Now the recursive call is hidden in , and also the cannot get negative or otherwise mangled by a user. Next, we can make your more general: 

is provided by , so no reason to implement it yourself. Also, try to avoid in recursive functions or accumulators, as it turns \$\mathcal O(n)\$ algorithms into \$\mathcal O(n^2)\$ ones. Encapsulate often used functionality in a function You often use . That's somewhat error prone as you can accidentally forget the file name. Instead write a small function that takes care of the for you: 

Ah, that's a definition problem. What's minimal? What's "smallest"? Your program is short, but a single additional function removed some repetition which can lead to a technical debt. That function won't increase the size of your program, though. 

You write down the numbers from 2 to \$n\$ (only the odds). You start with the next number that you haven't looked at and that isn't crossed out yet Put "maybe prime?" markers on all numbers that aren't multiples of it Cross out all multiples of your number (all that don't have a marker; that step is implicit) Go to step 2, until you've run out of numbers 

Now add export lists and you have a nice, type safe vector/matrix multiplication library. However, I'm not sure whether for large matrices leads to problems in GHC. 

Exercises The function above is left-biased. Why? Could this pose problems for your program? Why not? 

Other than that, your code fine. However, I would probably create a function that handles this instead, e.g. 

Note: I've changed to , since it was too quick with . However, the times above don't give enough information where you actually lose that time. That's what was for. contains the following data: 

As you can see, except for the first element, you will always get for any other element. This adds a little bit more logic to the empty case, but you don't need to traverse your range twice, and this method makes your algorithm eligible for input iterators. Other than that, the only other thing I would change is to use an instead of an . This prevents you from accidentally using . And global isn't my cup of tee either. You can, however, move that into your . But here's a little exercise: you can just use an :