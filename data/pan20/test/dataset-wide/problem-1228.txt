That's really bothering me. It just feels wrong and suboptimal and I'm sure I'm not thinking this through properly. Full code below: 

I wanted to remove this very strong coupling which my components have (as a result of specifying exactly which component should receive the message), and transition towards an event / message system. As a result, I've written an implementation which seems ideal, however it uses run-time dynamic typing which has me concerned that there may be a better way to achieve my goals. 

I am implementing a multi-player game in C# and having seen all sorts of projects, from indie developers all the way to large studios struggle to patch networking into existing products in the past, have made the decision to get the networking aspect done first, and build the game on top of that. I've so far gotten to the stage where my server can accept clients asynchronously, but I have a strong feeling that I've implemented the threading very badly. I think it is possible that I am misunderstanding and/or misusing async/await and Tasks, but having read documentation and similar questions I think I will need practical experience to get my head wrapped around the correct usage of these. As a result, I am hoping that someone would be generous enough to look over my code and help push me onto the right track. I have excluded 'using' statements and the client code for the purposes of this question, however I can confirm the code does function correctly. I am not too concerned about issues such as naming, and the fact that I have a bit too much code logic in the Main function right now -- these will be modified and extracted to more appropriate locations respectively as the project progresses. I have denoted lines I am particularly concerned about with 

Sometimes, I need to change the color of elements in an email. The only achieveable way is by using CSS. But not every email client supports CSS. Most clients delete separated stylesheets. And some even delete stylesheets altogether! With a lot of trial, I came up with the following: 

I've kept the there because it will speed up your code quite a lot. Speaking in 'speeding up', you are re-running per gif. Just store it into a variable. Like this: 

Also, notice that when you use on an event handler, jQuery runs and . Depending on what you are trying to do, you should be careful when returning anything in an event handler. 

It accepts anything that can be converted into a string, and expects the length of the substring to be found. The length must be withing a certain range and must be a valid number. It will be converted into a 32-bit signed integer later on. This will be part of a larger project, and just want to make sure it is as polished as it can be. 

But in a more readable way. I can't make it more readable than that. Repeated handlers. Yes, your handler is the same, with a very small difference, that is fixed by checking the event type and the . Just store the function in a variable and you are done! Like this: 

Adding a new message type does not require any modification elsewhere to be supported. Subscribing to an event is as easy as creating a method with the correct event class. There is practically no overhead for listening to a specific event - no need to instantiate a class, inherit some event-specific interface, register interest at run-time with a subscribe method, etc. As messages are represented by classes (like a MoveMessage), they can contain all the relevant data without needing to be cast or coerced. 

Exhaustive set of event properties which components can subscribe to manually - adds extra code overhead to each message type, which I'd like to avoid Dictionary from event Type to handler in each component - have to subscribe at run-time, which feels undesirable. Switching dynamically inside a non-overloaded handler - more viable than it sounds since most components will not listen to more than a few message types, but still has unpleasant code overhead 

Additionally, my usage of any features in more recent C# iterations (C# 6 most notably) may not be up to scratch, so I'd appreciate any suggestions for making my code more condensed or 'modern' I apologise if this question doesn't fit perfectly here -- I was concerned it was a bit too specific and if it is, please comment and I'll try to open it up a bit. 

I am quite sure this code is okay, outside of the overhead induced by the run-time typing - my apologies if this makes it a bad fit. I am just hoping for a once-over review by someone more experienced to reassure me that this is a good design. 

You'll have to adapt some code but you can also get rid of the parsing for the names and values. Instead of a you might want to consider a or your own class instead. 

As mentioned by Scott in his comment to your question you should use to retrieve an item as it will block until one is available. You might want to consider providing some sort of "object resetter" action which gets called whenever you have retrieved an item from the pool which puts the item into a clean initial state automatically. 

Testing for a positive outcome in a condition usually makes it a little bit easier to read especially if the condition is a bit more complex. E.g. 

Slightly more compact code. Your should get into the habit of creating dedicated objects for locking instead of locking on some data structure you happen to use. In your case it won't make much of a difference but you can get into deadlocks this way if you are not careful. 

Extracting sub expressions with multiple uses into a local variable can help to improve readability. Like this: 

One thing I noticed is that you have a fair amount of code duplication. It's something I try to avoid because it means if you find a problem in a piece of code which is duplicated then you have to go and them all and fix them. If you just have one place where you perform a certain operation then there is only one place to fix/extend. Some examples: 

To ressemble a little more a console, the animation is only applyed when there's no typing. With minor changes, it is possible to make it work with keypresses on the keyboard. And with a write queue. But that's left as an exercise for the O.P. 

You don't need the there, since all methods are by default (since, at least, PHP5.3). You should use type hinting. This basically limits the received value to a certain type/class. This is how you should've done it: 

You are calling jQuery just so that you can pass an instance to move the tile somewhere? You know, you would be better off without jQuery inside that handler. Like this: 

This code was written purely for fun, but that's not an excuse to write it poorly. Still, I feel that there's something to improve on it. Besides of any performance issue that there might be, and some readability crimes, what else can I improve in this code? 

Looking very quickly, it seems like a frail code. Still, it works as expected. But I saw a few things to improve: 

You have unterminated HTML entities. Through all the code, you have repeated over and over again You should use it like that --> (notice the missing ) You're closing your s in weird places An example, way at the bottom: 

Based on what I've seen on Firefox 53.0.3(32-bit), on Windows 10, my implementation is around 5-20% faster most of the time. You can try it bellow: 

Neither nor pose any type restrictions on . So I don't see any need for imposing an restriction in the implementation. The other option would be to keep the restriction and make actually use of that interface (i.e. ) is the wrong abstraction to use. is meant for objects to provide a sort order as it has the concept of smaller, equal and greater. For your purposes you simply want to test for equality - so you should use or instead. 

Expanding on Groo's answer a bit. One classic solution to this problem which avoids building temporary node sets is to add a to your class. For simplicities sake lets say we make it a 

Another standard convention in C# is to place opening braces in their own line (at least for classes, interfaces and methods) as shown above although admittedly there are some exceptions to that (mostly for auto properties, simple get/set properties and guard clauses). An advantage of sticking to standard language ecosystem coding conventions is that it makes it easier for other programmers to read your code. 

I have no experience with mvvm light messenger so I don't know how exactly it is intended to be used properly. So here just some general things which sure could use improving: 

What do you gain from it: You can now fiddle with the implementation of without having to touch the method. 

Your code overall is quite easy to read and understand. It's so easy that even I could read it! You know what that means? A+ on readability! But here's a very scary thing: 

These are easily fixable. Fixing this may solve some quirks when you spice up your page, in the future 

One thing that makes me cringe is the indentation. It really is off. I had to look 20 times to that stray brace to realize it isn't closing that . 

The characters , and will have a special meaning. They have to be replaced with their URL-codes. works on URL-encoded strings and leaving those characters unchanged would cause all sorts of bugs. The order of the elements in the array is VERY important. Here's how it works: 

What's wrong? The names! implies some actual text, but you have a . is alright, but it is actually . And that is a . I propose the following rewrite: 

You start by giving the value of . Why don't you start the loop at 1? You reduce 1 iteration! Like this: 

If you see something innacurate, please tell me. I haven't touched on the remaining functions, but I'm specially worried about the function. 

Adding on Flambino's answer, I just have to say that your code breaks on IE9. Since you didn't specify which browsers you want to support and which versions, I will assume you want to support all modern browsers plus IE8. According to the MDN page about , this method is only supported on IE10+. Currently, Windows Vista SP2 is supported (until 11th April), which only supports IE9. IE9 can still be installed on Windows 7, and may be the default browser for some. Also, devices with Android 2.1 will throw errors, since this isn't supported.