Your iterations would need to evolve to use the SortedSet#tailSet or SortedSet#subSet methods. Both of these are just new views on the same data so they are cheap operations. A pseudo approach: 

If you cannot rely on a selector (like I used above) to find the elements that you are interested in, or if you cannot add classes to the elements when the page is assembled then you could add the class in code: 

Now what you really want to do of course is collapse down that loop. I found that if you have LINQ (which I see you do not) you can use the operator, very simple e.g: 

Then onwards. Arguably this is borderline procedural but with these few steps I think that is acceptable. Edit: Less readable, more old school 

Modify this to render just the first three links, then your ellipses (...) separator and then the final page number. EDIT to add pseudo code This is messy but hopefully gives you the idea, create your function, make it work and then post a new question asking how to make it prettier (for example tidy up the ifs, add logic to only render a single set of ellipses, don't repeat any rendering code). 

Right now, you take two times the memory of the original array (your boolean array plus the original array), and in the worst case, you are running through the array-size twice (once to fill the boolean array, once over the original array). You actually don't need at all, because the default value will be false. So if you remove it, you will at least save on time. If space instead of time is the issue, you could also sort the array, and then find the two equal values that way without needing any extra memory. Misc 

Structure So your structure is definitely a bit off. First of all, you made your generic, which is good, as it could theoretically work with any content - which is what you want from a queue. But then, you have fields which just don't belong there, such as (and , which is just not needed). So first of all, lets move outside of the node and into the animal classes, where it belongs. As cats and dogs are both animals, lets also create an class which both extend: 

The main difference here is that you have deferred the creation of the random value to the callers end. The calling code will also be required to either use generics too: 

Are you changing the fields that you expose from your objects depending on certain conditions? On the whole it would be best to use reflection only as a last gasp. Gson works fine with collections in general see the documentation over at Google. If you want to exclude some fields from serialization then you can use the annotation, as documented here. This requires you to annotate all fields that you want to serialize with the annotation, and to use a builder to instantiate your Gson Object like so: 

-. When you are coding your method start thinking in templates. Sure it's not necessary now, but it costs nothing to write and you've got a utility function you can use forever. One thing that would concern me about this method is the Cyclomatic Complexity due to the number of loops and conditionals. Consider how you could break things down, e.g The content of your loop can be broken out into code which finds/verifies the rectangle is complete. As a rule each method should have a role as discrete as possible, again this makes things more testable and more readable (when coupled with sensible naming). 

I wouldn't do it this way, because it does seem confusing. And not just because you are using truthiness (which I really wouldn't do, because it's hard to understand and just screams for bugs). It takes a while to see what happens when there is no POST value, what happens if a categories doesn't exist, etc. You don't need multiple checks either though, just move all the code that belongs to category-doesnt-exists and category-exists into one block. If you also extract some code to functions, your code might look something like this: 

Whenever you echo variables that contain non-hardcoded data supplied by non-priviledged entities (eg direct user input, stuff from the database - which is also ultimately user input, etc), you should encode relevant characters via 

I just have a couple of small points: Exiting in Constructor You shouldn't just in a constructor, but throw an exception instead. But in this case, the only statement in the block is an assignment, so there isn't really anything that can go wrong. You should just remove the entire block. Naming Your naming is somewhat inconsistent. For methods you use camelCase, and for parameters you either use all lowercase (which you should always avoid), or under_score. At the very least should be . I would also use somewhat more descriptive names inside the queries. Having , , , as well as all in one query is a bit confusing. SQL Style Your SQL statements are also a bit inconsistent. If you write SQL keywords in all uppercase, do it always (see for example , , and ). 

So, I'm not sure how to answer because I don't understand the use case, but here are a couple of thoughts. If you are defining some data that will never change and is well understood then you could consider using an enum: 

For reference you can also check this excellent article from Smashing Magazine (check the author) and related GitHub repository. 

So, if you're clever about getting an index in there you could write the algorithm (without validation) in just 3 lines and you'd have done a bit of functional programming which sets you up nicely for playing with a new language. 

Firstly if you are going to be passing objects of type around I guess you best be prepared to do a few casts here and there. You can achieve this using a simple interface and templates quite easily. Interface: 

Firstly, underneath everything Javascript is an event driven language so I do not think that there is anything wrong with using an event driven design pattern if you are comfortable with it. Events are a great way to be able to interlink different components of your system without exposing the inner workings of them (loose coupling) and they add queuing by default. However they are more complex, they make it hard to trace behavior which in turn can make them hard to debug. I think that you would get a cleaner interface by developing using something called the revealing module pattern, there is an excellent resource on various design patterns by a guy called Addy Osmani at adyosmanio.com and the revealing module pattern specifically here. This (or a flavor of it) is commonly used in jQuery plugin development which you can see on the jQuery advanced plugin development page (see Keep private functions private). By following these principles you can keep the private stuff private and only expose the functions that you want the calling code to have access to. You mentioned specifically , and so a quick example of how that might look.