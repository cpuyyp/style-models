First of all nice, consistent naming. I approve. What I'm not too fond of is macros, I find the code hard to read because of the macros; however I appreciate that this kind of traits-system is hard (or impossible) to do without macros. The comments do help with understanding the code. You seem to be missing s for , and . You might want to consider adding the common types from as well ( for example). One thing that I wonder about the code is that how will you handle a type that evolves? Say that fields change name, get added or removed how would a parser handle this using this traits class? For example if a field changes name (or type). Other than that I can't see anything wrong with the code. Good work. 

Your card drawing is assuming that there are an infinite number of decks shuffled together, making it possible (albeit not very likely) to for example draw 20 aces in a row. This is not comparable to how you would play at a real black jack table (you can't count cards for instance). You'd need to decide a number of decks you want, allocate a buffer with all card values and shuffle it (for example using Fisher-Yates) then have a pointer into the buffer for the next card to draw and increment it. Once you reach the end, you shuffle the buffer again and reset the pointer to the start. 

It turns out that although your algorithm is faster than , Shaker Sort is even faster in this case. This is also the reason that you use Shaker Sort in the final stages of Quick Sort when the ranges get small. 

Your question is very broad and without enough code to do anything else than speculate. Regardless, I will venture an answer based on speculation. I believe that how to best improve your performance has actually nothing to do with OpenGL but rather how you render your scene. Or to be more specific, how to not render parts of the scene. To me it seems as if you're rendering every cube in your voxel grid, even if they are covered by other cubes and thus not visible at all. You need to process your voxel grid to mark voxels that are concealed as not visible and simply not draw them. Next you should consider not drawing sides of your cube that are covered by another cube. Eventually you will get to a point where traversing the grid to find what to render is the most expensive part of your render loop. And at that point you need to start considering to split your voxel grid into larger chunks that can be individually processed into a single vbo mesh that you can render in one call instead of a call for every cube. As always when dealing with performance, measure at every step and profile your code to see where the time is spent. 

Lazy Version It's possible to build a tree in a tail-recursive manner. It's much more difficult to do that with the references to the parent node. So I cheated by making it a lazy data structure instead. The first version was pretty basic. 

If the block throws an exception, give priority to this exception. The exception thrown by is added as a suppressed exception, and the modified exception is thrown. If the block did not throw an exception, allow the exception from close to propagate upward. 

There's really not much we can help you, given the low level of detail in the question. There are somethings you have in this code snippet that are generally considered a Very Bad Idea, so I'll give what help I can in that regard. Null Checks There are a bunch of these types of checks in the posted code: 

By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

Now that we are using a more appropriate data structure, we have regained the simplicity we had before, and don't run out of stack space. 

It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

Execution can begin immediately and the total delay is 1 div as the divs can run in parallel. This is assuming the compiler doesn't do this behind your back already (I'm not sure if it is allowed to by the IEEE rules) . It also depends on if there is enough instructions to fill the execution units while calculating the reciprocal. Any way it's worth trying. Apart from that I can't think of anything that would make the function as it is any faster. If you really want speed you need to use SIMD instructions in addition to using many thread. But that requires you to restructure your data from "array of structs" to "structs of arrays". Edit: I've had an opportunity to take a closer look and there are some things that you can do to improve performance. This calculates at two occasions: 

If multiple threads access this instance simultaneously before it is created, you have a data race and may end up be being constructed multiple times or other kinds of undefined behaviour. You need to add mutex locks around the block or use which is preferred. As it is supposed to be a singleton you're not supposed to be able to create more instances as the meaning of a singleton is to just have one instance but it appears that it is fully possible to construct multiple instances of simply by creating them as local variables. So this is a design flaw in your template. A much better way of creating a singleton is to rely on C++11 Magic Statics (N2660). And simply do this: 

this only does one memory allocation and gives you better performance when using the as the reference count will be allocated together with the data. Which brings me to my next point: Use Forwarding Reference Correctly This: 

Refresher of A* I see some indications that you are not entirely sure of how A* actually works so I'll try to explain. Consider a graph of nodes and edges where each edge has a non-negative cost associated with it (in some cases edges can have negative costs but I won't cover it here). A* will efficiently find a path from node A to node B with minimal total cost. What makes A* efficient is that it is "guided", in the sense that it uses domain knowledge in the form of a heuristic to guide it to explore more promising paths first. The heuristic is a function that can give a lower bound on the best possible path between two nodes. Essentially it is an informed, optimistic guess. Example: Think of a car map. Each node is a city, each edge is a road between two cities, and the cost of the edge is the length of the road. A suitable heuristic could be the straight line distance between two cities because there can be no shorter route. This heuristic will never over estimate the cost but it can grossly underestimate the cost at times. So if we have a path from A to some intermediary node X and the total cost to get from A to X, and we can guess the remaining cost with the heuristic (without over estimating), then we can estimate the lowest possible cost if we continue on this path by taking the sum of the two. By repeatedly taking one step along the path with the lowest estimated cost, we will eventually find the shortest route. Untested example pseudo-code: 

You've got a nice idea, planning for extensibility. There is one issue that I see with the way you've implemented it. 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

You claim that your is faster than I do not believe this claim. Please post your benchmark code. often has Small String Optimisation to avoid dynamic memory allocation when used on small strings which is fairly common. Your code is not const correct. For example: 

Use of white space You have a lot of randomly added line breaks, this makes your code difficult to read because I have to scroll a lot. Please keep your code tidy. Don't do unnecessary work For example in your destructor you do this: 

Okay I understand this is a programming challenge so I won't comment on programming style or variable naming as one does not usually care in this case. But it would be nice if you'd tidy it up enough for us to see what you're doing. I can't quite make out what is supposed to be for example. In any case I'd bet your performance issue comes from these two for loops: 

The class seems like a work around for a problem with passing integers as arguments, I would structure my code so that this is not needed. 

and you would have all the private members from your class as globals in the file. This is the exactly the same thing as what you're doing. You're abusing a as a . While I do not condone this particular design for the problem at hand, the namespace approach would have placed you a bit higher up in the pile of applicants, because at least you're not abusing object orientation and I can accept the namespace approach as a convenient design decision. Had you instead properly used the singleton pattern where it is suitable, like this: 

You are using a naive matrix product, this is slow. There are faster ways to perform a matrix product. See Wikipedia:Matrix Multiplication. In general you should not write your own math primitives. I would recommend that you use for example Eigen or Armadillo or any of the umpteen linear algebra libraries. 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

This sacrifices quite a bit of functionality to pull this off, mainly because of my preference for s. To add the ability to add/remove child nodes, I went with a view instead. This way the data itself stays the same, just our view of it changes. I also added a helper to provide depth-first traversal, to abstract away doing things with the nodes in the tree. 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

I found about 5 things that can be improved, or maybe it's more accurate to say that I did 5 passes over the code in my efforts to improve it. Here's the changes I would recommend, in the order that I encountered them. Better Names The first change was mostly cosmetic, but it was very helpful laying the groundwork for more changes later. 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1