I would tend to use either properties on both sides, or fields on both sides. Primarily because if the property is changed to do anything other than return the field you could end up with different results when comparing and . Construction Order Again, this is probably personal taste, but I'd finish constructing the class before updating the internal state: 

I'm sure this is subjective, but the way you're constructing your snake seems a bit circular to me. You essentially have: 

This would allow you to remove the assignments from the split clauses above to make it more concise. Copy to end You stop merging the lists after you've identified that one of the input streams is empty. At which point you copy the rest of the list across like this: 

One of the things you've indicated is that you don't like the idea of the nested try/finally blocks to ensure that all captured items are released. You could consider writing some utility functions to help make this cleaner. Something like this: 

intcheck Your method behaves differently, depending on when it's called. It checks for an error on stdin and assumes that if one happened it is because a number hasn't been entered and throws a "NUMERICAL" error, unless the language hasn't been set in which case it throws a "LANGUAGE" error instead. It seems like it should probably be responsible for actually receiving the number from stdin, since it's already tied to stdin by the error checking. It should then always throw the NUMERICAL error and leave it up to the caller to be responsible for checking if the language has been set. It's also worth pointing out that whilst the method is called it actually works with doubles not ints, which is confusing. With the modification above, you might end up with something more like this: 

Error Handling You don't have any error handling in your application. What do you want it to do if it fails to copy one of the files (for example because of a sharing violation, network error, permissions error)? Should it continue, ignoring the file, ask the user, abort? At the moment, the program will just crash. 

It's been a while since I used SQL directly in anger, so any feedback's welcome. I particularly don't like the way is repeated in both the and the clauses, so I'd like some way of aliasing the check if possible. 

Nested ifs and input1, input2... If you look at the following code, you'll notice it checks the value of is '1', then fetches a new value into . However, you then check for '3', which it can't be because we know it's '1'. The check may belong somewhere else, or you may be checking when you should be checking . 

Summary This is obviously a personal opinion, but I don't really like the interface you've defined for your list. By defining your methods in terms of a , you're making the caller responsible for constructing Nodes. It seems like Node should be an implementation detail of your list. Otherwise, since the caller has complete access to the Node they can iterate the list and modify it without the class being called at all. I'd define the interface in terms of the Data that is to be stored, currently this is an , so you would have something like this: 

is never used again and is only ever used as an equality check to detect that you've reached the end of the list. Generally, it's better to name things so that they can be recognised, so isn't a great name. Particularly in this case, where you already have a variable that contains the value and has a better name . Lose and just do: 

Tests - Focus and naming Since you had provided them, the first bit of your code I looked at were your tests. As has been pointed out by @Roman Vottner, their names are not very descriptive. , etc tell the reader nothing about the scenario that is being tested. I'm guessing that they should be called something like . The tests themselves are quite concise, although again as has been pointed out by @Roman, you're not calling which is what I'd expect. All of your tests are also validating all of the basins in the returned list. This is a good way to test a whole scenario, however it doesn't help you to know if you're testing all of the edge cases. Having more tests that validate only a single thing can be more descriptive (this also makes it easier to name the tests). For example: 

The connected flag isn't set in the thread, it is set in the worker thread, after it has been started. This means that it's possible to call twice in succession without this guard triggering or an error being raised: 

Magic Numbers For the most part, I don't mind having actual numbers in code where they make sense in context. In the die drawing code above, it is easy to follow that the 1 and drawOne are connected as the value of the die. However some of your numbers are less clear, like representing not on a ladder. Where the meaning isn't obvious, avoid using the numbers and consider replacing them with a meaningful constant / #define. 

Testing more than one thing Looking at some of your tests, you you are testing more than one thing. You are also testing contradictory things. This makes the purpose of your tests less obvious. Consider: 

Suddenly you're setting to ' ' instead of 'Y'. There's obvious duplication in your code, which will expand if you start reading more items / add more flexible parsing and error checking into the read. I would tend to write a function for splitting the input into two parts, the option name and the option value. I'd then write a function for parsing each type of option value (string, number, character). This would allow error checking to be done once, rather than for each specific value read. Whether or not this is needed depends on how much you trust your users to edit the file correctly. 

Your can produce some erratic results, depending upon the number of characters entered by the user. Rather than: 

Memory Management You're not keeping trace of your pointers to allocated memory. This means you're leaking memory. Generally, every in your program should be paired with a delete. Looking at this loop: 

This creates a layer of nesting for the else statement. You don't need the else. When the condition is matched, you return from the function. The only way you get past the statement is if the condition didn't match, so the else is redundant. Redundant checks In enqueue you perform: 

Your _connectionString is static, readonly, so presumably never changes. Are you expecting that GetAccessNumber should return a new value for every call? If not, then why not just save the value on the first call (or read the value immediately through a static constructor) and simply return it on subsequent calls? 

Expressive names Think about using more expressive names. You're referring to the array of bools as both 'b' and 'array' in different parts of your code. One of the names tells your there's going to be more than one, whilst the other name hints at the type. Your method actually prints it to the console. If you get the names right, your program will be a lot easier to follow. 

This might not make a huge difference, but I'd start by combining your find calls. It's been a while, but I think something like this will work (basically, match against *.cf followed by c or m): 

my my my This is obviously subjective, however I'm not a huge fan of prefixing member variables with . It makes the code read like it's been knocked up to try an idea (I'm not suggesting this is what you have done, simply that the variable naming gives that impression). This may be because I'd tend to use fields in things like , so would end up with: 

It seems like should really be a local variable, rather than a class member, unless you've got another use case you haven't implemented yet that requires it at the class level. You only check if the connection is open in your constructor: 

Bug You've got a bug in your dequeue function. It doesn't update tail, which means that if you empty the queue, then start adding to it again you get errors. 

Once logged on, interactions will take on a more fluid approach. Approach 1 My first draft split the processing up between two session classes. One for managing the logon transitions () and one for post logon (): LogonSession 

This could then be used from your form. Notice this is class takes the initial number as an argument, because it seems unlikely that you're only really interested in the number . Of course, it may be that all of those statements are important and you're planning on replacing them with writing to a text area or something. If that's the case, I'd consider replacing with statements that write to a . You could then pass in initially and easily replace it by something else in the future. Either way, I would define a function and call it from the , not just write the code into the form load. This will also make it easier to reuse the functionality if you want to trigger a recalculation when an input number box changes or a submit button is pressed etc. 

Fail Early Your class has a dependency on . Check it in your constructor and throw an exception if it is null, don't defer the check until you use it. It's better to not let your class be constructed in an inconsistent state than to have to check it for every public method. Tests One of the requirements was that you submit everything you would normally check into source control. I would expect to at least see tests that covered the example cases provided (you may have written them, but not added them here for review). Testing styles vary and can be the source of many string opinions so it it worth considering them as much as the 'production' code. Comments It is very tempting to over comment code when submitting it for an interview. I would try to avoid it, the code should be as much like your real code as possible. Write your code so that what you are doing and why is as obvious as you can and reserve comments for more complex explanations. I know you save the live order board in your constructor because you have a dependency, you don't need to tell me... 

You do the computation, however you don't reset the machine ready for the next customer. It seems like this should be zero'ing out the currentPurchase, items, purchase (and possibly adding it to a totalPurchases etc variables). Since it doesn't reset, you're currently having to create a new CashRegister for each transaction. 

Similarly, after the move, if I input again, the and will again swap positions. static So, the other thing that screamed out at me when I first opened the file was that it's kind of odd that all of your variables are state variables are , apart from . It seems like it should be static as well, unless I'm missing something? Also, you're not marking any of your methods as static and you're including them in the header file. Is this because you're preparing for another consumer of your functions? Or should these methods really be static as well? 

Auto Properties If you're not really doing anything in your properties, other than passing values back and forth to a backing field, you should consider using auto properties instead. 

Arduino specifics Disclaimer: I've got very little experience with Arduino programming. That said, my understanding is that the code you write essentially sits inside a function like this: 

I'd consider minimising the contents of your spin section. Some of the operations only need to be performed once (loading eax, checking pass). I'm not sure you're really getting much benefit from the unlocked gate check, but without running tests I don't know either way: 

If you're going to be capturing groups of objects then you're going to need to be very careful about the order that you capture those objects in order to prevent deadlocks where one method performs: 

Members Vs Globals It's odd that you have global variables defined in your Blackjack.cpp file. These: 

Only Read What You Need So, the first thing I noticed was that your method is fetching all of the rows returned by the database. Since you're doing a pretty board full text search on two columns, my guess is that it's returning a fair number of rows. The method itself is then throwing all but the first record away. If you don't need the rest, don't fetch them. Changing the query to only retrieve the first row might help: 

As far as testing goes, you're sending to the same IP address so should be pretty safe but some things to try are: 

However, the main constants I would introduce are for Yes(1) and No(2). You ask the user some yes no questions and have the same values for the answer, so using a constant would really aid translation. Consider this (from your main loop): 

This seems error prone. It also flags up a possible design error. Does it make sense for a to exist without an engine / without a team? If not, then I would expect it to be passed into the constructor, rather than passed in immediately after every construction. It seems like you've done it this way because of the interfaces you've declared which specify class dependencies rather than what a class can do... Public fields You're passing an instance of into every class it has public pointers to other engine classes that have public fields. This feels like way too much exposure of your engines implementation. I would hide this information behind getter methods. Then either pass the intial values into the constructor or provide setter methods. Whilst they may be simple pass throughs initially it will easier in the future if you want to make changes such as supporting different gravity zones Does it really make sense that at the moment any can change the gravity in the game? 

You could then have different implementations, for different types of user input/output. numberOfMines You're setting numberOfMines so that it's easier to use from your loop instantiations, however it's confusing. 

Why both having the second argument if you're not going to check it, it's just extra typing... Wildcards It's not really clear from the spec, however the built in 'find' command supports wildcards. Your current implementation doesn't appear to (you're only doing an exact match). 

As it stands, the property can only ever return an , that isn't null, this is enforced by the compiler. All your tests do is make sure that the type of the property can't be changed. In rare cases you might want to have tests like this (for example if you had a versioned API and you wanted to ensure that changes didn't impact released versions), but generally you want to be testing the behaviour or methods, not the implementation. Without looking at more of the production code (which you haven't posted) it's hard to say what approach you should taking to writing tests. The class is partial, which suggests there's other implementation elements somewhere. Looking at this method: 

The application processes two strings "How is it going?" and "duplicate input". The thing to notice in the output is that when the initial three items are added and executed (from different threads), it results in three sets of processing ("duplicate input" is processed twice). If at a later point, "duplicate input" is added again, the existing item in the map is used and so the processing doesn't have to be done again. How important is this? You can detect that you're in this situation from within your , by checking the value of the call: 

Also, if you've only got two cases as in this case it should be an statement, not a switch. ID On the surface of it, I'd expect the ID to be unique, however you don't ensure this. It's possible to get multiple records with the same ID. Is this by design? Because it feels like a bug. malloc You don't need to cast the return from . Sometimes you don, sometimes you don't. Be consistent, it makes your code easier to read and generally err on the side of not introducing unnecessary code (so don't do the cast) like this: 

And then the rest of the code is contained within the clause. The branch never escapes, so you don't need the else. You can simply do: