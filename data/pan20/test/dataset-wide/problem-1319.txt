I need to concatenate 3 input fields into a string which is formatted as a date , using or will not work in my scenario because Firebase doesn't allow it for some reason. I came up with a rather ugly solution, but I'm not quite sure how to improve it. is bad for performance, but I think that it is needed because I need to completely remove the properties from the object once they've been used. 

This might need a bit of editing but you get the idea. However I'm not sure if any of these are actually better ways of doing what you want, but it's other ways of doing it. It might make everything more manageable if the code gets even bigger. Hope this helped. 

In a bigger project of mine I'm using angular to create a dropdown menu dynamically and then toggling a dropdown menu for some of the menu items. This is why I got a function that toggles the dropdown menus for only the items that should actually have one. However, I feel like I should try to DRY this out a bit since I'll be repeating the same function even more than what I've done so far. How can I improve this code? Should I create a self invoking function or something similar? Here's the functions (they're part of a controller object that I left out): 

Personally I would create loops for this, it's very unreadable at the moment and you are repeating yourself a lot. Remember the DRY rule (don't repeat yourself). Also if you do it via loops it's easier to maintain and change in the future. 

You could save yourself some hassle here by using something else than to delimit the string. This pattern, where you initialize an accumulator to an "empty" value and then iterate over a collection while appending to the accumulator at every iteration, is called a Catamorphism, , or . In Ruby, it is known as . However, in this case, it can also be done even simpler, with a . 

There is nothing in the spec about passing es to find. In fact, you named your parameter clearly indicating that you expect it to be a . Then why even bother checking for es? 

It might not be immediately obvious that those two examples are the same, but they mostly are. The main difference is that .NET's libraries are much weaker than Ruby's, so we had to implement some stuff manually that was provided for us by the Ruby libraries. You would use both versions pretty much the same way: 

The is superfluous here, the return value of a method is the value of the last expression which is evaluated inside the method body. 

Indentation in Ruby is two spaces, not four. You have that correct in your specs, but not in the application code. Also, you create here a pair of methods, which you never use anywhere, and , which you overwrite further down, anyway. Either get rid of this line, or (preferred!) actually make use of those methods. 

Here you check whether the key includes the search string. However, from the documentation in the spec, it appears that the search string should be a prefix of the key. Unfortunately, there is actually no test in the spec to test for that distinction. 

I've made my own pagination service for my forum that I'm working on. I'm quite happy how it turned out but it feels a bit rough around the edges so I would like to know how I can shorten this code and make it more efficient and better structured. The comments are overly redundant just so that I can pick up on the flow of the program really quickly now during the production phase whilst working on other things simultaneously. Figured it'll also help you guys understand what's going on easier so I left it in. Any pointers here are welcome, let me know if you need any additonal information. The markup (excluding banner): 

And then just call the function so you don't have to repeat yourself every time. OR another way would be to put all the elements you want to manipulate and the classes in two arrays, and then just call the functions using a loop and the index in the array. 

Is this a property in an object? If so why have you named it ? Give it a proper name such as or something along those lines to make it more obvious what it does. Now it's just confusing. And for the other function you could name it . If you included some additional markup it would help your question a bit. 

I've written 3 factories as a part of a sign up process in AngularJS and Firebase. After completing them, I thought to myself, would any of these fit better as a service instead of a factory? From my research it's a bit fuzzy when it comes to choosing whether to create a service or a factory. If so, why would they fit better as a service? How can I tell when to create a service and when to create a factory? I've documented the to explain what they do, and the ones that lack a documentation explains themselves in the name. 

I also have a class called ServiceManager, which checks to see if the SQL Server (SQLEXPRESS) service is running on the local machine. 

I also have a helper static class that provides some functions to make some tasks easier. 4 CRUD FUNCTIONS 

Here is my problem. Do I need to give a new identifier to each delegate I write of the following delegate type? like so: or could i use one delegate that accounts for any Datatype I need to use so i don't have to keep repeating the code? Something that may or may not be relevant: I'm calling these functions to prompt user's input for new fields to add for records in a database. So database field types are the data types I'm dealing with, but I'm using this approach for learning purposes to try and minimize redundancy. 

You see how the above class is very similar to the DbResult class and works relatively the same way? This is how I might make a class for Services, but is there any way I can make a class that does both DbResults and ServiceResults without becoming more ambiguous like the following class example below? or, is it ok to be ambiguous like the result I put below? 

I'm looking for a way to simplify this code, because I could develop more overloads for I made the string and int both of class so that in each overloaded function, the catch block could return the same value. The problem is I need, if possible, no overloads of . The function overloads are both identical, except for the type of delegate they are passed. Is there some kind of variable that would encompass any delegate that can be executed? 

There are two different camps when it comes to block styles: one camp says to use / for one-liners and / for multiple lines. The other camp says to use / for "functional" blocks and / for side-effecting blocks. Regardless of which camp you follow: your block has three lines and side-effects, so it should use the keyword form. 

This should be called . is the standard name for a method that converts an object into a textual representation. It is used automatically by methods such as or . [Note: I realize, this is prescribed by the spec. IMO, the spec should be changed.] 

I.e. implemented as a left fold. After all, reversing any sequence (not just strings) is really just the same as 

In fact, the C# version I presented here is slightly more powerful, since it allows the client to choose the termination condition more freely. For example, what if I don't want the multiples of 7 below 50, but rather the first 50 multiples? Easy: 

This is such a perfect match for the Replace Conditional with Polymorphism Refactoring that it even looks as if it was specifically designed to demonstrate the Replace Conditional with Polymorphism Refactoring. I mean, the field it is basing its behavior on is even called ! 

This should probably be called instead. [Note: I realize, this is prescribed by the spec. IMO, the spec should be changed.] 

Personally, I can't really warm up to either version. I guess that to me, reversing a sequence is so obviously a fold, that anything which doesn't implement it as a fold looks just plain weird. I would have expected to see something much more like this: