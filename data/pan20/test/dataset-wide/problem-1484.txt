Naming: A name like is bad practice. Give meaningful names to parameters/variables. Change it for example to . Although the class is , the method probably expects a "print-job", making a meaningful name. Writing output: Try to apply separation of concerns. In this case this means that you shouldn't write output to a screen in a method that merely returns a boolean. You could refactor it like this: 

Edit2: I re-read your updated code and noticed you set the text of a different textbox too, this is now implemented in my code example above. 

UpdateDatabaseStatus(): You should only instantiate the when is not null. And since you don't use the variable, get the rowValue in one line. I also applied the naming tips already in this method. 

As you can see everything is handled in the constructor with all possible parameters. The other ones just call this one with the right parameters and the necessary action is performed. Now you only have to handle situations correctly. If I pass and the item is null you'll get a . This was also the case with your code though. Update: (tip from Morten Christiansen) When dealing with lots of code in a switch statement, you can extract that logic into a method and call that method from the case. Example: 

Note that this last line will enable the item when it is checked, not only disable the item when it is unchecked. This logic can also be applied to all the if statements in the code. 

is a materialized list (for example, ). After running , a new enumeration of will produce the same, modified, objects. is an enumerable that produces new objects on each execution. After running , a new enumeration of will produce new objects. The changed objects are out of scope and will soon be garbage collected. 

The problem here is that you'd actually want to include subtypes. If had a collection of s, you could have done 

Single responsibility: a controller shouldn't also have Unit of Work responsibilities. The context itself is the perfect Unit of Work. You don't always need Use dependency injection. 

The second part is OK. Getting the most recent item from a collection always requires some ordering that defines "most recent". Note that using the improved form, EF will translate this into one query, because isn't materialized yet. It is an expression tree1 that can be merged with the second expression. If you want, you can create one statement in LINQ as well: 

... that is: the entire database table. Other than for small tables, who's going to want that? Don't save changes. Repositories shouldn't call . The Unit of Work is responsible for that. I know that you intend to wrap each repository operation into a , managed by the UoW, but if you remove these , the UoW doesn't need this : the single call in its method will be enough to save all changes in one transaction. 

... assuming that simply s the entity to the context. Now EF will see and as new objects and (try to) insert them on . So how to assign the and values? You could do that in a very generic way that will solve this for any you add, not only copied ones, even removing the need of this constructor. It's by overriding in your subclass: 

Naming conventions: Please read the Capitalization Conventions by Microsoft. Class names will Always be capitalized, same goes for method names. 

I am a fan of loose coupling so I would suggest that you take the values of host, username, password and database out of your class. Pass the values through the constructor and set them in the constructor. This makes it easier to reuse your code. Second, in classes such as one that creates a connection to a database I would not "echo" stuff. You better throw exceptions on error or return meaningful values to the caller. Last, I'd suggest other names. This might be nitpicking but this has more meaning to me: 

Your and method should be private. The change in state should be determined by the class itself. Otherwise you can close the connection and try executing some command. Dispose: When using instances that handle unmanaged resources sucha as streams, connections, ... you have to dispose them. Otherwise they will not be claimed by the garbage collector. There are two ways to do this: 

Useful property names: I find using names as bad practice. It doesn't give any info on the instance. Give it a useful name you, and others, easily understand. Casing of property names: Don't use PascalCase for local fields, use camelCase instead. Your will become . You had already done this correctly for . Redundant parentheses: Following: 

With you correctly used , but you should also have done it for in both methods since you know what the type is from the right side of that assignment. 

This achieves the desired data reduction. But now you haven't got objects yet. Can't be done by this query, because they also contain data from . This final step can only be achieved by joining the result in memory with : 

You are combining an with a local sequence, . It is possible to do that, but Entity Framework1 needs a lot of code to convert the sequence into something that behaves like a SQL table. I'm sure this is a major performance killer. From what I see, you can do without this local sequence. You know the begin and end date. So it's possible to get the forecasts between those dates. If you group those forecasts by their , you achieve the same grouping: 

One file vs. many partials My first comment is about the class itself. I would prefer keeping it together. If for any reason you want to make some consistent change in the extensions it's very hard to do that when they're scattered all over the place. When to use extension methods This is the main question: should I do this? My opinion: no. At least not to that extent. When extension methods were unleashed in c# 3.0, the whole developer community (including me) went on a razzle with them and started creating extensions for just about anything. A bit like the days when text processors with more than one font entered the market. Suddenly we saw club bulletins appear that looked like (and violated) this: 

You could create a new class in which you define all sorts of methods like these to process a result and return it to the view-file where you will show it on the screen. Hope this clarifies it. :) 

Now when the remaining lifetime is greater than 0, your rover can happily move and will die when you keep subtracting the changes from its remaining lifetime. This gets me to another error in the logic. This is the formula you use to calculate the number to subtract from the lifetime: 

Coding style Variable names Avoid variable names like or . In your code they still make sense because they're the abbreviation of the class name and it's not a lot of code, but it is still bad practice. When you have lots of code with less obvious class names or origins for the abbreviations, it'll become unclear what they are really fast. Rename them to and or something similar that clearly indicates what it is. Casing Per the Naming Guidelines by Microsoft, use the following rules: 

The compiler will generate a backing-field and this will result in the code you had, but this is cleaner to develop. if/else vs. switch: When you're in a situation where there are a lot of if/else statements, you should consider using a swicth statement. The code in your method would look like this: 

Get the enumerator Loop over the collection Calculate the difference between the previous and the current item 

At the end of the day, only you can tell what performs best. But there are two things that in most cases will help improve performance. 1. Reduce the number of queries. Essentially, you do 

So there is a redundant database roundtrip in your code. After this statement you know everything that is going to find out again. So you may as well do it yourself: if the record exist: modify it and its details, if it doesn't: add it. To modify the existing records, use : 

Side note: Dapper's Multi Mapping Feature won't alleviate the first two points because it also creates separate object instances for "equal" entities. So all in all, I wouldn't do this. I would get the data separately and perform some sort of "relationship fixup" manually. 

This is generally considered to be a bad idea. has deferred execution, which means that in your example, can be forced to enumerate any desired number of times. As a consequence, it depends on the implementation behind the whether any changes applied by will still be visible after your methods have run. There are two possibilities: 

You evidently want to clone mapped and scalar properties only. Your approach works (if you remember the error sources), but I'd prefer to use a method provided by EF itself: 

As I explain here, the EF model is primarily a data layer. Its classes may be suited for other roles, but their primary responsibility should always be: smooth data access. Your question is about combining three possible roles an EF model class could play: 

This is wrong, the setter should be used to set the value of a instance, certainly not to save a value in the object. Also since this has all to do with and not with the , maybe this belongs in the class. 

Update: As stated in the comments below, you can also take the code and throw it in an extension method. Also nice for reusability and your could will also look a bit cleaner. Here goes: 

This way you can also use a general method like before and use the tag to call the method. Like this: 

Summary I'm not saying that my code is perfect in any way. Probably my code could be revised and corrected as well. I only want to show you the way how you decouple user-input from class-definitions, use proper variable names, bring a proper structure and logic in your code. Please feel free if to comment if anything's wrong with my code. Edit: Thanks to the valid comments I received, I edited the code. The posters of the comments were absolutely right. I've also rewritten the Initial()-method to a more correct logic. Here's the result in it's entirety: 

Before thinking I didn't read well, I didn't want to rewrite everything: the final edit is at the bottom of the answer, but please read everything to understand it all. :) 

I know I have strayed from the Exception subject but I thought this might help you too refactoring your code. Keep in mind that exceptions are for when your code does something unexpected. Ecxeption-handling is for catching situations which might result in abnormal behavior of your program, not for data that you (not the code) expect there to be. I hope you understand what I mean and that this helps! ;) 

You may succeed in implementing the interface methods in a way that they display the same behavior as . This is hard enough. is far from trivial. affects an entire object graph. In fact, all methods affecting an entity's tracking state have nitty-gritty details when it comes to the adhered object graph. If you don't respect these details, saving will behave differently. If forces you to use LINQ-to-NHibernate. This in itself inevitably introduces differences. Both types of LINQ have their own set of supported methods. Both have their own bugs, or run-time issues (like generated queries that perform poorly). NHibernate has other powerful query APIs that you can't benefit from, at least not fully. NHibernate's workflow resembles that of EF. But there are important differences. For example NHibernate's auto flush (auto commit) feature. The standard implementation if , , has other important methods that are not part of the interface. For example, . An NHibernate implementation should also implement these to be even remotely interchangeable (which it never will be). 

If returns you'll see that the s and s (all s) will be fetched into memory by two queries. Also, the is executed in memory, not translated into SQL. With , the whole statement is translated into SQL, making it far more efficient. (Assuming, of course, that both repos receive the same context instance). Finally There's always much discussion about the use of generic repo/UoW on top of EF's / that implement the same patterns. I wouldn't use them just because it's a "good pattern". In most cases they're only a thin wrapper around the EF objects. Maybe you have to reevaluate this.