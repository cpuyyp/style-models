(Note: at present this actually doesn’t play optimally with using for as it requires you to clone the user ID every time you call rather than only the first time a user ID is encountered. RFC PR 1769 would fix that.) is unnecessary ( is in the prelude). shouldn’t be necessary; you don’t appear to be using any unstable features (mostly just benchmarking, really). Something to bear in mind: you’re locking the entire balances table to make any changes at present. This is probably undesirable. If you were doing this seriously, you’d be using a proper database which would take care of this stuff properly. Just thought I’d mention it. 

Making private fields public only for the sake of tests is undesirable; you should instead add new methods which are only available in tests, e.g. 

Macros can be quite good at alleviating these sorts of pains; there is , for example, which works well at handling Results; if you refactored your code so that all of the important stuff was inside a function which could then return , for example, you could use on all of the fallible I/O operations. As it is, you can do things like writing a new macro to assist, and also give a more helpful message explaining where the error occurred. Here’s something more like what I would write; of course, there are various points that are subjective, and I have made some stylistic changes to be in line with what I believe to be more common standard style: 

Again, I do not think relying on this is a good idea, but it does not seem insecure either. Personally, I would rather make the number of iterations a smoother function of time, i.e. round after the multiply. You still get different iteration counts for different passwords, but you also avoid the abrupt stepping up every two years. Also, you lack any code to upgrade the iteration count of password hashes as time goes by. That should probably happen somewhere in the class, e.g. if the iteration count is less than some fraction of the current. 

Personally I find your use of a global variable fine. Using a singleton class for encapsulation where a module would do is IMO needless complexity. If you can have multiple high score objects it's a different matter, of course. 

First, the obligatory pointer to PEP 8. In particular, your class names and some docstrings do not follow it. Variable names and line lengths arguably as well. Next, a couple of specific cases where you could make the code clearer or more efficient: 

Now you are walking the path twice, which again may or may not be faster than recursion. You should only need to call this for one of the paths, though. 

One must realise that in these common tasks that people tend to assume must succeed there are actually possibilities of failure. 

The name should, under Rust conventions, be . The macros could be written as private methods, and I tend to think that they’d be clearer thus. I would expect them to be inlined automatically, but you could mark them also; because of inlining, there will be no performance difference to the macros. wrapping is only needed to provide indirection so that recursive data types work. thus needs it, but doesn’t. Your implementation could (and thus should) be replaced with . You check if , but then report as the error that universe size must be > 2; the clause, however, would correspond to > 1. Now, concerning the equation; for starters, should be written as —superfluous parentheses hamper reading. But there is a more significant issue at stake: the actual equation being calculated. The comment gives this equation: $$2^{floor\left(\frac{log_2 x}2\right)}$$ But the code calculates this equation: $$floor\left(2^\frac{log_2 x}2\right)$$ These give quite different results; the comment would yield only powers of two, but the latter will yield all integers, and might as well be . I feel that would be clearer as , seeing as has already been asserted. In : would normally be nicer written as . One less indentation level, and a more natural way of expressing it. In : is being called quite a few times; it feels like it should be possible to remove some of them, but I haven’t thought about it much at all. 

Yes, path compression. You descended down two paths from and to and and it took \$O(log\ n)\$. At each step you can point a node to its root, instead of just the next element. You can do this recursively like so: 

By default pickle uses an ASCII format, so you shouldn't really open the file in binary mode, although nothing should break if no one touches the file. You could leave out the s from both calls or use binary pickling by passing to . 

You could leave out that second – it will cause an extra unnecessary line break if the name overflows the limit and will not alter normal output in any visible way. Calculating the column width is also independent of the current score, so you could move it out of the loop, breaking the overlong line: 

On Python 3 you can encode the letters into bytes and avoid inside the loop, for similar performance. You might still make it about 1.5x as fast if you replaced the -> algorithm with something faster ( and depth first search?), but that's about it. 

You are saving some data that you never use. , never used after this. The whole parameter is unused if you remove the assignment. already is. If you remove from here, you can also remove from . 

HashMap has some really nice things for efficiency. Just as returned an in the previous point (which rendered the part superfluous), can use the Entry API to do less work: 

Secondly, you shouldn’t be using strings for this; you should be using paths, because that’s semantically what you’re dealing with. The easiest way to get a path tends to be to take a or a generic parameter implementing and calling on it; , , , and more implement it. You can get the base name from a with ; this admittedly produces a , so if you want to display the path you’d need to convert it back towards a string with e.g. . Anyway, the point of this latter part is just that for something that is semantically a path, you should be handling it specially, as a rule; a path need not be Unicode. Think on it more. 

If you wanted to minimise allocations, you could shift the definition out of the loop and replace its assignation inside the loop with . That way it can keep using the same heap allocation time and time again. But that’s an optimisation that is not necessary for something like this. I might or might not do it, depending on what I had eaten, if anything, for morning tea. Personally I think I’d go with instead of in this particular case, but that’s completely subjective. 

Again, you are creating lists which takes time. This whole thing you iterate over could be a constant nested tuple that's only allocated once at the top (or even outside the function). 

There's also a question mark I have: – that works in Python 3, but not Python 2, because . Since your code seemed to work for you, I assume you are on Python 3. I'm not sure if Python 3 people think making it portable with a dot/cast is a good idea or not (i.e. ). There's always the explicit if you can't decide. 

Python 3 introduced a new cleaner format for the common case when you want to step up from the current class and pass (the first argument): 

At this point you can probably guess that I'll recommend doing away with the list. A generator should work. If on Python 2, is probably better than as well. (Note, I didn't mention . That could be changed into invocations if you are on Python 2, but you seem to be on Python 3.) 

Is it an improvement? On the original: I think so. Nested logic is generally more difficult to follow. On the --? Not really, but that's the price to pay for caching the intermediary values.