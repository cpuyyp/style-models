Since there are different keyboard layouts, I wonder if it makes sense to generalize the functionality on creating a keyboard based on standard keyboard configurations? Your current logic to build keys seems basically hard-coded for standard 88 key keyboard. There is an odd mix of work that is happening before the main loop where keys are populated (setting the octave 0 keys) and after that main loop (setting the octave 8 key). I would strive to set all key values within the loop so this logic isn't disjointed like it currently is. 

If you look at other comments, changing to more generalized validation function will help you get away from using globals. Bottom line is this function should not set end user messaging. It should do one thing - perform the validation functionality, leaving the caller to determine messaging based on validation results. 

You are falling into a conceptual trap of trying to define javascript behaviors for each element on the page by numbering each and every one with a different id or class name (i.e. ). Any time you see this pattern in your coding, this should be a red flag that there is probably a better approach to your problem (which is why I think you are asking for this review). With jQuery (or really javascript in general), you should be thinking in terms of what the behavior of an element is supposed to be using classes to identify elements which need to exhibit similar behavior, much in the same way you use classes to define elements that have common CSS stylings. For example, all of your choice buttons fundamentally have the same behavior. That is, they hide other options and expose a new situation. Because this basic behavior is common, there is no reason that you need to duplicate code for each of these buttons. So the question then becomes how do you generalize your code to have a single onclick handler for all of the choice buttons? To do this, you have to have an understanding of which buttons expose which situations - something you are now implementing via class naming. In jQuery/javascript, there are probably two main strategies to do this. One is to tie the elements together via their hierarchy in the DOM and to traverse the DOM hierarchy to hide/show related elements based on their location relative to each other on the DOM. For example, when hiding/showing elements, you might hide all the siblings in same level of DOM as the one you are trying to show. The other main approach is to use data attributes to describe how elements should interact with one another. I will focus on the data attribute approach here as I think this makes the most sense for your use case. You have a potentially complex set of interactions in a "Choose Your Own Adventure" style of game where you ultimately may have multiple story branches each which could lead to different situations via different paths. This would likely be hard to model via HTML hierarchy alone once you move beyond just a trivial proof of concept. Data attributes are also a powerful tool for a budding javascript developer to learn. I would propose some changes to your HTML to make each "situation" its own self-contained set of HTML elements, like the concept of a page. You could then hide/show each situation (including choices) as a single entity. I also think in this case it makes your HTML much easier to read and maintain. 

Is there any reason you are using loose comparison operators (, ) instead exact comparisons here? I would recommend getting in the habit if using exact comparisons by default and only using loose comparisons when there is a true use case for doing so. this will make your could less fragile to unexpected truthy/falsey condition evaluations. 

This doesn't really do what the comment says it does. This function simply determines that name of the session cookie to be used. This doesn't guarantee any cross-domain interactivity of the cookie unless this same name is used for the cookie in all those sub-domains. I think naming your sessions is totally fine, but this is really not necessary to achieve this effect. For example, if every subdomain was a PHP app with the same INI setting for this, this line would be unneccessary. Similarly, if you had other subdomains that were not PHP apps, this code here does nothing to help you, as you would need to use whatever means the language in use on that subdomain uses to set this cookie name. 

Consider providing better validation for parameters passed to public methods. For example, validate input is non-zero length string. Particularly with something as critical to application operation as configuration, you want to take reasonable measures to make sure the class and its data are set up in an appropriate state and that other areas in application are interacting with it in a proper manner. 

I would say that when you are dealing with bulk load operations, you might want to forego usage of your framework's ORM (data model) or query builder functionalities, in favor of more straightforward raw query or even command line functionality in order to leverage the DB's bulk load capabilities. In this case, if your file and DB are on same server you might consider Postgres COPY query to bulk load the CSV. For example: 

Get out of the habit of using loose comparisons, especially on a decision as critical as whether to perform an update or not. One could pass any of the following values to trigger this code path: 

This is a really odd usage pattern in that you are turning a transactional operation (inserting a record in the DB) into something that the caller must write six steps/lines of code to complete. To me a static usage case such as this might be more appropriate: 

You should consider taking the approach of using meaningful class names to apply multiple CSS styles at once. So, rather than using specific semantic color and font class names, define a CSS class that encapsulates the entire state of being a correct/wrong answer. So taking this approach along with the suggestion to store configuration something might allow you to change this: 

Why is this in "database handler" class? You should have knowledge on model or helper class for each type of object you are modelling to get the latest id. 

I do not like the approach of always redirecting the user to another page even when there are error conditions, giving 300 series HTTP redirection response instead of a more appropriate HTTP 400 or 500 series response. In either, case obfuscating the code read from an understanding of what the actual end user messaging mechanism is, also seems a little odd. How is one reading this page to know what different id values are? 

The early return might even be changed to do something different. For example, if you expect that this method should never even be called with , then perhaps an exception is thrown. Should this method have a return value to indicate success/failure to caller? AdminRuleTest thoughts: 

Why would readFile ever accept as argument? What if caller did something like You are making it too easy for application to be put into exceptional state here. You should be biased towards being explicit about your dependencies vs. providing multiple ways to to inject dependencies (i.e. via constructor vs. via method call). Consider using for null comparison. When doing comparisons you should also be biased towards explicit comparison vs. loose comparison. You seem to do this interchangeably throughout your code, which can lead to unexpected behavior. 

But I think my main concern with it is that it uses sessions vs. cookie indiscriminately. I will start with the assumption that you are propagating sessions via cookie, as is considered best practice. If that is the case, why do you need to persist information about the user's authentication state outside of session data in their own cookies? 

Why do you only have two suits of cards? Why numbered 2-14? As opposed to common J,Q,K,Ace nomenclatures? This looks to me like someone who does not have forethought to move between numerical values, that may be needed for calculation/comparison to values that are meaningful to the user. 

Some thoughts below: I would encourage you to think about validating parameters more thoroughly on your public methods. For example, in , you do nothing to validate that you even have an integer value (or whatever) to work with. You do it in some cases such as type-hinting for array and validating non-empty array on , but it is not consistent. What if non-array is passed to your exception constructor? What if non-integer (or whatever) is passed to ? You may not think it matters now because you are currently working in this application area and understand where all the calls are made against these methods, but think about in the future when you try to leverage these classes in new ways. The call patterns may be different. If, for example, you introduce a buggy use case that passes a non-array to your exception class, you want that class to complain loudly, rather than silently fail so that you can focus your debugging efforts more quickly on the problem code. 

You don't seem very consistent in working with file paths. Most of this stuff is using relative file paths, which is likely to lead to a fragile application and/or lead to you putting files in a web directory that don't really belong there. 

In class A, why your config? It should be considered very unusual to have a require inside a class like this. The require should be somewhere in your bootstrap sequence prior to where this singleton is first used. Then you just use the constants as you are currently doing since constants are global in scope. 

For the element's property, I have changed it to use array access notation. This will allow most server-side languages to automatically populate a numerically-indexed array with all values populated into it. This moves you away from the whole paradigm of naming things like (both s and s). Because of this, I have done away with the property for the as it really serves no purpose when using this approach other than to require you to add a bunch of logic to make these values unique. I have also nested the inside it's to connect the two, since we don't have id to ties things together anymore. Finally, I have added a class to the as a means to provide a way to query against these elements in DOM (could obviously be used for styling as well). This would greatly simplify your cloning operation to something like: 

From a performance standpoint, your best best is to actually load test your application to see if it is going to meet your needs. I am guessing when you say 5000 users, you don't mean 500 concurrent users. How many users do you truly expect executing this script concurrently? How much memory does this take on typical execution? How does that compare against your server hardware? Is the user experience on your hardware (i.e. the time that this takes to execute) appropriate? Does that time to complete change under concurrent load? Really your performance is going to have more to do with the questions I just asked than your code. 

I don't understand the need for both and in the scale code. This is just the same array rotated, and considering you will have to rotate or transform the array given the specific input scale, why have two arrays that hold the same values? 

The inheritance model does not make much sense to me. It seems like you have made an arbitrary line of separation of responsibility between the classes. For example, the base class has responsibility for: 

Consider using array notation for your data properties, as this will clean up your , , anti-pattern and a lot of your javascript code. I would always take a step back and revisit your solution when you find yourself naming variables, element id's, data properties, etc. in this manner. This is almost always an anti-pattern that suggests you should be using an array. That might make your option HTML look like this: 

You seem to be taking a very non-optimal approach from a performance standpoint, as you iterate over the data set unnecessarily trying to extra only derive certain pieces from it at a single time. I would think your goal would be to map the into your data structure with a single iteration over the array, resulting in \$O(n)\$ operational complexity to read the data in). Right now you do: 

Your function is really pretty meaningless, especially since it seem you are really only trying to set up the dependency once. Why not just this line in you main execution path: 

These classes should have no business in performing client redirection. They should handle voting functionality and that's it. Something further up the stack should handle routing concerns. 

Don't mix function definitions randomly in the middle of procedural sections of code like you are doing with 

I would like to see you adopt the use of strict comparisons (, ) as default coding behavior. Especially in loosely type languages like javascript, you can often introduce fragility to your code by making loose comparisons like this that can trigger on unexpected truthy/falsey values. There are cases where loose comparisons make sense, but they should be the exception rather than the norm. 

What do you expect to be returned? Currently, your function would return , but is that what you expect, or would each instance of a repeated value need to be treated differently (i.e. return would be )? Have you considered flipping your array values into object keys (if type conversion is not a concern) or using on input arrays in combination with parameter to to minimize array iteration caused by ? This may not be a concern if you don't expect to be diffing large arrays. Do you really want to support the syntax for this? I don't really see much value in nesting your function calls in this manner vs. just using: