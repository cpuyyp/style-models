Inside the callback, we're rejecting the constructed promise with a , but keep in mind, if the function has already invoked or in its , this call is essentially a noop because the constructed promise has already locked into its state and cannot be "settled" again. Because of this, it is unnecessary to assign a reference to the timeout and call if those occur first. Conclusion If you've read this far, you've probably realized by now that the suggested code is compact because it takes advantage of a thorough understanding of the promise specification, and is able to safely make assumptions that keeps the code DRY. 

Here, we are mimicking the signature of the native API, which has one required argument and one optional argument. We simply expect a property to optionally exist on within this wrapper function. 

You can write concise code without using cryptic variable names. Change to something more meaningful like or even just . One way to resolve pyramid code is to look for places where your logic can be decoupled or flattened. While it's possible to continue to use the dependency in order to achieve this, it's probably much easier to just use since you're already using promises anyway. This will also give you an opportunity to get rid of your global variable : 

This code lies directly on the (most) critical path, and felt very inelegant (and wrong?) to me, so I tried to improve it. Note that I don't intend to replicate the exact same behavior as the legacy code. 

How often do you need to mutate the initial value? Not a single time, of course! There's only one element which should take the initial value. Is this a real issue? I think so. Consider this example to generate all powers of two which can be stored in an : 

Here you call , discard its result (return value) and then call it again, this time assigning the result to the local variable. separate calculation and output Instead of 

The lambda returned by above function cannot be used with your unroller. To fix it (as a user of your unroller), you need another (non-mutable) lambda which references the original one: 

All in all there's not much to criticize. Be sure to fix the bugs mentioned in the other answer, though! 

Note that our tests would have revealed this domain knowledge, too. Try the code without the condition and see which tests fail. Finally: Tests pass. Fine. I hope this is of potential use for you. (Ideone link with above code) 

I'd appreciate any feedback on improving perceived responsiveness for the feature this UserScript adds to the webpage. I realize changing the URL after a slow image load within might make the URL change seem slow, but I also noticed that when calling or within a listener to or events, it appeared to cause the fusion image to load significantly slower. Though this UserScript still functioned properly either way, I'm curious if anyone can come up with an approach that improves responsiveness overall. 

This first checks that is "truthy", and then checks that is a valid, non-zero number. If these are satisfied, then is assigned the value of the supplied property, otherwise it defaults to milliseconds, like in your example. 

This part is pretty straightforward; we're creating a timeout given the amount of milliseconds supplied from or the default , and invoking the callback function in that amount of time. 

In order to satisfy the O(N) time-complexity, construct a in O(N) time and space complexity, then use a loop which is considered constant time relative to N O(N) as well (thank you, wchargin), since the maximum possible number of iterations is equal to N and average performance of a operation is O(1). Because O(N + N) = O(N), regarding time complexity, this solution is overall O(N) performance in both time and space: 

This hard codes as the function to use for swapping. C++ also has a powerful (and sometimes confusing) mechanism to allow multiple namespaces to be searched for a function: argument dependent lookup (ADL). To make use of it call swap unqualified, which performs ADL to find functions in the namespaces of the arguments, but also add as a "fallback": 

Live example. Note that this may destructively modify the list argument. The helper function is defined as follows: 

I think you do this to clearly separate between local variables / function parameters / global variables and the data members of the class. I've done this, too. But I think it's a reasonable assumption to make that somebody reading your code knows that data members can be accessed without , and to know (at least roughly) the rules regarding name resolution. And, moreover, you already have something in place to distinguish between data members and "the rest": That prefix. I read that as ember, or alternatively as atrix. Having both just means more to type and more to read. And the long lines suffer somewhat from that "more". Compare: 

One of the things in this rewrite to flatten your pyramid code, I changed the order in which is called, because the way your code accessed the property relied on the usage of a proxy get trap in order to work properly, which is both unnecessary and inefficient. Lastly, I cleaned up your generated text to break it up into a few lines, otherwise it's quite unreadable. You might consider storing that text to an external template file using a minimal template engine (possibly written yourself just for this specific case) in order to avoid hard-coding it in here. 

While this is a relatively simplistic and deceivingly elegant implementation, insertusernamehere's solution is admittedly an order of magnitude faster, when using an array as a perfect hash table for non-negative integers instead. 

I did a little preliminary research and was unable to find a class to create re-usable instances of template string literals, so I wrote my own. Below is the main file (slightly modified to remove exports) written in ES2016, along with a few examples of usage that show the convenience of the class. 

The first is the template definition that will be used when the template specialization (the second definition above) doesn't match, i.e. when there's no (more) content: . The specialization inherits from the previously defined wrapper (and thus gets a member of type ) and also inherits from a variation of its own type with the "removed". Accessing the sets is now almost trivial: 

Note that you could do similar tricks in the header file for and , but I'd advise against that as the benefit is minor compared to the issues that may arise if the used macros interfere with code including that header. Better keep ones macros behind closed doors ;) No pointers to arrays without a size or end, please 

test corner cases Does your function work well with an empty string? A string with only vowels or consonants? A string with only punctuation? 

This also shows one thing I'd consider an error in your code ... off by one Yes, it will do one superfluous mutation. Consider this example: 

Just always use . Saves you from potential headaches when you later add a line of code without looking too closely. Consistency Just some small oddities, nothing of real importance: 

And as promised, here is the link to the repository, which also contains formatted documentation on the respective github pages, and a full demo on Heroku. Please be responsible and only make HTTP requests to the Heroku link sparingly, as I have it hosted on a hobbyist plan, which only allows so many hours of uptime a month. I have plans to implement a service worker for it in the future to mitigate this issue. 

If you are at all familiar with using promises, then you'll recognize this pattern. While it is typically considered an anti-pattern, this particular implementation is written properly, and is also necessary in this case to take advantage of a convenient implicit race-condition behavior of promises that I'll explain in a moment. 

I would like a review of a library I've recently published. I realize this is a rather large request, but having looked on meta, it seems this is perfectly on-topic. I'll include a few choice samples from the library to demonstrate my approach, as well as a link to the full codebase for anyone interested in giving a full-breadth review. So to summarize, this library, called , is, as the title and tags suggest, an object-oriented approach at designing an educational tool for teaching sorting algorithms, which is why the sorting algorithms use generator functions to introduce interruptions in the control-flow in order to be visualized step-by-step. Here's a few of the classes needed to implement an iterative (bottom-up) merge sort algorithm: