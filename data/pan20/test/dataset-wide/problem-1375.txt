You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

how to use the result of (which has to be done anyway to test remainder) as approximation of suggested sqrt(input) test, for earlier exit. used to set zero into register (shorter opcode than plus modern CPU recognizes it as idiom of "set to zero" and optimizes for it) to check if remainder is zero (shorter opcode than plus modern CPU will recognize it as idiom of "test for zero value" and optimizes for it) resolving even numbers at the beginning (even numbers have zero in least significant bit: . And the only even number being prime is , no need to test other even numbers by . but that means only odd divisors have to be tested in the loop, because for sure. So my loop is testing divisors 3, 5, 7, 9, 11, 13, 15, ... some non-trivial usage of arithmetic instructions and flags to check for input values ahead of loop, as those would break the loop logic and produce invalid result. It may be nice exercise for you to "decipher" how it works. you should try to keep things "together" (if possible). For example you set up for at the end of your loop code block, so it's A) not together with , interleaved by (hard to read for human, no problem for CPU) B) you have code duplicity (), because you have to init the register values ahead of very first separately. => So I do initialize right ahead of , only single time in code, and it's easier to read IMO. 

I would move lot more closer to the area where it's modified, so it can be easily seen with eye, where the whole block is, and span over fewer branching points (which is always error prone, to keep correct stack across some branching). You can actually surround just few instructions with , not having any branching at all. 

Overall your code is very reasonable for somebody learning Assembly, I would say quite nice work. I can produce something what will look more advanced (I hope), but it's more like tiny details improved here and there, and some of them for the price of worse readability of source. I mean on the syntax and low level. On the algorithmic level your code can be improved considerably, as Pawe≈Ç already answered, but he missed another opportunity to halve number of divisions. My variant of code, showing: 

The Ugly Nothing is really ugly here. For that you'd need a helluva lot more Clint Eastwood. Breaking Down Your Application Into Components To really organize your code, you need to break it down into components that focus on one specific task, for example, adding a category. Looking at your code, I can see the following tasks: 

Really, all of my objections are related to this tenet of software engineering, and especially object oriented programming: Do one thing, and do it well. Putting validations into your domain objects means they are serving a dual purpose: Hold data from a storage medium AND ensuring it is valid. Do one thing and do it well. The domain object should hold data. The validation layer should ensure things are valid. Putting validations into your storage manager means it is serving a dual purpose in the same manor. You should be able to swap out one layer for another with minimal refactoring. If you have to copy and paste of rewrite lots of code, then your application needs additional layers with looser coupling. 

This way all AJAX is centralized and abstracted away. None of the rest of the application even needs to know AJAX is at work. You could rewrite your repository layer to use asynchronous calls to the browser's IndexedDB for an offline application and you wouldn't need to refactor any of your other code. Controllers Over the years I keep coming back to this basic pattern when creating controllers in JavaScript. Controllers: 

As an added bonus, adding a new decoration/drawing style becomes trivial. Add a new value in a attribute, and then create a new function using as the name of the function. No need to update . 

If private variables aren't all that beneficial, or the property is meant to be public, I'll just declare that as part of the prototype: 

I know this is a lot to throw at a code review, but this does allow for loose coupling, plus all the functionality is componentized and reusable. Since each class has all of its dependencies as public properties (like the ) it becomes easy to mock up those dependencies for the purpose of unit testing. 

If the only purpose is to provide a simple wrapper around the body of the HTTP response, this isn't so bad. Things break down when you need to access things like the request and response headers. Error handling is another thing entirely. I would recommend catching all errors, and rethrowing the exceptions wrapped in your own exception classes to make error handling for client code easier: 

When you change anything with categories, you need to refresh the category list. Same thing with bookmarks. For this you can use events. Controllers would publish an event, say "category:updated". The would subscribe to "category:updated" and refresh the category list. Same idea with . Now the AJAX functionality is currently all global. I usually go for the Repository Pattern to encapsulate AJAX calls. For that you would have two more classes: 

I was thinking whether searching for neighbours for new word can be optimized by searching only trough "neighbours of neighbours of first-found-neighbour", but after short tinkering with it I think this is not valid, this would maybe work for all 4-letter permutations forming complete graph, not for regular words when plenty of possible 4 letter permutations are not available. 

I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code. 

Hmmm... anyway, I really like what you wrote here: "I'm noticing that reading doesn't really help much as much as writing programs and running into issues and solving them." This is absolutely spot on. All this general babbling around usually makes little sense when hit by real world problem. Also refactor a lot. Not just the code, and implementations, but as learning is your goal, dive deep into finished project and go trough all the API, all the abstraction, and try to imagine something better, easier to use, easier to understand it's responsibilities, easier to read and get the idea and eventually easier to implement (although sometimes to get better API and abstraction the implementation can be more bloated, but the cost of bloat has to be clearly justified by the cleanliness of resulting API/abstraction). 

EDIT: The invalidity of PIC-ness was nagging me, so I finally did dig into the issue, and fixed it, these are things to be modified in the answer above: Commands to compile: 

This seems pretty clean to me. It's very testable, which is a definite must-have. It also decouples the reformatting of user input from the view-model. Looser coupling between layers is a positive thing. The downside is that you'd need to create a service for each view model. I'm going back and forth in my head whether this approach is best, or if defining some custom class and property attributes might be more worth while, and then use the service to process any object in a generic manor by looking at the attributes associated with a view-model property. Some pseudo code: RegisterViewModel.cs 

It sounds like you want a JavaScript Template Engine to render raw data into HTML. JavaScript template engines also pair well with a view resolver like Bloodhound (which I wrote). Edit #1: If you need something lighter weight this would suffice: 

The hardest part of managing HTTP requests is that there are a million ways for these things to die. Any assistance you can give for error handling will be appreciated by all who use this class. 

Notice in this variation that the property is now defined as part of the prototype since it has no special logic around getting or setting its value. Now the and properties are read-only, maintaining the relationship that is the Document object that contains , and is the Window object that contains both and . 

Your service could get the object for the view model, and then inspect the using class reflection. This could make processing multiple view models easily repeatable with little additional code. 

Separating things into these layers makes them testable. You could write Jasmine or Mocha tests for your controller and repository layer: 

Now we perform special logic in the function for . Defining the property via is now beneficial. You might find Inheritance and the prototype chain a worthwhile read, as well as Introduction to Object-Oriented JavaScript. Edit #2: Defining a property using is useful for creating delegate properties. I'm going to build on the class from my previous edit. The belongs to a document and a window. In the previous example, there is nothing preventing you from running this code: 

This way all of your rule classes are hidden. All of the validation rules are portable because they are created inside a model specific class, and it's easy to use an IDE's auto complete feature to discover which rules are available since the RuleBuilder class has strongly typed methods encapsulating each rule. On top of that, the IRule interface just accepts a value and not a model, making each rule unit testable to ensure your validation library is functioning properly. And for those who do some .NET/C# development, this pattern probably looks familiar if you've used the FluentValidation NuGet package for Visual Studio. Say what you want about .NET development, but there are some gems out there. I do like the pattern that FluentValidation uses.