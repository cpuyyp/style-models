1, 2 and 4 depend how well you've secured your system (no privilege elevation or random suid files lying around). 4 also depends on the security of flask and the rest of your python stack. Five can be broken, depending on how your firewall is configured (someone could use connection tracking to get your socket forwarded, even though it is bound to localhost). You'd be better off using unix domain sockets. The second is broken, because you chmod the file only after you've written to it. That gives a window for the attacker to open the file. In fact the attacker could even write to the file and execute arbitrary commands, which is why you should never use os.system, and you should use urlparse to build the url. The third is broken in two ways: 

I did a maze thing ages ago that could support any number of dimensions, but it was very slow to generate. To get an idea of how it generally works with the multiplier and stuff, here's a gif of something I made with it: image $URL$ One thing that always bugged me was I couldn't figure out pathfinding, and I thought there'd be some cool looking intricate paths between some stuff. I asked about that (since I'm stuck at home doing nothing due to having a broken wrist), and someone suggested linked lists, so I rewrote it all, and managed to get pathfinding between two points working fairly easily. However, since I'd made the nearest neighbour check run by default, checking for collisions was a huge bottleneck. I tried to optimise it a little, by only doing the pythagoras stuff if the highest coordinate difference was within the combined size of two nodes, which did speed it up like 2x, but it was still quite slow. Someone else suggested that's what you use trees for, and since I have no idea how KD trees work (and also the list is constantly being added to), I spent a good few hours yesterday making an octree that would work in any dimension, so I could find which nodes are near to then narrow down what the collision function has to check through. The result was like 2.5x faster at 1000 nodes, but exponentially going up to like 10x faster at 8000 nodes, which I'm pretty happy with. I've just got it fully working and cleaned up now, so I'm looking for a bit of feedback on either my writing style or anything that could be improved. Also, before the line length is mentioned, I decided to do 100 instead of 80. 

I'm playing around with switching some code to using and I have a question about whether I need to be concerned about the effects of concurrency here. Here's a simplified version of what I'm doing: 

I agree with Raj that you are probably best off not trying to unit test your WCF services themselves, but I have a suggestion specifically around your concerns regarding your static class/methods, assuming you are using VS2012 or later. I recently had to write some unit tests for some classes that themselves called some static methods that I could not modify. What I ended up doing after some research was utilizing shims. Here's a simple example: 

For this application, I do not care about the order that my objects are added to (in fact, I do explicit ordering later on). My question is whether I could get into trouble here with both functions attempting to add objects at the same time. My motivation for playing around with this is simply to try to speed up this sequence of events, and when I tried using a instead, my timings, obviously slowed down to the point that there was hardly any difference between doing these two operations in parallel versus the old, serial way. When I use a simple then I do see impressive speed-ups. So, considering I am just adding objects to a collection in a parallel fashion, is using a non-thread safe collection asking for trouble here? My real-world experience with multi-threaded/parallel programming is very sparse, hence the uncertainty here. 

Now I've grasped the very basics of Pygame, I thought it'd be useful to make a few classes that I could use later on if I try make a simple RPG style game. I've done this to handle the coordinates for the player movement (and possibly for other things too), and tried to do it in a way where you wouldn't get the floating point precision errors that Minecraft and similar games get when you travel out very far. I tested it against the module, and mine appeared to up to 10x faster for small movements, though the speeds evened out when using super large movements like +- 10000000000000. It's only half a days worth of work so it's not perfect, I can't find any more bugs though. It's recommended you input the coordinates as strings though if you're using large ones to start with, especially if you're using floats. 

This works fine, but I'm asking here as a fishing expedition to figure out if there are any clever ways to implement this functionality without either: 

I'm refactoring some code around a couple of ASP.NET Web Forms pages and decided to try out a variation of the Abstract Factory pattern of my own design. I need to create an implementer of an abstract class based on what query string value is available. Here's (a simplified version of) what I have right now: 

Now I will iterate over everything in and afterwards, I want to know if it was empty. Here is how I am doing that currently. 

My situation only included static methods on non-static classes, but it should work just the same for your situation. 

Admittedly, the logic inside the loop for display purposes is a little hairy since you have different criteria (less than as opposed to less/greater than or equal) for the first age range, but that cuts down on the operations you need to do on the set of data. 

I decided to try make my own way to save normal python data yesterday after coming across the minecraft NBT format, it's more limited than cPickle but appears to produce shorter results and so far works reliably (if a little slower). It works on the type of the input, and is currently compatible with , and I couldn't think of anything else. It's really easy to add in new types if you use the current things, like I'd forgotten about floats until the end, so I treated it as which worked fine. As the type ID is still stored as float, it sees its a float, so reads it like a list then puts it back together. I'm not sure how many other similar projects are available, but I'm quite happy with the result. It works by building a list of 1s and 0s for each item, which is in the format . If the item is a list or dict, its will refer to how many values it contains, and the code be repeated recursively.