I see a class. Your diagram inspired the thought. The diagram directly suggests the class would have an array (of hands) each element of which holds the final score for both players. This data structure, then, maps clearly to your UI concept. I see it as a separate class because it keeps score for both players, so it is inappropriate to be inside the (individual) Player class. A Player might have his score (hand) for the current game, but not past games, and certainly not the past games of a different player. *Your Other classes * 

We are lying the foundation for code organization and extensibility. With 20+ "types" this differentiation is also the single responsibility principle in action. This is fundamental functioning that every class/type needs. Now I can identify a plain-old byte[] by it's "type" and it behaves like a unique individual via it's values - as used in , , , , , etc. w/in the .NET framework. The entire statement will devolve to one line: 

Reference by Table Name and Remove more If-ing I'm guessing that your code is handling at least 2 different tables. If this is true then based on the name call "thisTable" code or "thatTable" code. Then you can eliminate all that checking for column names because you know they are there. And it eliminates another layer of 

OpeningRoleRule Seems to me every implements a piece of the overall score counting for a single roll of the dice. So the opening roll is just all those rules applied - see above - then checked against some minimum value. So maybe it's not a per-se. 

Incomplete or Incoherent Design I see (make it singular) but no classes for admins and requests. Is used? - what does it mean to "take" an admin? & - they should both be "Makexxx" or "Addxxxx". And "MakeAdmin" suggests that it makes an Admin object, but there is no Admin class to make it from. Why not instantiate member, manager, and request objects? You are forcing the client code to instantiate them. That's a guaranteed way to corrupt the integrity of your data. 

And as noted by Simon, the above assumes is a primary key or at least unique. Of course you can use any combination of value(s) that defines a unique record in your table. And of course this also means that when you read a record, read the key as well, whatever it is so the above sql can be done when sending records back. Finally whatever field(s) you use for a key, DO NOT let those values be modified in the user interface once they are created. 

That is generally true but inside loops... Well, for compiled languages there is valid reasoning not doing this but a brief browse is telling me it's not an issue in JS. And when creating closures in that loop/block-scope (not applicable here) you need to do this. end Edit 

EDIT This pretty much supercedes my original post, which remains below has been deleted. Strive For Structure "Structure" is any Class or Class composite that helps organize and use the data. The next two lines of code will replace over half the original code. I kid you not. 

What @RubberDuck said plus... I want to be clear that your Leagues / Teams / Players collections etc. - your domain / business objects, should work amongst themselves only. That DAL will create these. Then methods like are trivial because we're past all that XML stuff. 

Use messages in tests I strongly urge in the most emphatic way that you add a message parameter to every test. When you are reading oodles of useless generic test output that says, like, "expected to be equal but was not" you'll understand. Also the test method signature becomes more self documenting and is a huge help for anyone reading the code. Again, imagine dozens and hundreds of tests that you need to make sense of. 

Do you mean that if you had that then a would not have a ? But of course it should! You are not building a normalized relational database here. 

The Overall Theme Pushing details down into classes where they belong and making methods responsible for doing their jobs very significantly reduces client code clutter and makes object use simpler, cleaner, and reusable. large if block is hurting code comprehension Handle the outliers, the exceptional cases up front. I find this really helps eliminate unnecessary control structure. 

Memory Leaks As gets used it will have empty and occupied elements scattered throughout the . You will end up writing code to scan the array for every . Otherwise you'll be adding new elements when there are empty elements available. It looks like we leave objects in unused array elements. This is the case at instantiation, clearly. Also removing things involves but not ing the reference there. I guarantee you'll be spending lots of extra code and lots of debugging time trying to keep the in synch with the actual active objects. We don't know what an empty element is The is being incremented/decremented but we're leaving objects in place. I'm assuming that at some point we're done with a given object, in which case it should be disposed of. Besides the memory issue, how do we know what elements are in use and which ones we can over-write? 

You can use a mocking library, like MOQ, to "intercept" calls to , thus removing the physical database from the equation. And you want to do this because you do not want to be testing the Web Service. All you care about is what this code does with a given returned response. It is troubling that you have at this level. Why is this not done in the repository? Besides separation of concerns, it blows the whole idea of an abstract repository out of the water. Your concerns about "too long" methods seems arbitrary to me. may be "too long", but why? It's not so much "too long" as it is not understandable. Not without reading all the code carefully. It needs to be structured to express what's happening "at this level of abstraction". In other words, Your "Description of..." suggests what the method should look like: 

IMHO the ideal will be to pass a parameter to the factory that unambiguously tells what to construct. As is, the factory is making gross assumptions about the content & validity of the incoming query string. But there is no telling what free-form text is in it. The client code should evaluate & validate the query string and then pass the appropriate thing to the factory. And IMHO do not pass a string. Use . are: 

The Big Picture We made a data structure for the more abstract ideas of "difficulty" and "category" (vice "easy capitals" for example). This very dramatically reduced code volume and simplified client code. 

Be precise: don't say "blank string" when you mean (a.k.a. "empty string"). This: not: Eliminates uncertainty due to eyesight, font style and size, accidental spacebar, etc. Strings are reference types and may be null. Always use - preferred over . Either one definitely preferred over Test string parameters for null. Calling a method on a null string reference throws an exception of course. And to simplify downstream code I like to set null strings to 

Be kind to your readers and future you.... By convention class members are defined at the very top of a class followed by constructors. Puts blank lines between methods. is more conventional than . A hand is a flush. A hand does not have a flush. Don't be lazy with variable names: . That is excusable if it was only a for loop index counter. field and parameter names start with lower case by convention. Properties - upper case. What is a ? Very confusing. Underlying types are different in and . is magically the rank, suit, and hash code. Magic numbers everywhere! 

Students take courses. I need a course class. Is a course a student? no. vice versa? no. Oh - a student takes a course. Or a student has courses - has means composition not inheritance 

That would be good if you need to do lots of collective stuff - you gotta love all those extension methods! But here I want to demonstrate encapsulation. In the class override . This will make , for example, do identity equality. And you want that because you have a unique Id built into . 

This looks like the exception is essentially doing flow control. This is a bad use of exceptions. Exceptions are for unexpected, usually unrecoverable errors. The way exception handling works is intended for exiting gracefully from such an error without having the application just blow up. Exceptions are also computationally expensive. 

Data Structure Simplifies Everything By data structure I mean a class design making the hangman data accessible. You almost got this with the class. But we need instances. The big insight to all of this is that there are not "easy difficulty", "medium difficulty", etc. There is just a "difficulty". Likewise with categories. And the s say as much. 

Explicit output for debugging should not be built into the classes. Have the poker driver class do it. Implementing in all classes will help. That along w/ the existing public properties should be enough. Yeah we use the class along w/ a compiler switch to enable it but that is not license to violate single responsibility. 

DropDown and textbox work together. This focused interaction is independent of the calendar The dropDown and Textbox should be one class, and the calendar another. Further the calendar requires a object so we aggregate them: 

Do not assume class behavior, define it. I suspect the classes' s are coming from a database because they're constructor parameters. I say this because I wonder how id's are generated and are guaranteed unique. I assume they are unique! Just because it's name is "id" means nothing. The code assumes that I am assuming that id's are unique and are used for object identity. That a heluva lot of assuming all around!! Definitively declare the uniqueness concept in the class design by overriding . This leverages the often untapped power of .NET collections - they automatically use the override in , , etc. Embedding desired class behavior in the class itself makes that behavior consistant, enforced, and required (so to speak) throughout the application. Relying on client code to assume desired behavior and to implement it consistantly is the recipe for a lifetime of debugging frustration. Oh, the final gross assumption is that DB data is consistant and valid. Your class design should enforce all the business rules. IMHO if there is some redundancy in the DB, that's fine. But realize that relational database integrity and business rules are different things. 

Business Rules affecting Design All 3 controls always work interactively If business rules apply to all 3 controls together then let's keep them in one class. The calender has rules relating to the dropdown, and separate rules relating to the text box. And the dropdown and textbox have their relation rules too. In this case, one class to rule them all. However we assume these rules are the same; it doesn't matter if we're going to use is for "stop" or "start". Below we'll see how we get that context through class composition. 

We'll use that in a minute. Rename to something like Refactor so code reads "abstractly appropriate" 

Admin class When you go to McDonalds, do you ask for a hamburger or do you go to the kitchen and cook it yourself? should ask for the floors, it should not do it. Many methods in this class make this mistake. override toString is meaningless as a name, first. Second it's returning a formatted string which is better put into . Printing a ticket will essentially be a chain of calls. You do not need - override . Miscellaneous , not . , not . try block makes no sense. Java is compiled, if a class file was missing the compiler will tell you. - add as a parameter. Not all cars are created equal. There is no point having because all you do is pass it to . As an integral part of creating a vehicle this should be where you create vehicles.