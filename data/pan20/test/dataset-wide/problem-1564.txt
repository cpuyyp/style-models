In line with @M. Mimpen's answer, get all methods of object and store them in , where the key refers to the key from your parameter . An alternative to this, is putting an entry to Map every time an entry is added to your (the one you pass to the method). 

As an alternative of manually going through the loop to construct the comma-separated contents of the List, you can take advantage of the List's method alongside with method of 

You do not need condition check if you change the loop limit from to . This ensures that the last entry in the is skipped. Next, after the loop, you write 's last content. 

Code Explanation: First, use a two-dimensional array. Each row holds details about the question, answer, and choices. The number of rows is equal to the number of questions. Dedicate column 0 for question, column 1 for answer, and columns 2 - 5 for choices. A sample array content is shown below: 

Each possible option for is mapped to a with the method argument types used by your methods. You can then apply some basic mapping on the output to become a : 

The patterns now have an extra placeholder or (lower- and upper-case character, respectively), which the method handles internally. With this, the method can be further simplified: 

Part 1 solution is in the method , and part 2 solution is . Any optimizations that I have missed out for my solution to part 2, specifically in ? I feel like I keep having to compute the current layer and the maximum of the current layer every time I call to derive what is the value for the neighbours. How can I make my strategic (ahem) use of the values in the computation easier to understand, or it is fine as it-is? 

Inspired by this question, I decided to give it a try and implemented a brainfuck interpreter myself. It includes various improvements: 

Most of those sublists contain few or even only one item. Finding overtaking trains becomes a cheap operation. 

Main routine (for testing) Takes the program directly (not a filename) as first command line argument. Prints the tape's contents to after each step. 

Algorithm You only need two stacks. Always write to the , read from the . If the latter is empty, copy everything over. Naming Use meaningful names, such as and instead of and . Declare them . A queue's user doesn't care about the internals. Import only what you need, in this case . Generics The is a generic datatype, make use of it. Make your generic as well. Instanciate it using 

Second, breakdown your main process into sub-processes. For each sub-process, handle them independently. In case that there are required fixes to be done in your code, you only modify the sub-process(es) responsible for them. Sub-processes: 

Initialize items (questions, answers, and choices). For each item a. print question and display its choices b. ask user's answer c. Check user's answer. While it is incorrect, go back to . 

For instance, in row 0, the question is "1. Which country currently emits the most greenhouse gases?"; the answer is "B"; and the choices are "A. United States", etc. Since you have fix index dedicated to hold a particular value (column 0 is always question), it is a good practice to declare it as a constant inorder to make your code more readable and reliable (less error in encoding). 

The least common multiple can be calculated from the greatest common divisor, which itself can be found via Euclid's algorithm. 

Luckily, the common multiples also form an arithmetic series. It's step is the least common multiple of and . 

The problem can be solved in less than quadratic time. Sort the elements by absolute value, then search for consecutive elements that sum up to zero. 

The algorithm is wrong and can't be fixed. It's not dynamic programming, it's greedy: it iterates over the strings once and decides immediately which operation to perform. Consider some test cases: 

This is a textbook example asking for dynamic programming. The time limit is chosen such that success is impossible without dynamic programming. Dynamic programming can be applied to recursive problems. The idea is to store the results of all sub-problems in a table and if you encounter the same sub-problem again in another recursion path, you can return early. Change your code to something like this: 

Java's naming convention for variables are in , so I will suggest writing that as . With that said, the fact that Java being an OOP language doesn't mean that everything must be done object-style. For this relatively trivial exercise, all you need is just a random number: 

This is going to be subjective, but I'll just put in my two cents anyways... Looking at the statements above, I will roughly read them as 

Methods I'm assuming this chunk of code sits in your method, and I think one quick way of improving it is to break it into two methods - one that returns a validated user input (at least 5 chars with a space), and one for the actual work. When you separate them, you will also realize that you only need to print your validation message once, instead of twice as you are doing currently (to check for length, and to check for a space). Stricter input validation 

Both cases are identical in the first three characters, yet the operations to perform are different. They depend on characters not yet read. Any algorithm that does not take into consideration the full picture before making a single descision must fail at least one of those test cases. Yours fails the second. Brute force The naive way to overcome this problem is a brute force algorithm. Evaluate all possible sequences of operations (insertions, deletions, replacements). When all input was read, output the best sequence. Dynamic programming Dynamic programming starts out similar to brute force and evaluates all possible operations, but whenever it finds that two sequences of operations yield the same intermediate result, it keeps (and evaluates further) only one of them. 

In this case, if the last index of the character at position is indeed , that means we have found our unique character. 

Can simplified to just . Also, (and this leads to the next section), you need to be more careful about how you apply negation via your , e.g. when you values, you are -ing both and also values. and While your and is a step in the right direction, you should attempt to model it as a for an . Then, you should consider adding some helper methods on your to nicely parse the values to the required types, e.g. in most cases. So, assuming you end up with an similar to the following interface: 

Now, there's a set of list. Each of them is identified by a tuple and contains the connections between those points. 

The only difficulty arises from the requirement to sum numbers that are a multiple of both and just once. The easiest way to achieve this is to sum and independently and subtract the common multiples. 

Learn to use Folds, Maps, Filters and Zips! They are key concepts of functional programming. The sum over a list can be written as , a product would be . This is not limited to basic math operations and numbers. You can supply any function on any type of elements. In a similar manner, joins two lists into a list of products. Don't repeat yourself. Your function , and share a lot of code. Never copy-paste code. Create the proper modularisation and reuse it. Here, can be reformulated to use only calls to , and is just the self-covariance (and a square root). 

Calculating padding Storing your results as an means that you are also doing integer divisions for . You will need to add 1 more whitespace (start? end?) to fulfill your requirements, or can it be assumed that will always be an odd number? Validation You also do not validate whether \$number < 0\$, it'll be nice if you have done so. :) 

What is the point of ? According to Java naming conventions, your use of camel cases is inverted. Variable and method names should start with a lower case, and classes (e.g. ) should start with an upper case. The for can be replaced by one line for brevity, although there are still a couple more ways to optimize this part: 

Closed form solution The problem is basically a sum over an arithmetic sequence, which has the well defined solution 

The algorithm is overly complex. First, some general remarks. 1. If you use in a loop, you're doing it wrong. A search operation in a loop can be replaced by a grouping operation. Perform a single pass over the list and group it into a hashset. 2. If you can't reduce complexity, change the variable. Kruskal's and Prim's algorithm both calculate the minimum spanning tree of a graph, but their complexity depends on edges (Kruskal) vs. vertices (Prim). In most nested problems the variable to loop over can be chosen. Decide on the smallest. In your case, the number of trains and stations is probably large, but each train stops at only a couple of stations. Let's apply them.