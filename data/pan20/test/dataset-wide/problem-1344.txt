You've created a tuple of parameter values equal in length to the number of parameters specified in your query. 

No. This is not a regular grammar. Regular expressions are not the right tool for this job. Check string length and for the existence of character code points within each of the necessary ranges. Better still, follow the other suggestions to push for a more legitimate password complexity algorithm. I'll let someone edit in the appropriate and obligatory xkcd and stock overflow references. 

The following should read a hex string such as into vector . I was unable to find any built in method for doing this. 

Your and variables are very bad design. Hoisting allows the variable to be in scope through es3 (to my recollection), but you should never try to take advantage of that. These functions should be rewritten to take the object they are operating on as a parameter. Additionally, unless there should be some third undefined state, the opposite of should be , not a different detection method. is a poor description for the method as well. Consider something describing what it does like . Consider the following: 

Use caution in assigning an instance of the class as a static member as concurrent access to its operations can cause contention and consequent poor performance. A pattern I like to follow to ensure random instances are seeded uniquely is to have a package level static random member for seeding instances. This still risks contention, but limits the surface area for it to occur in. For simple gaming purposes the 48-bit seed of will suffice, but using will provide a better source of entropy: 

Then use the actual objects from the rows array if being consumed in other javascript code or send the rows JSON to wherever it is consumed. If for some reason your consumer cannot be modified to use a proper object and relies on the broken JSON string originally in the method, change to . 

To answer the question which was asked, no. The best method of document protection will be found in a technology designed with document protection in mind. HTML is not that technology. As others have pointed out, there are plenty of methods for copying the text both by disabling or modifying browser features such as javascript, as well as just requesting the document directly. There are, however, technologies available to protect documents. While nothing is foolproof, using something like an encrypted PDF document with the appropriate permissions set will likely be the "next best thing" that can be done in a digital form. 

You've called the parameterized query method of the cursor object with your parameterized query string and your tuple of parameters. I'm not a seasoned pythoner, but looking at the documentation, it appears that you have properly parameterized your query. I would give you a sign off on this code. 

I would join both and in recommending to guard your implementation and throw an appropriate error as well as exposing an external status check method such as or . Also I agree the card should be popped from the end of the list when using an as the backing collection. Finally, you have a very well formed class with clear and concise public members. Be sure to add just enough javadoc comments to allow a the class to be consumed without needing to open the code. 

While I would argue with that your implementation of is a non-in-place implementation of the Fisher-Yates shuffle, I would prefer to be more concise and use the base library utility method: 

TheJSON schema and data class attributes are unlikely to change. Consider implementing the class to encapsulate the JSON hash, adapting it to the ruby idioms and whatever other custom operations you've added. This should greatly decrease the cost and complexity of deserialization. 

A common quiz question is to check if a string is a palindrome without using in-built reverse functions. In Java, this can be done as follows: 

However, you are not actually using the month names anywhere in your code, so removing the months array and leaving the daysInMonth array may be more succinct. getMonthData() Convention would imply that a method beginning with should return something. In your existing code, you have assigned values to local variables and , but done nothing with them and they will be lost when the scope leaves the function. Referencing and without ever having instantiated them is opening up yourself to bugs. A newly constructed object should always be in a valid state. Consider assigning defaults to these values in the constructor or having a like parameter passed into the method. Finally Dates and times may seem easy, but they truly are a hard problem to get correct. Consider using a quality library such as moment.js to handle any Date/time needs which are not handled in the javascript specification. 

Your code is well formatted and easy to read. Congratulations. With regards to SRP, I believe your code complies just fine. Each dependency: the cart, rentals, and loyalty points is retrieved with a single call. The mapping for those DTO are isolated in a small single purpose anonymous method. The single responsibility for the method matches its name . If your uncomfortable with the idea of anonymous methods being separate from the method where they are defined, consider creating private static named methods in this method's class and referencing them. The only SRP violation I'm concerned with is the invoice DTO. I would recommend using the raw cart id and letting your presentation code format the title. Here's an example of how I may clean it up: 

Using two arrays to express an array single objects is unnecessarily complex. Conside creating one array of objects: 

I've created the following implementation of a trie in F# as an effort to learn the language. I would like to know what could be done to make it more idiomatic. Any other pointers are welcome as well. Of particular interest are: 

Second Javascript is a truthy language, and are considered false. Your and my method can go away entirely with a simple . If the property is undefined or evaluates to a falsy value, then it will not execute the block. Again in this section, is a poor description of what we are expecting. Consider using a more descriptive value such as . There is no need to at the end of the function -- You've modified the objects that were passed in. Consider the following: 

Yes, your while loop is suboptimal leading to increased loops and increased time for larger values. The problem can be solved mathematically. Consider this: $$ s = \mathtt{startingTotalItems}\\ n = \mathtt{newItemInterval}\\ $$ $$ f(s, n) = \begin{cases} \emptyset, &\text{when $n\lt0$}\\ s, &\text{when $n=0$}\\ \infty, &\text{when $n=1$}\\ s + f(s\ \mathbf{div}\ n + s\ \mathbf{rem}\ n, n), &\text{when $n\gt1$}\\ \end{cases} $$ Using a little algebra the last equation can be factored into a single operation. 

Encapsulation and create an unnecessary requirement for the consumer to manage the state of this objects connection. These methods should be made private and used internally by the object. Furthermore, database connections use unmanaged resources which need to be disposed of properly to prevent undefined behavior and memory leaks. I would reccomend creating a private method and return the MySqlConnection directly. It can be put into a block to ensure it is properly disposed when no longer needed. should not be public. It changes the state of the object, but there is nothing which can be done externally to capitalize on the changed state. Other does not need to be initialized to a , as it is over written later when you does nothing useful as written. All of the objects created in this method are abandoned as it returns . Ideally it should call and then operate on the DataTable that is returned. This function really doesn't seem to fit with this class at all -- It would work better in a DataTableAdapter class or as an extension method for a ComboBox 

This allows us to short-circuit the assignment of a value such as a name. Let's remove some of that duplicate code, and make a few more names clearer. 

Something @mjolka corrected but didn't comment on was the unused parameters in your method signature. If method parameters are not used, don't add them. This is an example of the YAGNI principle. If you later implement the functionality you anticipate using the parameters for, you have locked yourself into an implementation which may not fit your future needs. You also risk breaking consumers expecting the current behavior. If unused parameters are needed to satisfy an interface definition, seriously consider if your object fits the intent of the interface. This is commonly considered design by contract. Otherwise, implement the method to satisfy the interface contract. As a last resort, document the discrepancy in XmlDoc comments if the the object satisfies the intent of the interface and a proper implementation is not reasonable. In your example, should be implemented. A consumer relying on proper behavior could have disastrous consequences. There doesn't seem to be any reasonable custom logic possible in this implementation -- indicate is ignored if it can't be removed entirely. 

The response from the server is not best practice. If you have any influence over the service, it should generate an http error (4XX range) on an exceptional condition and include the exception details in that response. Assuming you have no control over the service, I would recommend wrapping the service call in a method returning a promise which can be resolved or rejected upon checking the response. If you only have one piece of code making the call then I would leave it as is -- wrapping for a single call would add unnecessary complexity. 

I would recommend an interface with read-only properties (getters, no setters) and have your final class implement that interface and return its constant values. I'm also not a fan of your Log class. 

That still leaves a lot of duplicate code. We will want to clean that up. Finally The truthy nature of javascript allows us to do this as well: 

If your shuffle method and random source are fair, than one shuffle is actually better than more -- you're skipping over entropy and risk introducing bias. If either is not fair shuffling more will not make them fair. 

Idiomacy Idiomatic c# expects PascalCase class names and public members. Member names should be a description of their function. Consider , , , etc. OOP Dependency Inversion Your constructor is hard-coding the values needed for your connectionString. If this is simply demo code, either hardcode the entire string or do it right and have the values passed in. Scope 

This can be further modified to support your use case: checking if removing a single character will make the string a palindrome. Instead of failing when a character doesn't mirror the opposite position in the string, look ahead and behind to see if the next character will match. If so, increment a counter and continue. If the counter is equal to the number of occurrences expected (1) then the result is true. 

Event Handler - You've attached the event listener to the document which is fine, but you've used an Id selector to filter it to. There can be only one element with in the document referenced by that Id.1 Unless the #updateBtn element is expected to be destroyed and recreated during the documents lifetime, it would be better to specify that element explicitly. Unused Variable - The variable is never referenced after it is instantiated, remove it. Improper Scope - The variable is pushed to, but never read from. If it is to be useful to other code it will need to be moved out of the event handler's scope. The variable is never used at this level of the scope, move its declaration to the narrowest scope required. Exactly One - According to the HTML snippet you've provided, the contains the which forces me to assume means there will be only 1 . Update the markup to indicate this element is special by setting the instead of the attribute. Because we expect this function to be invoked once it can be flattened into the parent scope. Parameters - JavaScript does not allow functions to be overloaded by parameters.2 the and parameters are never used and can be removed. Parameters are essentially variable declarations and should be named accordingly. would be better named . Type Variance - is originally instantiated as an empty array, but you're now adding a string to it. I'm not sure what your intent is, but the effect will be to cast the empty array to an empty string and append . This is only being done for the 0th element so a simple assignment will do. Wait, what? - First, nearly every string literal in your code is enclosed in single quotes ('). Suddenly you've begun using double quotes ("). Javascript will allow either, but keep your code consistent. I'm not sure what the purpose of the method call when your arguments are the full length of the string. this can be removed. Commented Code - Remove code that is unused. Only comment out code for the purposes of debugging or experimenting and remove the comment (and code if necessary) when done. Alert - should not be used for debugging purposes. Use the console methods , , , , etc.. JSON - JSON is a format used for serializing data. It should be used to save, restore, and transfer data. Your code should never manipulate JSON directly. Instead use the objects serialized from the JSON string. 

I would agree that your implementation is quite readable. Indentation and white space are consistent. The variables and operations are named clearly and concisely, with the exception of 'getNextCard' as noted by '200_success'. This allows us to focus much more at the low level nuts and bolts of your code. 

Casting p as a less derived object will NOT invoke the less derived implementation of the method. I've tried to make the recursive .Equals call obvious enough to illustrate what is a more subtle common problem when people override it. In this answer, I am focusing on the point that casting the object does not change the method implementation which is used. Unless casting to an interface type which is implemented explicitly in the Class's hierarchy, this will invoke the most derived definition. To not work this way would violate polymorphism principles. This will work for operator overloads in .NET as you are doing. Until I started researching this answer, I was not aware that operator overloads do NOT actually use the most derived implementation. I personally find this result surprising. 

I will comment on the JavaScript only. Each of your change handlers are doing essentially the same thing: check if the field is null, a single space, or the empty string and add a message to a notification panel. The textbox text attribute will not return a null -- only empty string. I assume in checking for a single space you are invalidating whitespace values. As written however, a double space (" ") would validate. I'm not familiar with the YUI library, but given its prevalence would be quite surprised if it did not contain dim sort of utility method. The same notification area appears to be updated each time, but is looked up each time. Only the message is different. I would suggest the following factory method: