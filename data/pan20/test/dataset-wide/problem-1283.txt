The above comments should be placed after setting , since they describe ... They are more confusing, since the code does not do what the comment say - it sets the at either or , then totally ignores the given information, and tries to get even if the last statement returned false. BTW - don't use - does exactly the same, and is more readable. 

Where not to lock I'm not sure why you decided to lock on and , as they don't seem to have any potential to cause any race condition (except for maybe when the manager calls , and even then - all that would happen is that you will 'lose' a round of one second - hardly catastrophic). Where to lock When you want to concurrently work on a queue - you should synchronize your work with the queue (in this case and ), which you don't do... How to lock You should also note the is implicitly which means that if the queue is empty, it will block until a new message arrives, which is probably not what you want, since you can't be sure that it is not empty (between to another worker might have 'hijacked' your message). Since is thread-safe, you could write your worker like this: 

Make operations close to where they are used Same as variable declaration, it is better to calculate a variable value close to where it is used: 

(perhaps you are asking about and not ?) A better way would be to simply iterate once over the collection, keeping the current position, returning upon reaching the correct type: 

One more general guideline - although you can have an construct, it is not recommended. Better to reverse the conditional: 

Naming, naming, naming... Your code is very hard to read - , , , (?!?). I understand (hope?) that some of these names are part of your business nomenclature, but, especially when asking strangers to read your code for optimization, giving meaningful names can go a long way. Asking me to figure out how to optimize a loop with would be hard enough if the names there meant something to me... Break it down Your methods are very long ( is 67 lines long...) this is a code smell, which also makes your code hard to read, as well as hides the structure of your flow, and possible complexity issues. Refactor your methods to be shorter, with expressive names, that will make your code more readable, more testable, and more optimizeable. Distribute the load As @Dan suggested in his comments - you should consider spreading the load on several threads/CPUs/machines... As far as I could see, your calculations are independent of each other, so you could simply arbitrarily split the load on several instances (let's say take over 9 of your friends' machines, and give each machine all the run ids ending with a specific digit...). This should give you linear scale (up to the point where writing to the DB is your bottleneck). Optimizations for one-time code Perhaps I misunderstood your explanation, but it seems that this code is meant to run once. If that is the case, why do you care if it runs 15 minutes, or 8 hours? Just run it and get on with your life! 

You are interested in how to use classes properly, so let's talk about it. Design your classes Why did you choose to split the functionality as you did? Does you have any stand alone value? Does it have any re-use value? In ruby it is very easy to arbitrarily break functionality into different classes, because you can call methods and members which are not there, and only in runtime they are checked. This does not mean you should arbitrarily break functionality into different classes - quite the opposite! It is the developers responsibility to design his classes well. How should you design this? What are the actors in this exercise? 

I've made my own pagination service for my forum that I'm working on. I'm quite happy how it turned out but it feels a bit rough around the edges so I would like to know how I can shorten this code and make it more efficient and better structured. The comments are overly redundant just so that I can pick up on the flow of the program really quickly now during the production phase whilst working on other things simultaneously. Figured it'll also help you guys understand what's going on easier so I left it in. Any pointers here are welcome, let me know if you need any additonal information. The markup (excluding banner): 

Is this a property in an object? If so why have you named it ? Give it a proper name such as or something along those lines to make it more obvious what it does. Now it's just confusing. And for the other function you could name it . If you included some additional markup it would help your question a bit. 

I'm trying to grasp this whole MVC design pattern idea but I'm in the dark if I'm doing it correct. This is where I need some feedback on what I've done so far. Here's what I'm wondering: 

Personally I would create loops for this, it's very unreadable at the moment and you are repeating yourself a lot. Remember the DRY rule (don't repeat yourself). Also if you do it via loops it's easier to maintain and change in the future. 

To start off, I can't see a single semicolon being used here. You should always close your statements with a semicolon. Also I can't quite understand what you've done here: 

I need to concatenate 3 input fields into a string which is formatted as a date , using or will not work in my scenario because Firebase doesn't allow it for some reason. I came up with a rather ugly solution, but I'm not quite sure how to improve it. is bad for performance, but I think that it is needed because I need to completely remove the properties from the object once they've been used. 

And then just call the function so you don't have to repeat yourself every time. OR another way would be to put all the elements you want to manipulate and the classes in two arrays, and then just call the functions using a loop and the index in the array. 

In a bigger project of mine I'm using angular to create a dropdown menu dynamically and then toggling a dropdown menu for some of the menu items. This is why I got a function that toggles the dropdown menus for only the items that should actually have one. However, I feel like I should try to DRY this out a bit since I'll be repeating the same function even more than what I've done so far. How can I improve this code? Should I create a self invoking function or something similar? Here's the functions (they're part of a controller object that I left out): 

I've written 3 factories as a part of a sign up process in AngularJS and Firebase. After completing them, I thought to myself, would any of these fit better as a service instead of a factory? From my research it's a bit fuzzy when it comes to choosing whether to create a service or a factory. If so, why would they fit better as a service? How can I tell when to create a service and when to create a factory? I've documented the to explain what they do, and the ones that lack a documentation explains themselves in the name. 

Error Handling Why not use (by way of , which - as @Pimgd noted - is better done using Objects.requireNotNull(Object, String). An NPE is, very commonly, a specific kind of invalid argument. The exception heirarchy isn't set up that way, but semantically they provide clear information: "Actual argument must not be null for 'abc' in method 'xyz'" is preferable to "Actual argument is (somehow) invalid for 'abc' in method 'xyz'" - no? You get this just by using - when checking, only indicates that "some" duplicates exist, but doesn't provide even a single specific duplicated key. Providing that level of feedback would be nice, but requires either a different map collection logic and/or extra logic deferred to when the "must have had at least one dupe - let's find one specific item to report" is being done. Such extra effort should only be done once the error is detected, when it's already known to be worth the richer error reporting effort. If you are going to validate args (vs. null or otherwise), you should do so consistently in all API methods - even when you "know" that validation would also done by other methods called in that method's body. True, such checks will be redundant, but I would rather be sure that it's done consistently than have to think about if the called function validates (and reports) a violation in the way it should. This is especially true when argument names change from what the API client used to what is reported at failure (assuming you were to follow something like @Pimgd's suggestion). Unless this is a "high-performance" utility (which I don't think it is), you shouldn't bother about any inefficiency due to argument re-validation. Even so, even if this were an HP utility, I prefer to validate arguments at the class surface (API / public methods) and then transfer control to private methods that can blithely (efficiently) continue without further checking, knowing it was done at the API level. (Simple check-then-delegate API methods would likely be inlined, and would be fine even for HP. If you're still concerned about efficiency, then you should be writing micro-code...) API Names Why and ? Perhaps and Sometimes sometimes ? How about consistently ? Use established language from mathematics about function inverses, where a is considered a discrete finite function: should be When a name part is , it should refer to the already existing class , not merely "some map with enum values on one side or the other." When you mean "Map of Enum to T" you should use (which may, or may not be, an ). Conversely, for a map (not necessarily an , which would under this naming imply an enum-to-enum mapping, where the two enum's might (not) be the same Enum). Why This Way? What purpose would serve? Rather than why not ? I suppose there might be times when some existing code wants such a mapping (and it's not open to refactoring), or ... hmmm... when? (Actually, I can see the point to such a converter, even in a green-field project. I would like to see the JavaDoc suggest that such a mapping be avoided in favor of the already-available when that is sufficient.) Ditto, re: Also, the reverse situation with a is also of uncertain value. Isn't that what is for? If you don't like client code dealing with exceptions, then a utility class which swallows and/or and merely returns seems right. BTW - such a utility method wouldn't belong to the class, but rather an or class in a utility package. I know you're playing with Java 8-isms, but seems overwrought. Why not just (I made this modification to your code and all tests continue to pass.) Since takes a merge function, why not expose that capability to the clients of this utility class? You might still default it, if you like defaults, but for clients that need to keep the first item in a merge, or the greatest, or the closest to a reference, or ... - they can't use your utility as it stands (making it less utile(?)). Documentation (and related type) When a method is documented as returning an (or ), the return type of that method should be specialized to match. If you don't want to specialize the return type, then you shouldn't mention it in the JavaDoc. The doc describes the contract - and the code should be as close to it as possible. Thus, as per the current JavaDoc, I prefer: I like your use of the right-arrow in the JavaDoc, but the "raw" docs are much more readable if you use rather than .