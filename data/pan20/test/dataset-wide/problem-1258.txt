Your program first says , before complaining about the "[[ ]" not being correctly balanced. Next, your program is hardcoded to check for , and . But what if we wanted to add ? Then you'd have a problem, because you'd need to change the code in a lot of places. My first thought of a solution for this is to use two strings, and then using to see if our token is in the string. It's not the best solution, I think, but it would work pretty well: 

And that ruins pretty much everything. You can kill the application at any time by just calling . What's worse, an application that's been stopped and been told to can't be restarted! So you should make it private, and access it via and . 

Ah, a validator! Stuff goes in, boolean flag "valid yes no" comes out. Looking at the function name, it seems I'll get back if the object is valid, so I guess I'll get back if the object is not valid. Except you don't. 

It actually makes no sense. Turns out that you're actually asking the user if they're going be working out. Well, in that case... ... I think you have two options here. One would be to not ask the user if they're going to be working out at all - that way the check can go - imagine a gym - someone walks in the door, and the gym attendant says... "Hi, are you going to be working out here today?" Now, mind you, this is not just any person, right. It's someone with a gym membership. In workout clothing. No, he's just hear to look around- of course he's here for a workout, why else would he show up at the Gym? If you're gonna be building a logging app or a converter or a calculator or a ... you do not start with "Hello do you want to use this app today". The user ALREADY started the program. ... Anyway, you could also rename the function to or something like that. Nothing wrong with descriptive function names. If they get too long, consider simplifying what the function has to do. Moving on... 

Style I'm sorry for making it personal here, camelCase, but the preferred styling for function names is that they're, well, camelCased. (Apologies for the bad pun). So not , but . Removing the Operations class I think your approach for implementation of is flawed. You're taking two Strings, converting them to numbers, performing a simple operation and converting it to String again. This by itself is not a problem, but... 

According to your comments, "Triggers" must start with the character. However, due to the way the code will look after you implement , this is nothing more than an assertion. Personally, I feel you should remove it. 

Additionally, for any three integers a b c, if a = 0 then a + b > c && a + c > b is false. Because that would imply that b > c and c > b. Thus I'd rename isTriangle to isValidTriangle, opposed to the function I described above. 

And is false. Next, the external thread calls . Because there is no other thread busy with start or stop, it can go into the method. It goes through the checks, is true, is also true, and starts a new thread (because the old one is "dead"). is set to true again... and... oh snap. Application threads: 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

this right here, with the if statements without braces? That's bad form. At least, to me it is. And then of course there's the overloading for checkForNull where it takes either Item or Bid. Even although the two are completely unrelated. That's weird. I'd personally have named them and . You could have put various business logic in there. Maybe you can't have negative bids? I dunno. It's a bit of a shame they gave you no feedback, if I was interviewing you I'd be interested in pressing you on these points. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

How this works is that, upon first usage of the class, the class itself is instantiated. The static variable is initialized, which uses reflection via to get a list of fields that need to be filled with enum values. You can see this in . When the call returns with a string-indexed array, it's able to set the enum values from this array. 

But it looks like your setter is actually quite complex, so we definitely cannot get rid of the setter here. I think a helper which takes would be useful. ... Heck, looking at it again, I think making the a helper and the delta the real one is the better choice. 

You should check the result given by , because otherwise your program may crash. Maybe not on your system right now, but basically, memory allocation can fail, and if it does, your program will crash afterwards by dereferencing a null pointer. Additionally, your function should not take a node pointer. What happens if I pass in an existing object? You just overwrite it. That's a cause for memory leaks. Treat as a constructor: either give it a cleanly allocated node struct, or let it allocate its own struct. 

One is clear to understand, the other could mean anything. Yet it can even make sense after we give it a comment... 

If you're going to throw an exception, then there is no need for the second if. If you're not going to throw an exception, you could at the least just turn it into an else. 

Additionally, due to a recent confusing, I suggest you rename to or something of the like. It's what caused the bug in an earlier revision of my answer. 

But it takes... 4 arguments. So that's maybe not ideal. New bugs ... err, features There's one sideeffect: Previously, if input was 

Readability It would help if you were to put spaces between operators and the operands. Basically, I find more readable than . The less effort I have to spend on interpreting the code, the more effort I can spend actually writing or improving the code. For reference: 

After this bit of code, you . There's an else block, but it's not executed if this snippet of code is reached. In that light, there's no other uses for and in this function. Additionally, was to begin with. So all that's actually relevant is to do this: 

Validating whether is null is not needed since you're just setting to otherwise anyway. I also feel this function should be split in three: One function for nodes. One function for determining from and one function for determining from . This will get rid of the deep nesting of statements you have here and make it easier to understand your code. 

Sign is good, main is good, Player is okay, I don't like Board, and Game is a mess. Relatively speaking. It's pretty naturally written, but you seem to be lacking some tools. Specifically, the idea of using object references as more than just storage of data, and "tricks" like using arithmetic in accessing data structures. First, learn to remove duplication. 

You don't have any performance metrics, so there is no telling whether this will have a significant effect, but one of the things you could do is combine your queries. Take this one: 

This bit of code contains a weird structure. It's for "adding a player choice to pattern", according to the function name. And that's what the first line does. adds the player's choice to the list. Then it goes on to validate. Why is it validating here? Instead, make a function called . Thinking in turns makes it easier to handle flow too. Its body can be something like this: 

This is a ton of duplicated code. Even the commented-out lines match. I'd recommend that you make a separate function for setting the size, position, texture and fill color, in an attempt to get the initializer of GUIWrapper to a higher level of abstraction. Similarily, InputHandler could use a higher level of abstraction as well - when handling mousebuttonpressed, you're traversing so many objects: 

Your example implementation is not good enough. It's not very complicated at all, as you suggest with the title; rather, it is really simple. The abstract class is not needed. There is no reason why a class (like a or something of the sort) should want to extend - something like a might already be extending a or a . You are abusing the is-a relationship. Consider this rewrite of your code: 

Because you want to program on the same level of abstraction - high level code is in "programmer english", describing the actions that need to be done (basically that list of 6 steps of yours, maybe compressed a bit). Low level code is pretty much regular code - code actually doing the work. 

Lastly, for , you have case 1 , case 2 and case 3 . You should use else-ifs here, because if 1 and 2 don't match, 3 does. 

So given the rather large amount of indentation, I'd suggest that you'd negate the if statement and turn it into a guard clause: 

I think you should work on splitting things up into even smaller functions. Especially the parts in where you start getting into the HTML. 

Will do the trick. If that's not what you wanted; such are the dangers of writing out every case; you haven't got them all until you've written down (where the amount of conditions you're checking is \$n\$) \$2^n -1\$ cases. So 1, 3, 7, 15, 31... etc. (The last one is caught via the else). 

Final code I can't fit the whole thing in here, obviously, but here's the helper function, and the segment: 

What you are looking for cannot be done. The type of the value to be retrieved cannot be determined as long as you store it all in a . Imagine you want to validate compile time that reads and writes use the correct type. The writing could be easily done; you can simply wrap and provide 3 methods for : , , . The reading could also be easily done, you just create a , and . What you CANNOT validate is, compile time, that should not be combined with . Similarily, it is also impossible to specify that for a CERTAIN RANGE of input values, these are floats, and these are strings, and these are... It cannot be done in a clean way. ... Ah. It can be done in a nasty way, though, by creating Enums to serve as keys. First, create an interface for the key... 

So for and and we enter the if statement, for and we perform the check for setting , and... the last statement is for when both are not null. So, basically, rephrased: