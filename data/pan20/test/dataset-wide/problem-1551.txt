Encapsulate connection information Introduce a new structure that represents the information necessary to establish a connection and use it to be independent of "retreiving the data from a properties object" that provides no semantic. Variable scope You can reduce the scope of the connection information variables to "method". Once you are connected they will be present within the connection. And you never reinitialize the "conn"-variable. Extract constants You have a lot of Strings that should be extracted as constants String templates Not neccessarily objective but using template strings will have influence how you express String composition. Naming As you are currently supporting a MySQL Database I suggest to rename "Database" to "MySQLDatabase". Separate concerns of process and output If you introduce a callback or an observer mechanism you separate the console output from the real doing. You are no longer tied to a console output. You can easily change console output to log file output. Refactored code 

Remove the interface State. It's not necessary. You already have an abstraction with "AbstractState" ResetState should not derive from PausedState they have nothing to do with each other. Inheritance is not for reducing code redundancy. It's modelling semantic. Maybe you mean that AFTER you made a Reset (go into ResetState) you are going to the PauseState. The same with the methods in AbstractState that were involved in the state machine. pull them down to the concrete states. Code is not necessarily redundant if it looks the same. In the AbstractState the methods involved in state-change should at most implemented empty. Remove all the super-calls Pass the Mp3Player through the constructor to the states and not through the methods As you are using the flyweight pattern right now for your states keep them immutable in the future. As you are using the flyweight pattern no prototype pattern is neccessary. Why would you create something out of a prototype if the result will always remain like the prototype? remove static initializer static {...} and introduce lazy initialization in your StateCache. As you have no access to the Mp3Player in the StateCache do the caching in the Mp3Player. The holder object and the state objects are high cohesional so do not pull them apart. You should not let other objects than the holder object or other states create them 

Writer I do not know if it is intended to close the PrinterWriter after the queue is empty. This will cause a problem when restarting the LogThread. Closed PrintWriters may not work anymore which depends on the underlying Writer that interpretes the "close()"-operation: 

You need a key generator that continiously produces unique keys of a certain key length that are used to shift characters You need a Decoder that will decode an encoded Text with a given key You need an indicator that your decoding was potentially successful. 

NEVER implement a hashcode on the base of attributes that may change. So following implementation is invalid by definition as the "id" is either expected to change or you have nonsensical objects: 

Due to JAVA restrictions JAVA does not support tail call optimizations of recursive calls. So this is a choice for or against readability and for or against potential StackOverFlowExceptions when the amount of stack elements becomes very high. 

parseConfig Semantical representants I guess that '#' is something like a comment and should be ignored during the parsing process. Here again you have potential to extract code to deparate methods. One other thing could be "isEmpty(line)". Token If you always have 6 tokens in each line OR the category is always encoded in the last token then you should do the split first and check this token on its own. This is alot more explicit as you do not implicitly assume anymore that the categories "process", "client" or "device" can occur in any token (that would be wrong I guess). Furthermore your token should not be check by "contains". Here also I would go more explicitly changing from "contains" to "startsWith" to assume that the category is always encoded as the first element in the token. DataCenterEnum I generally suggest to avoid language structure information within business names. I do not know how it will help somebody to know if it is an enum he is dealing with. SRP The method can be splitted to iterate over all lines and process one line. You will apply the single responsibility principle. Magic numbers Extract magic numbers as constants with meaningful names. Especially the the indices of the entries in your splitted list should be named properly. Code 

Documentation Documentation is overestimated. The only truth lies in the executable parts of your source code. The way code emerges the same way documention has to emerge and that is an experienced problem. Often these elements diverge when development goes on so documentation begins to lie about the things happening in the executable parts so it confuses more than it helps. Documentation often becomes an alibi for bad code. My suggestion is as soon as you are dealing with interfaces you should learn how to write JavaDoc for central interfaces that define the development responsibility borders or system borders. So source code should consequently be documented at those borders. Sometimes it is necessary to give an inline hint what is the intention. But most of the time your code should express exactly the requirement so no further documentation is neccessary. But why I am talking so much? It is because you should not create comments like "This loop prompts user to give a value for 'x', time in minutes" if the following loop prompts user to give a value for 'x', time in minutes. Naming We have several mechanisms to make complex things more ascertainable without falling into a delusion of documentation. One very important thing is "Naming". From some occuring names you are not able to evaluate a meaning. If you translate "x" for the user during output to "time In minutes" why not simply name the variable "timeInMinutes". Another problem is the abstraction level of names. Often abstraction levels are mixed. That relates to control flow and names as well. Your "validReply" can be evaluate to a lot of meanings as reply is not very concrete. But you are handling a concrete case: a (maybe very optimistic) validation if a "time in minutes" was successfully entered: "hasGotValidTimeInMinutes" for example would be a variable name of the current abstraction level. Modularization To make a developers life easier you should not flood your brain with information. Keep your stack "small". Your main-method is NOT small. Asking for "timeInMinutes" is one part. Asking for "Are you sure?" another. Those things can be viewed separately with "timeInMinutes" as the only connection to "Are you sure?" Modularization can take place variously. In your case I would start to "extract" a method. This is a typical IDE supported operation but you also can do it by hand. You should watch a video on youtube how to do this for the IDE you use. For your "timeInMinutes"-loop where you get the time in minutes you should mark the whole loop and perform an "extract method" refactoring operation either with the help of the IDE or by hand. The name of the new method should be something like "getTimeInMinutes". You should slice the main-method into several other methods each method doing on well-defined thing. What we are doing here is applying the so called single responsibility principle (SRP) in a very basic way. The main task in SRP is to achieve a 1 to 1 relationship from a code fragment to a responsibility. Things that belong together should be together. Things that do not belong together should be separated. You should continue to extract methods and separate the responsibilities. Method local variables Currently you are using the variable "validReply" only within the new method "getTimeInMinutes". So why removing it from the global scope and declaring it locally in the method. Why should we do that? Currently you know that the variable "validReply" is only used by this code fragment. But other developers hav to evaluate that Their mind have to process much more information to identify this relationship between the variable and the algorithm. Their mind has to hide other global variables and consider them as not relevant. In those small scenarios it is less a problem. But in professional software development with thousands of classes maximal neccessary scope of ANYTHING is the Holy Grail. So put your variables in the scope they are needed but keep them as hidden as possible. The "validReply" variable should be declared within the new extracted method. Encapsulation Here we mean that things have an inner state and an outer state and the inner state is totally hidden to us and our efforts to directly modify it. If we take the new extracted method as an example. It is currently not well encapsulated. The variable "x" or now "timeInMinutes" can be easily modifed by other algorithms which is called "side effect". We should introduce a variable with the same name (timeInMinutes) in the new method "getTimeInMinutes". Furthermore we will introduce a return value and assign the returned value to the gobal scope variable "timeInMinutes". We now successfully improved the encapsulation of the method. It is not perfect but it will do the job. Now I want to show the final result of our refactorings: 

Monitor I would start with formulating the Monitor. The Monitor is synchronizing the things of interest: 

General I was struggling about making this code review as in the first place I saw "a lot" of classes and separations of concerns (so my guess). But I went deeper into the analysis. Finally I came to the conclusion that something is strange about it. Do not get me wrong. You have basic modularization. But this has gone into only one dimension. You separated concerns vertically but not horizontally. Action The first thing which makes me think about is not beneficial polymorphism. An indicator for unfavourable polymorphism is that no behaviour is encapsulated. The only method in your Action enum with something to do is "byActionNumber". And this method is not under polymorphism. "isStopCondition" and "isChangeNumbers" are unnecessary indirections. You can evaluate directly the type and it is worth the same. Maybe at least "isStopCondition" is adressing another aspect. An inheritance hierarchy with each subclass providing same amount of boolean getters that will evaluate if the current instance is of a specific type makes this inheritance at least boiler-code. But furthermore you provide internal knowledge that you wanted to abstract in the first place. Calculator The Calculator has too many responsibilities even if it delegates tasks to its known "friends". Effectivly the Calculator "inherits" the responsibilities of all sub components. So effectively your Calculator ... holds the process state ... gathers input from a scanner for process purposes ... produces intermediate output to the console for process purposes ... gathers input from a scanner for calculation purposes ... calculates (this is what a Calculator is all about) ... holds and maintains the history ... produces the calculation result as output ... produces the history as output One reason for that: you haven't introduced abstractions at certain points. You are violating "dependency inversion principle". You can easily figure out the resulting coupling and god-like responsibilities by asking following questions: 

A Business-Object "Dog" that is self organized to keep its internal state consistent A Mapping-Object "DogMapping" that represents an intermediate state with little assertions to consistency. Its purpose is to make it easy to persist, load and transform it to a Business-Object A DAO-Object "DogDAO" (former name: DogMapper) that abstracts from the data layer. It can be used from the business layer. 

Your approach is flawed in both ways. I see some fundamental misunderstanding of equals, hashcode and == operator. To Option A 

Remove unnecessary dependencies Try to minimize the "invasion" of additional libraries if you can simply say . Apply single responsibility principle Extract code into additional classes: ISBNSpecification 

First of all: You got it nearly right. One thing in your implementation deviates from the standard implementation: 

With this in mind it will lead to following code at the caller: ... System.out.println(askForFirstNumber.getContextMessage()); Double d = askForFirstNumber.ask(); ... The goal should be to have all console output statements in one compilation unit to be sure that you are not violating the single responsibility principle. HistoryHolder You provide a presentation method. You should separate presentation from datastructure. Suggestions 

The tryAdvance-method handles the case if the supplier returns null to end the stream. The supplier in our case will be the "ElementJoiner" which getElement-method will return null if the timeout has passed. Defining simulation data Here I harmonized the return value to be a Set.