My ultimate goal is to compare two rows (only two will exist) and for a specific type and determine if its rows values are greater than the other rows type values. The result I came up with seems to be unwieldy which leaves me to wonder if it can be done in a faster or more elegant way. 

In trying to achieve a -ed goal for a two row data table into one row, my first thought was to use a . By using the one can identify/generate each of the rows with a specific column name derived from the row's unique id. (e.g. 'Lat1' and 'Lat2 for a 'Latitude' source column). All is fine when I use or data types but when I try to use a all become . 

Example (as found on SQLFiddle) In a User Table there are two records where the ids of s are and . The first s select, will return no rows requiring the the third CTE, , to use the instead. 

The space consumption for statistics on Teradata is not significant enough to qualify as a disadvantage. For example, the statistics for a single column is retained in a 16KB VARBYTE column on DBC.TVFields The rule of thumb has always been 10% change in the data which you have statistics collected or if they are stale. Unfortunately, stale has never really been clearly defined. Teradata 14.10 will introduce a more automated mechanism for maintaining statistics to help reduce the cost (CPU and IO) associated with the collecting stats using a homegrown maintenance schedule. This enhancement will be supported through Viewpoint. Teradata 14 also introduced some changes with statistics that have to be taken into consideration from previous releases. Carrie Ballinger has done a good job of capturing these changes in her articles on the Teradata Developer Exchange found here and here. Your stats maintenance schedule will be driven by the size of your environment, your ETL schedule, and manner in which your ETL maintains the target tables. We have multiple streams that maintain the same set of large target tables. As such we have moved the stats maintenance for these target tables to an external process instead of within each ETL stream. 

Example Shipping Lat/Long/DateTime We have two points in a ships journey reported on two different days: 

Since the row that could be read first and joined to the next may not be the Main route (remember always value 1 in for main), the sql has to have an which checks on what type Max1 is and then swap the check/results accordingly. Can this be optimized or even rewritten? This is just one operation in a CTE process so other operations can be entertained. 

Or is there a way to make the select smart enough to extract all users when its main operation returns no rows? 

How should one work around this if my end goal is to pivot all the values from the original table into one row? 

How would one go about having a sproc that allows a consumer to optionally specify the number of rows returned? If no row count is specified, then all rows returned. 

Most data models are lacking in a good DATE Dimension and thus force developers and report developers to rely on date arithmetic to find date boundaries that are relevant to the business model. (Fiscal Year, Fiscal Quarter, Fiscal Period, Calendar Quarter, etc.) A good CALENDAR table would go a long way to making your life easier. A simple EventDate BETWEEN SYSDATE - 458 and SYSDATE risks truncating dates out of your oldest quarter. Take TODAY as an example: SYSDATE - 458 yields 2010-09-28. If my math is correct the 3rd Quarter of 2010 started on July 1, 2010. You need roughly 548 days to make sure you are covering the entire range of current quarter plus the previous four full quarters. Trouble is that when you this will cause some overlap as your current quarter is partially complete. So you are faced with some additional logic to truncate out the fifth oldest quarter that you don't wish to include. My PL/SQL isn't the sharpest right now to write that logic but I hope the explanation helps shed some light on the approach you will need to take. 

Right-click the database (not the table!) Open Tasks | Generate Scripts On the Choose Objects tab, select the table to script 

Just to add that restoring a database from an older version (e.g. SQL Server 2005) to a newer one (e.g. SQL Server 2012), i.e. upgrading is usually smooth. The issues are encountered when restoring SQL Server 2000 and older databases to SQL Server 2012 and newer. Downgrading - restoring a SQL Server 2012 database to a SQL Server 2005 instance is troublesome. 

There is a huge difference between the records logged in a transaction log file for a DELETE and for TRUNCATE TABLE statement A DELETE statement records what exactly has been deleted, i.e. the value of the deleted row e.g. 'JohnSmith', so you can read the transaction log content (you can use fn_dblog), see what was deleted and re-insert the deleted record if you want. With the TRUNCATE TABLE statement, you cannot do this, as the statement is 'minimally logged'. The exact deleted values are not logged in the transaction log, only the IDs of the pages that held the truncated records are logged. These pages are marked for overwriting in the database data file and the truncated data will be gone for good when the new transactions are written to these pages. Therefore, reading only the transaction log cannot provide the values that are lost due to the TRUNCATE TABLE statement. The only chance you have to recover the truncated records is to read the page ID in the transaction log and find it in the MDF file, in case it hasn't been overwritten 

I have created a involved , no recursion, with multiple selects being done as it processes the business logic of the requirement. But I have been advised that the logic needed for the scenario where no rows are returned, should instead to return all rows in one of the middle s.. How can this be achieved? Note the following example is basic interpretation and the operation in question occurs after multiple cascaded CTE selects which are chained. 

I have created sql fiddle here which demonstrates the issue. Say we are shipping cargo and our main route of type 1 needs to be compared to the other route type 2. Each route has a Wave value and a Roll value which need to be compared independently. Note that other route types (except main, it is always uses) can be compared to of type value 1, but only two at a time. 

With the values currently in the table we expect that the MainsWave will be greater than the other's wave and the reverse for the Roll. Here is the working sql, note that the true end result is only concerned with and but all columns are shown for debug: