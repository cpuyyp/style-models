Update You should read The Genuine Sieve of Eratosthenes by Melissa O'Neill, which shows how to lazily produce a list of primes in an efficient manner. It's a very accessible and interesting article. I've pasted my own version of a fairly simple vector-based sieve below, with extensive comments. To run the testing code you will need the and packages. You can install those (and vector) in a Cabal sandbox if you wish. 

I've been working on adding an operation like to . This uses an extremely fast, extremely small, and extremely limited sort of queue of bits representing the path taken down a tree of bounded balance with . If the word size is 64, or nearly so, then it's unlikely that the code will overflow the queue (which can hold up to bits). If the word size is closer to 32 bits, then I need to be a bit more careful about very large maps. I believe that I've calculated appropriate cutoffs based on the maximum tree depths described in the paper, but I'm not entirely confident. Furthermore, I don't really know how to test this code—it requires a setup with a small word size and a giant, badly balanced map. 

I'm a total newbie at parsing, so I figured I'd start by writing instances of for , which does not currently have them. I'd appreciate some feedback on the following: 

To fix that, you need to allow for some very small tolerance. You could mimic by setting that tolerance to : 

Always write a function (with appropriate inputs and outputs) already returns a data.frame was not needed since is vectorized. This will be faster but it is probably a drop in the sea compared to plotting. The use of to add dependent columns interactively (no need to write over and over and your code is much more readable.) Make your code (especially the one you posted here) source the packages it requires. I had to look where was coming from Do not write code that throws warnings. Read the message carefully and find what the problem is. In this case, it was warning when trying to plot arrows outside the plotting area. Hence I added some margins and to the plotting area. Personal preference: put some space after commas and on each side of and binary operators. Also use linebreaks so your lines are never too long and add spaces to make things align when you get a chance. I have removed your comments because they were not using the R syntax (need and not ) but that's an easy fix. Yes, comments are good and having a lot of them was great. 

Instead of a top-down (very memory intensive) approach, I would recommend a somewhat bottom-up approach, where you add one column at a time then do the reductions, add another column, etc. Try this: 

Of course, the implementation is according to the specification correct. But that doesn't make really sense. I would prefer two alternatives: 

I wouldn't say, mine is better, but I prefer it this way: 1) One entry, one exit 2) One variable changed if needed. 3) Easy to follow. 

Even better: you have microtemplating on board, which means: You could define HTML including placeholders within a script-tag 

You iterate over all books in the library, and if one book matches, you return the whole library. That's not, what you intended. And more Do not return ! Please, never ever! That doesn't make any sense and leads to excessive use of Guard Clauses against . It is a clear antipattern. In Java8 there is a nicer solution if you want to hide in an optional. Say, your teacher asks you to look for a specific book on the shelf and you do simply nothing - what does that mean to your teacher? A) you are deaf or b) you are dumb or c) you are neither, but there is no book. If someone asks you for a list of books, when there is none, simply return an empty list, and say politely: »Sorry, the list is empty, because there was no such book«. 

You have two responsibilities: 1) A , which is used to authenticate/log a user in 2) An , which takes care of all actions belonging to the user So a possible routing schema for the API would be: (1) POST: api/login Possible Answers: 200 OK or 401 Unauthorized If an unauthorized user enters a page, where authorization is required, the answer should be: 403 Forbidden. The same goes for every REST-action, which needs authentication. POST: api/logout Possible Answers: 200 OK (2) GET: api/users/ Possible Answers: 200 OK and a list of all users in some output format (JSON/XML whatever). The client could specify his wishes via e.g. application/json GET: api/users/{ID} Possible Answers: 200 OK including the requested user or 404 Not Found. If you keeping track of ex-users a possible answer could be 410 Gone. POST: api/users/ Possible Answers: 201 Created including the created Ressource in some output format (JSON/XML whatever). If there is anything syntactically wrong (something missing or a field misspelled) with the userinput the answer is: 400 Bad Request PUT: api/users/ Possible Answers: 204 No Content DELETE: api/users/{ID} Possible Answers: 204 No Content So far a possible Layout. Now some words to your code: 

This way, each iteration will only have to search through $M = 2154$ rows instead of the 100k. But it is not fixing everything and I prefer rewriting your code with your more general goal in mind, where 

Note that assigning intermediate outputs to a variable in the first approach () should not carry any significant time (feel free to test). And your code will be a lot more readable than using nested calls: . 

(I would even encourage you to drop the and keep a matrix of booleans). Also, since this is so easy to compute on the fly for any given threshold value, I would discourage you from storing the output in a file. You would only need to save the incidence matrix. This way, you will save disk space and read/write computation times. Next, 

Finally, a recommendation. Be careful using single characters as variable names, since R already uses a few of them for built-in variables or functions. You could for example confuse your variable for the function for transposing data. Other single character variable names used by R that come to mind are (concatenation), (quit), (TRUE), (FALSE), (inhibit). Anyway, it is always better to use descriptive variable names and that usually implies more than one character. 

Here is how you would do it with no for loops. The function computes the distance between every pair of rows of a matrix. So you have to apply it to two matrices: 

There are more efficient ways to implement this: 1) If you only need a dictionary to keep your data together without semantics, you could split as follows: 

Looping over your array and sorting out, which ones you don't like. You could play with this Fiddle 2) The "functional" approach 

I can't find any reason for your global variable. As far as I can see, it is declared and overridden in the success handler of your ajax request. So why not declearing it inside the success handler? Next: Why didn't you use a parameter in 

First: I have to admit, I do not know a single line Elixir. But on the other hand, I think I get, what the code does. I can not give you advice, how to implement the improvements, but I hope to help you anyway. In the description you have the following definition: single minutes: When it is 1 minute past the hour, YOOO is returned. When it is 2 minutes past the hour, YYOO is returned. When it is 5 minutes past the hour, OOOO is returned. single hours: When it is 1 hour past, ROOO is returned. When it is 2 hours past, RROO is returned. When it is 5 hours past, OOOO is returned. What both have in common is the pattern and the result . That should result in one function, which takes the following parameters: number,Symbol and produces the according output. Your code has: 

I think the author meant that at each time step the walker will walk in one of three random directions (x or y or z), not all three. Without making drastic changes to your code, you could replace this section: 

Question 3 Is the design correct? As I mentioned, I frequently will invoke this function on the columns of a data.frame. For example, I'd frequently need to do my_filtered_df <- filter_by_mz(my_df$mz, target_mz, ...). Would it be better to write the function to work on data.frames rather than just vectors? Your function returns a vector of booleans, not a data.frame. So you would have to do: 

You can speed up your code by replacing the loop with more efficient (vectorized) functions. Your code can then be reduced to a simple one-liner: 

Regardless, let's take a step back. The construction of the matrix is so simple once you have that you should just do the following all the way at the end: 

With , this code runs in 0.015 seconds on my machine, versus 12+ seconds for your . It also scales pretty well as it takes less than 0.4 sec for . 

Disclaimer: I don't have an account to that rescuetime website so I was not able to fully test my code. If you find a mistake, please feel free to edit my post, I won't mind. Thanks for sharing your code, I like R and particularly enjoy seeing people use it to connect and analyze online databases like you did here. I hope my comments will help you. 

is in fact a model with a key called "content" (e.g. {content:"blah!"}), which is used to render the template, so that <%= content %> is substituted with the actual content. And many more stuff to discover. Referring to your problem - you could abstract your problem with backbone like the following: Every tab you need to display is a view to which belongs a template to determine its html as well as a model, which represents the content of the tab. You could embed each tab in another view, such that you have one embracing view to control the whole tabbing system and nesting views, which represent each individual tab. You could write a custom show() method to show an individual tab and a method which coordinates which of the tabs is shown and which should be hidden. So instead of doing the annoying work yourself, it may be a good idea to use a library to help. Some places to start (besides the official API and documentation): $URL$ $URL$ $URL$ $URL$ 

This gives you nothing in terms of performance. It would be optimized away by the browser. 2) Chain-calling 

»If the book is or the book is blank throw an « Btw. Why did you you use the negative from: instead of just ? 

Of course you could choose another strategy to get a suitable transport. For the sake of the example I chose the strategy to get the first one able to do the job. Since you asked for constructor injection, I implemented it this way, taking a collection of transports. I would prefer setter injection. If there is the need to travel on a (different) ground, the human asks its collection of transports, whether one of it is capable of doing the job - so the human too has not to have any knowledge at all what is good for what job. If you ever come up with a car, you add it to your factory and ask your factory for that. And the car knows best, for what grounds it is made for.