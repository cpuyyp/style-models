The performance doesn't make any sense to me - does the same thing as , except it doesn't create any unnecessary strings or arrays. Is with a start position just really slow, or is there some optimization only the first method is picking up on? Finally, here's one more method, which is much slower in every browser I've tested, but beautifully concise: 

If you know every element in is truthy (not 0, null, undefined, false, or ""), you can use this loop, which is shorter and more efficient, and in my opinion more legible. 

ps: I can't just do something like , because I need it to shrink as text is deleted. Also, I don't want to remember the previous count and just calculate the difference, because some changes will inevitably be missed and a differential script will never right itself. 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

Instead of , use to avoid precalculating and storing the entire sequence in memory (and also spawning an unnecessary subprocess). Instead of , use to name the argument then use . Note that is an alias for , but it's idiomatic to use for assignments and for expressions. Beware of the possibility of failing! Using an chain as @glennjackman suggested will avoid this pitfall. It would also be possible to replace with but that's ugly IMO. 

The solution you edited into your question can be improved upon (shortened and sped up) by using an object for instead of an array. After all, you're just using it as a lookup now - and an array is one of the worst ways to store a simple lookup. Here's a complete implementation. 

That has the benefit of not creating properties you don't use. Also, did you strip out some code? Because it seems like all you're doing is storing a reference to an object. Why not just use the object? 

The switch statement might be more legibly written as a series of if else-if statements (with nesting), but that's mostly a stylistic choice. 

Zirak's answer is all the advice you need, but since he didn't actually write any code, here's how I might re-write it. 

If you don't like nasty bugs, always use for allocation sizes, not . Yes, somebody will do it, this is a fatal flaw in the Qt libraries. You're missing move constructors/assignment. Most likely they should be implemented by moving the ownership logic out to a separate class (if you don't take all of my advice, would work) and then using the Rule of Zero. There's no point in providing a method (this is a flaw of ), you can just use on the iterators (that you need to implement). Most implementations use instead of , or even just a single member which points directly to the string data. and stores size/cap information at offset . Newer implementations often use SSO (Short String Optimization) as well. You're missing slicing operations. Slicing operations should return a class though, instead of allocating a . You're missing , which most people want from a string. Though I'm not convinced it's useful; I treat strings as opaque blobs rather than containers. If you choose to have mutable strings (see below), you're missing , , and . In either case, you're missing . You're missing , , etc. These should allow mixing with . 

While the above solution works, it is somewhat inefficient and messy. This stems from the fact that you're trying to get javascript to work the way you want, when what you should be doing is trying to understand how javascript wants to work. Each language has a style, even a personality, and if you're flexible enough to go with it then your code will be shorter, faster, and cleaner. Here's how I would abstract away my JSONification. 

is, actually, the worst variable name there is. It is impossible to create a less specific name. I would suggest renaming it. 

This looks like something you'd want to do server-side, mainly because you can cache the result. So for every request but the first one you're essentially just downloading a file. If you can't do it server-side, here are a few improvements: 

There is no good reason for you to make 4 separate calls. Most likely a single call for would be enough, but even if you have a pressing need for them to be on separate pages, you should still 4 pages in a single call. You don't need to open to get anonymous memory, just pass as the FD and add the flag. 

My preference is to then use so that I can stuff it in a or or set along with any other read- or write- file descriptors. 

All of the above, except for the last two which are special, provide exactly the same public API (except ) and can be implicitly constructed from each other if it makes sense. 

Here's a second solution, which is slightly faster in Firefox, but otherwise between a little and 5x slower: 

Why is slower than ? Is there any way to optimize the regex in so the performance is comparable to the first two? Is there any other way to speed up this code? 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with. 

Other answers have handled specific issues, mine will handle larger design issues. Some of my later advice is highly opinionated, but it is motivated by real design problems; be sure to understand the problem before dismissing it. 

In my experience providing or on strings is a mistake. Instead, strings should be constructed via one of: 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler).