The type is now modelled as a tuple. I would recommend a case class for it. That allows you have the code in search be more readable. 

To me it's unclear why the method contains the code it does. It seems the code could also be in the class. Or, the other way around, the code for analysis could be in the factory (or another class). I would not use mutable structures to split the document space and documents containing a word, this is more sensitive to programming mistakes. On top of that it disconnects two pieces of code that are connected, forcing our brains to do more work. A simplified example using option: 

I recommend the same structure for classes: public (and most important) members at the top. Then (in usage order) the other members. This is ofcourse personal preference. In some cases it's not needed to specify a type. For public facing members it's good practice to write down the full type. For private (and function local) members it's not needed and might actually introduce noise that harms readability. I noticed you are using and a lot. I try to not use them as they require the reader to backtrack to find the type of the tuple that contains them. There are a few techniques you can use to avoid their usage. 

It's clear that you took some time to polish your code, good job on that. I like how used method names like , the allow for very readable code. My suggestions (note that none of the code was tested or compiled): It's 'weird' to combine a class and a . A case class gives you a few things for free: 

It's a small point but it can make a difference when coming back in future and looking at the code but try to be more consistent with your indentation and general code cleanliness. The contents of your classes aren't indented at the moment and you have a couple of unnecessary new-lines at the bottom of the , and methods. Aside from that you've been consistent with the casing of method names and using your braces on the same line (I want to recommend new line braces but that's mostly just personal preference). Something debatable is whether you need the method. It's only called once and that's inside the method. While only the method is public so from a public interface perspective it's OK, if I were reading the implementation I might be confused as to why there are two similarly named functions and what the semantic difference between and is. In this case I don't think the method adds much because I wouldn't be confused to find the line in a function. There's more discussion on single usage private methods here. 

Don't catch , try to catch specifically the exceptions you're expecting to see. In this case you'll want to catch things here $URL$ and whatever might throw. You might also need some exceptions around your LINQ statements afterwards in case the .ini file isn't valid, e.g. 

The method has a comment, requiring the user to do something before it can be used. Most programmers will not read a lot of documentation (apart from Ikea manuals) before using a library. In this case it might be best to help users of the method with an explicit type. 

For the line and the line are connected. will throw an exception if it is not guarded by . This is a simple example. In more complex cases the maintainer of your code might move some pieces around accidentally breaking the code. If we apply that to splitting the documents into the two datastructures it would look like this: 

It seems there is a clear relation between a and a , it seems reasonable to expect a factory method. 

I would also change to a normal class without title and a lazy field. About the and the , they seem to be the very related. It seems you can construct an instance from an , this would make the an ideal candidate for the factory of . Such a factory is commonly at the companion object. Note that I would personally introduce a case class for document. 

The class contains quite a lot of public members that are not really suited for public use. It's a good practice to mark methods as private that are only for internal use. This has (at least) two upsides: 

In which case the second line wouldn't have a . Similarly you don't currently handle the third line properly. Also consider your access levels. The constructor is but because the class is the constructor can only be accessed internally too. I'd also recommend sorting your methods in such a way that private functions are at the bottom but that's a personal preference/situational thing. The following points are low priority but worth thinking about. As others have mentioned you don't need the word Config in your methods (and be consistent about it, don't use both Config and Configuration). Think about how the calling code would read, e.g. . Since you can get autocomplete hints with argument names now if the method signature was then it's more readable. Similarly isn't the best name in my opinion. Since you're then converting into a dictionary that uses s, might be better. could return null if the fails but this might be what you want. doesn't need to be stored if you pass it straight into and as others have mentioned, its value should be passed into the constructor. Your error message for failing to read the file could be improved, it says . Firstly that should be as is possessive. Secondly that isn't the only reason a file might be locked. It also doesn't include the filename itself. A better error message might be: . Similarly the message could be better depending on your expected usage. I would use or something along those lines. To me, "missing" implies something more than simply not finding something. Also note the string interpolation using there if you're using C#6. @JanDotNet also mentioned the class killing the application if loading fails. I'd add that it also shouldn't interact with the console. In future the class might be used for a non-console application and throwing exceptions with the relevant messages would make it easier to move them from the console to a dialog window or web callback. Finally, C# projects have an app.config file that can be used for configuration like this, with a pre-built configuration manager. It would be better to use that unless you need to support .ini files specifically.