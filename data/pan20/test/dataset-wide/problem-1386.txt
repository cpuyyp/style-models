»If the book is or the book is blank throw an « Btw. Why did you you use the negative from: instead of just ? 

Why only compare the title? There are at least two books calledFrench Kitchen, but they are not the same, since the authors differ. 

To me. the design as far as I get it, seems a little bit smelly. I do not know engough of your code or the domain and your concrete implementations, but I would prefer other solutions to the dictionary-lookup or switch-statements. Perhaps you could make use of the decorator-Pattern: 

Your code has two major flaws: 1) It has bad runtime behaviour: First looking up the special cases, treat them remove them. treat the rest. This are too many iterations over the source material 2) It is unneccessary complex: From (1) Alternatively: It depends on how much effort you want to put in, otherwise, this will do (for your simple case): JAVA 8: 

I think, there is room for some improvement: 1) You are mixing OOP with procedural code If you choose one paradigm, you should stick with it. Besides: why are you abstracting into a class and not the whole ? 2) DRY - Don't repeat yourself 

I note you have preset values for your arrays, which contain no html, otherwise I would be wrapping those echo statements in htmlentities() or the likes. And lastly not sure if it is intended behaviour, but you use ->addDay(0), then addDay(1), then addDay(2), but when you get to 2, you will have actually added (1+2 = 3 days) to the date, and so on. 

Database service, take the config out of the service, and store it in a config file. otherwise you need to edit the code when you deploy to a different server. Would a join work better here 

I prefer to have a guard clause at the top, so you can easily see the outcome of the if/else without having to scroll to the end of the code 

I have included a test script below (DO NOT RUN AGAINST YOUR LIVE DATABASE) I have manufactured some bad json data so that it will execute a delete statement on the tracker table in your database. Obviously it won't work unless I get the table and column names correct, but as your code is now, if I try a dummy column name it will give me back an sql error message, which can help me to narrow it down. Log the error message instead of returning them. This is an API, all the client end needs to know is that it failed. Don't give the attacker any more information then necessary. 

Supposing, splitting by \w+ gives in most cases, what you want. Another solution would be . Depends on your demands. Go play with it! 

a) CRUD and ajax There is no clear answer to that: it depends. If you are working with browsers as clients of your interface/API, there are only two of the many implemented, namely and . This is, what we all know from our standard specified under . These were the genuine methods available (rooted in historical decisions, but I see no reason to stick with that; browser developer should change this constraint). In order to use a restish API, which has e.g. also support of , , there is a way to circumvent this constraint. Many frameworks provide parsing a hidden -field where the "rest-method" is defined and map to the according controller. As you can see, it is not always necessary to do it asynchronous or with javascript. So ajax is only one - but a nice one - option to play with. Unless not otherwise restricted (managers, users etc.) I would always go for ajax. b) Is ajax safe It is as safe as you make it. There are possibilities for securing your endpoints. But as I said, I am not quite up to date, what Microsoft offers, there are possibilities for sure. c) Is it fast It is as fast as your hardware (connection, server etc.) allow. There is no difference in terms of performance doing something like a or a . The main difference is, that a traditional is a) not asynchronous and b) you are loosing the current context. d) Form of CRUD requests You form your actions via and : 1) Get a list of all Users: api/users 2) Get information about user 1: api/users/1 3) Get all users, which are from Seattle api/users?location=Seattle 4) Get all male users, which are form Seattle api/users?location=Seatte&gender=male 5) Create a user api/users/ sending a JSON representation of the created user {"name":"Doe", "firstname":"John","city":"Seattle" ...} 6) Update user 1 / api/users/1 sending JSON of the changes {"city":"Miami"} (if he moved to Miami} 7) Delete user 1 api/users/1 If you want to specify the output data from the server, you could set the field in the header e.g. to or . As you see, there is a big advantage in using a RESTish API: you have a set of universal verbs, which each service speaks, which is easy to learn and to adapt. These are the basics of the REST-philosophy. There is more to say, but not in this post ;) 

The security aspect of things looks fine, but there are some areas for improvement, I have provided inline comments where possible. The whole quiz could be coded as a class, and would be a lot nicer, however I didn't want to go too far from what you started with so you can see what changes I have done. Overall, I have split the code into functions, and tried to make each function do 1 thing only, and renamed variables for readability. This will become more important when you go to maintain the code. The first bit of code is what I used to test all the functions and catches exceptions that occur. You could improve by adding more error checks after each prepare and execute, but I will leave that to you, as they are only really necessary if the database structure doesn't match the sql. 

On a final note $lang->xlate may sound like a nice function name, but after a while you will get sick of typing it, $l->x is cryptic but shorter 

My personal preference is not to nest functions inside if/else statements as you have done with the copyRecursive($source, $destination) function. Put functions at the top level it will make your code easier to read. For code readability I would also move your email generation code into a separate function 

Besides the nice OO-solution, another (procedural) solution to your looping problem is possible: If you have cases, where you iterate over a collection of and only the first element needs special treatment, you could it off your collection, treat it like you intended to and iterate over the rest, so in your case: parse the text until "headline" is reached and iterate as intended over the rest. You could make use of to shift the first element. Pseudocode: 

I've seen, that you made up this code as an example, so I hope, that this is not your production code: 

Looping over your array and sorting out, which ones you don't like. You could play with this Fiddle 2) The "functional" approach 

You have a instead of a plain variable. This helps you to encapsulate: 1) The name/filename (in case you need it somewhere else) With the constructor, you are free to define a naming scheme for your files. For the sake of the example, I simply used ".dat" as a suffix. 2) The actual datastructure (here for the sake of the example a list named »array«) 3) The calculation function This is, what OOP was invented for: keeping together data and functions, which work on that data. In the -function, you see, how you set up things: 1) the are made of a simple tuple, holding the name as the first element and the function as a second element 2) the configuration of your "variables" is done via list comprehension . For more complex tuples, I would go with namedtuple which allows you to reference the content of the tuple via proper names than indices, which would result in better readable code. But in this scenario, the indices do the trick. Your -function should take the list of objects as a parameter. And you are done. 

I have been using php for over 10 years and never found a need for a session wrapper, but maybe you find it easier/better. There are a few improvements that could be made with your code If we are checking to see if the session has a key, a simpler test is 

Code reuse, when I design stuff I only create a separate method if I can reuse the same code, or due to it's complexity/size of the function it is best to break it into smaller parts to make it more readable. 

If you can get all the shift ids in advance and do something like this. This is just some pseudo code to give you an idea 

To be honest, I was able to pickup and read you code really easily and understand it, which is the end goal. So what you have already is fine if you want to stick with it. In saying that, there are a few things I try to do, when mixing html and php. 

Doing that alone will remove 40-50 sqls from you total, then do the same for another repeated query. I do like using ORM's in code, but only for basic Browse Read Edit Add Delete operations. As soon as I get to complex reports I drop back to plain sql, as the ORMs don't perform as well on large datasets, and they can often end up performing more sql's then are required. 

Of course, the implementation is according to the specification correct. But that doesn't make really sense. I would prefer two alternatives: 

Even better: you have microtemplating on board, which means: You could define HTML including placeholders within a script-tag 

I do not get the reason for having two functions for asc and desc ordering. In principle, if asc is a call to a function , then desc is nothing more than calling the same function with reverse order of parameters . No need for code duplication. As far as I can see, the only difference beside calling your sort function with different parameters is, that you in the asc-Version have lines, which contain and the desc-Version calles . You could refactor this out into a call resp. . Besides that this code has to be broken down into smaller easier to understand sections - I really do not want to get my head around this - you have to avoid code duplication by all means, since it is the N°1 source of errors: if you change a statement in one place, you have to make sure, it is changed in every further place. 

This way the browser does the img caching not your server, so the network bottleneck is no longer an issue. There are a limited number of combinations that the browser needs to cache. I am making some big assumptions about your design here If you treat the tile as a div background, you can use plain html to render the coords over every tile if required. 

I feel your code is way more complex then it needs to be. I am guessing in the end you just want to produce a random secret santa list. I have put some echo statements in the code, so you can easily follow how it works. This is not the most efficient way of doing this, but I have tried to keep the code as simple as possible. This list executed in less then 1sec for me, I am pretty sure it would work for at least a few hundred names without timeout 

Check $trackCols against a list of valid column names you are expecting, to stop me doing things like I have below. 

Personally I find if it is a short function, that you do your validation and exit early, these are usually called "guard" clauses What you are doing here is more what I would call validation, than sanitizing. Eg. sanitizing would be escaping data before feeding it into and sql statement.