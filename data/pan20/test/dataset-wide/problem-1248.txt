First, there is no presentation of the board when play starts. So you're relying on the X player to know what's going on. Second, using two lines to ask for the move raises the issue of making a mistake and needing to go back. I'd suggest you either add a "go back" feature of some kind, or convert to using a single line of input for the entire move- some kind of X, Y input, or numbering the cells from 1-9. Third, you don't do any range checking on the input, as is obvious from the end of my game. Given that you don't prompt the user with a definition of what input is valid (1-3), that's a double error. You need to tell the user what's valid, and double-check the input to make sure that it is, in fact, valid. Fourth, you need to improve the presentation of the board. You should display it prior to each move, even the first move, so the players know what's what. You should also label the board, so that input is obvious. If you ask what row, column for a move, then label the rows/columns on the board display. And please change the '/' into something more sensible - use a space (' ') or a dot ('.') or something that looks like an empty cell. That said, let's look at some code: 

And if your nodes default to truthy (which most objects do), you can replace with , for more readability! 

This may tend to make your last loop iteration cleaner, and impose fewer constraints on your generator. How Enhanced Generators Work Generators are functions in Python that make use of the or statements. We'll focus on because that's all we need. You can create a generator like this: 

You similarly have 3 values in a pipeline going perpindicular: [iy-1], [iy], and [iy+1]. Obviously is the same for both, but I don't think you can effectively cache your previous 512 values. (The CPU cache might store them, but you shouldn't try to cache them in your program.) Pointers? Because your computations are fairly straightforward, one thing you might consider doing is using pointers instead of array accesses. Again, this assumes that you refactor your loops to be in the right order. For example, you might try something like: 

Parameter Order The search function puts the first, then the details of the array to be searched. Why? Because the key isn't related to anything else in the parameter list, and it's the "important" thing in the search expression: Find me a needle! In this haystack, of such and such size. Use this comparator. I'd suggest you reorder your parameters to conform with this. Not only is it a more sensible arrangement, it keeps your search function consistent with the "standard" search function. That means less to learn, and less chance for a silly bug. Parameter Names 

Wrap your top-level code in a function There's a standard idiom for top-level code in Python. Use it! 

Edit: Based on your comments, you don't want lodash at all. You just want to sort an array by an arbitrary key. The key, in this case, is the order in which a value appears in another array of values provided by you. takes a comparison function as its argument. I'd suggest the following: 

(for some value of .) You are not using descriptive names for your functions. What does do? You are not using functions to organize your code. From about line 7 down to the definition of you have a bunch of code that is just executed in-line. That should be a function, or some such. Your logic is confused. Consider this code: 

Apparently, is actually the secret word the player is trying to guess. Which is fine, except the whole program is about words, and is plural - suggesting perhaps a list of words or a dictionary of words or a disk file containing more than one actual word! This variable is the most important piece of data in your program, and you named it wrong. Maybe instead? (Because is taken.) There are very few beginner programs that need comments. But there are often programs that need better variable or function names. Let your code speak for itself. K.I.S.S. Consider this: 

Apparently, your concern with really translates into a change in the values you pass to (or whatever you want to call it). BUT WAIT! Because I've looked at your code, I know that is really a translation of - the theta value of your robot's current posture. Just exactly as is a translation of two other elements of your robot's current posture! So why not just define a function that encodes these rules for you? Then you won't have to drag them up into this higher level code! Just write a group of functions that convert "relative" references into map references: 

Your module can define very simple functions, extracting just the lines from your current code. This code: 

(Sadly, there's no good way to spell except for .) For your explicit validation, you have totally bungled your code: 

See this article by Raymond Hettinger for more details. Don't hold open files you don't use You open files in that you don't use and don't close. Avoid this. Instead, open/read/close or open/write/close them when you actually need to. The open operations are cheap compared to writing or reading from a file, and file handles are a scarce resource. Also, doing your open/read or open/write at the same time allows you to use the preferred Python idiom, , for your file I/O: 

Once you have a step, you can display the narrative text, and then present the user with a collection of options to choose from. Because users are users, there probably needs to be an inner loop that keeps asking for a valid option until one is entered. I would make a function for that: 

It's a good idea to separate your private data from your source code, especially since you might be tempted to put your source up on a code-sharing site like bitbucket or github. This way you won't "forget" to scrub out the secrets when you post an update at 3am one night... You can set your api key during your initial startup: 

that's much clearer. And already has a fine set of dundermethods for comparisons. Finally, consider your implementation of the parsing. You write: 

How many times did you reference in your entire code? I counted one - the line shown above. So why use an aliasing import? Why not just set ? This is a personal-coding-style issue: in a program that might have 10 or 15 import statements, are you going to use aliasing or spell out the name of the providing module? As a reader, I want to see the name of the module for names that don't get frequently used. (Obviously, if you have to type 50 times, by all means alias it! But if it's only once or twice, please give me the module name in-line.) Next, consider your doc comment: Initialize this queue and enqueue the given items, if any. This is misleading, because you only allow one optional parameter - an iterable. Please make this explicit in your comment. Consider this documentation for Python's built-in and : 

And if it matters, you should be intersecting your with the set of inputs () to make sure you're not carrying any extra baggage... 

Ignoring the whole "it doesn't work" thing, this solution is vulnerable to all sorts of programmer errors, and it is not at all obvious what you're doing. A far better test for "done" would be simple equality: is A equal to B? It turns out that Python implements list equality correctly. You can simply say, 

The only tricky part will be finding the fractional-block numbers, since you can't just add 5 to 33. This leaves us with two cases: the cases where K is a multiple of the block size, and cases where there is a remainder. If K is a multiple of the block size, then the result is simply 

Count the number of times appears in the code. (Two times.) Now count the number of times appears in the code. (Three times!) Whose method is this? Your code is violating the principle of encapsulation. You are "operating on the hero" instead of "interacting with the hero." There is another maxim of OO programming: "Tell, don't ask!" Instead of asking for properties and asking for and reducing the hero's hit points, just tell the hero you hit her, and tell her how much damage to take: 

Given that the player data is a function of the turn number, there's no reason to pass the player data into the function. Instead, defer the computation of player data as long as possible. Just pass the turn number and board into the function: 

With that in mind, what happens if you think of your program as operating against a single object - the register file - instead of operating with a collection of and objects? 

The same is true for the filtering of : you are looping over all rows, and then for each row you are looping over all rows again. This is operations, or O(n²). There is no simple way to fix this. If you insist on computing the distances from each point to its surrounding points, you will have to structure your code this way. However, there are some alternatives: 

You don't seem to have a policy for a maximum pool side. Is that by mistake or by design? What should happen if someone requests an object too many? Your choice of method names is slightly off. When I talk to an object pool, I don't want to Loan it an object, nor do I want to Receive an object. I want to "borrow," "obtain," "take" or "get" an object from the pool, and I want to "return" or "release" or "put" an object back into the pool. I'd suggest: 

You might find that many dungeon creation tasks are made easier by defining iterators. For example, if you want to randomly generate rooms and hallways you could define and . (Be consistent on how you handle the end position: inclusive or exclusive!) 

In your loop, you are setting the status from the event loop, but that won't affect anything until the entire loop is completed. I'd suggest moving that code down to the bottom of the loop. Your code calls this line: 

This is an example of a situation where good naming is your friend. Instead of parameters and , and magic numbers and , and the rather long-winded expression , I suggest you start by installing some useful names: 

Here's a link to a useful blog post. So let's see... if the cell state at some location is not the map border, then change the cell state to and print some kind of debug output and . (Seriously? What is ? Did you mean ?) I'm going to ignore the fact that you're skipping over a check for another obstacle, because I can't read your code. It might make sense to do that. But each of those blocks - which are so long, and so "common" that you deliberately folded them up onto a single line - is really the same code over and over again. And in the 1970's they had a mechanism for that: functions. So why not write a function to handle all that code for you? 

If you do that, you can eliminate that entire call, and just retrieve the values. Yes, you pay an up-front cost of 27000 extra function calls, but it beats doing it in your find loop. (If you can't pay that cost, you could certainly do it as a separate loop at the front of your find function. You're going to do it anyway, and this lets you store the result.) Also of note: and . You can certainly compute the cosine of once at the top of the function. And if you're going to call this function a lot, it's probably worth storing the cosine(y) for all the points in the initializer. Heuristics, anyone? Another suggestion is simply to guess what's a neighbor and what's not. You've got a nice calculation there, with lots of trigonometry. But keep in mind what it's doing: it's trying to compute distance on a sphere, which is basically distance along a circle. The key word is circle. At θ = 45°, cosθ is √2/2 as is sinθ. The sum of the two is √2, which is the maximum sum for a circle of radius 1. Thus, you know that for whatever distance N defines your neighborhood, the sum of cosine and sine will be less than or equal to √2 * N. If your points are widely separated - that is, if you're dealing with cities and not the entrances to buildings in the same town - you can implement a heuristic: change √2 into 2.5 to allow for spherical error, and compute the corners of a "square" centered at with sides 2 * 2.5 * N. Then just compare pt.x and pt.y with the min/max x and y of this square. Only if the point is inside the square do you perform the "expensive" computations. This adds a set of 4 comparisons to your loop, but eliminates the trig calls for all the non-matching candidates. Hopefully, that's most of the points. This is important! If your points are heavily clustered, there's no sense having a heuristic to guess if one point is a neighbor of another - because you know the answer is yes! In that case, it would make more sense to develop a reverse heuristic, that says "here's a square contained in the circle. If the point is inside this square you know it's a neighbor, otherwise do the computation." The objective with heuristics it to produce a fast computation that handles 75% or more of cases. If your data is biased, make the heuristic align with the biases! Finally, another simple optimization would be to take your value and divide it by the various factors you are presently using to multiply. This can be done outside the loop, once, and saves you some cycles. Larger-scale changes First, don't forget that if A is a neighbor of B, then B is a neighbor of A. Make sure you are only looping over the "higher" values in your N-squared neighbor search: 

You can take this farther, but the idea is to produce a single source of truth that you can stare at REALLY HARD to confirm it is correct, and then have everything else look basically the same. This doesn't apply to the pointer scenario, obviously. But in that case you will probably want to define a macro for the loop body, so you can repeat it easily. Assembly Your compiler has a command-line switch that will produce assembly code as output. It might be (gcc) or (msvc), but it's there. Use it! If you're not going to enable optimization, then you are going to have to measure the effects for yourself. One good way to do that is to look at the generated assembly and see what result a particular change produces. Honestly, this is difficult. But if you focus yourself down to a small section of the code - the innermost loop - you can generally figure out what is going on. And for the most part, shorter is better. Optimization You don't say why optimization options are not available to you. Unless this is for some class assignment, I'd encourage you to try enabling optimization anyway. One thing you might do is split your code. Move this one function into a separate source file, and get it to compile and run okay. Then start building your project however you usually do, but configure this one separate file to use a higher optimization level. That might get you around whatever blockage (technical or political) you are encountering. Of course, good unit tests are essential for this. 

you have a loop nested inside another loop, specifically to handle the case where your month counter rolls over. Why don't you just reset your counter to the top, and handle the code in your main loop? I promise, it's possible. Of course, you might not be aware of this, but the C++ operator (modulo, or remainder-after-division) is perfect for use in this scenario. Next, this code doesn't do what you think it does: 

Note that unlike C enums, your declarations define some values of , but in Go they are not considered to exhaustively define all valid values of . Also, the values are integer constants - why are you passing around pointers to them? You might consider a statement: 

You wrote two answercheck functions, but you always use an statement to determine which function to call. Put that logic into a single answercheck function: 

You could use a kd-tree or a space partitioning hash of your own design to access your points. This would make pandas secondary in your access, requiring you to write more python code yourself. You could take advantage of some other heuristic to determine proximity, and use this to filter your data before running your n² algorithm on it: note that 3² + 3² = 18, while (3 + 3)² = 36. Breaking your data down into smaller units can have a substantial impact on your performance. For example: in the United States, zip codes within a given state all start with a few identical 2 digit prefixes. You might build a dictionary of "adjoining" states, by hand, and then pre-filter your locations using a zip-code prefix, such that you only consider other points that have the same 2-digit prefixes, or the 2-digit prefixes of an adjacent state. If your locations were US cities, this would let you eliminate more than 90% of your data before you start your n² algorithm. There are surely some other approaches, which will tend to vary based on your application. Perhaps if you mention what problem you are trying to solve, someone will have a suggestion.