Note that gives you a dangling pointer so you should try to avoid that construct. Prefer s. Don't Typedef Meaningless Types When you introduces types like: 

But instead you set a global variable. That makes it hard to understand. Also, your most important helper function has this signature: 

Don't Repeat Yourself Your looping code appears twice. Once in the body of and once in the body of . You only need it once. In fact, the entire structure of is kind of weird and unnecessary. I also don't like how you named the function , made it , and have it take a reference... Instead, let's write a free function: 

I also question the name . That seems to suggest that this is a container more along the lines of , but really you're talking about the norm of the vector. So a better name, please. Use range-based for Whenever you loop in a way that doesn't actually involve the index, prefer to use range-based for. It's just easier to write. For instance, your : 

I'm working on some precompilation operations for a world compiler. Currently to identify flags placed by the level designer I need recognize when a specific entity exists at specific coordinates from the flag's origin. I need to generate a list of offset coordinates from the origin(and include the origin) in string form. That is 7 coordinates. this operation is done for every flag in the world, so it is preferred to be efficient. It is not an operation that takes place during gameplay, so I don't have to worry too much. My current implementation works correctly, and quickly, however I still would like to get a review on what I have written, and hear any advice to better this operation. 

Separate your main-loop logic from your main menu rendering logic. You should have a main-loop, which calls recalculate, and draw, then in your draw you should draw the appropriate menu, based on the games current state, the logic should stay in its own class away from the main-loop. 

However, now that you have actual code to review, I will also point out that there is no reason to be using a loop vs a loop. I would write that as follows. 

isn't a good name for that variable. Perhaps ? Consider something like as the return type to more clearly indicate failure. Don't write expressions comparing to booleans: 

This simplifies your algorithm drastically. Now instead of keeping two lists, we just have to keep one: 

Pointer to pair? Similarly, for , take a vector of pairs - not a vector of pointers to pairs - and by reference to const: 

And similarly for . For , writing is an antipattern. It should just be . Also, comparison should be : 

Going from to is a little more awkward than going from to , so let's just subtract 1 from everywhere: 

This is bad. could fail - and you'd expect it to fail when the input runs out. But you're not checking the result of , so you end up writing an extra string onto your vector. The correct approach would be: 

Taking variables by . There's simply no reason for it. Take them by value. Taking by is good practice to avoid unnecessary copies of large objects, but is not a large object. In fact, it's smaller than the size of the pointer you're having to pass. Copying. Let the compiler write the copy/move constructor/assignment for you. You're just doing what it would do anyway. Save the code. Not to mention that the self-assignment check is an unnecessary branch. Self-assignment isn't unsafe here. The boolean anti-pattern. You have this code in your equality comparison: 

I just wrote this short little program to increment up the build number for my projects every time I build them. After compiling this exe, I just call it in the pre-build command line. I did take out the filename string because I used it thrice, and I figured I'd get some flack if I didn't. 

Over all, your program could look like this. Note: I didn't programatically address the issue of the user escaping your program, I noticed you updated your OP with that. 

use iterator instead of , I also took the liberty to use ternary operators instead of giant if-else bocks. 

Now the succeeded value is available after the method returns, and will only be true if all values past the test, and now there is no nasty exception throwing, which hurts your application's performance and is just bad practice. You can call the method like this now. WITHOUT a try..catch surrounding it 

Review I don't know if this is something you should implement, because I don't know how you intend to use this class. In C# you can place access modifiers on the individual parts of the getters and setters. A way you can use this (again, not sure if you need to, but this is isncase you do): 

Note that a string in python is also an iterable, you don't have to make it a list of strings. Also your in your loop does nothing - and the loop itself is just a very verbose copy. Just the suffices. Your outer loop Your logic looks like: 

That'll also future proof anything else you add into these loops. What if you added logging? You'd have to go back and add braces then anyway. It's a good habit to get into. Always braces. 

But you don't or , etc. You should add another function like or that will every node in the list. inserting should - but just the one node that you're inserting, you don't need the top-level there either. Since we're assuming that the list is non-empty, your logic would be better if you split up the insertion part from the looking-for-the-end part. Also there is no reason to take the value by pointer: 

Just going to address the code, not the algorithm, as an optimal solution to this problem ends up being pretty boring but the brute force solution gives me something to talk about. C++ is not C You're using and . While those work, you should prefer to use and . 

A good alternative to your current implementaiton would have been to create a recursive function which takes in , and the method would simply loop over the remainingNumbers and making new composites to check on, each time you would want to check just the currentComposite to see if that is a valid set. The way I would do it, would be to create a list of number arrays which hold every combination of the given numbers, then I would simply loop over that collection to determine which sets fit my conditions. Here is some code I found online (specifically here), because I did not want to make my own Combination generator. I'm going to post this code on CR, because I'd like to see someone take a stab at making it better. 

Some people prefer that, I just am not, and that is up to every coder to decide. If I was to put brackets arround that, I would probably do it this way 

Point of affirmation, this is indeed a good binary search. finding halfway between your highest and lowest values will get you to the answer on average the quickest. 

That actually implements . It'd be pretty surprising to users if they did and found out that had changed too! Also there's no reason to restrict the input to non-const references. This should become: 

There's no reason for this to be a lambda. It's actually quite a bit shorter if you just write it as a function: 

BUG Your program gives the wrong answer, yielding 53 instead of 55. The reason for this is you over-eagerly exclude rotations in if anything ends in an even digit or . But and are prime, yet end in a digit that you exclude! It turns out that the exclusion check (in addition to giving you the wrong answer) doesn't actually help you anyway. Timing your function run ten times: 

This does all the same thing that you're doing, but once you split it up, there's less logic to have to reason about. You can even move into directly: 

It's still linear time, but I end up doing FAR less work than you have to, since most of the time I'm doing almost nothing. And the numbers show it: