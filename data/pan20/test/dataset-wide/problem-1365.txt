In the loop where the calculation is done the deletion of the zero element is costing too much time. Rather than erasing the zero element in each loop just index through the vector. 

Improve Performance Since the code is using a C++ container class, it might be possible to use iterators to improve performance. Once the code is broken up into functions and compiled -O3 it can be profiled to find where any bottlenecks exist. 

Generally it is better to assume that code will need to edited at some time in the future to add features or fix bugs. Prefer return() over exit() In the case of this program since there is no error checking there is no reason to use either or . If there is error handling in the program, the function should only be used if the program encounters an error it can't correct deep in multiple function calls. The function should only be used in stand alone programs, never in operating systems code. When using the exit() function, use the macros EXIT_SUCCESS and EXIT_FAILURE that are defined in stdlib.h. Don't Repeat Yourself When code is repeating itself, it is better to write another function rather than repeating the code. Then the code only needs to be written and debugged once rather than multiple times. This is know as the DRY principlein software engineering. Example: The following code has loops that repeats that 

Slow Compiling Two possible reasons, one is that the macros are hiding the fact that there is at least another 160 lines of code in the header file, and you may have independently rediscovered why Microsoft C++ and especially MFC have pre compiled headers. The compiler has to do a lot of work and substitution for template. You may want to allow the user to use the templates in the C++ source files for only the types they actually need rather than including the macro usage in the header file. 

The DRY Programming Principle Ask your teacher if he was referring to the DRY programming principle. In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of information of all kinds, especially useful in multi-tier architectures. This code repeats almost exactly 6 times: 

Consider following the Single Responsibility Principal and break the function up into smaller functions that do less. Note: This answer makes use of the loopEvos() that is provided in the updated version of the source files on GitHub. 

It is more efficient than using input[inputIndex]; Use Symbolic Constants Rather Than Numbers In C you can define symbolic constants using the pre-processor directive. 

The Good The choice of variable and function names is very descriptive. The code is properly indented but. The consistent use of camelCode is excellent. MAGIC NUMBERS The term Magic Numbers refers to numerical constants in the code. A good programing practice is to used named constants rather than numbers. Named constants make the code more self documenting, and allow easier modification of the code. When a named constant is used the code only needs to be changed in one location rather than multiple locations. An example of this in the code would be to increase or decrease the size of the arrays. Example Named Constants: 

Always Test the Value Returned From Malloc The memory allocation functions such as and may fail for a number of reasons, such as there is no memory to allocate or there is no block of memory large enough to allocate. When these memory functions fail they return NULL. After every call to always check the pointer receiving the memory address to see if returned NULL. This prevents accessing a memory address through a NULL pointer. Example of a possible correct way: 

Memory Leaks This program has a memory leaks. There should be a for every memory allocation, the variable gets gets freed once at the end of the program, this is the wrong place to call free on . Word should be freed whenever a Node is freed as root->lines is freed. Use the Library Functions The function isn't really necessary, the function can be replaced by , especially since already calls . Program Return Values The program already includes probably for , and . Since stdlib.h is already included it might be better to use and rather than in and in other functions. The Use of exit() There are two functions that use after memory allocation errors. This causes the program to exit without closing the input and output files. It would be better to have some way to return an error code from and and then closing the input file and output file before the program quits, even better if was called before the program exited. Not as Fast as You Think While the binary tree does allow a fast implementation, all the reallocation of memory can slow the program down. Every time , and are used the program is swapped out for a system call. 

You worry about violating DRY, but you've violated a C standard, macros should always be all capitals. While I don't recommend it, the fastest code would be to avoid the use of functions totally and just have the macros. Inline code should always be faster than functions, although on modern computers this is less of an issue. The function can be a macro or just inline 

If anyone has any thoughts on why the compiler generates errors that say my class object is undefined I would appreciate it. It may be because you don't have constructors for Player and board. If you want the compiler to generate the constructors and destructors you can add the following lines to your class definitions: board.h 

You have a number of functions where the closing is down one or more lines, and then you have functions where the closing immediately follows the last line of code. Pick one method and stick with it. Programming Principles that Apply You have done a pretty good job of this already, and you may be aware of some or all of these programming principles. Here are a few good programming principles that apply: Single Responsibility Principle: The single responsibility principle (SRP) states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. Demeters's Law: The Law of Demeter (LoD) or principle of least knowledge is a design guideline for developing software, particularly object-oriented programs. In its general form, the LoD is a specific case of loose coupling. The guideline was proposed at Northeastern University towards the end of 1987, and can be succinctly summarized in each of the following ways: 

Each of your global variables could be private to the class. Global variables are bad because they impact the namespace of all the modules that share this code. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The KIS(S) principle is simply stated as and is used in all forms of engineering. 

As noted by @yuri above, the warning message indicates that there are paths through that don't return values, this actually indicates there can be bugs in the function. Magic Numbers The code already has a few symbolic constants, but closely examining the code shows that there are still some numeric constants that should be converted to symbolic constants: 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. 

Doing so makes the logic of copy_max() clearer. I'm fairly sure that you can calculate index only once. I'm not sure why it's being calculated in 3 different places in copy_max(). The title is miss leading as well, since this will copy more than just characters. 

For the following keep in mind that is a compile time expression for the following cases. The following suggestions might make the code more portable between different devices. It might be better to express ALIGN as sizeof(long long) rather than putting that in the comment 

Don't Assume the Buffer has the Necesary Capacity There is a possible critical error in the following code: 

This could be a cut and paste error while creating the question. The program will not link of DEBUG is not defined. The code either needs 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and stackoverflow question. Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility.