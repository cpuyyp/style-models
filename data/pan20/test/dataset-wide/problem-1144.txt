Recently I have also done this process with Postgresql.But I didn't use any third party tools. Here is my process. 

Its good to see that you are working with Alwayson. Here are the answers for your questions: Do I need the same config for all the nodes? Unfortunately its YES, becuase alwayson is helping us to make the business always up. Once the Primary goes down, then Alwayson will failover to another node and make that as the new primary. So it must be have the same config to get the same performance here. Luckily this is the only case you must have same config. If you are using Availability group for Readonly purpose then make the reader with less config. Alwayson is for DR? NO, Human errors are also considered as DR. In this case if someone deleted a table, then this statement should immediatly replicated to Seconday. So there is no delyed replica here. Multiple Availability Groups? I didn't understand this question, but as per my understanding, You can have more than one availability Group, but you can't add one database to multiple availability Group. 

Not sure about general log, but this behavior belongs to auditing system. If you don't insist to write into binlog, both Oracle and Percona offer solutions: 

If you feel it's a hack, try PXC (Percona XtraDB Cluster). PXC uses Galera Cluster (by Codership), which is synchronous replication with InnoDB. 

This will reduce production downtime to minimal. I have done this on a 100GB table before (but without Foreign Keys) and it worked very well. 

You just need to optimize for InnoDB environment. is still the key for performance. And beacuse your slave server is weak than master, you might need to deal with replication lag. (i.e. Write to master, but cannot read data from slave immediately) 

Basically, ibdata1 contains the tables and ib_logfiles are having . So the important thing is to being your ibdata1 first, the only way use any recovery software, or if you have MySQLdump then restore it. 

I want to map Linux's root user to Postgres user, like if I enter psql in root user it should go the PostgreSQL cli without asking any authentication. I tried to add an entry in pg_ident.conf and make the necessary changes in pg_hba.conf, but it didn't work. 

It is difficult to say why MySQL Optimizer is choosing a different join order for 5.7 without seeing the optimizer trace for the query. However, you can force the same join order as 5.5 by using STRAIGHT_JOIN instead of INNER JOIN. That will tell MySQL to process the tables in the order they are listed. 

If overlaps are only partial, (i.e., a range may partially overlap another, but no range is a subset of another range), I think the following query will do what you want: 

Create a read replica. Export the data from Read Replica as CSV format. Create the tables with appropriate column names. Then import CSV files to tables. Make shell script to automate this. 

I want to setup 2 node master-master replication. Im aware of the point of failiures in this replication. Its a huge database around 1.5TB. Heavy OLTP is going on. But its mandatory to implement right now. I have 2 servers. 

Any suggestions to achieve this? I need to map multiple Linux users. The above one is for who all are using root user. 

Yes, you should shutdown down the slave parts (including web & database servers). However, you can use GeoDNS + health check to redirect all users to the master site to avoid this issue you mentioned (I guess you have done this already). This should be a reasonable solution for business. 

So in SQL92's definition of , it must preclude P1, P2, and support for atomicity, no update lost. A5B (Write Skew) On the other side, A5B (Write Skew) is defined in A Critique of ANSI SQL Isolation Levels: 

I do not think it will be worthwhile to change the type. You may save a byte or two for the length field of each column value if using TEXT or MEDIUMTEXT, but that will be insignificant compared to the size of your data. VARCHAR and TEXT columns are handled the same way in InnoDB, so there is no reason to switch to VARCHAR either. 

Join ordering is left to right. That is, in the above example a nested-loop join is performed by a full table scan of CUSTOMER followed by index look-ups into ORDERS and LINEITEM. (The meaning of ALL and ref are defined in the user manual for traditional EXPLAIN.) Note that Visual EXPLAIN is significantly updated in MySQL Workbench 6.1 including more descriptive text for the table operations. 

If your table is InnoDB format, then try pt-online-schema-change (from Percona Toolkit), for example: 

Is preclude A5B (Write Skew) ? In the later paper, it claims will preclude A5B (Write Skew) in Table 4. Isolation Types Characterized by Possible Anomalies Allowed., and I am not conviced. Any thought? 

You need enough disk space in . Once you finish it, you can copy entire directory to another server. In , there is replication information. (it is useful if you need to setup slave replication) 

Please never mind, I found a solution on this blog. Still the mysql data directory points to $URL$ Then did chmod 700 binlog. 

Basically we don't need any Postgresql server to take the backup. Postgresql client is enough for this. But you must have sudo privilege to install this client. For Ubuntu: 

Im using backup on secondary only.Even in few outages, I tried to use copy only full backups and log backups to recover them. 

I have a PostgreSQL master/slave setup. Today I created a new slave from the existing slave (cascading replication). 

This design looks like that you stored log data into MySQL, and you want to do something analytic on it. I would suggest you to look at Cassandra (or ScyllaDB, a C++ re-written compatible solution to Cassandra) + Presto, they are all open source softwares, and they can process your SQL query parallelly and effectively. Especially because Presto's SQL language is very similiar to MySQL (because it's developed by Facebook in the beginning), it should be very easy to learn. Anyway, if you must use InnoDB, there are serveral optimizations you should do for this SQL query: 

Then you can use this view instead of the table in the query above. (And life would have been a bit simpler if you had picked some other value than NULL for the default district_id). 

Since MySQL 5.6, MySQL may automatically convert IN-subqueries into a JOIN query. This is called semi-join transformation. By converting the subquery to a join, the MySQL optimizer may be able to process the tables in a different order than for traditional subquery execution. For your query, the amount of data that need to be accessed, will be much less if the tables of the subquery is processed first. However, as described in the manual, semi-join transformation will not be done if subquery contains UNION. In your case, it seems straight-forward to avoid the union so that semi-join transformation can be done. AFAICT, this query should be equivalent to yours: