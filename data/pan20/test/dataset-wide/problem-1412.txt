Naming , to me, would mean that it is a class that generates a . But the way you use it, is itself, a Dungeon. I would drop the "Generator" part of the name, or refactor it so it is in-fact a dungeon generator. Additionally you have a namespace and a class within that namespace. I would avoid having a class the same name as its containing namespace. Otherwise you need to write confusing things like: 

Then, the datagroup collection is filtered using and . On really big array, this can be really expensive as javascript is quite slow. Instead, we can let mongodb do this operation with a simple query using : 

All errors (type error, required flag missing ect...) are handle directly by the library Now the complexity of the function is 3 

I'll go for the second method as there is a simple way to handle all connection in the main goroutine: instead of , let's handle incoming connection synchronously. There's no need for channels here, we can rewrite it like this: 

This keeps your database layer separate from your data layer and separate from your presentation layer. The more separation you can do here, the better off you are going to be when it comes to updating and maintaining this code. I would recommend a good read through SOLID principles to get an idea. 

Now let's suppose we want to validate this class, but we need to support quite a few types. We don't want to have to modify the validation logic each time we add a new type, so lets create a validation attribute: 

Work on []byte rather than on string This is a general advice regarding performances: always prefer working on instead of working on to avoid extra allocations. The regex package has methods to work on string or on byte slice, so instead of 

from now, we can check that we don't break anything when modifying the code. We can also accurately measure the performance gain... 3. Results We can see a clear performance improvement with the new code: old code: 

You are saying its a "tax id scan copy" but then you are loading a "photo" and displaying it as an avatar. What is the difference between and ? I'm assuming one is a physical file path and the other is a web URL. If that is the case, I would suffix the first with , otherwise a casual observer would expect it to return the binary image data. 

So what is happening here is you know that for every open bracket there must be a close, so if we count all the opens, and subtract all the closes, that resulting number must equal zero. 

Your program works fine and you are correctly using goroutines, but the code isn't very idiomatic. Producer/Consumer architecture What we have here is a typical producer/consumer scenario. The producer is wich returns a list of files, and the consumers are goroutines executing on file content. So instead of the method, we could just have a : the producer sends file names to the channel, and the consumers loop over it and parse the file content. This have two main advantages: 

Avoid Mutable Properties Your has a few externally mutable properties that I don't see a reason for them to be mutable. It would be better if these weren't mutable: 

It is now functionally the same but has less code to maintain. Nullable properties can also be defined shorthand: 

I would advise to not have a list of "variables used" in your program. They really don't serve any purpose (pretty sure you can figure out when reading the code that writes to a file, etc). This only serves to add complexity to your code documentation. The problem is that if you change your variable name in your method, then you have to find it in there and change it too. Some automated renaming tools are good at renaming variables, but don't (usually) find it in documentation unless it follows a specific format (like Xmldoc). The other thing that I see is that you have a lot of "thinking" in the code in the form of comments: 

Concurrency Maps are not safe for concurrent use, for more details see map documentation Here you're modifing the map from multiple goroutines, so two solutiions to fix this: 

2. Make sure that arguments are valid if is <= 0, the program will panic. A little check after could prevent this: 

It's easier and nicer to read 2. Use range loop instead of switch Instead of specifiying behavior for 3 cases ( 0, 1, default), we can use a simple range loop So this 

But since we are learning about abstraction/inheritance I'll leave it as a class. Now lets tackle the implementations, I'll do two of them here, you can figure out the rest: 

This shows the power of inheritance a little better. MSDN also has a good example using shapes as well that you may want to read. The take-away here are these points: 

You seem to be very much over-complicating this. Here is an efficient solution: Assuming and are positive numbers and the result is a valid 32-bit integer value 

It's also better to use the package to parse arguments instead of relying on Here is the final version of the code: 

Don't use a to get the number set, because iteration order is not garanteed from one iteration to the next (see go maps in action for details) This can be a problem if some value have the same weight: the order of randomly change from a run to another. Intead, use two slice of A new version of the could could look like this: 

The first thing I would say is that the API is not well-defined. The upstream code should be calling the specific method. The fact that you call a single method based on multiple names is fragile. It seems like you are trying to stick an entire API into a single method. It would be much better if you exposed one method per "childCollection", for example: 

Now the user of your class can decide to do something else with it, such as write it to a file, send it over the network, print it on a webpage, etc. The user is no longer tied to the console.