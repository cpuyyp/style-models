if TableName == NULL then "0" is returned if TableName !==Null then TableName is returned You could rewrite the ternary expression as 

to the offending SP to force just that SP to use the prior CE. The SP should now perform in Compatibility Level 120 as it did with Compatibility Level 110. <-- I prefer this approach as your Database/System gains all of the other advantages of SQL 2014 while the "fix" only impacts the offending SP. Irrespective of the approach I would then profile the execution plan/read/writes etc of the offending SP on a test system in SQL Server 2014 Compatibility Level 120 and rewrite the SP to cater for the new CE. Once tested and verified I would then apply to production. Microsoft have a good article on the Cardinality Estimator changes in SQL 2014 

Create a SQL Server Account and use those credentials to connect to the SQL Server <-- this might be the easiest Trust the domain in which your GIS Programme is running <--I would be loath to do this 

Allowing even trusted users to login to what appears to be a production database is in my mind a big no-no. The solutions you mention above may provide you with a sense of security/relief but they their own have side effects. I would be particularly worried about your statement 

A commit is a user initiated action that tells the database (Oracle in this case) that the transaction is completed and that the changes may be committed and any locks/resources released. Normally the changes are committed to in memory data buffers and to the redo log buffer. A checkpoint though is a database initiated action that writes all of the data to the actual physical disk file based on the changes recorded in the redo log buffer. Some good articles can be found here and here. 

SQL Trace (what Profiler is built on) will capture all instances of any events that you decide to collect. So if you collect RPC:Completed events, you'll get an event for every RPC completed, trace will be capturing that event. If you don't select that event, trace won't be grabbing it. So it will only capture what it is told to. You can (and should) then further filter the data returned by adding filters on various columns (say a database name or a duration for a completed event to capture only events with a duration of greater than a certain value, for example). In that case, all of the instances of that event are still captured, but the filter is then applied before the information is dumped to the mechanism you are using to trace. See the difference? If you don't select the event, that event isn't captured or sent (Emitted as you are saying, if I comprehend you correctly), but if you do select the event - all instances are captured but only those that pass the filter criteria are sent (emitted). I would also argue against using profiler but consider doing a Server Side trace to a file. Look at this blog post from Jonathan Kehayias to show the difference in performance impact between the methods. 

There is an excellent resource here that talks about some of the dangers of plan cache pollution and some things you can do. I'd recommend a read here. It is written for SQL Server 2012, but the concepts and solutions apply. 

The issue is that you are running your GIS programme from a domain that is not trusted by the domain in which SQL Server resides. That are numerous methods you can use to correct this. You should discuss with your network admin/sql server admin as to the best approach. 

When the SQL is run the SP is created and stored in SQL Server. Once the SP is created the Grant execute statement is executed. When the SP is executed only the contents of the SP are run. The Grant execute statement is NOT stored with the SP in SQL Sever. This can be verified in a number of ways 

Once you have encrypted the data using an AES key the data is encrypted (the point of using AES). The only way to change the key would be to decrypt the data with the old AES key and then re-encrypt the data using a new ASE key. Some good MySQL AES documentation. 

Start at the YQL Console In the top left hand corner under Datatables ensure you tick the Show Community Tables In the search box type Finance. This should display all of the Finance tables (approx 31) In the "Your YQL Statement" window type your YQL statment. In order to get the average daily volume for Yahoo you could use the following YQL: 

By opening SQL Enterprise Manager, locating the database in which the SP resides and viewing the SP under Programmability. Use sp_helptext 'MySP' which will return SQL Servers stored version of the SP 

You can also do things like - figure out who has permissions. Honestly, as a DBA, when an object gets dropped there is a shared responsibility there. The person who did the drop, and the person who let the person who did the drop do the drop. When I'm on dad duty, and one of my kids does something a little silly that mom would never allow when on mom duty, we're both in trouble when mom comes home. They shouldn't have done that, but I shouldn't have been answering questions on DBA.SE and I should have been controlling their access to whatever mess they caused. It's sort of like that. So this is a good reminder about least privilege. 

Yes from that link it supports it. A Database Snapshot is a read only "frozen in time" (when the snapshot was taken) view of data. This is a tool useful in some recovery, reporting and rollback preparation scenarios. The isolation levels you are asking about are all covered by the line talking about Snapshot Isolation Level (Row-level Versioning). I would question what sort of workload you are putting against SQL Server Express that needs a snapshot isolation level as there are other restrictions on SQL Server Express that tend to make it not a great fit for busier, high concurrency apps (Most notably database size and memory restrictions) but this is certainly supported from that edition features matrix you linked. 

In general there two different ways to obtain an Identity value after performing an insert, using the SQL SERVER SCOPE_IDENTITY/IDENT_CURRENT/@@IDENTITY or SQL SERVER OUTPUT. 

The use of Save Transaction provides you with a mechanism for rolling back portions of a transaction. For example SP A starts a transaction which then calls SP B. At the start of SP B, a Save Transaction Start Processing could be created. If an error then occurs in SP B you could just rollback the change in the SP B allowing the changes in SP A to be committed. 

To Quiesce means to pause/alter an application/device to allow the application/device to achieve a consistent state. In terms of DB2 the Quiesce command should force all the users off the specified database and should flush all the buffers to disk (been a while since I've used DB2). While the database is a Quiesced mode there are users who can still access the database such as SYSADMIN and SYSMAINT. There are several DB2 functions that can be used to determine the status of a table such db2tbst and MON_GET_TABLESPACE_QUIESCER 

SQL SERVER SCOPE_IDENTITY/IDENT_CURRENT/@@IDENTITY. While SCOPE_IDENTITY/IDENT_CURRENT/@@IDENTITY perform similar functionality the values returned from each differs depending on the current scope such as a stored procedure, trigger, batch each. The documentation should be read and understood before determining which one to utilise. CREATE TABLE Test( TestID INT IDENTITY(1,1), TestName VARCHAR(20) NOT NULL ) INSERT TEST VALUES('Test1','Test2','Test3'); SELECT @@IDENTITY,SCOPE_IDENTIY(); In this example both @@IDENTITY,SCOPE_IDENTIY() will return 3 as they are in the same scope. Depending on scope though they may return different values. SQL SERVER Output allows you to access all of the rows returned from an INSERT/DELETE/UPDATE or Merge statement. You may need to use a variable to access the identity. The links provide more comprehensive information. 

What Do You Do if You Find The Table Empty? Again, I am pretty sure that an empty table here is an indication that you, or some monitoring tool or process you are running emptied the table. Or possibly that there was an issue with a portion of the installation. If you find this table empty, there should be a file in your directory called This file creates some system tables and populates them. If you search for you'll see the create and insert script for this table. The reelinsert script (in SQL Server 2012 RTM) looks like this: 

You can see more about the commands and options for backup here. There are many other options you should look into - such as verify, checksum, etc. A couple notes also - 1.) The is necessary the first time I execute this here since this mirrored set is not yet formatted/created. So the backup doesn't operate like a traditional backup in that regard - because you are effectively creating a new mirrored backup set. The link above will help explain that a bit more. And seeing you ask this does lead me to ask the question of "What is the goal?" - This is a feature for a reason and it may just be a requirement you have. But it could also be that you are trying to handle something that may be better handled in other ways. For instance backing up to a device with redundancies built in, backing up to a network drive, backing up to a SAN that has proper SAN replication in place, grabbing a copy of a backup right after you take it, etc.