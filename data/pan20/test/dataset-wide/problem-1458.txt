Really, your code is fine. Perl, like most languages, is not Forth and cannot have super-appropriate DSLs without runtime overhead. With that said, you have a state machine, and you hold its state in a single subroutine's lexical variables. This limits your ability to break out factors from your code. You're faced with these choices: 

This form of would allow you to cleanly switch back to returning errors instead throwing them with . 

For patterns as simple as these, I'd probably not bother to encode them in any special format. Just an array of lines is fine (unless you're programming under heavy memory constraints). These patterns can be set statically, loaded from somewhere or even generated dynamically. Choose what fits your circumstances best! E.g. loading from a file could allow for different patterns, allowing for customization. 

Design It's simplicity of usage is great. However, you have no way of enforcing that it will be used at all possible call sites (where appropriate).Another possibility that comes to mind would be to use the State pattern to provide access to the OpenGL functions in form of a member, with 2 states: One that records the OpenGL calls and one that simply forwards them. The call to then switches state from recording to forwarding, executing the recorded calls.Though also not foolproof, but which is harder to forget: "I have to use OpenGL calls in a lambda passed to this function." or "I have to use this member to get access to the OpenGL functions (as they aren't provided directly by default anyways)."? Example (rough outline, as I currently have no Qt install at hand): 

EDIT: I didn't even notice the protection against new instances of the Enum constructor. This seems to me to be an unlikely error... but this kind of protection is easily added with a check against a closed-over lexical variable: 

Accept some redundancy, as you do above. Pass state through the factors. Which isn't going to be pretty, but won't be as bad if you put all of your state into a hash and pass a hashref. Change the scope of your variables so that they're shared with any factors. The traditional reasons to oppose this design don't apply to this situation, as you're not recursively calling -- and don't apply to Perl, as any thread-shared state must be explicitly tagged as shared. Put your state in an object and break your factors off into methods of the object. This is basically #2, but might be cleaner in practice. 

Hopefully the class illustrates my point about classes being in charge of their own state, actions, etc. Lastly, about , I will also say that this class is weak, and overly transparent. My idea is that once a object is created, it will never change. Because of this, I think that should be defined this way: 

This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: 

These factors aren't useful. Although appears a second time in , that function only makes sense as a part of . Folding all of these into makes it more readable rather than less, and would increase repetition by one call if you don't also reconsider your loop logic. is especially poor: anyone reading that would have to find its definition to understand what it even means. Without changing your algorithm, but with a cleaner loop, and with some very minor style changes: 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: 

Algorithm allocates a new buffer of scratch memory for each recursive call. This means sorting an array has to use \$O(n \log n)\$ allocations total, with \$2 * n\$ peak memory usage. This is double the amount of memory usually required, and if s runtime complexity is worse than \$O(1)\$, the whole operation will perform worse than \$O(n \log n)\$. Also, every call to unnecessarily copies all of the elements of the previous buffer into the new ones. These copies can be completely skipped with appropriate management of the already existing buffers. The operation isn't stable, though it can trivially be made so by changing to . Stability is usually a major factor for choosing merge sort! Implementation 

My personal view in methods like this is that instead of making them setters/mutators, you turn them into actions/features. So instead of having a that takes a from a client component, I think it would be a bit more sensible to have something like: 

I'm not really sure, but somehow I feel like this can be an instance of a refused bequest, or some sort of breach of contract. I think you have few options here: 

Why should work? Is this a real, intended feature, or just something that fell out of your code? Why freeze everything? calls are easy to add to the following code, I just wonder what the point is. Do enums have a name for any reason other than to show up in their string representation? Again, easy to add back to the following if you really want it. Mainly, this strikes me as an incredible amount of work for what it does. 

Correctness can be destructed while another thread is performing an operation on it, because the destructor or its caller don't have to acquire a lock to do so. Technically destroying a mutex while it is locked already is undefined behavior, but it gets worse if another thread happens to modify the now invalid object. Same reasoning for the move constructor: The object from which will be moved could still be modified concurrently by another thread, so locking would be required. Also, rule of 3/5 violation: There's a custom move constructor (and there will hopefully be a corrected destructor), so copy constructor, move assignment operator and copy assignment operator should also be provided (currently, they copy without locking neither nor the other object). Also, should be marked , otherwise a can't be accessed. Other nitpicks