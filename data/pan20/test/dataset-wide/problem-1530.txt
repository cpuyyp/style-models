Concrete operator interfaces are decorated with an attribute that specifies its symbol for later usage in messages. 

You can do the same with the other loop. When using LINQ you might experience some performance hit but don't be discouraged from using it. Use LINQ first because it's easy to use and read. Only if you are not satisfied with its performance rewrite it with a normal loop. In most cases you won't even notice that LINQ is in action. Run a profiler if you're not sure. Don't blindly rewrite everything with loops because LINQ potentialiy could slow something down unless you really, really, really need to. 

is redundant everywhere and you are not using it consistently. For example only for properties and not for methods. But even for properties not always like here: 

I find this method is unecessary. You're better off with normal casting then with this and its overhead. The problem with is that 

This would create a package called with rebuilding the solution but not uploading it to the server yet 

The second enum is a list of color properties but you are allowed to use only one property at a time so your enum should not have a plural name. Let it be : 

Without the this seems to be faster in tests by just ~8ms for 100.000 loops and a string lenght of 1.000 

I would start by removing one of the branches and customize the loop to do the job according to the parameters because both loop are nearly identical. You can create two helper variables for the conditions and act appropriately: 

This isn't but rather . The argumetns have invalid values but they might be within the allowed range. 

If someone likes LINQ you can do it with one long chain of extensions and a coalesce operator at the end: 

Well, this is not particularly a bad idea (or maybe it is?) but it isn't a good one either. You make the models more complex just to save one or two properties. Those are just simple data models so leave them simple. An abstraction like the should have a purpose so you can use it for something meaningful like dependency injection but can you? No, you cannot. on its own does not mean anything and is completely useless - even as a raw data model. 

This is a good start. You created two functions to separate parts of the logic but there is more that can be refactored. The sub is too big and does too much. Let's try to improve. First the path shouldn't be hardcoded inside it so we pass it as parameter: 

Finally the clones the because it's not a good practice to overwrite the parameter. It performs the calculation on a copy. Here both loops start at the bottom right corner and the prevents the second loop from unnecessarily going over the zeros. 

Some more observations about the rest of the code: Be consistent, if you call the main class then don't name the other one just but 

The . It's a collection and for collections we usually just use a plural noun. In this case just would be enough. 

I'm sill experimenting with different design patterns for full integration tests for Console applications (and later also Windows Services) and I wasn't quite happy with the result of the refactoring of my last question. I've changed a few things and this is what I've come up this time. The main application code that starts an application is now divided into two files and that are classes of the (otherwise I needed a new name for the other file and this isn't actually necessary). The file contains only the method and redirects this call to the method that besides the parameter also takes a few other ones that I'm using for testing. It also contains other static methods necessary for the initialization. The file contains only instance code that runs the application. Having them both split allows me to better separate the two tasks. The new code: 

To use it, you call the with an anonymous delegate or you can pass a function that has the same signature as the delegate, this is 

With the hash code it doesn't seem to be O(1) anymore but all the keys are in one place an the logic is just a single method. LINQ wouldn't be faster anyway and it would mean a lot more work. 

I'd like to make the usage of my configuration framework easier so I created a few extensions that after getting a value from a source automatically assign it to a property or field. They should make retrieving and assigning setting values as convenient as possible. I'm not concerned about the performance as most of the assignments are one time operations when the application starts. 

I broke it down to extensions that now provide the additional es that add the to the message. So it's possible to use them with any . 

With a few changes you could create the queries dynamically. In order to do this you need to define an enum decorated with the and specify the column names as custom attributes: 

I think you'll know how to use it. Save notification as you do and later get only those where the property is null. DbContext 

Also by convention the parameter is usually named just . is the parameter you get from . async mistakes You're not using correctly and you did it exactly the wrong way around. 

You could use single loop and a buffer that you obfuscate and empty each time you find either a or . Then you can fix the line breaks and join the strings again: 

You use the same nested loops four times but you actually could use the one you wrote for the in the other three places for , and with or a simple . Another thing is that you shouldn't call it a list without implementing the list interface. A would be more appropriate. 

What you do is a simple inheritance that needs a few improvements. You should start by renaming the base class and the models. Classes are objects and should have noun names. How about ? The models don't need the suffix and their properties don't need to be prefixed with the model name e.g.: 

You should define a class for the results. It would help to explain all the magic indexes above and encapsulate some logic. It's extremely hard to follow in its current form. 

The extension works with enumerators. If it could not then it gets a new enumerator and tries again. If the second try failed then the collection is empty, otherwise it starts from the beginning. It uses a local function that handles the enumerator by resetting it if necessary. 

Getters & Setters + Validation I think it's better to validate the serial and the purchase-id in their setters instead in the method that actually could be a readonly-property. 

You can create another attribute to map these values as well and read all settings from the attributes. Also the magic numbers like or etc. The import method can be completely generic and the only place where you change the configuration are the attributes. 

I let a local function take care of the indexes. It returns if an index could be successfuly increased and if not, this means we're finished. The second part is quite small and just keeps this function running as long as necessary: 

What I don't understand and find a little bit strange is that you sometimes use the internal dictionary and another time the keyed-collection for dictionary APIs: 

I have this little class for parsing, comparing and sorting semantic versions. I did my best to implement the specification at semver.org with one exception - it doesn't support the build metadata. Now you can tear it apart ;-) I removed all parameter checks to make it shorter. 

(See also comments in code) GetRefNo Create case-insensitive dictionaries right away as you ignore the case later anyway: 

One of my data-import tools needs to support CSV files. I thought that parsing CSV is such a simple task that I didn't want to use any any external libraries for that. So here is one more RFC 4180 CSV parser. This one however works with two s. 

The last extension in this class allows to chain another expression and more validations. Here are some examples (the lines throwing exceptions are commented out): 

So I thought I create my own formatting and later a base exception to get a better result - at least one that is more pleasing my eyes ;-) 

The maintability of this line is horrible. Everything's nested in one long chain of calls. The streams should be disposed. Static APIs Every API in this class is static. Why do you need to create an instace of the reader at all? It can be used with the same result and complexity by calling the methods directly. 

so that you don't have to cast it. You also don't create a new so you don't need the constraint either. Maybe a different, maybe some interface but definitely not this one. But even if the generics were corrent I cannot find any line where you actaully use any property of being some interface or abstract class. An after all would probably be just fine. I think this will work too: 

You can rewrite the nested s and loops with a nice and short LINQ query that will give you all the items first: 

You have too many obvious comments here. There is no need to comment start as start ;-) One of them can even be replaced by a helper variable that makes the comment unnecessary. Meaningful variables are always better then comments. 

I'd say this is more secure as you work with an entity that really exists, in case someone tried to post an invalid . Less work becasue EF handles tracking and ataching the entity thus less error prone. 

This is an internal detail that could change at any time. You don't test it. You test the public contract that you usually must not change. 

Besides here I don't expect you to write a 100% bug free solution but rather create something that shows me that you know how to write good code. Code that can be improved and bug-fixed later easily. You could also ommit the implementation alltogether if you can provide a sensible API and explain what you would implement in each method. From a senior developer I expect he can write code so I don't want to see it. What I want to see is if he can think in abstractions, if he can design a modular and testable API, if he can properly separate concerns and if he knows more advanced techniques to accomplish such goals.