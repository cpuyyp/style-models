Based on the execution plan, and the data distribution, MySQL would decide to scan the table or one of the indexes to get the required data. If the data is to be read from an index, and the index is corrupted, it is possible that no data or wrong data is returned. Optimizing the table will rebuild the table and its indexes. So, if an index was corrupted, it will be fixed after the optimization. HTH 

The caveat here is that you have no control on which row will be returned from each set of rows that have the same values of "C" 

This way, you avoid dropping the old table before making sure the new table is there. This is good if you intend to keep booth DBs on the same server. 

If in your setup you have two or more servers, like master-master, or master-slave(s), I think it is better to do it offline, one server at a time. 

You can build this query in your code, and change the limits based on your needs. Note however that when the numbers in limit get big, there might be a performance hit there. 

While there is more than one way to do that (including the one you mentioned), if you can temporarily stop the traffic to the DB, I suggest this way: 

My recommendation is that you talk to your admin and work both as one team, not as two separate teams. HTH 

I am thinking of two things to try. If you get faster execution time, then the slowness would be related to the distribution of the data. If you still get slow execution time, it maybe then related to the server configs. 

My manager has asked me to work upon a request. I am not sure if it is reasonable or weird but he wants me to setup an alert based on the "waiting task" that we see in the activity monitor. Basically, if the value in the "waiting task" goes above 10 then we need to be alerted upon. I am not sure as to how I would replicate the same information that we see in Activity monitor as this seems to be live data. Closest DMV and the column I could think of is "waiting_tasks_count" in sys.dm_os_wait_stats. However, this does not seem to be in line with what he is looking for and the column consists of cumulative values over a period of time since last time SQL was restarted. Can someone shed some light on where I can find a query or a counter that I can alert upon? I have thought about a query at this time but I think I can't calculate the delta correctly it always shows me 1. Can someone help me out exactly where I am going wrong here. 

I've been working on this query handed to me by a developer who wanted to reduce the query execution time even further. Currently, it takes almost around 40 secs and outputs 262K records. Based on the actual execution the query cost is more towards the clustered index scan on "CacheClients". However, I am not sure if adding a non clustered covering index would benefit it. Also, I see a table scan at the extreme bottom right of the plan and as per the developer they were testing with an index on that table but they weren't able to figure out an appropriate one that can fit the criteria which is basically they would join on the id fields and run queries based on date period. 

Note: Increasing 's value may be helpful in your case. Edit To generate all the queries with the help of , run the following queries: 

Get the backup without routins. , and don't add -R is it is false by default Make a backup of routines only: Edit the backup file of the routine, and create the user in the new DB Restore the data backup file Restore the routines backup file. 

is better to be , unless you want to store the price in "cents". i.e. if the ticket price is $5.99. you either have to store it as and let the application process it when doing calculation, or viewing it; or, you store it in field is better to be an integer, and the user ID in the users table is better to be an integer Your primary key is good. Don't change it to . Maybe a flag field would be more clear to know which tickets are already used (This is personal preference) Depending on the queries you run against this table you may create the required indexes. 

One way to do it is to update and select in the same statement; and add a condition to the statement so that (if selected, don't select again) Here is my way: 

Notice: Depending on your version of MySQL, using to combine conditions could be a performance hit. It is not the case in 5.6 + 

You may use function with to choose what to take into consideration for each row. Here is my example: 

In short, it is sufficient. As far as the searched field is the first in a composite index (PK, unique, or regular index), no need for other separate index. However, you mentioned that you 

Based on the discussions that we had internally we initially decided to move with a SQL FCI for our non critical databases so that we would have hardware level redundancy. However, now the issue arises where in the project manager says that one of their azure VM's are in main campus and the other VM is in the DR site...so shared storage is not possible. Basically, as per him it would defeat the purpose of having them in separate locations on separate hardware..so he is overruling SQL FCI as an option. Now, the requirement is to have 2 SQL Servers with their own storage that we can fail over in an emergency or for maintenance. My question at this point is why we can't have a shared storage between 2 different sites? Also is it feasible and recommended to have more than 30+ databases into AlwaysOn in case if we want to explore that route. Is there any other option if not that. 

1/1/1997 – 1/31/2997 2/1/1997 – 2/28/1997 3/1/1997 – 3/31/1997 …. 1/1/1998 – 1/31/1998 2/1/1988 – 2/28/1998 … Through 9/30/2017 

All, I would like to know what path should I chose in order to achieve MCSE for SQL 2016. I already completed MCSA certification for SQL 2012/2014 and would like to upgrade it to MCSE SQL 2016/2017. Kindly, let me know what is the best approach for this. Is there any direct path or do I need to take n number of exams to get that certification. Also, would like to know what resources or links you'll can share that can help me possibly get through to that certification...most likely in first attempt. I only would choose one exam but it should be more focused towards honing my existing DBA skills. $URL$ Thanks 

I assume you have an auto increment primary key Add the source server, the MySQL one, as a linked server in SQL Server. Then, add a job that runs every x minutes, and does the following: 

To answer your first question: In the first query, some records are filtered out AFTER getting the result of the left join. These rows are the ones that meet this condition: On the other hand, in the second query, ALL result rows with "card.package_id =14" are returned regardless of the value of Example: 

Your query will get the max value of with ANY combination of the other fields from the rows that satisfies your condition. A better way to do that: 

The master writes to its "binary log" files The slave reads its master's binary files and write them to its "relay log" files The slave executes the statements in its "relay log" files. 

The clause after is the condition which is if met, the row will be returned with the result set. In your example, the condition is always met, so the result is the Cartesian product of the joined tables. This is similar to saying , which is always true. You will get the same result if you don't add the condition with the inner join. 

Group by both user IDs Inner join to the users' table two times, use different alias to join it with different user id 

You cannot use clause in an statement. However, you may use if in your targer table you define nUserId or vEmail as unique keys. More info about INSERT syntax: $URL$