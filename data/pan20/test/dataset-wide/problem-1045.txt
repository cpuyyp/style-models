A way to resolve this would be to put the joining of things with tags into separate tables. You would have your original tables users, posts, meta-tags and perhaps items. In addition, you would have user-tags, post-tags, and perhaps item-tags. The later three tables would only have the keys from the specific type table (e.g. user_id) and the key from the meta-tags table. This design would also allow you to have other attributes to a tag that apply across all the base tables. 

For your particular question you have defined the list item as a comment, so you will simply need additional columns to indicate what object (post?) it goes with and what comment number it is. You may also want to have columns indicating who made the comment, when it was made, and from where it was made. Here is how this could look: 

I wouldn't call this syntactic sugar by any means, but in Oracle you could pass your tags as a delimited list in a query like this: 

We have tried bouncing DBConsole, re-submitting the job from the library and even recompiling the package being referenced. This is happening to multiple jobs with about one execution in every ten scheduled succeeding. Any ideas on what can be tried or checked? Update: I've opened a SR with Oracle. 

I have a procedure that generates an XMLTYPE and I want to validate it against a schema. The problem is that there seems to be a permissions issue running createSchemaBasedXML because when I run the procedure as AUTHID DEFINER it gives the error "ORA-31050: Access denied", but when I run it as AUTHID CURRENT_USER it actually returns a validation specific error (I'll deal with that separately). CURRENT_USER is not an acceptable solution. My supposition is that CURRENT_USER works because the user has the XMLADMIN role. Granting the permissions the role includes does not resolve the issue, so it must be the roles ability to bypass the ACLs. The thing is, querying RESOURCE_VIEW for the ACL that protects the resource shows that it is protected by . shows that the xsd has all the following permissions: 

As the comments indicate, you need to understand normalization. Without too much theory, when you want a list for a particular object in a database here are some possibilities: 

While auditing is the most comprehensive solution, it may be overkill in some situations. For those times you might consider just logging your session. In SQLPlus for example you could change your login script to turn spooling on like this. 

I recommend you put the code in an AUTHID CURRENT_USER package. You can certainly pass a Boolean, but I think a Varchar2 makes the usage clear. You should unit test this code, add documentation, formalize the error handling, include instrumentation, and probably modify the reporting method. 

Procedures in PL/SQL can have default values for parameters, but the caller can pass values that are identical to the default values. Is there a way from within the PL/SQL to determine whether a parameter is passed? As implied this cannot be done by comparing the value with the default value. 

Assuming you are not using bigfile tablespaces and assuming you have no standard for how large datafiles should be or how empty they should be, you should create a tablespace with one 14G datafile and allow it to autoextend to a reasonable percentage of the overall free space you have available. If you have plenty of free space, you should set the maximum to unlimited (which is actually a finite amount dependent on your block size). By doing this you can set an amount for the autoextention that reflects your balance between system performance due to frequent autoextending and the space benefits of allocating only as much space as the objects need. 

The first three columns should all show identical information and the last should verify that the year is correct. 

Gaius is correct.+1 In case someone else has this problem in the future, it is known to occur on 10.1.0.2 to 10.2.0.3 on any platform. In addition to upgrading to 10.2.0.4, Patch 5120780 can be applied to fix this problem. The patch is available for a limited set of platforms. 

This section of documentation uses the term “User Processes” to refer to the client processes that connect to an Oracle database. If you read down the page further it describes the two types of processes that run the Oracle database server code – Server Processes and Background processes. Like DCookie I have heard Server Processes referred to as User Processes, hence the confusion. The 11.2 Concepts Guide uses much better wording (emphasis mine): 

The wallet is created without error, the credentials added, and I can list the credentials back from the wallet without a problem, but when I go to use them I get an ORA-12578 as follows: 

Does Oracle's Configuration Manager which according to Oracle provides a "40% faster issue resolution", violate HIPAA or require specific configuration in order to comply? This question concerns databases that contain Protected Healthcare Information (PHI). The questions scope only covers OCM and not the broader scope of Oracle support accessing the database. The following from Oracle describes what OCM collects: 

There are no alternate definitions of NULL in Oracle. A column can't take less space than NULL unless the column doesn't exist at all. Also, if a null value is in the last column of the row, the row will take less space than the same null column as an earlier column. Here is the wording in the documentation: 

Oracle Enterprise Manager Grid Control Advanced Installation and Configuration Guide 11g has the following section: 

I'm not looking for a trick applicable only to my specific test case, but a general solution to the problem. 

To answer this question best we would need to a whole lot more specifics about what you are doing and what the kinds of value are going into each of the fields. In general though since more values can be added to each set of possible values, a seperate table is advisable. Unless the fields have overlap in their possible values it would be better to have each set of possible values as a seperate table. In Oracle these could be Index Organized Tables. 

You put together some good sample code. Did you look at the timing in SQL Fiddle? Even some brief unscientific performance testing will show that query three in your demonstration takes about the same amount of time to run as either query one or two separately. Combined one and two take about twice as long as three and that is before any client side join is performed. As you increase the data, the speed of query one and two would diverge, but the database join would still be faster. You should also consider what would happen if the inner join is eliminating data. 

You can grant column level privileges for INSERT, REFERENCES, and UPDATE, but a standard grant cannot be used to limit SELECT privileges on a specific column. You can do column level masking with a Virtual Private Database (VPD) policy restricting columns using the sec_relevant_cols parameter. The feature required Enterprise Edition. mrdenny is right, the other way to do this is to create a view which does not select the column or does, but masks it. 

It sounds like you are describing a mutual relationship such that there is no difference between and . In this case you should design your code to always insert the lower userId as the first value and the higher as the second. Then you can use AlexKuznetsov's suggestion and add a CHECK constraint of . The code can then catch the duplicate exceptions and ignore them since the relationship already exists. Note: I flipped the comparison from > to < because the lower number being first makes more sense to me. It works either way and may make more sense the other way in your environment. 

I really like Phil's answer (+1). Here is an alternative that you've probably already considered. I include it here only for completeness. It satisfies your requirement for a row type, but is certainly not as elegant. 

The check is only done when the exception is raised, so the only overhead is the variable declaration. You will know which value caused the exception based on the line number. If this were the only reason to move logic into a package it might not be worth it, but since there are many other benefits, it is worth considering. 

Justin Cave and Eric Humphrey's queries both return different results. Here is a third equally valid answer that returns a third different set of results: 

Based on your comments, it sounds like you are really interested in knowing the growth of the object over time. You could create a table to store this data and as frequently as you want to see changes, insert into the table the results of the this query: 

If you have a column that preserves order, here is how you could do it in Oracle. You will have to translate to SQL Server. 

As a side point, you should have a table storing which students are assigned to which classes. Having that there is no need to store both attendance and absence because each can be derived from the other, so simply store the least common. If it is more likely for someone to attend then store absence and if it more likely to have an absence then store attendance and infer absence by the lack of attendance. This also eliminates the need for the status column entirely as the name of the table would either be Attendance or Absence.