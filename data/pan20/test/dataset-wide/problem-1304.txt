You can expand on this by providing functions that use the "Error hiding pattern". That is that they return a to indicate whether the input operation succeeded or not, while the result is stored in a reference parameter. Other isn't the only object that can be streamed from. For example, you can also stream from files. You should provide a way for users of your function to specify what they want to stream from (this can be as simple as having a parameter. 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

Specialization for special types You can also provide a way to read whole lines through template specialization or through a different function, since it would be useful for strings (reading a phrase, for example). More functionality You can provide a way to obtain values based on a predicate. So that it can be a lot easier for people to get valid values. For example, I want to get easy input of an integer that is between 0 and 10 from an user. Example 

Here's a working example of the function, along with the function that I use to attach it to the mouseup event on row elements. 

This code is telling SharePoint to retrieve every item in the list, forcing all of the returned items into an in-memory DataTable. Then it's manually filtering that table down to just one specific item. This is inefficient for two reasons: 

Selecting elements by ID When obtaining a reference to an element by its ID, it's more efficient to use than . Instead of: 

Then you could set up a function for creating objects and attaching the event listener to fade in the given elements. 

Eliminating functional differences between Vanilla JS and jQuery versions Your vanilla script and your jQuery script are not functionally equivalent. Your vanilla is selecting the container by its ID, while the jQuery is selecting the container by its class and then selecting the images. Your vanilla script would more closely resemble the jQuery by using and/or . e.g.: Making it work for multiple containers Your code will function strangely if more than one image rotator container is on the page: the jQuery will grab image elements from all the containers and only set one to active at a time, while the vanilla javascript will only change elements in the first container it grabs. (EDIT: As you noted in the comments, you can work around this by selecting the different containers by ID before passing them to your function, but that approach requires manually specifying IDs both in the HTML and in the JavaScript. Ideally, you'd be able to just add more elements with the appropriate classes in the HTML to take advantage of the existing image rotator functionality.) With a little tweaking, you can ensure your code processes each container separately (allowing each container to have its own active image). 

Note that there are also native JavaScript equivalents for manipulating HTML within HTML elements (such as and ). Table elements in particular have their own special properties and methods for manipulating their layout and presentation, as documented here. Cache reused HTML elements and collections to limit DOM queries If you have code that queries the DOM using any of the selector methods I mentioned in the above section, you can save the results to a variable that you can access at will. That way you don't need to re-query the DOM for those elements if you need them later in the code. The exception to this is when the DOM may have changed and you want to get the latest version, in which case you generally need to re-query the DOM. Avoid polluting the global namespace You can avoid creating global variables by simply wrapping all your code in an immediately-invoked function expression (IIFE). 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

To indicate that the first three files have been processed. You would then only have to check the first character of every line you read, instead of the whole file name, to know which files have been processed. This is the technique I would personally use, as it doesn't require an extra file and it keeps the original file mostly intact while providing a much faster comparison. 

What this means is that when the comparison fails, E is updated to the current value of X. If the comparison succeeds, X is updated with the value of N. Therefore, you don't need to update X again! That is the whole point of a compare/exchange operation; you're basically saying: "I was the last to modify X." Issue #1: Unsynchronized access to writer In your code, you perform a store to the atomic variable with a copy of a value you last obtained from the update performed in the compare/exchange operation, but this is not atomic. 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

Von Neumann extraction is a technique to remove bias from a source of entropy. You extract an unbiased array of bits from a biased one by comparing pairs of consecutive bits in the array and returning the first one when they are different, or nothing when they are the same. The extracted array will be smaller than the source array, but will be more balanced in terms of overall 0s and 1s. To accomplish this in JavaScript I ended up writing two extraction methods: one for extracting a bit (given an array and an index) and one for extracting an entire array (given an array). The code appears to work as desired, but I'd love to hear any insights or suggestions related to best practices, naming conventions, performance concerns, or problematic edge cases. Here's my bit-extraction method: 

Here's a working snippet that demonstrates another method of using closures to maintain live references to HTML elements. 

Note that you'd have good reason to reinstate the extra intermediary variables if any of them were being used more than once. Note also that I'm not suggesting that you eliminate the and variables and replace them with their literal numerical values, even though they're each only used once. In their case the intermediary constants serve to eliminate "magic numbers" and make the code easier to maintain. You could similarly endeavor to eliminate "magic strings" and convert your element IDs into constants. 

If you find yourself using and want to be more angular, check out the service in the AngularJS API. In addition, for your purposes, you might be better off using . waits for at least one digest cycle before executing the expression, which might be enough for the DOM to have the new elements added (though not yet rendered). This can prevent the "flicker" that you otherwise get from waiting for elements to render before manipulating them. The only reason to not use would be if you're dependent on the DOM rendering for accuracy. 

consider objects with named properties as alternatives to arrays In general, I think your code is over-using arrays to store values that are not inherently suited to that data structure. A good example of this is the use of the array and array in . You're populating with values from the text boxes, then looping through those values to check whether they're blank, and if not, you're then pushing those values into the array to represent your actual item. Consider instead capturing those values directly into an object, as below.