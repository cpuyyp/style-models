and use that instead of the hard-coded period. But that still does not cover all invalid input, such as "12-34-56". There is a better (and simpler) solution: Check if the new string after replacement can successfully be converted to a number, using a . That will recognize valid numbers according to the user's locale correctly: 

which is faster because the function is called with smaller numbers. On my computer it reduces the time from 0.6 to 0.02 seconds. A faster implementation of would use the prime factorisation of the given number, as explained in the above referenced Wikipedia article. 

(Remark: Usually, forced unwrapping with should be avoided, but here we have a programming challenge with well-defined input data.) To increase the legibility of the code, I would assign the three parameters of a query to variables , , . The code then becomes almost self-explaining. The entire code then looks like this: 

can be simplified. Your function can only return (on success) or (on error), therefore the return type makes no sense. One possibility would be to change the return type to to indicate success or failure. Another possibility is to return the total number of bytes copied in the success case (which can be less than the parameter if end-of-file was encountered), or on failure. Yet another possibility is to an error, that allows to report details on the problem to the caller. I would not use empty external parameter names (), a call 

Your function expects that the passed string buffer has space for characters. A better design is to pass the buffer size as an additional parameter: 

Checking for a trailing newline character can be done with the method on the underlying . Instead of creating a mutable copy and removing the last character, you can extract the first characters instead. The method then becomes 

which is probably not faster, but simpler and cleaner ("Swiftier") code. In order to pass the coding challenge in the given time, you need a different algorithm. The idea is (and to be honest, I did not invent this myself but found it here): 

To generate or not to generate ... I don't think there is much difference with respect to efficiency. Your second “non-generator” version does not occupy more space because each product is immediately compared against the current maximum, and not stored in a list. The advantage of the generator-based version is that the two tasks 

This automatically leads to factorizations with the factors in increasing order and without duplicates. As a side effect, the function is not needed. Here is a possible implementation. (Please take this as a demonstration of the algorithm only. Java is not my first language, so there may be more idiomatic ways to do implement this.) 

The correct result would be 3037000490, since $$ \sqrt{9223371982334239233} \approx 3037000490.9999996957524364127605120353 $$ (computed with PARI/GP). The following implementation uses the ideas from DarthGizka's answer to the above mentioned question to implement a "correct" integer square root function in Swift 4: 

Your code looks generally good (with two real problems explained below). Instead of an empty default array 

All functions which add an element to the circular buffer take the a parameter, but returning the elements is done as a . I would recommend to use in all cases (and apart from changing the function prototypes, no changes are necessary). Since can be assigned to any pointer type without an explicit cast, retrieving elements simplifies from (taking your test code as an example) 

Having said that, here are some remarks and possible improvements of your method. I have named different implementations , , ... so that all can be tested in the same program. I am not sure what the effect of 

in your first version of because is not guaranteed that the elements of a Swift are stored in contiguous memory. 

making the variable obsolete, and mutating instead of concatenating strings. Iterating over all valid string indices is better done with a for loop: 

so that they can be configured directly in the interface builder, with a live preview (compare IBInspectable / IBDesignable: 

because the number of possible combinations of divisors is just \$ 2 ^ {\text{number of divisors}} \$, which can be computed as 

is a keyword, therefore it must be quoted in the enum definition (but only there). Alternatively choose a different name, e.g. . IMO describes the first case better than , and , (or ) is a better than and . I also would omit the labels ("n:", "x:", "f:", "g:"). They are somewhat arbitrary and the code is better readable without, e.g. in your function: 

is more efficient, it computes both numbers in a single call and gives you integers instead of strings. But here we can do even better: There is a dedicated method to check if two dates are equal down to some specified component: 

In the same improvement as mentioned above applies: If a prime number is found then "crossing out multiples" can start at the square of that prime: 

First to find a terminating newline character, and then again to determine the length. This is not necessary because returns the number of characters written to , i.e. a newline character can only be at position : 

Even if the code is only needed for ASCII letters ("A" ... "Z", "a" ... "z"), it can still be improved. Defining a global function instead of a closure variable increases the legibility. You should also use a better function name, is pretty non-descriptive: 

(And the chances are good that the compiler optimizes the variable storage anyway.) And if there is any chance that a node with the given name does not exist then use optional binding: 

Euclid's algorithm for computing the greatest common divisor does not require that the two numbers are sorted by absolute value. It works well without that preliminary step: 

There is a catch (!) however: Existing objects already loaded into the managed object context are not automatically removed, and doing so it a bit tricky. See $URL$ for more information. 

But actually I would go the other way around and replace the initial values by an method. The reason is that – since you defined your own init method – there is no default memberwise initializer anymore. Therefore I would start with 

once. Next, the address calculations can be simplified by separating the swapping of two objects into a helper function: 

But actually it is not needed to create an array with all numbers in the given range. You can iterate over a range directly: 

1 is not a prime number! By definition, a prime number is an integer greater than one which has no (positive) divisor other than 1 and itself. Both the iterator and the function – correctly – produce as the first prime. But then in , the number is inserted and I see no reason to do so. 

As a bonus, the code now works not only with integers, booleans and strings, but with all types (provided that they are “UserDefaults compatible”). 

but that is a matter of taste. I don't think that it makes a difference if you compile the code with optimizations switched on. In addition, I would use as type for the and parameters. is what returns, and is the correct type to describe the size of an object in memory, see for example the declarations of , or . 

is not necessary, also variables should be declared at the narrowest scope where they are needed. Setting an initial value for 

which also has the advantage that no forced unwrapping operator is needed. Even if we know that it cannot fail here (because the type has been checked in the if-statement) it is better to write the code in a way that it becomes obvious that it cannot crash. Next, the loop itself can be simplified: 

Yes, that will crash if the function is called with an error code that does not correspond to one of the enumeration values. Better use optional binding with : 

Your function prints all found IP addresses in debug mode, but binds the socket only to the first one. The recommended practice (if I remember correctly, and I will try to find a reference) is to 

The iterator expects that no elements are added or removed to the circular buffer during the iteration. A possible solution to detect such a programming error would be to add a generation number to which is incremented with every modification. Then copy that generation number to in and verify it to be unchanged in . I would add such a check at least if the program is compiled in mode. 

Now this is confusing! A function called which returns a single integer? or would be an appropriate name. The forced unwrapping is acceptable because the input comes from a programming challenge with well-defined input. However, finding errors in your code is easier if you check the optionals explicitly and print an descriptive error message if the input does not match the expectations. And with a short description (using the "markdown format" which is recognized by the Xcode "Quick Help inspector") it becomes a reusable function for this and future programming challenges: 

Note that the size of the array is limited by the tree height. In my test with a tree of 1,000,000 nodes, the traversal is done in about 0.2 seconds, compared to 3.5 seconds with your original method (test done in Release mode on a MacBook). 

The variable name suggests a boolean condition, but the value is an optional range. It would be clearer to make it a boolean value: 

then it suffices to import (or + ). But I would get rid of the floating point conversion and implement it as (taking the hundreds as an example): 

The dispatch group has a “counter” which is increased by and decreased by . waits (with almost no CPU usage) until the counter reaches zero. In our case this mechanism is used to start the next page request only after the previous one has completed. Another option is to use a “semaphore”: 

Now it is no longer possible to call any database method without having opened it. For better type safety I would define a custom type with a private property. could then be a method of this type. You have two methods 

Some remarks concerning the performance: Each key lookup is done by a linear traversal of the array. For large dictionaries this can become a problem. The project from the referenced blog post solves this by maintaining both a dictionary (for the key/value pairs) and an array (for the ordered keys). The advantage is that a lookup is fast. But adding a new key or removing a key still requires a linear traversal of the keys array. Whether this is acceptable or not depends on how often keys are added/removed compared to key/value lookups. One could store the key/value pairs in a tree structure to improve the performance (e.g. AVL tree or a red-black tree). Of course that increases the complexity of the code. 

All characters are shifted by the given amount so that a space becomes a quotation mark, and some letters are transformed to non-letters. Also 

the type annotation and the first are not needed, and the generic type can be inferred from the compiler in the second instance: 

Now observe that gives the least significant bit of the number ( or ), and is a truncating division. Therefore the function can be simplified to 

is bad because it wastes CPU cycles. In my test it caused almost 100% usage for one CPU core while a network request is active. Network requests are asynchronous in nature, and there are better (and less resource intensive) ways to handle that. First change the function to take a callback instead of returning the result. It is also sufficient to create the once: 

But actually this loop is not needed at all: In the j-loop, remember the index where the lowest element has been found, and then set to a "large" number directly: 

is better named because that is what it does. I prefer instead of to convert a sequence into an array, but that is a matter of taste: 

I'll start with a review of your existing code, and then make a suggestion for a better algorithm. The first thing to notice is that there are many conversions from arrays to lists and back to arrays: 

This is also a valid use-case for a forced cast: If it fails then we have a programming error, which should be detected early. You could even replace the three view controllers by a single one in the storyboard. The only difference between them is the background image, and that can be loaded (e.g. in ) depending on the chosen league. With respect to the duplicated button action code: I find it acceptable for three buttons. An alternative is to add outlet connections to each button in the and connect all buttons to the same action method: 

Similarly, the static property is used to assign consecutive names to the each created group. This is acceptable, but why not create each group with an explicit name (as you already do for the participants)? 

determines it from the table itself. Always computing width and height from the table would be one way to remove this inconsistency. Another way would make the table “know” its width and height. In other words: make it a class with attributes and consequently, make the global functions instance methods of that class. The Python way of printing an object is to implement the 

is suitable for any type of object if the memory of was obtained from or a related function. It is then not necessary to separate between and and the buffer creation simplifies to 

a operation where is the number of characters in the string. It is much more efficient to iterate over the characters with 

For an upper bound of 10,000, this took about 0.001 seconds on my MacBook Pro in Release mode. But creates an array of all that numbers, which costs time and memory. If you use a range instead 

That works, but it does not take advantage of the "object-oriented" aspect of Objective-C. Here is an alternative implementation: Each can be dumped as a property list. The default implementation just prints the keys and the value: 

method, and then simply call . This is what it would look like (without changing your logic otherwise): 

Finally, the hamming distance of this code to the zero code word is the number of 1-bits, in this case . The main method of your program then becomes (using the code from @janos's review as a starting point): 

which returns an array containing the non-nil results of applying the transformation to all sequence elements. For example 

The first improvement would be to make the test faster. The conversion from a number to a string is slow. Testing for adjacent "ones" in the binary representation can be done with simple integer arithmetic: A number is rare exactly if and have no bit in common: 

but he does not have to. The is available without knowing the concrete error type at all. You can also make the error type conform to to provide additional information to the caller, e.g. the SQLite error code. 

Your generic pack/unpack functions can be called with arguments of any type, and that would give wrong results or crashes for 

Define instance methods Both and operate on an instance of , therefore I would replace the free functions by instance methods: 

prints the winner's name using the method, and you can adopt that to your needs without affecting the rest of the code or the image resource names. 

Then one could try to avoid the code repetition for the even/odd case. But actually I would suggest a completely different, more efficient approach: 

Finally, note that ISBNs are usually printed in groups with a separator (e.g. "978-3-86680-192-9"), so another suggestion is to 

There is quite a lot of "almost similar" code due to the fact that you treat "value observers" and "result observers" separately: Two classes 

instead. Note how string interpolation makes the expression more concise and readable, compared to your original 

Note also the use of the dictionary subscripting syntax instead of . This can be simplified further by using the method of . This method calls the given block once for each key and the corresponding value: 

Possible improvements Both the and the method call twice: first with and then with . A possible improvement would be to start the second search at the piece and offset found in the first search, instead of starting at the very beginning again. Useful protocols to adopt If you adopt the protocol 

As of Swift 1.2, multiple optional bindings can be combined in a single if-statement, which reduces the number of nested if-levels: 

method creates a (temporary) mutable array for each subview in the hierarchy. It might be more effective to create only a single array and passing this array around to append subviews recursively: 

Indeed, there are, and the "simplest" one is : Your code checks that the maximum side length is equal to the first or last number in the array, and prints "Yes". But actually this row can not be stacked: The first cube with side length 2 must be picked first, then the two cubes with length 1 in any order. That leaves us with a cube with length 2 which cannot be stacked on top of the others. How can this be fixed? If the given side length are $$ a_1, a_2, \ldots , a_n $$ then your code checks if $$ \max_i a_i \in \{ a_1, a_n \} $$ which is a necessary condition, but not sufficient. Let us first assume that the row of cubes can be stacked, and let \$ m \$ be the index of the cube which is chosen last (\$ 1 \le m \le n \$). Then it is clear that $$ \tag{*} a_1 \ge a_2 \ge \ldots \ge a_m \le a_{m+1} \le \ldots \le a_{n-1} \le a_n \, , $$ i.e. the side length are first decreasing, and then increasing. So \$(*) \$ is a necessary condition for the row to be stackable. But it is also sufficent: If \$(*) \$ is satisfied then the two decreasing sequences $$ a_1 \ge a_2 \ge \ldots \ge a_m \\ a_n \ge a_{n-1} \ge \ldots \ge a_{m+1} $$ can be merged into a single decreasing sequence by choosing (and removing) the larger of the two front elements until both sequences are exhausted. Therefore a row can be stacked exactly if the side length are of the form \$(*) \$, this can be checked with a single traversal of the list. I'll leave the implementation in Python up to you :)