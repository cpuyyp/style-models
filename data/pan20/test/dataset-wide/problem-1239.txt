If this is truly what you are trying to do, then I would recommend you take a look at popular PHP dependency injection frameworks/containers like PHP-DI or Pimple either for direct use in your applications or for inspiration on how you can approach the problem. 

For this simple use case, you are correct that you could do all this work in a reduce step saving yourself an additional iteration over the array created by the operation. Now whether this is enough of a performance impact for your expected use cases to move away from the (probably clearer-to-understand) map-reduce pattern is something that perhaps you would need do some testing to decide how you want to approach the problem. If for example, you ever foresee yourself adding a step, then perhaps keeping separation between map - filter - reduce steps makes sense. I do think there are some edge cases around your basic query-split approach which might not be handled well here. For example, what about parameters with array notation (i.e. )? You can certialny do plenty of search on the internet to gets lots of ideas on how to approach the basic query string parsing logic. 

First off, I think this code is one of the better "professional-level" PHP examples one would expect to see here. So, kudos on writing clean, well-documented, well-thought-out code. My biggest point of feedback here, is that I am not quite sure what this class is intending to be. Perhaps that is because the scope of the class is quite large. This class seems to want to provide the following functionalities: 

I would consider building and storing reference to choice options related to a specific question as part of the . That way in this method you don't need to do any jQuery selection to determine the universe of options related to this particular question. I also think that you might want to consider the fact that you could have multiple items selected if you ever move beyond just using radio buttons, which should probably be a property of the question (i.e. allow multiple answers), not something hard-coded into the template. So you might end up with something like: 

Since JSON can only represent two data structures - a numerically-indexed array, or an object - I would think that a numerically-indexed array would make more sense as the first dimension, meaning you might end up with JSON like: 

Of course this eliminates the echo altogether. But this makes sense if you are committing to the pattern of having all end user messaging delivered on files page based on value. Why would you need messaging here anyway? 

Which would work with a set of validation functions like this (note I am using arrow functions here which seem to lend brevity to this code). 

This allows you to only have to specify the footer include once vs. having multiple exit paths from this script. 

To your question on calling against user-defined functions, I see no problem with this. I think this could reduce overall nesting level and make the logic around the Redis lookup read much more cleanly, without all the specific data transformation logic you have in the map callback. I would would suggest that all this transformation should actually take place in the iteratee passed to as opposed to the the callback function that is passed as you are currently doing. This callback should really only handle error conditions or perform whatever action needs to happen on the result array upon completion of the mapping operation (in this case return a response to the caller). 

In the comments section, we talked about options around the DB queries. It sounds like may not be suitable for your use case in dealing with those execution times (which still seem odd to me given size of dataset). So let's assume rather than look at optimizing that randomized query (again there are many good examples of this out there), or caching query results locally in some manner that you find appropriate, we are just going to look at simplifying your code, but sticking with the approach of randomizing the id's in the application. I would suggest that you test through both sides of your if-else conditional to understand the relative completion speed of the "download all ids and shuffle" vs. the "random row retrieval" side of the conditional. Ask yourself things like: 

I would also would be careful in evaluating the result directly, as you could get unexpected truthy/falsey results there I might use: 

Consider using constants for these, as they don't change during script execution. You might also find this helps readability of your code when you begin to concatenate with these. 

Since you tagged this question with , I would say you could benefit greatly from making your keyboard and scale representations into classes. 

Thanks for your example. It kind of validates my concern on how you are thinking about routing. I like that you are thinking about the routing problem and trying to move away from legacy ways of having each URL going directly to a physical file for processing. I would however challenge you to take this a step further, as what you have now really only gets partially away from the legacy web application, a script-for-every controller/action line of thinking, in that you still have scripts that you are redirecting to rather then using your router to instantiate an appropriate controller object in order to satisfy the request. Most modern frameworks that utilize a front-controller routing pattern like you are trying to achieve have gone the route of auto-loading a controller (ideally auto-loaded in a PSR-4 compliant way) to handle the request passed to it by the router, not having the router just include some specific script file. So you might see a pattern like: 

This seems problematic. Are you insuring uniqueness across your email and username fields? Can there be one record with username = and another with email = ? If so, which one are you actually retrieving? Should you provide to give preference to username match over email match? Why is your application not architected to treat these fields uniquely? It just seems like you are building a potential problem into your app here. 

Updated comments So it sounds like your real problem is one of dependency management. As you are developing different versions of your digitalData schema, you currently have no reliable way to ensure that interacting code adheres to your standards. It seems that you don't really care that each area of the site be on your most recent schema, but rather that each area of the site at least work with a schema that works with your backend data collection system. This is actually OK and a reasonable way to think about working with a large-scale application/site. To this end, you might consider treating your digitalData code as a version-controlled dependency. If you release version 2.0.0 of the dependency, each different team that develops a different part of the site can then control whether they want to take the new version of the dependency or stick with their 1.X.X version. It would conceivably be OK if portions of the site are on different versions of your dependency as all of those versions have been built to properly interact with the backend data collection mechanism. With your current approach, you don't know this to be true. Teams could potentially introduce schema changes on the fly and break the data ingestion process. By taking this approach, you enforce that every development team that works with this dependency must declare which version of the dependency there are going to load into their area of the site. Meanwhile, as the team developing the dependency, you can begin to enforce specific behaviors against the data structure, as I have mentioned, without concern that your changes are going to break portions of the site, as when you release a new version, nothing on the site would actually be using it until those areas update their dependencies to work with your latest release. You push the testing burden onto these individual development teams to make sure they are working with your dependency in an appropriate manner in their portion of the site. 

Why would be part of the conditional criteria for this POST logic? This variable may or may not even be populated with a record. 

You only seem to be considering happy path. What happens in DB connection failure occurs? Have you considered passing the DB connection/object as a dependency to this class or method such that this class/method is guaranteed it gets a connection in a proper state? 

Think about validating requests against the object more stringently. For example, this code that you use in your get/set magic methods: 

Should this be a concrete class at all? These seem like they should be static methods. There is nothing that you are doing here that would seem to necessitate a concrete instantiation. 

I would consider moving away from using your own serialization methodology (in this case simply concatenating with ) in favor of using PHP's serialization methods, JSON, or some other well-structured, well-supported approach to serializing structured data into a string. I think over time you will find them more powerful, more flexible, and less fragile. 

Be careful with relative path with regards to including in other pieces of code. If being included by code in another directory (particularly at a different level in directory structure), this may break. Also, you won't be able to include this file more than once within any given script execution since you are defining constants. Since you can only include this once per execution, do you really need to define constants at all? 

My suggestion would be to abandon such an approach in favor of writing individual classes for your database entities such as , or better yet using a proper PHP ORM. 

Consider replacing this with - $URL$ - or have this function used within validate_form operating against a configuration passed into the function as parameter. This function allows for both validation and sanitization depending on what filters you apply to each passed parameter. This a more reusable approach across various pages with forms in that it allows you to avoid having to have several different validation functions for different forms. Instead you have a single function which can perform your POST validation and you have form-specific configurations which you can pass to that function. 

This object would not represent order of layers, as technically object properties have no order, so you would still need to maintain your array to maintain ordering. For convenience (and to prevent O(n) seeks against the ordered array), you might also want to store the value of the current order of the object in the array on the each layer object in the key-value store For example: 

The nesting in your while loop is a bit out of control. You should think about inverting conditionals and/or using to clean up these nested conditionals. Consider how much easier it is to read code like this: 

Now your option "value" is actually something meaningful, holding a string that can be used to directly instantiate a object. 

The last line of code here is unreachable. represents the last line of code that will be executed from within that code path in your function/method. Any lines of code after it in that code path are unreachable. You should never write unreachable lines of code. It is probably good that this line is unreachable, is if the order of this lines was reversed you code would break. Why are you trying to close a connection right after opening it anyway?