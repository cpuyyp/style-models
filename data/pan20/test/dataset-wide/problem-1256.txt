I can't say that it's going to be more efficient, or better designed, but one option is to take advantage of polymorphism by creating a set of classes for this. 

You'll still need to code each calculation function, but you don't need to manually attach each calculation to a specific crop or trait. You can just have a database table which tells the code "Crop + Trait = Enum value" 

You don't provide any example of how would differ from , so I can't be more specific, but here's the gist of what you should do: 

Everyone has had good ideas, but since you're asking about OOP, I'd suggest refactoring it altogether. 

Each grouping of numbers is an instance of a object, and we test if two are equal based on the items in each . 

LINQ has extension methods for any which will help with this. There's , which will return the first elements, and which will skip elements, then return the rest. Of course, these don't actually change the they're operating on - they just return a new one. But that's a safer pattern to use - it means you have the option of keeping the untrimmed version around if you need to. 

Use an if-statement to check if you are currently processing the last number. This will get rid of the last for-loop in your current code, which only loops through the array and shows the non-zero number it encounters. There is some things that can be simplified within your algorithm as well. 

Also, your interface specification does not need to mark methods as , all interface methods are public already. So can be just 

Unfortunately, I don't speak python so I can't provide any code but there's a couple of things I see that can be improved algorithmically: 

But in reality, there is no need to transform all the positions to a number, instead you can access the 2d array directly, like this: 

This is a bit inefficient, as ultimately, once should be enough. To accomplish that, we need to check each item exactly once (or technically, at most once, as it is possible to return false early). Also, to make the method slightly more useful, you can use . Which is easiest, checking if the list does adhere to your requirements or checking if it does not? In my opinion, it is easier to check if one of your requirements fail, which means that we can have the method as the last statement and perform some early returns for if something doesn't match your requirements. What I would end up with is this, which is pretty much straight-forward: 

Both methods can be made , because they don't depend on anything specific to whatever class they're in. Rather than redefining the odds each time that is called, you can create a and populate it once. This also lets you do that right next to where your enum is defined, so that when you add a new enum value, the odds are right there. If you have other properties associated with an , you may want to consider a class to consolidate them all, rather than let each place they're used keep track. 

Heslacher is correct in that you should split this into two separate methods. That said, sometimes doing that isn't an option, so I want to point out an alternative to passing the "magic values" of and into your function. When you have a function argument that only takes a very limited number of values, you're usually better off replacing it with an . That enforces the limitation when you're writing code, and helps avoid typos and other subtle gotchas. 

is just a call to get as a (instead of an ). And so on... This lets you easily add a lot of logic ("Do I add this set of tags?"), doesn't require a multitude of s, and you can go back and add more things to a tag later. 

On the one hand, they provide a default (empty) implementation so you don't have to override both methods. On the other hand, it's not as easy for the classes implementing this interface to know what they should implement (although the options can be easily figured out by using Ctrl + Space). The fact that your and even exists in the first place is telling me that you often want to implement one function but not the other. By the way, I think your name says nothing, pretty much. A better name would be . Also, some libraries which have plenty of listeners with many methods often provide a default easy-to-subclass class that provides empty implementations already. 

Imagine I would write this code at an interview. What would you say? Time complexity: \$O(n)\$ Space complexity: \$O(n)\$ Auxiliary space complexity: \$O(1)\$ 

In this case though, it doesn't hurt that much IMO to have false-positives, and I must say that your simple filter is quite good. 

Again, method extraction will make this code more self-explanatory, and make the buttons better be responsible for what they should be responsible for. 

Now, even though this can be rewritten using a ternary operator, I wouldn't recommend it because it would end up being quite unreadable. Actually, I'm a bit skeptic already at the last line. Actually, I believe that the check is unnecessary, as that's already covered in the last return statement (it would call the function once more for an empty string, which now returns true). So if you really want just a one-liner for this: 

I find this much more readable than trying to do conversions to an Enum, and more straightforward than a decision grid. That being said, it doesn't scale as well as either option. 

I'm not entirely sure how your second example fails to match, because the string contains all of "AU", "A3", and "2.0". That being said, here's an attempt at a cleaner rewrite: 

Everything that's the same gets put into . Everything which could vary is defined as an method or property, and then the subclasses implement just those things which make it different. 

By doing it this way, you separate the formula (which is basically just Ingredient/Percentage pairs) from each application of it. You can use the same object to calculate the weights for 10000g of dough or 50000g of dough - simply call with a different value. Notice how many fewer properties you need on each class, and the question of "late setting" of some of them is entirely irrelevant. Effectively, weight is not an intrinsic property of an ingredient, because it varies based on the total weight, so shouldn't be a property of . 

If you want to be sure only a limited number of classes are supported, put the supported classes in a and check if the hashset contains the class you want to retrieve. The throwing of the would be better of as an , and don't forget to provide a helpful error message. 

When this entity gets persisted in Hibernate, it will also persist all it's contact information. One formatting issue with your current code is that you're not indenting your code properly. Each should add one indentation, each should remove one. This makes things so much readable. 

enum improvements I would use a constructor for your enum to make things more consise. I would also use the instead, which works directly with the primitive type. Additionally, you might as well make your method public and your map private. Applying these changes will make your enum look like this: 

This uses the Math.abs function to perform the calculation of how many stars to print. If we take a look at a plot of the classic Math.abs we can see that it looks useful. We need to flip it upside-down though, this is done by taking which would look like this. Finally, we need to switch it to the right a bit, so we modify the input to the function call and end up with this: 4 - abs(3 - x) Images courtesy of wolframalpha.com 4-abs(x) 

Everything in your code should either require the interface or the interface. If the former, it can accept any of the four classes. If the latter, it requires the plus four bit. Since a plus four can always be downgraded to a pure zipcode, this set of inheritance will let you pass a +4 wherever you are looking for a . Also, by always requiring the interface, rather than the concrete type, you can trivially implement the null object pattern you asked about. 

Another possibility would be to store the words in a dictionary of nested dictionaries. The key would be a letter, and the value is another dictionary of every letter that can follow that. Repeat until you've reached the maximum depth. For the sample case, this would look like 

You could use instead of the in the second case, but I seem to remember reading that it's faster to do as an array than with LINQ. 

This will kick off a new solver run each time the prior one displays, up to the limits of what your computer can handle. 

Edit: Stole the idea from Jesse C. Slicer's answer, but didn't modify the function signature. You can also return if that is more useful to you, or you can go with his idea of returning , in which case you don't need that at all. 

Again, if using a 2D-array, you should be able to loop through all the tiles here and check the put for each position. Or better yet, as the tells you exactly what index to change, you should only change the value on that specific index. Study up on arrays in Haskell and you should be able to make it better by only changing one index in the array. checkWinner First of all, this contains duplicated logic. Once for and once for , that part can be extracted. Additionally, there's a little trick that can be used when checking for winners in Tic-Tac-Toe. The idea is to start at a certain position, and then loop and change the row and column indices by 1 and check the next position, repeatedly until you go outside of the board range. checkFull Again, use a for-loop. getTile Again, use an array and grab a specific index. The last part of your code That's a lot of indentation! A looooot of indentation! Try to find a way to reduce that. Put more if-statements on the same indentation level? Switch if's with else's? Sorry I can't provide detailed help here. All I can say is: Yes, that is a code smell. 

You're right that all the casting is a sign that there's better way. Rather than using the value of an as the index to an array, you should use a structure that's designed to store two values in the first place. There's a couple of alternatives here. My first instinct is to use a . That most explicitly matches the concept of what you're trying to do (each has a value ), but it's not actually the best option. You're not going to be looking up the value based on the key, the order of the keys may change which could lead to hard-to-reproduce bugs, and it's less memory-efficient. Instead, I'd use a , , or (in C# 7) . They're all effectively the same thing in this case, and best convey the concept "here is a pair of related values" without implying the A->B relationship of the Dictionary. (Note that you can also use arrays instead of , like I do below). To make handle this, you would need to make it generic, so that you can pass any arbitrary type in and get that same type out. Here's what the code would look like using C# 7's ValueTuples: 

A possibly faster, and at least more compact version than using a is to use a good old integer array. A can actually be typecasted to an , which gives it's ASCII code value. 

Just pass it your node and it will verify your tree recursively. Note that there are two things this method does not verify, that are also a requirement for a Binary Search Tree: 

Using the conditional operator to choose different methods is not very readable. Another option might be to use a framework that does these kinds of things for you. 

In Foo you can then use your object which you retreived from the method to use that particular object. Note that one can take the "Tell, don't ask" thing even further, but with the code in your question this is what I think you need for now. 

The second call will return the object, with as the string value. This makes me wonder a bit about the general design and purpose of this code, it feels a bit strange. 

There is one important thing missing on your and fields. What if I do ? That's right, I would break it. You must specify them as