Since all my work is done in the method (similar to in a regular generic handler .ashx), I thought that I add a method there which can be overridden. However, it never seems to get called. What did I miss? Do you have any other suggestions on improvments? 

I'm using a StaTaskScheduler (TPL extension) to open some web browser windows simultaneously and navigate to different sites (using WaitN, but it might as well just be a ). In my example below I'm running 5 concurrent browsers. Works fine, but it locked the UI thread, so I wrapped my tasks in a . Seems like it does the job, but is it the correct way of handling the issue? Do I need to dispose the worker once I'm done? And finally, is the correct way of keeping thread safe? 

That second is a bit long, but we can rewrite this to something I think is more readable by creating ranges and using as a cross join: 

shouldn't be a property on the program. Nothing is going to be accessing the file, so if it's going to be in there, it may as well just be an instance variable: 

The algorithm you used is the way I've always seen it - flooding the matrix. I think my sister had this question at her first interview, and I think she did it the same way as well. 

Using namespace std pollutes the global namespace. It's better to use everything with its full name (, , etc...) 

returns the price plus the tax. If it's going to do that, I would name it . There's also a lot of repetition in the method. Find out the part that's not repetitive, and do that first: 

Each of these steps can be put into their own helper function which are also called "subroutines". The will make the body of the while loop a lot more readable. Here is an example of a subroutine to get a valid number from the player (again, pseudo-code): 

Note - my JS is a little rusty, but this should illustrate the idea. Update: Per our discussion in the notes, I am suggesting changing this code: 

where is the (infinite) list of primes and returns all of primes less than which can be combined with . 

First of all, there are so many pitfalls associated with programming that I prefer to write all except the most trivial scripts in a language like perl, python or even awk. I realize that availability is a concern, but all of those languages are pretty standard now. If you write the script in a better scripting language you can get rid of the duplicate call to which is one thing that I presume bothers you about the code. If you must write in /bin/sh, then run your code through one of the following static analyzers to help you find potential coding problems: 

Another shameless linq answer that doesn't require reversing or creating a new enumeration and only goes as far as it needs to: 

I'm going to be brutally honest, because I think it will do the most good for you as you look for a job. You say you "have the right frame of mind" and "just need someone to 'nudge' [you] in the right direction." You're way ahead of most of the pack, as you are capable of something much harder than FizzBuzz. However, this code needs a lot of work and a lot of reorganization. It's going to take time to learn the culture of C#, and it's going to take time to learn OO principles in an effective way. If I were you, I'd start writing a lot of OO code in C# in my free time and posting it to codereview. This is C#. You don't need to call on strings. Instead, do: 

A clique is just a set of Ints. You could use a linked list, or a bit set, or whatever you want. Here is part of a Haskell solution which might help you structure the problem in C++: 

Using Data.Memocombinators Have a look at Data.Memocombinators module. It offers combinators for memoizing functions which is essentially what you are doing with the . Here is the example from the documentation on how to use it to create a memoizing fibonacci function: 

The only drawback is that explicit bounds have to be determined for each level function. This approach computes in about half a second. 

and you have a similar problem with . Unfortunately, to preserve whitespace in these cases I don't think you will be able to use the function here. It is customary to have parens around the list patterns, e.g.: 

Sure, they could still pass bad values, but they have to try harder by explicitly creating an invalid enum value. Also, making it a scoped enum provides extra type-safety and prevents naming clashes. Either way, I think it makes sense to throw out of the constructor immediately if the key length is wrong instead of waiting until the function. If you want to enforce a valid value at compile-time, you can use a , or you can use a smart-enum pattern. This is an example hacked together real quick: 

Since there are only three valid key sizes for AES, it makes sense to not even let the AES class be instantiated with any value. I would introduce an enum similar to this: 

Now you can keep variables and methods private within your and only expose what you need to access from the outside. This is just a small sample to get you started. Are and already defined in the global namespace? If not, you probably want to pass them as arguments to the methods. It's hard to say from your two examples. Some other comments: 

I would like to execute a certain method at a given interval. The reason why I can't use a timer + its event handler right away is because I want to add an offset to each tick (100ms in my example below). It seems to be working just as intented. The reason why I'm starting it manually is because if the takes more than the given tick time, I want to let it finish before starting a new "tick". Perhaps this could be done in a much simpler way. I would like your thoughts on the code: 

I changed the logic a little, because seems to neglect to grab the item to the left of the current item. Also, in the for loop skips the entire row above the current item. I would add the enumerable in the traverse method into the for loop: 

Of course, then you have to fix the other parts of your program that use them. In addition, I'd stop doing assignments inside of parameter lists and and headers. It's dangerous to do so, especially as a beginner. Here I've changed the first : 

I removed because I don't think it's necessary. I would also check for malformed input, as can fail with an error, and can be something other than , , and . Before I got into the industry, I had flaky UIs that worked if you used it how I, the programmer, intended. There were quite a few ways to misuse it and break the program. One of the first things I learned on the job was that that was not going to fly. Ewan's answer is great for the OO principles, so I'll neglect to cover that. 

stream->list Avoid on large lists. In your function it will create a (large) list before passing it on to . There is a stream version of - namedly , and this will process the stream lazily - i.e. it will only generate as many elements of the stream which are needed. next-prime Another way to eliminate the recursion here is to combine with and with your predicate, e.g.: 

partitions This is inefficient since once you have one person's items you know what the other person's items are - just take the complement. Also - does this condition really work if two items have the same value? 

It all depends on how many configs you have. For a large number using a sqlite database could be a win. 

Consistency is important. The rest of your variables start with a lowercase letter, so name the variable in the same way: 

I would get rid of the continues on the for loop. They can get rather confusing, especially with three of them in there. You can use and to do so: 

Use when you can. It lets the programmer know (reasonably well) at a glance that a variable will never be modified again. The variable can be declared as such since it's never changed. Also, returns a , so I'd probably declare it as such and cast later: 

Instead of putting the logic in the method, we can change the header of the method and let it populate a list of items visited by that cluster: