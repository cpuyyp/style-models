Does the same happen with Netfilter DROPs or REJECTs? Such an error should not cause a relevant delay. DNS filtering Another solution (rather easy one if that is possible) would be to filter AAAA records for certain domains. If that is not (easily) possible: Is it possible to connect the DNS server and Netfilter so that I know "IP address X belongs to domain Y" so that I can add it to Netfilter? Anything more elegant than logging everything and grepping the log? The way to go? Which (other) possibilities are there and what is the easiest? 

Your configuration says: "If a packet has arrived on br1 then send it via br1." That obviously doesn't make sense. Rules like that are for routers but you don't even mention routing. What you mean is: "Send packets which are a reply to packets which have arrived on br1 via br1." This could be done with Netfilter's packet marks and the option . But here this would not make sense. Because you use rp_filter you can simply route by target address. You don't even need advanced routing (). For that. Plain normal routing should do the job: "Send 10.0.4.0/24 via br1, the rest via eth0." You have explained what you have done but have not mentioned any task that would require a complicated setup. If you "don't do anything" special what goes wrong then? 

I don't know Vyatta but it seems to be a regular Linux. It's not clear to me whether your question is 

I guess avoiding a bridge and using host-only networking with routing makes the configuration easier to understand. If the guests are Linux systems then I recommend to configure them with a serial console (which can be accessed by ). 

should do. BTW: Even if this does not solve your problem (yet) I do think that the effort and quality of my answer should at least be worth an upvote... 

The rejection is not related to DKIM but to the recipient. But why should Google mail servers try to deliver to wrong MXs? Doesn't make sense to me. The recipient system could be incorrectly configured, of course. Do the failing recipient addresses have the same MX? Something else: Have you verified the DKIM signature? Maybe it's just some technical looking text... 

Then define the rules as usual (just -A for INPUT though, no , please) and in the end remove the connection safety rule: 

That does not guarantee the exported disk(s) to contain only zeroes in their unwritten areas. Thus the kernel may detect something which isn't really there. You should overwrite the first part of the COW volume (I don't know how much is needed but the first 4 MiB should be enough. Oh, your COW volume isn't even 4 MiB in size: 

Your problem is on the client, not on the server. The system on which sshd is running doesn't care about ssh-add/ssh-agent. It just checks whether the client system is capable of making the authorizing digital signature. Whether this signature is made by ssh, by ssh-agent or even by a smartcard does not make a difference. If you do not use one of the standard files (but e.g. ~/.ssh/id_rsa_newbox) then you have to tell either ssh (ssh-add ~/.ssh/id_rsa_newbox`) to use this non-standard file. 

Routing is the decision over which interface a packet is to be sent. This decision has to be made for locally created packets, too. Routing tables contain network addresses and the associated interface or nexthop. This refers to and (in a Linux context). Forwarding refers to packets which reach a system but are not destined for this system. Forwarding is a decision of the system: "I take the packet and try to get it towards its destination." Instead of just dropping it. "forwarding" is a common term in the context of packet filters. Linux' Netfilter has three chains in its base table: INPUT, OUTPUT, and FORWARD. This chain just makes the decision "Shall this packet be forwarded or dropped?" (if forwarding is generally enabled on the system; Linux again: /proc/sys/net/ipv4/ip_forward). 

This is most probably a firewall problem on one of the systems. You can use tcpdump to check whether packets are not sent at all or discarded by the recipient system: 

You can check the exit code of You can check whether the socket given in $GPG_AGENT_INFO exists. That should be enough but you can also check with fuser or lsof whether the process given in $GPG_AGENT_INFO is the one that has opened the socket. And if you want to be really exhaustive you can also check whether /proc/$PID/exe is a link to /usr/bin/gpg-agent (or whatever). 

tells you which services are running on your machine. (Possible but improbable that others are just inactive at the moment.) As long as you don't use one of them you are OK. You may choose a well known port of a service you are sure never to use. Telnet maybe :-) (But maybe there are attacks on that port, too.) 

This should not be a problem at all. You just have to order the needed amount of IP addresses. This means that any hoster can do this. And watch out what you ask: Shopping questions don't live long here... :-) 

From a network perspective it is best to solve this on the client: Check for the LAN ip and act accordingly (don't start OpenVPN; adapt routing; whatever). I don't know how to do that on Windows, though. A workaround may be to change the IP addresses the client connects to. Probably it's just a few systems which the clients connects to. It may be possible to configure different IP addresses for the same host name depending on where the query comes from. So you could create a host name samba.vpn.example.org which points to e.g. 192.168.1.15. If you have a local DNS server you can configure it so that it gives e.g. 192.168.2.15 for that host name. Your OpenVPN gateway can make DNAT from .1.15 to .2.15. That does not affect bandwidth. If the client is local it does not try to connect via OpenVPN because the target is in the LAN network, not in the OpenVPN network. So OpenVPN would still (try to) establish the connection if physically connected but the OpenVPN connection would not be used and thus waste minimal bandwidth only. A third option: Throw away the Windows client, keep Linux running in a VM, and route the company addresses (or a client-side mapping) through the VM. In the VM everything necessary can easily be done. The bandwidth loss should be quite small (if using virtio NICs).