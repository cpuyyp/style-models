I realize we are supposed to keep our comments about the code posted in the question. I am breaking a little from that because this is less a what's wrong with my code than a why did the interviewer not like my code. Here is my take on a FizzBuzz - see how simple it is? 

I am no expert in streams so this may not be an ideal solution but here's a moderately streamed version. Essentially, the game is a stream of objects which are evaluated, grouped by the result and counted into a Map. Most of the streaming is in the method. 

I post full code in the hope that you will learn. If this is homework please try to understand all the changes I have made instead of just copying it. 

Added Spot the deliberate mistake - not closing the at time. Not relevant to the issue but important. Fixed! Also - failing to close the stream and checking the entity against null. Fixed! 

There are many edge cases to e-mail address structure that you will exclude if you try the simplest approach. One I use that accepts most of the reasonably acceptable e-mail address looks like: 

Will this do what I want it to do - i.e. handle multiple threads waiting for a resource without consuming unnecessary CPU. Is the necessary? Logic suggests that the head of the queue at that point must be me but is there a scenario where it may not be? 

And that's all. You need to eliminate all the view related stuff from the view model in such way. It is how MVVM have to be implemented. 

I don't see any reason the variable should have type. You use it within integer calculations so there is no point in . Declare it as and remove casting to in the loop. 

If you read about Random.Next on MSDN, you'll see that it returns value that is greater than or equal to minValue and less than maxValue which means you'll never get . 

The advantage of this approach is you can forget about and other -methods. If you need to add another character in the game, you'll just put in one of the arrays. No additional actions required. Also use camelCase for local variables instead of PascalCase. I mean you should write in the code above instead of . Another one recommendation is using of keyword when the type is obvious (but I use it evrywhere :)). 

two times that can cause slowing down if some method in this chain is not lazy and executes heavy code even for . 

You should never throw an instance of the class. Instead use apropriate built-in class or design your own exception. So instead of 

(This is an extended (and formatted…) comment (don't like the repetition of the non-pair comparisons at the beginning and end of the sequence). Not having used C++ in a dozen years, I'm hopeless with move semantics, for one. (And not quite destined to review C++ postings…)) Let me try something about the non-pair comparisons: 

Triggered by Finding overlaps between two lists of axis-aligned rectangles, I tried to code "rectilinear" intersection using line sweep - in python. I'm not keen on discussing (2D) line sweep in general here (which is why this isn't tagged algorithm). The code looks small enough to stay a single module. I didn't take the time to digest PEP 8 & Co. 

(Given a choice, I wouldn't read a single shortish input using file (or stream or channel) IO - just use an argument to main.) is neither documented nor named suggestively. It doesn't even live up to it's name, not returning a value, but using a class data member for result communication. This prevents multiple&concurrent use - instead, return a value. RE60K (and jschnei) showed "analysis from the sum formula". Alternatively, start from the sum target: to be a sum of two consecutive natural numbers, it needs to be odd. Tabulating this for several sum lengths: 

is bad since you throw the same exception for different parameters and without any details. Also I believe suits much better for . And you doesn't check on . Also it would be better to have ability to pass any as rather than only. The same can be applied to return type of the method: can be replaced with which allows you to use and . Benefit of this approach is that returned collection will be immutable (of course you could use , but I prefer in this case). Thus I would rewrite the method like this: 

you don't need setter since is set via constructor and is not supposed to be changed. Small note: don't use extra spaces in generics :) will look better as . 

Node Properties should always have PascalCased names. So have to be changed to . You don't need to initialize properties in constructor. Starting with C# 6 you can initialize them in declaring statemenet: 

In my opinion using bool return values is appropriate for methods that are purposed for checking some conditions. Examples: 

I make conclusion that is invalid. If you want to compare string on equality ignoring case you should use : 

I don't understand how can be a subclass of . Authority is an attribute of user and not user itself. The same applies to . In my opinion it is bad to keep users related to specific group inside the group. You should take a look at databases developing where there is the first normal form according to which you need separate objects that will connect and . And I see you have the class for this – . So proceed completely with it removing list of users from the . The previous point in fact is even more important since groups contains related users and users contain related groups... In my opinion it not just can be reorganized, it have to be. 

sums it up nicely - you might have been explicit about the dimensions of improvement, though. The first thing to consider with non-throw-away code is readability/maintainability. Enough has been said about premature optimisation - I find instances of premature analysis with your code. The very concept of (y-coordinate)collisions is flaky - just rotate so slightly that formerly identical y-coordinate values get separated while none separate before collide. 

Zhu, Wu, & Wang claim in a 2014 JofCIS article that their "Efficient Algorithm for Chain Multiplication of Dense Matrices" is both simpler and faster than Hu/Shins 1981 O(nlogn) algorithm (is that real Pascal code?) - any takers for a free implementation? 

This is going to be a performance at the cost of readability post, see explicit praise for the comments, only for a regular code review. There always are "microefficiencies" one could worry about - and shouldn't, at least not until all bigger points are taken care of and a problem persists. Still, it is advisable to start with emphasis on readability and improve the algorithm there. One thing that might catch a would-be performance coder unawares is Java io performance - in particular, gets bashed. (I haven't tried to do useful measurements, I suspect it is comparatively bad only with big input files and no buffering.) For the hell of it: 

Your lazy method is not thread safe. If two threads check for the key at the same time they will both find it absent and both create a new object. Wrapping your in a will get around this. 

and it all still works in exactly the way you would expect. This is essentially coding the algorithm and the data separately. 

Your problem is not with the loop construct - nor is it with GOTOs. Your problem is you are avoiding some tools that can make your code better. Here's an example. 

I would recode the list of s into a list of tests and implement them as an . There are other techniques but s offer a nice succinct way of doing this. 

I totally understand how exciting it is to make full use of the richness of the Java language but sometimes you must stand back and decide whether you have don good or bad. Here I think (and this is only my opinion) you have not done good. My problem with this is that it is not obvious how to use the mechanism. I would suggest that the transform mechanism should not reside in the enum, it should be in the . Something like: 

is bad name for this method because from the name I expect it just returns bool indicating whether the hero dead or alive. But in fact it doesn't return anything and prints some text. Choose another name for the method, for example, because it what actually happens - you exit the program since game is over. I recommend to move checking of hero health out of the method. Then you code will be: 

Now we see that we can store to variable since this expression is used multiple times. So the final form of conditions above will be 

you have no thoughts to rewrite it by eliminating repeated calculations and name all those constants :) 

Looking on this lines some people can say that omitting curly braces is very very very bad. Although I don't mind to place them for every I decided to go away from this "rule" some years ago. I totally understand what problems curly braces should prevent but I need to say that I never had any issues with s without them. So it is just a matter of taste. But you can use them and if you feel you are not experienced enough it probably will be better. 

(Getting late: the following code is work in progress; posting this to save the above, mainly (not quite trusting SE's autosave)(Never used C# - give me a break on documentation comments, const-correctness, commendable use of or some such.)) 

highlights an opportunity for result reuse: if the sequence of dimensions has been evaluated in a past invocation, the optimal association should be the same this time. 

In each iteration of 's outer loop, stays the same for all the iterations of the inner loop, as does its contribution to the set. If you didn't literally concatenate strings, it was apparent that the same sets were created for the 2nd ticket's digits time and again - and the sets "checked for completeness" were the unions of the digit/char sets of tickets i and j: It looks advantageous to create each ticket's set once and for all and think hard about what can be done to reduce the number of set unions to evaluate - if ticket i consists of 2 distinct digits, only, there's no need to pair with any ticket consisting of no more than 7 distinct digits. If one ticket contains every digit, it is a winner paired with every other ticket … If and when coding that proves not fast enough, note that the digit sets are quite small and reconsider their representation. 

My problem is that sometimes (unpredictably but after at least 1 hour of idle time - which is how long the cache pill takes to expire) the code passes through this mechanism, does not rebuild the cache but retrieves a . I know that the thing was added to the cache in the last rebuild so my logic follows that something unexpected is happening but I cannot think what. Any ideas? Notes 

If (as suggested by @h.j.k) you are not able to adjust you could still achieve the same functionality with something like: 

I have implemented several lock-free algorithms to maximise throughput but have always baulked when performing a spin-lock. I can usually convince myself that this is the only way but it still nags at me that a spin-lock is a terribly bad idea. I recently came across a FIFOMutex code fragment and thought perhaps that would be a solution. I have hacked it around a bit because I don't want mine to consume interrupt exceptions but essentially it looks like this: 

Am I using the pool correctly? Am I closing/not closing at the right time? Should I reset the request ()? Have I missed something? 

Note also the and methods that avoid your manual creation of the lists. Note also how I calculate the carry rather than explicitly set it to or . It is calculated to be the value remaining after the digit has been extracted from the divided by . Finally, see how using s allows you to interrogate each list to see if it is exhausted and, if it is, use . This way we don't need to special case one being longer or shorter than the other.