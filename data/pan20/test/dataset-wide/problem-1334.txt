Finally (minor thing), rename as either or . This will let it follow the camelCase format and be more descriptive. 

If you don't know what an enum is, now's a great time to learn. It's a very useful data structure which lets you define exactly what its potential values are. Here, it seems like your missile types are PAC-3s, GEM-Cs, and GEM-Ts, so that's what we have above. This is why object-oriented programming is so powerful. A missile is a thing in the world with its own properties, and so it is here. This enum may have been more appropriately named , depending on your preference, since technically it will hold values for multiple missiles, like the . But having this data structure set up is what will let us completely rewrite your method in just five lines. 

In my original question: Generically encapsulating random generators and distributions into a class template I was given some excellent suggestions from two very informative users. I will give a basic outline of what each user had suggested by topic. I will finally demonstrate what changes I have made to the class. 

Then with the appropriate type of commenting for valid reasons might serve you well. Then at least this way; one would know that you intended to call or omit it and why! Well written code is the how and shouldn't need comments. 

Follow up on HungryBeagle's excellent answer: The generalization of excluding factors of 2 and 3 (and so on) from search is called Wheel factorization. In my opinion the best is to do it for 2,3 and 5. It has a period of 30 (relatively small), and exactly 8 jumps between prime candidates: (6,4,2,4,2,4,6,2). You see the appeal: only 8 candidates out of 30 are tested, and 8 is perfect for iteration (for binary reasons). You output 2,3,5 as primes, then start jumping (testing 1+6,1+6+4,1+6+4+2,...). If you include 7 or higher you have a bigger jump table and less and less improvement. The formula is: , where phi is Euler's Totient function. So for 2, your trade-off is 1/2, for 3 it's , for 5 it's , and for 7 it's which is slightly better, but requires BIGGER jump table, which also isn't of size 2^n. It's true, when you are doing primes sequentially from 2 up, you can use full sieve (remember all previous primes) but usually you need a test for a specific prime. Here's quite a fast and short code in c: 

Stop declaring your variables and then setting their values. You can just set the values in the same line that you declare them. Always use the appropriate type parameter for generics (i.e., , not just or . Don't create variables where you don't need to (i.e., , , ). Wherever possible, separate out different functions into different methods. For example, in your refactored code below, I split the anagram generation into a separate method from the actual file IO. This not only improves code readability but also prevents your program from holding a lock on the file for the duration of the run. (Think about it; there's no need for the file to be locked up while we're actually checking the list for the anagrams.) People generally use the interface rather than the underlying object whenever possible. ( vs. ) Not really sure why, to be honest, but this is the accepted convention. The function probably doesn't even need to exist, but if you're going to leave it, it can be a one-liner. Use variable and method names that are actually meaningful. Don't convolute code where it's not necessary. For example, see the refactored method below. 

Questions - Concerns I would like to know from both users who have provided a solid, well detailed, and informative answer if the changes I've made reflect what was suggested. Is the code accurate or does it still need some improvement? As for my next question; it deals with the overloaded . It is supposed to allow a user to define their own to be passed to the seed function in order to seed the generators or engines. This can be answered by anyone who feels that they have critical feedback. The function is untested, the code does compile and run without trying to use it. Does the for the function declaration look correct? If so, kind of a stack overflow question but, how would I integrate the needed parameter(s) for this function into the this class's constructor? This particular function overload has me held up. 

This method will print your input prompt and then wait for the user to hit enter/return on STDIN, then return whatever was typed. I've added a call on the result for convenience and cleaner input. (To see why that's relevant, consider what happens if your user types in "s " for your variable.) I also changed the to be , just because I think it's a more beautiful command-line interface when the prompt is on the same line as where the user types. Of course, that's very subjective and completely up to you. 

These are the basic improvements. After this step, you can employ advanced primality tests, such as Miller-Rabin test or Pollard's Rho test, which bring orders of magnitude of improvements. But this first step still eliminated a lot of unnecessary tests. You can guess I've done this before :) 

You are testing many many more divisions that necessary. The number is always divisible by itself, and if it's not divisible by anything up to sqrt(x), it must be prime: Like this: 

I don't believe there's any good use-case for this code. I know it makes for a boring answer, but sometimes the correct thing really is simple and boring. As you say, the Struts framework should always redirect to the appropriate method and fail entirely otherwise. Even the scant lines you posted have some bad/useless programming practices, so my guess is that the developer thought he was being thorough and clever by tacking on needless framework. 

After reading through the question and the answers I came to the conclusion that this is were comments can come into play. I had recently read this Q/A Guessing a number, but comments concerning and the accepted answer gave me insight to the situation here. Use comments to explain the why, let the code explain the how. I can use your function similarly for each case as an example: 

I have previously asked A library of books to demonstrate C++ to a C programmer and I took some of the advise from user: JDlugosz and this is what I've managed to come up with so far: My question(s) are relatively the same as in the original, however I would like to know if the changes that I've made based on some of the suggestions are appropriate, if I had missed anything, are there any mistakes, and is there any more room for improvement? The only major internal changes are: instead of using I decided to use for better performance, and instead of auto generating a number the user now has to type that in as well. I had to update a few of the functions in in which I originally forgot to do. I originally posted this code with the change where the function was updated, but forgot to update the to for and functions... They are now updated as well to reflect the full change of using a instead of an converted to a . Now the is fully accepted by the user via console as a string. No need to convert to a . main.cpp 

These methods make no sense if you think about them logically. Your client code will pass in a that it already has, in order to invoke on it? Why wouldn't that code just do it itself? Here's how getters and setters work: 

This is just general nitpicking, but you should only expose methods as which actually need to be . The method makes sense as a method because it's the part of the API that you will want to use in other parts of the application. This method, however, is purely internal and thus should be . Also, method names should pretty much always be verbs or verb phrases. I might rename this method to something like or . Actually, because of the nature of how I rewrote your loops above, I would change it to or that way my usage of it is more intuitive. These notes also apply to your method, which is and might use a more intuitive name for code readability. Also, in those two methods, what happened to your beautiful variable names?!? Why did you suddenly move to using single letters instead of something more descriptive?