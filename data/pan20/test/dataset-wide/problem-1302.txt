The biggest problem in your code is probably the fact that most interesting function takes a parameter for no obvious reason. Easiest solution would be to make it a default parameter with value 0. A more interesting solution would be to try to understand when we want to stop which is when all nodes have been given a color. In order to do so, get the list of nodes with no color and consider we have a valid solution if this list is empty : 

and it appears that only the different between and is relevant: we could use a single variable for it. 

Here are a few details : Variable declaration It is usually a good idea to move your variable declaration in the smallest possible scope as close as possible to where they are getting used. This for instance shows that is never used. Also, you can take this chance to change your loop into a loop and declare in it. Warnings It is a good thing to activate all warnings. For instance, I get : 

Please let me know if I missed something. Edit : Here's a quick attempt with an initial array containing the original array twice to make testing somewhat easier. I've included different versions, more and more optimised. One could go further but I started to have doubts about the correctness :-) Corresponding jsfiddle 

Avoid hardcoded strings and magic numbers in your code. In you do need them, make sure you define them in a single place ( Don't Repeat Yourself ) . 

Diclaimer: the comments in this answer will be in a fairly random order. Also, because of the random AND interactive aspects of your code, my comments are not very well tested. Iterable unpacking The functions return multiple elements. You always store these in a variable, then access each member individually using the syntax. A more concise way to do so is to use iterable unpacking and write something like: 

Finally, is not required as a first argument to . Style Python has a style guide called PEP 8. It is definitly worth a read. You'll find various tools online to check your code's compliancy to PEP 8. From what I can see, the main "issue" is that the function name is and not . Documentation If you wanted to do things properly, it might be interesting to add some documentation to your function. More details (and personal preferences) We have a nice ternary operator in Python. Using it, you could write : 

Then, iterating backward (or forward if you define your array as the reverse of what I have written), everything should be easier to maintain. 

Here's the principle : the interval will contain the closest element to at any time. At the beginning, this interval is the whole array (). At each iteration, we'll make it strictly smaller. When the range is limited to a single element, this is the element we are looking for. In order to make the range smaller, at each iteration, we'll consider the middle point of . Because of the way is computed, is also in the range. We'll check if the closest value is at or and update or accordingly. One can check that the range actually gets smaller. Edit to answer to comments: As spotted by @Vick-Chijwani , this code doesn't handle perfectly the scenarios where an element appears multiple times in the input. One can add the following working tests to the code : 

Now, if I was to write the same function, because it is so easy to iterate on strings in Python, I'd probably avoid the recursion and so something like : 

You do not need global variable to propagate the list of servers up/down : a list populated in the main and fed to should do the trick. 

Now, if you think about it, the list is not that useful. The point is just to perform a re-indexing : what we are really doing is that we loop starting as and we stop at (included). We can write this directly : . The same kind of comment also applies to the "basic" version of the code. 

Simple optimisation Instead of doing in the nested loop, you could compute once at the beginning of the function then call as you need it. Other optimisation Instead of checking if and are in the range, you could just generate them so that they always are in the range : 

Re-opening and closing the file every time you need to log something does not seem like an efficient solution. In your case, it might do the trick. 

Be consistent in your code style The code style seems a bit inconsistent. For instance, sometimes you have whitespaces before "=", sometimes after, sometimes both, sometimes none... You'll find various coding styles online and different tools to check you code compliancy. Declare variables in smallest possible scope I find it a good habit to define variable in the smallest scope in order to make things easier to track. In your case, could be declared inside the loop. Getting rid of the your -d values All your values (except for ) could be removed because the link between the name and the value is hard to understand at first.:w So far, I've got: 

This is very concise and would prevent you from using for instance the code of when the one from is expected. Also, rotors are expected to have 2 properties : 

Enum might be the real solution to define the different possible operations. The implementation of the XOR method could be more concise : and you probably don't need it anyway because Java has a bitwise xor operator. Also, that would make your cases AND,OR and XOR more consistent. You should try to make your code a bit more consistent : sometimes you store in a variable before using it, sometimes you don't. My feeling is that even though it's not great from a performance point of view because it makes you compute stuff you may not need, it might make things easier to do : 

? Also, just some food for thought as I haven't studied the issue in depth : how do you handle parameters that don't need to be in quotes such as numbers ? 

The last fact is probably the one that can be useful to you. Test and Code organisation In any case, if you want to optimise your code, I suggest you write some test cases (with huge values so that you can see where the bottleneck actually is). In order to write these tests, you might find it more convenient to write small functions with a single responsability. You might realise while doing so that you don't really need to store the inputs in an array only to go through the array afterward. You could probably write something like : 

for a total of (n-1)n(2*n-1)/6. This tells us that the current strategy won't be able to be better than O(n^3). Now, what you could do to is maintain 2 arrays instead of one : 

( probably needs to be renamed, I'll leave this to you) List comprehension You can use list comprehension to rewrite in a more concise/pythonic way : 

Style You are lacking consistency in the spacing in assignments. Organisation It might be worth extracting the algorithm in a function. It makes code easier to read and to test. 

This makes your code go roughly 500 times faster. From this point, it is hard to make things actually faster but let's try. Once you have , to find 2 divisors under of 2 digits, you don't need have two loops : one is enough and then you check if the number actually divides and if the result has 2 digits. 

in : can be re-written . Also, Python does not handle deep recursions very well because it does not perform Tail Recursion Optimisation. If needed, you can rewrite the function: 

Data structure I have troubles understanding what the returns data structure is supposed to be. A dictionnary mapping each category to a single update is a bit weird. Wouldn't it make more sense to map each category to a list of updates ? I've tried to emulate some item/category hierarchy to see what was happening but I might have wrong assumptions about what your code is suppose to retrieve. For the record, here is the corresponding fake function and the value returned: 

Nitpick Because of Gareth Rees' excellent answer, there is no point in trying to improve your code until you've made it correct. However, here is a tiny piece of code that could be improved: 

Even better, this looks a lot like what you did for "new game" or "load game". Did someone say "reusable components" ? 

In the function, you write a loop to add elements from . You could use a simple operation on lists. Also, it is clearer to add at the end of a function whose return value is used. This is one of the latest addition to PEP 8: 

Also, if what you want is to iterate over a container and also get the corresponding index, the pythonic way is : 

As far as I can tell, you don't need the conversion to . Also, you can iterate directly over keys and values using : 

You are not done yet because there is another bug in your case which does not always appear (depending of the order of the element in the list). Indeed, the idea is to check for each element in if it is in . This is NOT what you are doing at the moment. Indeed, if is shorter than , you won't check every element of . Once this is understood, the bug is quite easy to fix. 

You can avoid a few cache lookups. Indeed, at the moment, you consider all pairs (a, b) with a != b and add a whenever you find one. You could limit yourself to pairs (a, b) with a < b and add a+b when you find it. Also, by doing so, you know for sure that the value you are looking for will be in the cache. 

Last detail Your first call to is useless because the elements are unique already and you just need an iterable. Also, you could get rid of the list comprehension by tweaking the parameters given to : . 

Comments Even though you have missed an key step in the algorithm, you have tried some fancy optimisation, it would probably be worth commenting on those to explain why and how it works. 

We can make this even better by fixing a small issue with your code : the trailing whitespace at the end : we can ask to add a whitespace between chunks. Your code becomes : 

Code organisation To be honest with you, I have no idea what your code is supposed to be doing. However, wouldn't it make sense to define a method taking the time you want to approximate as an argument instead of using the attribute time? It would make things somewhat easier to test/understand and you can always call the method with if required. Algorithm From an algorithm point of view, depending on the number of times you plan to do this, you might find interesting to perform some preprocessing whose cost will be amortised to achieve better average performances. Among the different options. For instance, you can sort the values : if at a given step, the computed distance is bigger than the minimal distance, it means that you are getting away from the closest value and you can stop iterating. Otherwise, you can use a binary search to find the closest value. 

It seems much clearer to me. Also, your function doesn't seem really useful to me. You could just have : 

this does not correspond to the pythonic way of looping over a container. There's a cleaner way that doesn't involve indices. 

If we could be sure that self.gender has only 3 different values, the default value could be put in the dictionnary straightaway (associated to for instance). Different variations could be written. I guess one could use to ensure that we always retrieve the default value. I don't like this solution that much as the dictionnary would get bigger as we try to retrieve using invalid keys. I don't know if there's a (simple) way to have a dictionnary which returns a default value when the key is not present without updating the dictionnary but I'd be interested in such a thing. 

Rewriting the function You can avoid considering as a divisor if you simply start at 2 (then, you might need some special processing for but I'll leave this to you). Then your function becomes : 

I was about to say that I had found a bug with the following test cases while trying to understand how your logic works : 

is all you need (on top of replacing with ). It can hardly becomes easier. The check is somewhat artificial. If I was to write the code, I'd write in such a way that only numbers bigger than 1 are in the returned list. 

Now, it's time for the special trick : we could remove the test by performing this before the loop. Also, we could't remove the by performing this after the loop (but we need to check that this would have happened which is when ). 

For Loop The way Python loops is designed is supposed to help you to write concise and expressive code : what you write should match pretty closely how you think about things : "I want to do this for each item in this container" instead of "I want to have this index and I start at 0 and I increment and I get the element at this index...". 

I thought that this would be very confusing for any player : you are asked for something that might or might not be relevant. First, I can choose "rumore" or "leave" but I have the feeling they do the exact same thing. Then, I am asked if I want to drink before checking if I have enough to drink. 

I don't have much to say after Jamal's comment. However, I just wanted to point out that some tests are not useful. All the logic around Western Zodia sign could be simplified and probably should be extracted in a function on its own. 

Your code is simple and just works. For that reason, you can be happy and there is not much comment to give. However, being very picky just for the sake of learning, one could say various things. statements You are using without parenthesis. This is the one and only reason why your code wouldn't work on Python 3. Just to be future (well, actually Python 3 is not the future, it is the present) proof, you might as well add the 2 parenthesis. String formatting Instead of using the format, you could use the method. You'll find more information online. Also using named place holder makes things easier to read and avoid duplicated values. You'd get something like : 

(I took this chance to replace with just in case we ever reach something after 4 for whatever reason) Then you could put the content of the else-block and the content of the if-block in functions on their own but this doesn't seem really required to me. 

Make your code easier to read You can ensure you respect PEP 8, the guideline to write Python code. You'll find various tools to help you comply to the usual standards : , , , . Also, is a pretty bad function name, let's pick something better (for instance ). Use pythonic loops Python provides you a clean/safe/concise/way to iterate over pretty much anything : . Using the loop index is much more verbose on top of being less efficient. You can change : 

Avoid repeated values In your testing code, the values appear in multiple places. You could re-write your code to generate a formatted answer from the list: 

When the number of cases gets huge indeed, it might be worth performing some preprocessing to ensure queries can be performed more efficiently. We can easily write a procedure to prepare our datasets in such a way that we can apply the trick described above directly. This leads to much better performances indeed : 

Your code looks good, seems to work and is somehow documented but it can still be improved in various ways (not only performances which will be only tackled at the end if at all). Code organisation Your call to could be moved behind an guard in case you ever want to reuse . It may not be relevant in your case but it is a good habit to take. Then, it may be a good idea to split your code into smaller functions, easier to understand and to maintain. By doing so, you'd also separate the concerns my having the code computing the results you need not mixed up with the logic handling the input/output. Finally, and maybe even more important, that will make your code testable. Indeed, before performing any changes in the algorithm, it is highly recommended to write unit-tests to prevent you from breaking everything (tests are usually not fail-proof but they help a lot). 

Your code looks very good and the type annotation is a really nice touch Also, your code is well organised and easy to understand. Some documentation could be a good idea (but it's better to have no doc rather than bad doc). Also, you could consider writing unit tests. Let's try to see what could be improved/made more Pythonic. Loop like a native I highly recommand . One of the idea is that whenever you are using , you are probably doing it wrong. In your case, you could use . End of word The end-of-word detection could be done in a single statement: . Also, you can get rid of the definition before the loop and even in the loops, sometimes, you could define it only behind the because you use it only there. Reorganise the logic Sometimes, you check if something is empty and then if it contains a particular element. This can be factorised out: Also, simplifying the code , you could rewrite :