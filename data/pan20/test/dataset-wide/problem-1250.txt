You are representing some state using 3 individual boolean variables. It may be better to represent such a state using an enum with flags. Then this complicated test to figure what state you're in wouldn't have to be done. You could then combine flags to represent each of the separate states then switch off of that. 

A better solution in this particular case IMHO, rather than defining multiple functions with varying number of arguments, you could just define one function accepting variable arguments to achieve the same thing. 

You could also condense the conditions a bit if you recognize that values of are considered and non-zero is . You're testing if they're equal to so you could just write it as 

You can make this more maintainable and more compact by utilizing LINQ here. I'm not sure what is in your code, I'm guessing you derived from a WinForms . I'd argue that the node's is unnecessary. You can easily determine that if you look at its . Level indicates it is at the root of the tree, otherwise it is greater than 0. Unfortunately there's no nice way to add a range of nodes to another. You could only add arrays of the nodes. Using a loop would be the best option. Here, I would flatten the nested loops as far as I can then loop through to add them to the tree. To compact it even more, create a factory method to create the nodes. Even more useful if you have a lot of properties to set. 

Otherwise use a switch statement if the mapping gets too unruly or you want to map multiple combinations to a single value (it's not necessary in this case). 

And to a lesser degree, a call to with parameters should be printed a single line at a time. The newline characters sprinkled in the format string makes it less clear how many lines this will print out. Do this: 

For operations that alter the structure (i.e., add or remove items), it will accept an object to modify and return the modified item. The modified item may or may not be the same exact object that was passed in, depending on the operation you're doing and the state of the object (more on that later). You might be thinking your function does something like this: search through a list to remove an object. Instead, you should be thinking of your functions like this: given a list, return a list that has an object removed from the list. They will be recursive usually doing some operation on the first object in the collection and recursively be called on the rest. The recursion is what drives the code so you generally would not have loops going through the collection. That's not to say you will never have loops, you might have loops going through a subset of the collection, just not the whole collection. Being recursive, the function will perform different actions depending on the state of the object so you'll usually have a set of / statements (or if possible, ). Ideally there'd be only 2-4 different conditions at most. The key is that the conditions should be as general as possible. i.e., have cases for an empty collection, one item and more than one item; don't have cases for an empty collection, one item, two items, three items, four, five, etc. 

Suppose you kept track of your balance at the bank for every day in the month. You'd have data such as this:How would you determine how much money you earned/lost between day 1 and day 2? How about day 2 and day 4? Is there a way to represent this problem in a similar fashion? Think about what representation of your information is really important here. Your code stores a collection of points. Whenever you need to perform the count, you would have to determine what quadrant the point belongs and increment to the appropriate counter. But do you really need to keep track of the coordinates for each point? If you represented the data in another way, would you still be able to perform the three operations that are required while still maintaining the information you need? What would that representation be? 

That is a great start. It's almost perfect logically. First thing that caught my eye however is the lack of indentation. It could just be that something got lost in the transition between your code and your post here, I don't know. But you should indent whenever starting a new block. You indented the bodies, that's good, but you missed the function body of , the block. Had you done this, you would have been able to identify the following problem in your code. The body of the while loop consists only of the first statement that is counting newlines. You are effectively counting only newlines and not counting the blanks or tabs. This is how you have your code written but let's include some correct indentation: 

I'd be weary of solutions that builds the HTML by hand. Work with the DOM and let it write out the HTML for you. HAP can do that for you. Don't create one-time use extension methods. It appears you created an extension method for strings to encode your titles. If you can't use it anywhere else in your code, it doesn't belong as an extension. I'd argue that it should be a regular static method of your class as it might be specific to how you want your headers encoded. In this context, it is confusing to see that call there. Your logic in your headers to get the "sibling number" and TOC prefix is more complicated than it needs to be. Especially the method, the logic is very confusing to glance at. I was having a hard enough time trying to figure out what it was doing. The string reversal at the end really killed it. They both could be done simpler. In fact, they could be calculated at once on construction with some refactoring. That leads in to the critical thing that's missing in most of these methods, comments... there's not a lot of useful ones in there. Your comments should be explaining what is happening in the code that couldn't be determined at first glance. The code really should be self-documenting. When it isn't, you need to say what it's doing in comments. But no one cares that the next line will add some item to a list. You should me saying things like, "we need to ensure we don't have an empty list because..." or at least explain why some actions are needed. I did a lot more that I thought I would do but I would rewrite it more like this. p.s., I don't know what your HTML would look like so I don't know how the nesting actually worked. But this should give you an idea how it could be better implemented (IMHO). 

It should be pointed out that there are methods to retrieve custom attributes in the framework now as of .Net 4.5. See the CustomAttributeExtensions class. This should simplify the extension method a bit. It might be worth changing the name of the extension to as well since it will always be a custom attribute. 

So after our little discussion, I hope you see that you're missing some key cases here, when the given is . Some things that should be pointed out, when comparing to , you should be checking if it or . Don't use (in)equality here, it is just not correct. Assuming this is a method on your tree node objects, I'd rewrite this to make use of . That way we don't even need to worry about the case when is , that just shouldn't happen. 

Now there's some minor style issues in your code. You can follow these if you wish, it's just personal preference. But it could help other people read your code easier with little chance for confusion. Your variable declarations should go on separate lines and the initializations of the variable should occur in the declaration. I'd also pluralize the variables since they are used as counters. In your head, if you read out the values of the variables what makes more sense? "I have 5 ," or "I have 5 ? The comment was off a bit, we're not initializing here, just declaring it. Do this: 

First of all, don't reuse variables to hold values that represent different things. That only makes your code even more confusing to read, especially if it spans many lines. You should declare a variable for each different use you have (a set of variables for today, tomorrow and after tomorrow). That might be a sign to move some code into a separate function in those cases. The query is the same all around, only the date ranges change so you should put them into a function to minimize repetition. I would write it like this: 

As a side note, you should have separate functions defined to perform the different node manipulations. e.g., functions to create/initialize a new node, to destroy a node, etc. You will need to perform these operations a lot so there you should minimize the amount of copy/pasting to do these. Though this is C, you should follow C naming conventions. You shouldn't use , but rather (I don't know if there's a name for this convention). I'd recommend naming functions in this form: . Personally, I'd create s for your types rather than using raw s, makes things easier to use and cleaner IMHO. To rewrite your remove function to follow this form, it would look more like this: 

Any time you override the equals method, you must override the method too. Use an implementation something like this: 

Consider renaming to something that would indicate it is a . I'd usually go with something like . You already did that for the constructor parameter and property, I don't know why you didn't do the same for the field. Your method should not ever throw exceptions. What would happen if you passed in something that was not a ? 

On the other hand, since your inputs are constrained to up to 50'ish, you could just use an array (and not an ) for the lookups. 

Your code is very difficult to read. (To give you an idea of how difficult it is, I've been looking at this for the past 2 hours so far) 

If you can answer these, I'll expand more on my answer and we'll probably work out a nice solution together. I'll probably share my answer too (though I haven't actually run it against their tests). 

You can rewrite it with two separate comprehensions. One to generate the values and one to filter them out. You can use to get the cartesian product. 

Calling any function in general will give you a small (miniscule) performance hit. Recursive functions (AFAIK) cannot be inlined so that can't be optimized away. LINQ revolves around calling other functions so that's the worst choice to make if you want to write good performing code. I've said it before, LINQ is not for writing fast code, it's for writing concise code. This is a simple algorithm that doesn't need to be bogged down by that. * It doesn't help if you don't use LINQ correctly, you have a number of no-no's in your code. If you want the fastest approach (without resorting to mapping out all possible values in memory), you'd stay away from these and do a more direct conversion. To be the absolutely fastest, you have to get down low-level and use (unmanaged) code. I won't go there. On the other hand, if you want fastest managed code, you'd want to do this iteratively. In any case, my proposal is not a claim to be the fastest implementation, it could very well not be but I don't know, you would have to profile it to find out. We're doing a base conversion from base-10 numbers to base-26 "numbers". I don't know if there's a faster algorithm to do this but here's a straight conversion using a as a buffer. 

To splice the string in general, this would be faster and more efficient then using LINQ or other methods. 

If you know for sure that the types that are used here can be converted from a , then you could convert back using . 

I find it easier when working with hierarchical data structures that the functions you write should be written recursively to make your job as simple as possible. These types lends themselves well for such methods. The typical structure for such methods will usually have this form: 

Well here's my take on it. If you want efficient in terms of speed, write a loop. LINQ is not for writing fast code, it's for writing concise code. is just a collection of the memory counts of all the machines that are on. You then essentially partition those machines by some to do some calculation. The call to , while somewhat helpful (you do the filter/projection once) isn't really needed. You can perform your calculation in one pass and therefore don't need it at all. Look at the following lines in your calculation: 

Within a conditional, it would depend largely on the type of the object. In general, I'd favor the first form, particularly if it is a non-string reference type that doesn't offer a nice default value. Otherwise if it was a or nullable structure, I would prefer the second. I'd be very careful instantiating new objects only for doing a comparisons like this. It's rather wasteful, especially if you have many comparisons and the object isn't very cheap to instantiate since it's being thrown away. In this case, it is a nullable ( apparently) so it would be cleanest IMHO using the second. 

Converting back to the generic type won't be as straight forward. When casting between an and a value type, no conversions will be made and you are just boxing/unboxing the value. Since you have a constraint that the type be a value type, the casts won't really work here. In fact, I don't think it's even possible to do so generically. If a conversion exists from to the type you wouldn't be able to express that here. And you won't be able to use the Convert class to do the conversion, there's no way to "add" conversions to existing convertible types. Your best (and probably only) option would be to convert it to a variable and let the runtime figure out whether or not that conversion exists. That way if you have a custom here that has an implicit or explicit conversion from a , it will be used.