"want" / "did" "want again" / "did" (active) "want" (active) / "done" "want again" / "done" (active) "want again" (active) / "done again" "want again" / "done again" (active) 

Finally, we have to consider when to make each button active. If we clicked the done button first, then done will be active when the done count is greater than the want count. The opposite is true if the want button was clicked first. As a special case, no button is active if the want count and done count are zero. 

is always one less than size, so you don't need that variable. Just replace all instances with . Similarly, could be replaced with . 

Acknowledging the state machine, look at the "want"/"want again" button. The text will always say "I want to do it again" after the done button has clicked. Essentially we can boil it down to this: 

To guard agains the previously mentioned bug, we need to check if not null. I'm including only the function. 

Speaking of, is defined as , which only works for elements with an ID. A broader solution would be to set target using '$(this)': 

The path is one of these two options. In the first path, done is clicked first. In the other, want is clicked first. 

If we consider these two buttons a state machine, we see that there are six simple states (not including hover). 

Moving on to the "did"/"done"/"done again" button is a little trickier. "I already did it" will be visible so long as the want count is 0, and "Done it again!" will be visible after the want count is 2 or greater, but "Done it!" is more complex since it only shows up on one of the state machine paths (step 3/4). It turns out it is visible when the want count is 1 and we did not click the done button first and the done count is 0 or 1. This all leads to this block of code: 

On top of the comments provided by Billal BEGEURADJ, you also have the possibility of a stack recursion error in your code: calls calls calls calls calls calls And calls To fix this it may be worth making the game get started from outside of the class in a loop: 

Following the review of my old merge sort implementation here, it appears that the biggest improvement to make was to use iterators instead of copying the s. Having never used iterators before, I'd like a review of the new code following that review: 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

Edit: Thanks to @ratchetfreak for pointing out a bug whereby I was overwriting elements of without storing the overwritten element elsewhere beforehand (essentially losing it). 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

Finally, you have several magic numbers. To make code maitenance easier, define variables for constants like colors, strings, and timeouts. 

The only part missing from that match is the end, the last . I would use another regex match to grab that portion: 

Generally speaking, anonymous (unnamed) functions are completely acceptable within the land of Javascript. They are used frequently and without prejudice, so don't be afraid of them. That said, I'm not a fan of the second code sample. Without an understanding of the jQuery API, I don't really know what the two functions do to the hover call. Are both called, one after another? Perhaps something else happens? The name doesn't really give any clues here. I think a great option here would be to combine the two samples. Use the anonymous functions of the second with the explicit naming of the first. Furthermore, it should be noted that according to the docs, is shorthand for and , not and . I'll let you read over the docs and decide which of the two you decide to go with, but ultimately I recommend going with something like this: 

Brief aside: If this script is only to list the instances for you, you might find it useful to check out the and the tool: 

Honestly, your loop doesn't seem that complex. I would probably ignore this warning in your case, at least until it grew in complexity or the surrounding function grew in size. In any case, here are some things you could change: a. Add a variable to replace the five instances of . b. Off the top of my head, I'm pretty sure an EC2 instance is only going to have one "Name" tag. You can extract this loop into a separate function if you feel comfortable with this assumption. c. If your lint rules / personal style allows for multiple returns, you can reduce the depth by returning from the error. 

I'm working through some Project Euler problems using C++ and some of the numbers in question are starting to get quite large (21000 for Problem 16) and I need to add some of these large numbers together, so I quickly threw together a string represented (positive) integer adder: 

As part of a first year university course in computer architecture some time ago we were tasked with learning 8086 ASM. The final course work required creating a small animation of shapes moving around the screen changing colours and the like. As I would not expect anyone to review 720 lines of assembler I'm just going to provide my implementation of Bresenham's Line Algorithm. Note that this is not the entire program but a single macro from the working program. Also note that at the time of writing I had little to no experience with 8086 ASM (I still don't in fact), but I'm very interested in knowing how I did and how it could have been improved upon. If anyone is interested in reviewing the rest of the project as well (it can be done in small parts) then let me know. 

Will not come out as the numbers they represent but can be reconstructed later on. But sequences such as will come out as making it easier to account for multiplication of variables. Questions For the most part I'm quite happy with this code, a couple things that I'm interested in (alongside general review) are: 

I'm aware that not all op-codes have been implemented as I have only implemented the ones needed to get the 15 Chip8 games that I have copies of running. The code that I am most interested in having reviewed are the chip8.h and chip8.cpp files however I have included (the majority of) main.cpp for completeness. An update that I would like to work on would be to switch from using a statement to using function pointers but would like a hard review of the current working code before I begin with that. Thanks to this tutorial which I used to get started and for opcode . chip8.h