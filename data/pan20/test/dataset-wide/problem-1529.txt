This should be one of or because otherwise any pair of points which is rejected as a major axis will be tested a second time with the indices reversed, doubling the workload. 

The next trick to consider using would be a implementation which wraps the original string and an offset for the starting character. 

Assuming Processing doesn't diverge too far from Java, is equivalent to , and I find it more readable. 

I find the variable naming a bit counterintuitive: why not name the variables in order and require ? But more importantly, the two calls between them take \$\Theta(N)\$ time, so the entire loop takes \$\Theta(N^2)\$ time. It would be asymptotically better to pre-calculate lists which give the minimum value in each prefix and suffix, because then the whole thing can be done in time \$\Theta(N)\$. 

Here you could have an early-abort if the partial digit sum of prime factors already exceeds the digit sum of the original number. That same idea carries over into the suggested rewrites of the method. 

As rolfl commented, this is a useless comment. Logarithms and are far more basic concepts than Bloom filters, but you haven't tried to define Bloom filters anywhere. A useful comment here would be a literature reference to justify the estimate.   

There's no point passing in because the task ignores it completely. ( would test whether the token has been cancelled before calling the action, but if the timeout is happening before the action is called then either the timeout is far too small or there's a much bigger problem to fix with server load). There isn't actually a method, so you can either forget and use a different synchronisation method; or pull in either the token or directly from the outer scope. Bad practice is , but neither of the methods which create an instance are disposing it. Since its scope is clearly defined, the best practice would be a statement. Overcomplication Two s just to handle a timeout for a single task, when you have full control over the task's source? It seems to me that the KISS approach would be 

exposes far more than is necessary. If you make that private then a public method can call it with the appropriate initial values. Names 

This reinforces my first point about the type: the result is returned as a return value, but a very close approximation of it is also returned as a side-effect, modifying the argument! There is a case to be made that in computer algebra systems the majority (if not all) of the objects should be immutable, and the functions pure. 

First, in terms of general code review, that bundle of arguments makes me this that it would be worth refactoring to extract an object. If the class is non-static but has a private constructor then can become the only way to construct an instance from outside, can become an instance method, most of the body of can become another private instance method, and the state can be stored in fields. 

Full marks for honest commenting, but you may not have realised that you're making a dangerous assumption. What if the image isn't of ? The more robust way of doing this would be to create a fresh for each image, using to create an appropriate for each one. 

There's no need to pattern-match a structure if you're not using the structure. This could be simplified to 

Pretend for a moment that we're not using . The benefit of with something like image processing is that you can keep the CPU busy even when one of the coroutines is blocked on I/O. But half of the I/O has already happened (maybe more if you're always scaling down rather than up). If you want to make an async version, the image load should be async. 

This code aims to be simple over being efficient, although there are some efficiency considerations. It uses a for testing membership of the excluded set rather than iterating through it, and it uses to avoid duplicates. The next efficiency complication to add would be using and to quick-reject cases where we will certainly exceed . 

It took me a while to figure out what the purpose of was. Given that you're using Linq, I can't see any reason not to just implement as 

Yes. The decision variant of this challenge is the subset sum problem and has a well-known dynamic programming solution. That solution is easily adapted to give counts rather than just Booleans. In pseudo-code: 

Never ever ever open a file for reading or writing characters without explicitly specifying the encoding. You'll think it's all working fine and then someone will run your program on Mac OS X and send you a file encoded in MacRoman because that's the default on their platform. Yes, I learnt that one the hard way. Unfortunately the Java standard library tries to make things "easy" by hiding access to the encoding and ends up making it hard for anyone who wants to write portable code (supposedly Java's strong point). You can't use , because none of its constructors have an encoding parameter. You have to create a and wrap it in an . is similarly useless. 

Any particular reason for returning instead of ? What's the purpose of the call there? It's easy to prove that it always returns (and so the method isn't needed at all). As a point of style, I prefer methods, but this is really subjective. The loop guard might be more intelligible as . 

How to achieve optimal asymptotic performance? You need to arrange for the insertions to be done in order. I think that probably requires some additional datastructures. The simplest approach conceptually is to have an array (or a list in Python terms) to store the characters in their final positions and a datastructure of unassigned indexes which allows fast selection of the maximum element and a random element. In Pythonesque pseudocode: 

would be nice. I'm not convinced of the benefit of renaming to for a scope in which doesn't change value. Since you have , you could break out of the loop if you've converged before iterations. I would expect this to give a significant speedup. 

The registration form asks for an e-mail address. Why? If you don't use it, don't ask for it. If you do use it, does your security model not require it to be correct? So shouldn't there be an e-mail validation step in the registration process? 

Code to the interface, not the implementation. The type of the field per se should be an interface: maybe , maybe , or maybe even something else. With respect to maybe even something else: should it be ? The explanation given for the use case suggests strongly that elements should not be repeated, because if they are repeated it's going to be complicated to avoid playing the same track twice in a row. 

That's confusing. Using when the comment delimiter is just also makes me wonder whether there's something odd going on, and that's not the kind of question you want a maintenance programmer to be asking. Spelling 200_success already pointed out in comments that igonre is incorrect, but so is peformed. If you don't have backward compatibility constraints which prevent fixing it, I suggest fixing it. Capitalisation Most of the SQL keywords and MySQL built-ins are capitalised, but not all. In particular, why rather than ? 

and then observe that if is in the set, it's either greater than the least element in the set or equal to the least element in the set, so I think it's valid to refactor further as 

The code which follows looks like a linear search, not a binary one. Is this comment a statement of intention which was forgotten when the code gave the right answer? 

Since we have to convert to a list here, there's an argument for doing it earlier and ensuring that we only iterate through once, solving the problem of non-deterministic iterators. 

The code is pretty consistent with whitespace, which is good, but it seems to follow a style document which makes some unusual decisions. In particular, I would highlight the ternary operator and the traditional as two places where I would find the readability improved by the addition of whitespace. 

Looking past the syntactic sugar, that's six public methods (three getters and three setters). How many of them should really be public? I think that at minimum the setters should all be private, and I see no good reason to expose at all or to allow an external class to get and then mutate it. I would prefer to publicly expose just the equivalent (see below...) of 

Two things here: firstly, since the sorted values are only needed in one branch of the it makes more sense to push the sort into that branch. Secondly, 

Be nice to the maintenance programmer, even (especially?) if you expect it to be you. If you're mixing characters which are visually indistinguishable but don't need to be literal self-representations, you can use Unicode escapes and hexadecimal offsets as so: 

which is the naïve recursive definition, and a classic teaching example of how naïve implementations can be insanely inefficient. Your answer meets the rather vague spec (it is recursive), but is much better than the intended solution because it takes linear time (or maybe quadratic if is linear, but I doubt it) rather than exponential. If you want an additional challenge, here are two: 

Why ? Following the principle of coding to the interface rather than the implementation, this should probably be or even . 

I'm not entirely sure whether there's something subtle going on here which needs a comment, or whether you've misunderstood the meaning of . This method doesn't just start the thread: it waits for it to stop. It might as well ditch the thread and do the calculation directly. 

The is completely pointless: a loop over an empty enumerable does nothing: it doesn't throw an exception or whatever error you're trying to avoid. 

Python style is to use lower case words with underscores for variables. I don't see the benefit of creating new names for the defensive copies. IMO it's safer to reuse the name of the parameter, because that way you can't accidentally modify the original dictionary. The names and sound like in- and out-parameters. The comment explains their meaning, but I think there are more transparent names, such as and . 

In answer to your question as to alternative ways to make your subject pick up the changes: there are two options which I'd use before reflection. The difference between them is the direction of control. Option 1: callback. Make the static method take a third argument, probably of type , and call that action instead of . Option 2: event. Give an invoked by 

The effect is to guarantee that no track will repeat within of the previous time it occurred. You can then make settable with a public property or derive it from according to some hard-coded policy (e.g. a fixed percentage). 

This is fine until someone uses the class with a which overrides . In an object pool you care about object identity, so this should use . (NB the above line occurs twice). 

This isn't really production code, is it? There's an obvious test method which is testing a private method. What should be the API? The chunks of five are returned as 

seems like a lot of implementation detail for the javadoc. I would be inclined to inline into this method, rename it , and simplify the javadoc to something like 

To use properties rather than fields; To make the setters private, and move the clone method into ; Since the specification doesn't say anything about the contents, to parameterise as rather than forcing the contents to be (although maybe you clarified this with the interviewer and forgot to include it in the question). 

What about ? If you store that you greatly simplify the update to , because it's simply a case of adding the of the selected parameters from the accumulator rather than repeating the calculation to determine which points are on the ellipse. 

(Of course, this has a hideous magic number, but it's not much worse than the in the one it replaces). 

The function is very long: it's probably worth at least pulling out the solution search routine. But beyond that I'm not going to comment much on style, because I'm not a Pythonista and others can do it better than me. 

I agree with Peter Rader that static factories are not a good pattern. For this particular task I would be inclined to use a builder pattern. In particular, I would quite like to have a varargs parameter somewhere, and IMO the cleanest way of doing that would be for it to be the sole parameter of a constructor. 

Suppose that we call it with a set of \$n\$ elements. The outermost call produces a set of \$2^n\$ subsets by taking the union of \$n\$ subresults, each of \$2^{n-1}\$ elements. So the outermost call discards as duplicates \$(n-2)2^{n-1}\$ subsets. But, of course, each of those recursive calls discarded \$(n-3)2^{n-2}\$ subsets from their subresults, etc. This is why the typical simple implementation is to build up from the empty set. An advanced implementation, which isn't always better but can reduce copying in some use cases, is to write a custom iterator which uses a Gray code to add or remove precisely one element in each call to .