so now my tests pass again. Oh but I have duplication again, but no longer in the start position, now it is in the end position. Since I know it is there I can remove the check in my while loop and make a slight adjustment in my duplicate change in index. My final outcome is something like this. 

I made a Player class which has a string called , and a Color called I have an array of and switch back and forth which one is current. This allows me to loop through each player checking for a win, and if no moves are left showing the user it's a draw and returning true. Might be worth trying to replicate what I did. 

So that is all I have. Normally I'd go on a rant about TDD and creating tests and so forth. And i still want to, but I'll let someone else cover it. 

I like this concept that you make it easy to get a count of either gender... but a string??? what would happen if you asked for or any other combination? What if the file itself is not standardized. This would have been much better as an Enum. then you can parse the file and know that you have a type safe version of it to group by. 

overal that is a bad test. Mainly because i'm not asserting anything nor am I checking that what was serialized is what was deserialized. That's cool we can work with that. So now lets write my test the way I want my code to work. I want to take a clubinfo, serialize it, then using my deserializer I want to check that it gave back the same values. 

First off there is a minor bug. In the constructor of you call twice. Inconsistant Naming There are a few instances of names where they don't match either capitalization or naming. For instance in : and . One is static the other is not but the naming convention says they are the same. Similar thoughts for , , , and . Also some of the names of the buttons and check boxes in are not consistant with their name. vs Long Methods You know that long methods are hard to read and understand. You said in your code and you said in your post. This is probably one of the hardest things to do in programming. Although the concept is easy to help in the area it is also the area that requires a fair amount of work and understanding. The trick to it is learning how and when to use design patterns. I would recommend taking a quick peek at DoFactory's list of design patterns. It isn't exhaustive but it has enough to keep you busy for a long time. Some of the more simple ones though are pulling out methods that are similar if not duplicate. For example in you this button click event: 

I create a new instance of a box, and pass it in immediatly to BoxChanger. BoxChanger is this very simple classes: 

Although you are doing it correctly, a part of me wonders if it was the correct solution for you problem. The reason I ask is because a interface usually means that each method that you define is going to need to be implemented differently for each sub class that implements it. In your case it doesn't matter what type of person you have they will always introduce themselves the same way, and they will always say their name the same way, and they will always tell their age the same way. That being said an abstract class would have been a better choice because the basics will be the same for both parent and child (and even if you decide to add another branch of a person) for things such as their name, and age. The introduction would possibly be the only exception if you added a culture to this mixture. Since different cultures introduce themselves differently in almost all scenarios that would be a good candidate for a interface. 

However passing in an integer to the sort method is not very clear. What I mean is that, without looking at your code can you tell me what number is needed to sort by for each property in ? Nor would I want to. Even if you were to put a good comment that described very clearly what each number represented, it's still not clean. No instead make take in a Then your code could look like one of two options. 

Since you mentioned a programming class, I find that most students would greatly benefit from learning about Unit Tests. It isn't often taught, but I believe it should be. One main reason is that it forces you to be make code that is able to have automated tests. Automated tests are awesome because they are fast, and give you feedback if you made a mistake or not. There are a few prominent approaches to writing tests and the purpose is to not make you use a specific one. I can say that I prefer to write my tests first then write my production code. I do it this way because, for myself, I name methods a bit more with english in mind than programming. This takes a small amount of brain strain out of programming. (FYI the paradigm I mention about writing tests first is TDD, but like I said there are a few other ways of doing it they all have their advantages and disadvantages). So although it may seem trivial to write a test for a calculator one thing that it could possibly do is make choosing where you show your output even more trivial. (I've read in a few of the answers people mentioning where they would put the output.) You mentioned how you want your code to flow so I will focus writing a test that matches what you wanted. (Note the final code is almost complete, just need to finish implementing the operators.) IntegerCalculatorNGTest.java 

Think small, Think one What I mean is that breaking up things into smaller chunks that all do one thing and do it well helps in so many ways. Now granted it can be taken too far, but for the most part if you break things down into something sort of vague and build from there. For instance if you think of uno as a few things such as "Game Rules", "Cards", "Players", "Deck" then you would at a bare minimum start with 4 classes. Those 4 things would do one thing and do it well. Like lets take Game Rules. You could have started with it calling each player in order and asking them to take their turn. It could have kept track of the deck and gave a player a card when it was requested. It could have also shuffled the deck of predefined cards (like it sorta would have been if you buy the game). After each player it could have checked if said player won or not. This would have made the class kind of big, but now maybe you could have seen that the user input is what is bloating the class. So you could have pulled it out in a user input class of sorts.. so on and so forth. The point is that if you think of the individual moving parts of a system and start there and work your way down while keeping in the back of your mind that you want things to stay small, and they should be responsible for one thing and one thing only then your code would look very different than it does now and potentially easier to understand at first glance Magic Numbers Magic numbers are numbers or string literals (for example: ) make a person wonder. "What does 12 mean?" or "What does 13/14 do?". You asked that question to your self at one time because you put a comment in to tell yourself that 12 means that the card is a Draw 2. So instead of putting 12 why not make a class (abstract class if you want, or maybe an enum) that contains some these magic numbers it takes the guess work and the comments out of your code. I imagine it looking somethign like this in one case 

if the result is authenticated you redirect your action. But if authentication was not successful then you don't return anything??? that is how your code is phrased. Obviously next line is where you return a blank View, and you comment that if you get that far that something failed and you want to redisplay the form. You do the exact same bit of code for register. If you find exact duplicate code like that it would be better to pull it out into a method and give it a useful name. I chose this 

Side note The link you provided was to the wrong project, but they are right next to each other. I scanned through the website that you are learning from, and the project Address book is found in the ArrayList section but there is no reference to the ArrayList type. $URL$ "Java doc for ArrayList". Not to be harsh, but if I was the teacher I would be requesting a re-write. Using inner classes can very rarely be useful. This is not one of those cases. Entry has a proper place in the project as you use it as a data model. Making an in your Book class would be clean and to the point. The Book class itself will become very easy and clean when you switch to ArrayList. For instance if you decided to use lambdas and kept using the number to sort your entries your code would look something like this in your 

The test class was autogenerated in my IDE so don't worry about it too much. Just know that with JUnit you mark methods that need to be run to test your card with the attribute. Now I can think about what I want my class to do. If no player file with that name exists I want it to return null. If it does exist I want it to return that player; If that file got corrupted I want an exception thrown. with those in mind I wrote the following 3 tests one at a time. After I finished writing one test. I worked on it until the test passed then wrote the next one. 

problem with this is taht anyone can change TotalCapacity. also why does this class care how to calculate remaining fuel. Your concept here is to use some gas, and then get the percentage left. so make those methods in the class and don't expose your fields. (To see the point even more ask around and see how many people know the exact figure of fuel that their fuel tank holds) Unit tests I think the best way to make your code reusable is to write unit tests. How/Why? When you write tests it gives you a safety net to go in and change things without the worry of breaking how the logic works. Also it points out areas in your code that are pain points quickly. Above is mentioned that changing how you display this game would be a HUGE pain point. Lets imagine for a minute that your game used a GUI instead of the console, AND I started writing unit tests to show that the strings are lining up correctly. Are you going to expose all your TextBoxes so I can from them? Yuck! then when you go to change them because of your test you'll end up throwing something (physically or metaphorically). Normally the first thing to get thrown is the unit tests. But dont! Lets consider your DeserializeDemo and SerializeDemo code. Those two bits are prime for unit tests (as they can easily be tested as they are). You'll also get the benefit of not having to run your code to test if they work. This post isn't to tell you how to write unit tests.. There are countless blogs/videos/demos out there on how to do that already! So here is my test. Simple and to the point. 

In my comment I mentioned that this frame looks like a demo of what you are trying to achieve. After diving into the code though I feel compelled to mention a few things that will make what you are trying to do hopefully easier. First thing is to use methods to help make clear what you are trying to do from a higher level. Here is a small idea that I've been playing with 

Separate Concerns The very first few lines in your code for startup and use a . While that in of itself is not wrong, how you use them is not right. Ideally you should at the bare minimum pull out the stuff into a new class that returns a . being a new class that has 3 properites (guessing by the code you provide). We do this for a variety of reasons. One is that we want a class to do a single thing. In this case we want this class to give us all the Fields on this form with a small amount of information about each. There are many approaches on how to do this, and how to make it testable so I won't go into too much detail about it. But just know that just doing that makes understanding your code MUUUUUCH easier. For instance now my code would read something like this