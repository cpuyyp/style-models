creates an array of separators that is passed as the argument in when the middle name or initial is to be included. Each element of that array is the (string) value of bracketed by a separator (except in one case where the initial is converted to (). For example, 

It remains to construct the method to return an array similar to above. As I've rambled on awhile, I'll leave it to others to cover that. 

I don't know if you really need to create classes for checking each of the substrings in the file name prefix. After all, there are only two types of checks that need to be made: against a list or matching a regex. Consider a simple, straighforward approach like this: 

If we cash out at the end of day , the net gain is . For example, if we cash out on day , the net gain is (). Therefore, if we enter the market on day , we maximize net gain by computing: 

It takes a couple of seconds to generate the hash, then each random string takes very little time to generate. [Edit: Flambino pointed out that it makes more sense to use an array: 

and instead of a sequence of vectors, we'd get back a sequence of maps with keys , , and . This usage is totally unrelated to your original intention for this code, but it shows how generally useful the function is—so why make it private and hide it where no one can access it? Let it out and see what uses people can find for it. Finally, for such a small program it probably doesn't matter, but one of my favorite features of Clojure is docstrings. I would write one for any function I was publicly exposing: 

would call with as the value of and as the value of . The more complex way to do this is to use the module from the standard library. If you're sticking with all positional arguments, then reading directly is probably fine. You can do something like 

Not to be excessively negative, but the solution in the C# code is much cleaner than the one you implemented. No shame in that; it happens to all of us. But I assume you wanted some advice on making the code you have run faster, because if you just wanted to copy that C#, you easily could have. So that's the direction I'll go with the rest of the answer. It honestly puzzles me that this code is so much faster than yours. I would have expected the BigInteger math to be the really slow part, but this code does the same amount of BigInteger math as your original code. Your code does take quite a bit more memory, since it stores all the Fibonacci numbers it calculates, whereas this code only stores what it needs to calculate the next one, and uses an integer to count how many Fibonacci numbers it's seen so far. An array list is backed by an array, so actually accessing the items shouldn't be much slower than with a plain array, but there might be some kind of cache or memory allocation effect. With this code, the compiler can block out a single, static chunk of memory. In the original code, the that stores Fibonacci numbers keeps on expanding, so the backing array might have to be reallocated several times. Every time the array is reallocated, everything stored in it has to be moved over to the new storage space, which is pretty slow if you have a big list. If that turns out to be the problem, you can try passing the constructor a guess for big you think the list might get (the default size is ten). If I were you, I would profile the code and look for some issue like that. Dig into the implementation and see if it's spending a lot of time reallocating. Just see where the code is spending its time, and try to figure out why that's where it's spending its time. If you don't already have a profiler you like, Netbeans has a pretty good one built in, and I'm sure Eclipse and other Java IDEs also have them. If you profile and post some of your numbers, we can probably give you better help with diagnosing performance issues. EDIT: @ChrisHayes discovered why the code is so much slower: it's the call. I took the original code and just replaced the call with a check against a limit of \$10^999\$ as the C# code does. Still used the array list, still stored all the Fibonacci numbers. As Chris Hayes observed, this reduced the runtime from about 900ms to about 13ms. The author of this blog post also found that was quite slow. An answer on this page implies that BigIntegers are stored in a way that makes it easier to implement the method that lets you convert a BigInteger into other bases, like hexadecimal or ternary. One could apparently implement in a more specific way that makes it quick to convert into a base-10 string, but difficult or impossible to convert into strings in other bases, but the standard library implementers chose a representation which was more general, but slower to convert into a string. See the end of the answer for my final version of the code, including modifications I made to get rid of . [/EDIT] Aside from the performance issues, I had some readability issues—not that your code was unreadable, just that it was harder to read than it had to be, and that contributed a little to the confusion that we had over where the number 4872 was coming from. The biggest one is the variable . Unless you're working with coordinate axes, please don't call variables . The C# code gives the analogous variable the name , which is better, since you can tell it's probably some kind of counter. In general, that C# code is quite clean, so it's a good model to learn from, though I'd probably just go all the way and call it . could also work, since it's traditional to index the Fibonacci numbers with . (This is another reason why is confusing; if I'm reading a program about Fibonacci numbers, I can process or the like pretty easily, but is just strange.) I also found your use of the do-while loop with a boolean flag confusing. A or loop with a statement would have been better, but I think the best would be to let the do-while work for you, and write something like this: 

You can invert the if-condition and thus make the code shorter. The else is implicit. The parantheses around the condition are not needed and usually not used, since without them it reads more naturally. 

and the other actual variables are a bit confusing. What other lifes can there be? Metaphoric ones? Better call it , because it is the current state of the object. Also, reads more naturally than . The latter even sounds like a noun. 

Rethinking the architecture Every class should contain its own information. If it needs any further information, it should always be given to them, instead of it taking it from elsewhere. The input, which you handled in the class could be moved to its own class. This one could have some static methods to ask whether a key is pressed or released. Then you do not need the class to change the paddles' velocities on key press. Following I will try to rebuild the architecture so that it is more modular. There are surely multiple ways to do this right. I will omit parts of the code that I think you can do by yourself and might be a good practise. Also I will add some comments to explain my version. The code will not run like this and should only give you an idea how you could structure your code. The game class: 

This alternate calculation of is not especially interesting in itself, but note that can be computed: 

This saves all those methods in the class instance variable . One could then use the earlier approach to make the validity checks that draw only on the information in , and cycle through to perform the others: 

but only a fraction of these are shown in the documentation. Perhaps a reader could provide an explanation. In any event, the two methods I mentioned are used as follows (when applied to @Ben's example): 

Though I am not a professional developer, I will venture one suggestion: learn how to use String methods and regexes to fullest advantage. Sometimes it is necessary to use , , etc. to convert a string to an array of strings (possibly single-character strings), manipulate the array elements, then re them into a string, but there is a lot you can do by working on the string directly. Here, for example, you can use String#gsub with a block: 

Your first question was answered nicely by @sockmonk. You could have written , which, though longer, is arguably clearer. Regarding the second question, I suppose that's a matter of individual preference, but I am happy to use a ternary operator when it fits comfortably on one line. One reason is that it reads fasters than an clause or statement, as we humans have greater experience reading horizontally than vertically. @200_success makes an important point in his comment on the question. For the example he gave: 

I'd like to echo the comments: it would be really helpful if you told us what this code is supposed to do, exactly, and maybe explained some of the pieces that touch on what you have here, like what type is and why you chose to represent it that way. In your second code snippet, you have this section: 

Then you can call instead of and instead of You could also put a inside to make things even shorter. These changes give you a kind of API to shorten and simplify interaction with your game state. Here's what those helpers would look like as macros. (Hopefully; I'm far from a macro expert.) In this case, since we're not doing anything special with the order of evaluation, the macro version of looks exactly the same as the function version. 

I recommend against having print statements inside classes. One of the benefits of classes is code reuse. Having print statements inside class methods makes the class less reusable. Some of these can just go away, or they can become logging statements if you want. The ones inside your clauses should probably become rethrows. They can also be logging statements if you want. I would probably write it like this: 

Yet another capitalization style. This should be . Probably it should even be something like or , or something similar. But then it should be returning a boolean. 

Built-in functions You don't need the function, as Python already has one. It is called . Boolean expressions If you return a boolean value based on an expression, don't write 

Note that your is equivalent to , and since is exclusive on the upper bound, this gives you numbers between and , which I'm not sure is what you intended. 

First of all, something regarding usability: The player has to press space to start, space to play, but click to restart or continue. If you were using space for all of these actions the player wouldn't have to move the hand between mouse and keyboard. Also, you are telling the player to press space, but actually any key will work. 

This can be done clearer by concatenating the output and do one single println call. Don't forget to add newlines (\n). 

What is ? What state can a lock have? The one state that is meant here is whether it is locked or not, so just call the parameter instead. Instead of defining that variable , whose name does not really explain what it is for (probably something like "delta", so might as well write ), and than only using it to subtract it from another value, just assign the result of that subtraction: 

Think of it this way: is there any way to count the number of distinct elements without actually looking at every element? (More accurately, without looking at some substantial portion of the elements?) If not, then \$O(N)\$ is the best you can do, asymptotically. There might be other optimizations you can make to speed things up in wall clock time, but the algorithm is as fast as it can be. I suspect, though, that your code isn't actually running in \$O(N)\$ worst-case time, because I suspect that adding an item to a Java TreeSet is an \$O(\log N)\$ operation, since I think they're implemented with Red-Black Trees. If you process \$n\$ items, and each time you process an item you do something with it that takes \$\log n\$ time, then your algorithm has worst-case complexity \$O(n \log n)\$. A Java hash set, which uses a hash table, should insert in \$O(1)\$ time, so your code would run in \$O(N)\$ worst-case time if you used a (as Simon André Forsberg suggests too) instead of a TreeSet. In general, I think that's the best you can do if you're just looking at an arbitrary array of items. 

What are these values? Better be more explicit with the parameter names. When calling the method, you should not need to read the method's body to know what parameters to pass. It should be obvious from the parameter names. 

That's shorter and more readable. However in this case, it would actually make more sense for it to be a private field. 

The same applies here, however that is even confusing, as it is not obvious to me what it is supposed to tell about the code, and the comment in a comment is also weird. Maybe it was on a different line before. In general I recommend writing comments in plain english on their own line before the code they are refering to. 

I shortened the call to hide some of the parameters. You are passing the variable by reference and changing its value, which can easily lead to hard to find bugs, especially when there is an easier and more intuitive way of doing it. Furthermore you have different variables for both players whether they have won or not, and still the function is returning boolean whose value always seems to be -1. If you changed your function to return the number of the player (1 or 2) if the player has won, and return 0 if none of them has won, you wouldn't need most of the parameters. Even better, if you only check whether the current player has won after he placed his symbol on the board, then you could just write the check in like this: 

to check whether optional arguments were passed. But really shows its value if you want to have options and switches, which are a pain with and near impossible with interactive input. (You have to either have a config file somewhere, or annoy the user every time with "Do you want gold-plating? (y/n)".) To end on a positive note, I have nothing but good things to say about your use of docstrings, especially the ones on your functions. This is exactly the kind of excellent docstring that Clojure has and that Python mostly lacks, at least in the standard library. 

Or, if you're uncomfortable with the shortcut syntax for anonymous functions (it can get pretty hairy), like this: 

First off, I'm going to have to complain about your taste in function names, which will probably be unproductive and just lead to hurt feelings on both sides. Yes, it's that function . I don't mind so much if small inner functions defined with have names like , but to my eye, something declared at the top level of namespace—private or no—should have a more descriptive name. I would probably not define as a top-level function at all; see below for more on that. It's also confusing that you call the top-level function , then also call the function passed as a parameter to by the name and then go ahead and pass as the parameter in . I kind of don't like that you expect the output of to be a vector of vectors, but you depend on the function passed as a parameter to to return a vector instead of putting that logic inside . If I had a top-level private function that's only used once and seems too specific to ever be useful again, like , I would consider making it an anonymous function that gets passed in the one time it's used. So I would probably rewrite like this: 

This is a perfect example why good variable names are important. You have variable names that are hardly readable, and comments which describe what the variables mean, but which will not help you if you read the variable names somewhere else in the code without the comments. Variables should always explain themselves. Better variable names, which would make the comments obsolete, would be: 

Even better you can add parameters, to be able to easily change how the screen is setup without having to read and change the setup code: 

Also I suggest using braces even for oneliners, as in the last line of your code. Even then I would use the bracing style shown above, but if you want to make a one-liner, putting braces within the same line makes it still more readable: 

Poisoning someone should not look like this: . It looks like checking whether the enemy is currently poisoned or not. Better name it , or just . 

That way you achieve a good level of abstraction, where you don't have to read all of the details everytime you want to change something. 

These functions do not add any value. (Hint: Just after reviewing these functions I saw why they are defined, which is using them for event handling. In this case they do add value, but I will leave the info for understanding.) gives you more information than . If you read somewhere in your code, you do not know what is turned, you do not know how much it is turned. Whenever you want to write a function that only contains one or two lines, think about whether the one line or two lines would be more readable and give you more valuable information.