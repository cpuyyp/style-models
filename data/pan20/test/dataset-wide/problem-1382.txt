The value of the privete field should NOT be tested, as it is only an internal implementation detail. Also what should do if the user has not yet logged in? 

So if writing unit tests don’t help you writing the code then don’t write unit tests for code that is tested by acceptance tests. However unit tests help you developer the API to your class and provides examples of how to use the class, so may be of value even when you already have 100% test coverage. On a normal sized code base, it may also be quicker to track down way a unit test if failing. 

(Some people will disagree with the above, but every programming job I have done in over 20 years of programming, we had had some naming convention for members of a object.) 

You have written nice small methods with clear names that greatly helps with understanding the code. However it is very easy to mix up parameters that are passed into the method and fields of the object when reading the code. Therefore it is better to prefix all your fields with “_”, so making the code read like: 

at run-time you can associate one mixin to the target class. Jackson matches properties and methods by name and takes the annotations from the mixin. overriding any from the target: 

Second, although the acronym stands for "comma separated values", parsers (and writers) usually accept any single character as argument for delimiter. this gives clients flexibility that sometimes is necessary. Imagine if an api produces files in the following format 

I have two comments of the tweaking kind: 1) any variable that is shared between threads has to be . this is true even for static variables that have one value throughout the JVM (actually it is per class loader but this is irrelevant here). The reason for that is that threads can locally cache the value of variables. volatile variables force the thread to read the global value each time. You might also want to take a look at which is an int that is guaranteed to be incremented synchronously and that has the same value for all running threads. 2) while will work, Java concurrency package has several Lock mechanisms that allow for better control over the synchronization process. of relevancy here are , . 

On Fixed Size: I don’t think I have ever backed a queue with a fixed sized array apart from code written for university exams. However it is easy to extend what you have done to allocate a new array of double the size and copy the item over if the queue gets filled. Doing so tends to be faster than using linked lists on modem CPUs (due to the processor cache) and also creates lets garbage so helps the garbage collector. See Strategy: Stop Using Linked-Lists On Naming: Lets take this code for example: 

Also your qSort could be written to be a lot faster by not creating 3 new , it is also very important to quickly choose a good item to privet on. You do not even set the size of the list when you create them, hence each list will have to be reallocated and copied many times as you add items to it. You have a qSort that is implemented is an inefficient way compared to a boubleSort that is close to the best implementation for boubleSort. Yet as you confirmed in your comment the qSort does better when you have over 10000 items, slowing just how much better qSort scales. 

Thanks for submitting your code for review — it shows that you care about code quality and you're willing to improve and learn. Note that OOP stands for object-oriented programming and does not have a plural form ;-) Alexandre has given you some good advice and one possible implementation. I'd like to critique your code a bit more thoroughly and offer another, more lightweight possibility. 

Output Parameters I agree that it would make more sense to initialize the output parameters with since you made the effort of making them . But if you take a step back, you realize how ugly the use of parameters is in this situation. So I deleted them and made return an instance of a new class designed to hold two pieces of information: and . I called it , but I'm sure you can find a much better name for it. LINQ Query I rewrote your query as a because I find the syntax less convoluted. However, using a method chain is also all right if it is more readable for you. End Result method 

You need to look through your code with an analytical eye and discover the pattern that you are implementing. I call it default if (null or) empty. So I created an extension method to implement that pattern. 

define the test data define all possible validators and initialize all of them upfront. validate the input by applying validators it knows when a validator should be applied somewhere inside the validation code block, the method decides that it is now time to do the calculation the method is also responsible for producing all the output (from validation as well as from calculation) 

in addition, interface contains a method that returns a boolean. how do you plan to prevent clients from calling it? 

in my eyes, in the case of deciding between two options, the short form of the if statement can be used to make it clear: 

First of all, I do not understand how this may happen, since in you ask on unequality of user ids. anyway, at the very least, you should make a method like . 

You can replace the for loop with a java 8 of the collection of the properties map. You can replace all the nested if statements with a you can have your choice of separate s for each if statement, or just concatenate all of them together with operator. after the , you need to tell the stream to end (aka Short-circuit) by finding the first item that matches the filter. The operation returns an since it is possible that no item satisfies the filter's predicate. in the question, it is required to take an action only if a match is found, so you can add an that takes a which does something to the matched item and returns void. does nothing if no item satisfies the filter's predicate. 

Welcome to CodeReview. Your concern for the quality of your code is warranted, but don't let that put you down: digging through that book on your own, writing your own code and even exposing it to the Internet's critical eyes are impressive first steps in the right direction. You seem interested in writing clean code. I can warmly recommend the book Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin). For me, it was a very thought-provoking book that helped me really understand why internal software quality matters (and how to achieve it). Now, let's get to the Review. Pulazzo's suggestions are spot on. (As he pointed out, you may want to revisit the concept of object instances and the keyword). In addition to the points already made, I'd like to explain some more abstract topics that really drive code quality. 

That way, is only called in a single place and can easily be disabled or replaced with a real logger. For instance, this: 

Applying it to your Tic Tac Toe The entry point Look at your method. It spans nearly 50 lines and contains six levels of nesting. I tried really hard, but my head nearly exploded trying to comprehend everything you were doing in there. What if that method were to look like this? 

The inheritance relation between the two classes makes no logical sense. It seems to serve the sole purpose of sharing the instance. Inheritance is more than mechanism for sharing variables. It has application (aka business) meaning. It defines "is kind of" relationship: a is a kind of . The class names say absolutely nothing about what the code does. Well, one could argue that serves as the program's entry point. I've seen this "naming convention" in actual java projects so that's passable. I would call it something like . It is also acceptable to add the method to the other methods instead of putting in a separate class. class is another matter: There has to be better name that describes what the collection of methods do. In conclusion, it is up to you whether has its own method or keep it separate. So, if we look at as that is a class that implements your improved bubble sort algorithm, then can be regarded as a constructor. and it should take a instance as argument. So, from the above constructor, we deduce that holds the int array as internal data structure. So the sort method should accept no arg and return void and if you wish you can add that is a "classic" getter method: allows access to the instance variable. regarding : so we now can deduce that this method also accept no arg. It is considered "best parctice" that a class with a data structure (or just a bunch of variables) will have a string representation of its internal state by overriding 's method. This allows the caller to conrtol to which output the is written. 

And that's it! Well, almost. You've probably got a pretty good idea what the enum and the helper class have to look like, but I'll show them for the sake of completeness. Helper data structures Some Java experts and professionals will tell you that every field should be protected by getters and setters. I disagree (and Robert C. Martin happens to be of the same opinion): Some classes really have no significant state to protect, so they should be classified as data structures without behaviour and may have public fields. Others will disagree, and using getter-setter methods is fine too. 

Pretty straightforward: and will show up on the game board correctly, so all we need to do is override of to give us an empty space. Also, there's a convenience method to give us the next player. Formatting the game result 

The following method is called when the player makes a move. It replaces your three enormous if statements where the conditions spanned multiple lines. Even in this refactored version, some complexity remains. Basically, the approach is: 

This comment is probably a remnant from testing; commented-out code should be removed immediately as it adds clutter and serves only to confuse. 

why do you need two loops with the same loop condition and same break condition and some other identical lines of code ? and why did you put the exit condition as a separate statement? why not (by the way, there is nodefinition for ) The code also lacks documentation. a comment for each statement would explain a lot. the whole logic seems overly complex to me. the requirement can be easily fulfilled using one loop and simpler code 

there is a useful example in this topic it shows how you can use a instance across methods, something that may be useful in your case. lastly, have a look at which seems to fit at least some of your requirements. if you are doind this asan exercise, then take a look at the class' source code and see hoe they dealt with thread safety issues. 

it assigns a value to the String . now, I assume that the logic was meant that should be assigned the name of either or but the code actually allows for both statements to be false and the value will then be an empty String. You can fix that by changing the flow to an one