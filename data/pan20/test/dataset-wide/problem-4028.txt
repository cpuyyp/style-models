With the common set-theoretic approach of defining the order in terms of $\subseteq$ or $\in$, appealing to eg transitivity/ordinality is unavoidable. But if you take a slightly different approach to the definitions, these can certainly be done with just induction and a couple of basic facts about the surrounding set theory; and the end result is in a sense more natural, not depending on the specific implementation of the numbers. Suppose $N$ is any set, $0 \in N$, and $s: N \to N$, and $(N,0,s)$ satisfy the usual induction principle. Then firstly, you can bump this up to the recursion principle: that you can define functions on $N$ (in particular, $\{0,1\}$-valued functions, i.e. predicates) by recursion. This is where you need to use a few things in how the surrounding theory treats functions and so on. (You could also start by saying that recursion, rather than induction, should be the basic defining principle of the natural numbers.) Now you can define the strict ordering by recursion: 

A slightly-less-trivially equivalent form is the same statement, but using an alternative construction of the object of equivalences — call it $\Eqv'_X(Y_1,Y_2)$ — which represents not just “equivalences from $Y_1$ to $Y_2$”, but “maps $f$ from $Y_1$ to $Y_2$, equipped with a homotopy left inverse $(g_l, \alpha)$ (where $\alpha$ is the homotopy $g_l \cdot f \to 1_{Y_1}$) and a homotopy right inverse $(g_r,\beta)$”. This is equivalent to the other versions just since the evident projection $\Eqv'(Y_1,Y_2) \to \Eqv(Y_1,Y_2)$ is always a trivial fibration. Now let’s move to type theory. First a couple of notes about language. It’s familiar in homotopy theory to think of a fibration as a family of spaces varying over a base space. In type theory, this is literally the case in the language — you work with a family of types indexed by a variable varying over a base type, just like in traditional settings you work with the family of sets $\newcommand{\R}{\mathbb{R}}\newcommand{\N}{\mathbb{N}}\R^n$ indexed by $n \in \N$ — but such a family will generally behave like a fibration, not just like a discretely indexed family of discrete sets. And in the simplicial model (and other similar models), a family of types gets interpreted as a fibration. Also, like the HoTT book, I’ll work in prose, not in formal symbolic type theory, just like how when one does maths over a traditional foundation, one writes in prose rather than the formal symbols of first-order set theory. (In fact the gap between prose and formal language is significantly smaller in type theory than in set-theoretic foundations, for most mathematics.) The only basic notions we need are path types, function types, and $\Sigma$-types (types of tuples of data). Given two types $Y_1$, $Y_2$, we can define the type $\newcommand{\tyEqv}{\mathsf{Eqv}}\tyEqv(Y_1,Y_2)$ of equivalences between them as the type of tuples $(f,g_l,\alpha,g_r,\beta)$, where $f$ is a function $Y_1 \to Y_2$, $g_l$ is a function back the other way, $\alpha$ is a function giving for each $y \in Y_1$ a path from $g_l(f(y))$ to $y$ (so $(g_l,\alpha)$ together are a homotopy left inverse for $f$), and similarly $(g_r,\beta)$ is a homotopy right inverse. Saying a function $f : Y_1 \to Y_2$ is an equivalence means equipping it with suitable $(g_l,\alpha,g_r,\beta)$. In general, $Y_1$ and $Y_2$ may have been dependent all along on some variable(s) — say, $Y_1(x)$ and $Y_2(x)$, where $x$ ranges over some other type $X$. Then their interpretations in the simplicial model will be fibrations $[Y_i] \to [X]$; and $\tyEqv(Y_1(x),Y_2(x))$ is itself dependent on $x : X$, so its interpretation is also a fibration $[\tyEqv(Y_1,Y_2)] \to [X]$. And in fact this comes out to be precisely $\Eqv'([Y_1],[Y_2])$ as defined above, since path-types are modelled by (fibred) path-objects and function types by (fibred) mapping objects. Now for a type $Y(x)$ depending on $x:X$, and for any $x_1,x_2 : X$, there’s a canonical map $\newcommand{\tyP}{\mathsf{P}}i : \tyP_X(x_1,x_2) \to \tyEqv(Y(x_1),Y(x_2))$, defined by giving the identity equivalence $Y(x) \to Y(x)$ on reflexivity paths. (To construct something depending on a general path, it’s enough to construct it for reflexivity paths; this is the defining property of path-types, and is analogous to extending maps defined on $X$ to maps defined on a path-object $P(X)$ along the inclusion $X \to P(X)$.) Now, say that a family of types $Y(x)$, indexed by $x : X$, is univalent if this map $i : \tyP_X(x_1,x_2) \to \tyEqv(Y(x_1),Y(x_2))$ is an equivalence for each $x_1,x_2 : X$. I hope the remarks so far about interpretation make it reasonably plausible, if not quite watertight, why a family of types is univalent in this sense just if its interpretation as a fibration is univalent in the simplicial sense. Now, in type theory (as in other foundations), one often wants to consider a universe — a family of types closed under common constructions (e.g. forming function types). Indeed, one may consider multiple such universes. The Univalence Axiom, for a given universe, says just that this universe, considered just as a family of types, is univalent. I’ll stop here, because this is plenty long enough already! But a full treatment of all the above, together with the construction of univalent universes in $\SSet$, can be found in The Simplicial Model of Univalent Foundations (Kapulkin, Lumsdaine, Voevodsky). Specifically, it’s in Section 3, using the universe introduced in in Section 2; you can probably comfortably skip Section 1, which is about the technicalities of constructing models of type theory, and also most of Section 2 after the universe is constructed. 

$\newcommand{\C}{\mathbf{C}} \newcommand{\AbGp}{\mathrm{AbGp}} \newcommand{\Psh}{\mathrm{Psh}} \newcommand{\Sh}{\mathrm{Sh}}$Let $\C$ be any site (i.e. small category equipped with a Grothendieck topology). Then the sheafification functor $\AbGp(\Psh(\C)) \to \AbGp(\Sh(\C))$ preserves finite limits, but not in general all limits; so it is a left exact functor without a left adjoint. (It does, however, have a right adjoint — the forgetful functor.) 

Analogy with how vertices match up when you glue paths together along vertices. Each path has one vertex oriented as "source", and another oriented "target". To glue paths together in a consistently oriented way, we do it like this: $ \quad \cdot \longrightarrow \cdot \longrightarrow \cdot \quad $ where a "source" vertex is matched to a "target" vertex; in other words, a vertex should have opposite orientations in the edges that it joins. (Matching them in the same orientation would give $ \quad \cdot \longrightarrow \cdot \longleftarrow \cdot \qquad $ ...ouch!) (Working from the picture in David Sayer's example.) Each triangle in his picture has the edges in its boundary oriented clockwise, which makes them match up consistently at their vertices, in the sense of the previous point. When we paste the triangles together along an edge, that edge is no longer part of the boundary of the resulting quadrilateral. So looking at just the resulting boundary, we want that still to be consistently oriented, with each vertex occurring as a source of one edge and a target of another. Having the glued edge matched in opposite directions is what will make that work... contemplate how the vertices of the "gluing edge" occur in the remaining boundary edges, as sources/targets, and what will make sure that they still cancel out. Now, imagine you're standing somewhere on the surface of either triangle; the notion of orientation you can see, locally, is the idea of "clockwise around you". What should it mean to say the edges are consistent with this? It seems reasonable to say that as you walk up to any edge of the triangle, its direction should agree with your idea of "clockwise around you". So let's you're on the right-hand triangle and you sidle up to the "gluing edge"; it's on your left, and it points forward — that's good, that's clockwise! Now you step over it; but now it's on your right, so to still agree with your orientation, it should point backwards, seen from this side... and it does! Awesome!