There are some things to be said about your C version as well, but since you explicitly asked about the C++ version (and also because my C-knowledge is not that great), I will leave those for somebody else to comment on. General Hints and Tips 

Well, you could make this work using . However, since you are implementing a quite low-level memory structure, I'm not sure I would suggest it here. In general, smart pointer usage is preferable to raw pointers; however, in a case like this where you have to manipulate the pointers themselves a lot (as opposed to the data they are pointing to), smart pointers tend to be somewhat clumsy and ill fitted. However, you should definitely make sure that you are doing memory management correctly (using static analysis as well as runtime analyzers such as valgrind, asan, msan etc.). There's nothing inherently bad about using recursion in a constructor. There are two different approaches to the copy problem. One is to treat as a dumb, struct-like class that does not much more than combining a piece of data with a pointer to the next node. In that case, it is fine to make copying nodes correctly the responsibility of . The other approach is treating s more like "smart" objects which have some ingrained behavior, in which case copying should be defined through the class. I personally prefer the latter, because it plays well with the C++ approach to OOP, and lifts some responsibility from . However, I would not say that the other approach is wrong, I just don't like it as much because it makes the overall burden on heavier. 

or similar to avoid indexing and bounds checking errors (for example, you could run into problems with your version here because might not be big enough to hold all index values for ). Don't rely on implicit conversion when assigning values to types. The correct initializer for a single-precision floating point number has the form , for example (meaning that you should write instead of ). Implicit conversion can sometimes really ruin your day because it can lead to unexpected results which are hard to diagnose. Don't use , use instead. will also flush the underlying stream buffer, which you usually don't need to do and which can harm performance if you are doing a lot of I/O (also, if you really need and want to flush, there's ). 

Overall, I have very little negative to say about your code. Still, there are some things I'd like to nitpick about a little: 

Since does not modify its inputs, it has to make a copy which is then modified and returned. However, does modify one of its inputs, in this case , so making a copy, modifying it and reassigning it to is unnecessary. Instead, you could approach the problem the other way around: First, implement , then implement in terms of it: 

file that corresponds to the current file headers from other parts of the same project/library header file from external libraries standard library headers 

ArtemyVysotsky has provided you with a improved solution, so I am just going to give some general advice: 

Apart from the fact that you should prefer writing algorithms to work with iterators (to enable you to sort things that aren't arrays, such as s), there are a few things here that are problematic: 

You are missing . Fix that, or your code might not compile on a different compiler than what you are currently using. Don't use C-style arrays. C++ offers , which adds some more handy functionality (such as iterators) and prevents some nasty bugs (caused by array-pointer-interconversion, for example). Don't use C-style strings. Either use , or, when you are sure that the underlying string has a long enough lifetime, use . C strings are inherently unsafe and thus discouraged in modern C++ code. should most likely be , since you are modifying neither nor and both are small enough to be efficiently passed by value. This does not necessarily apply anymore, however, if you follow my suggestion from point 3. Use less . I'm sure you will not suffer too much from writing every few lines, and both people reading your code as well as the compiler will thank your for it (also, you're preventing some nasty ADL bugs, which can be a real pain to debug). 

As to question 2: No, your queue is not threadsafe. The problem is that you are handing out pointers to the same data to different threads without synchronizing any accesses to these pointers, which constitutes a race condition, which is undefined behavior. Citing from the most recent working draft of the C++ standard before the release of C++14: 

As part of a project where I will be rewriting the most common GNU coreutils for practice purposes, I wrote a simple command line option parser in C. The parser works by categorizing entries into either flag or argument by comparing them to a list of possible flags specified by the user and grouping them together in pairs where applicable. Currently, only the standard encoding is supported (i.e. ASCII in most moderncases, no UTF-8 or other extended charsets). Nearly all of the work is done in a function named . The Files: options.h 

Currently, nowhere (and never). You're leaking memory. Add a destructor that invokes on all nodes you have. Not really. You could implement a stack-based version with limited size, but that's not very useful in a lot of cases. (Also, you could use or any other memory allocation routine instead of but that's not really different as you're still allocating free store memory). Yes, there is (in some cases). The first line is only valid starting from C++11 and performs list initialization while the second line performs direct initialization or value initialization. 

when you should write because that is what your code is actually doing. There's no need to be overly clever and assign from a location whose value is known; please don't confuse us and yourself and write out the value. It might be beneficial to have a member to track the length of your list so that you don't have to recalculate it every time is called. 

makes me feel really uneasy because it goes against how iterators are used by the STL. Calling and on an iterator just feels wrong. I suggest splitting up the functionality into two classes instead: One class which is used to make indirection iterators from a given set of value and index iterators (called , for example) and an class which encapsulates only the iterator functionality. De-cluttering An added benefit of this method would be that you could reduce your actual iterator class by a few members. Another point which makes me uneasy is the fact that you have six different members in what is basically a simple iterator class, some of which are unnecessary as far as I can see. For example, you never make use of , so that should be the first variable to go. The same is true for , as for . Before we go on removing stuff, let's talk a bit about iterator design here. In particular, I want to talk about . So far, you are evaluating whether a particular index is in bounds for every access and, if it is not, throw an exception. That last part is going to make some people angry, because throwing exceptions is something a not negligible part of C++ developers disapprove of, and on some platforms, exceptions are not even usable at all. This does not mean that you should never rely on exceptions, but in my opinion, you should make everything relying on exceptions opt-in. In your case, that basically means extracting the index check into a public interface method that the user can call if he wants, but doesn't have to. This is akin to how this issue is usually dealt with in the standard library: For example, offers both an unchecked as well as a checked (and exception-throwing) method . Having said that, I do actually believe that iterators should be as minimalistic as possible and only offer what they were designed to do, which is, in most cases, iterating a certain range of objects. If I had to rewrite your , I would certainly leave out range checking as a whole, and require that all the indices in the underlying container be valid (again, it does seem to me that this largely reflects how the iterators in the STL were designed). This is a matter of opinion, however, so don't take this as a must-do. Adding to the interface The interface of is currently kind of meager. For example, is missing, which is a requirement for input iterators; an iterator category you could easily fulfill. The same is true for pre-increment, and having , although not strictly required, would probably be reasonable. Another thing which I would definitely add is a way to retrieve the current index, since this opens up a wide variety of possible use cases for your users, ranging from logging elements with their index to doing bounds checking manually. Then there is a whole group of methods which are difficult to provide, but oftentimes very reasonable, e.g. . The difficulty here arises from the fact that what you have written is less of an actual iterator and more of an iterator adapter. Optimizing functionality for different iterators could definitely be beneficial to usability as well as speed, but the big downside is that it will be a lot of work to implement. Ultimately, it depends on your use case, but if you really wanted to make this iterator part of a publicly available library, you should do that step. Otherwise, it is purely up to you whether you want to invest that much time and effort. Little things and nitpicks