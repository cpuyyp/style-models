The code is not self-documenting, because the problem description is non-trivial and involves what you'd call "business logic". That is, you're not trying to perform some technical operation (like a cache, or a data structure, or a parser), but you're following rules defined by someone else. Each of those rules has to be programmed in, of course, but without describing WHY they have been put in, you'll always need the problem description along with the code to make sense of the code. Imagine you had posted your question without the problem description. Would we have been able to guess what the goal of your assignment was? Personally, yes, I think so. This is because if I were to run your program, it asks clear questions and prints a clear result. It does require a non-trivial time investment, though. You get 

This variable is unused. Additionally I'd clean up the blank lines you have, it's dangerous to have an if statement end, and then a couple blank lines later, there's an else that continues the if. 

Bug: leads to you removing the last node. Your solution should have comments: I have NO idea how it works. And that's after reading it a couple times. If this was production code, I'd have wrapped it with unit-tests, thrown the implementation away and rewrote it. 

In an interface you NEED to define the semantics. If you define the semantics in function names and argument names then it is much easier to verify implementations. 

Bad rolfl. This is the kind of comment that is written once and then dies a slow death. If you must leave such comments, name it somewhere. Even if it slips through the cracks of your issue management system, you'll still be able to search for TODO and find the remaining tasks. ... and if a TODO stays there for a very long time, maybe the cheat way isn't so bad. 

So, either you get back , or exceptions. ... So what's the boolean for? If the method returns normally, it's always going to be true! What's more, you've got a function signature that seems to suggest non-throwing code, and the comments for that function make no mention of exceptions either! 

Lastly, it makes no sense to have a return statement at the end of a function which will return . So we can remove the return statement. 

But, if we change the max or min, then we also already found 1 instance, so we should just start counting at 1. We also put the counting in an else statement so that we don't count them double: 

silently fails with and returning NULL if you provide it with bad params. You might want to replace this with a . 

(Ckuhn also posted some naming changes, I suggest you add them in here as well.) But Pim, if I do this, my if statements become very long! Encapsulate Conditionals Let's take a look at one of these paths. 

But maybe you'd benefit from writing some abstract function which "overwritesExistingValues"? You're doing the same thing twice already... Lastly, back over here... 

Type mismatch, "Num" implies numbers which are not strings, could be really helpful to explain this in documentation. Also, don't shorten function names like this. You're one step away from . Reduce typing via autocomplete, not text compression. 

are unused. I think this is because you've stuffed everything in one class. If you use multiple classes (via SRP, as Kolargol00 says), you'll have smaller classes and it will be easier to find these unused variables. Specifically, I'd make a class for Keyboard input, a class for the hero character, and a class for a wall to start with. 

You have your tile sizes hardcoded in the TileMap ... in an obscure place (render code). Consider placing them as constants in Tile or TileMap. That way, upscaling to 64x64 tiles is a lot easier. 

I think you should add some blank lines to improve the readability of your code. Take these two methods: 

This could be a method . You could rewrite the entire method as a list of "increase adjacent mine counter": 

This guard clause can be done sooner. There's no need to convert to char array before checking the length. 

Failing all that, if you just want to improve your current setup, at least use overloading for that. Rename to , ditch the type checks in , and make 3 overloaded versions of which take a Integer value or a String value or a Float value. That'd at least get you type-safety for value writes. 

If they both end the same, there's really no need for an else case, you can just put the statement after the if statement. 

You do get multiple statements on one line, but I'd see the ( for those who are LOLCODE-inexperienced) as a part of the if statement. Indentation - Comments 

But, this seems silly for something that is essentially "has 2 or 3 neighbors". If we make it more explicit... 

A good list (for shopping list) allows me to check if something is already on there () and allows me to cross items off my list when I have them (, ). 

Keep the blank line in there, it's for showing the difference between your guard clauses and the code that does the work. 

You could make a helper function for this that takes two strings, one to check and the other to put as variable name in the exception message. Alternatively, usually in enterprise projects you'd already have a helper function for this; both Guava and Apache commons have some sort of String.isNullOrEmpty or something like that that you could use. If you don't like either of those options, at least get rid of the extra parentheses. They are not needed here. 

Gives back "5 11", which... I have no idea what it means. I guess you're treating this as "91", which ... well, I think this too is parse error. 

That's some tasty looking code. I don't think I'm going to be able to find anything wrong with the implementation. There's something to be said about the documentation, though... 

It will throw an exception, but after that you'll be in a dirty state. If you then call again, but without an index, () then you'll get more exceptions for going out of bounds. 

Weirdly enough, all that matters for connect-four is that the top row has to be filled in order to block all remaining plays. Perhaps that's not what this method checks, but if you're going to use to check if a new move is possible, then what this really should consist of is checking if the top row has any free spaces. There's no need to start from the bottom up. 

The evaluateHand function in Hand doesn't seem to actually evaluate the hand, what is its purpose? Since you have a HandEvaluator, does a Hand still need an evaluateHand function? 

So at least 4 cases aren't covered, because you've got 12 cases and the total amount of cases you can have is 16. Let's cross off the matched cases... 

That's what I pulled from it after a single passthrough. I don't have comments on your design yet. Possibly because nothing really looked badly out of place and there were more issues in the code than in the design. 

You're not modifying . Is it possible for to not return once it has once returned null? If not, why not break out of the for loop, rather than going through the remaining loops? (Performance when dealing with large TreeMaps). I can't find anything else, really. 

Dead data CTRL + F "name" ... 8 usages... class member variable, comment, comment, constructor argument, setting variable, passed in argument... comment, setting variable... No reads! It's nice that you gave your LinkedList a name, but if nobody is going to call it by its name AND it doesn't get to tell its name to anybody, it's still gonna feel lonely. Treat it like the inanimate object that it's supposed to be and strip it of its name. (Sorry if that sounds harsh.) DeleteNode Who manages the nodes? or ? Pick one and make that one responsible. Heck. Copy the method, paste it in LinkedList, make it private and make it take a argument. LinkedList now controls the Nodes like it should (don't ever expose the nodes to the client, they don't want the nodes). Stack and Queue You might be better off implementing a generic (yes, generics) type that you use to initialize your LinkedList. Doing so means you don't have to cast anymore, and that you support more than just . Comments I dunno if your course teaches this, but when you make generic (not generics, just generic) classes like this, you'll want to add javadoc explaining what each method does and what it's side effects may be (such as throwing an exception if the list is empty when removing something). 

How about using some form of collection, then iterating over it to call the property, and if it's empty, setting focus and breaking the loop? The algorithm would be like this: (pseudo code) 

There, looks good. Now, normally I'd convert the other half into a separate function as well, but then we have to go deal with the part where the array size might not be large enough, and that'd be a bother. 

Is either a spin loop or does not check the fast enough. Or so I think. If there is no timeout for and it does block until input is required, then stopping the application whilst it is waiting for input will lead to the application only actually shutting down AFTER the input has arrived and been handled. In case of a system shutdown, or programmed shutdown, this input may never arrive. The JVM will handle power situations for you, forcibly killing your thread, but if you were to use this as a library and another thread was told to shutdown the application your application thread wouldn't be shut down. If there is no timeout for and it does not block until input is required, then you've got a spin loop. When running, the application will check thousands of times whether you've got input, and then pass the non-existing input (maybe as empty string, maybe null), through your commandhandler. This is a waste of system resources. By setting a timeout on the input reading, you can resolve this issue: By blocking for only 100ms (or so) for input, you can reduce the amount of checks to about 10 per second (which is easily handled by processors), whilst at the same time maintaining a fast response upon shutdown. Secondly, your code is not threadsafe. There are certain cases which will cause things you do not want to happen. If two threads call at the same time, then... 

You're using the wrong tool for the job. If there's ever going to be a loan that I will pay an amount to every week for 2 years, you're gonna have to write a script to generate the code for you, because doing it by hand would suck. You'd have to write code for 204 different enum values, including the switch cases. If you had to map months to strings, you could have given your enums values, e.g. 

and it supports mountains and multiple dragons! Possibly the best thing you could do is take another look at your code, and remove the python element from it. Start in English, and convert that to python. I bet that's what the kids will be doing. Using an approach like this, the code is going to be a lot shorter and easy to understand. Yes, it's slower by doing all the checks all the time. But for these kids, it's probably going to be more important that they understand the code, than that it runs three times as fast. Computers these days are forgiving, and you can always teach them better optimizations later. Plus, if they were to shy away from programming because the code is too complex, that'd be a darn shame. And get comfortable with your code before the lesson. It would be best if you could do live editing in the classroom. 

There! Except the naming is flawed; this should really be called . Adjust your interface as needed here. is a really weird construction. 

I think you should expose the values of your errors as either constants or some sort of enum. You should keep the "negative is error, positive is socket descriptor" return value of , but it'd be better for users of your code to be able to check why socket creation failed. And that's better done by checking for of some sort than . 

This is the only part in your code where you set the attribute. Since it's not read, it can go; you have no need for a doubly-linked list and can just use a singly linked list. It makes sense, because all you need to access is the top node; the other nodes aren't important. We can further improve things: 

The changes are pretty simple - first, relocate the so that there's no need to do it once for starting the loop and once per iteration. Next, change the loop into a do-while loop, because the first iteration doesn't need a check. After that, we can see that the only happens at the bottom. Which means it can be part of the loop condition. And since the only way to exit the loop was via that break, we can move the adding to to outside of the loop. The result is code which is much more compact and doesn't rely on flags such as and . 

There's 4 parameters here that can give you a . And all of them look the same. The only difference given will be the line number. You could save programmers a lot of effort by including a description of what is null. There's many ways to dress it up, and I don't know which one is best, but here's what you ought to do at minimum: 

Performance You want to know if there's a faster way check if integers share a digit. To be honest, I don't know. Your implementation looks pretty fast. But your implementation also takes a constant amount of calculations related to the size of the input and makes no use of shortcuts. One shortcut that I can come up with - if a number contains all the digits, then you don't need to continue. But perhaps checking for this case makes the worst case slower again... I also checked $URL$ which is a collection of "Bit Twiddling Hacks", but there doesn't seem to be an algorithm for checking for duplicated digits in there. 

You never allow to get below 0. can't return a value lower than 0. Thus, the second condition will never evaluate to true. Additionally, when shuffling, you don't reset to 0. Is that intended? Naming is a typo, I think. It should be . Names with typo's are hard to remember as you need to remember which way it is written exactly. Use of built-in functions 

I'm assuming you have some way to handle other image formats, like .bmp or .gif; if not to actually handle them, at least a way to tell the user "this service does not support that image type" or something of the sort. 

Maybe it's faster because it does a whole block in one go. Maybe it's slower because a whole native call for copying a few items is adding a lot of overhead. Do the profiling and find out. 

Stop. That's not . That's . If that sounds too long winded, that's because this method is doing too much. Eventually, you'd want to see a method that calls methods for validating the users, updating the users, and sending mails. 

I think you should add a comment for what you're trying to do here. 8 and 7 smell like magic numbers, their meaning is not directly obvious.