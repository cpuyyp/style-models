Now you can use the computed bucket number as an index into the array and replace the switch statement by 

or which is very versatile and can do the conversion according to the user's locale settings. In other cases (like working with monetary values) it may be more appropriate to work with integers only (or ) to avoid all rounding issues. 

This works as long as the length of the code word is less than 32. For a generator matrix, this method reduces the computation time from 0.8 ms to 0.08 ms on my computer. Update: Here is the test/timing code. (I simply took the sample matrix from $URL$ duplicated the rows several times to get 28 rows, then duplicated the last 2 columns to get 7 columns, and finally modified the new columns slightly to get a non-zero distance for the generator.) 

For better structuring of the code, protocol implementations such as can be written as an extension. Testing against and implicit unwrapping should be avoided in favor of optional binding: 

So we need to determine if in the prime factorization $$ c = p_1^{e_1} p_2^{e_2} \cdots p_n^{e_n} $$ there is a term \$ p_j^{e_j} \$ such that \$ p_i = 3 \bmod 4 \$ and \$ e_j \$ is odd. This is more code, but very efficient for for large numbers, because 

For further performance improvement, note that the strings consist of lowercase letters only, i.e. there are only 26 possible characters. Therefore you can use a fixed-size array instead to count the number of occurrences of each letter in the strings. Array subscripting is much faster than dictionary lookups. In order to compute a number (from 0 to 25) from each lowercase letter, it is more convenient to enumerate the of the string. This leads to the following implementation: 

In addition to what @pacmaninbw already said: The return value of is not checked. It will be if the file does not exist or the caller has no read permission. You have to decide how to handle that. Another option would be to open the file in and pass the file handle to your functions. A simpler method to get the size of a file is using (or if you already have a handle to the file). This is also much faster, because it only queries the filesystem, without reading the entire file. The function can be simplified to 

You either have to add an explicit check (and throw an error or fail if duplicate keys are given), or add the key/value pairs sequentially so that duplicate keys are silently overwritten with the new value: 

Another option would be to attach the segues directly to the buttons and remove the button action methods. Then the logic has to be put into , depending on the segue's identifier. 

You are catching the error and throw your own error code in the failure case, so the actual error information is lost. Better just call the and let an error propagate to the caller of your function: 

One possible approach would now be to start the first request, and in the completion handler start the next request, until all pages have been retrieved. Another approach is to use a “dispatch group” to chain the network requests. This allows to almost keep the structure of the main loop: 

It might also be worth to add another specialization for the case that the key is (as it is in your example) because then the array can be replaced by a set, which improves the lookup speed from to : 

A switch-case statement allows to transform only the ASCII letters, with a well-defined behavior for other characters. Finally, instead of creating an intermediate array, you can append to the view of the result string directly. Putting it together, the function could look like this: 

Back to the protocols: Defining a protocol for "Stack" makes only sense if it contains all required methods: 

and implemented in $URL$ Until that is implemented, you have to provide a method. I would probably not choose the method because that requires a conversion to strings. A good choice would be the function in Hashing.swift from the above pull request, this is also what hash.hpp from the Boost library uses: 

Throwing Swift errors is a mechanism how a function/method can report a failure to its caller. Your code throws and catches the error within the same method, and I can see no advantage of using try/catch in that situation. Your code is equivalent to 

However, this did not make a significant difference in my tests. One further remark: Requiring the destination count to be strictly positive seems unnecessary restrictive to me. I would change that to 

the array is one element too large. That does no harm, but there is a risk of forgetting to change the array size if the string on the right-hand side is modified. Better let the compiler determine the size automatically: 

Only one loop instead of two nested loops now! Further improvement is possible with the help of mathematics. As stated in Sum of two squares theorem, 

This would also come in handy when you start to define operations on the vector type, e.g. an addition of integer vectors: 

because the type is inferred from the context. But why do you force the view to be fully transparent at all? Shouldn't that be left to the designer to configure in the interface builder? Unless there is a special reason I would just remove that from the init methods. 

would be a correct way of sorting an array with respect to the last name first, and with respect to the first name second. This can be simplified to 

where the property names should be according to the API Design Guidelines). Avoid implicitly unwrapped optionals As of Swift 3, “Implicitly unwrapped optional” is not a separate type, but an attribute on the declaration of a regular/strong optional, see SE-0054 Abolish ImplicitlyUnwrappedOptional type: 

I think it is a matter of taste which version you choose, I would prefer passing the type explicitly. 

Closing a path automatically adds a line segment from the last point to the first point of the current path segment, i.e. the final in is not needed, and it suffices to pass 4 points to the function. Also I would not make the return value optional. Passing a wrong number of arguments is a programming error and should be detect early in the development instead of silently ignored: 

the file size it computed for each loop iteration. Better compute it once and store it in a local variable. In the function 

would already improve the performance because the primality check for each number \$ n \$ is reduced from \$ O(n) \$ to \$ O(\sqrt n) \$. For the range this reduced the time from 43 seconds to approx 0.3 seconds on my 3.5 GHz Intel Core i5 iMac, measured with 

The efficiency of the function can be improved. It is not necessary to check both players against each winning combination: 

takes a lot of space in the function and therefore distracts from the relevant code. I would store the original data from the Project Euler problem into a text file and load the data from there. That also helps to avoid copy/paste errors or other typos, e.g. when adding the quotation marks and commas. For an Xcode command-line project this is done by adding a "Other->Empty" file "data.txt" to the project and adding this file to the "Copy Files" build phase: 

The method can be simplified. and are both or not, so there is no need to check both. Here it makes sense to check the tail via optional binding, so that a new node can be appended if the list was non-empty, or a single-node list created otherwise: 

I would do an "early exit" in the case \$ p \le 1 \$ and save an indentation level for the "main case": 

Your code is correct as far as I can see. However, there are some things which can be improved or simplified. Let's start with the definition: 

Your original algorithm corresponds to . Using instead reduced the computation time for a=9, b=4000 from 0.095 seconds to 0.014 seconds on my computer. If that is not sufficient, you can use for the array and work with an even larger BASE. 

where the final does nothing if the search return . This would become even more simpler if you change the search methods to include the receiver itself in the search instead of starting the search at its subviews. 

Here you access the underlying instance variable directly and not via its accessor method. It should be 

There are different opinions about this issue (see e.g. When should I access properties with self in swift? on Stack Overflow). The The Official raywenderlich.com Swift Style Guide recommends: 

The conversion to a string cannot fail anymore. If another case is added, the compiler ensures that it is added to as well. 

The compiler can then check that you don't (inadvertently) modify the pointed-to memory, and may be able to do further optimizations on the calling side. It also documents that the function does not modify the strings. Array sizes In 

Benchmarking code for the Eratosthenes generator: Calculates the sum of all primes below 10,000,000: 

Note that the call to is now in the constructor of the error, and not spread across the entire class anymore. This is how you would use it in your class 

is the string length – which might not be obvious to the reader, and is error-prone if you change the given number. It should be computed from the string instead. Global variables You pass the number of adjacent digits as an argument to the function, but the big number itself is a global variable. Passing both parameters to the function makes it easier to add unit tests. Simplify the program logic You reset , , and each time after a product is computed, this seems unnecessary complicated to me. 

My main point of criticism is that the logic in your main function is far too complicated. The label is not used. The inner loop is confusing, and comments like 

But this does not scale well if more sorting criteria are added. Which leads us to Your second attempt There are two problems. First, you sort the arrays with comparison functions like this: 

are clearly separated. Performance improvements Every substring is converted to a number by iterating over all of its characters. This can be improved by updating the product instead, this “sliding windows technique” is described for example in 

The code is difficult to understand (well, at least to me). It is not obvious what a variable named represents, or what functions named 

Correctness: Project Euler Problem #3 asks for the largest prime factor of 600851475143, and that number exceed the range of the data type. (Your program aborts with an exception for this input value.) You have to use instead. In 

and makes the preprocessor definition obsolete. Also note that your function does not NUL-terminate the result string, the line 

Creating a new (ordered) dictionary by mapping both keys and values can lead to unexpected results if two keys are mapped to the same new key. E.g. (with the fixed init method from above): 

Adding all elements in an sequence is conveniently done with the method, here we can apply it to an array slice: 

otherwise the number of bytes written is added multiple times to the total counter if multiple calls were necessary (and then can crash). With the outer loop 

Other things that can be improved: If you create a subclass for your entity then you can use the property accessors instead of : 

An array is sorted if for . For an empty array that is a “vacuous truth” – there are no indices satisfying the condition. Therefore your functions should return for an empty array. Your first function returns for an empty array, and the second one crashes with an . More remarks: 

where is your data type containing a property (which I assume to be of type ). The next step is to define the up/downward movements as arrays and to use a for-loop: 

does not tell anything about what the function does. inside that function is not a count but a (running) sum. Separate computation from I/O Separating the actual computation from the I/O makes the main method short, increases the clarity of the program, and allows you to add unit tests easily. Use separate functions for self-contained tasks The computation of the total salary from the current candidate value in the binary search is done inside the search function. Better move this to a separate function 

It is also not obvious from your code why the function has a (boolean) return value, as the caller ignores it. 

Also is a better choice than for a "large number". This reduces the number of iterations by a factor of 2. 

The performance of the algorithm can be improved by using a different representation for the generator. Instead of a matrix of integers the generator is stored as a vector of integers representing the columns of the matrix, using one bit per row. For example, the matrix 

But this is not yet perfect! The problem is that the sublayers do not animate correctly if the view's position or size changes, e.g. when rotating the device. You'll notice that clearly in the iOS Simulator if you activate "Debug -> Slow Animations": 

You get the same result with less code by using the bridging cast from to , which works for (nested) arrays as well: 

Another problem occurs when the clock is adjusted for the daylight saving time. For example, when DST starts in Germany, the hour is put forward at 2am by one hour, so that the time "2am" does not exist at all. Similarly, when DST ends and the hour is put back at 3am by one hour, then time "2am" occurs twice. Therefore, instead of simply incrementing an "hour" variable, I would recommend to use calendrical calculations which handle all these situations correctly: 

conversions. You can do a pattern matching on and instead, this avoids all unnecessary type conversions and does not require at all. The statement checks if and are both (two integers), both (two strings), or if the values are of "mixed type": 

because can be replaced by , using the method from the Swift standard library. I would suggest to remove that parameter. That leaves us with only two cases: creating a finite sequence (using the sieve of Eratosthenes), or an infinite sequence (using a priority queue), and the definition can be simplified to