The only problem I see is that at inside the function, the object is not automatically usable in its native type you need to cast it back before you can use it: 

Variable declaration Variable declaration order is important. Objects will always be constructed in the order they are declared inside the class. 

But why not pass the stream you want to print on as a parameter (you can even default to ). But the main way to print in C++ is to use so you should define this (and just make it call printLL). Prefer over . The only difference is the extra flush. There is no need to flush any buffers. The default built in automatic flushing will flush ehenever you need. Any extra flushes that you do will just make the code less effecient. 

For the move stuff you want to use swap when you get down to the level of pointers. This is because when you move an object the src of the move should be left in a valid but indeterminate state. But you should leave it in a state so that when it is destroyed it will not affect other code. So this looks OK. 

C Vs C++ String You are using C-Strings rather than C++ std::string. I would switch to using C++ std::string as it uses is much more natural. As it is an well defined class its usage semantics mirror those of the built in types. 

This way you can not just pass a pointer. You need to construct a object that will make people understand that they are supposed to pass an unmanaged pointer across. 

Design Lets start by saying this is a C solution to the problem. You need to think more about classes encapsulation and protecting the tree from random coders to make sure your enviranrts remain protected. Something like: 

But OK. lets use it (just as a demo case). In this case I would not make the result as this prevents further mutation. Just return a reference to the and it will allow you to chain operators. 

PS. Don't write that. Put it in a function. I see what you are doing. But the functionality could be a lot neater. 

The DB is an expensive resources. There is no point in connecting to the DB or even getting stuff from the DB unless you have a valid username and password. 

Especially your stream handling. Its usually bad practice to test for , or during normal processing. You want to test these after things go wrong to generate the appropriate error message or not. Usually stream code looks like this: 

Technically not exception safe. This may become more important if you extend this past integer types. But it is just as easy to do the following instead. 

But can be made more succinct. If you do the read as part of the test you can do the read and test as a single line. 

For this you will need a real parser. Regular expressions will just make this worse. Code Review using namespace Don't do this: 

You can basically remove all the getter/setter methods and put in methods that actual manipulate the object. Edit Based on Comment: 

Is subscriber every going to be NULL? Do you need to check if subscriber has been destroyed? Personally. I would pass by reference and document that a subject must live longer than the observers. Not that just because you pass by reference does not mean you can hold a pointer. 

This is creating a temporary object. Which goes out of scope at the end of the expression (the semicolon in this case). And thus the temporary objects destructor is getting called just after the constructor completes. 

This just gives you the opportunity to misuse in the code. If you declare and initialize in the same statement then no misuse. Also C++ code should never contain a (especially when you are learning). It should have very few calls (if any calls) to . Dynamic memory management should be controled via an object. This is usually a smart pointer or a container depending on your usage. Thirdly why use the C-String API. C++ has its own string that handles memory management for you and does a better job. Currently your code is not exception safe. An exception thrown in your code will result in leaked memory. Thirdly you actually did it wrong and did not allocate enough space (you forgot to allocate space for the character that terminates a C-String). I know you used the to compensate for this. But all the other string functions are expecting it so something is likely to go wrong. Forgot to check the result of a string function. 

Internally it uses std::vector<> (by default) but the elements in the vector are organized into a binary tree structure for faster sorting and organization. (ie element 0 is the root, element 1,2 are children of 0 etc). If you want to do this manually you can your own container and the following methods: 

The trouble is that at the end of scope. Both objects get destroyed. 'y' will get destroyed first calling its destructor and calling delete on the node. Then 'x' will be destroyed and it will also call delete on its one node (but this node has already been deleted so this is illegal). Now the compiler generated methods are usually exactly what you want. But when your class contains an "owned" pointer then you need to do some extra work as the default implementation simply does a shallow copy. Rule of 5 (Optional) In C++11 they introduced move semantics to the language. So it has become pretty standard to implement move semantics for container class (as it makes a lot of things very effecient). Use Initializer List 

Is it useful for the application to know this? It is already checked by the Read/Write methods. I don't actually know this is a question you need to ask. Can the application do anything useful with this information. If not then leave them out of the public interface. It is a lot easier to add than remove functions from a public interface once it has been used. This is one you definately should not be in the public interface. 

Personally I think the tree could handle this. But I can't really complain about the usage. So this is just a personal comment. The parent. Hmmm. 

Most algorithms use iterators as the interface between themselves and the container. It abstracts away the actual container type and in cases likes this removes the need for a copy. Prefer over when you already know that your index into the container is valid (the validates the index before doing the operation (useful when using unvalidated input but otherwise expensive). 

Also the swap operator should also be marked . It is usually used by the move operators (so if these are noexcept so does swap). 

You are giving the option to pass by r-value reference this implying you are going to rip the guts out of the object. But you are actually just making a copy into . A cheap copy as the tuple only contains references. But I think the interface is better if you pass by const reference to more accurately reflect the usage semantics better. 

Your comments are too long (line length). Your code is also also seems untidy because of them. I would reduce the comments and have use self documenting code. This seems to short. What happens if is 2048? 

Rather than using the member functions and you should prefer to use and (or in your case std::rbegin() and std::rend()). This allows you to change the underlying data type without having to change the code. If you changed to an array the code would continue to work as normal. Passing parameters by value causes them to be copied. 

Design. Looks like perfectly good but its not . You should create a class that wraps the node and acts as the interface to all your operations and handles all the resource management. None of these essential parts are currently done. I would expect an interface like: 

I find your code a bit dense and hard to read overall. Your identifier names are compound words but all lower case. 

This may be what you want but usually I would expect to see you return a reference to the object in the stack. That way a user can potentially modify the value. If they want to make a copy they can also do that by assigning it to an object (but it is not required). As a result you also usually want to versions of this function. A normal one and a const one. 

Doing it this way also gives the compiler better opportunities for optimizations. I am not sure I would do release like that. 

Also there is no need to write your own the default one will return a string you provide to the constructor of the base class (even std::exception has been updated to take a string). You got the prototype to wrong. 

You are implementing your own hash based dictionary (badly). You need to use the visitor pattern (rather than have a mark in each node). 

The other thing you need to watch out for is the recursion here. This may work well for your test cases. But a huge list of millions of islands is going to eat up your memory. Look to using a loop instead of recursion. 

Your regular expression for detecting valid urls is very weak and you can slip a lot past it. Though you have used escapeshellcmd() to protect yourself a bit from people trying to run alternative commands you have not protected yourself from people sending extra parameters to ping. Two alternative attacks spring to mind: 

But don't get into bad habbits. No using the braces can lead to maintenance problems on C/C++ code because of macros. Best practice dictates that you always use for sub statements of . To make the code easy to read when including the code in the interface declaration put the variables at the top. Thus you can read the code in with the context of the variables and knowing their type. If you interface declaration is just an interface (and the code is put in the source file rather than the header) then it is fine to put the private variables at the bottom. 

Order of construction You also have another invisible problem in the order of construction across compilation units. Remember that the order of construction of objects is undefined across compilation units. 

But even this is not usual. Usually you check the result of the read operation by placing the read into the if statement. 

Yes all books use this. But it is bad practice in general. They have a good excuse in a book that they only have so much horizontal space to keep things readable. In reality using it is dangerous and should be avoided (even for short programs, as doing it here becomes a bad habit and bad habits have a tendency to accidentally intruding on production code). See:: Why is “using namespace std” considered bad practice? Don't declare all your variables at the top of a function.