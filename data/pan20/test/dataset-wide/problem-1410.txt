Too many variables - the majority of the time the need to hold onto the DB's credential inside the object is not necessary - it should be part of your configuration of the APP and invoked as such then passed inside to the DB object to initialize the connection - once that is done you don't need this info. If you change information then a new object should be created. Why? because image you do need to connect to two different DB (one for user, one for tracking as an example) - if you store your credential your stuck to this. Also as I can see from your constructor - your not even passing your credentials to it - its fixed from a global stand point. The majority of your class is just a smaller typing of what is already presented ie: query, then bind, then execute. Its a rehash of the system's PDO. Another flaw is your Single() function - it has the command - what happens if your query returns more than one result and you want to iterate it one at a time - you can't re-execute the query to grab the second row. fetch()'s purpose is to go fetch and iterate through the rows one by one. You can argue that you can use resultSet() to grab all then foreach but if you are returning 10K rows you will be in a heap of trouble. Next - lets touch a bit of the tracking class. One flaw is the getInstance. Singleton are bad for maintainability because you can't make more than one object of it and its hard to test it. Ideally - since all your functions are relying on the database - you should have passed it (aka injected) is part of your constructor and then call your functions which uses the DB. Its not like you will instantly use a different DB within the function because you are tightly coupled from it. Basically: your Track class is your repository, and your PDO is redundant because its just shorthanding the coding. thats my first pass through of your code. 

If you are working in PHP use a framework that has MVC such as Laravel(up and coming and popular), Symphony, Yii, Codeigniter(defunct), etc. Each of them will enable you to use some reuse mechanism. Laravel itself uses a template PHP called blade. There are several other template mechanism such as Twig that enables you to template your views to even add more granular way and cleaner. If its a single file system that you must what you are doing is fine because you are using require_once it enables you to call other files and you can modify that file and it will reflect any other files that references it. 

checks whether the value is an integer and whether it's a string that only contains digits (thus a integer in string form), any of the two is acceptable for the following check, . I've also moved out of the check, I'm initializing it to zero and will override if and only if there's a need. But let's see what happens if the check is true: 

I would suggest returning instead of when element not found. It feels a little more natural and expected. 

Well, more of a factory method now, which is silly. But not as silly as . If you absolutely need to keep the class's signature as it is, go for it. If not, a PDO wrapper would be the better approach. 

You need to add another css class to any of your paragraphs You need to change a css class to any of your paragraphs You need to convert a paragraph to anything else You need to change the text of a paragraph blah blah blah (there are a lot of other likely scenarios, but I think the first 4 are enough to illustrate my point) 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

Obviously, what's more important right now is to minimize that glorious readability mess, hopefully the (small) performance gain might be just the incentive you needed. Cache your jQuery objects You are using in and twice in . That's three times jQuery traverses the DOM to find , what you need to do is: 

This is obviously incomplete. The outer check is simple enough, it's whether is empty or not. If it's empty, nothing happens, if it's not, the inner check is on whether has a index, and if it's value is . If that's true, something happens, but who knows what? I'm assuming one of the things that would happen would be to set a proper value to . Anyways, if the check is false: 

Consider all of the above as extreme nitpicking, your code is way past the point of obvious flaws. The real value of the answer, if any, was to point you towards the SPL. If you did consider it and rejected it, would you care to share why? 

I have a private function in PHP that takes a given URL string and just leave the Alpha or numeric and certain punctuation left. I need the stripping of string due to having it match against ElasticSearch and ElasticSearch doesn't take it too kindly for special characters when it comes to exact match. The following function so far is working fine. 

I'm currently using a make shift INSERT on DUPLICATE UPDATE function that relies on a DB raw query from eloquent. I'm looking to improve the quality of the code and the speed. Please take a look 

From a first pass over - all you are doing are if else without any throw or inspection as to what possible errors that the PDO might be tossing out. Thats bad because on production servers - I would assume that you won't be turning on error/warning reporting but will be logging them. Also as @Alex L mentioned - you are missing a IF statement that checks if $pdo == null then throw exception. However its better with a try/catch 

Ok with all that routing question out of the way - I agree with mbanzon with basename being fine to check for internal directory structure to block people out... If you want extra security you can run a short alpha numeric check to make sure nothing funny is included. As for the white list - since this is a routing file and a static one a white list can also help speed things up as long as its minimal, one problem though with that is if you file system becomes extensive it maybe best to not have a whitelist at that point (you dont want your lookup to be too large to maintain and add. Side note: if your looking for interesting ideas symfony2 routing is pretty good (its being use at core with laravel). It is more extensive than your solution of course but still interesting to look at. 

I will apologize for the lack of formatting and using your code segments as straight example - but as I re-read your code I see my old self a whole lot and I don't consider myself any level near some of the coders here. However one important aspect to improvement is obviously trial and error and a lot of refactoring. So you asked about OOP going from procedural php within a single require I would assume your going into one right way which is using classes - however there is a lot of pitfalls in your code. The first would be that to effectively do OOP you should use SOLID design pattern. First there are plenty of ORM out there that does your PDO wrapper. One thing starters would like to do is to wrap a low level class (the PDO object) into a higher wrapper functional object - its not wrong to do so - but its been done over. In reality what you should do is not offer the user (ie you in this case) a simpler form of accessing data that you need while using the database. The database of your APP can change...what will you then? You will need to write a wrapper class again because your class is tightly coupled with PDO. Lets take a look at the database class 

In addition to the recommendations suggested by @Austin, you could inherit from to create an object to register and recall your functions. For example: 

To be honest, I didn't read through your code much because I don't have the attention span and it seems the biggest issue is the approach rather than the solution. Nothing about your code looks terrible or un-Pythonic, so I'm going to go through a different approach instead. The first thing that I noticed about the next number is that all but two of the digits of the original number remain unchanged. When going from to , the was incremented to a and the was decremented to a . When going from to , the was incremented to a and the first was decremented to an . This pattern suggests that we may be able to increment one digit, decrement another, and arrive at a solution. The first challenge is to find the digit to increment. Increment 

To address the recursion depth error, you could either change , or you could rewrite your initial solution to use as an argument to avoid the global variable. 

Note that this creates a new list object rather than altering the original word list in place. Your current code isn't terribly inefficient â€“ it iterates over the list twice rather than once, but both are asymptotically linear. If you were to keep that structure, there are a number of small things that could be done to make the code more Pythonic. Compare the following loops to your own code: 

Notice that this isn't contained within a because there isn't really a need for one; a method does the job better. Also, I made some (bad) changes to make the algorithm less readable. This new regular expression counts the number of 's that occur successively starting from the second-to-last digit backwards and replaces the old loop, the at the end absorbs the original . Now, if we really want to make things unreadable... 

We can't increment the because we can't decrement any of the 's. We can't increment the right-most 's because then decrementing the would lead to a number less than the original. Thus, we have to increment the first . We would reach the same conclusion if we considered the number instead. From this, we learn that trailing 's should be ignored. 

This is my first foray into the wild world of jQuery plugin development. The plugin "ajaxifies" forms, which isn't particularly spectacular: 

The first clause, essentially checks if there's an "old_keyword" index in the array (and whether it's or not), that's a pretty typical check for arrays. The second check, that executes if and only if the first one passes, checks whether what's in is not the same as what's in . I'm assuming that the author had some reason for that, but can't imagine what that reason is. Summarizing what happens here, if: 

Points 1 to 3 are user interface specific concerns. In an MVC approach they belong to the View and not in the Controller. Point 3 can be a user interface concern, if the texts are static, but can also be viewed as a data concern. The same way you get data from the database, you could collect all these static texts in a configuration file and only have to look at one file to change them across every View in your application. That could be considered a Model approach. Having said that, this: 

I was trying to explain the mediator pattern to a new developer, and ended up writing a simple event mediator. Thoughts? EventMediator 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

This way a function to get cabin information is available to all your controllers, you don't have to rewrite it every time you need it. Don't repeat yourself. If there's any HTML / CSS or any other presentation logic in your Controller, and of course any persistent data logic, you are doing it wrong (in MVC terms). But MVC for small sites may be an overkill. It's a correct approach conceptually, but you will have to decide for yourself if it's the right one for your application. But if you decide it is, you should follow it as is. A very easy approach to separate presentation from logic would be to use a template engine. There are quite a few of them out there, and there isn't one that's better than the others. Using one is more important than which one. And of course it wouldn't hurt if you didn't try to reinvent the wheel and started using an MVC framework. Or if that feels too much, a micro framework. There's is an often quoted article by Rasmus Lerdorf that some people perceive as advocating against template engines and frameworks. It's not, the only point of the article is that you don't have to use them. In the article there's a very nice and tidy approach on how to get an MVC kind of structure out of the box, without the added complexity of any third library. If you really don't want to use any third library, you should copy Rasmus' style.