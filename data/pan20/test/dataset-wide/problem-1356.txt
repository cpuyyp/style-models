See how that make using it a lot easier. Also you could add some very simple validations like notEmpty(), isSet(), isPositive(), isNumber(), ... . But for all of them php functions exist. So you might reinvent the wheel. But make calling your validations as simple as possible. The other thing is that in this way it's simple to add another validation method by just inheriting from your class and adding another validateSomethingVeryComplex()-method. Adding validations in your method would require to rewrite your code. And every validateSomething()-method should return true or false, depending on the result of the validation. An additional error could be included in a by reference param. But you will run into situations, where you do not want all errors at the end, but need a result right when you validate. And sanitizing/escaping is not part of validation, but a seperate thing to do. I would not mix these two topics. 

Your code does not do what you said it does (My code performs CRUD operations in PHP using OOP and dynamic queries). At least not in the way I would expect it. It does much more. And your way of using OOP just uses the possibility to extend a class. But even your base class DB already does completely not db related stuff (issuing location headers is no db-task, isn't it). And your Admin class does things like getting patient details - what has this to do with admin? Or doing the acutal login for the admin and then redirect - that's not db related again. I was quite surprised to see a method sqlQuery() do an insert without any params. Please use a class for a single thing. If you want to do redirects in a class, then create an extra class that is only used for the redirects. What your question sounds like is more like using a MVC-scheme. Model (= database), view (= html code) and controller (= logic to connect model and view). There are good frameworks out there, that would definitly help you to do it. Or you can do it yourself. Some basic structure you might use - if you do not want a MVC framework: Database-Classes: IMPORTANT: no html code and no redirects in these classes. ONLY db related stuff! 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

You're matching the regexes in a loop, giving it \$O(n m)\$ performance instead of \$O(m)\$ where \$n\$ is the number of regexes and \$m\$ is the length of the text being matched. Any halfway decent regex engine can match an arbitrary number of regexes simultaneously and then tell you which one matched (a trivial extension to the way is matched; I've done this in C); I am not familiar enough with JavaScript to know if it has one. Possibly since these regexes are fairly simple, you could capture a fixed piece of text and then use that in a dict lookup? 

All of the above, except for the last two which are special, provide exactly the same public API (except ) and can be implicitly constructed from each other if it makes sense. 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

Although ternary operators are a powerful concept, they're easy to abuse as well and can cause either bugs or a WTF during code review. My personal guideline is to start favouring an construct when either the condition has multiple sub-expressions or when the manual is opened under operator precedence. 

Problem The cost reporting component cross-cuts two main areas of the model, i.e. purchases, refunds and provisioning (shown above). Purchases and refunds of any product are recorded for royalty payments and provisioning keeps track of software updates (between versions there may be added or removed royalties). My possible solutions So I have a few options: 

Actually, both methods assign the value first before comparing its value. Therefore, in terms of efficiency, there's no difference. For code readability, you could write extra parentheses around the assignment if you choose method A. Method B has a slight advantage when you have to perform debugging before the branch, i.e.: 

Background My project performs software application management; it covers in-app purchasing, product provisioning, account management, etc. I've recently been tasked to add a cost reporting component. Code On the code level, I've spread out my model into a few classes that represent categories or interest areas, each requiring specific dependencies. Here's a rough outline: models/base.class.php 

There is no good reason for you to make 4 separate calls. Most likely a single call for would be enough, but even if you have a pressing need for them to be on separate pages, you should still 4 pages in a single call. You don't need to open to get anonymous memory, just pass as the FD and add the flag. 

If you're using , you shouldn't have the shebang in the second script. If you're using the shebang, you shouldn't use . But rather than use directly, I would the script once at startup, and in it define a function that was called at the later times. You should use instead of to avoid forcing a separate subshell to spawn. I would provide a default instead of exiting if no argument is passed. Something like . Also, I always use named variables as early as possible. Note that if you were using a function (with or without ), you should use to avoid leakage. 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler). 

What you've written is more or less the standard implementation of . This is an equivalent approach: 

Make both my classes aware of the reporting unit; this means extending the constructor and what not. Apply Decorator pattern to "intercept" method calls. Apply ObserverMediator pattern; each class will emit "interesting" events and the reporting unit will listen for them and make the appropriate changes to the database tables. 

You can wrap the functionality in an object. You instantiate it with a canvas element and some configuration options. 

The ternary operator I've used above is yet another way to do your branching; its efficiency is in the same ballpark though. Since the variable itself is used solely in the truthy branch you can also use the shortened ternary operator (>= 5.3) like so: 

Questions Does it make sense to spread out my model into separate classes in the first place? Would it make more sense to make one big class that encompasses all my application logic? ObserverMediator pattern has its pros and cons; the advantage is that you can easily decouple units from each other, but the downside is that it's indeed decoupled. Are there other cons? Is there another pattern I could apply to crack this? Is there some other major issue with my code?