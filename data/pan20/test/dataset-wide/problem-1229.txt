is going to be very hard to test. If only you had made an interface on the , you could do something like. 

You can see that the new structure (which doesn't functionally do anything differently than the old structure) lacks a top-level logic that checks based on the low level data. Choices now know if they beat each other, and Scores basically update themselves based on asking the Choices. In the event that you needed to make a Rock-Paper-Scissor derivative, like Rock-Paper-Scissors-Lizard-Spock, you could simply modify the Choices and not need to touch how scoring works (or go searching through all of your code to see if it impacted external logic). 

Overdoing static is a code smell. Basically you have to balance things. Too much static code typically means not enough code in the objects, or not much object oriented structure. Since objects provide boundaries between the in-object code and the rest of the system, they allow "leverage points" for future change (and for testing). You can, for example, subclass an object to provide a variety of implementations of a particular class method. With static methods, no such polymorphisim is possible. This can lead to switch statements embedded within the static method (to function on key fields, acting somewhat like the state pattern). The primary reason this tends to become a smell is that switch statements put the burden of code maintenance outside of the object. In extreme cases, it begins to feel like the object is not encapsulating it's behavior, but rather the switch statement dictates external behavior depending on the data fields within the object. Such code becomes difficult to maintain over time. I would avoid static methods as much as reasonably possible; however, in some cases it is a better choice to use them. For example, one would not typically benefit from subclassing the java core types. So if I needed to write a method that operated on String objects, I would probably prefer to put that as a static method on a class. On the other hand, if it were a class that I had written, I would probably go out of my way to stay more object-oriented. In your example... 

So many people have commented on that I'll just avoid adding extra comments past this; however, I do want to talk about the which is another "thing" that exists in your program, yet there is no corresponding object. 

If you are sending everything through the controller, it's not exactly MVC. The beauty of MVC is that most of your views "listen" to changes in the model, which means the controller doesn't need to "update" the views for regular data changes. That limits the controller's updating of views to cases where the view needs to be laid out again (such as changing screens, layout, etc). Models that model changing elements (like clocks) don't even involve the controller. The model calls a (typically) private "changed(...)" method which signals all of the listening views. The views then fetch the data they are interested in (might be different depending on the view), and the view then invalidates itself (to schedule a redraw of itself). One clock "view" might be a digital clock, another might be a changing non-editable text label, a third a "solar" representation of the sun / moon in different phases (dawn, morning, noon, etc). Your solution could probably be fixed pretty easily. Initialize the views with a reference to their viewed model and cut out the controller "updating" the view for any data-related stuff. Normally the controller will still have to update the view for certain items, mostly for presentation (which view is visible, etc). Have the assignment of a model to a view cause the view to "unlisten" to the old model and "listen" to the new model. In the model, have any data change notify all the "listeners" of that model object's data change. The "listeners" then need to re-pull whatever data they might be interested in. 

Not bad. Regarding your concerns that toPretty.json is visible from outside object-scope, people typically get around this by using the Module Pattern. 

Ah, the age old pragmatism vs. purism. While it sounds like you have a healthy amount of skepticism, I think this is actually one of the few instances where it's OK to use a global variable. The core of your problem is you need to share data (state) between two routes. A global variable is the simplest way of doing this if all you're doing is appending the number 4 each time. Here's some things to consider: 

This will make sure that sure only one $db is ever created. Here's the source code from Pimple's method for demonstration purposes: 

I'm not following. Which file/object? You appear to pass the JSON object from to your constructor, and this is just a plain JavaScript object. 

I think this is fine for something as simple as a volume control; however, there are some limitations to at least be aware of: 

You could simplify this even further by using a single CSS class for all elements that need animating. e.g. Also, if there are any animations that are triggered by mousehover, you could do all the animation in CSS with the pseudo-selector. Finally, make sure the CSS transitions you use are compatible with all the browsers you're supporting. 

Move the PDO object to a constructor argument (see below) so you're not violating the Law of Demeter (see #1 and 2 here) Remove altogether and simply return the result from the method in which it's built. Break this into smaller, more meaningful methods based on responsibility (see #4 below) Create and methods with optional parameters 

Use CSS classes elements that share the same animations. This way you can just fetch all the elements that need to be animated with a single . e.g. Instead of using jQuery's animation methods, use CSS transitions. This will make your code simpler, and you know you're using the browser's native animation rendering. 

The advantage here is can be anything as long as it shares the same API. OK, so now let's talk about ensuring only one DB connection exists at any given time. Since the DI dependencies are just anonymous functions, you can just use the static keyword inside of the dependency definition; however, Pimple makes this even easier by providing a method that does this for you. As per the documentation: 

Since RequireJS invokes the module, it would be problematic to construct dynamically. There's no good way of creating more than one instance of your view â€“ probably not a problem. The View is tightly bound to a specific DOM structure. This means it will require extra code to make your View responsive. e.g. a small volume control for mouses (desktop) and a big one for fingers (mobile). 

While this may seem "decently normalized", it's not. As you said yourself, there will be a lot of (redundant) NULL values, but also, relationships will not be enforced correctly, as this schema allows for duplicate records for any combination of Post/Group/Link and Tag. For instance, you could have two tagmap records with the same and . Now, while you could add a compound key consisting of PostID, GroupID, LinkID, and TagID, then you have another problem: a single record can contain more than one (non-tag) Post/Group/Link relation. e.g. a tagmap record with = 1, = 1, AND = 1. This can lead to update anomalies. See Second normal form. A normalized solution would be to have three separate tag-relation tables as abuzittin gillifirca suggested: , , and . Doing so will eliminate all the redundant NULL values and allow you to enforce relations correctly. Having said that, I'm guessing you came up with this design, because you want to use a single query to fetch all entities assigned to one or more tags. You can still do this with multiple tag-relation tables like so: