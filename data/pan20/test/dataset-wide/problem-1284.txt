You might be asking why there are some null checks missing. The parent project protects the type converters from nulls. It is also not possible to use generics everywhere because most types are reflected and not specified at runtime. 

Common is not a good name for a class and it probably contains many unrelated methods. Try to group them in classes that have more concrete names like here the name would be great or even but at least something more specific. If I see I think: StripPrefix from what? however clearly suggests what's going on. 

Example As an example of how I'm using it, I post one of the unit-tests I created for it and the schema of the test table. I import the test-data from a CSV, I turn into a and pass this to the seeder which takes just 4 lines of code (not counting the constants). 

In order to make your switch testable and extendable you should split it into multiple classes. One class for each operation that could look like this interface: 

I cannot help you refactor your code because it's incomplete and lacks any context so I can only give you a general advice about 

Benchmarking The s shouldn't measure thier execution time. What if you want to run it more then once? You cannot measure the entire execution time. Instead create a . 

I already hear the voices saying oh no!, this is so slow!. Well, if you think that, then you can implement your own and that are aware of and don't have to iterate the entire collection. Then it'll be much faster but only if you have arrays with an insane number of items. 

The class itself is a and for creation requires a few basic parameters that a log at leat must have. 

As a result the extensions have changed a little and have gotten a new method and refactored validations: 

it will still produce the same result but it's simply easier (should be) to do it via the builder. There is no pattern that enforces it. You write one (builder) because you want shorter, more natural code. 

Disposing You know the statement but you are not using it for all disposable types in your code. There are more like the cancellation source, the sql data adapter or the sql command. 

There might be. If the type is under your control then you could implement the interface on it and return the sub-image collections: 

Then I have a test to make sure the opposite, this is, must be called if the type of the value is not one of the target types. In this case != . 

If you are comparing strings like these you don't shouldn't or anything because it's not easy to find that you actually do a case insensitive comparison. I find it's cleaner if you use the case insensitive overload: 

The new throw expressions in C# 7 are very nice but unfortunatelly they cannot be used when string must not be null or empty. You can workaround this with a helper extension: 

To sort your you should be using data-binding and let WPF do the work. First let's fix the that you currently populate manually. For the sake of this review I assume you use your code-behind file as a data-source that is bound to the via: 

false - means arr1 is fully contained in arr2 The good thing about lookup is that you don't need the method because if the key does not exist it'll return an empty collection. 

Using the in this way is usually a bad idea. It should be disposed as soon as possible. Besides this code cannot work. You pass it a but later in code you use the property which doesnt't belong to this object but to the . 

Caching To avoid multiple loads (for each attribute occurance) the file is cached for the lifetime of a request and loaded by another helper service I call . 

DictionaryToObject You don't need to call over and over. You already have retrieved the properties at the beginning. It might be real performance hit if you do it frequently. Luckily this can be easily avioded. 

Due to many confusing names (builder or factory?) and no single clear dependency structure I suggest cleaning this up first (probably by completely rewriting it). 

This should contain a but even with it, it won't work yet because the first won't pass the second time. The logic is more complex and it would require a flag to skip "" spaces. 

It's pointless to have both the constructor and a get/set property. Make the property either readonly and required via constructor or leave it optional and get rid of the construtor. 

- This is just a symbolic placeholder because the quote formatting does not display an empty line at the end. 

If you want to be sure that each workbook is properly closed you can add another for the data files inside the loop. 

I'm building a RESTful service that sends emails with body rendered by partial views. It replaces my old solution that used hardcoded templates of inside each application. One of its features is to inline es as . I'm using because it's easier to design a view this way. Since it's about emails, I'm not expecting any fency style selectors and to make it simple I'm using only es. 

SRP A downloader should only be able to download. If you need to search for urls or parse some websites then you need other classes that specialize in such tasks. Don't put all these responsibilities insinde a downloader. It's not its job. It might even turn out that you will have only one downloader but mutliple website-parsers or link finders etc. 

I'd like one of my RESTful services to support plugins. Currently it uses references hardwired at compile-time. The Application Parts seem to be THE solution so I gave it a try and created a small proof-of-concept service. It loads plugins located in the subdirectory. Each plugin is located in its own subdirectory named after the plugin itself and it may contain its own dependencies e.g.: 

Now let's get improve the variable. This one is really confusing. Is it asc when it's or ? It'd be much easier to use if you named it . Then is the same line: 

I don't find many things to complain about :-) but this bothers me... I would change the name of those variables: 

If you must give variables single letter names then let them at least be derived from the main name. Here or would be appropriate. does not stand for anything. The only exception is in lambda expressions which stands for current-item. 

ViewModels What about the views? You don't need three of them. I guess you have three categories. You add one category and you need to create a new view for it and adjust all your queries - a lot of work for a small change. I find you should have only one view-model with a single view that can recursively (or with a stack) display all categories. You start with the ones that have no parents and and get then the ones that have this one as their parent and so one until you have displayed them all. A new type for the results: 

And that's it because you now have a very LINQ-friendly class that you can use like this where you can parse all lines with a simple : 

There is one issue with stopping the scheduler. You are using the variable to control the loop of the method but there is nowhere any mechanism to stop the task. I think the scheduler should be and use a to cancel the method that initialized it. 

You now have a calculator that works. The next step is to read from the console... but maybe you want to read the numbers until the input is correct? Currently it would crash if you enter a letter. So create a helper for it that will try to parse the input until it's a valid value. Instead of using for this job you could use to get more precision: 

Buildings can be upgraded thus the method which increases its level. Each upgradable type implements the interface then so you can even filer on that. I don't know how you generate your map but for the sake of this example I did it by hand: Here's a simple city: 

Googling for xml compare c# produces countless results so I just review this code without suggesting anything alternative. 

A nullable value has the so that you don't have to check against null, it cannot be null, it either has a value or not 

You seem to be using expressions. Be aware of the performance hit if you use it a lot. If you use C# 6 then this would be a better alternative: 

It's a good start. Here are the changes I suggest: I think you should be able to execute the queries without sharepoint. To make it possible we'll remove the sharepoint stuff from the repository and put it in another one. We then combine them with a decorator pattern like this: The first step is to extract an interface (or an abstract class): 

Bug There is a bug in this method. It counts non-working days because the condition needs to be negated. 

Examples The code that needs to be written for each request uses a marker interface, here the . Without it, it wouldn't be possible to write extensions only for a particular resource so it's passed through the entire chain. 

If you don't care about performance the most generic solution would be to use and not to modify the original list at all. Usually you don't want to do it but return a new collection instead. 

Random file names Instead of creating random file names by yourself use the method already provided by .NET: