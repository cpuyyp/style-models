My situation only included static methods on non-static classes, but it should work just the same for your situation. 

Admittedly, the logic inside the loop for display purposes is a little hairy since you have different criteria (less than as opposed to less/greater than or equal) for the first age range, but that cuts down on the operations you need to do on the set of data. 

I agree with Raj that you are probably best off not trying to unit test your WCF services themselves, but I have a suggestion specifically around your concerns regarding your static class/methods, assuming you are using VS2012 or later. I recently had to write some unit tests for some classes that themselves called some static methods that I could not modify. What I ended up doing after some research was utilizing shims. Here's a simple example: 

Pandigital testing You are making a tremendous sacrifice of efficiency here to implement this in terms of . itself, although not terrible, is also not great. To even get there, however, you need to format your number as a String, which by itself is more expensive than one whole pandigital test needs to be. You could instead just pick off the digits one by one via the modulo and integer division operators, and keep track in an array, or even in bit-array form in a single (only 40 bits of the 64 are needed). General is a wider data type than you need for representing the numbers being tested. is wide enough to express all integers having nine or fewer digits in their decimal representations. You could, and probably should, use -- or even better, -- everywhere you currently use . Also, there is a space vs. speed tradeoff available here, where you have opted for using less space. It is possible to augment your sieve to efficiently fill an array with the actual primes it discovers, particularly if you're willing to declare a big-enough array at the beginning, and not worry about unused space. It would be more efficient to process the elements of that array that are in use than to iterate over the whole range, testing directly against the sieve. In fact, if you do this then some of the extra space need be consumed only transiently, because you can let the sieve itself go after you finish filling the array of primes. 

Why bother with having table be a two dimensional array when it is just a stop-gap collection to get you to ages and districts? Why not just do something like this: 

I don't know how I feel about this implementation. It certainly is better than what was there before, but I have a strong sense this could be improved some how. So now, in the relevant pages, I can simply do this: 

Additionally, depending on the size of your data set, why do five different Count() executions on ages when you could just group that data before hand like this: 

Now I will iterate over everything in and afterwards, I want to know if it was empty. Here is how I am doing that currently. 

... and skip the initialization loop. (Elements not explicitly designated in the initializer get initialized to 0.) Comparative efficiency It's hard to be sure what to compare here. The two codes comprise slightly-different versions of the same underlying algorithm. Implementing fixes for the various shortcomings I discussed would bring them to pretty much the same place, which would look more like the second code than the first. There are a number of possible variations on this approach, some of which may run slightly faster than others, but I don't see room for anything substantially more efficient. 

See also below. Flawed implementation Your code can easily be made to overrun the bounds of the array. In fact, that will happen if the number of usable key characters is smaller than the number of letters in the message. To (partially) fix this, you need to wrap around the end of the key inside the loop, rather than at the end of the loop where you now do that. That will, however, expose another flaw in your implementation: it does not handle the case where there are zero usable key characters. Your current implementation will just immediately run off the end of the array in that case; after the fix, it will loop infinitely. See below for a suggestion that will help. Error handling does a decent job of noticing when memory allocation fails or nothing is read from the input. It helpfully returns in those cases. , however, ignores those signals and unconditionally passes the result to . For its part, assumes that its argument is always valid. Either 's behavior or 's could be ok in isolation, but together they constitute a flaw producing undefined behavior under some circumstances. Similarly, returns in some failure conditions, but pays no attention, assuming that the return value is a valid pointer, in attempting to print it. Implementation improvement If you have (which is standardized by POSIX, not C itself) then it is a convenient alternative to + + . calls before prompting for the encoding key. This is useless. Move the flush after the prompt, or remove it altogether. Since the prompt ends with a newline, it is probably unnecessary to flush even after printing the prompt. I remarked above on problems with your key handling. I observe also that you handle your key inefficiently if it is short relative to the phrase to encode. You shouldn't need to check on each pass through the key which characters are usable. You shouldn't need to account for upper- vs. lowercase on each pass, either, if indeed you make them behave the same way. Instead, process the key once, before the encoding loop: remove characters other than letters, and convert all the letters to a standard case. Then it's also easy to validate result to ensure that there is at least one (or two, or whatever) key characters. It doesn't make sense to me that your encoding code is not parallel for upper- and lowercase key characters. The code for uppercase keys looks equally applicable to lowercase keys except the computation of , but you use a more complicated and difficult to follow scheme for lowercase key characters. Indeed, one of the alternatives for lowercase keys cannot even be exercised, because and cannot be true at the same time. Design improvement Your function modifies the input string in-place, but also returns a pointer to it. On the other hand, the function's name suggests that it will create a new phrase. I suggest changing that function's signature to 

I'm refactoring some code around a couple of ASP.NET Web Forms pages and decided to try out a variation of the Abstract Factory pattern of my own design. I need to create an implementer of an abstract class based on what query string value is available. Here's (a simplified version of) what I have right now: 

I'm playing around with switching some code to using and I have a question about whether I need to be concerned about the effects of concurrency here. Here's a simplified version of what I'm doing: 

This works fine, but I'm asking here as a fishing expedition to figure out if there are any clever ways to implement this functionality without either: 

(Or even better, use static final strings belonging to the class instead of string literals.) The localized format strings on which that method relies will use argument specifiers to designate which argument to format, so as to be able to accept the same (some possibly unused) field values in every case. For example, in the en-US locale, some of them might be 

It's at least twice as costly as rearranging a min heap appropriately without removing the modified element could be made to be. You've given no basis or context for putting that on absolute grounds. 

Your code exhibits some inconsistency about whether binary operators are separated from their operands by spaces, sometimes even within the same expression. I find code much easier to read when there are spaces around such operators, but if you choose not to place such spaces then at least be consistent about it. Personally, I prefer also to see space between keywords and parentheses (, , , etc.), but not between functions' names and the parentheses around their arguments. That's a bit easier for me to read and parse, but it is of little significance as long as you're consistent. 

For this application, I do not care about the order that my objects are added to (in fact, I do explicit ordering later on). My question is whether I could get into trouble here with both functions attempting to add objects at the same time. My motivation for playing around with this is simply to try to speed up this sequence of events, and when I tried using a instead, my timings, obviously slowed down to the point that there was hardly any difference between doing these two operations in parallel versus the old, serial way. When I use a simple then I do see impressive speed-ups. So, considering I am just adding objects to a collection in a parallel fashion, is using a non-thread safe collection asking for trouble here? My real-world experience with multi-threaded/parallel programming is very sparse, hence the uncertainty here.