Here is how you would do it with no for loops. The function computes the distance between every pair of rows of a matrix. So you have to apply it to two matrices: 

The profiler showed that rbind-ing your 16.5k data.frames was the main culprit. Instead, I create a data.frame after dumping the list of sentences into a single vector. I am also able to compute the vector of corresponding filenames using the function . Untested: assuming was also computationally expensive, I used again to append the and . You could check by yourself if this is instead faster this way. I used the supposedly faster instead of Your is presumably a slow re-implementation of the function I replaced with the faster construct. Also with . and are slower because they try to simplify your output data. Where possible, I have avoided large duplications of your data, e.g. where you were using . Instead, I just appended column(s) to your existing data 

You are using both the and operators for assignments. I'd recommend you pick the one you prefer and stick to it for consistency (for info, the community standard is to use ). returns a data.frame so was not needed. Your data is only numeric (even integer) so you could have chosen to store it into a matrix rather than a data.frame: . Matrices can make many operations faster, though not the ones you are using here. 

Rather than saving the answer in a static or object-level variable, you can return it from your functions. This lets you keep more careful track of what makes changes to it. Imagine if you had a lot of different functions like that incrementally update the answer every time they execute. If you started seeing the wrong answer due to a bug in the code, it could be difficult to trace it to the broken function. To handle the object-oriented way, rename to whatever you like, change both of your functions from to type, and return the partial answer and the end answer from each of them, handling them locally. You can make a new that calls your renamed function and handle the printing of the answer in instead of the function that does the work. 

Nice solution. This code is pretty legible, which is great if you have to debug anything. There are a few simple ways you can make your program more user-friendly and resistant to user error. Input: For the user, it can be tedious to type in their values on every line, always being asked for 

What would happen if instead of 4 objects, you had 2000 objects? Do you see yourself typing ? No. Maybe you will find about the or function so you can do: 

5) is a questionable variable name, given it is also the name of a base function. 6) This is debatable: I would get rid of the condition since it won't hurt doing the swap even if . IMO, the simpler code is preferable to the marginal computation time gain. 7) A nit: know the difference between (numeric) and (integer). Here you are using when you mean to use , which causes unnecessary conversions from integer to numeric (though the operator brings you back to integers by doing the opposite conversion). 

matches an input string to a pre-defined list. It allows for partial matches and handles the error in case it can't find a match. is like a smart for doing "the right thing" depending on the input. 

You have written six times in two lines... Store it in a well named variable (maybe ?). Same goes for . Also, was not needed, you could just use R's recycling rule: 

Object Oriented Programming: Generally, static variables should be reserved for variables that are shared between multiple instances of a class, and any other variables should be made local or non-static. The static variables you've defined here work properly, but reorganizing the methods and changing the variables into local ones will make it easier to add functionality to this calculator later. 

Can you use and to read in all of your numbers and operators at once, from a line like or ? matches a regular expression, and is the pattern for any single character. Error Handling: What happens if the user types in a bad operator? If someone tries to ask for , the operation is ignored in this case. Instead of getting the result of = 12, they could get a result of 21 without realizing there was a mistake. A good way to protect against that is to use a statement in your switch block. A way to handle these errors and let the program or the user know there was a mistake is by writing 

Have a look at the function . It is vectorized so it can treat all your dates in a single (fast) call. Your code should look something like this: 

If you need to convince yourself that was called a single time, you could add a somewhere inside its body (I did!). having been called only once, there is no need to say how fast the computation will be. Finally, if you want to store the distances in a three column (airport1, airport2, distance) data.frame rather than a matrix, you can do: 

I hope some of it is helpful. Please let me know. And thanks for sharing your Fortran code; I know at least one other R package that uses it: whose function for computing euclidean distances is extremely fast. I want to give a try one day. 

You might also know that is a disguised loop: while syntactically shorter, it is just as slow when it comes to computation times. Instead of , you could just do: 

If you only want to work with the 3 closest stations, you can write a function that will only keep the three highest weights on each row and turn all other weights to zero: 

is never actually changed or used. is functionally equivalent to the loop that you wrote. This is a fairly common pattern, and there are a few ways to go about organizing it. Yours is handy because the variable communicates that this loop will continue until something is 'done'. The best place to explain to the reader how a loop is supposed to terminate is right there in the condition. One more descriptive (but also less clean) way to write that condition would be 

This assigns the operator to and performs the comparison without the need for a statement. You can use a do-while loop to handle the first number and print "Operator: " to the console before reading , if you like. 

is a primitive type, while is a class. That distinction won't cause a logical error here, but consistency always helps when a program grows larger and more complex. Order of Operations: Your program handles each step of the calculation correctly, but it doesn't understand Order of Operations. That's a more complex concept that you'll have to look at a whole expression for instead of being able to handle each operation piece by piece. The fully object-oriented solution is to treat the expression and the individual operations as their own objects and apply logic to those objects piece by piece. You could, for instance, create a list of numbers and operations, and scan through that list, applying the highest-priority (multiplication and division in this case) operations first. The fully functional solution is to scan the expression and use recursion to decide which numbers need to into first, returning the results of each step up until the base function returns the final answer. There are many ways to do it, and you can think about how you'd like to implement it in your calculator