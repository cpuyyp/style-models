I have a list of elements (well, nested lists of elements, really) that the user can reorder (using jQuery ). A simplified view of the structure is something like: 

That will do the same thing as your code. Also, please consider using variable names that are not just single-letters. 

Separation of logic and presentation; Instead of composing a big long HTML string in I'd recommend having the basic structure of the output as part of your markup. For instance, contained within a that is set to initially. Then the only thing needs to do is update the parts that actually change and toggle the visibility of the . That will result in less code and be more maintainable than trying to construct the entire HTML snippet programmatically. 

This works, but as the notes I found that filtering using is incredibly slow. If I don't filter on , then what happens is that nested instances affect the count, and the numbering is incorrect (numbers jump like 1, 8, 17, 32, etc.). Can anyone suggest an alternate approach that will produce the same results without the performance hit? 

To provide some background context, I'm implementing a web-based solution (Java, Spring, Hibernate) that allows the creation/authoring of task-centric workflow documents. Basically a workflow provides an ordered collection of tasks (and related content) for a user to step through. One of the available task types is a "risk assessment" matrix, in which the user selects a "risk" level (i.e. "how likely is it that this thing will break?") and a "consequence" level (i.e. "how bad is it if the thing does break?"). Based upon their input, some text provided by the workflow author will be displayed. Essentially these tasks are backed by a 5x5 matrix of strings, and by selecting a "risk" and "consequence" level, the user is indicating a position in the matrix. There's one further complication, in that all text provided by the document author must support internationalization. To deal with this I've implemented an entity, which simply refers to a collection of entities, each one of which specifies a language, and a string of text in that language. That all works fine. What I'm wondering about is, what's the best way to store the matrix itself in the data model? I can't just serialize an array of Strings, as each position in the matrix is actually occupied by an instance and not a . I suppose maybe I could serialize an array of ids, but that seems fairly hacky, doesn't it? Under my current approach, I've explicitly declared a field dedicated to each position in the matrix. That makes for 25 getters and 25 setters. To avoid having to deal with that nonsense, I added some helper methods that take advantage of reflection in order to get and set fields based upon their matrix position, in standard notation (I use a two-dimensional to transport the matrix data to/from the rest of the application). What I'm really after is the cleanest, most convenient way of managing the matrix content. I think what I have is fairly reasonable, but can anyone think of a better approach? Here's the code: 

ps: I can't just do something like , because I need it to shrink as text is deleted. Also, I don't want to remember the previous count and just calculate the difference, because some changes will inevitably be missed and a differential script will never right itself. 

While the above solution works, it is somewhat inefficient and messy. This stems from the fact that you're trying to get javascript to work the way you want, when what you should be doing is trying to understand how javascript wants to work. Each language has a style, even a personality, and if you're flexible enough to go with it then your code will be shorter, faster, and cleaner. Here's how I would abstract away my JSONification. 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with. 

That has the benefit of not creating properties you don't use. Also, did you strip out some code? Because it seems like all you're doing is storing a reference to an object. Why not just use the object? 

I am writing a script to count the number of rows in a textarea, and as it will be called on every keypress I want to make sure it runs as fast as possible. I'm not aiming for a general solution: we can assume that the textarea has a monospace font and enough horizontal space for exactly 80 characters. I've probably solved this problem in 20 different ways, and this is by far the fastest solution I've come up with: 

Note that this allows you to easily pass the field itself to , instead of just an arbitrary key. Functions; I'd recommend the following style when writing functions: 

Globals; I would prefer using ids on the input fields (or even better, a jQuery selector) to retrieve them rather than going through . Like: 

Each inside of is sortable, and each inside of is also sortable (independently of the other sections). Each element within these sections is numbered according to its position in its own list. So to continue with the example above, the correct numbering is: 

I don't see anything in your code that should cause any performance issues. You're not doing anything iterative, or performing any complex operations; your code just executes linearly and changes some CSS properties. That shouldn't kill performance. Have you seen anything to indicate that this code does kill performance? If so then the only thing I could suggest is changing the events that you listen for (or maybe, adding some logic to ensure that you don't start a new transition while the current one is still running), as perhaps the page is triggering more and events than you expect. Premature optimization is the root of all evil, and all that. Also, you should be able to do: 

Globals; Even more than above, I'd prefer not having these globals at all. Instead you could retrieve them as needed in your functions (and/or pass them in as parameters). Event Handlers; If you're just going to use the and attributes, there's no need to bind them programmatically. You can set them up in your markup instead, like: 

There's an additional complication, in that each can contain a new repetition of the entire structure, beginning again from . This nested content, however, is essentially spurious and should be ignored for all practical purposes. Anyhow, to apply the numbering to the inner sections (and simultaneously ignore content in the aforementioned nested sections), I'm currently using the following code: