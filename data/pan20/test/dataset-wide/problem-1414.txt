While this is a relatively simplistic and deceivingly elegant implementation, insertusernamehere's solution is admittedly an order of magnitude faster, when using an array as a perfect hash table for non-negative integers instead. 

Overall, it gets the job done, but your code (especially the area I'd refer to as "pyramid code"), could use a little more organization and clarity. Your statement could be a little more concise, and, at the same time, more canonical about what it's actually there for: 

I'd appreciate any feedback on improving perceived responsiveness for the feature this UserScript adds to the webpage. I realize changing the URL after a slow image load within might make the URL change seem slow, but I also noticed that when calling or within a listener to or events, it appeared to cause the fusion image to load significantly slower. Though this UserScript still functioned properly either way, I'm curious if anyone can come up with an approach that improves responsiveness overall. 

If you are at all familiar with using promises, then you'll recognize this pattern. While it is typically considered an anti-pattern, this particular implementation is written properly, and is also necessary in this case to take advantage of a convenient implicit race-condition behavior of promises that I'll explain in a moment. 

This part is pretty straightforward; we're creating a timeout given the amount of milliseconds supplied from or the default , and invoking the callback function in that amount of time. 

And as promised, here is the link to the repository, which also contains formatted documentation on the respective github pages, and a full demo on Heroku. Please be responsible and only make HTTP requests to the Heroku link sparingly, as I have it hosted on a hobbyist plan, which only allows so many hours of uptime a month. I have plans to implement a service worker for it in the future to mitigate this issue. 

This line invokes the native method with the wrapper's arguments and resolves the explicitly constructed promise with the fulfilled object, if, and only if, it is successful and it completes before the callback is invoked. The reason this occurs is because of the specification: a promise can only be fulfilled, rejected, or remain pending forever, and if it is fulfilled or rejected, it is "settled" and cannot be fulfilled or rejected again. If it is unsuccessful, and it fails before the timeout occurs, then it will invoke with an error. 

Now you can prevent the user from manually setting by marking it as private, thus, forcing the input to be validated by your setter. 

Putting a function inside the jQuery function is shorthand for , they are the same thing. So, the answer is: yes, it will be more efficient. jQuery's method just waits for the DOM to be ready before firing the code inside but when it comes to setting event handlers, you actually don't have to wait for the DOM to be ready at all. jQuery allows you to attach your events to the object itself and when those events bubble up, jQuery will call them. So instead of using 

I recently implemented this same thing, here's what I used. Main difference: Let the for loop do the math for you. By the end of the first loop, if there is half a star it will be in the variable. Use an array to buffer your string (or create DOM objects instead, don't use to build a string). 

The benefit is that you don't have to wait for the DOM and you don;t have to loop each element and assign a whole bunch of event handlers.. Your current updated vanilla JS code is duplicating that event handler function in memory for each and every element you apply it to. That will eventually start to eat up memory. You should have been using instead of all along, but you can still do the same with vanilla JS.. Consider this re-write of your "DOMContentLoaded" function.. 

Your loop is testing so your're only omitting the last char, not the last two. If you want to omit the last two the loop needs to test instead of . The entire for loop can be shortened into 3 lines... 

If all you need is to generate a simple list then there is no reason to use react. React has a lot of components that your code doesn't have, like interactive features, etc. If you take a few minutes to read about exactly what react is and does the answer to this question will be clear. 

My version uses several C++14 constructs. This is intended, because the code is part of a lesson for teaching about C++14. Is there anything I could do better, especially with respect to C++14-ish code? 

I want to show how to interact with C from C++ and chose a simple and small library to demonstrate. zlib's , and looked like a reasonably closed set of funtions. Does anyone see anything fundamentally wrong with my presentaion? The main code I present here is in . Intro section: 

And with C++11 you do not even need that, you have and ranged- to beautify your. variable initialization 

I feel like some places could be improved, maybe. The iterators maybe? Getting rid of the loop in favor of an algorithm? Maybe even not returning a full at all, but only an iterable proxy-object, but that would too long a shot for this small example, I think. 

In big files you may want to "sectionize" the using by from which they came from. (Edit, thanks to comment below) Best do not introduce before other though, you can group the using afterwards. E.g.: 

I want to return an iterable collection of all q-grams of a provided string. This means all sub-words of length . Let be 3 for example: as an already whitespace-stripped and upcased word or string. and are constant strings and that are put surrounding the string before splitting. That is a common trick to get more q-words. For the word the resulting q-grams are therefore: 

The exception are "tight loops" when the frequent initialization and destruction would cost to much. But actually, is quite cheap and this is not a "tight loop", so I would recommend it. 

It is ok not to initialize , because it is a class/object. But you should initialize variables. latest possible declaration 

Note that creates a copy in the inner loop, where one can add before adding it to . Instead if the new C++11 ranged- and one can of course just use lengthy iterator-based -loops. Using instead of would also work, I guess. There are no set-operations involved here. Actually, now that I think of it, would be much better... hmm... One could save some copying by pulling out of the loop, initialize it with a a size of and use to put the values into it. And if one does that, one can even save the copy of all values by just replacing one in the inner loop, but I can not see how right away. Ah, well and you need a printing routine, of course. 

Why do you do ? You don't write or . Be consistent, just do without . It's easier to read. Fix your indentation, especially where you have nested switches, that is really difficult to read. Organize better. Do all your variable definitions at the top. In javascript you can use an array literal () instead of . I believe literals are slightly faster. 

Once you make these changes your JS only needs a single element from the DOM: the stylesheet. As long as you put the script immediately below the stylesheet you don't need to wait for the DOM to load. Here's the re-write: 

Any parameters that are required for the class to function should be passed into the constructor. That's what it's for. If you're still constructing the class by setting things after the constructor is called then you're not using the constructor properly. Sending a buttload of arguments is a crappy idea too. If you have a class that needs lots of data to construct, consider using an array. 

If you want it to work for both request types then why are you only validating ? That's a major bug. If GET is used none of the input will get validated. To fix that, I would suggest creating a method to determine if the form has been submitted, maybe something like... 

There's really no reason to have an anonymous function that does nothing but call a named function. this... 

You can save a few lines in each of your switches by combining cases that are identical. You can save 10% on car insurance by switching to Geico. For example... 

Some people would disagree with me, but I personally prefer to define my vars all at once, and to keep the functions separate from the variables. Also, I would use for the functions. 

You're not using your parameter and you're only allowing a single receiver. Check out the manual and you'll notice that you can have multiple recievers and you can specify a name for each one in the following format: