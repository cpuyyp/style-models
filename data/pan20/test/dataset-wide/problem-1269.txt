Bug (in jest): People can play 1.9 seconds of angry birds, swap to a different app, and then swap back ;-) Suggestions: There is only one improvement I can suggest. 

I have tested this out on regex101, and it looks good, but I have had to add the modifier to the expression. I am not sure whether this is required on the match statement. By using the pattern above you will: 

The choices of classes and other design patterns that you have made indicate to me that the books/tutorials you have been reading are pretty old. There are a number of things in your code which are almost ten years out of date in the Java 'world'. Also, you are only showing us half of your implementation, you have not included the code. While I can't review the whole system without the code, there is a lot to comment on without that still. General It is obvious that you are using an IDE to help you write your code because you have some code-template things like: 

This sub-select is better because it can do an indexed lookup in the table in the sub-select based on the column. Apart from that, I don't see a better, or neater way to do it. 

Your question does not show how you call/use the Comparators you have defined. Despite that, there are a number of issues I see with your code, and feel I should point out.... When you have data that is sorted, the data tends to last around for a while, and sorted-data is often a very important assumption for complex processing (i.e. if the data was not sorted correctly the computations will fail). Whenever you have sorted data, and Comparable data, the data should almost always be immutable (cannot possibly change). If the data can change after the sort happens, then the sorted data is no longer sorted. So, your Point class should probably be an immutable class. At the moment, it has a number of problems with that: 

I don't believe you can reduce the space complexity, and still maintain the \$O(n)\$ time complexity. There is a trade off here you have to compromise on. Of course, you can, if you want, run on \$O(1)\$ space complexity, but your time complexity will have to be compromised. Now, your code has a bug.... it needs to add the element to the Dictionary even when it has a match for neutral.... Consider a data set like (fake elements and pH's): 

I think the intended 1-line solution using regex is to use rather than what @janos suggests . With the replace, you can back-reference the matched group, and do it in one line: 

Really? That's a . Don't you mean ? The next obvious item is that the function should take the number of digits, and the input sequence, as parameters. I would expect a function like: 

set up a default value (or null if it is a complicated thing to do). do the hard work which may be missing dependencies or may fail if the hard work completes successfully, return that result. 

In the above code, if is nil, but that's not what you expect, then you do the .... which is OK, but, if is nil, and there's a pattern you expect, then you get a Nil pointer reference in the setup. Some other things to consider: 

Within the limits of the instructions, this is a good solution, but could do with some tweaks. I would start with challenging the assumptions a little bit. Even if you don't handle the odd cases, I would still mention them. The things I am think of, when I hear "Given an absolute path for a file (Unix-style)" are: 

In general, your locks follow the pattern (lock-try-finally-unlock) which is good, but, apart from that there is not enough context to determine whether it is right or not. There are some problems, like: 

Note that only the stderr needs to be handled by the anonymous fifo. The redirect back to stderr keeps it out of the way of the rest of the stdout. Also, note the use of the flag for . 

The above code uses an optimistic approach of first checking if the connector exists, creating it if it doesn't, then double-checking it. There is no global synchronization. The downside is that occasionally you may create and discard duplicate connectors in the unlikely event that, at an exact moment in time when the connector is being referenced for the first time, that two or more threads are doing it concurrently. The cost is simply the cost of losing the race. 

That will return all non-negative values for any of the number types. It iwll work for , , , , etc. Using generics, streams, and appropriate collections is the first step in making reusable code. 

is a bad name, and it is because you copy/paste code from a based method. In IDE's it is really easy to rename variables, even if the code is copy/pasted. There is no excuse ... ;-) Efficiency Apart from the above, I can't see any significant inefficiencies that need to be rectified. This code is run very few times, and is a low priority for efficiency. 

Your assumption that the entire dataset is read in to memory is not necessarily accurate. The JDBC clients I have worked with (DB2, MS-SQLServer, Sybase, Oracle, etc.) each default to, or have an option to limit the size of the client-side buffer. You only have a small amount of data on the actual client, and the ResultSet process fetches more data when you iterate through it. There is no need to add another level of buffering. Are you sure the data is all being returned? Have you inspected the configuration options for your JDBC Client? 

I believe there is a flaw in your logic that is insurmountable...... SoftReferences, once they are added to the queue, have already lost the Referent instance. I cannot think of any reason why you would want to handle an 'active' queued (the value has been GC'd) softreference in any way differently from an 'inactive' one. Once the reference has been queued it's too late to do anything about the instance it was softly referencing. On the other hand, if you want to 'process' a referant, and make sure it is not GC'd during the processing, then jsut keep a reference to it: 

As for your variables, they are nice descriptive names, but, in Java, it is common to use what is called 'camelCase', where the first letter is lower-case, and the subsequent first-word-letters are Capitalized. Also, while it is often convenient to shorten long parts of variables, the abbreviation of 'user' to 'usr' is not saving you much..... So, for example, your variables : 

is an array of the group values, and it is pulled from . is a constant defined in the class. is declared as an array in the class, but has extra data. 

^^^ That, that's the source of your problem ^^^ Java is an object oriented language. Objects encapsulate their data, and the better Object designs make it impossible for other classes to directly access the internal data. Your system, you say, has a Transform class, with some fields including a . It looks something like: 

one of the guarantees is that the Swing EDT will process events in the order they are received. Your solution will not, though, it will batch all events of the same type together. This may lead to a number of visual distractions as events happen out of order between different event types, for example. this is not preventing people from using the existing model anyway, it is adding another standard. 

Algorithm First, this problem is a 2-part problem. The first is that you have to find all 5-digit numbers that do not have the same digit twice. The second is that you have to find the right multiple of that number that uses the other digits. Your solution is pretty poor.... you use all combinations of essentially all 10 digits to find the numbers, and you skip many, many combinations. Consider this: 

'a' range from 0-9 IntStream convert each int to an Integer for each Integer, flatMap that Integer the flatMap creates an IntStream which it converts to a Stream even though we are flatMapping the 'a' value, we are not using the 'a' value in the mapping. All we are really doing is creating a new 'b' value, and who cares that the stream now has the b values streaming through.... with these 'b' values on the stream, we then flatMap again.... again, we ignore what the actual 'b' value is, abut we generate a new 'c' value in a third nested stream, and then we combine the 'a' and 'b' values which are 'in scope', with the 'c' value from the stream, and we make a Product. 

If the file is larger than your memory, you will have to re-position the byte-buffer occasionally. I recommend using a emopry-mapped size of about 4MB plus the size of the search-string. That way you can search the 4MB window, and then start the next window at the next 4mb boundary. Once you get in to it, it will make sense. This system will be fast because you will never have to copy the file's data in to Java. Everything will actually happen in the native side of things. There is a lot to read to make it work. I would start with a tutorial.... 

Your use of is misguided, and it does nothing for you, in this situation. The fact that you have used here indicates that you don't understand what it does, and why you may need it. In general, with the availability of the , and traditional , there is no real reason to use at all. is a hard-to-see memory management technique that immediately rings alarm bells for me. while ratchet freak's suggested implementation will work fine, I strongly advise against using simply because it is too hard to see. In your case, you never change the , so there is no purpose to the . Sure, you change the contents inside the , but that's different. Further, your should be final, which would be better practice, and helps with concurrency too.