I'm not a big fan of mixing LINQ styles, and I find the SQL-like version often too verbose. Example: 

Your method is 20 lines for something that can be done much easier and neater when using an ORM like Entity Framework or Dapper. IMHO you should avoid writing ADO.NET code unless you have a really good reason to do it. I also have the impression that you don't always properly clean up data readers etc. 

Why aren't you using an ORM like Entity Framework instead of this ugly, needlessly generic code? I mean: , -- really? 

You correctly use to dispose of , yet you don't do the same for , , etc. Your performance issue probably stems in part from not properly disposing of these. 

As can be seen from this jsperf, is faster than . So, your code is already efficient and expressive. 

Adding quantifier also has positive effect on the number of steps taken to match characters when the characters in the character class are consecutive/adjacent to each other. Here's the demo on RegEx101, without quantifierScreenshot and with quantifierscreenshot applied on the same data. Note that in these demos, PHP is selected as the steps taken to match is not shown for JavaScript. Also, the regex is different, it also contains lowercase counterparts of those special characters as flag is not working with PHP and don't want to apply (Unicode) flag as it is not supported in JavaScript. These demos are created only to show difference when is applied on character class. The effect should be similar in JavaScript. Note that the (two underscores) are redundant as is already added in character class and with flag it'll remove all occurrences. Method Chaining As returns a string, any other string method can be called on it. Multiple calls to can be chained. 

I have implemented two genetic operators, which is really just a fancy way of mangling lists. In particular OX-1 (illustration) and displacement mutation. I found it necessary to extract out the randomness from the algorithms in order to do unit testing with some known examples. Is that a decent way to go about it? Any comments on performance, structure, clarify and so forth is appreciated. 

Given a boolean 3D matrix and a set of actions specifying bit flips at certain positions, a set of resulting matrices can be obtained, one matrix for each action, as if executing each bit flip individually. A statistic (feature representation) defined on a matrix which for each row, column and depth counts the number of active bits at the same depth within some hexagonal distance in the first two dimensions of that row and column. What's the fastest way of getting such a statistic for each of the resulting matrices (afterstates), given the previously mentioned original matrix (grid) and actions (, and )? For example, given , , the first afterstate of can be obtained by . Actions are guaranteed to be bit flips. If the feature representation for is known, the feature representation for can be derived and need not be found from scratch. In the code below, the naive approach () and an incremental approach () are given. The naive approach should be easiest to understand. This is the hot hot hot path of my system and I want to make it faster, but I'm no speed demon. Any tips and comments on anything else, small or large, is also appreciated. Below the code is some background which is not required reading but may make things more concrete. 

Except for I don't see how this isn't handled by the logic inside . Of course you need to rethink and , but that seems a more elegant solution than the 10+ lines required to add a first entry to . 

Avoid names like and , especially considering neither of them is an , they're . Why is assigned? It isn't used anywhere. as a variable name? 

Also look into async operations and parallelism, in order to execute multiple queries to TMDb at the same time. 

: In general it is recommended to use the types specific to the language, so instead of , instead of , etc. 

IMHO class names rarely should be plural. But then most of what does shouldn't be there anyway, it belongs in a service. This goes back to my first point: you should restructure your project and separate the various layers. In your current code you're talking to SharePoint from what is basically the code-behind of a UI object. As it happens I'm currently working on a project where I'm extracting data from SharePoint. Here's my current structure: 

This algorithm sorts a list of Individuals, each with two fitness values, into what's called non-dominated fronts. A non-dominated front is a set of individuals where none of the individuals dominate each other. An individual is said to dominate another if is equal or lower (<=) for all fitness values and lower (<) in at least one fitness value. And so dominates both and , but neither of the last two dominate each other. The rank of an individual indicates which front it is a member of. would have rank 0; and would both have rank 1. Non-dominant sorting is a small piece in bigger puzzles such as multi-objective optimization with genetic algorithms. If you are interested in how the algorithm works you can check out Jensen 2003, but I'm completely new to Haskell so I'm sure there's a lot to pick on without understanding squat about the actual algorithm. Here it goes: RankSort.hs 

Is there a reason why your code is littered with class name prefixes like "Interfaces." or "DataAccessLayer.DataTransferObject."? Those make your code harder to read, IMHO. 

IMO it would be far better to create a custom class to hold the necessary parameter data: the parameter name, its value and its type. You then pass a list of these objects to , and loop through the list to construct the parameters you need to pass to , making sure to also include the correct . Or perhaps you can simply use instead of a custom class, it depends a bit on how you've abstracted your db logic from your business logic. 

Why do you use ) when you don't do anything with ? Why not use ? Oh wait, I see, you've called your collection -- a bad name, since this doesn't tell me it is a collection of lines. 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making. 

That way it would be easy to add additional parameters. Or perhaps you could simply store instead of etc. after all validation is complete, to comply with DRY. 

Considering there are calls to I suspect you're not using the MVVM pattern. I would really advise you to do this. That way you can also avoid things like and instead bind via XAML. 

I get the logic and how you're mimicking the logic of , but isn't it a bit much to return a and the ? Wouldn't it be easier to simply return a and test if you get a or an actual value? 

Your method is 140+ lines long. Even when you apply the above, it still is doing multiple things. Split it up into smaller methods, e.g 

As some of the features are only available in latest browsers/nodeJS version and some are experimental, see the MDN link embedded for browser support and polyfill. This, by any means is not polyfill for . This is just another version of the OP's code. is overriden with assumptions that only the provided input format is used to log in table. The horizontal lines are not perfect. They can contain less/more depending on the min and max length of key in the object. 

The function will give the timestamp from the given string. This timestamp can be used in the function for comparing with other dates. 

Remove some class from some elements Toggle some class on clicked element Hide some element Toggle some element depending on a condition 

At that point I'm not even halfway through and I have to give up. You need to seriously refactor this code. Each property you need to retrieve should have its own method, and in 99% of those cases there shouldn't be an empty block. WRT your question: consider converting countries to a , e.g. and then use . But please, first refactor your code. 

Now, WRT your approach: it depends on the volume of data. If this detail table isn't that "heavy" and the main table isn't that big, I would consider filling it up for each row by default and toggling its visibility through client-side code (JavaScript/JQuery + CSS). Not that in this case you should NOT retrieve it ID by ID, but instead in one query. If that's too much data to send to the browser in one go, then I'd consider your way. There really is no "one size fits all" solution, it all depends on the volume of data and what your users expect from your UI. 

I'm completely new to Javascript and NodeJs and functional programming in general. The code below scrapes a torrent-website containing movies, gets info about the movie from the OMDb API and lets a user choose a movie to watch by streaming the torrent. Any feedback appreciated. 

The code below is the core of a Genetic Algorithm (NSGA-II to be precise, without crowding-distance calculation), but I've taken out all the GA-specific parts and made a generic example. I think I've carried over most of the principles/'constraints' from the original algorithm, but I might have missed something. As you can see in , I need to convert a nested list (2-dimensional) to a flat list pretty often and I'm curious of if there are any better ways to do it. I've added some so that it's easier to follow the size and type (nested or flat) of the lists. Since expected size of input is m=100 individuals () for 500 generations (loops), speed is important. Memory usage is not that important (although knowing how to reduce it would be interesting), but execution time is. Any comments performance-related or otherwise are appreciated.