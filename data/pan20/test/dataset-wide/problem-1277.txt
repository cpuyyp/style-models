A good comment might be a high-level explanation of your algorithm. Edit: I did find one algorithmic thing which I would change. With this code: 

I personally like to add parens (though unnecessary) to highlight the relational expression. I find it aids readability. However, in this case, I would eliminate findMatch. The code seems obvious without it. Adding the variable just makes me wonder why the variable is there. I'm expecting to see it later. So I would do: 

you don't need to check as it MUST be <= because we have a match with a non-null string. Finally, I'd recommend looking at your comments. If the comment is just saying what is obvious in the code, remove it. Comments should help explain something that is (unavoidably) non-obvious. For example, consider these comments... are they really telling us anything non-obvious? 

You have to decide if the caller of your method needs to know if the parent was not found or if there is no difference when the parent was not found or when the parent element is simply empty. If the second holds true, then the other answer already describes the correct approach - return an empty list. However, if the caller needs to be informed that the parent element () does not exist: 

You could also benefit (depends on your actual usage) from not using for the compared values - by using a generic the compiler will complain if the types of the two are not compatible (for example, you are comparing to ): 

However, the impact of this change depends on the line length, and I could not observe a significant difference in my test. In order to find further performance bottlenecks, I profiled the program now with Xcode/Instruments (using the input file generated by ) This immediately revealed that most of the time is spent in : 

which should be faster than your code. Another possible improvement is to store the characters of the current substring in an or a instead of a . Which one is faster depends on the size of the strings, here is an example with an array: 

which allows you to create a value not only from a string, but also from a given latitude and longitude: 

You want to make the string incomplete again (so that you can continue searching) regardless if you've found the shortest substring. Maybe you've found a longer substring this time. 

Your code and algorithm seem pretty optimal for the problem. A minor nit-pick, the PrintWriter "out" is not being used. (The braces immediately following are unnecessary, but wouldn't affect performance.) There are only 2 tiny things which might help: 1) In each loop, you're allocating a new int[] array. If you didn't do this, you would need to call Arrays.fill() to zero out the array each time. I doubt there would be much difference as allocations of this type are pretty fast. 2) The bigger possibility is I/O performance on the output. When fine-tuning to meet a time constraint, I/O might make the difference. Instead of calling System.out.println, try using a StringBuilder and appending the output. Then, after the main loop, do a single output operation on the resultant string. Also, one final tip. The linked problem statement indicates that none are less than 150 or greater than 250. If you get input with 250, you will get an array bounds exception. You need an array of size 101. 

is guaranteed to return an instance of , either by re-using a cell or by instantiating a new one from the prototype. This is one of the legitimate use-cases of the forced cast operator . Or to put it differently: The cast can only fail if you did not define the prototype cell correctly. That would be a programming error and should be detected early. 

About the performance: @200_success already made an excellent suggestion how to improve the determination of the greatest odd divisor. The suggested algorithm is probably the fastest for a single integer. However, the programming challenge requires to compute for large numbers up to . Computing separately for each number and adding the values may not be fast enough for that challenge. In that case you'll have to find a different algorithm, and I'll try to describe a possible approach. First compute the result for small values , that will give 

- no need to convert to char array. - instead of reusing the memory already allocated to the existing builder, you are throwing that away and creating new one. - you are seeking to the beginning of the stream but are not setting to 0. So if the second block written there is smaller than first one, junk data will be written to the file. 

The best and most common one would be to throw an exception saying The HTML node with ID {id} does not exist.. If the exception should only be thrown in certain cases, your method could have a signature like . Now the caller can decide himself if the exception should be thrown. If not, then return an empty list (however, not null). 

I think the question you are asking is: Given a recursive algorithm, is there an inherent difference between diving deep and capturing a result at the deepest level of the recursion, vs. passing that result back up the chain to be captured at the shallowest level of recursion. Inherently, there should not be much difference. If we look specifically at your implementation though, there are big performance issues that far outweigh any difference in the method of recursion. In your first code example, this operation is essentially an O(N^2) operation. 

This is an O(n) linear search, for each N. So, (at least in this example) it's not the recursion that's a problem. It's the choice of algorithm and data structures.