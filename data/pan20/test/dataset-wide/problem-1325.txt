selecting channels (fine) reading socket content (fine) processing JSON content (not fine) building output responses (not fine) outputting socket content. 

and that will remove the need for the cast operations in the code. Methods like will become as well. This applies to both the and the Constructor variables. I much prefer initializing class variables outside the constructor, if possible. Certainly, you can do it inside the constructor, if needed, but, don't do both! 

is a special case of using regular expressions. Just because it does not return the position of the words, does not mean that regular expressions themselves are not the right solution. Consider the following: 

Your description says that you want to check whether the is less than 10 minutes old. Your code does something different, though. Your code checks whether there's less than 10 minutes between the times (the difference is <= 10 minutes .... If the searchTimestamp is 2 minutes in the future, it will pass the test, if it is 9 minutes in the future, it will pass the test, and if it is 11 minutes in the future, it will fail the test. Of interest, the math you use does a 10 minute check, but the message says "greater than 5 minutes old." Your message should say: "timestamp is older than 10 minutes, or more than 10 minutes in the future" So, changing your code to be what I think it should be, is a lot simpler than you would think. What you want is for the to have happened sometime after 10 minutes ago.... this is the way to do it: 

This splits the responsibility for managing the 'valid' threads in to two places, and it breaks the single-responsibility SOLID principle. Your model should instead have a callback mechanism, something like: 

Right, this interface is now a better representation of the work it is supposed to do. Now, here's a key feature I want you to consider.... at the moment, you may only have one 'action' you need to execute on the server, the part of translating a userid in to a JSOM response. But, I expect there is, or will be, more. Having to build a new implementation for your interface for every type of operation is a real PITA, especially when it requires building a new / instance.... so, what we do is we create a convenient abstract class, which will do all the synchronous/asynchronous work for us.... Note, it does not implement executeSynchronous(), and it is still fully generic. It uses an executor service that is passed in. One of the really huge advantages of reversing the logic (there is no Callable involved in the synchronous call) is that the work is done on the calling thread. In your implementation, you have two threads fully occupied, the calling thread waits for work to be done, and a thread in the ExecutorService is actually doing the work. By making the call the way I suggest, only one thread is occupied, and the thread that is busy is the same thread that calls 

does not add the second value . You only add the on the second time through, when and .... Your code above is equivalent to just: 

Note the creation of the WaitGroup and the killer channel that allows you to capture the no-solution condition, and the early solution killer. Also note the different mechanism for creating the closure. I am not recommending one way vs. the other, but creating the variables in the inside scope like allows you to access inside the goroutine without worrying about the scope, just like a parameter-based closure function. The recursive function is simplified with the loop, but more complicated by the killer process: 

It should return boolean to indicate whether it succeeded or not (i.e. at the end) if it declares a parameter then it should either use it, or remove it. 

or rather, you would get the 100 and the 90 from somewhere else, perhaps a constant for the purpose of this exercise. Now, how do you implement the calculateSpeed function? That is where the smarts of your program should be, and it should perhaps call other private methods, or do some basic calculations. There are some style issues I see, but the most significant is that I always recommend using decimal-style typed values when you are using a double literal in your code. You have code like: 

Your intention with this question is to improve the accuracy of the results by reducing the overhead of the code when compared to the typing. Unfortunately there is so much happening between your code and the keyboard that any attempt to increase the code performance will be outweighed by the simple operations happening on the system.... The following are things that may/will affect the accuracy of your timing: 

As for the actual criticism from your course... your Tuple class is not publically visible.... what are they talking about? It is 'package private' ... only classes in your package can see it. If you wanted to, you could nest the Tuple class in your AList class as a protected-static class, but I am not sure that is any better... well, actually, it is better. So, let me change my mind... Tuple should be a protected-static nested class in AClass. I have not inspected the logic of the Depends processing, but at face value it looks right. I think the interfaces is fine. One possible extension is to use another (a second) interface so that you can support classes that do not implement , just like there is and . 

from that point on, the inner-content of the class never needs to do an explicit cast from the data store. Synchronization Synchronizing on the instance itself is an anti-pattern, generally. In your class, you have synchronized methods: , etc. What this means is that anyone who has an instance of your class, can mess with your synchronization and create deadlocks. Someone does the following: 

Your code is not thread safe, does not use atomics the way they were designed to be used, and does not always produce the results you would expect. It appears that the intention of the code is to return an object against which a connection is locked. That process makes sense, but the way you get that lock object can be simplified a lot. For a start, get rid of all the exception handling that catches . That's just wrong. If you don't know what exception you are going to catch, then you cannot possibly know how to handle it. Additionally, since none of the code actually throws an exception, it's just noise. Secondly, you have a . Use it. You check if connectionName is not null, but it cannot be null, because a few lines up you check whether it starts with the prefix, and that line would throw a NullPointerException if it was null, so the check is (worse than) useless. You have a number of static fields that are not private, and not final. The final major bug is that very time you call the method you get a new Integer value returned.... yes. Even with the same name connection. Because your map stores an , and because you , the value stored in the will be auto-boxed in to a new Integer value.... thus, for example the following code will not work for you (always): 

by taking these alternate groups, there's some tricks we can play. For a start, we can do some bit manipulation and arithmetic on the 2-bit groups without overflowing in to the neighbours (because the neighbour is at least 2 bits away). Additionally, we can shift the second part by two bits, and use the exact same code to process the second part... it's easier to show, than to explain... but, more explanation first... With the 2-bit blocks, we can turn the in to using two's compliment. To do this, we take our 2-bit number and make it a 3-bit number (it's OK, we have the space because our neighbour is far away...). So, our bits become a 3-bit 2's compliment: 

Your description of the problem indicates that each event type can have multiple listeners, but the code only implements one listener for each event. Is this intended? The awkwardness is a "feature" of go.... Because Go is 

and your read-side becomes (note you had a bug before because if you had multiple listeners you would poll different values for each of them): 

This makes it easier to compare/validate your code. My next suggestion is to shift the data as you pull values off... This way you don't need to do 'brain-mushing' thinking when doing the manipulation. 

This saves a fair number of unnecessary print statements, and your performance will improve as a result. 

Which begs the question... why have the removeSpaces method at all? The same is true with Simpler Conversion Why use and when and will do? Simpler Math This line here (the crux of the problem), can be simplified using modulo and removing the Magic Numbers: 

Mike is correct that you are repeating the sum multiple times for each value. A simple array with the stored sum will make a huge difference. On the other hand, you are also doing a huge amount of unnecessary work in here: 

I see a few, actually, a number of problems in this code. I am afraid this will be something of a scathing review, in part because you mention this is intended to be for a tutorial.... I see a number of call them 'critical' issues. Then also a number of lesser issues. The critical ones first: Use Case Why not use an Iterator? Since an Iterator would do this job, and is the traditional 'vehicle', you should indicate why a Spliterator is the right tool for the job. Note, Iterators are relatively well understood, and there is a clear wrapper-path from Iterator to Spliterator using Spliterators.spliteratorUnknownSize() The obvious answer to "Why not use an Iterator?" is either: 

I strongly agree with this statement. Every custom class you create should override the toString method, and should find a way to textually represent the class content in a meaningful (but not necessarily exhaustive) way. For example, a 'Point' class representing a co-ordinate and where x==3 and y==4 should return something like . On the other hand, I believe that some classes are over-exhaustive with toString, like ArrayList does too much. I would prefer . Edit: The Java tutorial for also says the same thing about toString():