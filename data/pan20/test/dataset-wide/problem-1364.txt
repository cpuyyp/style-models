Unfortunately I was not able to get the code to run and produce any results even though I adjusted it to load the data file. It just returned an empty dict. Rather than try to figure out why, I took a look at the things I would change based on reading through the code and just made those changes, it seems to work after I did that, not really sure what the cause was but I did do the testing on Windows which may have had something to do with it. Here are the things I focused on: 

You have accessors (the and methods). These methods allow us to retrieve data from our private members of the class instances safely, without revealing how they are implemented. This is known as encapsulation, a very important topic on programming to understand. This is where having a properly implemented copy constructor can show its' worth, due to the fact that you can now create copies easily without exposing references/implementations of the member variables. Typically, accessors are paired with mutators, which conversely, allow us to alter the members of a class instance in a predictable and controlled way. As pointed out by cbjobar in the comments, the use of mutators changes a class instance from immutable to mutable; the data values can now be modified after instantiation. 

I took a little time and wrote the following code to produce enigma encryption. I don't normally write code in C so I would like to get feedback on the way it has been structured and any issues a more experienced C programmer might spot in the way I used structs, command line parsing, and the indexing around the strings to replicate the turning of rotors. I did not create a separate header file since the code is so short I thought it would be best to just have a single file. 

In looking at your code, it seems well written and solves the problem in a straight forward manner. The one thing I would do is to remove the else after your argument check and remove a level of indent. That just helps to keep things flat... Flat is better than nested. Now onto optimization and potentially making it more complex than it needs to be in order to make it faster. In these problems it seems like a reasonable thing to do even though....Simple is better than complex. Here are a couple things I looked at as potential issues: 

Instead you should be using a for accumulating fields. It remembers how many items are stored, so you won't need . And it remembers its capacity, so you won't need . As well, clearing it doesn't change the capacity, so you won't need . And it already grows exponentially, as needed, so you can get rid of all the tests comparing to . Much better: 

I believe it will be much faster than yours, because I was able to avoid ever using division ( and ). As a matter of fact, I don't use any multiplies either. (It's about 6x faster with g++ than the code in the question, and the actual factor generation part is marginally faster, about 10%, than lol4t0's. Returning factors in a takes 5x as long as the factor generation.) Test program: $URL$ Original application: 

When sorting by multiple keys, I need the second key to alternate between standard and reverse sorting. This is to minimize the change in the second key. For example, if I have a list of dictionaries, I want the first sort (group key) to be sorted and then the second sort (sort key) to alternate. This should produce a sort like this: 

Pre-calculate 1-9 powers and store the results in a dictionary so they don't get recalculated (Memoization). It lets me look them up very quickly without calculating each time. Separate the digits using math.log10 as to avoid the int->str->int conversion. 

This is a C++ wrapper for the National Instruments ANSI C library for interfacing with NA-DAQmx devices such as the USB-6008. I wrote it for use in real-time data processing to test algorithms developed in my dissertation research. I'm sure there's lots of room for improvement. Suggestions on style are welcome, in addition to contributions to support more features of the NI hardware (the emphasis of the current code is on near-simultaneous acquisition of a few analog voltage channels) 

Equally-sized sequential subsets of primes don't evenly divide the task. The smallest numbers lead to a lot more multiples. Test-before-set might significantly reduce cache contention. Even better, don't start at , start at . 

Once you have that you can look to see if any of the parts in "main" need to be broken out into functions. On the PEP 8 side, here is an example of some of your code with Pep 8 type formatting applied so you can see the difference in how it visually looks. 

There is quite a bit of code there. I would start with PEP8 formatting as it makes it much easier to read. The other thing that came to mind is using namedtuple() rather than using the indexing all the time, this may help with readability. As far as performance goes, the best way to confirm may be to do some profiling.... Since I went through much of the PEP8 formatting just to try and see what was going on, I have inlined it here along with the profiling setup at the bottom: 

Here is my updated code per the suggestions given in Joe Wallis' answer. I have changed the main loop in the method, eliminating the if/else statements. I have also added additional methods to aid in easily retrieving data later form a separate module that is used. 

Otherwise, I would remove the copy constructor; it really has no purpose if your class is mutable. On the topic of mutability, you have one private member and one public member? It's a bit odd that you would expose the next node, but keep the values private. I would change the to be private: and then I would create getters and setters for it. Only do this if you are required for some reason to have mutable Linked List. 

That even gets rid of the need for , because now the value-setting code is so dirt simple it can safely be repeated. I notice you already did this exact thing with , so why not with the ? is to as is to . 

That's a big IF. Throwing it into a method which is several hundred lines and already has a cyclomatic complexity in the double digits is not appropriate. 

If you understand your toolbox (standard library functions) you can make them perform well and not need to reinvent them. This is crazy: 

Any other feedback is greatly appreciated, I am new to bash scripting and trying to find the best way to get this to be as optimal as possible! 

Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

I have an AngularJS function that is used to determine which associative array variable is to have data pushed into it. I would love to be able to remove the switch case entirely if possible but haven't been able to envision a way to do that! My overall goal is to both improve performance, but more importantly reduce the overall number of lines if possible I also considered perhaps some type of variable interpolation, but that seemed like an investment with little return on my effort. The directive is called in my HTML like this: