Even though you might not know assembler, but you can see those four calls to . The first thing you need to know is that is slow compared to those other operations. Those four s happen in the innermost loop. The compiler removed the to and instead replaced it by its code (that's faster). assigns values to registers, adds values, and so on. The registers with are double precision registers, meant for variables. So we're basically calling with the right values and then add, subtract and modify our small little double values. Double trouble But wait a second. We're trying to solve a completely integral problem! Why does our generated program use those registers at all? This should raise a red flag. And indeed, if we remember 's signature, it should be clear that it's not the right tool. It takes a double base and exponent, which indicates that it's suitable for terms like \$15.12151^{3.1415926}\$. This is a total overkill for your problem. Using proper functions So let's use another version instead: 

Since you're interested in performance, you probably want to split the into two parts to skip the unneeded even integers: 

"But wait", I here you say. "If I have now the following input, I would not have enough space for my digits:" 

This interface is easy to use and hard to get wrong. I use the variants since I'm more familiar with those, but the same holds for . Note that I relaxed the to Ord a => a`. Internals Next, we have a look at itself. I'll keep its type for now. First of, instead of 

There are more elegant ways to handle this, e.g. prompt the user again if they didn't write a number, or quit if the user writes q[uit]. Either way, is now a lot larger than the original . And since we have to indent it with , there's a lot of whitespace on the left hand side, usually a sign that we should move things. So let us go ahead and move out of : 

Use & . They're SO MUCH faster. Since you call every time you instantiate your plugin, you should probably move the call into your constructor instead. Public functions should be assigned to the prototype, so that we don't create a new function every time we create a new instance. Likewise, define a private function outside of the constructor, in the parent closure. Again, we don't want to have to re-create the same function over and over again. 

Don't use , even if you think that in this particular case it's safe. Even if it were, it's still slow, and not supported everywhere JS is. There's no point in using this function if you know that the path exists. The whole point is to try to fetch something through a deep path without an error. I think you can skip the console logging bit. It'd make sense to allow the user to provide a default value to be returned if the final path segment is not found. If you're doing this, you may as well support arrays too. 

When providing an object, I don't think it makes sense to pass the index into the callbacks. Rather, pass in the current key. Also, I think reads much clearer here: 

Are you sure you really need that selector? Wouldn't do the job just the same? While we're at it, why are you listening to the click on the elements, and then find the via ? Can't you just listen to the event on the s themselves? Is there any method to that configuration? I wasn't able to deduce any algorithm from what you've provided, but I'm sure there is. You'd be better off calculating it on the fly, if possible. 

While using a closure to prevent polluting the global namespace is a good idea, you shouldn't be passing in random data like that. The way you are doing it, you are forcing the reader to scroll to the bottom of the function call before reading the function body - that's just plain confusing for no good reason. Instead, declare the variables regularly within the closure, and assign their values right then and there. That way, it's much easier to read (and maintain), while still keeping the global namespace intact. 

This removes the need to traverse the list again just to get the correct init/tail, however it's harder to read, so it's up to you. Also, I really like to have the compiler yell at me if I forgot a case in my guards. For example, GHC will happily accept 

It's easy to get rid of those bindings if we enable all warnings with . By the way, you defined but never used , nor did you use anything from . You probably intended to use it in but automatically inlined it. Apart from those nitpicks, your code seems fine. As I said, I cannot comment about the cryptographic details and whether your implementation is prone to side channel attacks or similar. Also, the quality of the random numbers depends heavily on and therefore is out of scope for this review. Personally, I would use a top-down approach instead of a bottom-up approach in the code, though. That makes it easier to know our goal: 

You write down the numbers from 2 to \$n\$. You start with the next number that you haven't looked at yet If it's crossed out, take the next one If it's not crossed out, cross all it's multiple out Go to step 2, until you've run out of numbers 

If there's nothing to encrypt, there's nothing to return. Now, what should we do if there is at least one character? Well, we check whether it is a space. If it is a space, we add a space to our result and continue on the rest: 

A "clean" version without exceptions However, that's not how I would write the program, since exceptions are meant for exceptional cases. I would write 

We went from 16.14ms to 14.77ms (0.89 of original time), or if we extrapolate this to your 110s to 98s, which is closer to Mathematica's time. 

This is especially important to screen readers or other users that look for a structure. A blind person can decide to jump over a list; it's much more harder to jump over breaks in a paragraph. So check what tags like , and so on mean. Not only do they carry some kind of representation (this should look like a paragraph, this should look like a headline), but also meaningful semantics (this is a paragraph, this is a headline). Also, the code gets easier to read. If you want to change they appearance, use CSS afterwards, e.g. 

Your code does not actually function the way you want it to. checks for the existence of that element, not whether its value is set. Your radio buttons don't have a attribute on them. They really should. You should cache your selectors. You're querying for a total of 7 times in your code, and an additional 4 times on every click. Instead of listening for every click inside , you should instead only listen for the event of the radio buttons. On page load, if there's a value in the input text field, all we have to do is check the correct radio button. The event listener will take care of the rest. 

If you want to, you could even build that original array dynamically, which will make this much easier to maintain: 

I built this very-basic lazy list (I'll add more methods as I need them). You provide it an array, a generator or any iterator. It creates a lazy list, which lets you run a pipeline of transformations in a lazy manner, meaning that they'll only be applied as you pull values out of the list. Here's the class: 

P.S. You haven't described how you're exposing the plugin's additional methods. For that you should read the jQuery plugin creation tutorial. Find the section titled Provide Public Access to Secondary Functions as Applicable. 

If you find that you have to do this a lot, you can abstract it into a custom filter, which you can then use in your selectors: 

Please remember to always cache your selectors. To get the of an element, use instead of . There's no need to use two separate steps to first get the value, then set it. Instead, pass a function to , and return the new value you want. To convert a string to a number, just prefix it with the plus sign (e.g. will return the number ). It's safer, and more concise, than . When using CSS selectors, you should always strive to use the native CSS3 selectors, since they're much faster than jQuery's own custom selectors. and are not CSS3 selectors. In your case, you should use and , since they're native CSS3 selectors. Since IDs are unique per page, there's no reason to qualify an ID selector with the tag name (as you've done with ). Just use the ID on its own. Again, better performance. 

's type is a disaster. I guess its provided by HackerRank, so that's not a surprise and not your fault. This is also the reason why you get so many type errors. Your reflects that perfectly: you want to use , not . But while we're at , let's change it. First of all, the coefficients and exponents should stay together in my opinion, so let's change 's type slightly: 

Instead of , we use to construct a default value of the given type. Now your works with other types than integral or floating point ones. Hide implementation details Your is an implementation detail of . It shouldn't be exposed to the user. Also, it can be simplified: 

Therefore, this behaves just as yours. Atbash This variant of can be used to implement . Don't believe me? Well, there's a cipher called Atbash. It doesn't need a key, and we could simply implement it like this: 

Brainfuck only supports integers from 0-255 officially, and it wraps. This should get reflected in our functions. With our new program structure, there is only one single point where you need to change something. Where? And why? Instead of , use . That way, you can still have a look at the code. Try to make a variant of that takes a to simulate user input and produces a to simulate output. Try to parse more variants of Brainfuck, for example charmander, whitespace or Ook?!. 

Make functions easy to use and hard to misuse However, this function's type is weird. We want to get values, so why do we have to supply them first? That's error prone. Our funtion should have the type instead: 

Proper You're writing C++, therefore, you should include the appropriate headers. Instead of , include , instead of include , and instead of include : 

By the way, if a variable should never change its value, declare it . Also, try to initialize your variables, with a value, whenever possible: 

Also, which one has which type, and which one is more general? Arrows are great if you want to abstract functions. But throughout your small script, you're still just working with , not any other instance of . For a small script like this, is too much. For example the pointwise definition above is actually a character shorter than the pointfree one. Sure, the pointfree one is clever, but it's also very beginner-unfriendly. About randomness introduces a dependency between your point coordinates \$x\$ and \$y\$, since both draw from the same sequence. This usually leads to points on hyperplanes (see disadvantages of LCG and spectral test). Your friends variant doesn't have this immediate problem: 

Your variable is declared without a , so that it's leaking into the global namespace. Don't do that. As it stands now, your isn't used anywhere in the code. I'll assume it's not applicable here. Instead of manually keeping of your iteration, use the % (Modulus) operator to calculate your rows. jQuery's method doesn't deal with code fragments the way you seem to think it does. actually appends a whole table, not just an opening tag (that's not even possible). Access to the DOM is not free. Every time you hit the DOM you incur some overhead. Try keeping DOM modification to a minimum. Unlike others, when dealing with a simple HTML construct such as this, I prefer to build my fragment from a concatenated string since it's much faster. 

If you don't care about IE, you can check the property directly, which is much faster and much more reliable, since also contains any arbitrary data that might have been set (possibly by a plugin): 

In the regex above, we're looking for any characters in the string that are not in the bracket group. If none are found, will return 0 (which when negated will result in ). If any of those characters are found, will be returned and negated to . 

The code above works, but the text is not associated with the radio button in any way. To remedy that, consider wrapping labels around your radio buttons: 

jQuery's method can take a callback function - it'll be called for every element in the collection - and will use the returned value to set the element's html. You can use bracket notation to access the key in your , so that you can dynamically get to the key you want with the string in the brackets: 

Just keep in mind that this will query the DOM on every single !! Are you sure you can't somehow do this differently? 

The method will traverse the DOM all the way up the chain. Rather use the method, which will stop at the first match: