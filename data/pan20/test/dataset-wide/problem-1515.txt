As @vnp notes in the comments, the fact that triangular numbers are products of coprime numbers allow for very efficient factorization - see this thread for an illustration of the idea in Java, easily carryable over to Python - which I'll illustrate in my code too. The idea here is that since the \$n\$th triangular number is the product of 2 numbers \$n\$ and \$\displaystyle\lfloor\frac{n+1}{2}\rfloor\$, which implies that if \$n\$ is even then \$\displaystyle\frac{n}{2}\$ and \$n+1\$ are 2 relatively prime integers, whereas if \$n\$ is odd then \$\displaystyle\frac{n+1}{2}\$ and \$n\$ are 2 relatively prime integers. This makes factorizing the resultant \$n\$th triangular number take less time as now a divide-and-conquer approach can be employed, making this part of the algorithm \$\mathrm{O}(\log_2n)\$ in time. As I previously posted in my comment to the question, this StackOverflow thread is a good reference for efficient factorization, especially the first answer there. The idea is that there can be no prime factors of a number greater than its square root, and factors are paired in the sense that each factor \$i\$ of a number \$\text{num}\$ has a complementary factor \$\displaystyle\frac{\text{num}}{i}\$. Thus we can use a sublinear time algorithm to factorize integers, which involves enumerating to only \$\lceil\sqrt{\text{num}}\ \ \rceil\ (\mathrm{O}(\text{num}^{\frac{1}{2}}))\$ instead of \$\text{num} - c\ (\mathrm{O}(\text{num}))\$, where \$c\$ is some constant factor. That gives us the major time savings. You adhere to the Python style guide, PEP8, quite well, so I have no stylistic comments for you, except for the fact that could be a bit more descriptive, e.g., (you're using an editor with autocomplete support, aren't you?) Side notes: 

Minor suggestion: As you do not mutate the parameter , you can consider marking it to indicate to the user that the parameter is not changed. However, as is of type , which is passed by value, not by reference, you can mutate it within your method without affecting the argument, in which case, you may choose to eliminate the variable. Overall, my suggestion is either: 

Your format specifiers totally mess up the output formatting - don't worry, I'll (mostly) fix it in the full program below. Now, you see that we are repeating similar calculations thrice for one number. What this suggests is that we pass around intermediate results ("cache" them) so the process becomes faster. For this, we can combine all my previous suggestions into a whole program as below: 

Note that @mdfst13's approach below also relies on Java 8, and although his is more efficient, I feel that my approach conveys the idea behind the process a bit better. By all means, please use his version in production code, mine might be too slow for that. Just reproducing his approach below: 

(similarly for ) Rely on type inference: In Scala, it is unnecessary to declare the types of most values, as they can be inferred by the compiler, and this does not decrease the readability of your code much unless the declaration is extremely complicated or the inferred type is unintuitive/incorrect. This makes your value declarations in look like (incorporating some of my other suggestions: 

This runs in about 0.01 seconds on my system (CPython 3.6.0 Windows x64, Windows 10 Pro 1703, Intelâ„¢ Core i7 6500U (Dual Core), 8GB RAM). I cannot believe that on your system it really took over 10 hours to run - do comment with details of your system like I did above and let me know how much better this version does! 

And why restrict yourself to arrays of ints? With generics, you could have the following modifications and make this rotation routine work with all types of arrays of objects (note that is not an object, it is a primitive type, you'll need to use , which is the object-oriented wrapper type for , instead of . Same goes for and other primitive types, you'll need to use arrays of their wrapper types, look this up). 

ing source files A very big issue - especially if you're planning on writing a library: You include a C source file to use . You shouldn't do that to avoid possible name collisions between the ing file and the d file, as all of the advantages you had from the header guards are absent when you import the source file itself instead of the header. The header represents the public interface of the code, so always include that to avoid name collision issues and not depend on implementation details, like internal functions (not that you do that now, but for the future). The problem with doing this right now would be that you have not put your function declarations in the header. Declare in the header (I guess you already know how to do this, as you've already done it for ), and you're ready to use it from your main source - just include instead of . Weird and missing s What is that doing in ? as far as I could find out, it's for the compression library , which you don't seem to be using. Also, you should in to get standards-compliant behavior and compiler portability for the macros you use in . You should in your main file too, as you're using . The header guard is in to save you from the multiple-include problem. Style and Convention 

You know, this is a financial calculation. s are liable to roundoff errors. You should be using for financial calculations and for formatting numbers. However, in the interest of performance, I'll let this one slide. I don't do this in the code I provide below either. You should really have some sort of Exception handling. You should also consider JDK 7's try-with-resources statement, which I use, to simplify resource cleanup. 

Type Coercion is not readable! Don't use implicit Boolean coercion of numbers in code which you claim to be "readable" - it isn't. Use proper comparisons in readable code, and leave the cool weak-typing hackery for the golfed version. How much does writing out the actual condition improve the readability of the code? Everything else seems to be fine - naming, indentation, and all. 

Type-alias to and import it to reduce some visual clutter. Also do the same with by aliasing it to to reduce visual clutter even more. 

Extract out into a variable. I think ES6+ gets you and - use them instead of . As far as I remember, the former gets you proper scoping and the latter allows you to declare a named constant. I think my point (1) should have a declaration. 

I did promise some Java 8-fu, so here you go! I won't bother explaining this too much, it should be self-explanatory once the concept of higher-order functions and lambdas are understood, along with method references. Reading up a bit on Java 8 would help a lot more than me trying to explain this. I'll also sacrifice a bit of good design to keep it short - it'll all be in the method. 

Suggestions You have written pretty good code already, and your describe your methods with comments just before them. You could make those comments into property JavaDoc comments, see the Oracle JavaDoc tutorial here. 

It is fair enough to close only the outermost stream - the close request will be propagated by the stream to any enclosed ones. You should make reading and writing as 2 different methods, and . You may even want to parametrize them to take into account different files (file paths) and contents to be written. Your variable names are good and descriptive, nothing to fault there. Note that Java convention states that project names should be unique and involve a package structure involving the reversed domain name associated with the publisher of the software, i.e., your package structure should be something like . This ensures uniqueness in qualified names to a great extent. Another place where your naming scheme falters is in the naming of the exception objects. If we go with the scheme as object name = lowercase initials (first letter of each camelCased word) of type name, it should be for and for - but see point 9 below. I don't recommend the use of , as it may lead to namespace pollution, especially in an I/O oriented app like yours. I would really suggest you take a look at - that very C-ish loop is not really considered good Java. will automatically keep track of the line number for you - otherwise, it's just a getLineNumber()` method, however, note that the line number returned is 0-based. You might have to add 1 to the result to make it work like yours currently does. You really should look into (JavaDoc linked above). It has utility methods for a lot of stuff - writing and reading files, file and directory management (copying, moving, deleting), etc. An exposition of the Java 8-enhanced properties of this class has already been provided by @mtj, and this answer's already pretty long, so I won't get into it here. Suffice it to say that most of what you've done is redundant and Java does indeed have a simpler and probably more efficient way of dealing with files - and subpackages therein. Please don't change the current directory for the reasons specified by @RobAu - it's very disorienting if your current working directory (CWD) gets changed if your app has been run from the terminal (using, say, , where is in the CWD of the shell). If launched separately from the IDE using a terminal or console, the application's CWD will be the same as that of the launching console. If you absolutely have to do it, though, you can try , where will be whatever directory you need to be the current working directory. If you just want to use a common relative root for all paths, you can rely on 's objects' method. They'll kind of do what you want - resolve the provided relative path string with the specified as the root. If you're handling all s the same way, then you might was well keep only the most general , (thanks @slowy!). Don't Repeat Yourself! 

What are you doing? You haven't bothered to explain your algorithm, either in the question body or in program comments. Bugs. As pointed out by @Abhisek, your code prints 3 instead of 2. When you count the number of camelCase words, you should ignore whitespace, in fact, you should treat any non-alphabetic characters as lower-case, as per my understanding of the problem (although this is an edge case). You haven't bothered to use any of Java's standard libraries. You would find the functions , and extremely useful, instead of doing error-prone and language-limited manual checking. Also, is always a better check than . Non-descriptive naming. Your method does indeed solve a HackerRank problem, but that does not describe it properly. You could name it for what it does, something like , as per some guidelines for Java method naming (Effective Java by Joshua Bloch). You only use once without the emptiness check. In fact, that is not required either, as the general code will handle that too. Just use the emptiness check to set the initial value of the word count to or , depending on whether the input is empty or non-empty. respectively. You do not need to return early to avoid the loop as the loop won't iterate in the first place. For that matter, as s are immutable, repeatedly calling on the same object does not have much overhead, so you do not need even if you are concerned about the loop. Avoid all the business, and use a for-each loop. Kind of like: 

You should handle the case of in if you're using s. All these gotchas are the reason why you should use for financial calculations. 

Note that the method is now obsolete. Also, the number is used twice in the above code, so it appears to be a magic number. As it doesn't change according to your use-case, you could refactor it into a constant, say , as @mdfst13 said. However, in my opinion, this should actually be a parameter of , as follows: 

I won't comment about your algorithm, as I understand that that's not the focus of this review - suffice it to say that there are better ways of checking winning than comparing against hard-coded winning lines, even in Scala. Also, Scala has a beautiful and extensive standard library, especially for collections - learn and use it! In no particular order: 

The operation you're looking for is known as a Cartesian product on sets. An implementation of Cartesian product for Java s is somewhat as follows (all s have the same generic type , otherwise we have to violate type safety, see below): 

Initialise a array of length equal to the number of required entries per line to all empty s. Copy in the array of the entries of the line just read into the array of empty s defined above, starting at the first index of each array, until the array of entries has been exhausted. Et voila! Entry padding for (somewhat) free! 

Thus getting the best of both worlds. The parametrization is assuming the declaration and call sites of this method are in 2 different classes, but otherwise it's perfectly fine to lose the parameter and inline the constant - however, the code remains more flexible this way. You'd notice that here we're doing reference copying (shallow copying), but that isn't a problem as s are immutable and interned (there is only one copy of 2 identical constants). Other notes: 1. Naming: is a pretty weird name for what this function does; why not just call it something like or something? Otherwise, the rest of the naming in the code looks OK. 2. Unnecessary code: The check you've got in approach becomes irrelevant using my algorithm. 3. Notes about : Firstly, could be (somewhat) better named as ? I'm not too sure, both are applicable given the context. If you can use Java 8, you can significantly reduce the complicated logic with a simple stream map and collect. It would look like this: 

Let me start by saying that a loop with a embedded is a bad idea. It works, yes, but the train of logic becomes more complicated to follow the more branches are within the loop. Now if you had, say, 10p, 20p & 50p coins, this would become more and more complicated until it reached a point where you would want to rewrite it in a more sensible way. With that out of the way, let's get on with the review. 

Rant You hadn't tried much to be functional. If you had, then not even a single , mutable data structure or loop would have turned up in your code, but all 3 did, so... Most programmers hate global state, and for good reason. if there were any s in your , it would have been a mess in the making. Thankfully, it is just a declaration of constants, so no problem there. My take on your code The final code, which is very functional and handles errors using (real error handling should use to retain error information, but AFAIK it's provided by , which I don't have), follows. I put it all into one file, as Scala allows that. 

Put all your s at the top of your source file. Use variable names that are full words - let the IDE do the repetitive typing via autocompletion. seems kind of weird as a name - why not ? In and other places, , for "traverse", should also be named as , as in the rest of the code. It is standard practice to put the declaration (interface) in a separate header file - however, it seems you're aware of this and you've avoided doing this deliberately for good reason, so I won't dwell on this further. Your indentation is non-standard: 4 spaces to a tab is considered standard by most programmers. You do not follow a consistent bracing style between functions and statement blocks - use the same for both. You sometimes leave a useless line break after the body of the - if this is intentional, be consistent. An explicit is not required at the end of a method of return type , as in . Try not to use or as variable names - it makes your code uncompilable by a C++ compiler as they are C++ keywords which occur in identifier positions in your code, although the rest of the code is undoubtedly valid C++, too. Use the Boolean data type to indicate / conditions - in a C99-compliant (or above) compiler (say, with the option passed to it), the type and the macro literals and are available from the header file .