It's more common to put comments before the code. However, in this case, the comment is redundant. Either expand it to be more descriptive or remove it. 

You should avoid using attributes on HTML tags. Use CSS instead. If you are having trouble making your style affect just what you want, add an or attribute (or both). For search engine indexing purposes, it's best to have just one tag per page. It can be helpful to give it the same text as you have in the tag. There are six levels of headings in HTML, but you are only using one. Usually you want the tag content to describe the whole page. Then you want tags to identify the sections. If you need to break things up further, you can use , , , and . 

This also helps with Leaning Toothpick Syndrome, e.g. s/\s/// -- where it can get confusing as to what is a delimiter, what is an escape character, and what is part of the pattern. Contrast with s{\s}{/}. Use non-capturing parentheses (?:) rather than using () when just grouping. Of course in this case, you only need to alternate a single character. A character class is better for that than grouped alternation. Thus is better than If matching a single character, a character class like is often more readable than an escaped character like I also followed M42's suggestions but used the more specific \z (end of string) rather than the $ (end of line). Always use a FILEHANDLE with print statements. This avoids the accidental consumption of a variable as a file handle. E.g. 

Note that is longer than , so it's clear that this is not a convenience abbreviation. What is the benefit? It almost seems like you are trying to make a base class that you can reuse for other database types. Unfortunately, I don't know that you can rely on each database offering the same abilities. For example, a key/value database is not going to offer some of the capabilities that a relational database will. If you are going to alias something, then there should be a reason. If there's a reason, you should comment on it so that the reader knows it. As a general rule, if you are clever, explain to the reader how it's clever. That way, the reader doesn't need to be clever just to read the code. I don't like the use of . It doesn't seem necessary. Either don't care about that situation, or check something more direct like the existence of . 

Note that and are constant relative to both and ; is constant relative to . Since none of those change in the loops, you can calculate all of those first rather than waiting. 

Hopefully you know that the former is a shorthand for the latter but think about the next person maintaining your code. What if this is that person's first time using Perl. People in that situation will see your code and think that is some kind of special variable name in Perl classes (once they realize that it's not defined in the class). How does such a person get from there to the latter version? The is a Perl built-in function which is defaulting to the variable. In that context, is set to the arguments to the function with the object as the first argument. The built-in takes an array as the first argument, removes the first entry, and returns that entry. Then you dereference the result with the operator and grab the value for the key with a hash lookup (since classes are generally built on hashes in Perl). Also, seems a confusing name for a function. I would find or even to be easier to read and understand. If I were the one evaluating your interview code, then I would give points for writing clean, consistent, readable code. It's often worth taking a little extra time to make the code pretty. Most of my employed time is spent maintaining existing code, not writing new code. Writing the original code correctly is important. I don't care as much about quickly. The most important part is that it should be easy for me to debug and modify. That's where most of the time goes. If you save fifteen minutes writing code but I spend fifteen hours trying to make it work, then that's not a good tradeoff. As always, other reviewers may vary. The fact that they were asking you to write substantial code with a deadline may be a sign that they have different priorities than me. 

I removed your comment, as that just restates what I can read from the code. I'd still like a comment here though. It's unclear to me why you are shifting the bits right by zero places. The only reason that I can see is that it forces PHP to treat as an integer. A comment would be helpful, but I wouldn't put it here. Instead use a helper function here. 

I would prefer to write that with an inequality. The reason being that an equality like this is fragile in the face of other changes. Note that if somehow becomes true, your code will happily keep pushing into unknown space until it crashes. By contrast, if you were using indexes to track these, you could write it with an inequality that would halt even when in an inconsistent state. Strictly speaking, these are not bugs. This is a place where a bug could be created by interactions with other code (not included in this program now). Such code could be external to the code here, or it could be new functionality that someone adds to this library. I mention them because it may be worthwhile to write your code in such a way that it is more robust in the face of future code. 

There's no real advantage to the function that you define there. It's about the same amount of code either way. You may find other examples where there is a real advantage to defining a helper function like that. The big question is if it makes your code shorter and simpler. Incidentally, I'm more used to writing that with echo. Sticking to your print notation, I might say 

Note: I did not find any functional problems with your original code. However, I think that my version is shorter and more robust. 

This takes a number and reduces it a single digit. It can handle any number that will fit in a . It adds in a different order than your version, but it will give the same result. 

This isn't random. This is a hashing function. For a given input, it always returns the same output. The normal name for something like this is a hashing function. You don't explain why you want to do this. If you ask again, try to include that context. We may suggest alternatives. 

You can avoid unnecessary nesting by returning on an error rather than putting the whole function body inside an / block. Because of the , the rest of the function is implicitly an , but you don't have to write that out now. 

This detects any error in including, not just the specific problem of not being able to read the file. A final issue is that requires are processed at parse time normally. By adding the check, you force it to wait until run time to process the require (because the code might not run). has two advantages over . First, it processes at compile time, saving execution time and avoiding processing part of the script before failing. Second, it automatically creates a fatal error if there is a failure. If you aren't using those, then why use ? Answers to your questions 

This adds a new variable that points to the end of the list. Note that you'll have to make additional changes to maintain the variable if you go this way. If you don't maintain a , then consider making the default to add to the front of the list. That's simple in a linked list whereas adding to the end is difficult when the list is singly linked. It's not necessary to use with field names unless you have a naming conflict (e.g. a function parameter). So you can just say 

We could even reduce this further, as we only need to check or , but adding costs us nothing and saves us a function call if it equals . The only reason we need it at all is that is an unsigned type, so subtracting from zero will have odd results. This also avoids the oddity of passing a perfectly valid to the function only to be told that something is "out of range". 

I got rid of the comments that just said the same thing as the code. I left the comment that explained why we were doing this uncommon thing. I changed the because you were doing the same thing in the as you would if it just fell out of the loop. Doing it this way means that we only have one statement to maintain. 

I do not understand these names. I would have expected to see something database related. Neither nor says database to me. 

That also resolves another issue where you were calling the function with a parameter even though is a member of the class. 

I also changed it to only calculate the radian version of once rather than twice. I also created another version that loops in radians rather than degrees. 

This function sets the to the last element of the array and then updates it as necessary. It iterates over the array from end to beginning. If the current element is greater than the , it updates to be the current element. Because we know that we are starting at the end, we can save most of the checks that we are at or near the end in favor of one check whether we've reached the beginning. Further, because is always maintained from the end, we only have to update when it changes. If the is greater than or equal to the current element, we can simply do nothing. This function eliminates the need to do any recursive calls. It's purely iterative. This review seems long enough, so I'll let someone else review your function. I'll just note that it would be easier to read if you reformatted the indentation so that code inside a block was consistently indented more than the code outside the block. Consistency in formatting makes code easier to read. 

This seems unlikely enough to not be checked. You already check that the file opens in the method. It shouldn't close itself arbitrarily often enough that you would need to check it in each write function. 

This seems more complicated than it needs to be. We know that , so why use in the query? Are there negative times in the table? Why not just 

You should rarely use the keyword. In this particular case it's unnecessary and may do the wrong thing. What you want to do is to return the highest star rating for a given movie title: 

The comments and code don't match. According to the comments, you should in both these cases. Either the comments are wrong or the code is. If the code is correct as is, you could write it more simply 

This creates a new table that maintains a unique index on and , so you'll never have a duplicate. Then 

As a rule, don't do work in the constructor. You could either pass the connection as a parameter to the constructor or do this in a later call. 

What happens if there is a non-numeric character in the year string? You could either accept a three digit year or reject a four digit year. E.g. -800 would be acceptable under this check but +2016 would not. What happens if someone provides a five digit year? You'd throw an exception even though that would be a valid future date. You catch anything that is a but then throw another with a less-specific message. 

The values here won't work. What these are doing is linking to anchors in the current page, but you haven't anchored anything. Also, they look more like they should be going to different pages. So you might have them look like 

Ok, you add an element to a list; then you copy the list; save the copy; finally, you remove the added element from the original list. Why not reorder things like so 

This explicitly marks when it exits the inner loop early rather than trying to recalculate it. This pattern tends to be more robust at the cost of an extra variable. However, there's a good chance that the compiler can optimize out that variable. This is also one of the times that a can be considered valid in C/C++. Other languages use labeled and statements to get the same effect. 

This isn't necessary if you don't do the excess is_open check. What you should be doing is to check if is called when the stack is empty. If you use the stack variable, this looks something like 

As a general rule, you don't want to do processing in your constructor. You don't show your function, so I don't know what should change there. It could be as simple as calling right after calling the constructor. Note: this is a very common thing to try when first encountering objected-oriented principles. It's just that doing this makes it harder to reuse the code in different ways. For example, you might have reasons to do something else before running the search. As a general rule, constructors should just allocate and initialize variables. They should not attempt to read input or process things. 

Any time that I see numbered variables, I want to replace them with a collection. Since we know that there will be no duplicate values, I'd use a . 

This works and uses minimal memory, but it is less readable than making the extra . That's why it makes such heavy use of comments. I also don't have any proof that it will always move all the necessary elements. It does in my testing, but that's not proof. 

Note: under some circumstances, it might be worth making this a separate function. It's marginal but worth considering. Note how it has no interactions with or , so we don't have to check those at the same time. 

You don't need a in the last clause. You can just let it fall through after a clause. Factory Method You have this tagged factory-method, but you aren't using a factory method. The factory method is when you have a method that can return different results depending on the exact class of the object. So you might have 

Why have both? You can get the stated meaning for with . Why keep an extra variable that does the same thing? Also, a leaf is normally a node with no children. A trie node can terminate a word and still have children. 

It's generally easier to follow if either both the and the clauses use or neither do. So change this to 

As Caridorc noted, is a bad name here. Another issue is that only has two possible values. This suggests to me that it is either true or false, so use a true/false variable: 

This reduces your repeated code. Of course, it won't work as well if the exceptions aren't just off by one in the ranges. Although if 1050 were supposed to get the 0 set, then you could use an || to move that value from the 3 set to the 0. We might be able to suggest something better if we knew what odNumber, k, h, k_inv, h_inv, and f were and why they are related. For example, if odNumber is the Orson Dines catalog number of a set and the other numbers are dimensions of the parts, you might put those in a database. Then you could read the values from the database as necessary. 

Unless you are doing something clever that I missed, you probably want to use the operator to indicate that you want this to be a list of the same type as the left side definition. You also want to declare this as almost always. You could also declare this as if you never assign a new list to it. Yes, you will still be able to it and elements to the list if you declare it final. You just won't be able to assign to the variable itself. 

These are mostly correct. You can put them in the loop that you are using to call in your current code. There needs to be one change in the first line to make it work. You can also take the out of the loop and rewrite it into a single statement if you want. 

You also may want to consider using absolute URLs, as those let you specify the protocol and domain as well as the path. 

I also changed to for readability. And of course, I started using the struct fields that we declared. 

I'd call this , as there's more than one. Alternately, you could name it and use it to mean that is . I changed this to a variable as it's the same for every object. We only need one copy, not one per object. This changes the usage slightly. We'll access as . It's generally easier to read if you add a little whitespace between elements. 

I didn't get around to figuring out whether that's faster or slower. My thought is that it should be faster, as it does fewer calculations per iteration. However, it replaces integer multiplications with floating point addition (and comparisons), so it may not be better. It's also possible that the compiler is smart enough to compile out any difference that might exist. In my tests, they seemed to run about the same.