Now we take parts of the big and move them into fuctions that do only one thing - we always strive for this because it's easier to maintain when you only have to care about one thing at a time (see SRP). 

It would probably be too easy if the old worked as intended being that simple. But an eye-openig review showed that from time to time it'll miss one second due to 14ms timer incaccuracy. This of course would have bad implications on the schedules (they wouldn't fire if their second was skipped). 

I have a use case where I need to deserialize some settings from a JSON file and override their values at runtime but when then configuration is saved, I want to keep the original value. Imagine a simple JSON like this: 

The is now calling the method of the object if the is blown. In the open state the fuse is disabled. 

Why is there no redo? What kind of edit I can cancel? This doesn't seem to be the right operation for this kind of object. 

I don't see much value in this method. Clearing an empty album does not make any harm so I would allow doing this anytime. 

This means that the looses it's execution time and you move it into the new type which should contain both values. Should you want to create other benchmarks then you can extend the with other algorithms but no longer need to modify the problems themselves. They should just solve the problem and don't do anything else. 

Tests To test it I wrote just six tests and I think this is actually enough. The first test is for the 

processes the data in order to build the string. It's quite fast but in this particular situation the minimal overhead is noticable. Generally the is the fastet way to build strings so using it is definitely the right choice. 

You can however make the lookup faster by using a . Its method is an O(1) operation unlike the array's O(n). Additionaly you should instantiate it with so that you don't have to use . 

IEnumerable With your current implemetation you could remove the method and further simplify the repository by implementing the interface for this class. DocumentFactory This class should only know how to create documents. It can have methods for creating many different types but nothing else. 

I don't like your test cases because it's too much copy/paste. Creating an array with test-cases and expected results would simplify it. 

Your method only throws s. This is always bad because the name of the exception is a very important information source for why it was thrown. If you don't want to reveal what really happened, or if you want to use a more generic exception the you should create your own type. But when you do it, don't leave the stack trace behind by not passing the previous exception as inner exception. Without you providing more context, I find you code should optimally look like this: 

As far as your code is concerned I'm not happy with the method because it modifies the that belongs to the instead of creating a new result. You actually don't need it because already has a such a method that you could use like this: 

But I prefer to avoid such circular dependencies without a layer of abstraction between them because it makes testing much more difficult. On the other hand if a already knows the it's a little bit strange that the methods still requires a as a parameter. There could be a property on the interface for accessing or you could already pass to the new instance of and remove it from its methods. 

Just create a helper method for executing a query where you wrap the entire error handling and pass the query via a lambda expression: 

I think this method doesn't need to be . Generating tasks in not something you'd like to implement in each derived class. Consider changing its name to as this is what it does. Generate sounds like it would create some random tasks. 

however in this version it is the one that throws exceptions after checking a validation rule. The method can be overriden in a derived class which allows to create a new validation context for unit testing. It is now able to throw a different kind of exception that the unit testing environment will notice. It forwards the original exception as the inner one. 

It doesn't matter if you use recursion or a stack or any other method. The most important part is that it should only do one thing: return a collection of items. What if you wanted to use a different delimiter such as or ? You'd need a new parameter for it. However, if you only have a list of names it's much easier to change it and build a different path because this is another responsibility. 

IsPrime This method should throw an exception if the number is less then 0. Consequently you would the be able to return a clean boolean value. What does the mean anyway - maybe? A number can be either a prime or not or there is an error. This would make other parts of the code much easier because you wouldn't have to cast it. Why do you need the there? This is a very strange design. You add values to it but you never use it, only the property. For this a simple counter would be more adequate. I don't understand why you need it. On the other side it should be just . We don't use type prefixes in C#. Among other variables the is super confusing and misleading. It suggests it's a list but instead it's an . firstA firstB They don't make any sense and their names don't help to understand their purpose either. 

I don't want to update the value. I just want to set a new one via the property. The object tracking it should be able to figure out what's going on which leads me to the next point: 

The old method can be splitted up into two methods. One will only calculate the cost und utilizes the new switch with filters. To get the right value you just need to check the upper bound and start with the lowest one. You don't need to specify the range. 

There is more to this which you can read on wpftutorial - How to Navigate, Group, Sort and Filter Data in WPF 

You provide additional methods for adding and removing edges... but currently the user is free to modify the list anyway becasue you expose it to him. Either remove the add/remove-edge methods or make the property so that he cannot change it.