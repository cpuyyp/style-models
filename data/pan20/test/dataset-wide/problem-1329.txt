Generally I would expect a command line parser to set variables that are used by the program to configure the way it works. If the command line parser is used by programs such as , and other programs that are primarily run from the command line I would expect them to report errors to . Graphic tools might report errors to the console, they . The use of should be avoided in most cases, it will prevent a program from cleaning up after itself. When an error occurs it might be better to use setjmp() in main() and longjmp() where the error occurs. More General Declarations The code 

First, a very interesting question. This review covers the C code, and may not answer the performance question, but with the suggestions it might be easier to find what is not scaling well. When one copies existing code and modifies it, it might be better to improve the style of the code. Style issues: 

Magic Numbers There are at least three numeric constants used in the main that should Symbolic Constants, this would make the code more readable and understandable. It's almost obvious that 365 is the number of days in a year, but it is not obvious what 2 or 999 are. I'm guessing that 2 represents the cost of a powerball ticket, and that 999 is just some arbitrary number. To create numeric constants in C use #define to create a macro: 

Review Issue My first issues is that using your shared pointer is not safe. Once I give you the pointer. You are responsible for deleting it all situations (especially when exceptions happen). But if the call to fails. ie it throws BadAlloc then you will leak my object. So you need to watch out for that allocation and delete the pointer immediately if you throw. Missing Feature You have not implemented move semantics. This is absolutely essential. Your object is missing a swap function. Design I don't think the class buys you ay functionality or makes the code any easier to write. nullptr Prefer to use over as the non existing pointer. is a number and can easily be converted to other things when you least expect it. of and can only be assigned to pointers and is not auto converted into other things. General grumbles I think the assignment operator is overly complex. It would be much simpler to write this as using the standard copy and swap idiom. 

But are you really saving that much. Even forward declaration of functions, its nice to have the name of the parameters. It helps in understanding the context in which the function will be called. 

Validate input. Your code looks good but you have no error checking. If anything but a number is typed in then the whole program crashes with undefined behavior. 

This will become quite helpful as the problems and code become more complex and you need to include other name spaces. Some languages such as don't support namespaces, however, C++ does and it is quite a useful feature. More complex programs may use multiple name spaces and each one of these name spaces can contain a definition for functions such as or , or overrides on operators such as . You may even need to write your own or . Using allows you not to create your own name space when you write your own with the same arguments. Initialization of Empty Containers There is no need for the empty braces on this line: 

Possible Bugs The calls to are not tested. The functions and can fail when too much memory is allocated. When they fail the value returned is NULL, access to fields from a NULL pointer result in unknown errors, but it generally terminates the program, it is a good idea to always test the return value from or prior to trying to use the pointer. It is possible that the code in the function should changed in the following manner: 

First, @Kerndog73 did an execellent review and mostly I will try to address things he didn't. You mention that perhaps you should have used functions, you are correct. Generally the main program is used to control the rest of the program. The main program should call functions that parse the commandline, functions that set up for the rest of the program, functions that perform the main logic of the program and functions that clean up whatever needs to be cleaned up. Common Macros The code already includes stdlib.h. The include file contains two macros that are widely used, and . The code might be more readable of these two macros were used. It is possible that the values of EXIT_SUCCESS and EXIT_FAILURE may change from architecture to architecture but the macros are defined on every system. 

Allocate first. If it works swap with the current content. Then delete the old content. I wrote some articles on vector. These will help you do it better: 

This is a pointer held inside an object wrapper. When it goes out of scope it will automatically be destroyed, this calls the destructor, which calls delete on the contained pointer. As an example: 

But how much effort is it to prefix your vector with ? There is a reason the standard namespace has such a short name. Its to make typing it easy. Also is one of those identifiers that is very common. If you were using another package this can causes clashes. Alorithms The interface between algorithms and containers in C++ is the iterator. This allows you to have an algorithm that can be applied to any container type (not just vector) by writting your code in terms of iterators. You can then sort the whole vector by passing begin/end 

Yep. You implemented the standard brute force implementation. Personally I think that is fine. For some silly reason though a lot of interviewers expect you to swat up on string manipulation for interviews and want you to know the non brute force versions off the top of your head. In my opinion if you know a clever versions exists is enough (because in real life I would Google "efficient strstr implementation") if you happen to know the name even better (because in real life you will find it faster). 

The i5 is not properly indented. Since the code brackets all and the i5 loop should also be bracketed as shown above. Declare the Variables as Needed The control variables can be declared in the beginning of the for loop as shown for , and . The variable is properly declared outside the since it is used in statements following the . It's easier to read initiations when they are on separate lines as shown above. 

There are two coding standards that might be applicable, either C99 or C11. C11 would probably be the proper choice for new programs. Many compilers today will allow the programmer to select a standard, in the gcc online documents: 

It clearly defines what the number means, which makes the code more readable. It provides a type for the type checking that makes C++ a strongly typed language. It makes it easier to change the algorithm by allowing the values to change in one place rather than going through all the code to make the changes necessary. 

Please note that in my compiler this exposes a warning message in Player.h that playermark is uninitialized. The class naming is inconsistent, board is all lowercase Player is capitalized. Constants - No Magic Numbers You have a lot of raw numbers in your code, these are sometimes referred to as Magic Numbers, to make your code more readable as well as making code easier to modify if the same number is used in multiple places in the code you should use symbolic constants. 

Overall Not bad. Resizing. The maths is in favor of using a refactoring size of less than 1.63 as it potentially allows for memory to be reused after several allocations. 

The main problem with this code is that it is not C++. It is basically a set of functions (ie. Just C code that happens to use some C++ structures and objects in passing). There is nothing inherently C++ about this code. You should never be including this. 

This is never used. Also looks like a dreaded getter so probably don't want it anyway. Easier iteration 

Placement New Your main problem (as described by Jerry Coffin in the comments) is that you are creating objects when you should not be. If we look at your copy constructor: 

Each time you create a new one. Best to only create this once (it is relatively expensive to create). I would even inject the random device into the object rather than let the device create its own (then you can control the randomness for testing). Easier to read this 

Avoid use of for this type of case. Here the types of the variables provided contextual meaning to the reader. Here I found myself thinking lastEnd was an iterator and it took me several reads to actually work out what it was. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines well. The function could be broken up into at multiple functions, especially the contents of the block. The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. Don't Repeat Yourself In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns, replacing them with abstractions; and several copies of the same data, using data normalization to avoid redundancy. Generally when there is repeating code in a software module it indicates that a function should be written to contain that code or a loop should be written to perform the repetition. When code repeats in different functions it becomes a maintenance problem. Someone can fix the code in one location and miss it in another location. The solution to this is to write a function for the code that repeats. 

Since you are not doing anything special in either the constructor or distructor you can use the default constructor and distructor if you are using C++11 or C++14. This allows you to declare/define your constructors only in your header file, and let the C++ compiler generate the proper constructors and destructors. The less code you have to write, the less error prone it is. In C++11 or C++14 

This is such a common pattern that in C++11 they introduced the range based for expression. Basically this is a loop that works with an object that can accept and being called on it. It is basically syntactic sugar to make the above loop simpler to write: 

Protected! Not sure that is ever useful. But I see you are trying to say this class never stands alone and always has to be inherited from. Think I would prefer the to achieve that result. But Tomato/Tomato (you have to hear it with me changing accent). Sure the standard constructor. But in most situations are you not going to construct this with a string literal. Which means you are creating several string objects and copying around a lot of data. 

Note: It makes little difference for an integer but if there is an object in the queue then it might. Formatting Your code is horribly formatted. Please do a better job in the future. Formatting is a critical part of coding. This is because your code will be read fro decades aftr you have written it by other humans. 

Technically still legal. But in my 40 years I have only needed to use twice and one of those times there was a better way. The goto makes your code less readable (many papers on the subject) and it has been shown that it can nearly always be replaced by higher level constructs. So unless you can prove that the makes the code more readable than the alternative I think you will have a big issue. So you need a big comment around the goto explaining why this is the better solution. Not Creating Objects in valid state Your code just uses to allocate an object. 

I would probably call the variable state since that is what it is really being for. Alternative Implementation For The State Machine YACC, BISON and LEX generate tables (matricies) for transition from one state to another. One possible alternate implementation of the state machine is to have an array of function pointers. Another possible implementation is to use the current state as an index into an array of the next state (how YACC, BISON and LEX are implemented). White Space The parsing algorithm does not allow for white space. Handling white space would be easy to add and allows the user of the program to make the input more readable. There are a number of ways to implement check on white space. One possibility is to have matrix_fill() be only a parser and have it run a lexical analysing function that tokenizes the input. Note: This assumes that the buffer char *input has not been previously processed to remove white space. 

Since the way and are passed into the function and used don't really allow and to be modified they can be treated as local variables. 

There is a special file pointer for reporting errors call stderr that is defined in stdio.h. Anything printed to stderr (standard error) will be immediately output to the console. On some operating systems output printed to stderr appears in read and is easier to see. I would change the printf() calls to fprintf(stderr, "...");. The functions that have these printf() calls might be changed to return error values to stop processing.