My point of view (which certainly overlaps with timothy's explanations): Abstraction I really dislike abstraction, I'd treat it - as it is said in german - "step-motherly". You have an abstract type , an abstract type which extends and overwrites and , a class which extends and provides additional methods. And several other types which override and extend behaviour. And this is, to put it mildly, a bit of a mess. Beside the mess, you can't test logic in your abstract type without an actual implementation, nor can you test your implementation without abstraction, except you're very strict about decoupling abstraction and implementation. And the could also violate Liskov's substitution principle, more about this later: Coupling of Question and GUI Your Question types have a direct dependency to swing classes. If you would want to change the gui, or use another technology, maybe an app, or a web page, you have to change the business logic. The GUI is usually the top part of a multi tier architecture, and calls the layer below it, and the layer below must not know about the GUI. Liksov's substitution principle Now, this is especially important, if you implement the 'coupling' part above. The principle is the following: You have a routine A. A performs something with the 'supertype' S. You have a class X and Y, which are a sub type of S. If you have to change the routine A, when you introduce a new sub type of S, then you violate Liskov's substitution principle. In your example it's for instance the type . A type, which is programmed to work with your type , won't work with , because you need for instance to work correctly. So what you then have to do is for example to the type and cast it. There's ways to work around it in a "oo way", but I think that's very important when one is working with subtyping. Smaller things 

Flashback time, again :-) Looks quite good. The code looks like you really wanted to make code good looking - which maybe is more important than people would think. Naming 

further readings I made this section, because you want to write your own database access, and to not use ORM's like hibernate or eclipse's link. So this should interest you Maybe you'd like to check Fowler's list of eea patterns: $URL$ - especially the Data Source Architectural Patterns. And also the "dao" j2ee pattern from core j2ee patterns: $URL$ that's a very common one (which only decouples backend implementation, there's still a lot of other problems). Also, "Tom" from oracle has a lot of very, like very good blog posts about databases, not only oracle specific. Just google "ask tom " + whatever you want to know (about databases, of course). For transaction management and isolation levels, read this one: $URL$ (Keep in mind, design patterns can't usually work on their own and will not per se solve your problems. But it should give you an idea, how problems have been solved and you can apply that to your own design). Hops this helps. 

is fine. (Don't overdo method chaining, though) start() method ... You call it start, but the comment says "Model Initialisation". (TWICE, btw). Which one is correct? 

Is my use of Java Reflection an OK design? Well, no, the usage of reflection is usually an indication of bad design. Honestly, it is almost always. Actually, you have to change the question and ask, when is it okay, to use reflection. The answer is something similar like this: Use reflection, when you do not know how a class looks like during runtime. But this is your code, so, why would you increase complexity and make your code more error prone? 

Why didn't you just made a simple class with a static method, which takes a prefix and an enum value? If you chose to save the message key as 'class.name' + "." + enumValue, for instance 'pack.age.PreferedContactForm.MOBILE=Mobile', you wouldn't even use the messageKeyPrefix! And you can get rid of MessageFormat. Why not something like this: 

I had a really hard time to understand your sample code. I tried to make an easier example of the usage: 

Other than that, the code is quite straightforward, the "stuff, which has to be done" is separated into subroutines. 

If you got that, you start to add the 'fight mechanic', you maybe add in the GameSetup a new step 'choose your weapon' (so, a new type ), the player chooses it and the sets it to the object... And please note, many newcomers have that assumption, that you can only represent real things from the real world as objects, like House and Door. But you can also have things like and ... it's about splitting problems into smaller problems. Also I'd suggest to read about test driven development, or at least testing in general. It's a more advanced technique and maybe new starter shouldn't be bothered, but in my opinion, very very, like really very important - to be honest, as important as the production code. Test driven development actually helps to make your code more clear, improves the design of your application and also helps to think more or better in objects. And it tests your code. Hope that helps... 

, and instead of putting the listener and the consumer to the map, I use the consumer as key and value, wouldn't I achieve the same thing? If yes, I think you should be able to use this one: $URL$ 

... it was an awful lot of scrolling to figure out what is. Guess what it was? A of course. It's logical. 

Reverse the condition and remove the continue. And I don't know,... I usually cringe when I see . Reminds me of my assembler lessons somehow. Don't know why, I try to forget about it. 

public methods The only method you call in your tester class (which should start with a capitalized T), only calls the method. Reduce the visibility of all other methods. Depending on how the type is used, the user of the API will see too many methods, he only needs one. And beside that: It's a common principle to hide as much implementation as you can, also known as 'information hiding' Hope this helps, slowy 

The reader is not sure, what the purpose of the contains is. If I had to change something in that code, I'd ask myself: "Why can't I delete the given user, if it is present in that map?". To be honest: I would have assumed, it would be the opposite: Only delete, if a userId is present aka "can't delete unknown users". To be really sure, I actually have to read through the code and check, what happens, if the given userid is present in the map. Or look at the annotations and check, who committed that and hope, he's still working for us or check, if there's a link to the issue tracker, where the requirements are described. So, your descriptive method (or a well written test case) would have saved me a lot of time. Just keep in mind: We devs often find us reading and analyzing and debugging a lot more than writing code. I have had implemented requirements, which took maybe an hour and the "figuring out what to do" took days. We read and try to understand code a lot more, not only because of bugs, but also to check, what the impact of our changes would be or where else we might have to change the code, to either fulfil the requirements or verify, that we do not break something else. If we try to be as clear as possible in the code, we can reduce that amount and can do more of the fun part: the coding. Hope this helps... 

The Employee itself is in control, of who controls itself. Shouldn't you tell the EmployeController, which model it shall edit? 

Since the http requests will be the main bottleneck, I'm not sure if the asynchronous http calls will improve the performance. The asynchronous call will be executed in a separate Thread again, which takes ressources, but your main app will have to wait for the backend anyway, right? Again: Measure.