These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

Alright, this is the first time I've used Typeclasses so someone feel free to slap me with a tuna if I mess something up. First of all, I don't understand why the use of "FlexibleInstances" is necessary, and it scares me because these kinds of warnings are usually put in place for a reason. With that out of the way, I'll go through the code. 

This is the key: asks the question "Is this proposition false for all possible inputs"? To test this, we split into two parts: its first argument and the rest. If the first argument is , then is it possible to satisfy proposition with the remaining arguments? If not, then it's a contradiction. This is the part . is itself a function of 1 Bool argument, so it is in class , and so we're able to apply to it to see if it's a contradiction. We also need to be sure that it's not possible to satisfy if the first argument is either, which is why we this with . I'll leave the function as an exercise, and move on to the next inductive step. Inductive Instance Definition - Inception Since is of class , then so too is . I could be mistake, but I'm fairly sure that is actually just short-hand for this. So this means that a boolean function of two boolean variables is itself a proposition. How do we determine its validity? We check if both and are valid. The former means 'if and both evaluate to True'. Hopefully you can see now the recursion that's going on (I haven't done a great job explaining it; sorry)-- what we're doing is recursively defining the ity of the type so that such a function is valid if and only if it evaluates to for all possible inputs. 

If you don't care about IE, you can check the property directly, which is much faster and much more reliable, since also contains any arbitrary data that might have been set (possibly by a plugin): 

In the regex above, we're looking for any characters in the string that are not in the bracket group. If none are found, will return 0 (which when negated will result in ). If any of those characters are found, will be returned and negated to . 

Note: is the same as , just a bit faster; it doesn't create a new jQuery object at every step in the loop. 

I built this very-basic lazy list (I'll add more methods as I need them). You provide it an array, a generator or any iterator. It creates a lazy list, which lets you run a pipeline of transformations in a lazy manner, meaning that they'll only be applied as you pull values out of the list. Here's the class: 

Just keep in mind that this will query the DOM on every single !! Are you sure you can't somehow do this differently? 

In addition, Crockford suggests that you put the calling parentheses inside the wrapping parenthesis. 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

Now to be fair, I don't know what the bottleneck in this code actually is, and I'm sure your application probably doesn't call for such niggly optimisation, but I still think it's interesting. I'd wager that the third version is the fastest. 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Sane Selectors - There's no need to add all those selectors by hand. Simply use an attribute selector to select all elements that start with a given string. Selector caching - If there's one thing you can do to your code to keep it fast, it's selector caching. $.each - We're using jQuery's helper to loop through the array, since it also supports older browsers ( is not supported in IE < 9). 

Please remember to always cache your selectors. To get the of an element, use instead of . There's no need to use two separate steps to first get the value, then set it. Instead, pass a function to , and return the new value you want. To convert a string to a number, just prefix it with the plus sign (e.g. will return the number ). It's safer, and more concise, than . When using CSS selectors, you should always strive to use the native CSS3 selectors, since they're much faster than jQuery's own custom selectors. and are not CSS3 selectors. In your case, you should use and , since they're native CSS3 selectors. Since IDs are unique per page, there's no reason to qualify an ID selector with the tag name (as you've done with ). Just use the ID on its own. Again, better performance. 

Now the first line says this: is of type , as long as the constraints in what we call the context are met. Here the context is what comes before the , and what it says is that , the type, is a member of the typeclass. This means that we're saying that any type which maps a to any type of is itself an instance of . Why are we doing this? Well, let's start with the simplest case. is an instance of typeclass , because we defined this 'base case' explicitly. Okay, so then is also of typeclass prop, because we said that any type is in class . This gives us the functions which take in one boolean argument and return a boolean. Examples: , , , . (In fact, these are all such functions). How have we defined whether to determine whether one of these functions is ? Our definition says that 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

To make all this easier on yourself, don't re-invent the wheel. Look into John Resig's tiny inheritance library: Simple JavaScript Inheritance. 

Your code does not actually function the way you want it to. checks for the existence of that element, not whether its value is set. Your radio buttons don't have a attribute on them. They really should. You should cache your selectors. You're querying for a total of 7 times in your code, and an additional 4 times on every click. Instead of listening for every click inside , you should instead only listen for the event of the radio buttons. On page load, if there's a value in the input text field, all we have to do is check the correct radio button. The event listener will take care of the rest. 

The code above works, but the text is not associated with the radio button in any way. To remedy that, consider wrapping labels around your radio buttons: 

jQuery's method can take a callback function - it'll be called for every element in the collection - and will use the returned value to set the element's html. You can use bracket notation to access the key in your , so that you can dynamically get to the key you want with the string in the brackets: 

says that the function mapping our proposition type of to whether or not it's a valid formula is the function . (This function just returns whatever it's given). says that the function mapping the proposition type to whether or not it's a contradiction is the function . Just as well, because takes just one as an argument, and returns a . This is compatible with the contract we laid out earlier in the typeclass definition of . says that the way of comparing two of these propositions (once again, of type here) for logical equivalence is to simply invoke the already existing method . 

What stands out to me is that you initially perform a check against every grade range and insert into the map in the right one. By that point, you've already found which grade is right. But then you initiate another loop to start searching for the grade corresponding to . I think instead, you ought to alter your method to output a enum, and delegate the string handling to another function. I feel that it's better practice to return a Enum from the first method because of the strong typing-- you may want to use this information for other methods besides finding the grade name. In fact, s are particularly nice because you can use a on them.