I'm noticing explicit prefixes. Typically I only do this when I have to remove ambiguity between two variables with the same name in the same scope (or when it is required to compile, of course). Adding this clutters the code a little bit more. 

Threading I'm not very experienced with multithreading but unless I'm mistaking, you're putting the UI thread to sleep here: 

already tells me. Yes, you specify that it's about buttons but that's very minor. This, however, is a good comment because it is less obvious from the code: 

If you make it you can never the call because there is no to wait for. Instead, make it return (which is essentially a method, but then in an asynchronous context). 

and are aliases -- you can use either one but stick to that. Since you've already used and others like I would suggest you stick to . 

Why do you group 3 scenarios in one test? Either use a parameterized test or extract common logic and keep it separated. Nobody wants to sift through multiple test cases when one of them fails. 

You can use this (or more) attributes to store all the metadata that you want. It will be more work that seems redundant but makes some things more loosely coupled and displays the intent better. 

This is some messy code. First of all: declare and initialize on the same line unless there's a good reason not to. Secondly: is there an option for you to return something other than ? No generic variant? Thirdly: Don't do an intermediate when it is not asserting the end-goal of the test. Just let it throw an exception because that means the test did its job well: it throws on unexpected results. Lastly: Don't use . You expect it to parse so you want to force it to either parse or die. In your scenario, if would have value 0 then the test would fail when it shouldn't because you use such a brittle way of checking if the parse succeeds. 

Compare case-sensitive strings using . Imagine if that method is called 500.000 times with strings over 5000 characters long: each call would create a new string object. 

Instead of using 0-based pages and then adding 1 to the presentation, I would consider using the reverse: 1-based pages and subtracting 1 when determining the pages to display. In essence this would turn your loop from , becomes unnecessary and in your controller you use instead. 

I'm okay with you using 7 separate ints but at least spell their entire names. Nbdy lks abbrevs, yh? 

After creating a quick scenario that I believe mimics your use case, it seems to work just fine: $URL$ 

Errors should never be caught in Java, only exceptions. An error differs from an exception in the sense that an error is the kind of problem that means something went really wrong and not just something was faulty handled in your application. Take another look at the first one you catch: . This literally means your app has ran out of memory. By definition, you can't do anything anymore which includes error handling. Maybe the official documentation speaks for itself here: 

Your code is filled with this and it's really not good: it hides all assert information and turns it into a true/false result. Why are you throwing information away? Even with a basic example as this test you'll already run into trouble: if an assert fails, you won't know what one. Instead use and retain the information. 

It's just a bit easier to read. Likewise for your method: the indentation is all over the place; maybe something went wrong when copy-pasting it here? Keep your statements in this format: 

This line seems to indicate you have a property called . First of all: the naming convention for properties is that they're UpperCamelCase. Secondly: in itself doesn't tell me what it is (I know it has something to do with a license, but what exactly..) 

The prefix is typically only used in the Builder pattern, which you don't use here. would be just fine since you're not actually building instances. 

Parameter naming Your constructor takes variables and in a scientific-oriented context this is an acceptable practice so it will depend on how you view this code but standard conventions state that variables use the lowerCamelCase convention. I would also make their meaning clearer: could become and would be . Likewise your parameter is named . What does that signify? You can simply call it and use to refer to the instance variable inside the constructor body. I would also distinguish between and . Computed what exactly? Maybe and are more appropriate terms? Method naming doesn't really tell me much about what goes on in there. Something about the neighbours average, that's for sure. But what exactly does it do? Does it calculate it? Return it? Do I have to set it? Conventions state that your method names are built up like which would become . NullPointerException The NPE is something you should always prevent and guard against instead of throwing/catching it at runtime. You know the flow of your program and thus you should be able to determine where a NPE could occur. Guard yourself against this by validating parameters, instantiating fields inline when you can, avoid returning , etc. Scanners You only need one on your which you re-use to get input. Returning instead of printing Right now you're working with methods that print the information directly to the console. This will bring problems when you decide to publish your library (class) online and let people use it. What if that person now wants to write the results to a textfile instead of the console? Likewise for unit testing this will become troublesome. Therefore I suggest that you return the results from your methods instead of printing to the console inside itself; let the class decide what happens with your results. 

Notice how I've assigned initial values of int.min and int.max. You have to provide a default value and this basically allows any value to immediately replace it (unless you add int.min/max yourself). As Tunaki commented: you should use an instead of so in the case of a single value you end up with both min and max the same (and hence: 0 difference). There is no array of values to be stored now and we don't have to sort it either. I won't bother with a benchmark but it is definitely faster than what you had before (which might not have been benchmarked properly anyway). 

Adhere to the single responsibility principle. Printing output and receiving input are two distinct tasks and shouldn't be done in the same method. 

I am mostly interested in finding a way to make the logic of selecting the format a little more cleanly. Additionally (perhaps more importantly): can you find a scenario that I haven't accounted for? All verified scenarios so far can be found here. Analyzer Github 

I took the liberty to make the exercise as well to see how our approaches differ. I don't think there are many remarks in terms of performance although is a red flag in that area. All together I think my code provides a more easily readable solution which should help in terms of human-reading efficiency. In the end I pretty much abstracted the things you do under library features. 

You don't really need the boolean results so you might as well use them in the directly. Since your regex matches only numbers, you will only receive numbers and your parse will succeed either way (aka: no need for the ). 

I'm not a fan of simple types in an . Even if it would be just one field, I would suggest wrapping it in a complex type. This has the benefit that you can always add more fields for extra data without having to change the entire pipeline to suddenly fit a new type through it. 

Implicit this Contrary to the above having explicit is unneeded and takes away from the readability. You should only use it when there is ambiguity with a parameter name. This results in this: 

The extension is expensive: you're creating a new string for each removal of a character. I would suggest a different approach where you unwrap the string into an array of characters, take all the characters that you want to keep and put those in a new array, which you then use to create a new string. In code: 

Added benefit: now it's also easier to provide support for bigger playfields, you just have to manipulate the constant. Consistency I prefer over . It gives me less the feeling as if the code is all cluttered which makes me feel all happy and fluffy. You use everywhere as well, so unless you overloaded the operator (which I can't tell), I would change 

First of all: I appreciate the clarity of your code. Variables have good names which causes the code to be read very fluently. Intendation, spacing and whitelines are also very well done so that's a major plus. Ofcourse, there are always working points. Let's take a look. Comments 

Keep naming in mind: members are UpperCamelCase. Underscores are only considered best practice as fields. 

This could use some commentary behind its approach and some examples. I shouldn't have to parse this entire expression in my head just to know what you're doing. Perhaps split it up in intermediate variables? Properly name the resulting variables and that would help a lot as well. 

Num is not an an acceptable combination in Scrabble thus we don't allow it here either. Write it in full. 

If you don't want to use multiple variables, may I suggest an array? Nothing fancy, just and fill it from to . Then you can switch your to . Note however that this requires a different loop or usage of . 

Can you tell what's wrong here? Note that there are several methods that have this construct! Assignment vs Comparison This is a very common mistake: 

A new diagnostic has seen the light of day! This one will alert you when you have a call where the formatting placeholders are in the wrong order. The right order is defined as: 

The former two are rather unclear: what is the purpose of these two images? Naming a variable by its purpose will be a lot clearer than "image" and "image2". The latter two don't follow the convention style which (as you can see) meddles with syntax markup. Also in the category of meaningful names: and are seldom meaningful. Consider making them more descriptive. Magic numbers Take for example this snippet: 

and most surely: it provides me with a warning and a fix (which works!) to swap the placeholders and the arguments. 

Use meaningful names. I don't know what and actually mean. Nor , but that might be a language-issue (I'd encourage you to stick to English-only). 

You don't have to call after each insertion or each type of model. Simply call once at the end of your method. 

Now it's easy to see what you can do with that block: you move it to the helper method! And the result is this: 

is only acceptable in two situations: events and partial methods. Async void methods are bad (tricky?) because you can't actually await them: they are fire-and-forget. Always make them return and perhaps use a library like AsyncEx to create an asynchronous context to work from. 

Yay, you use tests! Darn it, you don't use tests. Confusing? Allow me to explain. While I totally approve of you using tests, there is a lot more to it than simply putting the annotation above them. A test is comprised of 3 aspects: Arrange, Act and Assert. Typically a test (whether it's unit, integration, functional, end-to-end, etc) will have these aspects in explicit or implicit form. Personally I like to explicitly separate them with comments (). Why do I mention this? Note the last aspect of AAA: Assert. This tells us that, as the last step in our test, we will verify the result we have and assert that it is what we expected. Doing this allows us to run the tests and automatically compare the result of each test with the expected outcome. In your situation you have to manually verify that each test works as expected; can you see yourself doing that when you have 300 tests instead of 3? This brings us to another point: all modern IDE's have integrated test runners. If you have tests, you can just run these using that instead of having to use a method as entrypoint for your tests. By adapting these changes you also won't need those println's anymore which takes away focus from your actual content. 

General note about naming: keep things descriptive. , , , etc are all bad names because they don't convey what they are about. Don't abbreviate (unless a few specific known ones like ) and keep things expressive. 

Working on my first "big" project using the mighty Xamarin. Likewise my first venture in XAML so I suppose most focus will be going towards these new areas. Performance- and user-experience related remarks are welcome as well though. Or you know, just any issue you can see. The solution consists of 3 actively used projects (the 4th - MoviePicker.Android - doesn't contain any platform-specific code). There's the shared Xamarin.Forms project, a ASP.NET Web Api 2 project and a PCL to share models between the API and the app. I will omit the PCL since it's just a few models with JSON annotations. Web API WebApiConfig 

You're already returning an so you might as well turn it into an iterator block. Discard the local and simply use . MSDN on 

Use a direct cast or perform a check. Right now you're just using the result directly which could mean you get a -- a would be much more helpful in identifying the issue. 

What does represent exactly? Number of pages? Number of posts per page? Current page number? Properly naming the variable would help a lot in clarity here. 

A minor remark: your test is named . The annotation already indicates that this is a test so it doesn't have to be repeated in the methodname itself. Adding to that: I like to structure my tests in the format . It is hard to tell what exactly your test does when I look at the code because the methodname indicates something about a nonexisting email, which leads me to think about an exception handled somewhere. But when I look at the code I see no assertions like that at all. In fact, I only see an email being used once in a seemingly irrelevant context. Some type of clarification is needed: a better method name. Something along the lines of Now when the test fails amongst a big group of tests, you can pinpoint more closely what scenario is going wrong exactly before you dig into it. 

Do not print to the console from your domain, leave that to whoever is calling your method. Now you're printing and returning data. 

There are no differences between your two options. There are a few remarks we can make about though: Consistency Keep everything consistent. There are a few reasons to change it up (for example: you can do inline initialization all the time and only initialize those in the constructor that take a constructor argument), but that's because these two situations have a significant difference. If there is no difference (for example: initializing a field to its default value) then you have to be consistent. Multiple constructors If you initialize your fields in your constructor and you add a second one, you might forget to chain them. 

GOOD TESTS ARE INDEPENDENT The outcome of one test should never impact another one. You bypass this by forcing them to be executed in a determined order but this is as brittle as it can possibly be. If you're going to change one thing, it should be this. When I want to know how a test works, I only look at 4 places: 

I will go with the second option because it would require less rewriting. Someone else can write the less complex first option but the second option is more flexible in terms of allowing two different patterns to use the same processing option. I will change the earlier block of code with some additions to keep everything in one place. 

I have made changes that take care of the added test cases which you specified later. Alongside that it also takes care of the culture-specific notation (dot vs comma) and floating point errors. It's more lengthy than your solution but it is also more robust code and a lot easier to digest. This takes care of the following testcases: 

"Saving" 2 characters is nothing, but it lowers readability. Parsing You parse the same textbox fields many times. Instead, parse it once and put it a variable. Now you can reference that variable every time and it will be a lot easier to work with. Formula clarity You should also consider splitting up your long formulas (insofar a portion of a formula would make sense) to help you in case something needs to be debugged. It will be easier to check intermediate values and to keep the overview over what your formula represents.