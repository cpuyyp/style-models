Use absolute paths (either directly or prefixing existing paths with a variable). A simple script would make it easy to transform the original paths into propers ones, even launched as a 'post-hook' on file drop by the fellas Create symbolic links in the computed locations referring to the expected one Build nginx binaries manually, configuring that command as you see fit 

This reply is made assuming the rather unclear question is well-understood from my side... You wish to make requests like the following: 

You will need to signal nginx to reload TLS certificates. If you won't be doing that, there is no way what you wish is doable. Part of the reason is checks are done at configuration loading time/statically (file existence, content validity, private key match, etc.) which cannot be reasonably done at access time/dynamically (when a request is processed), which would kill performance, and even the capability of serving any request in a reasonable amount of time at all! Now, if reloading becomes acceptable to you, it would be unwise to make nginx allow people to drop files where nginx loads them, as you are providing a direct way to compromise your server(s), either intentionally/maliciously, or by accident if a user loads up a bad certificate, not being able to replace it since the server won't accept it! Luckily for you, nginx has safeguard to prevent the latter and won't load an incorrect configuration. But for the sake of the first argument only, you shall use side-channels for this operation and never, ever, the same one. 

Requests are limited to fit the defined rate. If requests are incoming at a higher rate, no more than the defined number of requests per time unit will be served. You then need to decide on what to do with those other requests. 

seems to be pointing to the same IP address as No virtual server more suitable than the one being found for your request to , it is selected to serve the request, the same as if it was having the flag on its directive. 

Thus, you should only define once. If multiple occurrences are found, I guess the first encountered value (when used at run-time) will be chosen. 

Disable by changing table default policy to and deactivate any or rule which might stand in the way Test again and check that it works. If not, the problem comes from somewhere else 

Once you have tested the locations properly and you switched back to the configuration you provided, any following error is most probably coming from the backend or the way you configured nginx talks to it, but not the locations themselves. 

You set up 3 servers respectively listening for requests addressed to . When a request for an unknown domain kicks in, nginx serves it with the default domain. By default, nginx uses the first defined one, unless you explicitely specify another one with the flag on the directive of one of your servers. That is why your requests will always be served by the default (first) server. Now, what you wish is a reverse proxy. It is not what you asked nginx to do. You simply defined your backend servers to which you need to add another nginx server as frontend reverse-proxy. To do so, you will need to use the ngx_http_proxy_module along with the ngx_http_upstream_module. Specifically, you proxy requests from a with to your backend servers. Here is a simple reverse-proxy server configuration that might work for you: 

To provide a fallback on file inexistence, you could use in combination with a named location. Moreover, you will need to use the with the flag set in order to insert the header in responses with status codes other than the specified list. 

Check your configuration is statically validated with Check your configuration is dynamically validated by monitoring an error log defined at level while issuing a reload (either or ) Create a test location in each server (see below) Ensure your nginx is built with the SNI extension (normally yes if yo uuse a pre-built package) Ensure the right server is being used: if the domain name selection through SNI fails or if SNI is not available, nginx will fall back to the default server to serve content. Default server is, unless explicitely specified otherwise, the first found in the configuration file. Ensure browser cache is cleaned-up (and that any cache whatsoever in-between server and browser gets updated/is purged) 

You could then use regex locations to automate parsing the location string to grab the corresponding (existing?) file in the include directory. Pay attention to something very important though: Traditionally, the content of the -like directories are blocks, making nginx configuration granular. Ensure their content suits inclusion in a block (trying to include a in a obviously won't work). Also pay attention to the scope of directives you include there, since not all of them might be used inside . 

Requests processing The base rule to remember is: nginx serves a request with one location (you could emphase even more: and one location only). Read: $URL$ matching Read: documentation Based on your configuration, nginx will first match on the prefix location, then on the regex location and will eventually serves the request with the latter. With the configuration you provided, the script should not be downloaded as a raw file any more but should rather by sent over to PHP. However, that does not mean your configuration is right: the request is not served by your location, which is useless at the moment. 

1 request = 1 location You will need to duplicate your regex location so one is found per prefix location you have. That is the most efficient way of doing it. Do not be frightened of copy-pasting! those few extra bytes in configuration will make nginx configuration more readable, scalable and running more efficiently. 

What you could do is following the example provided in the docs for and provide a location corresponding to the authentication path. You could then use to insert HTTP headers such as . 

On a setup using with , I noticed the following errors occurring frequently in the nginx' errors log: 

If 1 hit every 2 requests works properly and the other is 404, it highly looks to me like 1 upstream server is working properly and the other is returning 404. Remember nginx tries upstream servers in a round-robin fasion by default. Since you do not see any 5xx error, it suggests there is no server error. 404 is a client error, which means a request could not be served because nothing matched it. I would suggest to have a look at your tomcat servers. Since you can connect to 154.25.39.126 fro your machine, it seems this one looks properly. Try to dig into the one listening on the cs2 machine local interface. I do not see anything involving any nginx trouble so far.