loop What other suggested and as you mentioned already decrementing i in the for loop may be a bit confusing for the reader (well it was for me at least), having a do..while loop feels more natural here where the while condition is false until user enters correct code (or changes his mind and gives up). 

The SQL string is dangerous as it is, I am no expert of MySQL but most database allow for precompiling a statement and then just supplying the arguments in the code. That would also speed up execution. 

When you declare variables it is good to place them one per line and initialize them. If your C compiler allows it declare the variables where they are used and not at the top of the function. 

Note also that the variables should be initialized in the order they are declared. A tip is also to write Doxygen styled comments (doxygen.org), that way you can get a nicely formatted html document which is generated from your code. A see a direct error also, you have not declared a virtual destructor in Error but you inherit from it, add a virtual dtor to avoid getting base pointer delete issues. 

arguments to the function should be declared const since it is a good indication for the user of your function that you are not going to change the contents of strings 

You are a bit inconsistent with your if statements, sometimes you use braces sometimes not, sometimes the starting brace is on the same line as the if statement sometimes under the if. It makes the code harder to read. Choose one way and stick with that. I am also not sure why you pass fp to download(), since you do not open some other file in there it is enough to pass the file pointer itself Global variables; bad, especially if they are not really used by several functions e.g. is only used in . Comments; good to have. especially when I read such a line 

It would be interesting to know why you start at 22. EDIT: I see you have some of my comments already in your todo list, anyway I will keep them here as well. 

Exceptions in C++ are normally not used to steer program flow as you do in handle_replay(), I think it would be better to have a simple do {} while loop to handle "replays" When you create a project like this it is good to put it in its own namespace to avoid problems with functions overloading/collision when you don't expect it. E.g. 

always make a habit of initializing all variables when you declare them, it is good practice. when you use runtime functions you should check the return value e.g. scanf returns the number of argument it has successfully parsed based on the format specifier, if it returns 0 you know something went wrong and can do something about it instead of having a potentially uninitialized variable to deal with. personally i prefer using fgets/sscanf/atoi/atof for input, fgets is simple to use and can not cause stackoverflow if user enters something unexpected. even though you have split up your functionality into functions you shouldt go one step further and split it further. It may also be useful to create an enum for the account type e.g. 

in use instead to get the real error from the OS instead of "can't open" e.g. i also agree with Emanuele that seems a bit ... vague? better with in if you run out of memory you silently return, it would probably be good to return some kind of error code instead allowing for a user of the function to take action. This applies also to exit(), doing an exit in the middle is not a good strategy, better to return with an error code. Let the caller determine what to do e.g. write an error message. in you but there you do not check the return value. 

I find it a bit dangerously written, your while condition dereferences the pointer and checks whether it points to \0. But it would be arguably better just setting the array pointer to NULL when you allocate it in . Then you could just do instead of adding some extra memory that is not really used. I would write it as a for-loop instead since you have a variable you increment for each iteration. read_num_slices The function that have written to take user input uses a scanf to read the number, what it does not do is to remove the additional \n that is in the buffer from the user. So it may happen that you can get some problems with this. Personally I find using fgets together with sscanf to be a better way to read user input. That way there is no risk of stack overflow and you still have the convenience of scanf parsing. Remove the goto from the function, there is no reason to have a goto there, a simple if statement should handle the case if 0 slices is entered - you should check for negative values as well. e.g. 

with less versatile I mean that if your class does not throw exceptions the user of the class cannot take any corrective action if something goes wrong or give out custom error messages in his own language. 

memory ownership is not easy to follow in your code avoid using raw pointers. By using smart pointers ownership is always clear and you dont need to bother about where to delete. 

The function will for any string 't' return 0 since strlen(s) will always be 0 (as others already have pointed out). You move the pointer 's' to end of string. You may want to do the check before the while loop instead. 

There seems to be no error handling in your code, maybe it would be useful to printout a syntax error and in which location it occurred. Prefer to put implementation details at the end of the class declaration like private/protected parts. In a perfect world when a user wants to use your class he should not need to know the implementation. In general I find your code nicely structured. EDIT: rephrased according to comment, hopefully making it more clear: When you declare a class put the private and protected parts below the public part because the user of the class should need to know about implementation details (design goal). 

(depending on your compiler you may need to do that in the constructor instead) especially pointers, since a delete on an uninitialized pointer is undefined behavior but a delete on a nullptr is OK (NOP). 

There seems to be no reason to use a VLA in this context, you already have specified that the array has max size 255 so why not just declare it as such. 

other than that i find it was quite clever way of calculating atoi, it took me a moment to understand it -- sometimes it is better to let the compiler optimize the code for you than try to write too clever code. 

you should also check the function arguments to see whether they are null or empty. you start out directly by assuming points to something and increment it. at the very least have asserts to see if caller is following the contract of the function, asserts only trigger in debug mode. 

For one thing you might want to be a bit more forgiving with non-digits. The original atoi just returns 0 if there are non-digits, terminating the program due to a non-digit is a bit harsh.