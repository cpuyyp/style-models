If there are special cases in the real data (e.g. some sets may be incomplete), a different approach may be required. 

and, using them as a derived table, join them back to the source to get the rows matching the maximums: 

According to the manual, the clause expects a list of column assignments, meaning that the left side of each assignment must be a column reference, not a variable reference. However, you can use variable assignment in the right hand side, where an expression goes, for instance like this: 

In my tests, the above query returned the same results for 5.5 as the original did for 5.6 for your example. Although the two queries should logically give equivalent results, they are not exactly equivalent: the rewritten query explicitly changes the logical order of joins. Perhaps that prompted MySQL to choose a different path through the data. But whatever the reason for the different output, please keep in mind that there is no guarantee the behaviour will match for every scenario. I will repeat, you need to stop relying on the behaviour that is not documented, or, actually, documented to be undefined: 

If this is a table of back-to-back ranges only, your case can be treated as a classic "gaps and islands" problem, where you just need to isolate islands of consecutive ranges and then "condense" them by taking the minimum and the maximum per island. There is an established method of solving this using two ROW_NUMBER calls: 

Note that it is now just COUNT(...), not COUNT(DISTINCT ...), because the derived table produces only distinct NumCavalier values anyway. 

How it works By adding the container type column and making it participate in the foreign key constraints, you prepare a mechanism preventing the container type from changing. Changing the type in the type would be possible only if the foreign keys were defined with the clause, which they are not supposed to be in this implementation. Even if they were deferrable, changing the type would still be impossible because of the check constraint on the other side of the —junction table relationship. Each junction table allows only one specific container type. That not only prevents existing references from changing the type but also prevents addition of wrong type references. That is, if you have a container of type 2 (animals), you can only add items to it using the table where type 2 is allowed, which is , and would be unable to add rows referencing it to, say, , which accepts only type 3 containers. Finally, your own decision to have different tables for , , and , and different junction tables for each entity type, already makes it impossible for a container to have items of more than one type. So, all these factors combined ensure, in a purely declarative way, that all your containers will be homogeneous. 

PIVOT implies grouping, which is why you can see the MAX() aggregate function applied to rather than simply using . The implicit grouping is also the reason you often need to use a derived table before applying the PIVOT operator: all columns not mentioned in the PIVOT clause actually participate in grouping, so you need to exclude those that are not supposed to be grouping criteria. For your specific example you do need a derived table, because you need to exclude . Option 2 As an alternative to the PIVOT operator, you could try the old-school conditional aggregation method: 

To my knowledge, this limitation pertains to SQL specifically in MySQL. All the other SQL products that I am aware of do not have it. There does not appear to be a solution to this problem in general: you cannot force a column reference to be recognised deeper than one level in MySQL. However, there is an easy workaround in your specific case: replace the in the innermost query with : 

Calendar month to financial month First of all, you can do without all those nicely formatted CASEs and use simple date arithmetic instead. Your financial year starts in May, which means the number of a month as a financial year month lags behind the number of that month as a calendar month by four. Similarly, the year value of a financial year changes to a new one four months later than that of the calendar year. Therefore, to convert the current calendar year and month to the corresponding financial year and month, you just need to subtract four months from the current date and extract the year and the month from the result to match against and of and . Your time-related filters, therefore, would look similar to this: 

and so in the end gets the result of evaluation of , which will simply be a new ranking. Note, however, that actually evaluates on every row but assigned to only when changes to a new value. And it is the fact increases on every row that allows us to get this kind of ranking, with gaps. For comparison, consider this CASE expression: 

If you specify 18, then you will be skipping 17 characters. The solution using and , suggested by George.Palacios will work as well but the results of these two solutions might not be the same depending on whether can have trailing spaces. The reason for the possible difference is that the function ignores trailing spaces, while does not, which means that for a string with trailing spaces the result will most likely not be what you would expect. Let me demonstrate that using a simple example with a shorter string. Suppose the maximum length is 10, the number of characters to skip is 4, and the specific string is . (The quotation marks here are just string delimiters, for you to be able to see the trailing spaces.) If you do 

The expression calculates a running total for each row. So, the total increases with each row (sorted in the ascending order of ) – thus with each row an ever increasing amount is subtracted from , drawing nearer to 0. The above query will give you each row's balance but not the status. To get the status, you will need to reference the value to compare it 0 and select a corresponding status string to return. is a calculated column and in order to be able to reference it you need to nest the above query and reference at the outer level. Nesting could be done with either a derived table or a common table expression (CTE). This query uses a CTE: 

Of course, it would probably be better to use the window functions in the WHERE clause directly, but that is restricted by the syntax: window functions are only allowed in SELECT and ORDER BY. 

Note that adjacent seasonal periods will generate "gaps" for which . Such ranges would be invalid, of course, and you would need to filter them out before further processing. The further processing will involve finding the gaps intersecting with the hotel contract period. Those that do intersect with it will actually be the intervals that you want to return, except the you may need to adjust the beginning of the first matching gap as well as the end of the last one, because those might go outside the contract period bounds. This is the matching condition, which takes into account that both the contract period and the gaps are inclusive intervals: 

is evaluated last or almost last of all the clauses. Therefore, it can't be used on the same level as to get the results you want. Either use a derived table with : 

When you need to retrieve rather many attributes from an EAV structure, you can try pivoting it with grouping & conditional aggregation as an alternative to multiple self-joins: 

This returns the rows where isn't referencing anything. In other words, this returns the topmost-level managers only. For your particular example it works like this: 

Each query returns the result as a row set. The two row sets can be combined into a single row set if you cross-join them: 

Basically, it seems you need to group by and the name of the correct month, then pivot the aggregated results on the month name column. Here's how you could go about it, provided you are using SQL Server 2005 or later version: 

You can use the final query as a derived table to join the results to the table to further connect them with the results from the table – in much the same way as you are doing now. 

Approach 2. Using system loophole This method is completely different in that it relies on a built-in peculiarity of the DATEDIFF function. As you probably know, setting DATEFIRST affects the results of such functions as and . Unlike them, does not respect the DATEFIRST setting. It always calculates the difference as if DATEFIRST were set to 7, that is always treating weeks as Sunday-based. Knowing that, you can calculate the difference in weeks between January 1 and any date of the same year, add 1 and use that as the Sunday-based week number: 

The above assumes that your view has only the three columns mentioned in your question. If there are more (e.g. time of recording/storing the property or something else), then you will probably need to replace the plain reference with a derived table where you are pulling only those three columns: 

Replace every with a (close the preceding column's value, comma as a delimiter between the columns, start quoting the next identifier). Replace every with a (close the preceding identifier, put back the , start quoting the following value). Put at the beginning of the string (start quoting the first identifier) and at the end (end of quoting of the last value). Put at the beginning. Execute the resulting query. 

It only remains to apply your formula to the obtained values, which is essentially . Translating all the above into SQL, we can get a query like this: