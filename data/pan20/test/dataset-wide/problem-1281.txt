I can increment/decrement the count of nodes, without changing the actual number of nodes in the class? In this case it's not bad; but: 

It is better to use local variables and pass them as parameters to functions. Having global variables (better know as mutable global state) makes it hard to change the program from other situations (also known as tight coupling). Also don't declare multiple variables on a single line (don't be lazy, one variable per line). Declare variables close to the point where you are going to use it. Here you are declaring temporaries like a million miles from their usage point. 

As mentioned above should be a local function variable (not a global) and you should pass the list you are adding the node onto as the first parameter so that you don't need to keep as global variables. This is not wrong. 

So lets look at your sorting. The first thing I notice is that you return a vector. This implies you are copying the vector at some point. Usually you sort in place for optimum performance. You also pass by value. Which gets you that copy. 

In this case it is probably not what you want. You are making a copy of Enemy that you are using. What you probably want is to pass a reference to the enemy. This way of you damage him you damage the real enemy not a copy. 

The call converts a string in IP format into an address. But this is not really that useful. I needed a function that converts a hostname or IP address string into an address. The constructor allowed you to specific a non blocking connection (and it was the default). In reality that will not work for a connect call (as you are establishing the connection). So I removed the option to making it nonblocking and it always passes true down to the base class. 

Note: If you change the interface this problems go away since you don't have a ** parameter in the first place. In the llist_add() If you are going to assert() that the node was created you also need to make sure that the input parameter is valid. As the llist_new() can return NULL if malloc() fails. So you should probably assert on add if self is NULL (You should really chec kon all interfaces to make sure self is not NULL). 

If T is large or complex then this is probably not a good idea. Pass a reference to the object. If the subject wants a copy they can explicitly make a decision to copy the object when they receive it (they have enough context to make an intelligent choice). So pass by reference instead. 

Also since you currently don't allow write access through your iterator is actually . There are several version of iterator that you can implement. 

Parser.y Note: because of the way shift reduce parser work. The precedence of operators are implied by their position in the grammar. So '+' and '-' have the same precedence but have a lower precedence than '*' and '/'. So because the '(' and ')' are at the lowest level these operators have the highest precedence. Also if precedence is the same the expression will be evaluated from left to right thus giving you the correct order you would expect from normal mathematics. 

Why are you passing arrays as pointers around. Avoid passing pointers at all costs as they do not convey ownership semantics. This makes re-using the code hard. You should probably use a namespace: 

Every byte in the is being set to -1. There are multiple bytes in an . If it works you are just getting lucky. 

So you are copying the string twice. You are manually allocating memory (with no definition of how the memory should be released). Also any unset members of the array have there original values (which may be misleading). Either the caller of the function has to make sure that the array is correctly nulled out before calling (which you do not make clear in your interface) or you should be nulling out the undefined cells. 

Code Review Prefer not to use pointers. Pointers don't have the concept of ownership semantics. So we don't know who is responsible for deleting them. Use a type that conveys ownership semantics so the person reading the code understands the semantics. 

You do it all correctly yet it is still broken. Because the calling code does not check the return value. Yes internally within a class it is absolutely fine to return status codes (because you do not expose the interface publicly). But you must also make sure you do actually test the result codes. Note: It is never (very rarely) OK to expose status codes that need checking publicly. As we can see in the C world (were this practice is the norm)it is so easy to not check the error codes and thus invalidate any following code. You should write code so it can not be used incorrectly which means forcing your users to do the correct thing (or the program exits (exceptions)). 

Please stop using and . This is like reading old C code. Modern C++ rarely uses and practically never uses (unless you are building stuff at a very low level). You should be using containers or smart pointers (always question the use of new and if you see a delete you are not using the facilities of the language). 

If you have not done anything with linux then don't even include the header files. This gives a user a false sense that this is correct which is unknowable until you test it. 

This assumes that the passed node is virgin and has not been re-used. Since somebody else created it you can not assume this. You must set the next pointer of rhs to NULL to guarantee that it is correct. You never set the prev member. So I see no point in having it. 

Inside the function all similarity to an array has disappeared. It has decayed into a pointer. By using the array like syntax you might catch people out that want to treat it as an array (which is a real maintenance issue). If this code is C then just pass as a pointer. If this code is C++ then pass as a reference to an array, or use a container type and pass by reference (I prefer the container option as you can template it). In quick pre-condition checks at the head of a function like this. There is no need for the part. 

No need to at the end of main(). It does that automatically. Normally you use to indicate there was a success BUT also to indicate that it could fail and there is another way to exit that could return a non zero value. When I see a I immediately start looking for alternative returns paths to see under what conditions the application will fail. So if your application can not fail don't return anything (this is an indication that it can't fail). The compiler will add the if one was not provided. 

If you want to go python like we can compress it a bit more. The function is designed to run over a container and collect information. Normally we do something simple with it; like to add the elements. But with the quick addition of a lambda we can get it to count each value and return the highest counted value (the return value of each iteration of the lambda is passed back as the first parameter to the lambda). 

PPS. I prefer to name my classes (types) with an initial capitol letter (everything else starts with a lowercase letter). It makes it easy to see type names. Lots of compilers don't like this: 

I prefer others would prefer (and a lot of the code uses this second C like style). But either is preferable to your current style. This seems redundant. 

Wrong. buf->str is a pointer and it was expecting a unsigned integer (they are not the same). Use %p to print a pointer value. 

Your test for reaching the end of line and end of col is in several places. Rather than test on the call. Just increment the col and handle overflow at the top of the function (in one place). This will greately simplify the whole thing. 

Adding a node is a common task with its own specific method of doing this. Use this common method to do the actual work of adding a node. This prevents duplicating of code and makes sure that adding a node is consistently done (Note your current is not very efficient but I will address that separately. 

Comments on C functions C based functions for printing are dangerous, because they are not type safe. Prefer to use the C++ type safe streams. Comments on Data values 

Again. You could probably do the next loop using a standard algorithm. But this time I am not 100% convinced that is a good idea as it is slightly longer. But you may want to look into it. 

You may have issues with in a union if it is non trivial (i.e. it has any constructors/destructors/assingment operators). From : Section 12.3 Union 

Return a non zero value to indicate failure. Catch all exceptions in main. If you throw an exception and it is not caught the program will exit. BUT it is implementation defined if this will force the stack to unwind. If you catch in this will force the stack to unwind all the way to the top (thus making sure that all the appropriate destructors are called). Note: You should re-throw the exception potentially after logging. This is because most OS detect applications that exit via an exception and provide further facilities to the user when this occurs. 

All it does is flush the output buffer. Which has already been flushed (because cin/cout are tied by magic that makes sure the user can read the question before answering). You want to read three numbers divided by a slash? 

While we are on the hash function. I note that you are passing as a value and thus inducing a copy of the string. To avoid the copy pass by const reference. 

In my opinion (so its perfectly valid to believe differently) this buys you nothing and makes the code less readable. 

Basically I want to be able to see the class declaration in one screen (so I can see what variables need to be initialized when doing a review). I can also quickly gauge and see the public interface (when using the class). Lets also put all the constructors together. So I don't have to search in multiple parts of your class for the different constructors. 

Code Review A standard naming convention (if there can be said to be one). Is that user defined types start with an initial capitol letter. Other identifiers that name objects (or functions) start with an initial lower case letter. This lets you find user defined types very quickly in the mess that is the C++ syntax. You seem to have all the variables (apart from user/password and port). Though some seem to be derived from others. A URI looks like this: 

Then you make people explicitly fill in the length and they can not accidentally pass you an array that will cause problems. Alternative design One advantage of strtok() of your function is that it does not parse the whole string. It only fetches the next token. Thus in a situation where you only need the first couple of tokens it is much more efficient. I would change your algorithm so that it behaves in a similar manor. Retrieve one string (and store it in your data structure). Next call retrieves the next string etc (this would be a lot easier to change it you had made a modular design). Questions 

Probably. But these hacker problems are usually very specific. You can probably google a perfect solution in 10 minutes. 

By making it a reference you don't need to check that where is NULL and it should always be used with a known object on the other end (). I would just have made this a reference as that implicitly conveys this requirement to the user and thus reduces the chances of misuse. 

iterator Vs const_iterator There is a lot of repeated code here. There are a couple of ways to solve this but basically you can put put the common code into a single class and then the different code is done separately. Iterator creation. 

Could be redefined as (Though then it is possible to create a Vector2 with a single value (which may not be desirable). 

So it looks like you are running around a maze that has been printed incorrectly on the screen. and thus it looks like collision detection is not working (it probably is) but the detection does not match the visual cues. Reviewing your code: These expressions