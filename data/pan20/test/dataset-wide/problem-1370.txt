Ahh, maybe it should be called or so? And why does get a name while and the other operators don't? No apparent reason, so far. 

I've never actually seen this before, but apparently it's not good enough for the real pedants either. You can, however, use the first, simpler one, and satisfy most input cases as well as the compiler, who is right to warn. See What Every Programmer Should Know About Floating Point Math, and The Floating Point Guide. Opinion: omitting braces around control statements like is dangerous and ugly. The example oft provided is to suppose that someone, be it you or not, comes along and changes the branch: 

I've been working on a full stack web application for a school project, and I wrote antiCSRF without prior experience or example code to prevent Cross-Site Request Forgery attacks, and to differentiate users who have authenticated once from arbitrary anonymous requests. The original implementation (v0.0.1) was very short, and used a module-global token register, instead of a class, and reflected how little I understood threading and the GIL in Python. The second generation of antiCSRF (which I deem v0.1 because I think it's kinda stable) is about 400 lines with docstrings and comments in. The continued use of almost definitely continues to reflect how little I understand Python's threading, but it's in there just to be safe with threaded code, for which this is explicity intended. The implementation consists of 4 helper functions (of which only 1 is essential) and 1 class, , which is where it all goes down. One of the first pieces of code I've "designed" in a while, the keeps track of currently valid and recently expired CSRF tokens, as well as providing metadata and "lower-level" functions for more customisation of the API. Specify your own key function, key length and expiry time, or don't, and use the reasonable defaults. anticsrf.py 

If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

I found about 5 things that can be improved, or maybe it's more accurate to say that I did 5 passes over the code in my efforts to improve it. Here's the changes I would recommend, in the order that I encountered them. Better Names The first change was mostly cosmetic, but it was very helpful laying the groundwork for more changes later. 

I'm aware exists, however, it requires to be a fully-fledged module, with an and stuff. If I'm writing a small script that isn't really designed to be a module (i.e, that has module-level expressions that will be run if the module is imported), then I want to it normally, not with . I'm also aware I could use and for short-circuiting over but I consider this more readable. I'm looking for responses about any part, really, but I'd be most interested to hear whether I'm unknowingly abusing in some way (quoting, perhaps?) and about the probable inefficiency of the Python code I'm using to process / sanitise the args. I'd also be happy to hear about corner cases not caught by my regex / parsing job, and how they -ed you. 

Compiler errors First of all, this code does not compile with the (IMO too lenient) command line of : 

must be declared except if its return type is omitted, in which case it's inferred to be by the compiler. Compliant programs declare . Since C99, need not explicitly return -- if you omit a return value, the compiler will insert at the end. 

This does declare and define a function in C99 and C11, which I hope you are using. See Is it better to use C void arguments “void foo(void)” or not “void foo()”? 

Now that we are using a more appropriate data structure, we have regained the simplicity we had before, and don't run out of stack space. 

Alternate Implementation Another alternative, which is arguably simpler, is to implement this as a case class with function arguments. This implementation is exactly equivalent to the refactored version above, and is arguably simpler and easier to use. 

Lazy Version It's possible to build a tree in a tail-recursive manner. It's much more difficult to do that with the references to the parent node. So I cheated by making it a lazy data structure instead. The first version was pretty basic. 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: 

Perhaps this might be regarded by some as a non-issue, but for my workflow when I just want to test something quickly, it's really handy. The functions: 

Upon correcting the errors mentioned by the compiler flags, however, the bugs appear to have disappeared! 

These are poor variable names -- you are not limited to 6 characters, like assemblers of old! Seriously, there's no excuse for these to be named this way. I can only guess that is the determined type of the input, is the determined resultant operator, and is the raw input string, but I shouldn't have to guess. Use better names, and then use comments for more complex ideas. 

This scalably-threaded server has endpoints at and . This is just an example of how to use antiCSRF and you should never ever keep reusable, long-living secrets in your users' browser history. In the real world, instead of negotiating over , use with JSON or URLEncoded data, like me. I'd especially appreciate guidance on improving the threadsafe aspect of the library, but of course all recommendations and criticisms are appreciated. Finally, I fully expect to be told this is an insecure and wrong implementation, so tell me how I can write it better from an internet security perspective. 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

There's really not much we can help you, given the low level of detail in the question. There are somethings you have in this code snippet that are generally considered a Very Bad Idea, so I'll give what help I can in that regard. Null Checks There are a bunch of these types of checks in the posted code: 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

C is very cool in that you can do this in one line, but that doesn't mean you should do this if you don't have to -- and you don't have to. Here's one possibility: 

Instead it gives the message that @vnp showed in their answer, that you should change to either or to . Having said that, the command line I usually use (and the one I put in my Makefiles) is: 

The method was written rather haphazardly as I tried to find something that seemed robust. The way the elements are finally formatted, using and may seem sloppy but it looks better than an , and can't be used on non-constant values. The recursive nature allows it to be cleverly repurposed for other collection types and on arbitrarily deeply nested arrays. Moreover, string literals in arrays preserve their so they roundtrip too, which I initially struggled with. But, can it be improved? The goal is that any collection converts into a string and s back into its original value (called roundtripping), which it does: 

How I would write it I've been writing a lot of C lately, so here's how I'd reimplement your idea. Mine writes a lot less STDOUT, but you could make it do more with the information the functions give you: 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

I was irked by the amount of typing in that, so I wrote a couple of tiny functions that live in my , so I can just do (for example): 

Well, now the program aborts 100% of the time, and it will take you a couple minutes to figure out why because of the tricky indentation. If you had used braces, this would have been avoided: 

Rather oddly and inconsistently, getting the top of an empty stack is fine and gives 0.0 but popping from an empty stack is an error, and gives 0.0. 

One thing I think the other answers missed: you're using , and . It's 2017, you're writing C++ -- never do this. 

Let this be a lesson to ye -- listen to the C compiler, for it knows many things :) API When I write in C, I try to make my functions applicable to a wide variety of uses because C is verbose, simplistic and lacks polymorphism. Having said that, I'm not sure how I feel about the interface I find when I read your code. Because the point of this program is hardly an end unto itself, surely this has applications in other projects' s. To this end, it would likely be best and most testable if functions didn't have rather unrelated side effects, like printing, which could be handled by the caller. That is, however, quite subjective and your use-case may differ entirely. Organisation / Style I know you're using Windows because you call without an , or perhaps that was a typo and you meant (from ). So even though all the functions in are laughable with their , "idiomatic" C uses , not . Moreover, in "idiomatic" modern C: 

Normally, I'd suggest trying to get rid of as much mutable state as possible. That's not really possible here, the circular reference to the parent pretty much guarantees that something is going to need to be mutable. Vanilla Version Without deviating much from your original design, there are a few cleanup suggestions that I can make. First, as suggested by @Carcigenicate , could use some naming fixes. In the version below I used , but it could have been any number of choices. I also inlined the creation of . 

If the block throws an exception, give priority to this exception. The exception thrown by is added as a suppressed exception, and the modified exception is thrown. If the block did not throw an exception, allow the exception from close to propagate upward. 

It took a bit to remember where I'd seen this before. Implementing Newton's Method for taking a Square Root was one of the exercises in Odersky's Functional Programming in Scala course on Coursera. Here is an implementation that's mostly based on the hints and suggestions in that assignment. 

This sacrifices quite a bit of functionality to pull this off, mainly because of my preference for s. To add the ability to add/remove child nodes, I went with a view instead. This way the data itself stays the same, just our view of it changes. I also added a helper to provide depth-first traversal, to abstract away doing things with the nodes in the tree.