You are particular about supporting various forms of the input word. I would suggest that you create a normalized key dictionary that maps lowercased versions of the key to a list of forms stored in the main dict. That is: 

Read all the CSV records into memory (companies, visitors). Do some basic consistency checking during this part. Make a single bulk query for existing companies. Perform a single bulk create for new companies. Refresh the companies query. Perform a bulk query for existing visitors. Perform a bulk create for new visitors. 

Once we have a "clean" list, you can write another generator function. Better still, we can make the cleanup part of the generator function, to make sure the user doesn't give us bad data: 

That should be a single database call. You'll want to compute the set of companies that are not in the result set, and then them: 

Finally, you might consider just keeping the future-player variable, which is a of player, when you accept the move: 

When you add an edge you do not add a corresponding . This makes your Graph a directed graph. Was that your intent? You have no mechanism for setting all the colors. You need to either rotate color settings (change the values of black/white/grey) or add some kind of "set-everything-to-white" method. Otherwise, you can only DFS one time. ;-) You may wish to use instead of in order to save space. For a 4x4 matrix this won't be a problem, but if you get called on to use a 64k x 64k matrix, space will be an issue. Your DFS algorithm seems wrong. I don't understand why there are two loops plus recursion. With recursion and a matrix, you only need one loop. Here's an example I found on a different post: 

Those sets will be identical for 9 cells- each cell in the same col will have the same .col value, etc., and they're just lists of references to cells, so they should be space efficient. That said, you could then iterate over the members quickly, without computing anything. You use lists for the possible values of a cell. Try using a , it will make your code shorter since it supports which doesn't require checking: 

Identify the various conditions, and then have "A place for everything, and everything in its place!" I'm not going to address the places where your code is not "Pythonic". You've said you're learning, and I believe you. Plus, I expect some other people will chime in for that. There are a lot of things you can do to clean this code up, and to make better use of language features. But I think you should address the "bigger" issues first, because they will still be true even if you aren't programming in Python. Bad comments in C# are still bad comments. Poor variable names in Scheme are still poor variable names. 

Looking at the code, is a function that does not modify but instead just returns a value. That value is stored into and then the only place it is ever used is within . Why is that not a parameter? The call to iterates over all the tr tags in the input, building a list. Stop building lists! Start generating instead! Instead of building a list, and then iterating over it again and again and again, just process it one time and yield the results. Seriously. But anyway, returns a list. Which you store. Then you call , which takes as an implicit parameter. And returns nothing. Because ... why? Why did you change coding style in the middle of your parsing? If every other method returns the result, why does this one not do so? Reading the code, it's probably because you are modifying in place (making it not raw data anymore). But still, if you're going to do functional, do functional throughout. If you're going to rely on storing to then store to throughout. The method totally changes the format of the data, and produces a summary. I think that code should be moved out of the parser and out of the class, into whatever program you write that actually works with the data. Instead, IMO, once you have the fields separated and converted into whatever type, I think you're done. I will also mention that the removal of file paths and version tags should not be done in the parsing step, or in the report creation. You might add that as a helper method on the report, or as an object configuration property. But if someone creates , it should be possible to detect that without having to rewrite your library. 

Finally, what does mean? What does mean when returned by ? Could you use or there? Or some other constant? Why do you divide your time intervals by 100? Is that the speed of sound in microseconds per centimeter? A nice constant would help... 

I looked at this, and had trouble understanding almost all of it. You've really gone out of your way to chose coding a coding style that's opaque. (This is easy to do in embedded programming for some reason - you have to make a deliberate effort to craft your code in an open, approachable fashion. Please do so.) Abstraction For example, your sensors have numbers rather than names. This is just stupid. What are the chances that a robot engineer will add sensors to her robot? 1. A robot engineer is like a teenager with a crappy asian car: they are compelled by some mysterious force to tinker with it! You must assume that your "constants" will change! 

Let the loop do the work. (Note: your game-won code does a break. You could change that to a , or you could use the statement to catch the no-break case. Also, you've got this structure: 

IMO your second solution (using a to store s) is exactly right. The first solution, with a series of statements is not only inefficient, it also encourages and facilitates writing unrelated code inside the function itself. To wit: 

That code is a mixture of "things to do at the end of the game" and "things to do in a loop." Mixing things like that is a mistake. First, because it requires you to check your conditions over and over (which is inefficient). And second because you are flipping back and forth: he's in! he's out! he's in! he's out! This is unnecessary complexity (violating the KISS principle), and it doesn't keep related things together. Instead of jumbling all these conditions together, ask yourself: what things go inside the loop, and what things go outside the loop? Obviously, winning or losing the game is "outside the loop" because in either case you won't be asking for any more guesses. Similarly, reporting if a single guess was right or wrong is inside the loop, because then you will ask for more guesses. Consider using the or the statement to short-circuit the rest of the loop body. Like this: 

Now you don't have to worry about database username/password, database path, or anything else. You can just request a cursor from the connection, and do your thing. (Note: transaction support, and two-phase-commit support, are connection level operations, rather than cursor operations. That's why I suggest passing in a connection, rather than a cursor. See PEP-249 for details. 

You may wish to add a link pointing up the tree, to simplify the split code. Add an Invariant Write yourself a method (or methods) called . Assert whatever things you find to assert - I think the wikipedia article has some pretty solid candidates. Call it when you're about to exit a public method, and whereever else you feel the need. 

You can then define getRow and getColumn as calling the common underlying function and passing a different string: 

I don't know what this is trying to do, but by default the is going to remove an item from the matrix row (assuming the matrix is a list of lists, and not some other type). Since you are iterating over , and since you don't after doing the , it seems like there should be an IndexError when you try to access the last element in that row. Edit: Also, you spell "Hogya" differently in different places, although this doesn't seem to matter. 

You start with . In that case, will be which will access the last element in the prices list. That is, . I think this probably isn't what you want. You might want to do: 

In cases where you know the endianness of the source data and target data is the same, you can sometimes just use a pointer cast: 

The important thing here is that the method which deals with the fields and properties is a method, not a method. That means that if you decide to change how blocking works the changes will be in one place: on the Likewise, when you do damage to a monster, the class should handle applying the damage. That way, if you invent a monster subclass that is immune to swords (or whatever), you can implement that inside the subclass, rather than having to code it up in the various Hero subclasses. This is not to say you cannot use the attacker's info. For example, if is immune to swords, then the method could check the attacker's weapon. (Or maybe there needs to be some kind of attack details object...) But the part where it is immune is definitely internal to the class. And the part where it updates health, and divides by 2 if blocking, and ... Bottom line: don't touch another object's private data, let the other object do it. EDIT This is in response to your (first) comment. Consider what you are trying to do in : "Ask the user how they want to play, or if they want to quit. Then either quit, or set up the game the way the user requested, and play." First, the presence/absence of a save-game file is something you can detect. So you should only ask the user if they want to load a saved game, if there actually is a save-game file available. Otherwise, the menu should just be "New Game or Quit". This is something your code can check for: 

To answer your question, there's no good way that I know of - nor even a bad way - to get an update to the pointer without either destroying it and rebuilding it (by using the as your temporary, and then scanning-to-end once you're done), or comparing it and updating it if needed. Suppose you use as some kind of previous node pointer? Well, that's the situation you are determined to avoid with the whole "Linus' double pointer" scenario. So I'll assume you don't want to do that. Then how can you safely update the tail pointer? Well, consider this: