You do not seem to be doing any mitigation against cross-site request forgery (CSRF) attacks, meaning anyone can hijack this endpoint and being sending out mail. 

I am really visiting this question based on MySQL tag, so I wanted to add a thought in this area. You should consider moving away from queries against any sort of relational databases. These can cause problems by: 

So for rough max memory utilization comparison (ignoring word counts which are trivial). You current solution: 

Your nested "ifs" make the code very hard to read. I would think about changing your approach to something like 

I am not a fan of naming your class the same as your library. This class is not a library unto itself, so perhaps there is more specific/meaningful name , , , or similar might be more appropriate and descriptive than . Also, a very small stylistic thing - it is most common in camel-casing class/function names to drop case all but leading characters in acronyms (for example rather than ). This is so that it is clear where acronyms end and "new words" begin. and classes are common examples of this in PHP. 

If you properly separate concerns, you move away from having to implement hacky uses of output buffers - something which should typically be reserved for very targeted use cases. Speaking of your output buffer, I don't see where you are flushing it. I would think it really poor practice to begin buffering in one area of code and have the buffer flushed/closed in another area of code. You are opening up your code to having to deal with the complexity/fragility of nested buffers if you have this behavior in other areas of code. 

Should be considered as potentially harmful user input to be validated accordingly before doing ANYTHING with it in your application. These sorts of validations are simply missing from your code altogether, making your could extremely vulnerable to a number of attack vectors, the most glaring of which is 

I would be very concerned about any login/authentication/authorization model written in this sort of procedural fashion. You are in essence building in significant application fragility and tightly coupled dependencies. With the high-level support that PHP has built-in for working in an object-oriented fashion over the last decade (and this continuing to be the primary focus for PHP development), there really are few reasons for someone to code in a procedural fashion for such a core piece of functionality in an application. Also with the number of good libraries or framework components that deal with this specific functionality. I would strongly consider using something like this rather than rolling your own solution. The solutions are much more likely to address all the security edge cases, to be well-tested (ideally with unit test coverage) and will likely be much more re-usable/portable across your applications. As for your other code, it is extremely tightly coupled. You really should be thinking about how to separate concerns like... 

Consider naming your property to clearly represent to someone reading this code that this is what you are working with. 

By this point, if you have a problem with the request or route, you would need a lot of code in this constructor to handle these cases, something you do a poor job of in this method. Walk through your code to see what happens if I sent a URL like . You would actually try to instantiate and call on it! If you went with a program flow like I presented above, you could: 

At its heart, this is a stack problem. You can get O(n) worst-case performance and O(n) space complexity by simply iterating the string in place, pushing opening brackets onto a stack and when encountering a closing bracket, popping the last item off stack to compare against. You need to end up with an empty stack, and you can never have a case where you try to read out of an empty stack. This in addition, of course to making sure items you are comparing out of the stack match appropriately. So, there are three failure scenarios. The solution I present might technically be optimized by hard-coding the opening and closing bracket values into conditionals and such, but I find this solution more flexible and easier to maintain from a code standpoint, as you have decoupled the bracket "configuration" from the code logic. 

I would consider using and functionality to load your config files, as this should allow to do this in a much more robust way in comparison to . You could (and probably should), verify that the config directory and all files are readable to the application and throw an exception to bail out of the process if you can't load config properly. Right now you are kind of "soft" loading the config. , for example, will not halt execution if the file could not be included. I would think execution should halt with exception thrown so that your application cannot even run if the dependencies aren't met. 

This is kind of a meaningless try-catch block. It takes a more generic exception type and turns it into a more specific exception (an odd pattern in and of itself), but doesn't really do anything meaningful here like log the failure or add additional context to the underlying exception to the caller. How is this any better than the caller just getting the underlying Exception directly? 

Hard to give full answer without understanding the ReaderFeedback table definition. I will point to some areas of concern. 

Why have un-implemented magic methods in your classes? If you don't wan't your class to be clonable or deserializable, then consider throwing exceptions in these cases. Having unimplemented magic methods will not prevent a caller from doing these actions as these methods are called after the clone/deserialization already happens on the object. You probably also need to throw exception on to prevent serialization if this is your intent. 

Where you can use the bracket notation to indicate an array of values. This allows for you to handle a list of values of arbitrary length rather than have a series of a*, b*, c*, etc. values that you need to account for throughout your code. Of course, you might need to use or similar to get the list of values rather than just the last item from the list. In the query, you might consider not using . This is a bit of lazy code writing, IMO, and it makes it harder for someone reading the code, who may not have visibility into the database schema itself, to understand what the expected field values are. This can also cause more data being returned than is necessary as in most complex applications, the database tables may have a number of timestamp/audit type of fields that are not really meant to be consumed by the application, so why send this field data to the application if it is not needed? Finally, I would point out that some of your lines of code are too long, making the code hard to read. This line for example is particularly bad: 

Why are you trying to build a SQL parser? This seems like a lot of work and a lot of potential fragility for a use case better suited for other approaches. You are dealing with a large SQL script. Execute it as such. Donâ€™t parse it apart. 

I guess I also don't understand exactly how this is intended to work with regards to earlier comments around visibility in your main tree-flattening recursion. Assuming that you are starting with the root nodes in parent-child layer trees, why would you ever need to check visibility of parents here? I would think that with your current logic, your main recursion would never even hit a a child of a parent layer that is not visible. Also note that I am getting out of your pattern of unnecessary variable assignments like this: 

So there is a consideration that needs to be made when implementing your own session handler that is not really clear in the PHP documentation. That is that the does not support the method introduced in PHP 5.5.1 & 7. For this reason, you might strongly consider extending the PHP class as opposed to implementing the interface if you want best compatibility with more current PHP releases. Again, this is actually contrary to what the PHP documentation states, but it might help give context to this decision if you look through the the feature development conversation from the core PHP developers. In a nutshell, they didn't add to the interface in order not to break backward compatibility. I would particularly point you to the comment from from Dec 14, 2012 for the most compelling discussion around interface vs. object inheritance. By having access to method call, you could do something like: 

If you truly need to keep the concept of true/value pairs for some reason not shown in this code, then perhaps a structure like: 

First of all, kudos for progress made to this point. The code looks a lot better to me (and hopefully to you too). Some general notes: 

Why is this a constant on this class? If you want to make this class more flexible, perhaps it is passed on constructor or set via setter. If this is very narrow use class, perhaps at least consider moving this to app configuration. 

Your solution is very "functional programming" in approach, with nested function declarations and such. This in of itself is not "wrong", it is just a little bit unusual in the PHP world. I would consider moving this into an object-oriented paradigm which is more common in PHP. I would think in this case perhaps only a class with static functions might be needed, so you could make calls against the validator like: 

This may seem like only a subtle difference, but developers who use this approach like it because it: 

You are doing absolutely nothing to validate the data being passed to your public methods. That means this code is extremely fragile and likely to be put into unexpected states. Take your constructors for example. They just blindly accept whatever is passed to them and sets the passed data as the DB connection to be used by the instantiated object. Since (a poor variable name by the way) is an object, you should be able to type hint the parameter like this. 

Your DB constants are probably named too generically. Consider instead of just and similar so that the "domain" of the constant is also clear. Ideally these constant are moved out of class/function code and placed in application configuration somewhere where they are not hard-coded in your codebase. You also should NEVER run an application using mysql user. Build a user for your application with appropriate privileges. Your root MySQL user should NEVER be configured to used empty password. 

Don't echo out code-level error messages to the end user. Log the errors, but give meaningful display message to user in HTML. 

I think you need a better strategy for determining what language is being requested. Relying on will likely make your app fragile to user input. For example, what if I used URI of in browser? Your current code breaks. What if I put ? Your code would be triggered even though no localization would be served, when perhaps a 404 should be returned, or even a 301 to default page. You really need to think about handling the logic around URI rewriting/redirecting at the web server and/or application bootstrap level. A common pattern in providing the type of URI's you are looking to use it to put in a rewrite at the web server level to redirect something like: 

I don't understand the need for exception being thrown by if you are basically just swallowing it anyway in . I really like the idea of logging errors on expected behavior, but I would question making whether throwing/catching here is proper pattern. I also question having an early return upon hash string validation failure. Though early exits such as this are typically a good idea, in this specific case you are potentially leaking information about the password hash (that it is invalid) to an attack who is trying to exploit the system internally. Consider logging the unexpected input like you are now doing, but then just creating a new hash for the input password anyway even though you are going to send a result. This way, you ensure that you always spend hash computation time during this verification step. 

There is really not enough context here to talk to any performance improvements. On the surface, there doesn't seem to be any way to optimize on this simple O(n) array iteration. I have no idea what is happening in any of the functions being called though. You have some room for improvement on coding style IMO. You understand the continue command but you are not using it effectively. Consider inverting your conditionals in cases like this to get code structured more like this: 

Do you really need to keep likes and dislikes in different tables? Seems to me that these would be pretty much the same thing with a different value in one single field. So maybe a table instead. Doing this would simplify your data model down to two tables and probably be more scalable in the future, if/when you want to ad more reaction types. should typically be avoided. It makes it harder for readers of the code to understand what fields they have to work with in the result set (they would have to go look at database schema to understand this). It can be more bandwidth intensive than necessary. It you only want a few fields from a table with a large number of fields, why pull all the extra data? It can potentially make the code more fragile. Can a database schema change potentially introduce bugs in code? Consider whether relational storage (i.e. MySQL) is right for this in the long term. Since you are going to be dealing with most of the records in these tables, this is a query that really could be problematic over time, getting slower and slower as your user base grows. It simply doesn't scale well. The primary question to ask is whether the likes/dislikes (reactions) have any meaning outside the context of an owning user. My guess is that they don't. And if they don't, why does this data need to be normalized into it's own table? This data model is one that actually works quite well in NoSQL storage, where the data model might look like this: 

Lines of code in this section are too long. try to kep them under 80 characters per line. Break across lines to do this. 

I have comment below about alternate an alternate approach you might want to consider for form validation. Even if you don't want to make that change, consider generalizing your validation function so that it is re-usable across different forms. You could then pass form-specific configuration to that function and have it execute validation on what type of data you are validating. This could be as simple as an array you pass into the function containing validation and sanitization filters you want to apply to the passed parameters. Perhaps something like this: 

I would think that you would want to decouple the logic you use to determine what localization to display from the logic you are using to actually render the hreflang links in HTML. With your current approach, you are going to get into a serious mess as you try to localize additional pages in your application. You would need to hard-code similar links to what you have shown across every page. You would also need to maintain separate hard-coded versions for each page to show the slight variations in these links based on which page the user is currently on. For example, if user is on page, they should not see alternate hreflang link for . You also probably need to be thinking about generating an appropriate canonical URL tag as part of this same logic. Also, over time, you may find the need to send hreflang hints in HTTP headers instead of in HTML element. By decoupling your logic for determining which localizations settings are applicable for a page (more of a routing concern), from how you convey that information to the browser/spider (a display concern), you can make you logic more re-usable across your application. If you do not already have a central class or library of classes that handle localization logic for your application, you should strongly consider this. I think what you should be striving for is a usage pattern like the following in your display context. HTML link example: 

From the looks of your code, the class is probably doing way too much. Why does this class need to load libraries, perform form validation, manage session state, manage user input, etc. Do you really need to set all these different functionalities to be properties on this class? Could dependency injection be useful here?