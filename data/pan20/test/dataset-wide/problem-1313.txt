(in , I'd stop short of : the comment doesn't apply to the NULL-checks.) : I'd assign the malloc()-result to a local variable returning false if NULL, freeing and assigning to otherwise. The else-branch could be merged with the last part of the then - I'd prefer an early-out, instead. (Naming: I'm spoiled by java.util.*.ensureCapacity) An alternate name and rendition of : 

I don't intend to (directly) address/solve your counting problem, but comment on the code presented: 

using that, I get 1, 0, 2, 0, 1, 2, 1, 0, 2, 2, 1, 1, 1, 1, 4, 0, 1, 2, 1, 1, 4… ways to "consecutively sum to" n=1..21 (throwing this at OEIS yields - nothing. Going from to 1: oeis.org/search?q=2,1,3,1,2,3,2,1,3,3,2,2,2,2,5,1,2,3,2,2,5 - in the paragraph, you may find the generating function - and a description:) number of odd divisors (including n), plus one if n is a triangular number (sum from 1..k for some k). 

() - just in case.) (The uncomely business of parenthesization being less uncommon than parenthesation with parenthesisation in the middle makes me suggest association. Reminds of the origin of this degree of freedom, and optimalGrouping is dull.) should do just that, returning the two-dimensional array of splits (to the invoking to invoke with). Refactoring 

(If this worked (don't have a C++-environment I dare to try boost in), this would "trace" partial sums to the precision explicitly set, presumably.) 

Doc comments for public methods are indispensable. I'd probably just use a foreach-loop and a DIY stack: 

You seem to be bent on thinking of nodes numbered starting from 1 - nothing wrong with that, and coding the way you think about a solution/problem is the only sane way to start: for a shot from the hip, allocate one more array element, don't use index 0 and drop all of "the ". 

needs to initialise and start from 0 to check every transition - but even that is just one necessary condition where a second comes to mind: no code may repeat. (I don't know better that to sort with a "throwing comparator".) 

Where are the doc comments? Your naming is intuitive, the formatting familiar. If you used (thanks, h.j.k.), I wouldn't have considered factoring out histogram collection. If using s that can be constructed with an expected size provided, do so. I'm convinced using one histogram is better: smaller memory footprint, no need to "filter" entries. Downside: separate s opened a promising opportunity for concurrency where my half-assed timings indicate adding a to h.j.k.'s approach to just slow things down. Using a sorted vs. a fast one and sorting the results is an interesting choice. You can combine both using a modified counting sort: 

(Some peculiarities in diction, formatting and code factoring are due to the "code keyhole" on SE, esp. my dislike for horizontal scrolling.) Pretty late in the effort it occurred to me that Python may be a better choice (3.3? 3.6? 2.7? comments welcome (regarding any language in wide-spread use among, hm, "programming juniors", actually)). Uneasy with the design, I didn't invest due diligence in testing & "tallying" (counting/computing comparisons&assignments) (yet) - I'd regret major effort invested there on any reader's part. 

Another thing to ponder would be the name itertools. Even with "the basic three", this seems to call for common base classes - I gave it a try, without proper attention to other concerns. (One thing I'm never quite comfortable with is visibility: exposes quite a lot.) I didn't succeed in integrating Partitions without a second type parameter: 

Short of implementing the Strassen algorithm, you can try to approach sweet oblivion in (even a 2×2) matrix multiplication by reversing the iteration order of columns/rows (so that elements used last in the previous iteration get used first in the current one) and picking an evaluation order where each dot product reuses one column or row from the previous dot product. The ease of getting all those indexes wrong is another reason to factor out : 

(Using , MultiMap doesn't hurt as much as it used to, even less with .) Using probably doesn't reduce max. memory usage, trimming the elements of might help a bit. You could use and to improve upon the static and . Then, you can roll your own (drop 's size, have the element in a or an Object refer to the array, …) - if s don't kill you, returning a view might. Or use 3rd party collections - Goldman Sachs s (&/ look good, s not bad. 

To evade overflow in (the product may exceed ), check for . "The other condition" may be or ( fails for {0, 1, 3}). 

What exactly shall Generating the Cartesian product of N-arrays mean? If it is providing a list of comma-separated representations of all combinations of choices given as a two-dimensional assortment of values, it is not building all such representations and adding them to a . 

What do you need a new word for? Just remove the one found, up its count, and re-insert. (If this was the second time to manipulate , this would be an opportunity to re-think 's interface: perhaps or would be more useful than .) and next remove it… Don't write naked code - use a foreach loop, or streams. Here, should do. (Proper handling of obviates the ) Source organisation: I'd make a parameter to - which doesn't lend itself to dynamic/incremental use. , invoked/invocable more than once, would seem better. Strategy: Try to make do with run-time supplied classes. You stated that you want to be able to query which words are most frequent "dynamically". Imagine keeping s of words, one for each count. For each word, remove from current (if any) and insert into set of words occurring once more frequently. With standard s - say, s, keep a "global" set of your s to determine the count. Set up a test scaffold to get your approach working. Benchmark some to get an idea of resource usage. If and only if not acceptable, set and document an improvement goal and use your "first" approach as a baseline. Stressing fast What is most frequent? queries (and using a Map instead of ): 

Naming: is weak - it has a doc comment (way to go) suggesting or . Contracts: doesn't follow 's "strong recommendation" to document the inconsistency with (I do that on both class and method). : could be different for and with . I suggest . Tactics: 

For the hell of micro-benchmarking without the likes of Java Microbenchmarking Harness or jmicrobench(no idea whether this is official) (or that most visible one for those who don't have issues with empires), I tinkered around picking up ideas from rolfl and chillworld 

(For decent handling of most significant bit set (see , too), use - just slightly harder to read and explain.) 

This is quicksort, using Hoare's partition scheme with a twist (use two reads and two writes to resolve one inversion wrt. pivot instead of a swap (/"exchange" - making it the counterexample to labelling quicksort "partition-exchange sort": a direct exchange is not essential (partition is)), conventionally taken to be equivalent to three reads&writes, each. With today's memory hierarchies, don't expect it to be any faster because of this). This is a respected algorithm in wide use, if with three-way-partition, even dual pivot values. (There is a bug in your implementation: stuck if both and index an element equal to the pivot value ().) 

I do not consider transforming data to facilitate processing , unless it explicitly violates part of the task description. Things I don't like (this far, you saw it coming) about the execution (of said approach): 

You can do as a decent compiler would: precompute some expressions, and reduce the "strength" of others. For worse rather than better, most opportunities for this are in the constructor. Part of the performance of on object depends on its interface - I've included an alternative function that finds the (position of the) next match, if any. Benchmarking is difficult, micro or not: beware "printing" and use help. 

The very first line of the code presented features a strategic mistake: This is an undocumented not implementing an : "no one" will ever be able to provide a drop-in replacement for any implementation, let alone pick it from the likes of trove or Goldman Sachs collections. "Hearing" list-of-strings in a Java context, I "see" . Looking at what interface specification there is, I see a lot of (just as Timothy Truckle did), and a bit of : I'd willingly take serious a implementing if it extended a "standard" implementation: just consider supporting streams. I follow the concern regarding (the very first conditional statement prevents fulfilling the comment above), but beyond insisting on monotonicity, only seems guilty of not using (just as ). You claim (without providing a MCVE (which would likely render the question OT on CR)) - I'd look elsewhere: what about decreasing twice? A nice touch would be copying the beginning of the array up after a removal if it was shorter than the end. And using any unused indices at the beginning when adding (hey, half-way to circular buffer). I'd let petty concerns lie if it wasn't for - just don't get into a habit of (ab)using like that. 

I guess I'd add an alias for "the other side" everywhere a method name is decorated left or right, the way the library grew a . For , you could swap accessors (including, depending on implementation details, iterators) instead of references - better yet, create a class with swapped accessors and mutate the object on . What about ? 

The idea to split the input list is uncalled for - when merging begins with runs of length 1, begin by taking items from the input one by one. Posting this mostly to illustrate my comments about how to split (defaulting on the counting variant - would have a different interface and look tedious as well as boring (and pointless: see introductory remark): keep account of list lengths in mergeSort(Impl). Pass a count into split(), return node after that count and terminate head at the node.) If there was value in putting items in one of two lists alternately, have a look at . Without giving it due diligence: 

With determination, the bit-hack variants of population count and parity can be coded without undue regard to type sizes: 

(Dare I mention comments, doxygen, or statement of purpose?) No documentation of and in particular means not knowing if there are any invariants to keep (at least on return). There is quite some open coding of doubly-linked list operations: use a library or try and factor out as much as possible (which only carries so far with intrusive lists/trees in a language not supporting OO). Regarding the amount of lines: consolidate early outs, e.g.: 

(I had no luck using "the []-interface" to .) I have an idea what made me refrain from creating a class to (temporarily) keep a rectangle list, its label and its intervals "on the sweep-line" together - would a "named tuple" be/look more lightweight? Is ("avoidably") creating a new object using too costly? Suggestions (/edits) to make this code more readable or pythonesque (pythonic? "less irritating to those well versed in python") welcome. 

Note the order. Start readable. Start with What shall this be good for?: (doc)comment your code. No slower than what? A "well known implementation" for reference and as a base-line would be useful. Things I liked: 

LeetCode seems to stress preparation for technical interviews, I consider it prudent to start sketching the most simple thing that could possibly do (I take the liberty to substitute the original last word work). Things I like about your approach: 

As interface design is pivotal in type design, I'm happy to start there - let me refer to . In no uncertain terms, the documentation summarises in just two sentences what is about: element access and bulk boolean operations (see for something irritatingly similar) (leaving out summaries ( and ) and paraphernalia). I like that it is possible to have non-reflected binary codes - assuming a : . I second AJD in preferring a constructor with a single parameter as an alternative to a separate generator class for reflected binary Gray codes. With that change, the whole API collapses to - which in itself is weird: Objects should be constructed in a valid state and never get invalid if that can be helped. (Another hint about the API is the lack of documentation - compare to .) Then, there is implementation: 

(I don't intend to go into computing Fibonacci numbers fast (Takahashi, Daisuke: "A fast algorithm for computing large Fibonacci numbers"), but keep the focus on the code presented.) Which is not doc-commented. With cleaned up (rename to would be misleading, not much better, long/abstruse - fubar), comes to the fore: 

is an example of a comment not getting updated when the code is - place comments as near to the code they comment as possible, and check comments, too. s for input size & path: there are ways that do not require a recompile. lacks a specification, in the code: What is it to return? What are required and admissible side effects? While the first two parameters are not hard to interpret, it would be nice to have stated explicitly to be inclusive or exclusive. You code picking a pivot index/value directly into a function named - consider to factor out . (Do you try to follow a coding convention? Some of your function names are CamelCase, others lower.) You spend many lines to place the median of three at , even with three comments about the individual conditional swaps (something else to potentially factor out), but without a comment for the three combined. Not naming piques me more than & - not sure why. Why are & declared outside the ? Why do you need ? Next, it gets weird: an open coded swap, followed by indirectly recursive calls to (still in ) &dash; and no for an function - you should be getting a warning. In , you manipulate ( or might be more appropriate) in a way that looks evident - it misses the comparisons in selecting the pivot. ( misses the opportunity to save comparisons capitalising on <= == <= .) And, again, does not (always) return a value. 

Where is the code documentation? Everything not in the code will get separated - when code is copied and pasted into a different context, if not before. (Another thing python got right: the doc strings are between essential parts of the code.) /: Dispensable - whenever you can, process as you go. Giving it a try (with presentational abbr.), in Java for lack of a C# environment: 

The implied any aspect of the code posted is fair game for feedback and criticism justifies asking on CR even without an(y) explicit question. I'm taken against guessing what any piece of code is there for: Why another python quicksort? doesn't get answered in the code. While the docstring looks charming, the parameter to is over-specified: everything needed is "subscripting" to get&set items and comparable items. (Numeric items could be deemed handy for picking as a pivot the mean value of several.) The code mentions neither nor : should be specified to return its (ordered) parameter. , like beauty, lies in the eye of the beholder - to mine, both are close regarding code. I like python for its ability to express things with minimum ado. (I don't quite like & - sometimes use &.) In demonstration code, it seems to have grown conventional to factor out partitioning the current sequence from . True? The code doesn't use as a stack. As far as means o(n) space (in addition to output is where input used to be), the implementation presented is not in-place. More efficient? Sure -