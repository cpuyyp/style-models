If you are going to inialize n here, it would be better to put the initization above the loop. The code could be simpler by just using strlen in the condition portion: 

Reducing the amount of code is a benefit because it makes it easier to write the code in the first place, modify the code later and debug the code. You did well following another software engineering called the Single Responsibility Principle. The single responsibility principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. When raw numbers are included in code they can often be confusing. Also if the same number is used multiple times in the code for the same reason, such as for array bounds it is easier to understand the code and modify the code using symbolic constants. Some examples that might apply to this program 

Each unit should have only limited knowledge about other units: only units "closely" related to the current unit. Each unit should only talk to its friends; don't talk to strangers. Only talk to your immediate friends. 

The sub functions of both of these functions may be usable and sharable by each of the high level functions and that may reduce the total lines of code in this program. Error Handling in C There are times when it is inadvisable to call either because the code has necessary clean up that it must do, or the code is part of a larger system that should not quit such as an operating system. In such cases the error should be reported and then either the function should return an error status or some form of exception handling should be used. In the the only exception handling is the possibility of returning to a known good state using setjmp() and longjmp(). An example use of can be found here. The function saves the state of the program at the location where it is called and provides a location to jump back to in case of errors. The function jumps to the location indicated by . In best place to put a call to setjmp() is in a high level function such as or one of the functions called directly by Alternate Form of Main In more complex C programs such as this one it is better to limit the code in the function to setting up the program to run such as parsing the command line for switches and opening any input files, calling a function that executes the major portion of the program and then calling functions that clean up after the program has run, such as freeing any memory that has been allocated or writing to and closing any files that have been open. An example: 

If global variables are going to be shared between modules the header file should declare the global variables as because as defined above the variables are declared in each source file and this should cause multiple symbol definitions at link time (it should be reported as a link error). Global variables should never be used in shared libraries, it creates dependencies in the executable binaries that are hard to track down. libasc There are functions in libasc that are surprising in a shared library, , and are functions that one expects in the main executable binary rather than in a shared library. What would be more expected is features shared between executables such as functions that create and alter the prog_master and thread structs. Functions that are Declared but not Defined The code contains a static declaration for the function print_info(), but the function is never defined and never used. A good suggestion is to always compile with warnings during development, this will help to eliminate bugs. 

Inconsistent Variable Naming Conventions Within the function there are the variable declarations , , , , , and , but there are also much more descriptive variable names such as , and . It would be better to make all of the variable names as descriptive as these last 3. I understand that there is av has a naming collision with the average function and var has a naming collision with the variance function but it would be better if they were named more clearly. I have no idea what , , , or really represent. The point of descriptive variables is to make the code more readable so that comments like or aren't necessary. 

Recursion in an Embedded Environment This function is a recursive implementation. Recursion is a memory hog and in an embedded system you may be very limited to the memory you have. Instead of using C type strings, why not use std::string? The C++ string type std::string has a find_last member that will perform at least half of this function. Macros in C++ It appears that you are more comfortable writing C rather than C++. While macros are supported for backwards compatibility with the C programming language the use of macros is strongly discouraged because they aren't type safe. There are many alternatives to the use macros. For defining constants there is and , for functions that handle many different types the are . In C++ there is no good reason to use macros. Missing Header File The standard library function requires the header file 

This is a nice first Code Review Question. It's not a simple hello world program and it took some real effort. Use the Tools You Have When developing new code in C++ always compile with -Wall switch. This switch provides additional compiler error checking and allows removal of possible bugs as early as possible. The compile can also treat all warnings as errors. When I compiled the code I got the following warnings: ../src/SudokuSolver.cpp: In function ‘bool isNumeric(const string&)’: ../src/SudokuSolver.cpp:46:41: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] for(int itr = 0; itr < input.length(); itr++){ ../src/SudokuSolver.cpp: In function ‘void strToUpper(std::string&)’: ../src/SudokuSolver.cpp:56:37: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] for(int itr=0; itr ^ ../src/SudokuSolver.cpp: In function ‘bool squareContainsNum(subSquare ()[9], const int&, const int&, const int&, const string&)’: ../src/SudokuSolver.cpp:208:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ ../src/SudokuSolver.cpp: In function ‘bool rowContainsNum(subSquare ()[9], const int&, const int&, const string&)’: ../src/SudokuSolver.cpp:231:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ ../src/SudokuSolver.cpp: In function ‘bool colContainsNum(subSquare (*)[9], const int&, const int&, const string&)’: ../src/SudokuSolver.cpp:254:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ Type MisMatch When using any C++ container type that has the function . the function returns type . The type is currently defined as unsigned int. Comparing or assigning type to type can lead to surprising results because a positive unsigned value may become negative when it is converted. The loop should be recoded as 

First you can easily change the size of the array by changing the code in only one place. It makes the code more readable. If a for loop is used the same constant can be used in the for loop to make sure that arrays aren't indexed past the size of the array. 

A few observations to help out: Bug in Pop In a LIFO structure the value to be returned is not . LIFO structures are definitely different from FIFO structures. The Code is Not Portable Right now the code will only compile on Windows because of the use of . It might be better to just use standard C io, in this case probably . It might also be better if was only included where it was needed rather than in utilit/ssbl_stack.h. Struct Name May be Incorrect It might be better to rename to , an unsigned long is not guaranteed to be 32 bits, it may be 64 bits depending on the architecture and compiler used. Prefer Calloc() Over Malloc() in This Particular Instance Calloc by default zeros out the memory it allocates, so rather than calling malloc() and then using memset() to set the entire array to zero, call calloc() and the entire struct is already zero'd for your. LILO Versus FIFO @vnp is correct in his comment. Is there really a difference between these two, as far as I can tell the both equate to FIFO? The same question applys to FILO and LIFO, in each case it evaluates to First In Last Out? Typical computer science terminology refers to stacks as LIFO and queues as FIFO, the two alternate forms could confuse people using the structures as a library. Incorrect Order of Execution of Create Functions If the code continues to use rather than the call to should clear the entire struct and occur immediately after the malloc rather than at the end. This would change the existing code from: 

Generally the variable and function naming is clear and makes the code easier to read. If this program is for a first or second year computer science class it's really very good. If you are new to C programming it is also very good. Having modular programs is always good because it allows reuse of the code and minimizes side effects. Module Partitioning There is a software design principle called The Single Responsibility Principle. This principle applies to functions and structs in C and functions and classes in C++, Java and other programming languages. The principle states that a function or struct should be designed to do one thing and only one thing. This makes it easier to read, write, test and debug programs. Another important software design principle is to reduce coupling between modules and data structures. Coupling should be reduced to make each module of a program as independent as possible to reduce side effects. Decoupling modules allow the addition of features or bug fixing in one module without breaking code in another module. This is why global variables are generally frowned upon, they create tighter coupling. Here are some general guides to software design. The way the files are currently partitioned creates a tight coupling between main.c and map.h. The main() function really only needs to know about the functions in pathfinder.h. The map variable only needs to be available in the pathfind.c file, The map header file contains 7 character constants. This creates the static variables in every file that includes it. The static constants should only be included in the files that use them. The map.c file is the only file that uses these constants so all the static variables should be declared there. Currently these static variables are being defined in all files. If they were not staticly defined the linker would be reporting multiply defined errors. The function inBounds() should be declared as 

Using iterators in this manner makes it much easier to program correctly. Declare Variables as Close to Use as Possible In the loop defined as a possible candidate for a function there are 3 variables that should be defined within the loop rather than at the top of the function. The variables l1, l2 and l3 are only assigned values and used within the loop. 

It's a nice beginner effort, keep up the good work. This program can be and probably should be expanded, it will only process a single line of text. The while loop you have in the program should be moved into a function that processes a single line of text, in the main program you should have a loop that reads lines until there are no more lines. A getchar() version of this program may not have this limitation. Rather than checking specifically for space, you should include ctype.h 

Welcome to code review, a nice first question. The code is well written and readable. Just a few observations that may help improve the code: As @TobySpeight mentioned, you should change the variables to so that the warning messages go away. Missing Header File The code is missing 

For performance reasons you don't want to call a function. Check the file, may be a macro, in older versions of C (pre C89 for sure, possible pre C99 ) all functions provided by were macros. Type Issues The variables and in main are declared as unsigned long long, however the functions are expecting pointers to long long. It's also unclear that long long is required since 2^32 is the max value for either or .