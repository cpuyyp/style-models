Where is any alphabetical letter, is any number, and is any number . No result string should begin with , it should always begin with or , and all alphabet characters will always be capitalized. The input comes in a format similar to any of the following: 

Now that the lecture is over, let's look over the code quick: You have a lot of "magic numbers" here, most notably and , you should consider giving them a identifier. (Consider what and mean in each instance, and what they mean if you were to be writing a Base32 converter instead of Base64.) Your for loop () can use instead of there, just as well you should assign first, then use it instead of everywhere. I.e.: 

There is no need for to be as many lines as it is, we can shorten it into one. (ALL the variables are used in one location.) 

By using a we've made things substantially more clear: our intention is to only evaluate what is and do something based on it. 

The type in F# is, by .NET definition, mutable. So you really don't need on it, it's already mutable. We try to avoid mutable state, but sometimes it's just not simple. In our case, I'm going to leave it. 

For your use case, this function is not helpful. You update manually as many times as you update it with this function, and one of the updates you do with this function is undone by a manual update. Just swallow the bullet and replace this with manual updates instead. 

In our chat you state you were told to use when matching against a simple boolean (there's no specific reason to use it over , or over it for that situation, so I'll not comment on that) but you can rewrite that with one instead of a with a nested : 

Eventually you're going to want to handle other key-presses, correct? You might also want to handle other encoding styles, like EBCDIC, correct? So, I've never done Assembly before, but these are pretty simple things to design for, and I hope the implementation is correct. First, we want to build a (very large) jump table for ASCII. Essentially, a jump table eliminates all of your comparisons down to exactly one comparison. It's pretty easy to set up: 

The biggest issues I see are some conformity/readability issues. For example, the following / structure: 

Well this introduces our class, and really stands out here. Let's look at both of those: The class does some dirty things, and I'm not proud that it does them, but I think it does them well enough that, while we lack other options now, this will suffice. I built the the way I have to isolate the from the environment mostly. It can still access all the classes and such loaded, but at the very least it has no unwanted local variables, and won't leave any unwanted local variables in scope: 

It feels somewhat awkward to answer a question this old, but there are some things that can be done. 

On to the Review Your HTML is not at all valid. If this is a snippet, then that is expected, but I would recommend to take use of the tools out there to get automated reviews of whether or not the HTML is legal. The W3C Validator does a great job at that. Some points to take from that validator: 

There are certain, "acceptable" use differences between the two. For example, elements should never contain any block-level elements. It's considered good practice to use tags around bits of text that need special styles. It's considered bad practice to use them as block-level containers. You should also only use elements when you need a true container, as that is what elements are meant for. A is a "division" in the page. That is, this next bit if content should be significantly different from the previous content. A is merely intended to allow for the grouping of bits of text. Inline elements are similar to the inline code-blocks you see above. The style is only applied to fit whatever content is within that element. So, with a tag, it will resize itself to fit the content within it. Block-level elements are similar to the quote you see above. They will stretch to fit the entire width of the parent container, unless otherwise specified. Think of them as a rectangle. They will always be a rectangle-shaped element, whereas inline elements will wrap to their content. 

Disclaimer: if this answer feels like it gets less patient and more "to-the-point" as it goes on, I'm really tired as I am / was writing this and I can't English / logic right now. I promise I mean the very best with this, and I'm having trouble even typing at the moment. This is actually fairly solid code for a C# beginner. 

Now you can call and get a from it, but we're not going to do that. Now how do we wrap a generic construct? With a : 

And now your 'OutOfMemory' error should be fixed. This is the first suggestion that Simon stated. But, if you test it, you might find that for it doesn't solve your 'OutOfMemory' issue. Why? Because we're using the wrong data-type. Specifically, for value we end up going above the maximum value of a signed integer. You need to be using the data type for your iteration to fix that. I wrote a version which tells me when it happens, and got the following: 

I meant to answer this a while back, but I completely forgot. At any rate, let's talk about a couple things. First, try not to use a pattern match if there's no pattern. In this case you have: 

This was inspired by a conversation in chat, that started with the discussion of C#7.0 tuples and out parameter declarations, which led to the idea that there is no 'good1' way to return an error state in C# without throwing an exception. Out of curiosity, I wondered what it would take to design a type that was transparent to the developer, but allowed them to safely return exceptions without having to unwind the stack. For those who don't know, when you / objects in C# (or VB.NET, F#, any .NET language follows the same requirements), the most expensive part tends to be the stack. Throwing an exception is cheap, but the exception and the stack has to unwind and reflect against itself to give you the information you need. This is by-design, of course. The language and framework designers wanted exceptions to mean that the program entered an 'exceptional state', that is, there is an issue that needs resolved. The problem is that some methods don't really need to throw an exception on error, they could, instead, just return a pass/fail and then fill an parameter. The other option is to return a , where is the return type. Of course, this doesn't give us the ability to return an , just pass/fail. Sometimes we may want to return what went wrong. So, alas, I get to the struct that I created today. By including conversions to and from and , it allows us to simply instead of throwing, creating a much cheaper management of error states. The only caveat to this approach from a usability standpoint, is that one does not simply define an implicit conversion from . This means that is invalid, but is, as well as . If the framework/language designers ever open up conversions from , then this struct would be completely transparent.