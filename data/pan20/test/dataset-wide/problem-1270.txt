what s*cks is that you can't really compare with other types because is not expected to return anything other than 1,0 and -1 (no way to tell "it doesn't make sense to compare these values")... so , for instance, can't be used. 

Accepted an answer because it is a valid solution, but i'd like to explain an approach that seemed interesting (not functional as is): coercion plus a , in the spirit of the monad used by Avdi Grimm. 

Moreover, i have subclasses for this class that override these methods (different tax calculation rules, etc.) The thing is, as long as an instance is in a consistent state (all a, b, c... fields are present and valid), all the methods work fine. But instances must be able to be in an inconsistent state, because...well, we want to be able to validate them. So raising during when the params are meaningless is out of the question. In this case, let's say are filled with junk strings or instead of meaningful values : all of our methods will raise various errors, or even worse - thanks to duck typing it will work in a crazy, unintended way ( , anyone? ). Trying to solve this problem first try : nil guards this is getting ugly pretty quick : 

cache your jquery elements Looking for an element in the DOM is expensive, you want to avoid doing it multiple times for the same element whenever it's possible. Just store the element in a var and use it in your function calls and callbacks. getData doesn't return what you think it returns sure, you return . But just before you issue an AJAX request, that is an asynchronous (non blocking) request. What happens here is that the browser fires the request, but doesn't wait for an answer to go on and return immediately - potentialy before your callback even has a chance to change . That's why you have to use callbacks. Given all these remarks, I would go for something like this : 

To be continued I will come back when i have more time to analyze your logic, but here's a hint : when you have a lot of conditionals, it usually means you failed to capture a concept / mechanism as an object. Find out what concept(s) it is and you should be able to clean this. EDIT : Refactoring Let's analyze this bit of code : 

and so on. You get the spirit. Use presenters Another option is to use the presenter pattern. The Draper gem, for instance, makes it easy. The idea here is that instead of passing your model directly to the view, you decorate it with the appropriate presenter. You'll have for instance one presenter for the editable view, and one for the static view. Each presenter will have methods like , , etc. that know how to render a component of your view, format the values, etc. your actual view will simply be a layout that arranges the components. As presenters are objects, you are free to use inheritance / composition / delegation to share some logic, which often helps DRYing the code while keeping it clear and readable. 

This view knows far too much about your data model structure. One level of nesting is reasonably acceptable, but this many is dangerous : in fact, this view needs knowledge about no less than 4 different business objects, not to mention it has to know the relations between them. Solution 1 : the facade pattern Abstract away all those details in another object, which would be the sole source of truth for your view : call it a form object, or a presenter, or a context in DCI idiom, whatever. The idea is that this object has a simple interface that maps to the complex underlying system. We'd need more details on your business logic to be able to help you on this one. Solution 2 : cook your own "accepts_nested_attributes" method on your model, create a method that provides direct access to your ratings. Then create another method that allows assignment, like . In this method, process the passed parameters to create / update associated ratings ; you can find inspiration for this in the source for the method. 

same method applies to other parts of your script (for instance, only create the modal once, then show/hide/resize it, and change image inside). Style considerations Just a last minor remark : when declaring many vars, you can do : 

There's two things I usually consider in this kind of situation: Use custom helpers and partials The idea here is to break down your view in small components, and have one helper to build each component. Most of the time those helpers will just dispatch and render an appropriate partial : 

That said, I have a few pointers that you might consider helpful. Use closures Your object is not really necessary, and sometimes it obfuscates the code a bit. In fact, as your script only evaluates once (no subsequent call after ), you could replace your object with a closure : 

This way, all your callbacks will respond to uniformly, so you won't need conditionals anymore. 2) use inheritance As i see it, your instance variable masks the need for two different behaviors, which means two different classes : a "silent" trigger, and a "verbose" one that extends the former. 

What happens here is that you create a function that you immediately call ; all vars in the function body are in a local scope that is not accessible from the outside (this prevents conflicts with other scripts). Using a closure, you will be able to run intialization code without having to stuff all your functions inside an object or worrying to pollute the global namespace : 

... if it quacks like a float, then it is a float. This allows to leverage ruby's awesomeness with things like : 

As you can see, this simplifies the logic a lot, and makes clear that we have two different behaviors, which is invaluable for consumers of your API. 

Basicly all of this should be in the body of method (give up the struct, use a real class : too much logic is attached to this entity to be a simple bag of data), so that you can do : 

see the docs for more info. note : If you get an emtpy string from your params, in this case I usually find it more relevant to change the markup to avoid the need for calls. This is a matter of taste ; all things considered, in ruby any object other than nil and false is truthy, so I think it is coherent with ruby's 'spirit' to avoid passing meaningless params at all. 

I can't talk for the java part, but here's my two cents on your js. favor placing scripts at the bottom of your page. ...just before the tag. Many reasons to do so can be found out there ; mainly it's because script links in the block page loading while the external js is being loaded and parsed. use a closure Your var is in global scope. If you want to avoid this, use a closure : 

I promptly stopped because it felt ridiculously overengineered, and smelled like feature envy over the top. I also considered using the monad, or create a monad of my own like "MaybeAValidNumber" to coerce everything to meaningful values. That felt not much better than nil guards and again, overengineered. third try : don't care Thinking about this, i wondered if i should nil guard at all : after all, these methods are only relevant if the instance is in a consistent state. As far as i understand it, design by contract goes this way : if you do not ensure state prerequistes are met before calling the methods, you break the contract, so you are at fault. Problem is, as you can easily guess, these methods are likely to be called in the views to display the results of calculations. I don't find having to throw a bunch of conditionals in my views entirely satisfying... Thoughts ? 

+1 for . As to the best practices, i'd recommend if possible to clearly state dependency of module A on module B : 

It saves typing and it is a bit more clear. In fact, some recommend using the keyword only once and on top of the scope. 

Of course, there is certainly a way to improve that... just an idea. (I'm not really familiar with telnet protocol, either - so I did this a bit blindfolded) 

Not exactly a code review, but did you know that ruby 2 introduces binary search for arrays ? See : Array#bsearch. your problem could be solved like this: 

... Looks oddly like a ;). What i like about this solution is that it allows to perform arithmetic operations, even with potentially non-float coercible values : 

sometimes you can also DRY it up a little by using 'peacemeal' helpers that only affect parts of a tag : 

Use closure-local variables In your code, your init stuff is called every time the user clicks on an image. This is bad because, for instance, you call every time, creating a new element an appending it to body over and over. As you will only need one screen throughout the entire app lifecycle, it would be sensible to do something like this : 

1) get rid of conditionals I think your main problem here is the nested conditionals that litter your code. This increases complexity and tends to be less readable. You can get rid of those conditionals using a method like this : 

note : works under ruby 2, don't know for other versions EDIT : warning - unfortunately, this will only work with positive steps. I think it would be better to change the method's interface to this : 

EDIT the more I think about it, the more it seems obvious that a parser would be more adapted to this problem than a state machine. Unfortunately, I don't know much about writing parsers... ORIGINAL ANSWER Maybe you could try to create one class per state : 

... and to get rid of category-related conditionals in the template. I Just wonder if this is a good idea, and if it has drawbacks i don't see yet. Thoughts ? Note : Of course the actual implementation can be different (use a specific subclass of instead of extending an instance, for example - or even using a decorator). 

I think it's reasonable to sacrifice conciseness for more obvious code ; especially when dealing with time, which is often hard enough a problem in itself to avoid adding mental gymnastics to the outrage. Your code requires its reader to mentally add and substract time values to understand what's going on, the above does not. 

Dynamic typing sure is dangerous, but you have to embrace it if you want to benefit from it. Checking the type explicitly is an half-arsed solution, because : 

...wich also leads to a lot of conditionals in the template if is absent. I had this idea (a variation on the pattern) : 

note : if your DoubleSeries class has no state and is not meant to be instantiated, you should make it a Module instead (Service object) 

This also leaves you the latitude to inspect the params and throw an if some usefull params are not present. 

... this way you can iterate through or at the end of the import process (to display errors, or perform additional tasks). This code can also easily be adapted to only catch exceptions : 

A bit better, but now the whole validation process kicks in every time i call a method. This is silly. OO to the rescue ? second try : OO refactoring My first thought was : well, we have a behavior that varies according to state - this is textbook example for a state machine. But how would i hook this on 's validation cycle ? Did not figured it out. Then I proceeded to try and extract those methods into a variety of immutable decorator classes, with a factory method that accepted one instance from my class : 

... ugh, nil guarding isn't enough, what if i have strings instead of numbers ? I admit for a while i was tempted with heresy : 

First of all, this may be a matter of opinion (my CTO totally disagrees on this, for instance), but I think splitting a long method / function into tiny ones with a single, simple purpose is the right way of doing things. Actually, this is also the position held by the "Clean Code" book and many people out there. The benefits you state do exist, and other reasons to code this way can be found in aforementioned book. What i really like about this though : 

Anyway, if my design is wrong itself, let me know. Context I have an class. It is pretty simple, but has lots and lots of methods that require the whole instance to be to work correctly. The class in question handles a complex tax calculation, but for the sake of clarity, let's boil it down to this :