I do not understand why rounded up is equal to rounded down + 0.01? You are checking whether the rounded down value is smaller than the original one. From my perspective it is more logical to check for equality instead as this is what you meant. 

You function read_line does not what it suggests. It reads a file line by line. So you should find an appropriate name. Your choice of uint_fast8_t/uint_fast16_t is interesting given that your example csv table hold some larger values. Have you measured the impact vs unsigned int or std::size_t. Be aware that modern cpu can read multiple elements at once so you choice might actually have negative impact. Every line you clear numbers and build it up again. It will be beneficial to just initialize it once via and then just overwrite the old value. That way you can omit the unnecessary Getline takes a third argument which is the delemiter. Also getline stops at newline and end of file so you dont need all that error checking Given that you now the number of entries per line you can simply loop and accumulate 

The algorithm is overly complex. First, some general remarks. 1. If you use in a loop, you're doing it wrong. A search operation in a loop can be replaced by a grouping operation. Perform a single pass over the list and group it into a hashset. 2. If you can't reduce complexity, change the variable. Kruskal's and Prim's algorithm both calculate the minimum spanning tree of a graph, but their complexity depends on edges (Kruskal) vs. vertices (Prim). In most nested problems the variable to loop over can be chosen. Decide on the smallest. In your case, the number of trains and stations is probably large, but each train stops at only a couple of stations. Let's apply them. 

This is a textbook example asking for dynamic programming. The time limit is chosen such that success is impossible without dynamic programming. Dynamic programming can be applied to recursive problems. The idea is to store the results of all sub-problems in a table and if you encounter the same sub-problem again in another recursion path, you can return early. Change your code to something like this: 

Great that you renamed you function according to what it does. I would suggest, that you add a helper function that reads a single line. Creating small well encapsulated functions is key in writing maintainable code. Regarding you code there are some small nits: 

The reason for the error is, that we only need go back at max steps as after that point any instruction will be ready and we can sort from there with simply after the , which ensures that we always schedule the most important instruction first. 

Better Solution So these were the intuitive solutions. However, is there some room for further improvement?. Obviously yes. The point is, that you do not need to store the same element every time because you know what the maximum is. You can circumvent this by using two stacks. One with the current maximum and one with the number of its occurences. 

This is one of the questions, that is directly related to the underlying data structure. So you can actually be quite sure, that this problem is best solved with a stack. The trick here is, that a stack ha$URL$ a well defined order in which the elements are retrieved. In that particular problem, lets say you know the current maximum of the stack. If the new element is smaller than that, you can push the maximum value instead of the actual one, as you are only interested in the maximum value of the whole stack. This is only true, as a stack guaranties, that the new element is removed before the previous maximum element. Only if it is greater you push the new element. This has the distinct disadvantage, that you do not preserve the original data. So there are two solutions, one for tracking the maximum element and one for also preserving the data. 

Main routine (for testing) Takes the program directly (not a filename) as first command line argument. Prints the tape's contents to after each step. 

Now, there's a set of list. Each of them is identified by a tuple and contains the connections between those points. 

Algorithm You only need two stacks. Always write to the , read from the . If the latter is empty, copy everything over. Naming Use meaningful names, such as and instead of and . Declare them . A queue's user doesn't care about the internals. Import only what you need, in this case . Generics The is a generic datatype, make use of it. Make your generic as well. Instanciate it using 

Both cases are identical in the first three characters, yet the operations to perform are different. They depend on characters not yet read. Any algorithm that does not take into consideration the full picture before making a single descision must fail at least one of those test cases. Yours fails the second. Brute force The naive way to overcome this problem is a brute force algorithm. Evaluate all possible sequences of operations (insertions, deletions, replacements). When all input was read, output the best sequence. Dynamic programming Dynamic programming starts out similar to brute force and evaluates all possible operations, but whenever it finds that two sequences of operations yield the same intermediate result, it keeps (and evaluates further) only one of them. 

The same applies for functions that do not change the state of the class. mark them const. Your naming is often confusing. AcountLocation seems to stand for AcountID. Please go through your variables check whether the name means the right thing. The last element of a contain can usually be accessed via . So instead of you can write , although it returns an iterator. If you go through a container, you can use range based loops in C++11, so this becomes that 

You can paramterize a circle via a radius and the angle. Therefore, for the cycle with radius r around (h,w) you can calculate the x and y coordinates with the following equations 

I would recommend to include standard libraries li first and then your custom ones. Also separate them to provide a better overview. Directly throw an exception in this case std::runtime_error I would suggest to use iterators over current index and friends. 

Then i would urge you to define more classes that hold your respective data and apply some methods. Currently you have one class snake that does everything. It might make sense to encapsulate rendering into its own subclass and the snake itself too the same goes for the arena. 

Learn to use Folds, Maps, Filters and Zips! They are key concepts of functional programming. The sum over a list can be written as , a product would be . This is not limited to basic math operations and numbers. You can supply any function on any type of elements. In a similar manner, joins two lists into a list of products. Don't repeat yourself. Your function , and share a lot of code. Never copy-paste code. Create the proper modularisation and reuse it. Here, can be reformulated to use only calls to , and is just the self-covariance (and a square root). 

The problem can be solved in less than quadratic time. Sort the elements by absolute value, then search for consecutive elements that sum up to zero. 

Inspired by this question, I decided to give it a try and implemented a brainfuck interpreter myself. It includes various improvements: 

The algorithm is wrong and can't be fixed. It's not dynamic programming, it's greedy: it iterates over the strings once and decides immediately which operation to perform. Consider some test cases: 

Closed form solution The problem is basically a sum over an arithmetic sequence, which has the well defined solution 

I dont even know what you are trying to do here, but there is no possible reason you want to copy all that memory around. Also you know in advance the number of steps you have, but I do not see a single 

Regarding negative steps I would stop making my live hard and simply swap t_end and t_start. That way you can use the same code path for both cases without worrying about signs etc. If you is not a multiple of your you need to evaluate again with a smaller time step at the end of your computation. You are stuck with float or double for h. The steps are non integral so ... RK is a multistep methods, where you calculate the n-th step using the result of the n-1 th step. So it is not possible to parallelize the computation of a single step. What you can parallelize is the computation of the different ODEs. You need to really step back and consider whether your code is doing the right thing and then you should ask your self how long it took you to come to that conclusion. RK is a really simple method and your code makes it just so incredible complicated