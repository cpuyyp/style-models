All the code samples below are functional and in both cases my sequencer is behaving as intended when populated with some simple test tasks. I recognize that I'm being a bit loose with the permissions - a lot of things are public that probably shouldn't be but it makes it easier to test and debug in my current engine and I'll buckle down on that a little later. I'm a self-taught programmer who hasn't worked with many large or experienced teams yet and I'm still quite new to C# as a language, so I'm more than happy to receive any critiques or advice on how I can generally improve! First Attempt: This was my first attempt at handling real time tasks (for example, automated character movement over time). If a task can be performed with a single frame/update/tick it will either return or , the tree will continue being traversed, and as many nodes will be ticked as possible. However, whenever a task node returns we need to store that task somehow, back out of the tree traversal, and resume from node next time. Because each composite task calls on its sub-tasks, it seems like the state of the tree at any given time is tied to the function call stack. I can't just store the running tasks in a list outside of my behavior tree, because despite being easy to tick them again next frame I would be losing the bigger picture of their place in the tree and wouldn't know where to go next. I 'solved' this by creating a reference to a task in each of my composites. When one of a composite's sub-tasks returns a reference to that task is stored in then the composite also returns . Next time the composite is ticked it checks if a task has been saved. If so, the is reference compared to the current iteration and the loop will jump ahead until we find a match. This is the behavior tree class which only really serves to encapsulate everything: 

Overall, it looks pretty good. Not very much code, so not very much that could be bad. I'll give you some tips, from my perspective: This first note isn't exactly about C++, but more common than that: It's a good idea to put "public" things first in your class, and more protected things further down. This is because when people look at the class, they are more likely looking for public things, rather than protected/private things. So if you put those at the top, they don't have to scroll through to find them. Consider making an inlined function, by defining it directly in the header. It's a shame if such a quick and simple function would incur the cost of a function call, and the cost of inlining such a tiny thing is near to nothing. As I see it, all direct/simple getters and setters should be inlined. There is no need to write , since that is always implied. They only clutter the code. It is good practice to point out which variables are actually protected members, in the name of the member. I personally put a small "m" in front of all protected members, such as "mSurface". Some people write "m_Surface", or just a "_" in front, with no "m", and so on. The part that says , you should use instead of . It's a keyword from C++11, assuming you're using at least C++11. is a pointer-type, while is simply an . Writing is exactly the same as writing . In some cases, this causes ambiguity, so it's good practice to always use this keyword for null-pointers, since it sometimes actually matters, even if not always. And as for const-correctness, there is only one function to consider, here. And since it returns a pointer, which could be used to change internal data, it shouldn't really be considered a member function. (Or "method", to you Java people.) 

Here's my new sequencer code using IEnumerators. It works as it should, but honestly I suspect this code is kind of bad! The basic idea was to store an enumerator that always references one of the sub-tasks. If a sub-task is succeeds, the enumerator moves to the next one and we tick it immediately. If a sub-task fails, the enumerator is moved to the beginning. And finally, if a sub-task returns we don't touch the enumerator and we just back out. Next time the composite is ticked, it will tick whichever subtask is referenced by the enumerator. Here's the altered Sequencer composite task that I rewrote using IEnumerators: 

Conclusion Anyway, that's about it. Both of these "sequencer" composite tasks work correctly now, but I'm not convinced that the code couldn't be a lot better in both examples. The first code is just a brute-force reference comparison of the saved task against the current sub-task, but it's relatively clean and simple. The second code is based on iterators/enumerators and feels like it's on the verge of being the right path, but it's also a bit messy and it probably shows my lack of experience in certain areas. I'm alright with that, as I'm here to learn and improve! After all, I don't have many opportunities for code review! My main questions are: 

Spent a little hacking away at this to simplify the code. I wrote comments on changes inline the script, let me know if you have any questions Some thoughts on the changes. Notice that how I restructured your validators in the form 

No need to check if the variables are . A dates value is its time so when you make (less than/greater than) comparisons with a Date instance () you're essentially comparing it to or which will be the same as . Therefore the below will always be equivalent: 

To answer the actual question OP seems to be posing -- the pattern is fine I wouldn't change it but I would expose whatever you want to expose explicitly into a namespace using this format (window or whatever namespace): 

I see a bug for a property case as . You should check if it's not null or an object :) Another less important? bug is you can't use the key on any of your objects. You can get around this by using Only obvious optimization I see is to move the check after the check. is a relatively expensive function so you will probably see some gains off that. I expect this should be even faster than doing which is known to be faster than your loop... I assume you're polyfilling trim for older browsers right? 

This worked fine, but it felt a bit messy and brute-force. So I thought about other possible ways to do it. Thinking back to some of the C++ code that I've written, using something like an iterator came to mind. After a little research I found that IEnumerator seems to be more-or-less the same idea in C#... Second Attempt: So, going back to the drawing board, I tried rewriting my code to make use of enumerators. Now, instead of storing a reference to a task, my composite now stores an reference. I've used foreach loops and IEnumerable objects many times before in C#, but this is the first time I've ever needed to deal with IEnumerators alone. Honestly, I went for a kind of 'lazy' approach to calling instead of doing so in the constructor because I figured that tasks might be added and removed dynamically at various points in time. I added some small convenience functions for controlling my IEnumerator to prevent cluttering my code in other places. Here are the changes to my CompositeTask abstract base class: 

Background: I'm in the process of writing a relatively simple behavior tree driven AI system for a game that I'm working on. Basically, the behavior tree is made up of individual gameplay tasks (move, attack, etc.) as well as composite tasks that iterate over sub-tasks in a variety of ways. Each gameplay task is a leaf and will return a status (success, failure, or running). For example, a sequence composite task iterates over its sub-tasks in sequential order. If all of the sub-tasks in the sequence return , the sequence will also succeed. If any of the sub-tasks in the sequence return , the sequence will end early and fail. Finally, if any of the sub-tasks return , the sequence needs to store its position, return this frame, and re-tick the same sub-task again next frame. I had no issue getting my behavior tree to work correctly within a single frame of execution at first by recursively calling down the tree. This works basically like a depth-first traversal. But I've been having some issues finding a clean way of dealing with storing and resuming from nodes that return . I probably can't post all the code needed to compile and run this without making a mess of this question but here's the basic flow of the program: