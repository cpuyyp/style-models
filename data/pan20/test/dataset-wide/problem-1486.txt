Generalization Since this is C++ you can trivially use a function template to generalize this algorithm to work with arbitrary container/iterator and element types: 

The algorithm looks good to me. What I would change: Use loops when iterating over a previously known range or sequence 

Sorting has worse runtime complexity (O(n log n)) than the search for a minimum/maximum (O(n)). For small n that doesn't matter much but once you have tens of thousands of candidates tied for first place it should become noticeable. Unfortunately only works if candidate names are numeric but we can come up with another short solution: 

Array index type The natural type for array indices in C++ is (or simply in C) because it covers the whole range of possible index values on the current architecture. 

Avoid identifiers that clash with keywords of similar languages and are C++ keywords and C code is commonly included in C++ programs. Therefore it would be better to avoid these and other identifiers that happen to be C++ keywords. You can use something like to refer to a newly created node structure instead. See the next section for a better name for . Use more descriptive function names , and (and other verbs) aren't very descriptive because they're ambiguous on what to [verb]. Use something like [verb]+[noun], e. g. , , . You already do that with . Use or to print fixed strings 

for-loops are better at communicating what is being iterated over and there's a common recommendation to not alter the iteration counter outside of the loop header. Both of these individually and even more so together make it much easier to read and understand loops. Of course some algorithms are more elegant and easier to understand if you disregard these recommendations. That's why they're recommendations for the majority of simple cases and not hard rules. Use to repeat strings Instead of the loops above you can more elegantly (and probably more efficiently) use: 

Manipulate DOM objects instead of generating HTML code in JavaScript This may be a personal preference but I wouldn't even bother with HTML here. 

You can further improve the implementation if you don't create a new array instance for for every loop body invocation. It would be enough to use the same temporary array every time: 

Documentation I took me a while to understand and research the algorithm and the purpose of the function parameters. It would be better to write some Javadoc for reviewers and future readers (which may include yourself). Identifiers You should use variable and function identifiers that explain their purpose (barring obvious cases like for a loop iterator). 

You can use or instead of to print fixed strings. The former are simpler than the latter and have no drawback in the absence of format arguments. Additionally, you don't need to quote characters. Some compilers (e. g. GCC) will optimise calls to with fixed strings without format specifiers to calls to /. Watch out that appends a new-line character at the end of the string while doesn't. 

Your approach has one serious drawbacks: it creates N-1 new bound function instances on every invocation of the returned function with an argument length of N if big-O performance guarantees are relevant to you. To avoid this you can either use a loop or the operation, both of which only create a fixed number of function instances (that doesn't depend on the number of functions to chain). Additionally I believe that both variants are easier to understand than the code in your question because it doesn't rely on recursion. Loop 

create a copy of the game state , work on and modify , update the result, copy the content of back to , do some more work on and update the result. 

You can't be sure that is defined. If it isn't its value may have or garbage content. Check the value of first and print an appropriate error message if it's too small: 

As you can see you can omit one array copy if you perform step 2 directly on . This doesn't alter the result since, at the beginning of step 2, is equivalent to and step 3 sets the content of to those of . Only in step 4 do you need to work on a copy of because you need to preserve the state of for the parent call: 

avoids multiplicative floating-point operations and overflow of integers that shall later be converted to floating-point. The only optimization I can think of is to work on instead of if possible to use the available processor word size better (to achieve that one can wrap inside a and use a view onto it). Full program (Ideone is currently acting up here so a Gist it has to be for now.) 

Respect the principle of locality, avoid global variables Global variables clutter the name space and make it more difficult to follow the flow of the program. They also prevent a method or set of methods from being reentrant, a property that allows them to be executed concurrently. (This matters not just for multi-threaded programs, but also if you wanted to, say, interpret multiple Brainfuck programs one instructions at a time in a round-robin fashion to see which program terminates first.) One way to achieve this is to move more data and logic into the method: 

Use character literals to print single characters When you perform a formatted stream output operation that effectively prints a single character it would be better to use a character literal instead of a string literal since it likely has less overhead: 

However, this may not matter too much because the compiler may decide to perform this optimisation anyway[citation needed]. 

Your code doesn't fit your description Your code snipped returns the length of the last sequence of odd numbers – not the longest sequence of a ones! Let's see how we can fix it (including the aforementioned improvements): 

In a similar fashion you could return an error from , but we already know that we didn't accept any illegal instructions. Print error messages on and write their data to , the standard output stream, but you're also writing program output to via . To avoid mixing program output and error messages, you should write the latter to instead: 

You can then use another function to convert the returned byte array to a hexadecimal digit string (e. g. from How to convert a byte array to a hex string in Java? as CodeInChaos suggests). Or you can roll your own since it's so simple: 

Exit with an error status in case of an error Programs may convey information in their exit status. By convention the status 0 means “no error, everything performed according to your instructions”. Every other status value usually refers to an error condition but there is no general convention on what each value means. One attempt to conventionalize them can be found in the header. You could use it like this in your program: 

This will directly construct the DOM (sub-)tree that you're trying to describe in HTML. Respect the intent behind HTML tags is intended for text set in italic. However the use of “physical” formats in HTML is discouraged in favour of cascading styles (CSS). Use “logical” formats like or or the other suggested tags on the previously linked MDN page to designate your intent and format them with CSS (or trust the client web browser to use a sensible default if you care about intent but not the actual resulting typesetting). If none of the pre-defined intents match your case, use and annotate it with classes, then format it with CSS. 

hjpotters92’s answer is great for fixed separator strings. If the separators vary and one wants to join them with each subsequent match one can use the following two approaches, neither of which requires closures: 1 Generator function 

Assuming that you control over the value of the attribute, I suggest to store the reference chain as a list of attribute names. Then you can easily resolve the reference without having to resort to -like meta-programming. A reduction would be ideal like you mentioned. 

As a bonus, in C the macro typically expands to something like ; if you have warnings for potentially unsafe type conversions enabled ( for GCC), the compiler will notify you, if you try to assign to a pointer or to an integer, which helps to find potential errors. Use when you don't use string formatting 

Both and are pretty heavy-weighted but since you have such a small amount of possible items to go into the set you can just use an array: 

The improvements lies in the fact that the algorithm of can make an assumption about the size of the memory region to check while cannot. This could lead to a performance improvement. Use for boolean values The header declares boolean-like types. You can use them to express your intention for a boolean return value of : 

Characters vs. Bytes Hash algorithms usually operate on byte sequences, not on character sequences. The difference between the two is that bytes are a just bit octets without a canonical meaning while characters carry a semantic. To extract semantic from a sequence of bits or bit octets (i. e. bytes) one must interpret it, which requires an assumption about the encoding of that sequence. Since there are plenty of character encodings we cannot make a valid assumption here and we don't need to and shouldn't since hash algorithms operate on bytes anyway – at least those you mention and which are supported by . Read bytes directly When you extract bytes from , an implementation of which operates on bytes, you read exactly one line (according to the current character encoding) from a backed by and convert it back up bytes. Instead you should read the bytes directly and feed them to the instance. I'll use a separate method for that to decouple the stream digestions from the digest creation and output.