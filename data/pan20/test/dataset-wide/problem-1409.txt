I would also question if it is really required to return a . An might be sufficient and then you can get rid of the as well. This is somewhat dubious: 

Update: I don't know how it is in Java but in .NET is meant to return a short helpful description about the object largely for debugging and diagnostics. Dumping the entire list content is probably not very wise - imagine the list contains tens of thousands of entries. 

Some future speculation in case you are stuck with .NET 3.5 or earlier and want to stick with your implementation: If you are ever tempted to implement (to show the content in a UI for example) on your class then remember that the following implementation is broken (I have seen this more often than I'd like): 

Update: Turns out that enums generally don't implement . The best option in that case would probably be to allow the user to optionally pass in an defaulting to and again not impose any additional type restrictions. 

You have already named the variable - I'd say you don't gain much by initializing it via a the way you do it. Just saying would be good enough since it's quite clear what the 60 stands for. Actually, according to MSDN the is set in milliseconds as such your code is of by a factor of 1000 regarding the timeout (why the framework designers have not consistently used everywhere is a bit of a mystery to me). 

First, to re-iterate a point made in another answer: Making a helper class which has internal state is a bad idea. You lose a lot of flexibility, re-usability and increase testing pain and gain nothing from it. The major problem with a static class is: You can't easily mock it for unit testing. If you want to unit test something which uses random numbers it's very helpful to be able to feed it a known sequence of random numbers but with a static class you start adding code which is just used for testing and your tests become brittle if you forget to reset the global state to a known point. Calling is hardly much work - if you consider that a problem then maybe an OO language is the wrong choice. A static class with a state is effectively a singleton which is an anti-pattern. As such your question should not be "what are convincing reason to not use it" but rather "what are convincing reasons to use it". My other major point is: My very first thought when reading this was: Classic case of premature optimization. 

Property names like are completely useless as they in no way indicate the purpose of it's intended usage or what it represents. Given that it's probably bound to a radio button it means it's very likely some sort of option to chose from. My guess you could replace all those properties with a single enum property which states the option which has been chosen. At the very least all those properties should be renamed to something meaningful. You should move the comparison into a method on the like . Then your main loop becomes: 

Try to avoid generic s. A more specific exception is better because otherwise you force the caller to always catch all s when they might only want to deal with a very specific one. An might be more suited in your case. is not a very good name. Methods named like i'd expect to return the object as . would convey the intend better. The class owns a of . is and hence you should dispose of the s in the list. I was a bit confused by your usage of and how the whole stuff is put together so I searched a bit and found this MSDN page which your implementation seems to be very heavily based on. I'm not convinced this is the best way to go about it. Essentially it exports the report into a bunch of s which then get printed. In the end you have a whole set of class members which means that multiple calls to will probably yield strange results. I think the design can be changed so that neither the nor the list of streams would be required as class members but rather as transient members being passed around between functions. This would then allow you to: 

The advantage is that the filtering by specific entities is encapsulated into single classes with single responsibilities and you do not have to litter your code with all these filter interfaces. The concern that an entity can be filtered is now removed from the entity and kept separate which is always a good thing. The more an entity has to know what might happen to it the more complex your code structure will become. 

If you stick with your approach, you can get rid of the lock entirely by using InterlockedIncrement/Decrement on the counter. Reading an is atomic in C# so the spinning doesn't need locking (if Interlocked* is used to increment/decrement). Why is this a singleton? There is no reason for that and it's likely to make unit testing code which uses it a pain. Just create a barrier object and pass it to all tasks which need to by synchronized on it. Makes it more reusable as well. What if you have two groups of tasks which need to be synchronized independently? An approach which would get rid of the spinning is to use an event (although this require locking again) 

This should be extracted into a single common function which is called by each of the controller actions. This seems weird: 

You shouldn't name your classes which form the data structure you operate on according to the problem you are trying to solve. The classes should be named according to their function in the data structure. Thus should be simply . This also removes visual clutter when reading the code as the name is shorter yet conveys the same meaning. I'm not 100% sure why you build the list of children for each node in a separate data structure - it seems that this should be part of the class. It would also make for a slightly cleaner implementation of building of the children lists as each node only has to add itself to the children collection of its parent. Something along these lines: 

Yes, what you are doing is a problem. is not thread-safe and adding items from multiple threads can lead to data corruption (for example individual elements overwriting each other). You said that you don't care about the order of items inserted quickest fix is to use Another option is to the PLINQ extensions and use the extension of the . The code would look like this: 

Since is local to just the implementation file, it could be shortened to - this will make a few lines somewhat shorter. As mentioned in a comment: You already have a for in your header - don't put one in your implementation. In the variable to hold the return value is badly named as - it's returning the heap so the best way to name it is . returns in a whole range of scenarios. 

Effectively this means you only have to write as rules instead of so you saved yourself some typing work by reducing a case to a combination of the existing ones. Why does it matter? If you consider the problem as the business logic given provided by a customer then approx. 5sec after the deployment of your solution the customer will come back and say: "Ah yes, I forgot, if it's divisible by 3 and 5 you have to print FixBugz because some of our legacy applications which we can't change have a typo in their parsing code." Now instead of just changing into you have to change a whole bunch of implementation code and unit tests. In the end you have generalized a solution which might not fit the requirements because the requirements have changed (they always do). 

Update I think the main problem with your implementation is that the bucket size is fairly small (from testing it looks like you rarely get more than 6 or 7 collisions). Especially in buckets with more than 4 collisions your hash function actually throws away all hashes larger than 17 (which is you pass in from bucket) so your reduce your available bucket space. Also my suspicion is that in your hash function and should actually be, well, prime but does not yield a prime number. While reading up on hashing, a popular version seems to be Cuckoo Hashing which has a constant look up time (if you use two hash functions it will perform at most two lookups) and also a constant worst case insert time for an element (even if you have to rehash). I threw together a quick hack implementation which does not do re-hashing and just relies on the sets being big enough: 

If you create an object which is and you own it (your code determines the lifetime and ownership is not transferred to another entity) then you are required to dispose of it after you are finished using it. If the object you own is a class member then your class should become as well disposing of any members in its own method. 

seems sufficiently ugly to warrant a extension method (especially since I would suspect you might do this in other parts of your project): 

You could make a class similar to your class with a virtual however that's not a good idea for the same reasons why it's not a good idea for . Make virtual in all factories. Easy to forget. Create a marker interface and use that instead. Smells. 

I don't really see any benefit into introducing the local variable. Don't throw generic . In your case I'd use . Using specific exceptions gives more meaning to the error and also potentially allows the caller to catch some exceptions but not others. 

This way any user of you data structure doesn't know anything about the internals which in turn makes it easy to change the implementation without affecting anything else. Typedefing the struct in the header but only defining it in the implementation file is called an opaque type - a type where the consumer of the header does not know anything about the internals of it. 

While it's commendable for the (application) user experience to have 1 based indices, as a programer who might use this it will be confusing. Indices into containers like arrays and vectors are 0 based in C++ land. Deviating from the standard is bad because it is unexpected. Insert is broken. You will lose all items after the insert position ( points to nothing and now points to -> all elements starting from the old are now lost) 

It makes it a lot easier to figure out what each variable is meant to be used for (especially for others). 

From this I would suspect that the running process may eventually block after you have closed the input stream. There are a few options: 

While you could do without a public method having calling is semantically useful in case you can't use and need to release the lock explicitly. In this case the code will be clearer when you call rather than . The .NET stream classes do a similar thing (where calls ). Some things to consider: 

You have more than one race condition here: Since the expiration is done via asynchronous tasks you can cause problems even if the cache is used by one thread only (the continuation is most likely to be executed on a thread pool thread). So in it's current form the implementation is essentially broken and will cause random exceptions (depending on the usage patterns). To re-iterate the point which has already been made (since it's important): Because you derive from you have made it very hard (almost impossible) for yourself to actually fix the race conditions mentioned. Even if you protect your methods against race conditions you can't protect the methods because they are not (so you can't override them, you could hide them but that's rather ugly). All in all you've made it very easy to break the assumptions your class makes - classic case of leaky abstraction. It always irks me when classes are being designed to take some sort of time measure and the type is an integer type. .NET has a type - use it. Storing the expiration time as would also remove the need to convert it into one on every single call to one of get/set methods. If you absolutely don't want/can't use a then at least add a suffix to the name indicating the unit. Many timeouts in the .NET framework are specified in milliseconds - so using seconds is less intuitive. Regarding the topic: One of the rules you should always stick to is that if your class owns an object then it should also implement and dispose of the owned object. Doing anything else will get you into trouble in the long run. Your class owns objects which are hence you should implement . To quote MSDN: 

is a bit of a generic name (although I guess if you put it in a sensible namespace it might be ok). I'd consider renaming it to something like . From looking at the code it is not obvious what units the upload and download speeds are (apart from one comment). Consider abstracting it behind a class from which you can get any sensible transfer speed (e.g. KB/sec, MB/sec, MB/min, ...) or at least put the unit in the property name. 

I'd expect the to set these flags correctly. Then the only thing left is the keyword which should be simply passed as parameter and special cases handled in the calling function. This means we can now refactor it by moving the code into it's own function and call it in the appropriate places: