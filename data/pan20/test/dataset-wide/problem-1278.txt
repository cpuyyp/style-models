Check the text change Verify if the input contains a number Potentially change the state of the input (disable/turn red the input) Re-enable it. 

I think that your limit checking is a little obscure. Why are the constants defined in the constructor? They're related to your class, not to your constructor. If I were to be able to change the or someday, I'd need these constants to validate that my new values are still "legit". You might want to look at the Contract class in the .Net Framework. It offers functionalities that would be useful to you. Otherwise, if you don't want to use this, you should at least rename the method to something like or something close to this. Right now, isn't very self-explanatory. Comments like this : 

Methods/Properties headers in C# starts with . Try it in Visual Studio, you'll see that it's much better, plus it generates the header template for you! Also, you have too much comments. Usually, try to comment explaining why you did something, not how. That, people will figure it out quite easily. I can understand that you want method headers, but properties headers should rarely be longer than a few words and fields shouldn't be commented (not even headers) unless it it really important. Watch your indentation, some of your code is hard to look at because there's not enough spacing. In C#, braces are on a line each, which means : 

Now, notice something, I wasn't able to see which type was used in your code because of the keyword. is cool, but tools like Resharper indicate they should be used only when you can see which type is used ex : 

Now, if you don't want to override the equals, there's another solution for you. Use of constants Ex : 

The big problem I have with my code is the amount of I have. My code doesn't read well but I'm having a hard time figuring out how to do better.. 

Your method name is misleading. , in my opinion, would verify if your inputs are sorted. You should rethink the method's name to consider that there's the same increment between each values. If is set to , you can use this simple boolean expression to validate your numbers : 

Is it much clearer? Nope. What could we do to make it better? Nothing much, right? In such situations, add comments is a good thing to do. Basically, I think you need to think of better variable names and try to make the algorithm more apparent in your code, now it's kind of hidden behind your code. I know this sounds weird, but usually you should be able to read code once or twice and get what the algorithm does. Now, I can't. I know what you're doing because I know what method you employed, but if I was to read this without barely no mathematic background I'd struggle to understand what's happening. 

Btw, think about using instead of . It's just weird! Last comment, to reduce nesting you might want to revert your condition : 

Since your validators are stateless, I think you should initialize them in the constructor of the object (called only once) and make your validation list , this would save you the performance cost of creating validation instances everytime you create a instance. 

I use and in order to find the indexes of the but I keep another named to remove the words. The index to remove will be the same wether the is lowered or not. You also need to remove from in order not to find the same index again and again. I'm not sure if I'm clear in my explanations, it's been awhile since I reviewed something ;) If you don't understand something, don't hesitate to comment and I will answer as fast as I can. 

is usually bad. Consider returning a , because otherwise the one that launches the async task won't be able to "follow" it. If the "launcher" doesn't want to follow it, that's his problem, but you must give him the opportunity to do so. Instead of : 

To answer your second question, I believe it is better to use two separated actions to separate the use cases of when you will use Create vs. Update. Plus one day you might have different roles for adding and updating (it's a little hardcore but it could happen), you would want your actions to be marked with different authentication attributes (If you use MVC membership) 

I understand the point of having thin controllers, but I feel like this belongs in the controller. Imagine if your were in a separate project than your controllers and your services as well. Would you want to create a dependance between the DLL and the DLL? I don't think so. The view models are basically DTO, they shouldn't have access to your services. Though, I don't know if your service calls are expensive, but since you repeat some calls more than once, you might want to keep them in a variable. If they are expensive, you'll get a much better performance, if they ain't well... You'll get... less calls to your service! 

Field members are supposed to be , which means should be . Why? To easily differentiate them from the properties. You could make your fields , this way they can't be modifier afer they've been initialized in your constructor. (You could still Add/Remove/etc.. from the list, but the reference cannot be changed). Now, if I look at your code, I see that these lists are never used as lists. I mean that you never use methods/properties that are specific to the , only extension methods defined for . You know what that means? It means you should declare a instead of a in your fields. If you think you might want to alter these lists later, you should declare a . 

First of all, most (if not all) your comments are unnecessary. Your comments should explain how not why (apart from the head comments that resume the signature of the method) you do things. They're there to help your fellow developers to understand what happens, but don't forget that your code is its best documentation. Well written code won't need much comments. 

This is not a correct use of the UoW. A Unit of work "does two important things: first it maintains in-memory updates and second it sends these in-memory updates as one transaction to the database." [1] Your unit of work looks more like a Repository pattern, which takes care of hiding the implementation of the data access. In fact, the UoW should take care of the transaction part, and the Repository should take care of the data access, so at the moment both are mixed up in your class. The rest of your code looks pretty fine. 

You shouldn't throw Exception, create a custom Exception as proposed @Mat's Mug and throw that one instead, otherwise you might trap an exception you didn't want to trap (ex : )! I'd add that it is never good to have as much lines of comment as you have lines of code! Basically, comments shouldn't explain what you are doing but why you are doing it. If you need to explain what you are doing, something is wrong with your code. I think the only comment that is worth its place is this one 

I think you might have a performance problem with . Obviously, I'm not talking about the IL generation, we know that's not particularly fast. I'm talking about the statement. While I'm building a type, no one can grab a lazy type from the dictionary. That might become as problem as the IL generation is, as said above, kinda slow. I'd change : 

Now, I don't check if the dictionary contains the property name before trying to get it via the indexer. I don't think it's necessary in your case, since you have full control over what property is used and to which control it is bound, that shouldn't change during runtime. What if we wanted this code to be even nicer. We could extract a method to get the first error in the validation results!