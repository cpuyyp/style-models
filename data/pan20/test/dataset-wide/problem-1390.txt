Asynchronous multi-threaded processing In addition to the usual way of using an to start tasks asynchronously, Java 8 also gives you the class that automates and simplifies most of the manual handling one will need to do for both task processing and thread lifecycle management. In fact, there's already a handful of Google search results that it's worth your time paying attention to. :) Java 8 Time APIs Instead of the 'legacy' and classes for handling date/time formatting, there's the new APIs that you should consider using. For example: 

An ordinary imposes no such restriction, only a . If you had gone with a -based approach, at least it's still a passable, good-hearted attempt at a 'map' implementation that only relies on comparison, which is ok in itself. As it stands now, I'll be very cautious using it as a 'map'-like replacement. 

I suppose by advocating an OOP approach, you'll want your classes and methods to encapsulate your -based inner workings so that it's possible to swap them out for a 'real-world' solution, this will likely require the use of interfaces in addition. 

Finally, as suggested by @mariosangiorgio, you should over-ride too, and I'll leave you with this one weird tip: returns an , your is both an and used for testing equivalence in your method, so... implementation Inside your , you can consider using a conditional operator (i.e. ) to perform and return the calculation in one step. Without showing you the full code, here's something to start you off with: 

Ideally, the object should be passed to this method so that the method callers know what exact file is being opened here. edit: If you claim that the processing still tends to infinity, consider reworking your process: 

However, since you need to write the header and 'close' the end of the HTML document, you can rely on the terminal operation of a : 

Handling logic While I think it's helpful that the other answers are pointing you towards an -driven approach, for a beginner, I feel starting with basic comparison is... ok. I wouldn't change much here, but I'll suggest renaming your variable in to something like to stick to the convention you have followed elsewhere. On a related note to the previous section, since you shouldn't be checking for the as an operator here, you can safely drop the check. 

Don't have any comments on the math, but I can offer some suggestions regarding the code... Names and comments 

You can consider using types for your various ingredients, if you are fine with defining the 'universe' of ingredients first. 

I have taken the liberty to declare your file paths as constants outside of the method, again as a good practice. Also, I have opted to use a , which is buffered, so that I can make use of its method. Determining the student's details and ranking You are creating only one instance, and then repopulating its details for each input. Ideally, you should be creating a new one each time, so that they can all go into a in the future for further processing. Right now, you probably can settle for temporary variables in order to print them afterwards. Assuming we are sticking with your approach, you can hide the creation within its own method, e.g. . The idea is that given a instance, student details can be retrieved and a instance is returned: 

There's more elegant ways, although not necessarily more efficient. The common idiom for fiddling with this kind of linked list in C is to add one more layer of indirection and fiddle with pointers-to-node-pointers, like this: 

Okay, so what's this function doing? This queue has a maximum length?! That pretty much defeats the purpose of a linked list, which is basically the worst data structure imaginable except for the fact that it can grow unboundedly. If you know up front how big your data is (or will-ever-be), you should use a heap-allocated array instead. You'll end up using ~50% of the memory (because you no longer store the "next" pointers) and ~0% of the runtime (because pushing onto the queue no longer involves , and popping no longer involves ). Try writing up the array version and see how much faster it is. My bet is that the finished code will be half the number of lines, too. (Here's a generic ringbuffer using the technique, in 75 lines. Not that I'm holding this up as a shining example of C style, but it's exactly what you want except that it "auto-pops" old elements when full, whereas you let the queue keep growing "beyond full", which I don't really understand. Do you have a use case for "beyond-full" queues, or is that an accidental "misfeature" of your implementation?) 

For , you'll have to return an , which must remember the size of the array (or else retrieve it from something like or , but those are problematic because they're analogous to instead of . You don't want to destroy more items than the user provided). Fortunately you can partially specialize your template so that has that extra "size" member. (The STL's is also specialized for , but doesn't keep that explicit "size" member because doesn't need it. Instead, it's specialized to provide a different set of accessor operators: instead of and so on.) 

Nit: is technically the wrong name for a single dimension. Also, by capitalizing the template parameter, we've freed up the shorter name (or ) for the constexpr member variable. You never have to use a tediously long name like if you manage your naming real estate effectively! 

Here's the code showing why is worse than : if someone sees they're probably going to assume that represents an int (or at worst a ), and they're going to code accordingly, and their code simply will not work if you've used some other weird type. In other words, is widely recognized as a vocabulary type (a "ubiquitous type used throughout the internal interfaces of a program"), whereas is not generally recognized as such. Of course, might be used as a vocabulary type in your codebase; it all depends on your employer's coding style guide. But I would hope it's not, for sanity's sake (again refer back to the code in the Wandbox above). For another set of reasons that I mostly agree with, see Laurion Burchall's "unsigned considered harmful". Since you mentioned you've used Java, you might like this similarly titled blog post elsewhere, re Java, which makes some good points re "things C and C++ screwed up in their implementation of unsigned types." 

I've created the following Nix cron for daily and weekly scripts for a minimal Nginx server environment (as part of my larger script). The daily cronjob updates WordPress and brings back original permissions (that are changed by WordPress in its update). The weekly task clears accumilated WordPress cache, make local backups, and delete old backups. I wonder where this script could be shortened. 

I would like to have your opinion on the entire code as I might lack some security there (maybe I must delete OpenSSH, do some other stuff). 

Please review the following Bash script that uses to establish a "lightweight" Ubuntu-Nginx server environment mainly aimed to run small WordPress sites (about 5 plugins, about 25 webpages, about 25 images) on a cloud hosting platform. The heredocument sets aliases for personal scripts I already have and might use me later on. 

The following code is aimed to establish a WSL based LAMP environment. This is instead XAMPP or WAMPP based LAMP environment which doesn't allow Bash. The script includes a cat heredocument called "AWSM" (Apache Webapp Substrate Maker) that is used to make an Apache conf file for the app, as well as a mySQL user and DB with the same name (you can then run it with your domain as an argument (for example, the domain of the actual site your run in WSL as a test version): 

I use a Ubuntu 16.04 Nginx server environment with phpmyadmin (PMA). All my ports are closed besides 22, 25, 80, 443, 9000 (for PHP-FPM). A common criticism of the good software (PMA) as of 2018, is that it doesn't have good defense from Brute Force Attacks (BFAs). There are different common ways to cope with this and I admit I dislike all of them: 

I run it this way , or with a Bash alias . Note: stands for document root, which is in my case and defined in . I'd like to know what you think of the code I've written (especially, do you see any way to shorten it)?. 

Update I should clarify that I don't have XAMPP/WAMP or even individual Apache or PHP on Windows outside of WSL; I aim to have only 1 LAMP stack in my Windows, inside WSL. Besides having a fully functional WSL LAMP stack on Windows, the end state is to be able to access it from in any Windows browser so I could easily test the sites and access PHPmyadmin locally. Also, anyone is more than welcome to contribute directly in Github 

I found myself another way which is personal and comfortable (I don't recommend any company with customers to use this way in the form I'll describe below): SSH tunneling through port 80 to port 80 via Putty/OpenSSH, and use PMA securely and temporarily for 2 hours in a session (It is extremely unlikely that anyone could BFA PMA with a decent varied password in just 2 hours). Each time I want to use PMA I run this code: 

Instead of , I would have written just , as it's less likely to be misunderstood by the reader (e.g. by forgetting whether means or ). I think the only reason to use the longer mnemonics is if you're attaching memory orders to them, and I'm pleased to see that you've removed a lot of the wrong-memory-order code from this new version. 

to eliminate the named concepts etc. I'm ambivalent as to whether this would be an improvement. (It continues to suffer from the "Write Everything Twice" problem that infects most of modern C++; cf. the repetition in your original question.) 

It is unclear to me whether is supposed to be measured in kilometers, or meters, or what. (Megameters would make the math come out right, I suppose, but that just seems crazy.) I strongly recommend that any time you're dealing with measurements or other "unit-ful" data, you encode the expected units into the variable name, unless the expected units are already encoded in the variable's type. For example: 

is highly likely to be optimized into an infinite loop by any modern compiler, since the compiler can see that is a loop invariant — there is no code in the body of the loop that could conceivably change the status of the queue, so there's no point in testing the condition every time through the loop. If you want the compiler to know that there's some other thread participating in this loop, you'll have to explicitly tell the compiler that, via e.g. waiting on a condition variable. 

needs to be a member function, or else it needs to take the mutex , because otherwise the client code could call at the same time as some other thread is calling and suddenly you've got a race condition. However, if you simply slap a mutex lock around the body of , you'll find that and both deadlock, because each of them calls while the mutex is already (still) locked. 

This line invokes undefined behavior, because you aren't allowed to call on an incomplete type (and certainly not on ). Both GCC and Clang warn on this line: 

This is a version of C++17 that handles arbitrary functions to do the replacement, instead of using 's weird minigame language (, , and ). Also, I made it take instead of ; that's more to see if people have opinions on than for any practical reason. :) (The standard C++17 regex library is not aware of the existence of .) 

However, your code doesn't really match any common TMP patterns — which is probably just because you're noodling around, learning, instead of trying to solve a specific problem. If you just wanted to produce the same output with less code, you would do this: 

It's weird that you write function calls as instead of . It's also weird that you write instead of . 

Finally, the code is clean enough to notice that what we're really doing here is transforming a string character-by-character: for each character in the input , we produce a corresponding character in the output . So we can use a comprehension to get the same result directly, with no intermediate state: