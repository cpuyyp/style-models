Currently I cannot provide any specific suggestions on the existing code in good conscience. This is because it would be symptom fighting if I suggest something like this: 

Maybe you find a better name for such generics like "line" or "lines" The categories "client", "process" and "device" could also be held in an enum. That would express those categories as central elements of your current algorithm and maybe future algorithms. 

Solution 3 (OO) This is an solution that shows how the responsibilities are cut in the OO. I guess this is the most verbose one for the given problem. 

Test The only thing to determine thread-safety is to acknowledge that your monitor works. All other things can be tested without considering concurrency. To determine if a monitor is working is to "attack" the critical code fragments. Write access As mentioned above following statements are critical: 

You should not distorte semantics. student.getID() != QUIT is semantically strange. My suggestion is to check for QUIT BEFORE creating a Student You should not reuse of the Student-object for different Students. Technically this is ok but it's not object-oriented and not semantically correct either Try-catch with resources is the proper approach handling File I/O Errors I do not suggest to hold the files open during long user input. My way would be to have the files open when writing is neccessary and closed during user input. 

Monitor I suggest to think about your monitor. As every method is working with the "head" variable every method should be synchronized. Either you make all methods "synchronized" or you introduce an internal lock object and use the "synchronized-block" construct in each method. If you do so you do not even need an "AtomicReference". Synchronisation micro management For the sake of clarity: Of course there may be several solutions with "micro-managed concurrency mechanisms" (volatile, several implementations of sets, maps, lists, stacks and queues) and they may be faster. But my way is to have the monitor clearly and transparently defined. And this transparency omits any concurrency elements that are different to the synchronized keyword. You should only left this path if you really need whatever you want to achieve (mostly performance). If you do so then you will open Pandora's box and you have to handle it. And what is even worse your collegues have to handle and maintain it too. size-method Your size-method is good. Either you are iterating or you formulate a recursive algorithm. As Java has no "tail recursion optimisation" and the stack count can exceed the JVM stack I would go for the iteration. Generics Try to get your Generics right and do not suppress "raw type warnings" as they are important indicators of design flaws. Code 

LogService The LogService will delegate all public calls to the state pattern. It provides a queue that will buffer log messages. Initially the LogService is in the state "StateStopped". You see that we changed from a blocking queue to a normal queue that is not thread-safe. But that is ok as the LogService serves as a monitor around it beside the other two variables loggerThread and state. LogTarget may be access concurrently but this is not our responsibility AND we can only ensure the correct implementation by convention. 

There are some things to adress. "synchronized" Like you recognized: Using synchronized variants of certain maps or set classes will not get you away from the burden to define a proper "monitor". Often these variants are not even neccessary to solve the problem so that the synchronization elements will only reduce performance without participating within the synchronisation neccessity. A monitor is an area of code execution that has some assertions to the behaviour of the code under concurrency situations. The simplest situation would be "restrict access to the monitor to only one thread". So putting a synchronized-keyword "somewhere" will not solve the problem until your monitor is properly defined. Responsibilities You have to be clear about what are critical code fragments that should properly behave under concurrency. I do not want to say that I am THE reference but for me it took a while to interprete your code and identify what it is all about. Even (I would say especially) in concurrency we should be aware of clear responsibilities. Busy waiting Some other thing is "busy waiting" (while (true)). I reject those constructs. You should always provide a loop exit AND a mechanism to avoid busy waiting. Usecase As far as I understood your code you have a stream of elements from multiple arbitrary sources to print out or do whatever you want to do with it. It seems to me like a "Buffer" but currently I am not that sure about it. Abstraction from element sources Currently the elements of the stream come from 2 sources: 

You see that our solutions do not differ in structure. Only the algorithm to generate a new permutation is extracted in a class and reformulated. I unpacked this riddle (I somehow liked this riddle) and I want to provide a solution that can use either your algorithm or mine. But finally they converged against the same interface. I expected that as I know there is only one structure that fits the problem best. We may not have found it but both solutions have a "meeting" where the structure is mostly the same AND the things that may be different can work under the same abstraction. Sure, most structure was provided by the interfaces "Iterable" and "Iterator" but I found it interesting how the algorithms are interchangeable. So first of all the interface for our algorithms: 

First some general information. Your code currently solves a specific problem of the "object relational impedance mismatch" in a specific way. Consider to minimize the effort and complexity to handle this mismatch by using an object-relational mapping framework. Here is the thing: Every single step of code improvement code will lead towards an implementation of an more generalized object-relational mapper anyway. But that will be a hard way to go. Every answer given will be one of those: 

There is only one concern for me: you should not allow to instantiate the object with max elements below 0 (IllegalArgumentException ). Therefore a proper handling for this situation in your methods has to be made to avoid a neverending blocking. I suggest to return null. Expecting a timout for your poll-method may be beneficial in several situations. Concurrent implementations of the Java API do define both: a non-argument poll-method and one with a timeout. But I do not see this as mandatory. Some developers will suggest to make synchronization intransparent to the user of your class introducing an internal lock object and mention thread-safety in JavaDoc. They argue with "defensive programming" to prevent deadlocks. My personal opinion to that: You send the wrong message to the using developer. Don't get me wrong: Preventing deadlocks is important. But it is more important to know what to do when. That is known as competence. Preventing others to make mistakes is ok. That can be done in several ways. But others to allow a lack of competence is exactly the message you would send. You would try to solve a potential future errors that are not your business. On the other side you allow misusage of objects without habing the other force to correct thhis. My way is: If someone is doing strange things with objects he doesn't own he either should know exactly what he is doing or handle occuring errors and deadlocks. You should know that this is how the majority of developers will NOT argue. 

I suggest to have ready parsed parameters that will be given to the function and not let the function itself parse its parameters. Separate following concerns: 

Currently you are not able to execute a function without parsing. Decoupling helps in different ways like in testing or reusablitity. Example structure for parsing I only will provide an example for parsing as this is often the most complex issue. 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

Do not make the builder pattern return mutable objects, always return new objects. The "builder" pattern is meant to "build" something not to update something Only build transient, never involve persistence in the builder pattern Have a proper design for CRUD-Operations for your persistent objects (business objects??) and well defined responsibilities Distinguish between proposal, creator/updater/deleter and result 

Semantic mismatch in Constants You are mixing semantics in the class Constants. On one hand you enumerate allowed input parameters on the other hand you enumerate allowed characters. They will be changed on different reasons. Separate them into two classes (Single responsibility principle) Semantic encapsulation Tie together what belongs together. Connect the allowed characters to their label. Object vs Class Favor objects over classes as they are more flexible. They can be extended and mocked. That useful if you want to put them under test or reuse them. Argument preparation Try to prepare all the input parameters as early as possible so further algorithms are able to work on proper typed values. Invalid parameter The output of "Invalid parameter" is redundant by three. Remove redundancy by extracting it to a method and/or provide a better exception handling. First argument cannot be number This information has no more value than "Invalid parameter". Remove it. Case specific adaption of check concept and parsing On one hand you are checking towards (!args[i + 1].matches("^\d+$")) on the other hand you are checking backwards (!args[i - 1].equals("-length")). Try to establish a concept where you are only going only one direction. Insufficient check Once you determined that a parameter only contains digit you do not check this value to the end as this digit chain may not be a valid Integer. You pass around a half checked value. Parameter reusage Do not reuse the parameters passed in. You are removing "-" instead of using well defined labels. Duplicate checks You are checking "-length" twice. Try to consolidate this check with proper parsing. Exception handling Do not return null as the indicator. Throw an exception as soon as you identified a problem. General Parsing is a tricky thing. To be flexible in Parsing you need to build up structure and/or generic algorithm. Things will become very complicated as the parameters have different natures. To handle every state with a monolithic if-clause is hard. The example I will provide adresses some things I mentioned. But the real flexibility you will only gain with library support and/or a state machine. The solution I provide will go only with no library support, little generic and lots of structure. Code Structures for allowed chars 

No null checks You should not check for null input values. Semantically you cannot dermine a proper return value. So if at least one parameter is null returning true would be as valid as return false even false will often be more beneficial. So the return value will be more or less a convention than a correct answer. My suggestion is to not expect null as a parameter. You method signature says "give me a String" so the caller has to give you a String. This is the least the caller should do passing a value of the propert type as null can be of ANY type as seen here: 

Simply said: You mastered the decorator pattern. But: You have a misleading semantic. The application may be proper, but the usage ist not beneficial. Any pattern identified has its inherent semantic and you have to analyze if the pattern matches the semantic you want to apply it on. It can even be, that there is nothing like a pattern. In your case I would consider not to use a decorator pattern. I Think you have only simple associations. 

Semantic of methods The implementation or the signature of the method "int getCount(String term);" does not make sense. Either you delegate the parameter "term" to the search algorithm with a stateless implementation or you omit it and have a stateful implementation. In the last case your "term" should be given to the constructor. I prefer a stateless implementation and all further comments are related to that. Programming using interfaces You are not using the interface "WordSearch". The assigment 

permutate eleminate not permitted steps eliminate already tried steps choose one step if available register step as tried check if final state is reached, yes -> done, no -> 1. return to previous step if no further step is available if no previous step is available problem is not solvable 

I do not recommend this. Any pending or working thread will be aborted. If this is your intention then you have no well-defined shutdown as the threads may be in an arbitrary state (writing to harddisk, communicating with remote services etc.). You will also hide programming errors if some threads have corrupt shutdown mechanisms. So make sure to notify running threads to shutdown if you want to exit the program. The following Swing configuration for a frame will disassamble the UI and exits the JVM if no other frame exists: 

Overall I think it is a good solution. Exception handling I think getIds()-method cannot handle exceptions properly in the context of any application. Currently it makes the result look like as nothing has happened even an exception is thrown. I do not think that callers can make valid assumptions on the returned value so I suggest to encapsulate the general Exception into a RuntimeException (or some of your own). The caller of the method should know if the result is valid. If you want the caller continue to process with partial results then you can make your own exception containing the information received so far. But to abstract from errors is dangerous. The decision of throwing exceptions is as important as catching, rethrowing, wrapping, logging and handle them. If you throw an exception you do it because you want to indicate that the assumptions a method has are not met so it cannot fulfill its work. If you want to rethrow an exception the purpose mostly is to intercept information. If you wrap an exception you want to