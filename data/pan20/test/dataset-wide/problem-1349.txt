is misleading because can also fail if, for example, the file exists but you have no reading permissions for it. 

These numbers have no, I repeat, no business to be where they are right now. This kind of one-class-does-everything scheme that your code follows is going to fall on your feet sooner or later, but rather sooner. Let us just imagine you keep working on the game and add more and more functionality. As of right now, you have about two separate default values per functionality, i.e. pairs such as and , and etc. Now imagine you add some functionality to your game that adds about five different new entities. That means about 10 new constants on average, just in this class! I hope you realize that this is not sustainable. Even now, there is no way to tell which constant belongs to which actual class besides guessing by name. In a year from now, will you still know what class corresponds to, or ? Maybe, but it is more than likely that you will forget some of these. Furthermore, if someone else ever has to or wants to read your source code, they will first be massively stumped, then irritated. So what can you do about it? Take a serializer-based approach. Usually, when you are writing simple game data, you will have objects corresponding to the current state you want to save. The solution I propose is to approach the classes of those objects and insert a method that writes an object's contents to an . To actually save, you just call serialize in order on all objects that need to be preserved. The second step is, of course, to add a similar method that takes an and creates an object from the values read. You then have a file parser read in the file, determine the block sizes, and call those deserializer methods. The big upside of this solution is that it is relatively easy to implement while allowing you to encapsulate functionality away where it belongs, not in a monster class like you currently have. The downside is that the separation of concerns is still somewhat suboptimal, since you now have what are basically parser methods in game state classes. This can be somewhat mitigated through use of the factory design pattern, for example. Furthermore, this method can become messy if the complexity of the savefile and the game as a whole grows too large, but I am assuming that that is not the case for your project (and if it is, you will have to put a lot of thought in how to handle this well, anyway). Other Tips and Tricks 

Where are your includes? Your first file is missing the includes for and , your second file for , , whatever header belongs to, the header for , for and so on and so forth. It's a miracle that your code even compiles successfully. Everything from standard headers must be prefixed with . This applies to all the types as well as to , , etc. is superfluous; will do fine. This is not C. Why do you bother with , and the like? This is C++, and it has a standard library that offers a great range of very handy tools for such things, such as and . Don't reinvent the wheel. Again, this is not C. Don't use , use . This is not C. Why does have a followed by nothing? Remove that. Why are all of 's member variables public? This violates data encapsulation. Instead, provide getters and setters for data that should be accessible to the public. To answer the second question of yours: Yes, it is perfectly possible here to use and you should definitely opt to do so. First of all, provides a method named which allows access to the underlying array. Secondly, there is also , which you should prefer in almost all cases. 

Do not try to do too much on one line. Constructs such as are difficult to read, difficult to parse and prone to errors. Instead, let each control statement have its own block, and do not abuse the comma operator to do completely unrelated things. For example, the line I mentioned should rather be something like 

Much better, isn't it? Actually, seeing that is only ever one character long, why not make it type instead and use the convenience of a switch statement? 

is a very inefficient function. First of all, you calling every time, which you should not do because there is absolutely not point to it and you are actually making your random number generator partly useless. Secondly, you are doing string operations which may imply heap allocations. This also leads you on the path of int-to-string-conversions, which is not good: You are basically taking the route number to string to number, which is two conversions too much, one of which is actually a loop on single digits. Instead, you would likely want some kind of shift-or operation to generate large random numbers more efficiently. 

is a reference to a -object. References as class members are rare and very dangerous, so let's pull out our alarm lights and go investigate whether the reference is justified and used correctly: 

I hate to break it to you, but is not really a , at least not in the sense that you define it right now. The problem is this: If you have a base class, and you choose to derive from it, you should have a (meaningful) implementation for everything the base class requires you to implement. It takes no expert to see that this currently is not the case at all. But where is the actual problem? One issue is the interface of , in particular what methods it requires: 

Find the next word boundary Allocate memory according to the distance between and the word boundary found in 1. Copy the word into the newly allocated memory 

[Note: Java makes no guarantees about the time and space complexity of methods. Thus, could, in theory, also have a much worse time and space complexity if not implemented well. I assumed that it runs in O(n) (which is the best case) when matching on a single char only. This fact, of course, makes the second approach even worse.] 

Order your s. The generally recommended order is: first the header the current file is implementing (if any), then includes from the same project you're working on, then includes from other projects and libraries and finally standard library headers. Also, you should sort the headers alphabetically inside their groups (i.e. sort all std headers, but keep them last etc.). If you had followed the advice from point 6, you would have quickly realized that is actually missing an ! You interface to users of your class is meagre. The only way you provide to access the current game state is through , which is not exactly handy if I want to do something with the data other than writing its string representation. Since you have a very convenient representation of your grid already, you should at the very least offer a way to access the current grid directly. You can omit from since the compiler adds it anyway. 

is dangerous for containers which offer RandomAccessIterators, but aren't contiguous. In particular, invokes undefined behavior if and do not belong to the same memory area, which they might if the underlying container is not contiguous (also, sometimes is overwritten, which can cause a lot of problems on its own). To prepare against this, I would advise you to rename to or something in that line of wording. You are probably aware of this already, but your code is not really portable. For one, there is , which is a gcc builtin. Also, is a type from , which is a posix header and might not be available on non-posix-conformant operating systems (also, you do currently not include this header, which is a bug). is easily replaceable by in most cases, but if you care for that much of correctness, you could also write something like and use that instead. For , if the optimization value you get by using it is really that important for you, you should wrap it in some compiler identifying macro. If it is not important (which is probably the case), you could do a variety of things, for example replace it with a expression or just return a default value. is a very confusing template parameter name, at least to me. I would expect it to stand for "random number generator", which is not fitting here. Choosing a different name would likely be beneficial here. You should consider passing s instead of separate iterators. This makes clear that one begin- and one end-iterator always belong together, and helps cleaning up the parameters of your functions. . Please don't. This code is just ugly. The reason is that 1) you are relying on implicit conversion for all your values (why not write instead?) and 2) there is no reason here to use at all. Stick to integer types unless you do something that actually requires floating point features. 

First of all, this is remarkably good and clean code! Nevertheless, I do have some things to nitpick on: Code Formatting Let's talk about line length. As of right now, you have a (physical) line in your program weighing in at a whopping 160 characters. First off all, this is easily enough to make the code blocks here on code review have a horizontal scrollbar, which is impractical and not very beautiful. Second of all, 160 chars is too much for many of us to handle in a typical development environment. Maybe you have a nice, big monitor or two which allow having open four files simultaneously at a line width of 200 or more. However, I certainly don't, and making me work with your program on my 14" diagonal laptop with about 200 characters line width for the whole screen is not very accommodating of you. Now, the correct maximal line width has been a matter of ongoing debate. I'm an advocate of the good old 80 characters standard, but I'd argue that anything around 100 characters is fine. However, in my opinion, 160 is not; and you are likely to upset some people by sticking to it. Another issue I see is horizontal spacing. For example, let's take a look at two lines from your code: 

Notice that, instead of passing separately, now points to the beginning of the next word. Don't Cast It is unnecessary and even discouraged because it clutters your code with casts and adds no further information. Omit The standard specifies that is always 1. Although some people advocate for it because it adds some information to your code, the knowledge that the size of is one is so widespread that I wouldn't recommend writing it. Memory Leaks In , you are getting new words by using repeatedly in a -loop whilst not freeing the current word after each iteration, instead only freeing the very last word at the end of the program. You should add a at the end of said loop. Iterating Over A String Writing