The issue is that the rules state that if a card has a sub-type, that sub-type must be valid for the given (super)type. Since not all types have sub-types in this model, you need to have a many to many association between the list of types and individual cards. At the same time, you need to have a many to many association between the list of possible sub-types and individual cards. You are in a bit of a relational model rock and hard place. It depends on how you want to optimize your model. You can optimize for storage or you can optimize for retrieval. Optimizing for Storage: You can eliminate the redundancy by linking types without sub-types directly to cards. When you have a type that has sub-types, don't link the type, link the sub-type instead. This avoids redundancy and the potential inconsistency of parents and children contradicting each other. It sucks for data retrieval, however. Optimizing for Retrieval: You could instead link all types and sub-types (when applicable) to cards and then you have redundancy to manage - either with triggers or some other kind of application logic. There is one more option you could try, which is a kind of combination approach and which manages to push the complexity into a more rarely used corner of your application. In the third way, you collapse type and sub-type into a single table with an involuted relationship (self-reference). Now when you assign a type or sub-type it automatically implies any parents of that thing. Given the rules requirement for enforcing membership in the type before allowing membership in a sub-type, I would be inclined to just live with the redundancy. You need a business rule that says you can't have the sub-type if you don't have the type. That's the kind of business rule that needs to be in code anyway. 

contains the values for each type of generic attribute. defines the list of generic attributes which apply to a given type of device (these are the . This lets you control which attributes need to be filled out for a device while letting devices of different type have different lists of attributes. It also makes it easy for you to compare across devices by lining their attributes up against one-another. 

Another method is to place all attributes in a single table, and then use declarative constraints and/or triggers and/or application logic to enforce sub-type specific business rules. In this case: 

If you wanted to enforce this business rule through application logic instead of through declarative constraints in the database, you could use the first schema noted above instead. 

It isn't too hard to create table-driven access rules if you can base the rules on something that is in the data already, like a country code. You want to beware the power of multiplication. Don't try to create access rules based on the cross-product of two or three or more factors. The management of such a rule set will quickly become impractical due to the shear amount of data. Instead, keep each access rule separate (i.e. country, department) and treat each as a gate that the user has to get through before they get access. This will be a bit of work when setting up your data access code, but it is the best way to operate the system in the long term. 

The motivation for piling every kind of address into a single table is usually a misinterpretation and misapplication of the notion of code reuse. People can make the mistake of assuming that because you have two entities with some common set of attributes, that those attributes belong in their own table. Sometimes entities have similar or identical columns coincidentally. One wouldn't create a table for every or or in your database, at least I hope one wouldn't be tempted to do this. Some people mistakenly refer to all instances of removing columns out to their own table as normalisation. Normalisation involves removing columns to their own tables, but not every instance of removing columns in this way is actually normalisation. Normalisation prescribes very specific reasons for removing columns from a table. If none of these reasons are applicable then you aren't normalising you're just making things complicated. You have two correct ways of thinking about this: Either your addresses all belong in one pile because you have an entity super-type that incorporates all of the common features of several entity subtypes, including addresses, - or - your addresses belong in separate piles (tables) according to each kind of thing that has an address and you write your procedural code against an IAddress interface which is implemented for each address table. If you actually have an entity super-type, say which has subtypes like , , and so forth, then having an table that is a child of is a legitimate approach. It may even be a valuable approach if there is significant overlap between your customers, vendors, employees (or whatever you're tracking) because you can change addresses once instead of in multiple locations when a legal entity moves. On the other hand, if you don't have such a super-type, then you are going to face the problems pointed out by Richard Tallent. If you keep your addresses in different tables according to what type of entity owns the address, then you can still achieve code reuse, assuming the language you are using supports interfaces. As an aside: tvCa pointed out in a comment that addresses may be stored as columns rather than as rows in a separate table. That will depend largely on how many addresses you need for each entity. If you are tracking two addresses (physical, mailing) or if you are storing address history then go with an address table. If you only store one address per addressee, then a separate table is likely overkill. 

The short answer is "no." Entity relationship diagrams can be used to show constraints based on the relationships between entities. However, the particular constraint you want to show (that bookings do not overlap in time) is a constraint between rows in the same table, not between two or more tables. The only single table constraint that can be illustrated in most common entity relationship diagrams is uniqueness, since ER diagrams can illustrate a primary key. 

Your table just needs a simple foreign key to your table and your table just needs a simple foreign key to your table. This works because each sample record needs a test record and each test needs a patient. If you delete a patient, their tests must be cascade deleted. If you delete a test its samples must be cascade deleted. Therefore you don't need in the table. All you need is to declare cascade deletion on your foreign keys, like so... 

The PK of your department table is not . The column is an attribute of a table that you have not defined, since it is functionally dependent on the . The PK of your department table is . Primary keys don't have to be integers. Note: If your HR department creates departments with the same name, that is going to land you back in hot water. You might need to create a composite primary key of and . This could still lead to trouble if your HR department can't be trained to keep department names unique within managers. Excel is not a good data source for being able to enforce constraints.