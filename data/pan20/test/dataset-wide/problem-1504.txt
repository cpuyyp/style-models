You should use a switch statement, that will at least be easier to extend and maintain. The switch statement will clean up the code by removing all of the else if statements. The code doesn't need enclosing blocks for multiple statements. The switch statement only shows one condition although it tests for all the conditions listed by the cases. To add a new condition rather than adding a new statement all you need to add is a new case statement. The statement is needed in this particular case to move on to the next iteration of the loop. It is possible to flow through multiple cases if the statement is not there. The link above shows an example of flowing through multiple cases without a statement as well as the normal mode. Switch statements are common to C, C++, VBA and some other languages as well as Java. Here is the code re-written using a switch statement. 

Enum Conversions It's not clear why the enum and the enum are created. The implementation in syslog.h is pretty clear. If you absolutely have to convert from the macros in syslog.h then you might consider using std::map which is another of the C++ container types. The std::map container class can be used to map integers to strings, integers to other integers, and integers to functions. It can also map other things to each other. The values in syslog.h have been designed so that a single byte or word can be used to test if they are enabled or not. This is a space saving feature that one needs when doing embedded programming. 

The variable type size_t is preferred over int for indexing in containers. Container.size() returns size_t and using int generates warning messages. Don't Repeat Yourself This code repeats at least 3 times: 

Welcome to code review. Nice first question! Global Variables xReprisal provides a good answer. The first 2 bullets are very good advice, I might have switched the order, You should avoid global variables as much as possible. In more formal programming languages such as C, C++, C# and Java they should be avoided completely. Global variables make a program very easy to break and very hard to debug. In very large programs it is possible that there can be global variables with the same name used for completely different purposes. Readability and Maintainability The code is already very readable and maintainable, but there are a few inconsistencies in the style. Maintain the same indentation for all code This code is indented differently than all of the other code: 

The second function that might be of use would be a that finds if there are values that meet the proper conditions. 

To optimize the code create a copy of the array and use qsort() to sort the values in the copy. Find the dominator using the sorted array, then find the indexes using the dominator value. I don't know if this is a result of how you entered the code, but the following line of code should be 2 lines of code: 

@chux and @coderodde did a good job of covering the issues. The function free() is being used correctly and it is deleting the memory. The list in the implementation can't be sorted, because the nodes can't be inserted in the middle of the list. The implementation needs a general function and a general function. The functions currently in the implementation handle the edge cases or special cases, they don't handle all cases of insertion or deletion. Inserting into the middle or deleting from the middle requires more interesting logic that will keep the linked list intact. 

To make it easier to use the code you might want to have comments at the top of the file that the user can copy and paste rather than having the macros. 

Functions in Main.cpp: If you reverse the order of pause() and main() in Main.cpp you don't need the function prototype of void pause(); prior to main(). Having main() as the last function in the file is fairly common for this reason. In the past on certain operating systems, pause(); has been a system call. I would avoid it's use, although the system call did return int so the signature is different. It also isn't the most descriptive name you could give this function. 

It might be better to write a function that takes an input and returns a string output. It might also be better to use std::getline(std::string) In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns, replacing them with abstractions; and several copies of the same data, using data normalization to avoid redundancy. Generally when there is repeating code in a software module it indicates that a function should be written to contain that code or a loop should be written to perform the repetition. When code repeats in different functions it becomes a maintenance problem. Someone can fix the code in one location and miss it in another location. The solution to this is to write a function for the code that repeats. Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

Note: The code above would be more efficient if you had an array of color strings and indexed into the the array using randColor as follows: 

The code in doesn't do any error checking for failure of malloc, rather than check in my_malloc it might be better to check in main which would be more realistic. The code calls my_free() without checking that the memory was actually allocated. This could cause any application to crash. This code assumes that only one application is running, in embedded programming where memory is a precious and limited resource this might be a shared library that controls all free memory in the system. There is no consideration here for MT or MP. Limit Code Complexity, Think About the SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

The variable x needs to be one greater than the length because --x is tested at the top of the loop. 

Not only does it make the function shorter, but indexing into the array is faster than the switch statement. @MegaTom is correct, this code would be better using enums or named constants. The string compares are much less efficient that integer compares. Multiple Statements on a Line To make future modifications easier, there should never be multiple statements on a single line. Let's say some code needed to be added to each case in the switch statement. Each of the cases in the switch statement would then be need to be broken into multiple lines which makes the edit more complex, and can create typos during the edit. It is much easier to just add another statement by adding a single line, rather than trying to add it to a single line. 

The cs50 header file may define get_string(), however, some students may have had problems using it. It might be better to use the common C I/O fgets() or getline(), these should be available on all systems. You can write your own get_string() using either one of these functions. Initialize Variables on Separate Lines It is more readable and easier to maintain if variables are initialized on separate lines. The code contains 

This would be pretty good code in PHP4, but PHP has become more object oriented. Implement this code as a class. A class gets you multiple benefits 

A collision is when 2 different functions have the same name, the same argument types and a similar functionality (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionality of a class such as std::vector or std::stack. Namespaces allow these constructs to be overridden. The use of the programming statement: 

Drupal 7 replaced the Drupal 6 procedural interface with an object oriented interface. Several of the result interfaces are discussed here. They didn't exactly remove , they put it into the object oriented interface. You can use your while loop with 

Complex Functions It might be easier to understand, debug and modify the function if it was broken up into sub-functions following the Single Responsibility Principle mentioned above. 

Just pass in the lock, the address and the value to a function. Code quality is sometimes measured in errors per lines of code. The less code there is, the less the possible number of errors or bugs. Possible Performance Optimization The use of may be slowing the program down. It might be better to use '\n' in most cases. flushes the output buffer. Flushing the output buffer consumes time and is generally not necessary. Portability This may not matter in your particular use case. Because of the choice of functions the code uses, this code can't port easily to other computers. The address constants may differ on other systems as well. 

This does impact readability and maintainability so it should not be used unless the optimizing compiler doesn't do it for you. Testing for equivalency of floating points is to be discouraged because of rounding errors (floating point errors). Variable names and constants should be longer and clearer, sZ => MatrixSize. 

The code is too complex because you're dealing with too many classes in one file. Because Visual Studio creates the necessary structure to build multiple files into a DLL or an executable image, you shouldn't create all your classes in a single file. If the class can be used in other projects you are dragging too many things with it. Rather than creating an inner class, you can use an to provide the public methods. Visual Studio will make creating the very quick and easy. The will hide the structure of the class. From the looks of things you can create a class called LogFile and errorLogFile and syncLogFile can be instances of that class. The LogFile class should be in another source code file. 

If 320 and 240 are screen size, it would definitely be easier to modify the code in the future if symbolic constants are used, then the edit would only need to modify 2 lines in a header file. There are 2 constants defined in stdlib.h and stdlib, these are and . These make more readable rather than return 0, return EXIT_SUCCESS or EXIT_FAILURE from main, this will also allow error handling to be added at some point in the future. Global Variables While the global variable ANTS seems to be only in game.c it could be modified in any file because of the way it is declared. If it should only be modified in game.c then it should be declared as which would limit the scope to only game.c. It would be even better if ANTS was declared within main and passed by reference or value to the functions that need it. Using global variables can make it very difficult to write correct code and to debug. The ANTS variable can be changed anywhere in the program and as more lines of code and files are added it becomes very difficult to find where it is modified. Because the scope of ANTS is program wide NUM_ANTS and probably NUM_ROCKS should be moved to the basics.h header file. 

The use of parens is supported for backwards compatibility on some C++ compilers, however, it is obsolete. The two other answers concerns about the DFS() function are valid, you can find a fast working Breath First Search recursive implementation in the KnightMovesImplementation.cpp file, function in this question. 

If you use this number often, it makes it easier to change the value by just changing it where you define the constant. It also makes the code easier to read. The standard for symbolic constants in C and C++ is all caps with '_' between words. Function Names: Underscore in function names is a lot less common than it used to be, Camel Case is more common 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and stackoverflow question. Code Reuse One of the major goals of object oriented programming is code reuse. Once something is written and debugged it should be available for programming in other projects and programs. It might be better if each of the classes had its own header file (header.h or header.hpp) and a source file. A second goal is encapsulation. Code that uses other classes only needs to know the interfaces and not the details of the implementation. This allows implementations to be imporoved over time. RandomNumber.h KenoWinCalculator.h and KenoWinCalculator.cpp Bank.h Award.h and Award.cpp kenoGamePlay.h and kenoGamePlay.cpp The combined use of headers and C++ source files allows the classes/API to be maintained without forcing recompilation of all files. A linking phase may be required. In some cases these might become dynamic libraries with the header files providing the APIs. Avoid Using Goto C++ and to a lesser extent C provide a lot of ways to control the flow of the code, the use of is discouraged in most modern programming lanaguages because it is very hard to maintain the code. In the case where it is used here, rather than using a style integer array it might be better to use a C++/stl container class such as std::array and to use the std::find() function to find any duplicates. 

in their code they are allow possible collisions of functions from their code and different libraries they might be using. The code here is complicated enough that one might want to include libraries to do some of the work. Most professional programmers will use std::cin, std::cout and std::vector rather than the statement. 

but it is named HashMap.h in the question. Some operating systems ignore case in file names, others are quite strict. To avoid portability issues make sure the name of the included file is the same for both the operating system and in the #include. calloc() versus malloc() The function calloc(size_t n_items, size_t size_of_one_location) is meant to allocate arrays of some item. It makes the code clearer with similar results. 

Variable Names Generally the variable names are ok, some might improve with additional length such as changing to . One variable should probably be renamed from to `sequence_size since it is used in much of the program. Testing the Return of Allocation The code contains all the necessary testing to see if returns a value or not, but it would be better if each call to was immediately tested rather than what the following code does: 

Both and are getting input from stdin. The search you are performing for end of line is failing because bufferclear should be EOF on the first execution of the loop. What you should be doing is a search for end of line on . Keep it Simple Since you are reading from stdin, use rather than , has the same semantics as but only reads from stdin. If you want to be able to read from any file you should add another parameter this is either the file name or a FILE pointer. If it is the file name than will need to perform a . There is a software engineering/programming principle call KISS, or Keep it Simple. _principle The simpler you make the code the easier it is to write, maintain and debug. Alignment If is going to be used in a at some point in the future, you should consider the alignment of the fields in the struct to make the most efficient use of memory. Computers implement strings in of memory. A word is some power of two bytes long, in the past this has been either 2 or 4 bytes, most computers and compilers are going to use 8 bytes these days in a 64 bit architecture. Therefore should be some multiple of 8 (8, 16, 24, 32). I'd suggest as a minimum 16 because 8 may be too small. Use Functions or Loops for Repetitive Code In software engineering there is a programming principle called Don't Repeat Yourself. Any time you have repeating code such as : 

A collision is when 2 different functions have the same name, the same arguement types and a similar functionallity (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionallity of a class such as std::vector or std::stack. Namespaces allow these constructs to be overriden. The use of the programming statement: 

Since x, h and n are loop variants, it would be better to delcare them where their values are assigned: 

There is a Bug in the Code The code in contains at least one bug, it might have been easier to prevent if the multiple if statements were a switch/case statement. 

Welcome to Code Review, nice first question! Perform Error Checking as Soon as Possible The complexity of the code can be decreased by performing earlier error checking in the function . If the code was changed so that was tested at the beginning there would be less indentation and the code would be easier to follow: