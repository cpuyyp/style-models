I was suspicious that your initial code was basically as good as possible. It's already algorithmically better than your second example. is immutable linked list. There's no way sorting values is better than just generating the correct values in the first place. So, I decided to benchmark your initial version vs a hand-fused version that is guaranteed to allocate only exactly what it needs. 

It turns out that this is exactly what does in the monad. For the sake of completeness, let's look at exactly how works. 

Wow, my machine is noisy. I don't really know why it's that bad, but moving on.. The version that explicitly shares tails performs better in the small test, by a notable margin. At those sizes, the memory use doesn't have a significant performance impact. But in the larger test, it's notably slower. At that size, the cost of the additional memory use is visible. A side note from the larger test is that the performance difference between the naive version and my hand-fused version has become significant, and the hand-fused version is slower. I'm not as good of an optimizer as GHC! (I suspect that the issue is that I'm counting up and comparing against a non-zero value in my loops. I could test, but that's getting pretty far-afield.) In summary, I'd use the naive version. It might be a little slower in small cases, but when things get big, it starts to get ahead. And it definitely has better properties about memory use at any size. Sometimes duplicating work is faster than caching it. 

If the file contains PHP code without closing (which is recommended), you'll get a syntax error. the code and remove at the end. 

There is no need to put simple expressions within parenthesis in your conditions. The order of your conditions is irritating (negative, positive, negative, negative). Group them properly. That also helps to simplify the conditions. 

It is absolutely ok to call functions from other functions. There is nothing wrong with that. However, there's room for improvements in your code. function.php: 

Escape values on output using the right escaping function. Since you use prepared statements, no extra escaping is needed for the database. Create the database connection in central place, so you don't have to change several files and functions, if the database (or your password) changes. 

You see how the above class is very similar to the DbResult class and works relatively the same way? This is how I might make a class for Services, but is there any way I can make a class that does both DbResults and ServiceResults without becoming more ambiguous like the following class example below? or, is it ok to be ambiguous like the result I put below? 

I'm looking for a way to simplify this code, because I could develop more overloads for I made the string and int both of class so that in each overloaded function, the catch block could return the same value. The problem is I need, if possible, no overloads of . The function overloads are both identical, except for the type of delegate they are passed. Is there some kind of variable that would encompass any delegate that can be executed? 

If you want the laziness of , you'll need to write this using . Doing that requires a trick - the same trick as is involved in writing as . I wrote in some detail of my derivation of how that trick works here. For what it's worth, using that trick to write using looks like this: 

So is this better? Well - it depends. It should be better when the cost of allocating the suffixes is higher than the cost of keeping them around. The memory use of keeping them in memory isn't insignificant. Eventually it starts to really make a difference. Here's a new set of benchmarks: 

Of course the is simplified; you can easily elaborate it to do a more sophisticated error management, but you get the point. 

With that approach, you can easily make other tables taggable. To retrieve the tags for a post, you'd just say 

Since interrupts the program flow, you don't need to provide an branch. That way, you also visibly follow the good practice of using 'watchdogs': 

I'll keep the procedural style, you use; otherwise I'd prefer object oriented code. You need a function that creates the database connection on the first call and returns that connection on every call. 

I also have a helper static class that provides some functions to make some tasks easier. 4 CRUD FUNCTIONS 

I also have a class called ServiceManager, which checks to see if the SQL Server (SQLEXPRESS) service is running on the local machine. 

I have discovered, with thanks to you each, that it is better to call the display method within the DataAccess.ReadMethod() than to pass strings, Here's what I think i should do: 

I have a console application that I'm trying to make with minimal redundant code. I have 4 functions, Create, Read, Update, and Delete. 

Note that I do a round of benchmarks forcing smaller values fully into memory, and then do a second round of benchmarks with a much larger value that I only care about the last entry of. Here are the results: 

And in fact, that's exactly what leaning on the monad instance for iteration looks like. A couple of binds and a return. 

turns out to just pass off the heavy lifting to and . is pretty simple, so the interesting part happens in sequence: 

The big thing I can see is that you don't seem to know why to use a mutable structure in Haskell. They're not automatically faster. In fact, they have some GC-related overhead that exceeds that of immutable structures in GHC. Mutable structures in GHC are only a win if they can actually reduce the amount of allocation, and this implementation looks like it allocates a lot. When you consider using a mutable structure, you need to examine how mutability will reduce total allocation. If it doesn't reduce allocation (and usually by an asymptotic factor) it's unlikely that mutability alone is going to help performance. 

Here is my problem. Do I need to give a new identifier to each delegate I write of the following delegate type? like so: or could i use one delegate that accounts for any Datatype I need to use so i don't have to keep repeating the code? Something that may or may not be relevant: I'm calling these functions to prompt user's input for new fields to add for records in a database. So database field types are the data types I'm dealing with, but I'm using this approach for learning purposes to try and minimize redundancy. 

The keyword makes the variable keep its value after leaving the function. Now the functions with database access only have to know the function, but no details about the connection. 

In your context, a Factory is not helping you. DB Connection Don't use static methods, if you can avoid it. Inject dependencies whereever possible. Do not (finally) handle errors within your classes. Leave that up to the caller. The method to get an instance is usually called (and is one of the few cases, where static calls are reasonable). The initialization is then made in a private constructor. 

And the results say... They run in basically exactly the same time. The differences are well within the standard deviations in the measurements, and my computer is apparently a very noisy system to benchmark on. The conclusion I draw from this is that the naive code is basically as good as possible. The optimizations present in GHC and its libraries make it exactly as good as the far-more-complicated fully hand-fused implementation. 

You could argue that your second pattern was an optimization in the case that the second list is empty, but the tradeoff is adding O(n) overhead every time the second list isn't empty. There's a reason doesn't do that check for . The third case was pure overhead, and always an improvement to remove. 

As you may have noticed in the code directly above, I use the DbResult class as a return type to carry the status message and bool back to the main program. I think this does not make sense since DbResult is a class created for returning results from trying to perform operations on the Database, not the SQL Server checkup. I could create a new class called ServiceResult, which does the exact same thing as DbResult, but that would be duplicating code. see example below: 

I am wondering if in particular the function called and are unnecessary. It seems to me that the logic is more cluttered if i do away with those functions. Please provide me with your ideas and thoughts. If you have other thoughts please let me know. man is an entity class generated by entity framework. TestDataBaseEntities is the DBcontext item.