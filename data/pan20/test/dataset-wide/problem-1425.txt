URL Structure The URL structure is hardcoded in the //etc fields, which doesn't seem like a good idea. It is confusing, and it means that and are responsible for how the actual remote call looks, instead of having it all in one place. This means that in case the call ever changes, you have to change your code in two completely different classes. So what I would do is move the strings into the class. You don't specify if you have control over how the API works, but if you do, change it. Sensitive data should not be submitted via GET, as URLs are frequently logged (client- as well as server-side), while POST data is mostly not logged. Exception Handling Your exception handling could be improved. Just catching and printing is rarely the best choice. It's not user friendly, it's not development friendly (the stacktrace is swallowed), and it's not good for reusability. It also takes away any control the calling class would have if you just threw the exceptions. What if it doesn't want to print? And what if it doesn't want to continue? Eg seems like a good reason not to continue, except if specifically order to do so (you could add a flag to for this). Misc 

That looks way less nice. There are definitely variables directly inside an SQL query. So is this secure? To know that, we have to dive deep into the code, as we have no idea what the variables actually stand for. If we do that, we can see that: 

I get a . This is because you first access data of the root, and then check what the size is. It should be the other way around (and checking if the root is null would be a bit clearer). You also shouldn't set the data to null, you should remove the node, otherwise you have a root node that contains null (also, your list size is wrong from there on out). It also doesn't make that much sense to first set the data, and then override the node. In that case, just remove the setting of the data. remove non existing element If a non existing element is removed, you could throw a (it's what Java lists do). Setting values to null this isn't necessary, you are returning right afterwards. Naming 

I don't see how you could do this in a single queries, because both queries have nothing to do with each other. Your code does contain a bit of duplication, but otherwise it looks good to me. You can simplify your code by introducing a function: 

Yes, it is. You should never put any variables directly into SQL statements. Even if you think that the variables may possibly be safe, it's just really bad practice, and you will mess it up sooner or later. In your case, an attacker could use the profile fields, which would very likely lead to SQL injection (this depends a bit on the input filter for the profile fields, but I would be surprised if it caught all injections, and you should definitely not rely on it). 

No, they are not. All those characters pass without a problem. It only strips tags and encodes some chars (single and double quotes). The documentation is not very clear on what tags are, but generally it's something like , although the filter also removes from , so you could get problems if you want to allow the character. 

Generics Since you asked: Sure, generics would be nice. Right now, your would be better named , as it only accepts integers. Mutable 

Validating HTML5 Code It seems that you are new to HTML5, so it's a good idea to validate your code. You have 14 errors and 5 warnings in your code: 

If you extract the building of the return array to its own function, it will be easier to change, and result in easier to read code. 

First of, you are vulnerable to SQL injection. "remember to check if the value is an integer before setting it" would not be a reasonable defense against injection, you really need to defend in the same place as you build the query, and you need to use prepared statements. Structure On the PHP side, the structure seems fine to me. Spec is a classic model, holding the spec data and containing the business logic. The calcPressure method also doesn't do quite as much as you say (it doesn't prepare the output, which would indeed not be good). But the fields should be private and accessible via getters, which would break your view. The question is if you actually really need the whole object in the js view. In the example you posted, this is not the case, you could simply do this: 

Speed: it will always be slower than native HTML. Complexity: native HTML will always work (it might not validate, but it will display something). You have to extensively test your class, and still, you might overlook something. Usability: People know how HTML works, but they don't know your class, so they have to invest time in it. 

In this case I would create more functions. This should increase the readability and reusability of your code: 

@Elias Van Ootegem already covered quite a lot, so just a couple of points from me: Security: Login as any user Right now, an attacker does not need to know the password of a user to login, just the username. This is because of the precedence of over . Your query is executed as: 

Calling twice is not a good idea, as each time a db query is necessary. As you are asking about OOP: You could add an actual object, which contains , , etc as fields. Your current class could then be renamed or something, and would then return a player object. The main advantage would be that a concrete object is easier to use than an anonymous one (classes are to some degree self-documenting, while you can't be sure what an anonymous object actually contains). Misc 

In this case it's fine, but if you plan to create a more complex calculator class, I would just create public , , (just one argument), (three arguments), etc. methods, because a calculator should only have to calculate, it shouldn't actually be the calculators job to decide what it calculates. And it would be hard to manage once you have functions with more or less than two arguments. So in that case I would extract the switch statement to a separate controller class which then decides what to calculate based on the user input. 

This isn't all that easy to read, and it is calculated every loop. If you rephrase your calculations like this: 

You can extract the y check the same way. Note also that I rephrased the condition from to which is faster[*] and a lot clearer. You could also negate the expression and use continue if you think that this will lead to too deply nested code. 

Object Oriented I wouldn't call your code object oriented. And yes, using in too many places can be a hint that you are not using OOP correctly. But your program is so small and specific that this isn't really a bad thing. If you actually have some extension in mind, a different approach might be better, but right now, I would leave it as it is. But for example, lets say you plan to write a program in the future which prints every odd Fibonacci number, or every Fibonacci number dividable by 3. With your code, this might be harder to do. If your approach was like this: 

I already posted something about the general concept and OOP, but I also have some comments on the concrete code: displayWhoWon You have 

For proper defenses, see below. Relative Path Overwrite You include your CSS file with a relative path, which leads to vulnerable code, as it makes CSS injection possible. If an attacker can inject CSS code - which they can via the username - this injected CSS code can be parsed as CSS code by appending slashes at the end of the path. This can lead to phishing, defacement, limited data leakage, and other problems. Filtering the username is not the correct solution for this, you need to include your CSS files via absolute path. You should also set a doctype as it mitigats this vulnerability in most browsers. CSRF Your code doesn't have CSRF protection. In case this isn't handled elsewere, you really need to include this, even for login pages. An attacker could force-login a user in the hopes that they reveal sensitive data while logged into an attacker-controlled account, or they could exploit XSS issues in the user area. Redirect Your redirect function is vulnerable to open redirect. Currently, no user input is passed to it, but each function which uses potentially vulnerable functions - a redirect in this example - should be secure, in case it is used differently in the future. Improper input sanitation @insertusernamehere already pointed that calling on a password is a bad idea. Their example is a bit contrived (a password of ), but it's a lot worse. becomes . Users may not use often, but password managers may. Apart from that, calling either or on input is not a good approach at all. XSS is an output vulnerability, and that is where it needs to be defended against. You should have input validation though! Ideally, via a generalized class that handles all input, and which provides methods such as , , , , , and so on. Then, always(!) access all input via these methods. Proper XSS protection XSS is an output vulnerability, so defend against it when printing. You also want to do this by default. Having to remember encoding each variable - or worse, thinking for each variable if encoding is necessary - will lead to mistakes sooner rather than later. XSS is also context sensitive, meaning a call to will not be enough in many situations. , would be two examples. Use a decent templaing engine which HTML encodes by default, and use JavaScript or URL encoding when necessary. SQL Credentials Store your database credentials in a special file outside the webroot. This makes it easier to exclude them from version control, and avoids accidentally exposing automatically created backup files. 

This leaves the false impression, that you are adding up the value of . If you just return the value, your code will also be shorter: 

This means for anyone, for the group, and for the owner. The problem is that the owner is the webserver, as the webserver is the one creating these files. To make the directory actually non-executable, or similar would be better. Misc 

Not really. And if you are, it doesn't matter. When a user registers, you want to perform 4 actions, which means that these 4 actions need to be applied in one place, and a function is the right place for it. Note that the original definition of "responsibility" in the context of SRP is "a reason for change". So you could look at it like this: The only responsibility of the function is to register a user. You don't call it when a user unregisters, when a user changes their password, when a user needs a password reset, etc. You also have separated the actual implementations in the appropriate classes, so I don't see a problem here. Misc 

I would; if you do, take a look at the MVC pattern. You don't have to follow it exactly, but some separation of model, view, and controller can go a long way. But even if you stay with your approach, it would be a good idea to either have functions/classes in a file or code that has side-effects, instead of having both in the same file. Right now, you couldn't eg use the or functions anywhere else, because as soon as you import that file, the additional code will be executed. Misc 

And I removed from . Now the reset works without reloading each time. CSS I would put this in an external css file, and format it properly (each attribute on its own line, etc.). If you care about performance, minify with a tool later instead of writing harder to read code. 

test_input I see this function quite often, and I don't think it's a good idea to use it (see here). It is much better to have specific input filters which match what the input should be. Additionally, applying encoding functions at the wrong time - on input - can lead to double encoding and thus invalid data. The same is true for stripslashes, which may severely change your data. Filters Your name filters are quite strict, and many people couldn't enter their real name. If that is acceptable for your application, it can stay as-is, otherwise you might want to look at Falsehoods Programmers Believe About Names. Encoding You correctly encode the input when printing it to defend against XSS. That is great, as input filters should only be used as defense in depth, but never as your only defense. Personally, I would also encode other variables, eg the error variables. Code changes, and if the error variables contain user input in the future, you would be vulnerable. Ideally, you could use a template engine, which automatically HTML encodes all variables. Duplication and dedicated Input class There is duplication in your input filters (eg first and last name). I would create a dedicated Input class with methods like , , , etc, which will return the filtered GET variable (you would then have ...post() methods which return POST). You can also have a generic which filters the input by the given regex. Usability You are only allowing numbers in your telephone number. That seems acceptable, but users will enter numbers in all sorts of formats. Instead of just telling them that they did it wrong, you need to tell them how to do it correctly (eg ). 

I guess that is one solution, but I would just deny attempts completely for x seconds if y attempts where made from that IP in the last z seconds. Misc 

Then use this in your and functions to avoid duplicate code and to make it easier to add new types. You could also create a list or enum of types to make this a lot easier. Use to simplify statements If you use a , your if statements in would look like this: 

You could also replace the assignment with two statements, which might be easier to read. Also: your approach with iterating over the string and using is quite complicated. Just use to check if a string contains another string. And just out of curiosity: how would you pronounce or ?