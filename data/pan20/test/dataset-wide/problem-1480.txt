I'd want to see a solution that was reasonably performant but my criteria would be something like "runs successfully in the time it takes for me to get a coffee". If you were applying for a job that required regularly writing high perf code that would be different of course. Now, I think I can pull out one method to talk about in terms of what I'm looking for: 

is derived from which implements . As you're holding a reference to an you should implement yourself and dispose the port in your own dispose method. That's the first indication that this doesn't belong as a static class. 

You check if there are one or more selected items but the the rest of your code only works on the first selection. I think you should specifically check for a single selected item. I've used from the namespace. I wonder about the value you get from saying the list is empty - surely that's just the same behaviour as not having selected anything from the list? It might also be better to invert all of your if conditions to reduce indentation: 

Is this secure? No. It isn't secure because you can change anyone's email address on the last step. To do so, all I need to do is change the stored in the hidden field (for example, using my browser tools). In the final step you must verify the token. You don't need step 2 at all. There are two requests you need once you have your reset token. Typically you'd click a link in the email. GET passwordReset (pass in the reset token) POST passwordReset (pass in the reset token and the new password) Use the reset token to look up the email that you're changing the password for. The token should be time limited, long and random to avoid guessing. 

In general, I think you need to introduce an abstraction over the entity types mapping. At the moment, some of your methods feel a bit too low level: 

As another answer has said while I was typing - LINQ gives you most of what you need out of the box and extension methods fit very nicely here. Update How does the Math class violate the dependency inversion principle? Here is the Wikipedia definition of the dependency inversion principle (emphasis is mine): 

You already have an enum - make sure you have implemented equality correctly and let people create their own mug cup. 

There is also the possibility of creating a constructor that takes a of item and probability for bulk population. You'll note that I like to use and also don't want to get into a holy war about it. 

Remove the parameter and delete the commented code. Also, don't bother with just . Naming You've used a sensible name for namespace and class - kudos! Prefer to - it looks nicer and is more standard. All local variables should be named in -> . Quite a few of your names are quite good - but can be tightened up in places: try to be as descriptive as you can. Other stuff Everything is - not necessarily a problem but some people get upset about that sort of thing. 

It returns but it generates a dictionary? Now I have to dig into the code to find where my dictionary has been generated. 

That's not true: "my.file.txt" is a perfectly valid filename - your code appears to incorrectly drop the file extension and changes the extension to ".file". That's a pretty big bug. You should use the methods available on the class e.g. GetFileNameWithoutExtension rather than using . 

If you're going to set an explicit value for one enum member, I'd say you should do it for them all: 

Hmmm, the second user could kill the first user's word instance. That seems like a massive bug waiting to happen. There is a quit method on you should use instead of killing the processes. 

The code looks good, but I can see a couple of things that could be a bit cleaner: e.g. this method: 

and should be . The same applies here change it to . It would be even nicer if you changed to something meaningful. I know it all seems really trivial but code will be read far more often than it's written/edited so you should be optimizing for read time not saving the odd space characters when you're typing it. 

specifies that the only valid captures are explicitly named or numbered groups of the form (?â€¦) See documentation String interpolation - see documentation which is implicit typing 

You aren't using you should remove it. I was part way through writing a better solution but Janos beat me to it! 

will handle all the thread safety issues for you. You don't need to worry about locking at all - the default will ensure only one is created (i.e. compile only called once). As an aside - you should never when is public instance... you have no idea whether or not someone else will try to lock the instance and cause a deadlock. Always use a private object to synchronise access. (code from memory directly into browser so might not compile but should be substantially correct) *updated to use as per comments. 

If you need to come back to something, use a comment so that it appears in your task list in visual studio 

Naming again: should be although not clear to me whether it's already depersonalised here or whether it's about to be... Your final is redundant, it can be removed. Remove the parentheses around the returned value - they just add noise. The connection management looks fine to me - is incredibly clever and it's designed to be a long-lived singleton which I think makes it fine to be in a static readonly field. is intentionally very lightweight and you can make as many as you like. Edit In response to your edit, I would suggest renaming this from "depersonalised" data to something like a (naming is hard). 

I use Math.Floor on the TotalSeconds to add the 1-second tolerance. You can be 0.9999 of a second over and still evaluate as true. You could have done a strictly less than with instead. 

Not that I've Pascal cased to . I've treated user and name as separate words here () but if you implement full authentication on the site, you might find you move towards an actual username (one word). Having said all of the above, the chance of someone randomly changing a GUID and getting another entity is infinitesimally small. 

I've had to do this exact thing before, your way is absolutely fine but I went for the other way round - checking if it was all text: 

You are mixing query and fluent syntax for your LINQ queries which is resulting a in a lot of code bloat. Let's refactor it one step at a time. 

I haven't set the so the class can't work. Add a constructor so the class can be instantiated correctly and obviously. 

Although the code is untested and typed directly into this answer (so it might not be right) you should hopefully be able to see that we've eliminated all of those operations where we keep searching all of the items we've already added to the timeline instead just keep a list of end dates (which is all we need as we are going in order of start date). Note that I've also not eagerly evaluated the and have structured the code to avoid needing to detect the no items case. I've intentionally not done any formal big O analysis so please excuse the hand waving. Update I decided to see how much of an impact the changes I suggested would have. On 10,000 items that have to be scheduled across a minimum of 5 resources: My version: 2ms Original version: 4324ms I also tried it with 100,000 items that have to be scheduled across a minimum of 5 resources: My version: 44ms Original version: 438834ms (~7.3 minutes) Tests were averaged over 10 runs with a first warm up of each not measured. I also checked that the algorithms were returning identical results (which they were as far as I could tell). 

By "simplify" I mean make your intent obvious and avoid creating extra lower case versions of all your strings. 

Aside from the issue of s resolution/accuracy there's a lot of room for improvement in your angular. 

I think your best bet would be to teach about unit testing. For example you could do a really simple assertion to prove your solution works: 

Separate the mechanics and the semantics of the code. Here's my very well used extension method on : 

You could also add in an overload which handles the case where you don't want to do anything to the filename and add a default for the extension: 

can change between the check and using it. If a listener unsubscribes in this time you'll get an Exception! The proper way to do this is: 

You just inject this service into all the places you need to get files in the working directory. You don't have any magic that you need to worry about. If you change the setting and save it, then you expect (and want) it to be saved. 

Which one is it? General Wouldn't it be easier to use if your prefix and trailing content didn't include the colon (:)? This looks like that rare problem that would be easier to solve with regular expressions!