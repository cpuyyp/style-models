Return a String instead of printing Instead of your method being make it return a and remove all the from it. Then from where you call instead do . This limits the side-effects of the method. For tiny programs this is not a big deal but in larger projects knowing exactly what a method will do is very handy -- especially if the method is what is known as a "pure function" which means it literally has no side effects and its output is directly dependent on its output. Consistent formatting In some places you have spaces before braces () and in others you don't (). It's less important whether or not you use them than how important it is to be consistent. Personally I put spaces before them. 

It's unlike Java where single quotes are for characters. One exception to this is when using the in Strings, you have to use double quotes for this. 

This is worse. This is like saying . If you're set on leaving some comments it'd be more beneficial to leave some in the other methods with more logic involved like the method. 

I don't like the use of here. If is null then it's fine (but I still don't like it). It seems better to throw a . In addition, if it actually was null it would throw a "real" at the first if statement. 

I recommend this, but it's ugly. I'd like it better if the throwing was at the top, but it's a trivial change you can figure on your own (It makes sense for all preconditions to be at the top). 

A short suggestion because no one has suggested it yet. Instead of returning or throwing an exception when the book you are searching for isn't found, you should use . 

I know this is a small script but I am new-ish to writing Bash scripts and want to learn. The lines seem a little ugly, though they do work. Also I can't pass multiple commands in with a like because the ends the statement in the line, so I am wondering if there's a better way to write that line (or pass them in). 

I actually just looked this up writing the answer. You can use a method called on arrays in place of a closure. Documentation 

The commented out line is basically the same as the but it throws which to me is just more informative in this case than , but it's up to you which you prefer. 

I've created a voting system that's similar to Stack Exchange's in a Ruby on Rails web app. It's working great - as far as I can tell, all the edge cases are caught. This is the action to cast a vote. There are some conditions I've had to satisfy: 

[ln 215] ? Seems like one list to me. Rename it; again, consider the point above that it should be . 

Don't prefix your names like that. If you're adding a prefix, it should still follow all the rules of variable naming for C#. For private fields, variables are named in , with the underscore before it. Public properties are named in . So, you can rename a number of variables, for example should be . Server.cs I do believe I've found an error here. 

and its equivalent on the next line, is redundant: you should only use when you're passing in a delegate, and even then not always. Rewrite those two lines: 

At the moment, I'm updating the record if there's already a vote by this user on this post, but I wonder if that's the most efficient strategy. Would destroying the old row and creating a new record be faster? I'd particularly appreciate efficiency comments - at the moment, this is a very server heavy action, which I'd like to minimise. 

[ln 60] Single responsibility: if 's purpose is to get news, it shouldn't also be dealing with notifying the user if there is none. Make this method return if there is no news to be had because of the , and do the check in the UI code [ln 55]: 

can just be , because range starts at 0 by default. The syntax is essentially - the only mandatory param is . Filename parsing If you want to parse filenames by yourself rather than using a library, then while your current solution: 

What sorcery is this? You've conjured a string from thin air! Where did that come from? You should avoid magic strings where possible, instead assigning them to a or of commonly used phrases within your application. The same can be said for in the call: what is 1987 and where did it come from? Assign it to a resource list. Client.cs Code Analysis Says: Implement correctly. Your class nominally implements , but you've only written half the implementation. You also need a method, called by . If called as , it should also clean up managed resources; if it's you should only clean up your class' resources. You also need to tell the garbage collector not to run the finalizer on your class because you've already implemented . In this case there's no difference that I can see, so a few simple modifications: 

Everyone has commented about how to better replace the spaces, I will answer how to better test. I suggest making a proper unit test with Junit. This way you do not need to manually look at your output, you can simply run the test and it will tell you if it failed or passed. Unit testing is extremely crucial in a professional environment and is a very important skill to pick up early. (The below assumes your class is named .) 

If you throw a checked exception every single call of this method will need to be wrapped with . Checked exceptions are a pain to deal. If you throw an unchecked exception then you have the same problem of , maybe people don't realize it could happen. So they don't wrap it in a try-block. 

The only reason I even include the manual throwing of is because I assume you do more stuff in the part, if you don't, remove it because it will do that on its own without you writing it in. 

The idea is simple, most people have some one directory containing all their projects as subdirectories. When you are in the top directory and you run this script like so it will run the command in each of the folders. I have another script called that fetches all remotes and fast forward updates them which I usually run each morning with this script. 

My reasoning against returning is this: It is never 100% clear if a method will return or not in Java and maybe someone will think this won't so they won't guard against the null condition with . If you return an , it's an extremely clear signal that the content of the result may or may not be present. They still may handle it wrong but at least you can be more certain they know what's going on. My reasoning against throwing some exception when the book is not present is this: 

I am only going to talk about the sports method, from there you should be able to get the info you need for the others as they are all basically the same. DRY isn't a big priority As I said in my earlier comment, DRY (don't repeat yourself) principle applies to production code more than unit test code. I think even in general it's easy to take this too far, readability is important, but that's off-topic. Your code however is tough to grasp. To me, something like the below is more clear. I like to specify "given/when/then" in comments (although usually I do nothing more than , etc.) but it's not necessary. 

In fact, repeating pattern (for every type of call a method passing inside) clearly calls for some inheritance on side: you should have several different classes, subtyped after your , with method , which should have processing related to that type of output. Having that you would replace this whole switch with . But I won't do that now, and instead concentrate of contents of there methods (although they are already pretty small and readable, with exception of ). 

And now, thanks to this, all our code operates on . So we can safely move it to instance method, because all this processing is coupled to single instance of . Let's call this method (of course, all the code inside it does not use , but uses implicit . Now, all that's left of yours is: 

You obviously don't do enough encapsulation. I see at least three classes with no behaviour (, and ), your "main" class () contains only static method... it does not seem like good OOP for me (and when we are talking C# we should mostly talk OOP). Let's try to fix it, one thing at a time. 

You do that for every run you got thru your label, but in fact it won't change: neither nor are changed elsewhere in this method. So we can safely move this operation above . Same goes for , , and . Then we convert your into common-knowledge . To do that we simply replace with , enclose all code below in loop, add in the end, and instead of every . Inside loop we have three s. If we look closely, we'll see that they are mutually exclusive. We will mark it explicitly, so we don't have to guess. If we follow this line of thought, we'll see that every time we don't hit inside our we can safely return from call. So let's invert those conditions too. What we've now come to? 

Now I'll do some strange thing: I'll extract your call to to variable. I do this only because it is the only thing that operates with and and I can not make any decision about it without seeing it first. So I'll just save entire call for later. 

All that's left is . Most of it happens only when . Let's invert that so we don't have to think what happens if both bests are 0 (because we simply return at that, don't leave us hanging!).