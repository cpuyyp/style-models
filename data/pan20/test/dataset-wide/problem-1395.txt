Addendum/Edit Seeing as this answer has gotten quite some attention I've gone ahead and dug deeper. Using godbolt compiler explorer I compiled () and disassembled my trivial loop implementation. Here is the disassembly on GCC 6.2: 

I'm not sure that linear time is possible for the problem as you have described it. It is, see accepted answer. I have a way to make it faster though: Go through the array once and find the largest value in \$A\$, label it \$A_p\$ . Make sure you keep track of the largest and smallest \$p\$ if there are duplicate values. Then let $$G^* = 2A_p+ p_{max} - p_{min}$$. This is our greedy guess at the maximum sum that we will use as a starting point. Next we want to find a lower bound on \$j\$ to limit our search space for any given \$i\$: $$A_i+A_j+j-i > G^* \Leftrightarrow j > G^* +i-A_i-A_j$$ Unfortunately we can't have \$A_j\$ in the calculation of the bound of \$j\$ as that wouldn't be possible to compute. But note that if we replace \$A_j\$ with \$A_p\$ which is at least as large, then we will only lower the bound on \$j\$ and we will not miss any solutions. At this point we can start scanning of \$A\$ and update \$G^*\$ as we go to have higher and higher lower bounds on \$j\$ as we go. Technically this is still \$O(n^2)\$ but with a smaller constant as you are able progressively take larger and larger skips. Pseudocode: 

Set speculation hat: On The JIT should inline expand the function calls to and , it should also not do anything with the stack variables (not even initializing). So the remaining difference is and the book keeping associated with the variable which could make or break here as you're only doing a few instructions to fetch the data every time. Adding a few book keeping instructions on the variable could have a big impact in your case. I would investigate if I could get rid of it somehow, maybe encapsulate it somehow so the same instance is used in all calls. Now if you doubt your JVM is good, you can try to inline the two function calls manually and restructure the thread safe variant like this: 

First use which is \$2^{31} -1\$ to mask out the sign bit and then just take modulo. Handles negative values without a branch and is as fast as it gets without assuming the hash table is a power of two size (in which case simply use ). 

Please excuse the probably buggy code, it's late and I need to hit the hay. I'll fix it up tomorrow. 

Yes, having a quantity field in is bad design. The reason is that it is the wrong abstraction. If you pick up and hold ten pebbles in your hand, the number ten is a property of your hand (because it is how many things it is holding), not the pebble which is just a pebble. Consider if you drop all the pebbles, now the quantity of pebbles in your hand changes to 0. But if the quantity was a property of the pebble, and you dropped all the pebbles how would you model that would each of the pebbles have a quantity of 0 now? What if you hand the pebbles over to some one else? Then you would change the quantity in respective hand, but if the quantity was part of the pebble you couldn't model this transaction at all. Similarly the quantity should be a property of the inventory (how many of X does it contain), not of the which is just an item. Somehow this makes me think of Database Normal Forms. Simply have a with as key and an quantity as value. This solves your duplicate items problem as well. 

I think that conceptually you're fine. There are some details that need attention. Hide the implementation Your creation syntax: 

As you haven't explained what the code is supposed to do I'm going to go out on a limb here and assume that it is a filter for a text box that will show suggestions/predictions for what you are about to type. Better data structure If that is the case then there is a data structure called a Trie (wikipedia) which is commonly used for this. By using a trie you will get faster performance and less memory usage than your current code. You should check it out. 

Naming The name is discouraged in Java. You should use (without the ). The names and are terrible. Members The field isn't used outside of the main method and you can simply make it local. Leaking resources You really should use Try-with-resources to auto-close the readers. 

and similarily for . I would prefer to use the primitive in the API because more often than not the user will do some computations to end up with the input value and will thus have a primitive that they want to pass in. Other primitive types will automatically be type promoted to double. In the odd case that the user actually has a of some sort, we add an overload to handle it. Add methods for querying the count and mean as well You have all the data to get the mean value and sample count as well and these are commonly used in conjunction with the standard deviation so to me it makes sense to provide these methods as well as they are trivial. Edit/Addendum I would consider leaving the validation of removed values to the user. By having the you add \$O\left(n\right)\$ memory requirement even if the user doesn't need the remove ability. And in many cases where you do need a remove (like a sliding window) the removal is guaranteed to be valid by the definition of the window. 

You're setting yourself up for name collisions and other nasties. Just use the god... I mean committee given names. If you really want a shorthand, then use a type-local alias. Like this: 

Since noise is essentially random, your large block of chains is causing severe CPU stalls due to branch miss predictions. You should create a look up table (LUT) and quantize to an integer which indexes into the LUT. This should get rid of many of the miss predictions. Also note that is invariant under the inner loop and you can move that calculation to the outer loop, although your compiler should already do that if it is optimizing. Edit: Also, your code doesn't look like perlin noise to me but I could be wrong. 

I would consider your first question as offtopic. So I will only answer the second question. For each call to you make a lot of recursive calls. Consider what happens if is large. Say , then can you tell me how many times you call ? I can't work it out other than "lots". Also consider that you will be calling with the same arguments very often, calculating the same results over and over. Lets look at an example recursive function that bears some resemblance to your code: 

You should never specify which specific implementation of you want but rather that you want a "list" or even a "collection" of positions. See Liskov Substitution Principle. This is better: 

because your current api doesn't make it clear about who owns the memory and is susceptible to ownership bugs as you're passing raw pointers. Yet you don't want to expose the implementation detail that is . Edit: I didn't check that it compiles but shouldn't be too hard to fix if it doesn't. :) Edit 2 I've had a bit more time to look at this now. You should factor out the code that retrieves the smart pointer as a private method to reduce code duplication: