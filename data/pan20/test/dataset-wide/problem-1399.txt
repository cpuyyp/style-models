Use of implementation detail You work directly with and . If there would be an interface, I'd say, always develop against the interface. But in this case, always develop against the super class. Because, if you won't use e.g. a BufferedWriter anymore, you can change it at one place. other 

I think it's too much to ask, to point everything out or give more or less exact statements about what you may need to refactor to what and why, since with some reading about the presentation patterns, you should come up with your own pattern decisions which you then will implement. I think that needs a few iterations ;-) (Check Passive View, MVP, MVVM/Presentation Model, that's the most common used, imo, or check for open source projects). Comments 99% percent of your comments are obsolete. First, they explain what the code is doing - don't comment what you are doing. They will lie one day, for instances the comment. One day it will be 30, or dynamic, or whatever. If you comment, comment why you are doing something. But in general, even that is often not necessary. In enterprise applications, it's usual because of "business illogic" / absurd requirements. Naming Try to be as clear as possible when it comes to naming. For instance, in , you declare g, d and dt, I see from the constructor, what those are. But when I have for instance a bug to fix and I know it's in , I read the following line: . I have only a clue about what dt, g and d would be. If you'd name it better, it could read which is much more clear. Also be consistent. In the name of the parameter is , which will be assigned to . So you have three different names for the same thing which makes it much harder to read. double precision I recommend to use instead of doubles, because of the preciscion problem, I think that could be a problem in the future. See wiki's "Floating Point" page, why I mention that. direction / position You might want to wrap direction and position into vectors. The main benefit would be, that you have a lot less parameters to pass and set, and it's usually quite clear, what a Vector is. Also not really sure if the calculation of the positions should be within the Projectile, since those are very common calculations - you might want to calculate those in a separate "MyMaths" type, or even in a Vector itself, maybe. The "maybe 3d in the future" problem should then be easier to implement (I have to admit, I suck at maths, so not quite sure if that would really help) Other 

If you are intent on using a builder, then I'd suggest either making it an inner static class to the main class or a different class in the same package. If the first solution, then the constructor for the built class can be made ; if the second, it can be made package local. First scenario: 

Then have a in which you would pair keys with implementations of . If no entry exists, of course, the method call is wrong. While this is easy, however, it is not practical. Many frameworks, including light ones, include annotation systems which will do the job automatically for you -- you should try and find one, and use it. There is also another solution -- since this is JDK 7 you are using, you'll have it: . It also requires that you implement an interface, but using this, you can load your method implementations easily. This is what I use in one of my projects, and it works quite well; the only trouble with it is you need to create a file in , but it's a trouble you only have to do once for each method you create; or if you use Maven, there is a plugin to generate it for you. 

I really think the 'only select data you need' paradigma is quite out dated. The management of the 'choose what columns' thingy, the 'be careful because its not null in the backend but someone might not have loaded that column' and the inconvenient increase of execution plans on your backend - which has to be managed, too - is in my opinion much more expensive compared to just select all (= upgrade the switch or add another cpu to the backend server) 

getType() Why on earth it's the 's job to handle the car type anyway? And why is the car type stored in a . findNewAStarPath() 

I also prefer a verb in my method names (they should have, actally, but in that case I think it's okayish), that's why I use 'with' as prefix; And I explicitly do not use not 'set' as prefix, to distinguish it from the setter of the User type. If you do it like that, the 'actual building' of the user is within the builder and not in the User - and the User type is kept quite stupid. It might seem a bit strange, that the 'build' method doesn't actually build, but non-persistent built types are often only used for unit testing. The sweet part about builders, you can expand them to persist your built types or other fancy requirements. 

Easy to adapt in the second scenario. Second remark: I fail to see why is an illegal value at all for your predicate; as your code reads right now, I can very well input as an argument to the predicate and it will work. Why not just "let it be"? After all, it is the user's fault if a correct predicate is not provided, isn't it? Third remark: calling a an ? Uh... Why not just ? Also, remind that any interface obeying the prototype of a can be used, so you can define and use instances of this interface. By default, you could supply an empty one, or one that s, for instance 

The "drawback" here is that it is up to the caller to remind what predicates where in what order in the calling lists, of course. As to your hypothetical class: 

One advantage is that if two instances created for are equal (ie, the same and parameters), computation for happens only once! 

I'd just say to go with your implementation; just because it is easier to read! Also, you only from the list once, whereas the proposed solution does it twice. Shorter is not a synonym for better! However, the generics are not good; you should at least use . Not sure why the proposed solution uses as a lower bound... 

Nah, don't do that, it's much harder to understand than if else statements. Also, I only use the ternary operator if it's a plain if-then-else-that statement. Everything more complicated will be like sentence with too many subclauses; plain stupid boolean conditions can still be way too complicated to understand a few lines of code and are a major source of errors. Hope that helps,... 

Einstein was awesome Considering the solution to any problem, Einstein said: As easy as possible, but not easier. And to be honest, that's what your solution lacks the most. Here a general (and of course debatable) idea of how it could be implemented much easier: 

I really like the small test methods. But without seeing the actual implementation, it is very hard to tell, if a test case makes sense or does what it should do. Small improvements: 

This is just useless. It's not only useless, I have no idea what I have to do with that information. And it's wrong. The first line after that comment is the serialVersionUID. And it's not parameters. Just get rid of all those comments, it's just clutter and misleading. serialVersionUID Disable the eclipse warning for the serialVersionUID. And delete all of those uids. When I'm pair programming with my apprentices, I forbid them to use quick fix. Because they don't know what the error/warning is, and what the quick fix does. public variables Don't explose implementation detail: public GeomVectorField roads = new GeomVectorField(); See information hiding another comment Okay, I withdraw my previous statement, THIS is the worst: