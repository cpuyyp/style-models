The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. ⧺C.149 — no naked or . You should probably make this a as a drop-in replacement without otherwise changing the architecture. 

Take a look at Boost.Iterator. You can write what you want by a simple use of Boost’s , changing only what you need to change (e.g. member). Seriously, it does all that code you wrote, already in the can and well reviewed for edge cases. You only have to write what’s different from the underlying iterator, and everything else comes through. Or, if you’re living on the bleeding edge, just use a in the Range v3 library. 

I see you are generally using up-to-date C++ library and language features. But, the handler should be a rather than a . That makes me wonder if this class is doing a lot of the heavy lifting that already does, including local buffer optimizations? Could your class be built around that instead? 

Exactly! Don’t read one ahead. Skipws should do its one job only. It is especially confusing since peekWord does not do the skipws call. It seems that it is called when you already know that the first character of the word does match the input? This is going to lead to maintenance problems, believe me. (later: I see a lot of the functions take the read-ahead character as another parameter and have special code to deal with that first. Get rid of all that. The function should be called with the input set to the first position of the thing it wants to read. You already know to peek and to rewind, so there is no reason to have this one-off getting in the way.) Did you know that a stream can give you an input iterator? So rather than allocating a string and reading into it and then comparing (oh, and you didn't check to see if it read as many bytes as you asked for), you can use something like directly between and the input stream. If/when you do need to access the contents of a as a buffer for writing into, use . 

Another thing to learn about C++ is RAII (also read cppreference on this subject). This is a fundamental strength of C++ and it should be used to good effect wherever resources are used. So, don’t have a global file object that you open and close at various points in time. Declare the variable when you are ready to open it and use the constructor, not an call, to open it. When it goes out of scope, it is closed, so you never explicitly close it. In this case, you should define it in where you are opening it now, and pass it into functions that need to use it: 

The in the doesn’t make sense. It is non-throwing if what you do in the body will never throw. If this is a trick to get SFINAE tucked away, it will not work. Likewise, the does not belong in the body at all! You want this form of to only match overloading if the conversion is possible. That is, use , as an extra dummy template parameter. Meanwhile, it doesn’t make sense to assign an to a without any kind of conversion going on. You want to check conversion ability on the pointers, not on the types being pointed to! The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. 

which I don’t find as clear and succinct as it should be. You still can’t beat normal code inside a loop — maybe I need a joiner that can be declared, fed in a loop, and then have the result extracted. more iteration woes The member function needs to iterate over two vectors in step. Boost’s function crashes and burns big time when used with native C++17 features. 

Don’t write explicit tests against . Use the contextual conversion to as a more general truth value of objects. This is more important when it comes to smart pointers. The idiomatic thing to write is 

Don’t, in general, assign to clear out a . In this case, there is no need to say anything at all because has a constructor. So just leave the default initializer off of the member. 

Writing identifiers with a leading underscore is a bad idea, and is generally dissuaded as a style. Note that it is legal for member names if (and only if) the next character is not a capital letter or another underscore. 

I think you are doing well, just looking at the code itself — I’m not familiar with the library you are using, so I don’t know if you are approaching it well. Keep it up! 

Notes ※ I’d normally write all those as default initializers in-line and not give a constructor at all. But for this specific example, I worry about referring to other members. I’d need to look that up to see if it’s OK. Rather than updating a map every time you change a value, you can use the same effort of setting up each member with an identifier and callback but provide a general way to explore the current values and types when you are ready to do something with them. That is, pull rather than push. There are libraries that do this, most notably Boost::Fusion. But there are more modern ways — I think Boost::Hanna has that, but I don’t recall for sure. An any case, the thing to do is to supply a non-member template so the object can be used just like a tuple`. This will let it interoperate with other code that follows this approach, including the built-in structured bindings. Since your callback turns everything into a string representation, your Json rendering will not know what things were originally strings and what are numbers. Your code will output 

Now isn’t that better? And you didn’t even have to fix it when you changed the function parameters to be const references! 

Your function that switches from one to the other representation is overly complicated, and not very useful when you can’t tell which form you start with. E.g. 

What you are wishing for is called a projector, and it is a common need so Eric’s Range.v3 library features optional projector arguments on most of the range algorithms. To get to look at a single data member of the arguments, just supply your own comparison function. ‘What I mean by ordering KEntryContact objects is to just compare the single member inside it.’ 

And that's all. The Create function is special, and then the visit function can handle everything else you want to do with the objects based on the concrete type of what was read. 

I assume this is to learn how arithmetic works inside a CPU’s ALU on the bit level. That is an interesting idea, and in real life I recall implementing multiply on an 8-bit CPU and coming to understand how it works when figuring that out. 

which takes anything that is a “range” of some kind. If you call with completely unrelated parameters, like an int, this is not chosen (there is no overloading here, but that is the thought in general). Then, inside the definition,