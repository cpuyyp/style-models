Otherwise this implementation looks alright to me. I would probably make conversion implicit and conversion explicit (or just remove it, since you might as well just write ), but that's just me not being a fan of "transparent" things. :) P.S. Also does not feel like a typical to me, more like a . 

as any other read operation, removes read data from the stream, meaning you will never get the same string. logic is too complicated. The only code you really need is this: 

I'm not sure I like the idea of creating viewmodel in a command and then passing it to presenter. First, I feel like it should be presenter's job to create viewmodel and manage its lifetime. Second, the current implementation has really confusing semantics. Consider this: 

Alternatively, introduce a flag. Set it every time collection is modified by //etc. methods and check it before yielding each element. 

You should replace two methods with one. Your first method is a special case of your second method, so one way to remove code duplication is to call: 

I would implement those interfaces in separate classes. I see no interaction between the two implementations in your class, and they seem like two separate entities with different purpose. So there should be no reason to mix them into a single class. Have you considered using interfaces instead of s? Something like: 

My application accepts different messages. A is described by its . MessageFormat: represents . (, , ) Message: represents an abstract Java Object for . Schema: represents an abstract Java Object for descriptor. Contains MessageFormat. SchemaFormat: represents . (, , respecively for each MessageFormat) MessageParser: has a method . There is one concrete for each MessageFormat. SchemaParser: has a method . There is one concrete for each SchemaFormat. At start-up, all of the supported schemas are loaded and parsed one time each and kept inside the memory as concrete objects. When a message comes, we pass the message with its schema to the appropriate parser. It would be optimal to also have each appropriate parser instance inside memory (schema - parser, one-to-one). What is the best way to achieve this? My current layout is to have a switching the static parsers by asking a for the reference at the static parser that is inside that factory (as well as all of the parsers, for schemas and for messages, all are static). Strategy: 

Result: msgJson is now: {"Metrics":{"agentId":"12230","callsPerDay":"15"}} Now, I'll explain the classes briefly (too much code to fit here): Serialized: Has a private field, sets in the constructor, there is a getter. Deserialized Serializable: just an empty interface. Should I implement Serializable? I don't really know much about it, just seems appropriate. Schema Deserialized: represents an abstract Java Object for any kind of . Has a getter for FormatMessage value. Message Deserialized: represents an abstract Java Object for any kind of . Has a toJSONString() method. Parser: empty. Because for a message I need 2 parameters, for schema one. ParserMessage Parser: has a method ParserSchema Parser: has a method Format: empty FormatMessage Format FormatSchema Format For each FormatMessage value, there is a concrete class for Message and ParserMessage. For each FormatSchema value, there is a concrete class for Schema and ParserSchema. Obviously, ParserSchema returns its corresponding Schema and the same with messages. Now, the main part: Deserializer: has 2 methods: and . For both he accepts a Format (for message in a form of schema). Inside those two methods this class uses a by calling methods named and . Inside those methods, there is a call to a ParserFactory which holds all the concrete Parser static instances and gives away references to them by by the given Format on the appropriate . The problem is that I'm afraid that the Deserializer class abstracts everything too much that I have to cast a lot, even the caller has to cast a little. My team accepted this design, but I just want to make sure :) UPD: The code for and the as requested. 

Another edit: Couldn't resist from showing off, how the function can be further cleaned up for better performance (unrolling the loop for special case, getting rid of in loop). The real world benefit is of course useless, as the loop is done only N-times (vs permuting N size array inside, which is much more complex). So just for your fun ;). (BTW, OCD is evil thing, even partial ... hard to dismiss some things from head) 

(I did debug it in NASM, so if I'm unlucky, something may fail in FASM due to syntax, but it should be easy to fix. But it's highly unlikely, they should have identical syntax for instructions and I don't use any macros/etc) 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

Hmm... ok, one bit of source just to make it look a bit less like "wall of text" (although I'm afraid it's too late for that :D ). 

edit: When designing the algorithm, design also "memory". Where the data are stored, how much of them, why (purpose), when you want to create (temporary) copy, or when you want to use semantics, etc. I'm not suggesting to go after full "Data-Oriented Design" (unless you are designing some big-data processing application, where performance is main goal), but still some level of awareness how your data are flowing under the hood is good to have. Often by keeping data life cycle lean and without useless moving around, you will not only gain performance, but also simpler algorithm implementation and less code written = less bugs. 

won't work as you want it to. So eventually you might want to implement some sort of reference counting. 

I think you forgot to unsubscribe from . Better safe than sorry. You should also consider renaming the handler, so it does not look so out of place in otherwise conventional code. is a better name. 

The problem is that I do not know how many wheels you want to reinvent. The most straightforward way to implement the behavior you want is to declare an attached property: 

An offhand short sword that adds to defense? A shield that does damage when you bash with it? A magic potion that not only makes you less hungry but also adds armor when you drink it? 

In order to do a proper refactoring, you should move your classes somewhere, where you can calculate data. If you cannot do so, then you'll be better off with your original version. The second version is completely counterintuitive. Without digging into implementation details it is impossible to guess, that you need to set property for method to work. Also returning from factory (unless it is a valid value) is bad code style. You should throw instead 

This allows you to do all sorts of neat stuff later on. For example, to calculate total resistances of a player, you can call for every equipped item and sum the result. 

I found another bug in your source: will be always false. Unrelated to your bug, I have read an advice somewhere to always use only "<", "<=", "==" and "!=" in comparisons. It felt strange for few weeks, but once you get used to it, it really makes easier to read sources, as you know the values should only increase from left to right, if the expression is true. So I would write your expression as: . 

Overall your code is very reasonable for somebody learning Assembly, I would say quite nice work. I can produce something what will look more advanced (I hope), but it's more like tiny details improved here and there, and some of them for the price of worse readability of source. I mean on the syntax and low level. On the algorithmic level your code can be improved considerably, as PaweÅ‚ already answered, but he missed another opportunity to halve number of divisions. My variant of code, showing: 

Why does the function end when is not equal to ? That should be mentioned in description, that must be to make it work. 

I was thinking whether searching for neighbours for new word can be optimized by searching only trough "neighbours of neighbours of first-found-neighbour", but after short tinkering with it I think this is not valid, this would maybe work for all 4-letter permutations forming complete graph, not for regular words when plenty of possible 4 letter permutations are not available. 

If you have control over your data, you can try to change its format to simplier one. You can also try to move the logic to lower level, where possible. So it will look like instead. Its hard to tell an exact refactoring without seeing the bigger picture. Using "shortcuts" for commonly accessed fields is fine as well, as long as you don't overdo it. Use extension methods for that where possible, so that class structure remains clear. You can use shorter naming. Do you really need to have , for example? Isn't just as readable? Also if is an equivalent of individual "cells", then using indexers makes sense: 

So in which order should I call those to get things running? Should I call and then ? Should I await ? You should expose a single method, say, , so I can call it to connect to the server and be done with it. Straightforward and simple. Everyting else should be an implementation detail. If reads a single message, then you should change it's signature to . 

Well, in my opinion transaction should definitely NOT be responsible for getting a list of itself... Not only it makes little sense from domain perspective but it also violates SRP. Another major concern is that this design clearly encourages having classes with lots of hidden static dependencies. This problem alone is good enough reason to avoid it. 

That way I can just completely delete the and the classes. If they are present, however, each Parser in lazy-initialized and as soon as it's initialized, it's kept in the memory for the rest of the time. If I have all of the Parsers inside the enum then for each message an object gets declared and then discarded. But what happens with the performance when the application obtains 150 messages of 5 different types within a short period of time? I'm concerned that it would be really slow and the memory will bloat until the garbage collector comes and cleans it. I also don't have the way to load the schemas at the start-up, so I may choose the option with putting the s inside the just for the reason I will parse them once. But several data providers may choose the XML schemas, so, I that case I will instantiate the XML parser twice but that isn't a big deal, because there will not be more than 10 data providers. 

The component receives a as a string and a as a string. The contains key-value pairs or just the values. The describes how to turn that into a Java object. Firstly, we parse the into a Java object (schema format is known in advance). There is an with possible , which imply the format (it can be XML, JSON, or something custom). So, the contains this value as well as some additional information (like the keys if the only has the values, so we can later map already known key names to values and we don't need to send the keys every time over the wire). Now, that's how it works: 

is not the best name, as it does not really tell me anything about what this class does. If it were called, say, - that would give me an idea. method looks out of place. I think it should either be a method, that returns , or it should be non-static void method, that modifies property. I think the first option is better. is not the best name either. What are we chekcing, exactly? Use variable name to tell us that. You might want to implement . And you have to make sure, that , , and return the same result for any two given objects. At the moment they don't, and that's a huge problem and a source of future bugs. You will also have to implement method properly. It should return the same value for equal objects, implementation won't do.. I think you should make your class immutable if its possible. Is there any reason, why method has to be public? 

Also note, that Dataflow blocks can be converted to Rx observables with extension methods, so you can combine those frameworks. 

I feel like too many things are missing from your implementation API-wise to consider this code useful in general case (as public part of a framework that other people will use). Pieter already made a nice list of what is wrong. I can only add that: 1) There is no method. If I register a disposable object, how can I safely dispose it, if a reference to it is kept for a lifetime of ? 2) There is a lot of code duplication. For example this code: 

I would move lot more closer to the area where it's modified, so it can be easily seen with eye, where the whole block is, and span over fewer branching points (which is always error prone, to keep correct stack across some branching). You can actually surround just few instructions with , not having any branching at all. 

performance ideas (from comment): If you are already assuming ASCII alphabet-only word inputs, you may do direct , which will yield only values, and for vs it will produce the same values too (functioning as fake ). I also personally prefer non-else/non-nested variants (when they make sense), so I would do and the would go after that in the loop block. This is part of answer is level golfing advice, i.e. lowering readability and robustness of source for some hypothetical performance gain, not suitable for real world production code ;). 

how to use the result of (which has to be done anyway to test remainder) as approximation of suggested sqrt(input) test, for earlier exit. used to set zero into register (shorter opcode than plus modern CPU recognizes it as idiom of "set to zero" and optimizes for it) to check if remainder is zero (shorter opcode than plus modern CPU will recognize it as idiom of "test for zero value" and optimizes for it) resolving even numbers at the beginning (even numbers have zero in least significant bit: . And the only even number being prime is , no need to test other even numbers by . but that means only odd divisors have to be tested in the loop, because for sure. So my loop is testing divisors 3, 5, 7, 9, 11, 13, 15, ... some non-trivial usage of arithmetic instructions and flags to check for input values ahead of loop, as those would break the loop logic and produce invalid result. It may be nice exercise for you to "decipher" how it works. you should try to keep things "together" (if possible). For example you set up for at the end of your loop code block, so it's A) not together with , interleaved by (hard to read for human, no problem for CPU) B) you have code duplicity (), because you have to init the register values ahead of very first separately. => So I do initialize right ahead of , only single time in code, and it's easier to read IMO.