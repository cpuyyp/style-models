For file IO, the way you're currently doing it (saving after each add/remove) you could add it as part of : 

Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload. 

I think a plugin architecture would be a little overkill unless you're interested in versioning or deploying the sub-modules separately. You haven't shown the sub-modules (the actual solvers) but I'd probably define an interface for them and then use a instead of the statement. Really, it's pretty minor, but I see a couple of advantages of the : 

Now, we'll need something to keep track of the inventory levels. We could use a simple for this, but let's go ahead and abstract it out into an class, so that we'll have a place to put some convenience methods. Since we know we'll need to be able to remove an item by name (not caring about the price), we'll need some help to find that entry. We can also add some convenience methods around adding a product. 

Now, each filter simply takes an input and transforms to an output. We need a pipe to tie to it all together: 

You can over the directly, getting a . Or you can over and just get the . Either would be preferable to going over the just to get to the (and you don't check the return of ). I'd also change the name of your variable since the trailing implies that it's multiple dictionaries (FWIW, I'd probably go with just just so I didn't have to ever read a potentially offensive word over the phone; but that's just me!) 

I'd advise that if you're looking for 100% compatibility with here, you'll probably want some extensive unit tests. Here's what I came up with that handles the edge-cases I threw at it, but I don't expect it's bullet proof either. Main changes are using the format specifier, and using to get the number of digits before the decimal place instead of . 

first element is 19, since abs(20-19) = 1 is the nearest distance to 20. let's find 19 in the sorted array: 

It's not clear to me what are and ? If these represent the radius values (like C1-P1 line for ), then perhaps (and ) would be a better name here. I'd create and use a data class for each point-radius pair. Say, class with and or something similar. I'd separate constructor and results. The results are calculations that should not be part of the constructor. Take, for example, the class named in .NET: you can construct it, change the inputs, and only when you call the property named - you get the calculated uri. The same should apply here, too. Constructing a class gives us an instance with a valid state. Calculations - in their own methods or property-getters (that are practically methods, by the way). So should be the returned type of a method (or maybe if this pattern apply here), and not part of the class' state. 

Having so many operations -- seems like you'd want to use some kind of a factory, injected in the constructor, or the instances themselves injected in the constructor, instead of constructing the classes inside the constructor. 

Naming Consistent: might look better if it becomes Accurate: perhaps could be used instead of , since init means some kind of a setup, while the method actually changes the array's values. In addition, perhaps the class' name could be changed from to , which, at least in the aesthetic aspect (to my own eyes), looks better. 

I wrote a simple class in Python, which controls code invocation, in a multi-threaded environment, with the following logic: The class' main method, named , takes two function pointers as arguments: and . In any point in time, only a single thread can invoke code the function passed as argument. If a specific thread tries to invoke its code, but some other thread is already invoking its code, then the is invoked instead of . If there's an exception in the code being executed, it should raise to the calling context. The code: 

First of all, it's very good that you read about the evilness of . Avoid it at all costs :) As for your solution, it's not thread safe, in terms of functionality: Thread A tries to add an object to id = 123. Since this object doesn't exist, the returns , so the false part of the condition takes place. Then Thread A acquires the lock and starts to add its object. However, Thread A hasn't yet completed its processing, and the system now switches to Thread B. Strangely enough, Thread B wants to add its own object with the same id = 123 (!). And, what do you know, since Thread A hasn't finished its processing, Thread B asks if the dictionary and gets . That's the problem. Even worse, when Thread B starts its processing of adding the object, an exception would be thrown, since there's already a key assigned with 123. So, no, the suggested code is not thread safe. That's a classic race condition. How to resolve this? Option 1: Double check on read operations Inside the lock, you can call again to the , which is a read operation. MS provided a cheering statement, that read operations on its data structures (dictionary, list, etc.) are all thread safe. Update: from MSDN: A Dictionary can support multiple readers concurrently, as long as the collection is not modified (my emphasis). So please ignore this option. Option 2: Use ReaderWriterLockSlim Class This class is optimized to the scenario of multiple reads / seldom writes. So when you want to write, you upgrade your lock to have "write" scope, and you continue your code. Option 3: Use a simple lock on the entire method. This is very straight forward. All options are fine, and my personal bias is towards option 2. Update: see also a related post at Ayende: Why is this not thread safe? Good luck! 

In this example, I pickup the data from worksheet 1 and drop it into , only to do some operations on my data, and afterwards drop the array into worksheet 2. Notice that after I call .UsedRange, I don't access the worksheet again until I am totally done with the data. Unfortunately with some things you are stuck (like .NumberFormat'ing ranges) with accessing the worksheet, but otherwise if you stay away, thing will speed up DRAMATICALLY. 

I am setting the value of the dictionary to but I could just as well set it to anything (we don't care about the value in this case). What we do care about is the key. After doing this, you will have filled the dictionary with just the unique list of items in the matrix. After this loop you can just call to get an array of the unique items. You can then sort that array however you like. *note that to use Dictionaries you will have to add a Reference to the Scripting library. -- so for example: 

If you want a list of unique members of a matrix (or 2 dimensional array), one good option is to use a dictionary (vba's hashtable/hashmap). Since vba is lacking a 'set' data structure, a dictionary will do the job just fine. if you have a 2 dimensional array (or matrix), you can just do a for each on that array. 

I can tell you what you can do to make your code run between 60 and 100 times faster (and maybe much more depending on what you're doing)... but it will require something of a rewrite. In short: never access workbook unless you absolutely have to (including all it's child elements, worksheets, ranges, etc.) . Instead, read everything in as an array, and do you changes on that array. Once you are done, redrop the array into the worksheet. 

few things that come to mind on a quick look: You might consider naming this something other than "Copyinfo". If it is archiving transactions, for example, you might name it "ArchiveTransactions". If you do decide to stick with the name, you should go with the Pascal Case version: "CopyInfo". While you're at it: it's always good to specify public instead of leaving it implicit. You don't need to do , you can also do or just , or (and most simply) . I like putting things in With blocks (although many people won't for just two things) because I like reducing code duplication. As for the syntax with the statement... If there is an , it should be on multiple lines, in my opinion. The way you had it above with the line continuation seems to go out of it's way to stay on one line (which, it doesn't anyway!). Clarity always wins over conciseness on my book. If you use as shown below, it will eliminate the screen flicker that can happen when you switch sheets, as well as speed up the performance (which, since this Sub doesn't do a whole lot, performance tuning isn't necessary). 

Just a direction, not a full solution, but anyway... If limited by space, you could directly calculate each item in the matrix, given its indexes and N. So eventually you could have a function with the following signature: 

Without reviewing other aspects, I think you should separate the code so that there's the server itself in its class (or, maybe even better, its own project), and there's the UI. For instance, you should not show a MessageBox inside a server's code. There are so many reasons for that so I'll just leave this statement as is. In other words, the server should behave as a black box, returning error codes, or throwing exceptions, or anything else, according to its own API. Mixing the server's code with UI is not a good practice. 

What if the script renames file "a.zip" to "b.zip", and both files "a.zip" and "b.zip" exist in the same directory? 

I believe should return something. The returned value of might have a special value of in case that one of the s calls failed (this scenario should be covered by the code). In the implementation of extend - consider using instead of and manual copy. If you insist on perhaps using might be more elegant than a manual copy. I'd move magic numbers to s: Initial Capacity (hard-coded to 10) and Growth Factor (2). Alternatively, they could be parameters to the function How would you free this struct? Perhaps you should add a "destructor" to be called before calling with the struct pointer as a parameter. In terms of functionality, other than printing this "array", how would the consuming programmer could get (or set) a specific item in this "array"? 

From the algorithmic perspective, I'd like to suggest another solution (regardless to Python as a language). Here goes: let's assume that all items in the given array are different. the other case has a similar solution, so let's focus on the algorithm itself. 

Find the nearest number, in terms of distance, from the array to the given external number (20). sort the given array. find the value in (1) in the array. it can be done using a binary search. now, to the main point: the next value would be either to the left of the current value or to the right of the current value, since the distance is now between the next value to the current one, and the array is sorted (!). so all you have to do is to hold two additional indexes: inner-left and inner-right. these indexes represent the inner boundaries of the "hole" that is being created while constructing the new list. 

The math behind this function is not that simple, but it's not that complex, too: You should calculate the shell's index, according to , , and . Then you should calculate on which side of the shell are and ("North", "South", "East" or "West"), and calculate the "distance" (in steps) of the current item from the shell's start position. All this is pretty much mod calculations. Once this method is done, you could simply write a nested loop (N by N) with and , and print the function's value, without having to populate a matrix before that. The calculations in the should not take more than O(1) (in space and time), so eventually you could have a solution of Θ(N) in time, and O(1) in space. Just an idea, though.