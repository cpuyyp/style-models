These sections seem to be repeating again and again. You could make them into a method like above, and call it instead of repeating them. 

Smaller width lines if you can :). It helps, and it looks good. Also make use of case in these cases. 

Some changes to your code, First, your code didn't handle the case of empty list very well. This was why you need a complicated merge. (Also, the operation is not really a merge. A merge kind of means interleaving.) 

Please spinning it to a separate function. Here is what I think is a little more simpler implementation. 

As you can see, has a different type than the expected . This is the reason you cant use there, and why we have to do all that above. Note that my statement is really same as 

The same program with a few changes. first, try to refactor your functions so that they are small, second, Often, using a case statement is more clearer to using cascading ifs. third, 'using namespace std' is a bad habit. It is probably ok to use in a small one off program like this, but avoid polluting your global namespace in larger projects. And avoid magic numbers when possible 

Edit: Why is this better? Because unlike other approaches it never modifies a variable that is assigned once. Thus it preserves the referential integrity. That is this is a functional programming approach in comparison with others which (as of now) follow an imperative model. The succinctness that results from it is just a bonus. 

Here, while it may look nice, the method clean_hash is not general enough to be valid across all Hashes. So adding a method such as clean_hash to all Hashes would only serve to increase the coupling which is bad. A second problem is that you are mutating your method argument which is almost never advisable. The solution is to define the method outside, perhaps as a part of your internal API object and call . I would also define the clean method this way 

These few functions are tight. There is nothing more to be done with them I think. However, it should be noted that Entry and Directory have complementary functions everywhere. Perhaps it is profitable to abstract the common skeleton. 

Consider doing this at the getopt stage itself. That is the right place to ensure correct number of arguments to each option. I would also consider just printing usage if the number of arguments do not match. 

If you have a large number of such conditions, it may be just easier to use arrays for the same, (as in the above comment) 

Readfile shouldn't really say that a file if it does not exist will be created. It should just read the given file and return the value. The check and warning should be done elsewhere. 

I think this is better than repeating the state@ again and again. I think the below might also be nice since it is avoiding the repetition of foldexpression 

A possible suggestions. By looking at your data, I see that the difference between the strings may be small. Since Levenshtein distance is a costly metric, it may be profitable to compute some other easy metric such that it is not too different from what may be obtained from Levenshtein metric, and use it to presort the arrays. Once you have presorted them, merge the arrays together, and find the neighbors with in a delta range. For these, you can compute the Levenshtein distance and verify. Possible metrics to use for pre-sorting include 

stopWords is clearly a constant. So take its construction out. Also see that a set is used. It makes the member operation cheaper. 

I do not know much about performance of each versions because GHC has various optimizations built in, and I have not kept up to date with them. The best option for checking that is to benchmark the code in question. Here are my updates, 

Note also that I used an array slice notation that means all the values from in the array This is a rather nice for loop. If you are feeling more adventurous, you might want to look at list comprehensions. That is another way to write these things without using loops. edit: corrected for enumeration 

One suggestion is to make the roles two classes, initialize them based on the role and call the save function. 

Why do you use a separate match? Also name j some thing descriptive. And why \w ? Do you want to catch spellos in hint? 

Since you have written it for practice (as indicated in your comment), and has been implemented in various platforms in rather similar manner, I assume that you want comment on the function behavior itself and not specifically whether it conforms to the POSIX function. I am aware that the second function strlcpy handles many of the criticisms below, but there is no indication in your question that you have considered these. My first problem with the is that it allows no indication of failure or indication of any behavior even though there is a possibility of a few different behaviors that the user may be interested in. 

Regarding your problem of performance, time the program with the itertools permutation output alone (without dict checking). My guess would be that the permutations is taking the time, but it would be nice to verify. You may also want to check where the valid words are getting filtered. (Since you say that not all the words are being output). My guess is that permutation produces them but is not present in the enchant dictionary. But please verify. Here is a possible rewriting of your code. It removes the redundant sorts 

Avoid incorporating io statements with your logic. Refactor so that logic is separated to another method. Regarding your assertion that code changes have to be made if you change price, I do not see why. You can read the information to construct a country from a file and thus avoid hard coding it in the main file. However, this does not change the design as a whole. 

I suspect a simpler approach would be to just join the tokens together to form a sentence as string, and then use list of regular expression patterns to substitute each case. This will reduce the complexity, and will be much more readable than your example. (I will flush it out later.) pseudocode: 

Here are some comments. - If you are only @page as a way to communicate with , why not make it a parameter? 

Note the use of , I feel that it is better to do this than to distribute the cleanup code every where else in the function. Now, observe the functions below. Another way to do them is populate them into a table rather than defining function wrappers as below. An advantage of that approach is that, you could avoid defining too many helper_x functions. 

I suppose you feel that foreach is a kind of a map, and that inhibits you from exiting in the middle. In most code that I have seen, the first form is preferred except in the cases where we need to get the index where the break happened. i.e This is ugly.