Conceptual Problems You have hard coded the animation FPS as . This is a big no-no! You are assuming that your code will be called exactly with exactly intervals. But you are using which is: 

I found myself in need of a fixed size queue and decided to implement one using a ring (cyclic) buffer. I have tried my best to match the API of with the addition of to test if the queue is full and unable to accept another element. The code compiles cleanly with: , it runs and all tests pass on clang 3.9.1. Unfortunately at least GCC 4.9.4 and below cannot compile the header file due to a bug where a specification can't refer to a member. All comments welcome. File: 

You have already pre-allocated all the objects in one big block, allocating objects from the pool thus bypasses new/delete (or malloc/free) and the risk of page allocations and all that fun stuff as we have already forced the page allocations on initialisation of the object pool. Hence allocation and de-allocation is typically faster but more importantly more consistent in time. All the objects are contiguous in memory. This reduces memory fragmentation and improves cache coherency somewhat if you access the objects frequently. 

Performance (Without any profiling data, I'm guessing blindly here) You have a linked data structure (a tree), traversing the tree has poor cache locality and this is where your performance will likely suffer. Because every node could be a cache miss at worst. But please do measure this first, if you see that most of your time is spent getting the next node or close to a line of code that does, you're having cache issues. One thing you can do to try to improve your cache performance is to encode your tree into a linear sequence ( preferrably). And then measure to see if it actually is faster. As for the encoding, we'll refer to a level of the tree as and the root has . This means that the level has at most nodes. If we refer to each node in a level by it's grid coordinate then the node (at level and position ) will have it's child nodes on: 

the inner most 3 lines of this code may be executed at most times. Provided that the inner loop will complete in say 10 instructions and you have 3GHz CPU with 5 IPC, the loop will take about: to complete so I'm guessing the statement reduces that by about 40-ish%, give or take. I don't believe that you can make this code faster by optimizing, and there is nothing that's inefficient in your C code. You have to approach this by changing to a better algorithm. I unfortunately don't have time to help you with that right now but I hope that I have at least pointed you in the right direction. 

in the template context denotes a forwarding reference (universal reference to some). And will take the correct type depending on how it is called. Edit You should also properly forward the argument in the node constructor: 

is undefined behaviour. If the object has been destroyed, there is nothing that says that will have been set to in fact I'd wager it won't. At any rate as your waiters are reading from you need to inhibit destruction of until all waiters have returned. Otherwise you risk reading freed memory. You should initialize all variables when they are declared: 

Overall I don't see any major problems with the code. There are some things I would change though: Write unit tests. Whenever I deal with mathematical classes, I think that it is obligatory to provide unit tests to verify correct computation and computational precision. Add JavaDoc Please add a JavaDoc to clarify whether it computes sample or population statistics. Add comments The use instead of in the look ups to has a significant but subtle difference that is easy to miss if you're not an expert. I would add comments to clarify this (you are correctly avoiding and getting different counts). Use Since Java 8, which we have to assume is wide spread by this point, you can replace: 

Naming Looking at I would prefer the name as it's more descriptive. Design I would much prefer a design where the class doesn't expose its internal data structure but rather has member functions to manipulate and traverse the tree. This is a big rewrite so I will not do it here. In any way, objects in C++ should be constructed as close as possible to their final state, as such your method should actually be a constructor to . The syntax for adding children is a bit weird, why should I have to know where to place it? It's a binary tree, I would use a class for a binary tree to avoid having to do all this logic. You should simply have a method instead of the etc. at the top. It's common to have the section of your class at the top because this is what your client will likely be interested in, instead of forcing them to scroll through the implementation details. More memory leaks You need to have a destructor on to remove the root node when you're done. Use Also in C++ we have a dedicated boolean data type , prefer to use this over returning in an int. So the signature for your class should be something like this: 

There are a few problems namely that you the value of to . If the universal reference of has bound to an r-value reference then will have the same effect as and thus is not required to contain a valid task for and if it is added to a queue and subsequently executed you will have undefined behaviour. You must only a universal reference exactly zero or one times. Closing remarks In the current implementation I cannot see how this multi-queue could be more effective than a correctly implemented single queue. But I would love to be proven wrong by benchmarks with source code. 

this condition will always be true. And you are never removing from the list (if you were, you would get a . So the check is wholly redundant. So you loop over all of the futures in and call on your . This doesn't make sense to me, if you're going to call use a loop that describes what you want to do better. This is further strengthened by the fact that you never use the loop variable. Maybe something like this: 

At this point I feel that further review of the code is pointless from my part as the above already highlights problems that would mandate a rewrite that would make further review obsolete. 

For the love of don't use . You're teaching the students bad habits! If you want to show your students the awesome power of parallel computing, pick an inherently parallel problem. Like computing a Mandelbrot image, or compute pair wise edit distance of a large dataset of strings or compute character frequencies of a large codebase. Or brute force a password or something, there are endless embarrassingly parallel problems. Pick a real workload, and show them a real use case instead of a contrived example. Edit: Why is use of bad? First of all we should carefully read the the documentation on where it clearly says that: