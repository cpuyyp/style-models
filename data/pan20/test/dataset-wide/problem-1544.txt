Next, transform comments into code if they're explaining what the code does. Specifically, this bit: 

That bit of code. So what if we made a function whose job it is to tell you whether you should? Something that could give us this: 

Polymorphism failure. Determine who is responsible for deciding what the output is supposed to look like and go from there. If the feedback is responsible, just implement and overload . If the printer is responsible, find a way to get most of the detailed information into the interface. 

Naming is a poor name for a boolean array. I have no idea what stands for. How about ? Array ordering Additionally, the order of the tiles seems strange to me. It's ... . Without the image, I don't think I'd have gotten it. (For those wondering, it's non-diagonal, starting bottom, counter clockwise, then diagonal.) Any particular reason you have this layout within your array? Magic numbers Continuing from my previous point, this can be solved by naming the directions in constants: 

That's the first part. But you know what? If we were to assume that you'd wrap your code in functions, it doesn't make complete sense! 

Java 7 comes with multi-catch: You can catch multiple exceptions with the same code block. By using it, you can change 

That part should really be a separate function. You're doing all that effort just to get . Similarily, doesn't need to be a local variable, as you're never doing anything to it. 

but it doesn't. The return statement means that there was no way for args of length 0 to go past that if statement anyway. You'd be better off making it more explicit: 

Unless performance is somehow critical, you'd do far better by just making use of String.Split on '1' after getting a binary representation. Then you can search for the longest string in that array. The current implementation is very low level and hard to easily understand. A programmer who sees the code as it is now would have to invest time to understand how it works, whereas relying on (even if slower) a few library calls can make an algorithm easier to understand for programmers, thus being of more value than the faster, low level algorithm. It's also faster to write such things and less likely to contain bugs because most of the actual work is done by the standard libraries, which are thoroughly tested by other programmers. 

Obvious comment, and thus not needed. What's for? That's something I'd like to know, but that part of the commentary is missing. If I go in blind, I'll get an back... telling me that my are invalid. That's ... not helpful. I guess I could read the nested exception, but it'd be great if you were to describe the constructor arguments in greater detail. 

See answer 2, but beyond that... the design you have right now, it's okay. It'd be better if the actual IO and the user interface were separated from the logic, but that'd have costed a bunch of time and I don't know the requirements for this code. If the goal is for you to learn something, then it's possible the code is done when it gives a compile error - something which for pretty much any other goal would mean that you're not done yet. So, in this case, is it a bad design because it doesn't allow for easy internationalization, or is it a good design because you did all this so fast, rather than spending several hours on something which was just a learning exercise? 

More... table... stuff. Unclear what it does. It's separated from the other table setup, but it seems like it belongs with the column adding. Possibly wrap the table setup in a method anyway? 

If you build the string that changes dynamically, you'll have a much smaller section of code. You have 4 different things that may or may not be included in the string: - replaced substitutes - removed substitutes - delay characters - triggers replaced and removed substitutes are exclusive to each other. (but you can also have neither) Delay characters and triggers are ALWAYS in the string. So if you write 

i inspired of @MAG alternative solution, i re-implemented it in recursive way by providing template parameters. as following: 

Here my attempt solution, it works as expected, i have slightly change the input to make it interactive. All inputs are guaranteed to be valid and correct as well as the result. How can I improve it further. 

In your evaluate function, it is fine but not efficient doe to the call of std::string constructor in every iteration along with deleting un-palindrome elements. it is better to create another container for palindrome elements and check the main container elements if it has palindrome element. possible implementation: 

Your code looks so good, it is quite impressive of you were learning c++ few days ago. i'm sure you will get a decent code-review but here my humble attempt. It always preferred to pass the by const reference if you don't modify it. also, std::vector is preferred over std::list. here link for more details In your read function. It redirects all input into this container until EOF is received. However, the used container might need to reallocate memory too often, or you will end with a exception when your system gets out of memory. In order to solve these problems, you could reserve a fixed amount N of elements and process these amount of elements. here an alternative example to your read function by using and like so, 

@Incomputable provides a comprehensive answer i would add small alternative approach by using std::stringstream as shown below, in order to make it accept a delimiter rather than whitespaces and escape characters, it needs to covert the given delimiter to acceptable character to std::stringstream object. 

I wrote simple generic function to check if any STL container has an element. It seems work fine. I have tested it with VC++, GCC and Clang compilers. It works perfectly. How can I improve it further. 

i have made a simple sudoku solver which is a puzzle game where the player has to figure out the empty cell and checks which numbers are absent from the corresponding row, column. how can I improve it further? 

you may consider implementing your own as in STL in order to remove duplicated from since its algorithm is quite easy. so would be like this 

I have created mini-opengl program that draw simple chess board on screen by using SFML windows model only. The program runs fine. The main purpose of this program is to keep it as simple as possible and it is not rely on any of OpenGL helper functions like or for converting coodinates. Also, it is not using any external library for loading textures. I would like to know how can I improve it? 

Based on previous question i implemented most of suggestions. also, i have added Alpha-Beta pruning to minimize the calls. and making the game more generic to accept the board to be any value like 4x4 or 5x5 etc, every thing looks working fine for 3x3 board but it becomes so slow if i choose the board to be 4x4. how can i improve it further? 

i have rewritten a vector classes similar to the glm library which is used mostly in opengl application. i would like to know how can i improve it further ? Types.hpp 

here is equal based on the if it was converted to string size. also, will be always equal . i don't think you need it here. use where it is possible you have few candidate for it like , and . also in for-range loop it is better to consider it for optimizing purpose like so, for since you going to use it often in your code, it will be nice if create std::string object for it. 

thanks to @screwnut for suggesting to instead of for-range while the for-loop is bit clear and simple. but std::copy_if will allow us to use lambda instead of calling function, that might be helpful if you simply write it like this: