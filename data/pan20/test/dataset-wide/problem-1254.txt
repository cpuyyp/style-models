but already has a more useful return type than it has an which is giving you error messages instead of so we can adjust. 

if I am not mistaken (I have no haskell env on this machine, therefore this code is untested - sorry) 

And secondly, please use type annotations for top level functions - it is so much more easy to read and reason about your code, and the type checker kicks in. With any decent editor you have a syntax checking plugin to help you prevent errors, in vim it is Syntastic I know, others like emacs should have one too. Now for the matter of complexity, just start simple - all simple functions. is a great example, too. almost everything you put into your big function can be extracted. This makes it also easier to write tests for your function and not be bugged with , but have automated tests with or , so if you change any funcitonality it can be tested and you know where to look for bugs. It is really hard to find a bug in a 200 line of code function, but in 2 lines of code… . And try to restrict yourself to 80 characters of textwidth, as for example here on stackexchange you have to scroll, code with more than 80 characters per line, which is annoying, and easily solved. Next thing in Haskell it is common practise to use CamelCase instead of underscores. And please use names in your functions that are a bit more self explaining. Today editors help you with autocompletion and your harddrive has no problem with a few extra characters to memorize. for example, or , I changed a few but not nearly enough. so here is what i have corrected by now - it is not a complete but a compiling code i think. 

At first you do not litter namespace with global functions !!! Not at all, you just make a module and snap - no namespace problem - export only your function of choice and noone will care if you have a thousand helper functions. You do this with: 

one obvious change would be to add type signatures, i additionally introduced some type synonyms to distinguish between all those . A bit explanation could be done towards the algorithm - I don't know what it actually want to achieve. I am no programmer so the non understanding comes quite often. Next thing is it seems is never used - why is it there? and I've replaced by length and converting the result - as the library says length is faster. 

Unfortunately, we can't just say (nor, for that matter, ). Here's a solution I came up with to allow a single definition of in the presence of this. I've simplified a little to reduce the amount of code, so is and we assume all values involved support plenty of operations. 

To address the question of being too long: let's reformat the code a little and change the name appropriately: 

Your code does not work: $URL$ Just like calls to virtual functions in a constructor call the base class function, such usage of typeid also does not recognise the derived class. You could have the constructor take an and assign that to . Alternatively, you could be pedantic and claim that the instance of will always be an instance of , and that the derived classes are simply accessing this instance when they do . I doubt, however, that this would be appreciated. 

I know I am currently using a simple algorithm for the binary search tree which will not auto-balance the tree. I'll take a look at fixing it once I'm sure this way will work. I'll also be splitting out the functions so that they class definition is easier to read. I'm also aware that I should add a getter of some sort, but I have no need for it and don't want to complicate the code any further. Questions: 

Yay, you know about how to initialise objects that don't have a default constructor. That's a handy thing to know, and less common than I'd like to see it. Notice that we don't need the cast any more -- in fact, we don't even need to explicitly call s constructor. That's because can be constructed from a , which converts to. (If you're curious, isn't itself -- it's .) You used here, but there's no need for that. You can just output a newline character, and it'll get printed eventually -- makes sure it gets printed immediately, but unless the program crashes, it'll be outputted equally soon without it as far as the user can tell. 

When there's only one function that calls the function, the added benefit is significantly less; we end up obscuring what exception is thrown and losing the ability to rethrow if necessary. If this is all insignificant, a try function may be worthwhile; however, I'd use it in reaction to a common pattern, not in anticipation of one. 

Since the way and are passed into the function and used don't really allow and to be modified they can be treated as local variables. 

Make it as Close to the Real World as Possible During Testing If you are testing performance, then it would be better to actually do the malloc or sbrk here. The system call sbrk is what malloc calls for memory, or it did in the Sun OS and Solaris versions of Unix. This would provide a true measure of the performance of the algorithm. 

An else clause can be added at a later time if it is needed. The if portion of the current implementation is meaningless and would be optimized out by the compiler. 

Using a state machine is generally a very elegant way to parse input. This is actually how parsers generated by YACC or Bison work, and it's also how lexical analysers generated by LEX work. It allows the parsing to be more flexible. Generally the variable names you used are quite descriptive and makes the code easier to use, the one exception is naming the matrix A. Things That Would Have Improved This Question It would have been much easier to review this question if the following had been provided: 1. The definition of the . 2. The header files necessary (, , and ). 3. If the 2 different versions of had been separated and included as matrix_fill1() and matrix_fill2(). 4. If the program had been compiled using and all warnings addressed prior to asking. I have included the reformated code that allowed me to compile at the end of my answer to show what would have made this a better question and easier to answer. During development of code it is a good idea to compilte the code with -Wall compiler switch so that all warnings are reported. The warning can also be treated as errors. The type size_t is not completely compatible with the printf() statements in the commented out algorithm: Parse2DMatrix.c:142: warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘size_t’ Parse2DMatrix.c:142: warning: format ‘%d’ expects type ‘int’, but argument 3 has type ‘size_t’ The matrix struct should be presented so that we could have suggested possible error handling, there are times when i or j may cause memory access problems because they are outside the scope of the matrix. The choice of types is interesting, I would have used double instead of float, and unsigned int instead of size_t. Error Reporting Rather than using and for this portion of the code it would have been better if there was an internal error handling mechanism providing a better description of the errors. Invalid argument is a little too general, "Missing { at start of expression" might have been more meaningful. Exit Versus Return Calling exit(-1) does not allow the code to clean up after itself, returning an error value allows the calling code to clean up any allocated memory and reset all items that need to be reset. If this code was part of an operating system or a daemon that calling exit() is actually not an option because you wouldn't want the system to crash. Switch Statement Without Default Case There should always be a case in a switch statement to handle unknown/undefined behavior. In this specific instance rather than having a in case of errors the case could have been used to handle the errors on the next iteration through the loop. There could be one additional enum value in the enum, could be a status type. Enum Coding Standards It would be better to call attention to the enumerators in the ENUM, and follow general C Coding Standards (UCSD has published this coding standard). By making the enumerators ALL_CAPITALS the code would be clearer and show that these are defined someplace. It is possible that the status/state might be used elsewhere so it would be better to define the enum type outside the function, and possibly in a header file. A better way to define the enum would probably be: 

Prefer to use RAII above ; you are already doing this with , so disposing of it in the doesn't make much sense. On the other hand, you are not disposing of that way and I would say that this could leak to (extremely unlikely) errors. For example, if was a property and threw, you would now fail to dispose of correctly. 

From a design point of view: yes, I'd say this violates the single responsibility principle. You have a method that not only does certain calculations, but also creates a if necessary. If creation has to be modified at any point, then you'll have many places to change that. (Unlikely if it's default-constructed like this, but I doubt it's that simple in practice.) It looks to me like should actually be a member function of . 

I would go with the third, with the second as secondary choice. The first mixes addition logic and comparison logic: it's not immediately clear that the zero is meant to exclude those objects, as opposed to giving a default for . The second is better, but it hides the point behind a lot of unnecessary syntax. The fact that you're working on and not gets lost. The third is even better. It can be conveniently read left-to-right, and all the information is grouped near what we're doing (condition is after the where, sum elements are after the sum). Personally, I would use 

I've been looking at ways to use asserts in programs that must do some kind of cleanup on fatal errors, and have arrived at the following pattern (PROJECT being replaced by the name of the project): 

This solution does not sit well with me. It looks like you're doing too much: checking how to take the input, taking input, and then checking whether that input worked all at once. Before looking at the code, though, it's worth asking whether this is really the interface that you want to provide to the user. The way you've designed it, it looks like it is meant to be run by a human, as the requests for input will only muddle the output in a script. Furthermore, spell-checkers are usually non-destructive: running it with the wrong input file or the wrong dictionary file shouldn't lose you any data. All in all, this makes double-checking with the user whether the dictionary file is correct questionable. It is also inconsistent: you do validate the input in that case, but don't in the case that both files are provided, so the user has to remember that if he intends to rely on the input being checked. My first suggestion is thus to change your interface: only prompt for things that are not already provided, and if you detect an error, report it and exit. Now to the code: you have a few cases where the program can go in an infinite loop. This happens if the user closes , or if the user provided two filenames via and then at least one failed to open: you'll keep trying to open it and will never be true. Secondly, you're using in most places, but use to ask the user whether he's sure. This will likely break if the user provides one command-line argument and then some file fails to open. Thirdly, the condition of your loop seems strange to me. Why use an extra that you then set at the very end instead of using or to get out of the loop, or, better, checking the condition directly? You can use a do-while loop if you want to save yourself one check, though I wouldn't bother as the performance effect will be negligible, while the code will be clearer. As for the switch construct: I'd use a helper function or two instead. The code is sufficiently small for it to be clear, especially with the comment, but I don't think it wins you anything over two function calls. In general, the function looks too big to me, but I've already covered that above. Last and least, mixing and is strange. I can't come up with any technical problems, but mixing two styles without a good reason is generally more trouble than it's worth.