Apart from that I don't see much potential for time-saving. Curious to see the measurement after that change... :-) 

The main question here is in the understanding of the business context: do you want the date of operation as an external parameter (I tell you now that I will have a withdrawal next Tuesday) or always as "now"? If it is always "now", create it internally like you do right now. If you want to test the result of "new Date()" to equal a given predefined value, you could either use Powermockito to mock the new operator on Date, or inject a date factory which you can mock. Apart from that, there are two problems with your naming which make understanding the code quite hard: 

... if you need to pass a local tmp-map, this will be more BiConsumer-ish in your case, but the idea should be clear. 

That is exactly what Sonar says: "... from which an application should not attempt to recover". Thus, if you catch Exception and NOT Error, yes, this will effectively terminate your scheduler and probably impact the DataStore. BUT: as Errors indicate a severity, where the VM probably won't be working reliably anyway (also see $URL$ this is exactly the thing to do: terminate the program, bail out, call the admin. When you continue working under error conditions, the result is generally somewhat undefined. Better avoid this. 

is only good for files up to in length. Files systems do not have that limitation. Robust code would use other methods to handle such huge files. 

Other idea: Consider prime values for Certainly here is a simple function and not truly meant to hash the highly uniformly across . Yet remember that if the hash calculation before the final is good, finding the remainder with any will be good too. On the other hand (OTOH), if the hash calculation before the is weak, using a prime for will likely to make it better. Example 

Constants Alternatives to declaring a global object. There are various pros and cons to these. What is best is to code to your group's coding standards. In doubt, go with the last, simplest one. 

The adage is cute but not universal. To zero a string, code only needs to . This is a performance issue in the general case - here is not a major issue either way. Best to follow group's code guidelines on this matter. If coding guidelines encourage initializing arrays, this is very usually accompanied with initializing all variables. 

Pedantic: Using this method with letters would make code more portable to more machines as to may not be consecutive. 

Here you can find a test script for the different pattern sets, (you can also pass a callable to the constructor instead of an associative array of pattern/replacements) and useful functions: $URL$ About ReDoS attacks: Except if you finally choose a pathological pattern and doesn't limit the size of posted data, I don't think it's possible to crash your script with your patterns set. It isn't so expensive to run, no more than any other script that filters and validates form data. Other thing, when a pattern is badly written it reaches quickly the backtracking limit, the script doesn't crash and a warning is emitted. You can even retrieve the error using . If you want to increase the security against DoS, start at the server level, with the apache settings. 

First step, start with a simple solution: divide all in simple tasks, keep the patterns short and easily understandable. 

Your code works well for all the cases. After many tries and tests, I obtain two different ways to write the function. The first comes from your approach with several changes. I have, in particular, removed the test for foreign characters from the main loop: 

you can perform every possible action and return a detailed result ("performed 'A', but 'B' was not possible due to...") you can validate the actions, and only perform the complete set, if everything was possible ("no action taken as 'B' is invalid") 

When you have this structure, you can simply check for each legal i and combination created. For counting, using a mutable integer object (which the base libraries lack) is the esiest thing, thus here I use an AtomicInteger to count: 

First of all, splitting the spliterator only makes sense, if both the remainder of the current spliterator and the returned spliterator still have work pending. In your case, this is (almost) not true, as you operate on the complete batches and the current spliterator at most returns its current batch after split. Thus, I'd replace the trySplit() with a simple return null. This also addresses any potential concurrency issues (which I have not looked into in depth.) Characteristics basically tell the caller the - for lack of a better word - characteristics of your spliterator. :-) I think for the batch approach you take, ORDERED, NONNULL, IMMUTABLE should be OK. Apart from that, for more direct utility, I'd rather take the approach not to iterate over the batches, but over their contents, i.e. create a Spliterator which gets initialized with the first ObjectListing batch and then transparently goes through the underlying collections element-wise and fetches the next batch as needed. This would eliminate the need to flatMap on the result stream and feel more natural for a streaming approach. (In fact, this sounds so useful that I'd like to have it :-)) 

This may improve performance a bit as it can allow various compiler optimizations Avoid UB functions are UB when as they are designed for and . As a may be negative, cast to to cope with this pesky C nuance. 

Tolerate ? Should functions tolerate - IMO yes, but a design decision. is tolerant of , suggest the same for . 

"length" with C strings typical does not include the null character. "size" usually does include the null character. Suggest name change 

"The user of the priority queue is expected to define their data type in the data.h header. This is to make the code flexible and not use void*." Code limits the types available to pointers to some . The definition mechanism requires a file - this is awkward. Strongly recommend a simpler direct approach and reconsider using . "The user has to provide a sort function." This is reasonable although I would call it a compare function. If one still wants to retain the approach, at least use a like name for the .h file, perhaps . The 16 in is arbitrary. IMO, an empty "bag" like this priority queue should use minimal space. Perhaps start with 0 and use as the initial allocation once some something is added. Consider using for function calls that do not change the state. It conveys codes intent better and possible allows some optimizations. 

Simplify: Getting a next day via an overridden method seems a little overkill. We know the stucture of an enum and we know that the constants will be put into a value array in their original order and have an ordinal() which corresponds to the index. Thus, next() would probably look like this for me: 

As to your compilation error: when you are working with final fields, each class constructor must ensure, that all fields are initialized. This initialization of all fields is the main point of the answer: deserialize the complete buffer once and then take all further interaction with the answer frame back to object level. 

Mutable double array in the interface. Yuck! This is unclear, hard to read and generally leaves a bad feeling. As you only use it to calculate a single value, try to refactor this to method return values and somehow combine the results. A single discount strategy. While this may solve the problem posted in part 2, you don't estimate the future development here. What if the shop wants to keep the discount on apples but cancel the discount on oranges? They'll have to call the software guy again. This should be split into single strategies to make them individually pluggable. Global price map: while it might be true that this is a singleton in your application, you create an unnecessary dependency from everywhere to the concrete implementation. Better: pass a map to the strategies (maybe as a constructor parameter) to honor the tell-don't-ask principle. 

Note also that the escape sequence isn't a character nor a character class but an alias for or (depending on the mode). In other word is an hidden alternation. I build a set of patterns/replacements that fits your requirements to illustrate these techniques: 

First, is the literal notation of a RegExp object and not a string, is a string and nothing more. If you want to concatenate several strings to build your pattern and then to obtain a RegExp object, you need to use the constructor: 

The second approach is totally different and uses a regex approach. If it uses more memory (~3X) and is a little slower when you try it only one time with a little string (less than 10 characters), it becomes faster when you use it several times (whatever the size of the string) and is more efficient than the other way with long strings whatever the number of attempts. In other words, you need to pay the cost of the regex engine, but only one time. 

The main problem of your code is that you performs two replacements for each strings. Indeed when you pass arrays as pattern and replacement parameters to , the whole string is parsed once per item. These two replacements are not needed. You can avoid them if you replace all groups of characters that are not letters or digits with an underscore: 

Furthermore, check whether you can alter your transfer logic, so that you utilize the streams decorator pattern to the fullest. I imagine, that you could actually wrap the output stream into a digest ouput stream first and in a cyper output stream second, so that you need only a single read-file-and-copy-to-stream operation. (See $URL$ 

In addition to the answers already given, there's another problem with the Game class design. First of all, the constructor creates the Player and NPC by itself, which leads to tight coupling: you could not replace any of the parameters used in creation of the Beings without changing the game class. Better: let the Game take its participants from the outside: 

Variable scope In your loopUntilExit(), you declare the input String outside the loop - why? This should go to the minimal acceptable scope, that is in the line where you call sc.nextLine(). Law of least surprises I don't like abusing the toString() method to create a multi-line screen menu. This is not what I'd expect of toString(). Thus, I suggest you create another method to do this, and call it explicitly. One afterthought In 20 years of programming Java, I have never seen the use of Scanner in real life (TM). Is it really necessary, that every teacher seems to love this object and base their classes on it? Yes, it is simple, straightforward to use, and probably an easy-to-explore way to teach other principles without the input getting in your way, but it does not hold any practical relevance (at least as far I am concerned.) 

About special characters: , and are not special characters and don't need to be escaped. Note that is read as a literal character too, but only if it isn't the start of a quantifier , , . Except for these special situations, you don't need to escape it when you write a pattern by hand, but here it's easier to escape it systematically instead of testing if it is or not the start of a quantifier. (if the escape is useless, it will be ignored) Since you will use the RegExp constructor with a string as first parameter (Since ECMAScript 6, this parameter can also be in literal notation), you no longer need to escape the delimiter that is only used in the literal notation. You can remove it too: 

About the readability, no need to make things more complicated than they are, a simple comment before the line should suffice. Since escaping special regex characters is a basic task, and if you project to use it several times, you can build a function: 

(Note that when you pass a string to the RegExp constructor, you need to escape the backslashes, since to figure a literal backslash in a string you need to escape it.) ( is a method, not a method: ) 

Nice to have example usage in .h file. Suggest bracketing instead as it does not stop syntax highlighting. Pedantic: is the type to use for array indexing rather than . Code accordingly, remember that is some unsigned type. Namespace abuses namespace with , , . Suggest a more uniform prefix. is not too bad, but then use . Avoid magic number - why 30? Numbers other than -1,0,1,2 and maybe 42 deserve a macro or object. 

The above code also has trouble when: 1) is some character with values even greater than 2) When is signed and has a negative value. A simple solution is to create an array that is sized to all and to access that array offset by the minimum value. 

The name is a global object that could easily collide with other code. Its name does not suggest that is is part of the functions. Recommend a name aligned with the funcitons like . A use of needs special consideration. I recommend that such usage returns the same as to provide unique allocations. In any case, OP should provide documentation concerning the special case. is an optional type and not the best to use here. results in type , simply cast it to the destination type. Alternative: