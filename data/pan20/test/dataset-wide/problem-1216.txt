Then we declare the main method for getting the highest combination. I decided to make a line in four different directions for each point and check to make sure the line's points are in bounds before creating it. 

In , you can move the statement outside of the loop and get rid of the part, keeping the statements. You can also combine the predicates of the successive statements using . If you want, you can calculate the "constants" using a specified board width a edge width. 

A method would be useful and more efficient here. You can implement your own or find it in a library. I believe all the Project Euler problems have a solution that is a lot faster and more memory efficient than brute force. So you can try to figure that out for this problem next. For the later Project Euler problems, brute force is not an option. 

They are syntactically equivalent, so choose whichever you prefer, however the second one is more idiomatic than the first. As Paparazzi mentioned, you should use lower case for the first letter on your variable; in idiomatic C#, only classes, property names, names of structs, and enums should start with an upper case letter. Updated: added additional notes on what should be capitalized 

Break out of loops sooner This applies specifically to your spaceship and to a lesser extent to asteroids and torpedoes. Once the spaceship is destroyed, return. Any other collision checks are wasted processing time. For torpedoes and asteroids, once a torpedo has destroyed an asteroid, break out and move on to the next torpedo. This leaves a small edge case where a torpedo might perfectly hit two asteroids at once, so this decision is up to you. 

Surely is already defined as a attribute so why not read it from the DOM in the same way as ? Alternatively, simplify the HTML down to the wrapper and generate its content dynamically. The legend doesn't appear in either Opera or Chrome. 

All of which is interesting and potentially useful, but rather odd in some regards. [1]: is successfully and concisely coded. [2]: could be regarded as subverting jQuery. As it stands, the plugin leverages jQuery to provide an alternative way to bind methods to DOM elements, whereas we would normally expect a jQuery plugin to expose public methods via the jQuery interface and/or have private functions for internal use. [3]: could be inconsequential, useful, or a total annoyance, depending on the role of the plugin in the context of a wider application. [4]: you could consider a mechanism for user code to override the default selection of , eg by passing a selector in the hash. Out of interest, a more conventional jQuery plugin to achieve the same ends (with some extra features) might look something like this : 

Background threads tend to run at 100% CPU utilization unless you do something to prevent it. If your requirements allow for it, try adding a Thread.Sleep(10) (or some other number) to the code. 

Copying the array You are over-complicating the array copy. will copy the objects of the array (but not the object's objects). Using it on array of objects might be problematical, but an array of ints will be fine. 

Shorthand if/elseif syntax You can use the keyword in conjunction with and to cut down on the whitespace of your if-eslif chain. The syntax would look like: 

If you can't do that, when you start the new thread, try setting the thread priority to low or tweaking other related settings. 

Your code here is really just wrapping the Array class from the ruby library. As such, your performance will be exactly the same as just using Array itself. The array can hold as many items as you can hold in RAM and the performance will be determined by whatever machine you are running on. The ruby array class is written in C and performs fairly well. You ask about optimization but you don't given any criteria, so I can't really speculate beyond that. If you need something that is extremely fast or needs to scale across millions or billions of items, you may want to look at a different language or even a database. Looking at your code, you have several instances of the pattern . The last two are redundant and can be combined. For example, the max of an array with one item will be the one item, you don't have to break it out. Likewise for doing the average; you can average a list with one item and you will still get the correct answer 

To perform exactly the same manipulation on every member of a jQuery selection, jQuery will perform all looping internally. is only necessary when each member of a collection needs to be manipulated in some specific, individual manner. 

The expensive part of the opertion is finding the full set of qualifying TDs in the DOM, so you should avoid doing so more than once. 

If I was to make any changes to the code at all, the first thing would be to give the overloaded Controller (instance) namespace some internal structure. To make it clearer what's what in the rest of the code-base, you could put : 

I think you need the three inner loops but can get away with just two outer loops by moving the third inner loop into the second outer. In addition, I would choose to do as follows : 

When ruby does a regex match, any capture groups are assigned to the global variables , , , and so on. See this question on StackOverflow for more details about the mechanic. Note on your regex: If you want the capture groups to actually contain anything, you should change the asterisk to a plus: . Without the plus, "www.twitter.com/" will be captured by one of the regex. With the plus, that string will fall into the default case. 

After the worker has completed, it will call the event, where it will return its result (which should be the encrypted block and the block index. The event handler should write the encrypted block to the corresponding index in the output file, and then add the worker back to the list. Repeat until all the blocks have been processed. 

Calculating and can also be done using loops. There are LINQ methods to make this even easier. This requires . 

it won't get rectangles that are at the exact same X position. But that won't matter if it's guaranteed that none of the rectangles overlap. Then there's this code right after: 

In , you can get the product names before the loop and loop through those instead of looping through dictionaries, filtering, and then getting a product name each iteration: 

Why does have three parameters but only use one of them? should be declared inside the loop because it's not used outside of it. You can assign it on the same line that it's declared. 

You can get rid of a lot of repetition in by storing things in arrays and accessing them by the . You can set up your arrays like so: 

We now run over 1000 times faster, yay! Cleaning up the Code One of the reasons this question took so long to answer is that your original code is very hard to read. I'm going to keep your logic intact but clean it up some, just to make it look a little more rubyish. 

Function Wrapping Here is an alternative implementation, just for contrast with the other solutions. It needs a little work to be more robust, but the concept is clear. This version wraps the target method with a new method that checks the arguments. If all are nil then the default value is returned, otherwise the arguments are passed to the inner method. This approach's benefits include being purely functional and not being limited to just mapping; it could be used on any method. The disadvantage is that usage is somewhat ugly and not as ruby-like as one might wish. 

Then consider sacrificing readability for performance by not assigning what the terneries return. Instead write them directly into the expressions where the resultant strings get used, eg : 

You should recognize much of your original code but it's been shuffled around - refactored. Refactoring is commonplace. Even very experienced programmers find they need to refactor, and it's is an important part of their skill-set. It's seldom necessary to restart from scratch. 

In practice, you may define both plot-functions and filters either internally or externally. It's very easy to make mistakes when re-factoring to this extent, so I doubt that my code will work first time. Typical errors will be out-of-scope vars, and referring to the wrong object. Happy debugging. 

A separate reuse issue concerns everything in the vex dialog (, , etc), which is created afresh every time is called. Much can be created once per element (or maybe once in total) and reused by rolling some of into the constructor or the outer scope. Leave the resizing and part behind (and all the stuff I think). Also, the object is static. It need not be defined/redefined in the constructor. Global namespace There's no apparant reason for using the global namespace? If you really want (or an instance) to be globally available, then it could be assigned as a jQuery static method or refactored as a jQuery plugin? Use of jQuery Why not exploit the power of jQuery? Coding in POJS is very noble, but bulky and generally less readable. It's not clear why you might need polyfills for some portions of jQuery when you are already reliant on jQuery for Vex, which is a jQuery plugin. Others According to the documentation, accepts a DOM element, not an id. If the documentation is correct, the element doesn't need an id. Accessing and immediately after has been set might work in some browsers when an image drawn from cache, but generally not. Best to attach an handler and move much of the code inside it. is created conditionally therefore is not guaranteed to exist in the line where it is used. , and are confusing. Why make an alias for , then use ? What is ? 

The BackgroundWorker.RunWorkerAsync() and RunWorkerCompletedEventArgs only accept/return a single object and you need to pass two (the block index and the block itself). You will need to either use a tuple/struct/class or something else to hold both objects when passing back and forth. Finally, You may need special handling for the last block of the file. Some encryption algorithms (zero) pad a short block to the expected length (1K in this case). This means that your encrypted file may be slightly longer than your unencrypted file. If this is the case for your chosen algorithm, your allocated output file size may be slightly longer than the original input. Depending on the file contents, this may or may not be an problem, however you should be aware of it as a potential issue.