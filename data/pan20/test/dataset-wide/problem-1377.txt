Simpler solution. This solution assumes you are not using any libraries that manage listeners (but then you would not need it). To solve the problem execute the following at the start of your code. 

The variable holds each pixel as a 32bit integer. The channel order is from high byte Alpha to low byte Red. Eg to write a yellow you would assign an array item To write a pixel at a coord x,y 

Using to find the or empty string and then and to add objects to the stack. loop to iterate the values of each object. Pushing to the stack objects as needed. 

This controls how fast the numbers will increase per second. The animation will play at the same speed on all devices. 

Week start Day and Month week starts in The start of the week can be different for different people. To simplify the code you can set the start of the week (week day 0) to any day. 

Time not Date The best way to deal with dates is time in milliseconds. This is how JavaScript and most other languages deal with time, and is how a date is stored in Javascript. The value is milliseconds since midnight January 1, 1970, UTC. Once you are working in ms all date calculations are easy. ??? Your question is "Getting the remaining days of the current week" but the functions you call is yet the function does something completely different from both the question and the function name. I will go by what I think you want and that is a list of week days left in weeks that start in this month, excluding weekends, and holidays. I have also included a way to set the week starting day. So that you can start the week on any day, the example uses Monday as the start day. Some points 

The first call to executes the function immediately, this is not what setTimeout does. On the first pass should it not set a timeout rather than execute? Memory leaks? That would be up to the functions being called. Your timeout will eventually release any references that are held pending the timeout so you are not causing a leak. There could be memory problems (not a leak just running low) if there are a lot of timeouts and the delay between them is long, but not a real concern. Timing issues. You set the timeout after you call the function and do not account for the time spent running the function. The timeouts will always be late and any error in time will accumulate with each call by the amount of time the takes to execute (and any other page blocking events). The way to deal with this is to record the start time and adjust the timeout to be at the correct interval. That then introduces the issue of catching up to late calls. There are any number of ways the page can blocked making your calls is late. If late do you still make the call or skip it. If you make the call and the function you call is taking longer than the interval do you create a stack of pending calls? A quick rewrite As a suggestion only to demonstrate the use of closure to keep stats on the timeout and keeping track of the next scheduled time out, adjusting the time to keep things on time if possible (if more than half a interval behind the timeout is skipped) (though I did not test that) 

Minor style points and an alternative solution. With these types of problems the first port of call is always Wikipedia to get as much info as you can before you start on creating a solution. Two things stand out about the solution. 

but the following is quicker (note it should be defined outside the function but in this case you may only have the function's scope) 

Assuming you wrote to spec. I said above that your code was good not great. Lets assume you wrote the function to a specification that required the arguments and flexibility. What could be done to improve the function. Minor issues. The vars and should have been created outside the loop at the top of the code, or where they are as block scoped variables using . Performance is king In my book (and not everyones) if all things are equal then performance is the indicator of the best solution. The major problem in the code are the lines 

We only want this to play once. So remove the event from the button. When events are called references the element that triggered the event 

Frame rate control Use this if you have heavy and varying load rendering, i.e. game runs fine at 60fps but when some intermittent FX (That your game absolutely needs!!!) is rendered it drops to 30fps. You can use this to provide a consistent rate equal to the max load (95% of people cant tell 30fps from 60fps to save their lives) The implmentation is a bit tricky as requestAnimationFrame callback in not actually strongly synced to the display, only back buffer presentation is synced to display vertical refresh (time when the display hardware is not drawing pixels on the screen) Thus you need to use a little slack in the timing. To get a good picture of what is happening use devTools performance to see when frames get rendered (Note that devTools adds a little overhead so is not perfect picture of timing) 

Your function controls average rate not rate. Your function can let more function run than you want in the interval given. Say you have 3 calls over 5 seconds. The first call starts the timer, then at 4.9seconds just before the time interval expires, you call the function twice. Then just after the time interval expires (@5.1 seconds)you call the function 3 more times. Thus you have called the function 5 time in less than a second. The max rate you can call the function is per time to run each. You do maintain an overall average rate but you are not limiting the rate per interval. The solution is to track the time each function starts, adding the time to a queue. Each time you get another request to run the function you check if any of the previous runs start more then the limit ago. If so remove it from the queue. If the queue has less than the execution limit then you can run the function. 

You can compact a lot into a single line, but that is most times not the best thing to do in both source code quality and execution efficiency. 

Some notes (*) Called Object/s because in Javascript there are no "classes" only Objects. The class token is just a way of defining an object. (*1) Note that in some cases to such as conditional and loop statements (where you use conditional operators) it is better to define befor the statement variables that require operations. 

Inferred object type Or the ad-hoc construction approch can be called polymorphic using a factory function (or frankensteiner as I like to call from time to time) Objects are created from parts Each part on its own is barely a usable object, only together do they become a usable object (alive). The resulting objects are in a sense typeless objects that share polymorphic functionality. 

Don't test if not specified. The instructions indicate that the position of an opening parenthesis is given, not that you should test for an opening parenthesis, nor does it indicate that a parenthesis should be there. If the return is not defined then it is There is also no indication of the return if their is no closing parenthesis. To return a number is not correct as that is a position (negatives sometimes indicate a search from the end of a string) and you do not know what is to be done with the return value. The only valid return is if there is no closing parenthesis Never throw unless instructed to. Not in the OP's code but as the given answers show it I must say something. You should never take it upon yourself to throw if the instructions do not explicitly indicate that you should. Let javascript take care of any errors. The expected results. The behaviour expected is subtle but important, that the returned position is the closing parenthesis in the current nest at . This is explicit in the instructions. eg 

Your matching process is reliant on order to make matches, so i have done the same, but ideally it should be able to do it in any order such that each section would be independently matched and converted to colour without having to have failed a previous match. Noise Before the rewrite I will point out the only other bad point about your code, too much noise. Noise is code that is redundant, or superfluous, and text/comments that does not add to what is in the code and is in code making a mess when it should be else where out of the way. 

Example Your code was not bad, and the changes I would have made if DRY was not the considering option would have been just the win logic and remove the repeated click and end game functions. Your code after a little drying out. 

At the beginning of your function you define each image's but the function will only ever use one of them. Rather than define them all set the in the individual condition blocks. The same with there is no reason you need to do this, just use the reference or better yet . You don't have to wrap it in jQuery's code if not needed. 

Note V8 has made some amazing improvements over the past months. It always pays to test performance when in doubt. Rewrite The following will be about the fastest possible. the only performance increase you could get is using a typed array and implementing your own stack (which is worth the effort for larger array sizes) 

It was not until I read it that I realized most of it is completely unneeded. With identical functionality is the following 

And in the strict class definition it is no longer a true , it has been mutated. The mutation can make polymorphic like interfaces unsafe 

Alternative solution The following reduces the number of calculations to about half by exploiting the symmetry of each row. Further improvements can be made by using and pre-calculating the triangle size, then indexing directly into the array, avoiding the expensive array creation and and concatenation for each row. But that would only show any real benefit for very large triangles, where he need to hold all the rows would be questionable. 

Constants So many magic numbers. If you find your self adding the same numbers over and over it is a good sign that a defined constant is better. You never know when things may change. I.E. switch units from degrees to radians. 

For these and other reasons I have generally stayed away from SVG, but as the HTML canvas now has good support for the property, filling a MUCH needed hole in the API, I find my self writting SVG content more and more. So after having a particular nasty bug hidden in the mess of SVG code I decided to write the following. The code for review. 

Consider the image above, The x axis and y axis are defined as a 2D vector each with an X and y magnitude that usually defines the size of a pixel. The origin defines where in screen space the coordinate 0,0 will appear. You can define the axis as a matrix 

Simple conditions Make the condition statement as simple as possible. You had the additional not clause is extra work (if not optimised) is the same Use variables Some javascript engines (V8) are not as quick handling literal numbers. eg is slower than but you must take into account the declaration and assignment of the variable. If you use the number once or twice there is no advantage, but if you do it many time there is. Math rather than Loops Alway check to see if there is a way to directly calculate the result rather than use iteration. You do not actually need any loops Use memory Memory is cheap and fast, CPU cycles are not. So rather than iterate have a predefined object that can be used to create a result You have 

That protects you from cyclic references. Avoid recursion Because it is impossible to know the current call stack depth recursion in JS is fundamentally flawed. You should avoid using recursion if you can. In this case using recursion is a just creating (an expensive) stack for you by holding the previous objects on the heap. You push to the heap with a function call and you pop from the heap with a return. Old fashioned loops are still important. Seams everyone is transfixed on having to use the array iteration methods. One must remember that they carry with them a considerable overhead. This is even more important when you are using recursion to solve the problem. Each time you call a function you create a new context that is added to the heap. Because your function does not fall out of the recursion until the deepest iteration the heap usage can be quite large. You would not want to test a linked list of any size. Because you are using a callback to iterate the object you actually need to create two heap allocations for ever one object you step into. The net effect is that this function will keep GC busy and degrading the quality of the user experience. This can be done without recursion, but you need to replace the heap with your own stack. This results in efficient use of memory as you only need one reference for each object you step into rather than a complete context (2 context in your case). I have created two versions. 

Dont recreate DOM elements every time there is a change in the task list. When a new task is created create the listItem as well and store it with the task. When you create a DOM element 

Event if you want it in global scope. Use strict mode All beginners should have as the very first line of any javascript 

You catch all errors, not just the one you have planned for. Code running in the catch should always check the error and only handle the one you intend to handle, all other errors should be thrown to a higher level. As you have it you will consume all errors, errors that could cause problems later in your code but will not know about till way after it first threw an error. You are forcing the error via the function this is no guarantee of the problem being caught. I was at first puzzled as to why the was there as will do it for you, till it dawned on me, to throw the (incorrect) error. So not only badly using the try catch you are not using a standard method to throw a known error. You should have used and thrown a (I put "blah blah" because I do not consider it an error at all and have no words to describe it.) Major scope problem You will never get the correct result as is declared as scoped to the try block and the if invoked assigns to a new global scope . The only value will have after that code has run is as an undefined undeclared variable (Very dangerous) or as the global scoped