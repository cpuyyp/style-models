You are calling with a whose action accesses shared state (namely the local and variable ) without taking care of synchronization (a is not thread-safe). This is bad. might look like a simple for-each loop, but it is more than that, because unlike the latter, it might process multiple stream elements simultaneously in multiple threads, so accessing shared state without synchronization is dangerous. A safer approach would have been to use instead of . The solution proposed by Vogel612 for this problem is even more elegant, but, technically, it is not equivalent to your procedure, because your procedure doesn't create a new for every iteration of , as opposed to Vogel612's code, which assigns a new to for every loop iteration. However, the loop is probably a design flaw anyway, because as far as I understand your question, the input string is not supposed to contain multiple parentheses-enclosed "maps" (not to be confused with key-value-"mappings"). This can be rectified by using a single regular expression for the whole input string, as the other answers have already suggested. 

The switch statement might be more legibly written as a series of if else-if statements (with nesting), but that's mostly a stylistic choice. 

While the above solution works, it is somewhat inefficient and messy. This stems from the fact that you're trying to get javascript to work the way you want, when what you should be doing is trying to understand how javascript wants to work. Each language has a style, even a personality, and if you're flexible enough to go with it then your code will be shorter, faster, and cleaner. Here's how I would abstract away my JSONification. 

If you know every element in is truthy (not 0, null, undefined, false, or ""), you can use this loop, which is shorter and more efficient, and in my opinion more legible. 

Here's a second solution, which is slightly faster in Firefox, but otherwise between a little and 5x slower: 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with. 

Putting as little as possible in-between the user and the content they are requesting means better performance. Handle requests for missing packets If you want to automatically handle requests for missing packets, add a .htaccess file (or equivalent) like this to the css/js folder: 

The function invoke handles everything - there are 10 "actions" in it. Each of these if statements would ordinarily be a separate action (function) in a controller. include view That's not how views are rendered in CakePHP. Like that there are: 

There would be little point using the code as presented if it didn't make life easy, and not escaping any of the properties would make it cumbersome and error-prone to use. E.g. you've got this in the Testing section 

DRY - Write less handle more You can make your function half the size by designing it to work with scalar vars only, and handling arrays with a loop: 

It becomes difficult to automatically serve optimal packets. If each individual request results in 1 js file that is sub optimal, as the user receives one file per page, but the same content multiple times as they browser around the site. As such it's likely better to define all js packets in a config file and only refer to the packet names rather than permit dynamic usage. Appropriate Headers Whether you heed or ignore the above, this point is the biggest failing with the code as presented. There are 2 ways to handle headers for asset files (css, js images), the serverver and/or the php script needs to implement correct headers for optimal performance. Validation requests A short expiry is sent in the headers, the user sends a request and a successful response is either a 200 or a 304 - make sure to be sending 304s where appropriate. This means a user downloads the file once on the first request, and on each subsequent request for the same asset they receive an empty 304 not modified response. Not sending the user back the same file saves bandwidth and increases speed. Long expiry If the url changes when an asset changes - there's no need for validation requests and you can send in the headers that the response is valid for - e.g. a year. This means a user downloads the file on the first request - and never requests it again. Validation requests are a great improvement over no/incorrect cache headers. Long expiry is another significant improvement. Finally: Look for existing solutions You may find repos like this one useful, either the code, the docs, the api or all of the above. Try to avoid the mistakes that many have already made before you :). 

Judging by your comment, you already seem to be aware of the method , so there's no need to explain how to chain those comparators using this method. Unfortunately, the forth comparison stage does not fit into this pattern. Of course, you could ditch the nulls-first comparator and write your own generalized version of it which, instead of comparing the two values with , checks a given against the values: 

I think the main cause for the complications you mention is the fact that the state of a object can, in essence, be reduced to the s of the four subtypes of (by the way, unless you have a specific reason for the s not to be any implementation of but indeed an , you could declare these fields as s instead of s) and all other fields depend solely on these four lists. So you have the same property stored in muliple places, which naturally makes things more complicated, because you have to ensure that the different representations of the properties (i.e. the lists on the one hand, and the individual fields for each property on the other hand) don't contradict each other. A way to circumvent this would be discard the fields storing the individual properties and replace them with methods that calculate a property based on the four lists, like this: 

Note that there's no need to continue to the end once the answer has been obtained - this alone make determining the answer faster. This doesn't defend against out-of-bound problems, but it also doesn't need to. 

The backend mailer class is just an implementation detail of your own Mail class - it shouldn't be necessary to have intimate knowledge of such details, but because it's a mandatory constructor argument this is currently unavoidable. It should be possible to change the mailer implementation and make no changes to your application/usage code (except in tests). Another disadvantage to everything-as-constructor-arguments is that all classes in use are created eagerly. If the Mail class were to be instanciated but is ultimately unused - the Mailer object would also have been instanciated and unused. In this case that class doesn't do anything - but if it were also creating dependencies on construction, and if there is any setup logic executed this can easily mean a tree of objects get created before they need to be used. A practical example of how this can be a problem would be if the config is modified after construction but before first use: 

That has the benefit of not creating properties you don't use. Also, did you strip out some code? Because it seems like all you're doing is storing a reference to an object. Why not just use the object? 

ps: I can't just do something like , because I need it to shrink as text is deleted. Also, I don't want to remember the previous count and just calculate the difference, because some changes will inevitably be missed and a differential script will never right itself. 

Why is slower than ? Is there any way to optimize the regex in so the performance is comparable to the first two? Is there any other way to speed up this code? 

is, actually, the worst variable name there is. It is impossible to create a less specific name. I would suggest renaming it. 

Zirak's answer is all the advice you need, but since he didn't actually write any code, here's how I might re-write it. 

This looks like something you'd want to do server-side, mainly because you can cache the result. So for every request but the first one you're essentially just downloading a file. If you can't do it server-side, here are a few improvements: 

Your first version is unreliable if there are numbers that consist of more than one digit. For example, the method would count only two distinct numbers in the array , and only one distinct number in the array . Apart from that, you could also use a stream: 

This a bit more complicated to read than your code, because you have to manually find the element and keep track of the index (which you need to calculate the number of steps), but on the other hand, you only have to iterate over once per character from because the removal is accomplished via , whereas your code would require two (implicit) iterations if you make a instead of an : one for finding the first occurrence of the character, and a second iteration for removing it via (if is an , then would be able to find the element in constant time without needing to iterate over the list, but the actual deletion would, as already mentioned, require all subsequent elements to be moved, which is not the case with a ). Update Inspired by your idea not to reset the iterator over when there are consecutive identical characters in , I've tried to apply this principle whenever the next character in has not yet occurred in during the last iteration over , and not only when the next character in is identical to the last character from . The trick was making the check whether a character has already occurred in cheap enough so that the savings in loop iterations are not outweighed by the overhead of the check itself. I originally tried putting the characters encountered during an iteration over in a , which would be the easiest solution, but this turned out to be far too slow to be worth it. Then I tried using a array that contains a value for every possible character that signifies whether this character has already occurred in , and this did indeed speed up the program, not in a groundbreaking manner, but definitely noticeable: 

The less logic there is at runtime - the faster the code performs. Use a build process Rather than handle requests for missing packets, a process that builds them all, once, could be used. 

Which is in fact set to four spaces. "\t" is easier and shorter to type. Minor Point: Whitespace Whitespace in html is insignificant, so doing this: 

No I'm not sure why this question is tagged CakePHP but since it is: This is not CakePHP code =). Some specific points to elaborate: session_start, $_SESSION This should not be in any CakePHP application code - The session is started on demand whenever it is first accessed via the Session component, session helper or the CakeSession class. include_once Files shouldn't need to be included explicitly at all in CakePHP, there's a standard way to load everything. For classes that is using App::uses, for template files it's Controller::render and View::element. Model By defining a class called Model, even if it were loaded correctly - CakePHP's base model class cannot be used. new Model This is not the right way to construct a model in CakePHP - the normal way is: 

Your code is slow simply because it does much more than it needs to. It copies the first half of the original string to a new , but then, you only use this to access its characters by their index, which you could also do with the original string, since the indexes of the characters in the first half of the original string and those in this new are identical. So you might as well omit the variable and use the original string in its place when you iterate over every second character: 

You are horrified by "the type of that thing" because you are using stream operations for something they were not meant for. The purpose of streams is to perform pre-defined operations on an arbitrary number of elements of a kind. However, you have a scenario where the operation you want to perform depends on the nature of the stream itself. I did not really inspect your code in detail, because, based on your description of what you want to do, my suggestion would be to use a different approach altogether: It is possible to obtain an iterator over the elements of a stream by calling on a stream (which is a terminal operation, so the stream will be consumed after creating the iterator, which means that you can obtain the iterator only once). Using that iterator, you can simply accumulate the elements inside the encountered s in a as long as they are all right eithers. If you encounter a left either, you stop iterating and return this left either. If the iterator is exhausted before you encounter a left either, you just wrap the now fully populated list in a right either and return that either. 

I am writing a script to count the number of rows in a textarea, and as it will be called on every keypress I want to make sure it runs as fast as possible. I'm not aiming for a general solution: we can assume that the textarea has a monospace font and enough horizontal space for exactly 80 characters. I've probably solved this problem in 20 different ways, and this is by far the fastest solution I've come up with: 

The performance doesn't make any sense to me - does the same thing as , except it doesn't create any unnecessary strings or arrays. Is with a start position just really slow, or is there some optimization only the first method is picking up on? Finally, here's one more method, which is much slower in every browser I've tested, but beautifully concise: 

Note that this code is optimized for arrays with at least 1 element; if the majority of its uses are on 0-length arrays, you'd see a performance boost if you added a short return. Alternatively you can use Array.prototype.reduce. I highly recommend that you not use this method - while it is more "unique", it is also much harder to understand and much less efficient. And good code strives to be readable and efficient (and robust), not unique. 

I think the place where recursion is least appropriate is when you advance a queen until it is safe from all queens with a lower index (i.e. the last line of the method ). This doesn't really seem like a recursive process to me, but rather like something that calls for a loop. 

Of course, it is possible to check whether the collector has the characteristic and to manually ascertain that the stream is sequential, but then I would ask the question: Why bother with such a complicated design, when you can just call on the stream and iterate over the elements in an old-fashioned, but simple and straightforward way? This would be much more to the point, and the risk of headaches would be minimal. 

But I think there would only be a point in doing that if you need it more than once, because otherwise, it would not really be a remedy for code duplication, but just unnecessary code (since you don't really need it for the first three cases due to the pre-existing method ).