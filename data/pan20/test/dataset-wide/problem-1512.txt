Since your data is already sorted you definitely don't need to use a dictionary. You can just accumulate and then whenever the or rolls over you write them all out. That wouldn't be a huge change from what you've got. But honestly, what you've got is a bit confusing because you're trying to do several things at once. Namely: 

Now, let's write a function to parse the database records out into a list of objects. This is basically doing what I said earlier - tracking until we hit a new or . We're using C# iterators (that's the syntax) to make this a little bit cleaner. 

is a red-flag, and should be . Your code will spin in to an infinite loop for 25% of all long values .... anything larger than will cause this loop to become infinite: 

The reason is that does not exist. Sure, many things that print numbers in Java will print a rounded value for you, but any math you do will have small errors inconsistent with your expectations. The bottom line? Rounding floating-point numbers to any fractional value will result in occasional errors. The solution is to keep everything as a number. Do not use your method unless you know what you are sacrificing. Here is an ideone, it loops through small values until it finds one which causes errors. The first error it finds is at 65 millionths. 

(disclaimer: Glenn's a friend and former colleague of mine, but he is really good at this stuff. I don't get kickbacks. Maybe a beer, but probably not.) 

Before even addressing the actual question, have you actually proven that database queries are harming your responsiveness? Since the queries are to local storage it's possible that they are fast enough to not require using asynchrony, particularly if they are simple queries or the database is small. Next, I notice you've assumed that the database itself is not threadsafe, i.e. that you must only allow access from one thread at a time. Are you sure that's actually true? Many (most?) database handle concurrency themselves, so you may be adding an unnecessary layer of synchronization. I looked around a bit, but could not find anything specifically documenting concurrent access to isolated storage databases. I would start by researching that, or possibly asking a question on StackOverflow. If the database does allow concurrent access then you just need to worry about update conflicts, which you could hopefully avoid in a single-user phone application. What I'm getting at here is that multi-threading and locking is hard. Don't do it unless you're sure you have a good reason to do it. If you really must to multi-threading, then the C# keyword is a good place to start. Unfortunately, your example probably will not work properly because each instance will have it's own lock object - so if you create more than one instance they could conflict with each other. You "Current Variant" actually gets this more right, because your is a static variable, so there is only a single instance of it across the system. However, as I understand it lets you use Linq statements against the database, which will not know anything about your lock and hence will not be synchronized. I think you'd have to create a separate application layer to wrap the and expose just the certain operations that your application needs. This is generally called the "Repository Pattern". Inside the repository you could create a single lock object, wrap a around all accesses to a , and use inside each of the repository methods to make them asynchronous. 

This way the @Before things happen in the predictable order, etc. In your pro/con terminology, you cannot implement a concrete class of the abstract class, without implementing the abstract method. The method is called in the @Begin in the Super Class, and the Super Class @Begins are called before the concrete class. This is the way it should be done. 

I would not worry too much about the stack overflow. Java typically has 10's of thousands of levels it will manage before overflow. On a reasonably balanced tree this would be more than enough. DFS2 Again with the static, but the rest of the implementation looks fine. The Stack based system is a head-scratcher, but it works well. It allows for the stack to simulate a recursive approach, and that's what we would expect. Your use of is good, and often I see people using , so nice there. DFS3 You messed up your naming, why is got the method name ? Consistency please. THis one using a visited marker on the node is a real problem. The code is no longer reentrant, and you have to reset each node before you can call the function again. DFS4 (or 5, depending). Using a HashSet is an OK option, but it requires a lot more space to manage. Additionally, it depends on the hashcode and equals methods, so would be slower. I would avoid it. 

It's impossible to say what the problem is without knowing how the data is structured, how many rows are in each table, what the indexes are, and other information. Even then, the problem may not even be with this query but with some other query that causes problems for the database as a whole. Basically, your question is far too narrow. That said, you could try a few things: 

Try running this with Explain Plan turned on. That should tell you what part of the query is taking the longest. Run and then your query. That will give you an idea if the I/O usage is high. If the above don't suggest improvement, check the overall DB for problems. Glenn Berry's SQL diagnostics queries are a good place to start. If you still can't figure it out, hire someone like Glenn to help you. Or start reading a lot of books on SQL Server optimization. 

That's the safe way to create it in a way that's not going to have race conditions. Note that uses the value in (if set) as the location in which to create the folder, so it will use whatver value you have set in the code before running 

Since this is tagged 'algorithm' I am going to review your algorithm.... Your algorithm here is wrong. Looking for all combinations () is a very expensive way of doing it. I know very little about Scala, but, can assure you that a much better (the best?) algorithm would be something like: 

Making a copy of an object has a benefit: safety from unexpected changes. It also has costs: it takes up more memory, uses more CPU cache, and adds pressure to the garbage collector. Making copies that won't be modified is a waste - you're paying the cost with no benefit. So you should only make a copy if you know that you'll need it. The only code that knows for sure that the parameter will be modified is the code that's going to modify it. So whoever is going to modify that parameter should make the copy. Otherwise you risk screwing up shared state, or making a bunch of unnecessary copies. So: Option #1 if the child object is going to modify the parameter, Option #2 if the caller is going to modify the parameter. If neither is going to modify it, then don't make useless copies. 

The copyGraph function would copy the graph, believe it or not. Talking about graph-copying, this constructor should take a defensive copy of the as well. You don't want to have leaks of graph functionality to outside your class... 

There is no need for the array-of-Integer to count the number of values in each line. By putting the complexity of the generic types in the static method generics declaration area, the actual parameter has the simple type . 

Your use of StringBuilders and other systems to build and verify these facts is overkill. Bug You have slightly misinterpreted the requirements. Note, that a valid palindrome as an input string will always also have a char that can be removed leaving another valid input string. If the palindrome input has an odd number of characters, then removing the middle one leaves a valid palindrome. If it has an even number then removing one of the two middle ones leaves a valid solution too. Your code fails to handle this gracefully, and returns . Primitives Working with primitives is almost always my first choice. In this case, arrays are better than Strings, StringBuffers, and StringBuilders. I note in your code you use a StringBuffer. This is a poor choice in almost any modern context. When you encounter a StringBuffer you should always question whether it should instead be a StringBuilder. Simpler Palindrome check Consider the simpler code: 

That last function isn't really a thing of beauty either - it's got kind of a lot going on. But it's definitely better. I also added a statement around your , which is just a handy way of making sure that it gets d properly. By the way, I put up a DotNetFiddle of the whole thing. It doesn't work because I don't have a database to use, but it might be easier to read there. 

I'm not sure if you're interested in better algorithms, but if so here are some. In this particular implementation, I would consider changing how you handle substrings. You're currently doing a lot of string concatenation, which can be slow as a new object is allocated each time. Since you're just tracking substrings anyway, you could instead store the source string, start index and length of each match. That would save you potentially quite a bit of memory, and run faster as well. If you're really attached to having separate string objects, at the very least figure out the extent of the match and then do a single to extract it, rather than building up the substring one character at a time. 

The synchronization. You suggest in your comments that the needs to be synchronized to avoid thread problems... but your other setter/getter methods are not synchronized.... as a result, threads all over the place can be getting stale, wrong, and otherwise incomplete populations, ages, etc. 

OK, now for the real issue, the storage of the Enums in a convenient-to-access system... First, I recommend that you change your Enum to have two parameters in the constructor: 

When this method is called, an event of the listener's type has just been encountered in the log file. This is managed by an abstract class, and concrete classes that look for certain events. A Concrete class that just parses single lines, would be something like: 

Pretty straightforward here. We could've written this more succinctly, probably even in a (really big) one liner, but this strikes a reasonable balance with clarity, I think. So, now we just have to put those two together... 

It would be easier to figure out what's going on by separating those things out from each other. It might also make your life easier if you ever want to do anything more complex with this data than just dumping it to XML. So let's just do a little rewrite. To start with, let's create a class to hold each of those elements. (Honestly seems like a confusing name to me, it seems like maybe or might be more descriptive, but let's just stick with .)