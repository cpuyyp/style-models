But you have to be wary of alignment requirements: some CPUs cannot read misaligned data, or if they can perform the read they do it at a high performance cost. For this reason, most code is written to do bytewise assembly using shift and binary or, with the (frequently incorrect) expectation that the compiler will figure out and replace the operations if type punning is a viable alternative. 

Note: As a rule of thumb, if you find yourself executing a on internal data it's a good indicator that you should consider a new type. Switching on external data might be a correct way to deal with user input. But switching on internal data frequently means "these things should be different objects, or different classes". In this case, the enum values are serving as proxies for objects that have their own output string representation. It would be better, IMO, to simply emit the value, or a method of the value (as in the linked answer): 

That's a lot of letters to get 4 numbers into a list. You can, and should, do better! "How can I do this better," you ask? Well, post it on CodeReview of course! But also, consider how the Python class (and , and , and , and ...) is initialized. And how the Mutable Sequence Types are expected to work. Because your code is implementing a "mutable sequence type." So there's no reason that your code shouldn't work the same way. In fact, if you want other people to use your code, you should try to produce as few surprises as possible. Conforming to an existing interface is a good way to do that! Create an initializer that takes a sequence. 

Before anything else, I'm going to point out to you that you have a function called . It almost works. The problem is that it will return "x" or "o", but it won't return anything for "nope, no winner yet." That's sort of like returning None. But you really should make it explicit. At any rate, you need to create a loop - not a loop - to play the game: 

I have a problem with your code, in that the code seems unrelated to the problem statement you give at the top. You say you are "working on a REST API, where I currently create python objects from the JSON data returned by the server. Though not all attributes of the created objects will be called upon in user code." None of your code involves REST, or JSON. So while it's an interesting demonstration of certain parts of Python, it doesn't much address your issue. IMO, the feasibility of what you are discussing is going to be determined by the nature and character of the JSON data, and the REST API. Parsing JSON is generally a one-shot deal. If you get JSON data like this: 

You are not handling the case of a zero-length vector. This would be an empty input, or an error of some kind. You are not handling syntax errors at all, really. What should your code be returning for something like ? You are using recursion when it is not necessary. Specifically, your function is really just a way to hide iteration. It would be better, IMO, to write your code to loop over the delimiters instead of calling a function and then recursing with the same tokens and a new delimiter. You are using recursion when it is not necessary. Specifically, your "right subtree" case recurses with the same delimiter, and . That's a sign that you can just continue your existing loop, after updating the parent node to a new value. (You will have to move your "new node" code inside the loop, though.) 3. 

Next, if you can make it past all the hissing and snarling, I would suggest that you take advantage of C99's flexible array member feature, otherwise known as the trailing array hack. Specifically, declare a struct that contains your bookkeeping information at the "front" of the struct, and a trailing array of (or whatever your stored type will be)[hereafter, "(OWYSTWB)"]. Then, allocate the struct plus (OWYSTWB), compute the address of the start of the trailing array/flexible array member, and return that value to the user, and expect it in all user-facing function calls. It will have the effect of presenting to the end user as a pointer-to-int (OWYSTWB), which means you can use it like a ... dynamic array: 

Digging in: Check the Docs You have more fields than are needed. 2-3 tree nodes have either 2 children and 1 data field, or 3 children an 2 data fields. You have and in your initializer... Own the node You have a tree class and a node class. Move the node class(es) into the tree: 

You can do a similar thing for t3 into a different dictionary. Just make sure you read both t2 and t3 before you start processing t1. 

Encapsulate! You pass into as a parameter. So why are you calling ? Why don't you encapsulate this in your ? 

Finally, if you subclass and you can store dedicated offset tables for them, and add support for forward and en passant captures. (Note: I'm waving my hands pretty hard in the en passant section, since I haven't looked at the rest of your code.) 

You can replace with or whatever function you like. But it will make automated testing easier if loading your module doesn't automatically trigger a game. Scope You are accessing data as a slightly higher level than I'm comfortable with. I think this will make things tougher for you when you try to provide an automated opponent. For example: 

I'm confused on why you sometimes call and other times just call . Since you are implementing type-specific behavior, shouldn't you be calling all the time? You can facilitate castling and pawn double-stepping if you add a "never moved" indicator at the parent level, or specifically to kings, rooks, and pawns. I'd suggest subclassing black and white pawns. There's no sense checking your color every time. Just build two offset tables. Some of your code seems awkward. There are places where you have what seems like too many variables. There are other places where you don't loop when you obviously could. I think you need to make a pass and just "clean up" the functions. I suspect that you'll find some common routines when you do. Creating a new Rook and Bishop on each iteration for evaluating Queen moves seems horribly inefficient. I'd suggest you device a strategy for dealing with "zoomy" pieces, and just maintain a custom offsets table. As a performance enhancement, you might consider tracking threats to squares, and changes to squares. You could then use this information to avoid recomputing possible moves for pieces where nothing has changed. Basically, a pieces possible moves only change when (1) it moves, (2) a blocking piece moves, (3) a same-colored piece moves into blocking position. 

We're back to the approach. You don't actually return in your checks. Your code is "falling off the end" and is vulnerable to whatever happens to be in the return register. (Probably the result of the last condition tested, but still...) You have written functions to do these checks, but you're missing one function. Instead of putting calls to in your main routine, why not write a function called and summarize the results? 

This is a pain in the ass to maintain, so you only do it when you are done changing the algorithms and stuff, and you want to squeeze out that last 10% of performance. Note also, this is strictly a c-python thing. : The big cheese. The head honcho. The place where ... all the time ... is spent! I'll start out by pointing out that every time you write a kitten dies! 

And see Raymond Hettinger's guide to using for more pro-tips. The idea here is to override the default attribute values on a per-class basis (dmg and str, in this case) but have the root class do all the attribute-setting, since it's all the same except for the values. 

You have not specified the behavior of your list, which makes it hard for us to reason about it, and makes it hard for you to reason about it. Because this is a module about a data structure, it's a good fit for Design-by-Contract, which I recommend you read about. Fundamentally, in DbC, each method or function has a precondition which must be met just prior to executing the code, a postcondition which must be met after executing the code, and an invariant which must be true at the start and the end of execution, as well as being true when other public methods or functions are called from within the code. Consider your operation: the precondition is that a node with key may or may not be present in the list. The postcondition is that the first such node will be removed from the list. (It's not clear whether you want to handle multiple nodes with the same key: do you?) You don't specify an invariant, but I'd suggest the invariant might be that points to the first node in the list, or is NULL for an empty list, while points to the last node in the list, or is NULL for an empty list, and each node's field points to the next node in the list, or is NULL when the node is at the end of the list. You should consider documenting these three conditions. The invariant is always true - you can document it once at the top of the module. You might even document it in code, in a private helper function you can call for debugging purposes: . The pre- and post-conditions will vary from function to function. I suggest documenting them in a block comment. With that out of the way, let's consider your code: