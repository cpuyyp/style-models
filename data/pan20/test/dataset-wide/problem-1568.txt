Unnecessary comments I don't know who else will read this code but comments like followed by this will just make the code more obscure, since the goal of the error message is pretty obvious. Calling strlen for no reason Also it's not really clear to me, why you need to call here 

I recently read K&R The C Programming Language and wanted to write a small program to count the occurrence of each word in the input (std-input - I piped a file with all shakespeare pieces in there). Since I wanted to learn how to split source files into multiple files with this project I pretty much outsources every function I could think of. This is the part I'm most unsure, whether its bad practice or not (I include multiple libraries from the std-lib multiple times. Is this a bad thing?). You'll see. find_words.c 

If is equal to . Could not create socket will be printed as well as Socket created, which is misleading. I think: 

I'm sorry for the long post (I'm not 100% sure if this is allowed - I'll delete the post immediately if it's not). 

The code is executed by creating a new and calling . Like I said before, if I change the program so that the string building is handled inside the directory getting, thereby only iterating over each directory once, the program runs many times faster, but at the expense of being able to split the paths and then "right-align" the permissions result. I thought about displaying the permissions first, and then the path, but that goes against the spec I was given to work by. 

I am trying to make my ASP.NET MVC application use transactions for all database operations, to ensure safety when there are multiple users. To do this, I have created static methods in my class that take s or s as parameters, wrap them in blocks for a new instance of and then a , and then execute the or . Here are the transaction methods: 

This class represents a single query on an Active Directory. It is given the type of query to run and the types of data to return, and performs the query and returns the data when it is commanded to do so. The goals I had with this class were to ensure that the query is run async so it doesn't freeze (and crash) the UI and to be able to create the query without executing it immediately. The queries also support cancellation (it is handled farther "down" the calling tree in the and classes). Questions I have: 

is appropriate and the code doesn't proceeds. Outsource I'm also not sure if it would be better to outsource this part (as : 

And I think that the code will stuck if a non-digit, non-'+/-' and non EOF file character is found. Since it'll just unget this char and read it again in the next function call. Is this made on purpose? I left out the , since I think that the function is supposed to just read the next char of input in the next function call... 

when you store assign a few lines above in the -condition. will just search for a , which you assign by yourself with ... Besides these points I can't see any major mistakes. You should just think about your comments a little more (Do I really need this information? Is this self explaining? Is a single line comment enough here?). As I already said: I can't say much about the networking part, maybe someone else will jump here. 

One of the K&R exercises is to write a small piece of software to compare two files and print the first line in which they differ. Here is my attempt: 

There's a few things I find more satisfying about this: our base-case input is , a common base for s; our base-case output is , a common base for s; and there's no duplicated code in the two branches of the . Finally, I think I'd choose to replace the -- with a pattern match, noting however that this function has a slightly different behavior for negative numbers. Since we were never really doing the right thing for negative numbers, this doesn't bother me too much. 

As with waaaay back at the beginning, I find the choice of base case a bit odd. Let's try the trick from before of letting the "loop" run one more iteration (and this time hopefully the refactoring isn't wrong!). 

Actually, using and is also a code smell, for the same reason as the rest of the changes so far: is partial. Instead of protecting ourselves from calling on inputs it can't handle, we should write our code in a way that avoids partial functions. Here's how: 

This name sure leaves something to be desired! And it leaves another important thing to be desired, too: there's lots of inputs where it just crashes. Nasty! It turns out that you never call it on inputs of that form later, but totality is another good habit that you should get yourself into. It's just another tool in the mature programmer's defensive programming toolbelt. In our case, we'll want to handle cases like , or , or , etc. where there's no good answer to return. What should we return if that happens? One simple and quite common choice is to change our type from