The Rules list should not be public. Hide state and expose functionality. If you need to add rules for example, make an Add method. 

Warning! Arm Chair Quarterbacking in progress. Given that I offer this. Game Class Why is this in the ? You need a "driver" for a chess game and that would be a class. "A game consists of (has) moves" makes more sense. The gives us a conceptual framework for a richer chess game. A has players, may have a timer for speed chess, and can keep track of pieces removed from the board; and of course records the moves. Board Class The chess board is a data structure. Don't make more of it than it is; nor less. In the Visitor Pattern the data structure has-a element that has an method. That element seems to be a . I'm not certain if it's better than the being visited, but certainly the point is that we're evaluating the state at that one square? I don't see a big deal in giving a board reference to each square. OR .. maybe the s are visited. To test if the piece is "inCheck" for example. This perspective makes more sense than a square is in check. Is this why your board is and not ? Whether we are visiting the board and iterating the squares; or iterating the board and visiting the squares; or iterating the squares and visiting the pieces may be more than semantics. I vote for whatever best reflects intent, gives me good code expressions, and sensible building blocks. In any case I agree with @bowmore about refactoring to . Pieces Even given a rich class, I like the idea of using an enumeration for names. This makes for nicer coding and expressability overall (and my pet peeve - it avoids strings). Maybe two enumerations. As in and ; or , And a value to represent an empty square might be nice or . Maybe has a reference so it knows where it is. This may have a nice effect on the code. Visitor Pattern Nice call. I agree with @MarcoForgerg, the visitors do not need to keep state. Just pass in the needed parameters and forget-about-it when done. And, instead of Singletons perhaps just static. Nested visitors? Ok, so the board gets "visited" which in turn "visits" each square, which in turn, finally gets to . Visitors, by definition, understand their visited data structure so I'm thinking board iteration is wrapped in the board visitor, and the square visitor knows to check for an occupying piece and knows what Evaluator(s) to pass to the piece. It feels like nicely layered (code) logic to me. And note how the iteration logic is in the visitors, not the board (data structure). And subsequently all the business logic is in the visitor as well. SO instead of this 

The should be handling a - that's another class. As written your is a purchase, it is not a cash register. This is because there are class-level variables for a single and . A CR should hold a list of all the items bought. When I go shopping I buy an item. I don't buy a . But my "Purchase" is an item + its price. A "Cash Register" records the purchase object, handles the money transaction, calculates change, taxes, updating inventory counts perhaps (as suggested by the property). Another CashRegister function is end of day reconciliation. I mean simply adding up all the , collected, and clearing it's memory to get ready for the next day. Even if you cannot have a (list of purchases), your CR should have a object, not separate properties. Use objects. 

Map is handy for shortening ths common pattern, but I think Guido has officially disowned it for the future 

You're doing three things here: splitting up the listing into sentences, parsing the listing, and recording the results. You can clean this up by separating these out into separate functions functions or classes. This keeps the code less nested and easier to follow. To keep things simpler I'm using regexes for the room names as well as for the dimensions. This will actually be a bit slower - "in" is really fast - but it is more flexible (for example, if you have to support plural endings or something else besides string lookups). I'm compiling the regexes using re.compile to make them faster and re.I to make them case-insenstive. Lastly, I'm returning the results as a list-of-dictionaries, where each dictionary includes the room, dimensions and the sentence from which they came. This lets you keep the printout display separate from the parsing. In practice I would probably use instead of a dictionary but I didn't want to get too far off topic 

Conceptually this is halfway between 'traditional' inheritance heavy OOP and @MichaelUrman's data customization approach. All three have their applications, and the neat thing about python is that it's very good at both @MichaelUrman's method and mine -- which is not true for languages obsessed with type-checking and signature maintenance. 2) On the strategy level, in the long term you'll benefit from a finer grained approach. Engines, transmissions, and tires for example might be their own classes instead of aspects of vehicle (a station wagon and a sedan, for example, might share everything but body styles). The class hierarchy becomes less of an issue as you do more mix-and-match customization by creating collections of components. The usual pretentious programmer way to say this is 'prefer composition over inheritance' 

I'd also use string.Template for any complex string formatting opertations. The % operator is great for single substitutions but Template is better for keeping the code clean: 

By sticking the result into dict you don't have to override getattr yourself, which limits the intervention to a single place although it does deprive you of the option to do guard checks for bad values, etc. This example would except on name collisions and get you off the hook for manually redirecting double-dotted attribute queries. 

The first version will be faster but you're storing redundant copies of the indices, which might matter for big data sets Usage: 

Python has a neat built in called 'zip' which creates a pairwise list from multiple iterables. So you could do: 

Here's a couple of ways to shorten the code, which may or may not involve perf gains but may make it easier to work with. I tested this with plain lists-of-lists instead of numpy.arrays but I think it should work the same way. I used itertools.product to get rid of the nested loops and used sum() to avoid another loop. get neighbors will be called for every cell, and it's going to loop and iterate mamy times. You can get the same result by summing the rows of a subset: 

This could be even a little shorter if you use list comprehension, yields and iteration to avoid all the if-tests (and, btw, use named variables instead of indices for clarity!) 

Changing the answer would completely destroy the illustration for the future reader. Updating the original question in response to answers is discouraged on StackExchange. Distinct from error corrections, it can cause answers and comments to become wrong, non-sequitur, and confusing overall. I would say however that additions, distinct from changes, can be OK sometimes; particularly for clarifications requested in comments which are common immediately after postings. But even then, conventional wisdom says to fence an addition with (bolded) "Edit .. endEdit", and a brief "why" is helpful. 

You're right that having MainApp having to know/control the sql connection is bad design. We're going to get rid of the and calls by being "connection oriented" instead of "sql command oriented". Keep reading for clarification... Then should set up the as it does now, but not execute the query. Instead pass that into some other method and ... use "using" to get rid of Open / Close code 

Other examples using a dictionary are interesting. I'd use an for the key, not strings. overall it feels like the reflection/abstraction aspects are wasted as it's all internal and you still have to "open the factory", i.e. modify it, to add/delete class-types. The dictionary is necessary only because we pass the entire query string to the factory. Again, Tell the factory what to build don't make it try to guess (see above about "gross assumptions"). The calling client is the absolute best place with the proper context to decide what to build. Making the factory parse the query string - and therefore handle problems - is violating the single responsibility principle. 

Ask not what you can do for your base class, Ask what your base class can do for you We just did that by inheriting . There are some cool overloads. And every class inherits , and we have some great power just waiting to be unleashed. Fetching a specific CharacterCount Let's say our clients want to be able to find a specific character count object. 

end EDIT 3 EDIT 4 @PeterKiss answer mentions sorting. So let's see how that works here. Sorting CharacterCountCollection has internal objects but its clients don't know that and it certainly is NOT DOCUMENTED. Further it would just be good to have default sort behavior for our DTOs. Implementing is the secret. We're taking advantage of our structure, inheritance and built-in .net framework goodness. 

This could be the basis that get to where you want to go with the code. As pump, motor, etc. will subclass Product you have the polymorphic framework you need. 

Now the test code stays small yet your tests are as variably complex as your data object collection. 

Using composition instead of inheritance means that we've hidden all the public methods - so we can control how our collection is exposed to the client. And, we write methods in terms of our problem space. The simple above, for example, may seem redundant but that is not the point. Further we can add functionality, for example if we don't want duplicates, or there was some other criteria for adding or rejecting an we can do that. So our methods written in terms of our domain are customized for our domain as well.