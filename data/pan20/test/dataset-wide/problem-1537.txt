Well, that almost certainly isn't right. You take a parameter which you then ignore, overwriting it locally. 

My only other thought was also mentioned in the comments: make sure that there is an index on . It does not have to be a PRIMARY key nor even a unique index. Any index will do. Without an index, it has to generate the query results in memory, sort them, and then send them to you. With the index, it can just read this query directly from the index in sorted order. 

When commenting, try to say why you are doing things rather than what you are doing. E.g. . This seems odd though. You pass in an . Why not make a list of integer arrays then? If that makes something not work, comment on it so that you don't regress it later. 

This is clearer about what it is doing than the of the results. Also, it doesn't parse each line twice. And of course it doesn't define a hash just to get the keys. In general, I would make more use of paragraphing. This is extra new lines to separate blocks of code. This allows you to easily see what pieces of code go together. For example, note how I separate the from the file handling code. You have comments explaining what the file format should be, but you don't explain what the command line arguments should be. A user would have to read the code to figure it out. Your function does two distinct things. First, it reads the command line arguments. Second, it opens a file and processes it based on the command line arguments. It would be better if you could separate that into two functions. 

I tried compiling a new version using the online compilator at $URL$ but there was loads of errors and it seemed a little unstable. In addition, when trying to get information from OP regarding how you actually are running your code, and expected output, I didn't get much response. As such, I've failed getting you alternate refactored code better implementing a type dependent state machine in Idris. 

I compared my version 3, 4, & 5, your original version, the version by David Z, and the difflib version, for some various strings using timeit.timeit (with selecting the best of 3000 iterations), and got the following list: 

Here is an alternate approach related to optimising your code, if my previous answer doesn't help enough, and if you can't switch to using either a database, like sqlite, or use pandas. Before explaining the alternate I would like to recap that your current algorithm is something along the following lines: 

Notice how this also uses the idiom to pack the test code used. This would allow for the convert function to be imported from another script if imported. The output of this code is: 

You've gotten some good answers regarding how to simplify your code with respect to the overall logic and the use of operations. I would just like to focus a little on printing. First of all, the recommended version for string interpolation is the following: 

Since returns the position in the string, we have to check that the position is not valid to convert to a boolean value. Reinventing the wheel A better version if you want to roll your own would be 

What happens if there is no trailing in the URL string? You should explicitly check that you don't go past the end of the string. 

By naming your function nextValidInt, you have limited yourself. The only input that you can ever get is an integer. If you wanted to get a string (e.g. "exit"), you'd have to refactor the function to name it something like nextValidToken. The code would need to change as well, since the return type would no longer work. 

You don't need to save the value of the string literal. You only use it once, so you can just use it. Starting with instead of means that you don't have to add to the value before using it. I switched from to , as is a more common loop iteration variable. 

Now there are both an example declaration and use in the comment. You do a lot of work in the method. Consider pushing some of that out into functions. E.g. 

Having a numeric component can help with translation. For example, if you have both fields meaning entries in an HTML form and fields meaning land under cultivation on a farm, then you don't want them to have the same translation key. That said, people often want the translation keys to give some hint as to what the text might be, so they mix the numeric ID with a string, e.g. . You probably want to separate your main code from the translations. Also, you probably want to separate your English and Spanish translations from each other. The reason is that you don't want to have to change the file with the English translations or the code because there is a problem with the Spanish translation. This also allows you to use separate encodings for each translation. And of course, separate files scales well. I'd be wary of trying to use generic English messages to cover multiple situations. For example, there may be a language that uses different words to describe a form entry that can hold a string like a name versus a number. It's often better to be as specific as possible in your message so as to save yourself the trouble of refactoring when a new language causes translation problems. Repeating yourself makes for bad coding practice, but it may be good for translating. Be especially leery of embedding translated strings in other translated strings. It's very easy to get into situations where (for example) two strings use different articles or verbs. An English example would be "I am", "you are", or "she is". "I is" or "you am" would sound ridiculous but is the kind of thing that string embedding gets you. Also be careful of concatenating strings. The translated version may put the words in a different order. For example, Spanish often puts the adjective after the noun. 

Using a table here is the right choice, however I would put the total into a group where you can address its formatting needs specifically. In addition do use to collapse columns in the total, as well. 

Code is untested, but should work, I think. And use braces, not one-liners which hinders readability a lot. Better naming is also good. Especially when writing code which is supposed used as example code, you should strive for code which is easy to read and understand. 

This way your loop is clearly focused on getting a legal quantity, and breaks your when that has been achieved. Then it decides whether to add anything to the order or not. 

Just a little note to give you an alternative method on handling the ADT stack which is easier to maintain: Instead of using a dynamic array, use a linked list. Using a linked list would eliminate the need for dynamically changing the array size, and would do allocations (and freeing) of memory much easier. At any point in the time the list will only have allocated just enough memory. In addition if you make the list correctly it will almost be an immutable object requiring little or no work when pushing or popping besides handling the new stack element, and updating a pointer to whatever is the top of the stack. Here are some code to get you started, if you want to pursue this alternate method: 

The Ugly Nothing is really ugly here. For that you'd need a helluva lot more Clint Eastwood. Breaking Down Your Application Into Components To really organize your code, you need to break it down into components that focus on one specific task, for example, adding a category. Looking at your code, I can see the following tasks: 

If private variables aren't all that beneficial, or the property is meant to be public, I'll just declare that as part of the prototype: 

Separating things into these layers makes them testable. You could write Jasmine or Mocha tests for your controller and repository layer: 

The form would need to instantiate the user permissions service with the proper user object before the method gets called. 

As an added bonus, adding a new decoration/drawing style becomes trivial. Add a new value in a attribute, and then create a new function using as the name of the function. No need to update . 

Trying to use JavaScript like a class based language is what you make it. It sounds like someone was expressing an opinion, rather than imperial evidence. As for your implementation, it's very confusing how you'll expect to use the object. Be very careful with mixins or, "multiple inheritance." If you need multiple inheritance, I would argue that you need Composition over inheritance. 

This way all AJAX is centralized and abstracted away. None of the rest of the application even needs to know AJAX is at work. You could rewrite your repository layer to use asynchronous calls to the browser's IndexedDB for an offline application and you wouldn't need to refactor any of your other code. Controllers Over the years I keep coming back to this basic pattern when creating controllers in JavaScript. Controllers: 

Back to the basic of code review, what does this code do and how do you do it. At first glance I've got not clue what so ever this code does. I don't know what the content of the is. I don't know what the or the is referring to, and I don't know why the is the correct answer. The only thing I know is that your function is supposed to return the "maximum length palindrome subsequence" of . Which is not entirely clear either. (I wrote an answer (now deleted) based on a misconception of the terms included, as I didn't fully realize the definition of subseqence) So let us review some unknown code: 

Joining updates It looks like you should extend your queries to sum across all records with an extended clause. Something like the following: 

My main complaint about your code is that you rebuild the table used for translation for each and every character you are encoding or decoding. This is a major waste of computational power. In addition I've got some other minor comments: 

Do note that config file is somewhat picky and needs for each line start with either a configuration option, section divider() or comment starter (). Some additional notes regarding the refactored code: 

This should do the trick rather efficiently as well as elegantly. Will possibly code it later on, but just now I'm a little busy. But just thought I would give you something to think about regarding how to improve it. Update: No need to reinvent the wheel, so please do use (and/or accept) code example provided by Barry. Will maybe code it just for the exercise, but most likely using heapq.merge, or some union-variant, will be a better implementation. 

I know this is a lot to throw at a code review, but this does allow for loose coupling, plus all the functionality is componentized and reusable. Since each class has all of its dependencies as public properties (like the ) it becomes easy to mock up those dependencies for the purpose of unit testing. 

Basically, the code just looks consistently written. That being said, it's not really organized. The Bad 

If the only purpose is to provide a simple wrapper around the body of the HTTP response, this isn't so bad. Things break down when you need to access things like the request and response headers. Error handling is another thing entirely. I would recommend catching all errors, and rethrowing the exceptions wrapped in your own exception classes to make error handling for client code easier: 

The name of your class is a generic name, yet it is used for a specific kind of request being that the and parameters are hard coded. I think what you want is a class that encapsulates specific AJAX calls. For this, the Repository Pattern would work well: 

If you couple business rule validations to the domain object, you cannot apply different business rules to the same domain object. Never assume you will only have one set of business rules. By creating validators outside the domain object, you give yourself the flexibility of creating whole different swaths of business rules without touching the domain layer. Basically, by the time you go to save a domain object to a database or other repository it should be completely valid from a business rule AND storage perspective. This allows you to communicate problems to the user in a manor that allows them to correct their mistake. If you let a SQL error propagate up the call stack and result in a 500 Internal Server Error, you as a programmer have not done your due diligence when validating data. Now I could see a case for separating the storage validations from the business rules. Maybe you start out persisting your domain objects in a database, but later you move to a RESTfull web service. The web service may have different basic data validations, which you can then swap out for a different validator while keeping your existing business rule validations. I disagree that this solution doesn't scale. Quite the opposite actually. It scales very well. Mashing your validations into the domain object is what doesn't scale. Changing the storage mechanism or needing to apply different categories of business rules gets complicated when your domain objects validate themselves. Domain objects should be mere boxes containing data. The decision of whether that data is correct is wholly out of scope for the domain object, in my opinion. The storage manager should have absolutely no validations. It should accept a domain object, attempt to persist it and throw an exception if anything goes wrong. 

I don't really see the need for threading here, as it seems like it only generates a one-time key. If this was some kind of long-time running process it would make a little more sense, but I still believe I would rather use a method which kept track of the last request, and if that request was made more than 30 seconds ago then read a new key from the . The following code is totally untested: 

I made the into a global dict with integers as key, named . After some testing I found that the extreme variant was slower than expected, so I fumbled around and found this to be the fastest in my environment: 

I've also changed the logic into some more parts, so that there is one part, , which handle the overall logic, and a dedicated read for each test cases, , and a dedicated sorter for each case, . This separations allows for a lower memory footprint, and in my point of view easier read of what happens in the different parts of the program. Hopefully, this gives you some guidelines on how to improve your code in your future, and hopefully it solves the challenge within the time limits (and correctly :-) ). 

Notice how you now can read the if statement directly as: if not previousWasWhitespace and currentIsWhiteSpace putchar. And this should be a goal, that the code should as readable as possible. On a side note, the if statement can be reversed into , but whilst still correct it is harder to read, so I prefer the first variation just because of readability. 

I tend to gravitate towards making everything public, and part of the prototype. As a personal convention properties and methods prefixed with an underscore are not meant to be called publically. Some people force encapsulation by using private variables, but this always feels like I'm trying to fit a square peg into a round hole. Unless you jump through hoops, everything in JavaScript is public. Embrace it. It makes unit testing your JavaScript code easier as well. As an added benefit, most browsers have optimized the Constructor Function + Prototype code by generated classes behind the scenes for your JavaScript "classes", making property access in JavaScript almost as efficient as native code. Browsers haven't done much to optimize Constructor Functions that use private variables --- which is not to say that kind of code won't ever be optimized. It just isn't optimized very much right now. Edit #1: From OP's comment below: 

When you change anything with categories, you need to refresh the category list. Same thing with bookmarks. For this you can use events. Controllers would publish an event, say "category:updated". The would subscribe to "category:updated" and refresh the category list. Same idea with . Now the AJAX functionality is currently all global. I usually go for the Repository Pattern to encapsulate AJAX calls. For that you would have two more classes: 

There is absolutely no difference between and . The and properties created using are superfluous, and only serve to add weight to your JavaScript code. There is no logic behind the getting and setting of those values. On the contrary, consider a case where you do want some special logic around setting a value. In the code below, the property is a reference to a DOM node. When setting the DOM node we also want to set properties for the and to which the DOM node belongs: