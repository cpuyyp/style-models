Well, in my opinion transaction should definitely NOT be responsible for getting a list of itself... Not only it makes little sense from domain perspective but it also violates SRP. Another major concern is that this design clearly encourages having classes with lots of hidden static dependencies. This problem alone is good enough reason to avoid it. 

Arguably, 452 lines of code in a single class (which, to make things worse, is partial) is good enough reason in itself. Another reason: it is not really UI layer's job to query windows api for process updates and track active process. This is a business logic, which should be separated from presentation (in case that one day you get fed up with Winforms evil ways and join the ranks of holy WPF warriors). You should extract it into separate service: 

I am pretty sure you don't need to move cursor, if you call instead of . You are using both floats and doubles in your calculations. You should probably use one or the other. is unnecessary. I think it would make more sense for to take actual points as input instead of "delta"-s. Meaning you should move: 

won't work as you want it to. So eventually you might want to implement some sort of reference counting. 

There are also a lot of , but very little explanation to the user why the command returned early. Is this handled somewhere else? I mean if, say, the is (which I assume is the text user selected) and your command returns early without doing anything, how does the user know why it doesn't work? If such situation should be impossible you should throw an exception. If it is possible, you should provide some sort of feedback for the sake of good UX. 

You can now develop and test the data access layer in isolation. If your DB environment is different in production, than on your development (which is almost always the case), then you just supply a new App.config file. The UI only sees what the interface is exposing, not what back end is hitting. You have also (partly) removed the knowledge of the data source (XML, CSV, Oracle etc) 

So next step is now removing the dependency of s. You can happily use in the SqlDataAccess class, but convert the rows to classes before returning them. Therefore the UI only sees concrete classes, and DataGrid's will happily binding to classes. DB Performance Never do in a production application. Its fine for SSMS in a development environment to get a look over everything. In a production app, you should only pull out the columns you want, rather than everything. If a DBA decided to change this schema behind your application, you will start pulling in more columns, which could be dangerous, especially if there's something like 'IS_BLACK_LISTED', 'HAS_CRIMINAL_RECORD' .. etc. Using T-SQL like you are is fine, as its parameterised. But .. (as you'll see in encryption), if you are super paranoid, you should use Stored Procedures, rather than revealing the T-SQL you are querying with. The barrier created by the ensures the UI doesn't have to care where it comes from, it just wants the data back. This pattern is called 'Inversion Of Control'. Encryption I need to know more details about what you are doing, but lets review what is going on: 

This definitely has too many levels of into/reduce. You could do a pattern. Do we need ? And why are we passing in a list when we only need the first? And it's often a good idea to put the driving sequence in the first or last position, so you can do threading. Let's try it this way: 

First of all, good job! This is obviously a complex algorithm and it looks like it's working. I'm going to do this incrementally. So I'll save this and keep editing as I go. And since it's so long, I won't get to everything. Plus I don't understand the algorithm too well. First of all, doc strings in Clojure go before the arguments. I used to make this mistake all the time. The reason is that you can have multi-variate functions. 1: 

So, I tried and failed to refactor this myself. But I will give my general feedback. What this function, which is a map of a map of a map of a map, tells me is that there is a failure of abstraction. should be should be a high-level function which should read somewhat like the inner loop of a pseudo-code implementation of Viterbi. This function relies too much on the structure of the data structures involved. Deeply nested structures are common, but a single function that accesses them so deeply is not. A good rule of thumb is at most 1 nested map/reduce within a function. There need to be functions which act as your primitive operations here. I can see that you began writing some near the top. You should continue that trend here. Then your functions would be operating at a certain level and calling functions from the level below. An alternative approach would be to turn the algorithm into a sequential series of steps. This may or may not apply here, but it is hard for me to tell. As an example (not real code!): 

Note, that timers are actually gone from UI layer. It is 's job now to look for changes and fire event periodically. Active process info can be refreshed in much the same way. P.S. This was very much coded using notepad, so I hope I didn't make too many mistakes. 

Only your viewmodel should implement . That's kind of the whole point of mvvm. Normally, your viewmodel properties wrap your model properties. Also, it is your model, that should contain all the business logic. Viewmodel should know nothing about or any other details of implementation. Viewmodel should only manage interactions with UI. Being said, you should have something like: 

Also, you should normally override equality methods if you implement . If returns , should not return . 

I don't think you are going to need a special for any of those options, simple (or any other panel), should work just fine. But it is hard to tell for sure since your code is rather hypothetical-ish. I do not know the actual use case or an actual problem you are trying to solve (if any). 

I suggest you convert your image to separate buffer and then use in-between lock/unlock to block-copy the pixel data. 2) The way you use statement looks fishy. What exactly are you locking and why? If events come on different threads and you can't handle them fast enough, then you have to come up with a throttling mechanism, that would drop some of the camera frames. Otherwise events will just keep piling up on this in no particular order and eat up your CPU (which is what you observe). 3) Depending on what else is going on in your app, call can be pretty expensive performance-wise. on the other hand is much cheaper, but you will have to be really careful with your buffers, so that background threads do not overwrite the buffer, that is currently being rendered on UI thread. 

Separate data access from UI and business logic Only retrieve what you need, rather than everything Use a DTO (Data Transfer Object) to convert from the data sources (tables) to the UI layer. There are tools that can do this for you like Entity Framework and NHibernate. Look at all encryption options. How secure do you want this to be? To what extent should you go to (i.e. obfuscate the application code? SSL the DB connections? Encrypt the DB?) 

This interface is a more clean on its approach. Its slightly larger, but it makes the ORing and ANDing much more obvious. It also makes the code cleaner at the service side as each of these properties have well-named properties and should be easy to implement: 

A user types text into a UI (unencrypted) The UI encrypts this text (encrypted) Send data to the database (unencrypted transport) Data returns from the DB (unencrypted transport) User sees results from DB (unencrypted) 

Okay, best practices... Data Access Never do data access directly in the UI. Have a separate class file to do this. Best practice would suggest creating an interface for each 'aggregate root' (collection of classes that act as an integral whole). that you want to retrieve, then a subclass that inherits from the interface. To be honest, and for simplicity, you can use something like the Gateway pattern. This is like a central place to do all database work. Its fine to start with, but may get cluttered depending on how complex your Data Access code will get: Here is a typical pattern to separate the DB from the UI: (Note - I don't work with VB.NET, so apologies for incorrect statements) 

- i think you should either change this property name, or change type to . Semantically cell being a winner doesnt make much sense. In general i am not sure i can follow how will you derive from . implementation for small board doesnt make sense (shouldn't you check for winner instead?). Same goes for for large board. I have no idea how is going to be used for either boards, and what means (not very descriptive). Etc. As for i have a few minor concerns. a) I hate s, s, etc. with all my heart and soul. :) THey have this ability to turn even simple code into a mess. This is probably a matter of taste, but i think a simple arrays would be much more readable. b) I do not like multiple , it makes code hard to follow. A simple would be better. 

It locks on static object, which is a pretty bad idea. I mean, the obvious problem is that you end up synchronizing code blocks which use different s and would otherwise be unrelated. But what also bugs me is that it looks like a pretty major modification to your original use case, which might lead to wrong conclusions about the nature of original bug. method is pretty hard to follow. You do a lot of weird stuff. For example, why would you call if you already call for released objects a few lines later? Or why would you set if you've already checked for equality? Those things make your code look fishy and bug-prone. Restructuring it might help. For example: