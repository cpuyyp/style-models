quite often. Don't bother duplicating the name, it doesn't help. Only do this if the parameter name is different and adds information. Your code looks race-y. For example, 

If the block size you want is bounded by a fixed limit, it's probably better to write into a circular buffer of the right shape. This way, you can just do a single concatenation, rather than a concatenation of a large number of arrays. 

This gives a good speed improvement to the initial load. Since the load is still noticably slow, I suggest improving it with something like 

and immidiately trying to remove them. Luckily you never seem to do this twice, because if you did your removal would have shifted off the index that you were checking next! But it's still safer and faster to write 

Note the use of / instead of is because of lexical lifetimes. Since this is currently pretty ugly and the speedup probably doesn't matter, I'll leave this as a hypothetical. You say you "don't like the asterisk", but that's kind'a how it's meant to be done. I guess you could go the Julia route ( + + ), but that's not really better. After a few miscellaneous changes, the code for me looks like 

So the next thing to tackle is or , depending on which interpreter you care about most. Going with , I currently have: 

Now, you might wonder why bother having at all; with non-member functions seems to do fine. This is true; the only advantage of currently is that it collects member functions into a well-defined scope. However, this is not always worthwhile, and you should feel free to just stick with using non-member functions. I would reconsider . A direct translation would be 

which currently throws an unhappy error. You could also do whitelisting at the same time, further reducing the amount of unwanted computation that can happen. This is a bit long because each case needs dealing with separately but the cases themselves are rather straightforward: 

This is way faster than before (again). But we can do better; there is a squaring version. Stealing from $URL$ means that the whole summation takes only \$\mathcal{O}(\log n)\$ operations. Here's a table of the maximum sum computable with a budget of 1 second to one significant figure. 

Note that is actually cheaper to calculate at once, simplifying to just . Further, note that we can just compare to instead of to ; given the approximation of in the input this is basically the same as comparing to . Now, this might be problematic if you want to generalize, but there's actually little reason to have a . If the number doesn't stabalize, you'll just get a . That said, I'd actually avoid generalizing too much; a good square-root algorithm is not in this case a good general algorithm. It makes sense to specialize this use-case because you get both speed and accuracy improvements from doing so. A general algorithm should also support several cases you currently don't; look at how works for useful ideas along that line. 

You haven't explained what makes these transition probabilities different, so the whole thing is really confusing. However, you only use this later on with and co., so just move it down there: 

are bad; if the programmer needs commenting then the user is going to be confused. The function should just use a dictionary: 

This gives a generator of methods, rather than printing them, which is much more useful. Printing the output is thus done with 

which I hope you'll agree is simpler. To add a check for if any file has been removed, try something like 

This gets rid of the class for convenience (tuples are easier here). now generates the board and passes that to . This improves times: 

doesn't seem to be useful either; if the in the is ever hit the loop will be exited by the and if not, the will only exit after anyway. Therefore we can have just: 

For some reason there's a trend among scientific Python users to import things with really short names, like 

If and are wildly different (they can be up to \$10^6-1\$ different) then this will take a long time. For a maximum of \$10^6\$ iterations, this could take a while. What you should do instead is pre-process the string so you can quickly do 

leaks a file handle. Always (almost always) use for files. Do so in too. The flush here isn't needed: 

You don't need line continuation characters inside brackets. After splitting up your lines, says most of your time is actually in 

Remember, this is a round table. So if it's a round table... what better to use than a circular buffer? 

assumes but does not require , and then does even not use that fact! For if you used that fact, you could have just done 

in part so it can replace the other assignment. I would move it into a new function and rename the variables: 

$URL$ So this doesn't tell us anything (assuming it's true for any order, which it is), and we can drop the condition. 

This does highlight a problem, though - you still increment one of them if they are equal. Try instead 

However, this hasn't separated logic from UI (output), which is another important aspect of code quality. It also doesn't deal with invalid input (such as non-integers being passed to ). 

as you never have the large intermediates then, and there's no real point converting back from a set. This stuff: 

My first comment would be to comment your code. You need documentation so I know what your function is meant to do. "Sum any given finite Arithmetic Progression" would suffice if you passed in an , but instead you pass in some bounds. Writing an arithmetic progression type would be simple and might even help a little, but you still need to document that. I don't know what algorithm you're trying to use. You've evidently taken some maths for sums of arithmetic progressions and applied it to the problem, but there's no way for me to verify that the maths is correct or that the code implements it correctly without at least rudimentary explanation of what you did. I could reimplement it myself, but code should be verifiable much more easily than that. 

You should probably prefer as it's less likely to vary on different systems. It's not a big deal, though. You should use , even for , so names like and . Don't call ; use instead: 

as the moves you on for you. Note that not seeking is important when using buffered streams if you want them to stay fast (hence the need for two buffered streams on the input file, rather than 1 with seeking). Manually buffering with may seem tiresome but it works. 

I don't know what's up with the spacing in the docstring, but fix it. Your doesn't work with everything: 

You should be more careful about how you handle errors in ; if the constructor closes the file should also be left closed. Your first read to find the endianness uses the default, platform-specific endianness. I would imagine you want a more sensible default like . remakes its entries every call to . It makes more sense IMHO to generate once on creation. All in all, I get something like 

I've mentioned a lot of times about thing that shouldn't be properties; I actually think it makes sense for to be a property. doesn't need to yield names for the move (eg , ) since these can be reconstructed after the whole sequence is made. would then become a on . Doing so actually doubles speed for me since there is less packing and unpacking to do. Since much of the time is spent in , it would make sense to flatten the grid so that can be simpler, even at the cost of potentially complicating other sections. This gives another 2x improvement to speed. In , you can now push a little more into the by directly hashing instead of the . Since I've been talking about speed, my solution is between 2 and 10 times as fast as 200_success' and some similar significant amount faster than the original. It's really hard to time due to random factors such as hash randomization so take these times with a grain of salt. Oh, also I'll steal 200_success' idea to check for solved solutions before they are added to the queue. A final style point: can return since impossible puzzles do exist. This should be documented in the docstring to tell people to check for it. Here's the code: 

Sort your includes. Your has poor names. Something like , and would be better. If you don't want to give it better names, just use a . takes a line and tries to fill a record. It would be more senible to just a record (out-parameters are largely a bad idea for small types). This does mean you actually need to handle the early-return cases. For the moment, I'll just return - this is at least better than the old arbitrary-data return value. The input should probably be taken by . The constraints 

it comes at no extra cost. It also gives more internal flexibility for to, say, lazily produce values. 

You don't use - remove it. Rather than rename to , I would directly import and . Use new-style formatting, please! Also, use instead of - using neither would be best, although its use is mildly understandable in this case (even if still saddening). Don't call - this is a function only for interpreter usage. I actually suggest just ing in this case. Your subprocess call only wants output, so drop . Further, you can just call : 

But this just makes it obvious that is never used by the function, so shouldn't be passed in in the first place. This means that the comment for the function is also a lie! So what is doing? Idunno, let's work it out. tells me nothing about its purpose, but I can see that it's a mapping from numbers inside the triplets to counts of some kind. This suggests a , though that doesn't clarify a lot. The comment doesn't really help either. I'll call it for now. Note that is just , but the first loop can just be 

If you're actually targetting 3.4 only, don't write in the inheritance list. If you're potentially wanting 2.x compatibility as well, though, it's good to keep it. You have 

A simple should be fine. Your should be . You might find things easier if you use a over a as you can avoid all of the calls. can also be a . I find this gives a significant speed improvement. You spend a lot of upkeep on ; there's no real harm in using , so I suggest you do so. There seems to be no good reason for this line: 

\$ \newcommand{\pt}[2]{(#1 \!\times\! #2)} \$Here's some commentary about potential algorithms particularly suited to Python. Note that a general optimal algorithm might not be suitable for Python because Numpy almost requires you to be able to vectorize your calculations. The aim, basically, would be to make maximal usage of . This will require moving the data into homogeneous pure-Numpy arrays. I suggest 

I'll assume the first few style changes that jonrsharpe mentioned. I think setting up colours separately to other constants is actually advisable, but you should at least use the class: 

Don't use generic-yet-novel exceptions like - it tells you nothing you didn't already know. Rather, reuse standard exceptions to give the user some way of distinguishing errors based off of meaning: 

since each subsection is a logically separate action. In fact, you could make each a separate function if you wanted. Consdier the first branch. 

would likely break if a file is created or deleted between the check and the action. You should check the provided API for solutions here (although this might not be a problem). The code 

You don't need to check if you're just adding a on the end. However, you don't need that anyway due to the block for loops: 

but you run these at most twice and $$ 2 \cdot \mathcal{O}(n) = \mathcal{O}(2n) = \mathcal{O}(n) $$ Since the overall cost is at best (hopefully) \$\mathcal{O}(n + (largest - smallest)) > \mathcal{O}(n)\$, this does not affect overall running times. They are also very fast operations. However, since you're already sorting the array, indexing will be faster. All of this is not needed if you make your main loop more robust: 

This removes recursion limits, but it still involves a ton of redundant work. You actually want a stream, so I suggest instead ing the results to make an iterator. This prevents pointless recomputation. 

Personally the indentation of the strings is odd; I'd treat it more like a block of code and indent it singly. This is more my preference than anything. According to PEP 8, the name should be lowercase. Similarly with the name , which should be longer. However, these are hardly big deals. 

Your requires two calls to - this can be one with . Consider also using PEP 8 spacing. You can also remove the in place and an : 

Instead of storing the whole grid, each row is stores where each circle starts ()and where they end (). If you have many tiny circles, the original method could be better. If you have even somewhat large circles this should be faster. 

Note how the comment can now be removed. Here's an attempt at a cleaner version. I've also added a couple more speed improvements, because I'm a hopeless addict: 

Your sort is of course inefficient; you're using selection sort. However, you can at least make it a little faster. First neaten it up - including changing the name to something more descriptive. Note that is not a value but an index - this should be fixed. 

Your could utilize better naming and the last should be split into two. I would also reduce the number of decimal places printed: 

This initial generation might take a long time, though, as you need to generate a list for every possible letter - and there are a lot of those. If you only generate a list for which there is a letter in the string, you've improved your worst case but you're still generating a large square. This could be expensive. One other option is to store indexes: 

is prone to TOCTOU race conditions. It's probably not especially worrisome here since your whole code is one big race condition of that kind, but you should be aware of the risks. In you write 

which means that you're returning instead of in the first branch or if all three s fail. However, it's OK as you never use the result. Remove it. In , you can simplify generating with a list comprehension: 

They differ by . So we are adding up: $$ 1 \, (\text{divisor} + 1) + 2 \, (\text{divisor} + 1) + \cdots + (\text{divisor} - 1)(\text{divisor} + 1) $$ Letting \$\text{divisor} = d\$, this is just $$ (d + 1) \sum_{k=1}^{d - 1} k = (d + 1) \left( \frac{1}{2} (d-1) \, d \right) = \frac{d^3 - d}{2} $$ giving the much simpler 

Instead, though, don't put this information in - use and multiply out when using the results. Don't call variables . It's a poor name. You've double-indented the part where you update the neighbours. Note that 

shouldn't be needed so remove that too. makes a string of the form crops the final and then splits it. You can just do . seems to be what you're merging into, so call it . You use once, so just put its value where it's used. This does nothing: