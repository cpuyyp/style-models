Now, we've extracted the entire game result to a new class to eliminate the need for string processing. (This is far better for multi-lingual setups, or setups where you just want to dump this result to a DB, etc.) Notice that I left out, that's irrelevant to the result of the game playing method. It doesn't care about the game number, only about it's result. Next, we'll use this in our method: 

There's no telling what those numbers ( and ) mean and why we're looking at to determine if that's what they are. Create a constant that represents them and compare against that. 

Are inconsistent, generally speaking I prefer to inline the pipe when there is only one pipe happening. (It seems to make be more readable that way.) 

So it proves that nothing else needs to happen, the last thing is the recursion. Writing like this is called "tail-call recursion", the idea that the "recursive" call is the very last call to happen. If that is the case, then the function can recurse infinitely, and F# will rewrite this as a loop in the ter. I'm telling you all this so that I can demonstrate the purpose of this: if we write this factorial algorithm as a loop, it would look like the following: 

Pretty simple, I didn't pull all your code as I didn't need it, I just needed a mock. Within our transformation system we need to find a method dynamically, sorta. We want to find the method that has the return type of our input parameter. Of course I should mention that the final API call will look like this: 

Since you are already throwing your own exception, you should use instead. I know, you want to have an on your , but consider: what value does it add? It also only indicates a problem with one element, whereas if you use , you can indicate to the user all the elements that had problems. In my opinion, that's a much more helpful exception. Plus, catching and throwing is slow. There's no need to catch an exception if you can avoid it completely. You should also consider adding the appropriate attributes for (and the like). I find that I use this (and way more often than any others, but they require special attribute management. 

You just change whether to restrict the time to be between the two, or to restrict it to be greater than one or less than the other in the case that the time is less than . 

The block in this just prevents the last line from being ~2x the size of previous lines (which can be the case if there are high-code-point UNICODE glyphs. Finally, I assemble the entire result in a method: 

The first thing I would do is spend a bit of time cleaning up your formatting. It's very hard to read as it stands. 

I previously touched on some basic composition stuff, and I want to continue that discussion with some new examples here. We have opportunity to use some function composition in this code, which lends us to partial application, and allow us to not care about the node parameter to our functions. For example, we can take your and functions and simply omit the parameter and our functions still work the same, thus leaving them agnostic to what's applied even moreso than they were. But what if we want to omit node from ? Well we can't really do that as it's written, because the pipe-right () operator expects a value, not a function. Now we can use the compose-right () operator to eliminate that requirement: 

You shouldn't have to inspect something and read a 'Description' attribute when programming to find out what it does or represents, the name itself should tell me. 

All I have to do is provide a bad string in that JSON for and now I can destroy your database easy. Solution: prepared statements. 

Generally it is frowned upon. You should declare variables as close to their usage as possible, and within the tightest block that they are to be used in. For example, the: 

Let's look at what we can improve here. First, we notice that if then things cannot really happen here. So, let's move that to the top of the file. 

This will centralize the common methods/properties/events/etc. with all your characters, meaning, you only have to write the implementation once. The only downfall is that you can only inherit one other class, any other "inheritance" must be implementing interfaces. That said, your abstract class can also inherit one other class and other interfaces as well. 

Our entire programme is now down to 29 lines with appropriate whitespace, and supports much more than your original did. (Your original was 44 lines.) 

We can refactor with no issues. (This may not seem like a benefit, but it adds significant value to the code in the form of idiomatic code. It's much more clear what is going on with this example, than with your original code.) 

I'll post up a much more complete solution later, but you should be able to make this work as expected. :) 

I wasn't originally going to post this answer as it seems like petty things, but alas, here it is. I mean no offense by any of it, sometimes I tend to type things out to seem that way, but it's all in good spirit. :) 

So now our input prompting is separated from our processing, that's good but we can do better. The block is now something along the lines of: 

This is pretty self-explanatory, and it should make sense. The next step is directing the user to . This is where magic starts happening, and this is where we start making actual MVC decisions: 

Based on the research I could suss-out in a short bit, this looks like it's appropriate for EF-Core, whereas the accepted answer looks more like EF on standard. I can't test it, so I leave it to you, but I would go more towards this route than a shared lock. Of course, it's up to you, but I wouldn't even try to re-save the on a duplicate key violation, because we know it's going to be right now, so why do the extra work? I'd just and swallow in this case, with a clear comment as to why: 

First, C# member naming rules indicate that should always be used; second, we talked about the properties thing already; third, the value is the default for types. .NET languages have mandatory default constructors on objects that initialize all fields/properties to their default value, for any numeric type (, , , ) that's , for it's , etc. 

Architecture. x86 / x64 / Any CPU, this directly affects the compilation, default JITter used, and how the OS handles the resulting program, and what .NET does. Calling the algorithm directly or via a . So this is a potential issue, you call the method via , which can add overhead. (Or not, depends on the JITter!) Dispatching. You built a dispatcher, but you didn't use it. This is a factor we have to grade. Other values. You tested , but what about other key values? Large values? Like, 2, 3, 5, 9, 15, 16, 25, 255? 

tags are expected to be block-level elements. That is, they take up 100% of the width of their parent, by default. (Or whatever the browser is configured for.) tags are the opposite: they are inline elements. That is, they only take up enough space to fit their content, by default. They should never include other block-level elements within them. 

This is so that variables cannot unexpectedly be used in places where they should not, and so that they can be recycled when they fall out-of-scope immediately. It also means that you cannot accidentally use the value of them outside of the block they apply to. 

Absolutely correct. Using an additional type for the colours (as I assume that's what you were using a for) will be slower, it's more method calls that have to be made. 

But we don't want to do that: we're casting then testing for /, but there's a more effective manner: we can filter first. Enter the operator. This will do a direct cast to a type lower in the type hierarchy, that is: this will do a runtime cast to a sub-type. (So if we cast , this let's us go back to .) I wish this were synonymous with the operator in C#, but it's more like an explicit cast: . Our new function looks something like this: 

Another suggestion: pass your (or ) object to the method. This helps significantly as, at some point, you are likely to want to affect other characters. Create an abstract class for it and abstract away the method. 

Which silently does the null-check. You can also use it in statements, but only where or are valid values. So for example, the following would be invalid: 

Yes, you should look into the Stopwatch class for timing. It's much more accurate than using strings printed to the . It also allows you to easily reset it and such, so you could build a very effective diagnostics procedure that would measure the specific performance impacts that you are trying to. 

As far as security goes - maybe. I'm not a security expert, but I would be wary of having no input validation here. At the very least, do not allow input with a semicolon (), as that can totally mess with your connection string. 

Note: I'm not an angular.js guy, or a Javascript expert, so the above may need tweaking to work. This should help separate responsibilities of your code, and make it easier to maintain. 

Arrow-code is never appreciated, and nothing in that block becomes more complex when it's refactored to one level: 

Doing four times is slower than . (Of course, the location that is used should be a method instead.) 

Oh boy, that got awkward. This one is about 1.75x the time mine took, bad deal. Does Any CPU hold any luck? 

We use the to remove the period. That way, if you add support for a different file type, you just add it to . 

Finally, to conduct an experiment we absolutely 100% entirely need a control. You cannot justify a scientific result without a control. Our control will be a base . Nothing more. So I built a basic benchmark: five methods. One does , one does , one does , and the last does . I'm going to post the x64 result first: 

This is only one line-of-code longer than your version, but it should perform more quickly and is also clearer about what the last step is (remove the last character). Of course, an alternative implementation that avoids manipulating the like that might look like: