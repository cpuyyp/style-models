In order to understand single line of code, I have to go through lines of commenting junk, 1 line boilerplate Java and at least a closing bracket. This is useless. Anybody with little experience knows what this one line does, so why spend time on commenting it? Without the comments it is much better to read. 

I'm learning go. I wrote a simple logparser for SLF4J in Python some time ago and tried to port it to go as an exercise. The algorithm is identical, but the go-solution isn't quite as fast (the Python solution is about 1.5 times faster for large enough logfiles). Is there any way to get more speed out of it? It do not care, which one is the fastest, but I wanted to know if I could do better with go. Any inspiration is welcome. A typical logline looks like 

there should be no reference to a console at all. 5) Perhaps it makes sense to outsource the writing of a report to a report writing class. There you have a List of Writer which take a Report as an input and produce the wanted output. 

Think of the simple case: Is it likely, that the caller of your method has the ID of a person or the complete ? Most of the times, I suppose is the former the case. Then you have to build a -Dummy only with the ID to use your method, which makes no sense. On the other hand, you could if you really really can't decide, which one is better simply use method overloading and offering both. But that would perhaps clutter your API. It's up to you. 

That is not only handy, but cool B-) Besides it is nearly as readable as and not so noisy like the typical string concatenation and the risk of typos is really low. 

Why are you repeating the same task? You could refactor the into a constant: . Everytime you need a separator, you could use , which is more meaningful. 3) You should separate concerns 

So there is nerver an inconsistent object created and no objects were harmed ;) Another solution would be to allow the creation of an empty commentary, but check later, if comentari.getTexto() is empty and handle that fact later. So the try/catch looks like: 

This code needs some refactoring. Here are my suggestions: 1) since you have some kinds of reports, which seem to share some common behaviour, you could use a base class and some classical inheritance. So you have to write the execution logic once for all cases, where no change is needed and override in your subclass, where changes are needed. And your interface would be obsolete. "startDate", "endDate" and "reportType" would be member variables of the class. And at best start/endDate of some date-type and reportType as an enum. 2) it is bad to gereate new objects in objects. That leads to code, that is hard to test. Instead of 

I don't know if it is good practice, but in my eyes it would be cleaner, since you have several JS-files at this point, to separate markup, layout and JS completely. So would reside in a .js-File. In some cases, when you only have a few lines of JS or -on the other hand- if you have to care for every millisecond to deliver a good page experience, it would make sense to embed JS in the html-file and retrieve the non-critical JS at later time dynamically. It depends on your usecase. 

Define your omitting filter and apply it to your array. For read the according MDN-article. 3) Doing it with a RegEx: 

You are not iterating over in you are iterating over , which are perhaps from a ; in the function (and for python) it doesn't matter what the source is, but you should choose an apropriate name. You make your and your peers life easier, if you try to write better, i.e. cleaner code. 

Um. There is verry little code, so one can not say much about your code. It does, what it should, I assume. One thing, I see is, that you are alerting a message, which has nothing to do with the validation. So if you are looking for SRP - the separation of concerns, you take the alert out and put it elsewhere. Of course you could shrink the whole thing down to 

So. The Horse knows best, upon which grounds it would walk. 3) The Factory should know nothing of the abilities of what it delivers except the type. The ground which a transport is suitable for is up to the transport itself. It knows best. 

No. Within Javascript there is no way. But it is possible to send a message to the server, which lets the server know, that you wanted to delete one entry. It is possible to intercept the rendering process of , so that you generate attributes, which you could use to identify the objects displayed in the column (e.g. an ID or the like). And you could then initiate a request to the server 

does exactly that. What your code is lacking is the initialization of the datatable (see (3) ). And then you are done. P.S.: Perhaps this is interesting for you. Edit: I forgot to address this point 

One reason to choose OOP is the advantage of creating an object in a predefined state. What you wanted is: you wanted to create a valid Comentari object. What you did is: in case the state of your object would be invalid, your object would be created and just break in to pieces because of your exception. It would be much cleaner to wrap this into a factory function like: 

The same as above: Don't throw exceptions in a constructor! Additionally: If you do not allow blank books, why check for blank books in the ? Are you afraid of malicious subclasses of books, which allow blank books? 

That is a real code smell and should be refactored. How should any mortal soul unterstand, what this code does? Why not using a simple object? 

That's okay. You could improve on your current design by these minor changes: 1) If you know, that the binaries are in blocks of 8 chars each, you could simply omit filtering the noise and incement by instead of characters. 2) You do not need to split the string into an array. does, what need. 

If the user is already authenticated, there is no need to adress this case. You are responding with which is wrong: there are no ressources conflicting. A reason to throw a is: e.g. when you have a content management system with a versioning field, and a user wants to update with a version number which is lower than the current one; then that is a Or when you wrote 

This code is way more readable. You have the static constructor block, where you register the factory methods according to the keys. And the -Method shrinks to 3 lines, of which one is a purely guarding clause. Edit: modified after Mat's Mug's hint. P.S: Oh, I forgot to mention, that you really never should return . Better a) throw an Exception or b) use a . 

Here is a Fiddle to play with. This should do for many applications, you write. If you have many modules, dependencies, etc. I would take a look at RequireJs 

As far as numpy goes, I can't say anything to that. But what I am generally missing from your Code is abstraction. This makes your code unelegant - at best. OOP ftw! This comes with ordinary lists, but it helps to clarify: 

For this example, the use of is not necessary, but on the other hand gives you something like a lightweight object which could not only contain lables. On top is very readable. 

Here is the fiddle to play with. To make HTML-generation less painfull and a bit more JS-stylish I define what is called a higher order function : simply a function returning a function. A call to generates an anonymous function (a function without name), which returns every time it's called ""+ +"". The same goes for the other tags. This allows me to do something like a DSL: 

you could "inject" a Dao via "constructor injection". If you take step (1) you will have to split your concerns: a) you need an object to represent the report itself and b) you need an object, which creates different kinds of reports. There will be the right place to inject your DAO. 3) What are these details about? 

If you take a look at both blocks, they are the same, aren't they? But for further improvement, I would suggest working with a where you have usernames as the key and the according List of Names as the result. Second: I would reccomend you to take a look at Google's Guava Library esp. the section about predicates . Third: I am wondering, how you could retrieve any correct item. As far as I can see your names have to be unique to resolve the correct items. The collision rate for (nick-)names is generally high. So it would be better to switch to some ID-mechanism. Fourth: The task is in itself nested; you need to iterate over a list of items and over a list of users. So you couldn't "avoid" a nested loop. Okay: If you let a database do the magic, you didn't loop at all - the database does. But I think, that is not the answer you wanted. 

Does, what it should. Is simple to read, and was just invented for that purpose. I wonder, why nobody else came up with it. 

Will anybody know? Okay, I admit, at least you know. But think of a freshman, new to your code: it will take (too much) time, to get his head around the code. 4) Shorten your methods. 

Edit: It prevents you from precalculating your values for each if-clause. It's easily extensible: Just add another unit, wherever you want. And for the rest: it does its job in an easy understandable way. No rocket science. 

For a beginner you have a really good starting point; better than most I've seen. In principle you are following sort of revealing module pattern; not quite right, but it points in the right direction. Some comments on your code: 1) if you are the only developer responsible for your JS -or as in my case: make up an example- you are free to name your variables. But if you don't, please choose meaningful names (e.g. , `netflixPlayer etc) 2) You've chosen to encapsulate functionality in a single object. That is good! But I would prefer to make the object's interna less accessible: There is the IIFE-Pattern, which does exactly that. As you know, functions have their own scope. The trick is to immediatey invoke a function (hence the name) - notice the second parens after the definition of the anonymous function. If your function returns an object (like your code did), you have the exact same functionality as in your code above, but made the interna not accessible from extern; you only reveal a well defined API (hence the name . As with ordinary functions, you are able to pass parameters (which could in turn be other objects). This allows for a really modular code: 

Models have events to which you could subscribe. Most used is the "change" event. So you could bind a function to a general change by just declaring 

It's been a while, since I've been on the ASP-Road, but I hope to provide you some help: 1) Read the Documentation of DataTables, especially the paragraph about Ajax source data. There you learn how to use Datatables with server generated data. Serverside processing might be of interest too. 2) You are free to use a html-skeleton (as you did), but you could use Custom Column Definitions 3) In order to get the Datatables Plugin to work you need a) an Element in your DOM, where the Datatable can hook on: does that; and b) you need data to display. There are two basic formats: I) You have loose data, which is represented as an of . Each representing a Row, which consists of an of columns as in this or this example. II) You have structured data, which comes as as in this example So when I get your example right: 

And the Class Region could be refactored to a simple Enum (as it goes along with your further domainlogic). 

Done. Even if it is not the fastest solution, it should not be too bad for only 5k objects. It is simple, readable and not errorprone. 

So, I would prefer this approach as a first shot. And if you have to later add more complexity: refactor it! But perhaps YAGNI comes, and you have never to revisit this "ugly" code. There is no overcomplex Abstraction or Overengineering invested. Of course, if you are dealing with instead of you have to take care, that they are comparable to each other. 

So if I am getting it right: it puts, what it finds in values. I think, you have a lot of work to do. 

That are values. Up to this point, one has no idea, what this code is about. If you are dealing with books, you have a book, which consists of pages, which have lines, which have characters. So that would be the way to go. 7) What does the following code do?