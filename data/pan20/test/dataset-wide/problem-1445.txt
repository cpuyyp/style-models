is a blocking method; you should use . Network I/O is almost certainly the slowest part of the whole operation, so it's important that we're not blocking here. You might also want to consider using the newer instead of . The third parameter of is the length of the array, but you're passing it . I think you want to pass it instead. There's no need to set to . I don't really like that modifies the parameter. Since the method is private it's not that important, but it is, to me, surprising behaviour. To avoid this, I would consider merging and into one method, e.g: 

I find the logic a bit hard to follow, especially in , so I'll just comment on some minor issues and post some recommended reading. 

A rule of thumb for performance in C# is to avoid allocations. In this case, we should try to remove , as well as the calls to and that appear at the end. Of course you need to set performance goals and profile the code yourself on realistic input. Single line strings can reasonably be expected to be quite short (say 200 chars?), so what you have already might be performant enough, but I'll illustrate an alternative way. First let's make this a static method so it will be easier to unit test. As I mentioned in the comments, there's a bug in the code -- unit testing can help you catch such bugs. 

There is a canonical solution to this problem that makes one pass through the string, and uses a stack. A search for "balanced parentheses" will turn up hints/explanations, if you get stuck. 

Look familiar? I'm going to re-post part of an another answer of mine. Suppose our array \$s = s_0 s_1 \ldots s_{n - 1}\$ is of length \$n\$. We define a function \$f\$ such that \$f(i)\$ is the number of ways to interpret the suffix of \$s\$ starting at position \$i\$: \$s_i s_{i + 1} \ldots s_{n - 1}\$. In this way, our final solution will be the value of \$f(0)\$. How many ways are there to interpret the empty array? Just one, so we can write \begin{align} f(n) &= 1. \end{align} Now how about the suffix \$s_{n - 1}\$? Well if it's \$0\$, that's invalid; otherwise there's just one way to interpret it. \begin{align} f(n - 1) &= \begin{cases} 0 &\mbox{if } s_{n - 1} = 0, \\ 1 & \mbox{otherwise}. \end{cases} \end{align} Now for the general case, the suffix \$s_i s_{i + 1} \ldots s_{n - 1}\$. If \$s_i = 0\$, there are no interpretations. Otherwise, we have two cases to deal with. If \$10 \leq s_i s_{i + 1} \leq 26\$, we can interpret the suffix as \begin{align} (s_i s_{i + 1}) \underbrace{s_{i + 2} \ldots s_{n - 1}}_{f(i + 2) \text{ interpretations}} \quad \mbox{ or } \quad (s_i) \underbrace{s_{i + 1} s_{i + 2} \ldots s_{n - 1}}_{f(i + 1) \text{ interpretations}}. \end{align} Otherwise, we can only interpret the suffix as \begin{align} &(s_i) \underbrace{s_{i + 1} s_{i + 2} \ldots s_{n - 1}}_{f(i + 1) \text{ interpretations}}. \end{align} Putting that all together, we get \begin{align} f(i) &= \begin{cases} 0 &\mbox{if } s_{i} = 0, \\ f(i + 1) + f(i + 2) & \mbox{if } s_i = 1 \mbox{ or } (s_i = 2 \mbox{ and } s_{i + 1} \leq 6), \\ f(i + 1) & \mbox{otherwise.} \end{cases} \end{align} So in the worst case, for example , this reduces to the \$n\$th Fibonacci number, giving us space complexity \$O(F_n)\$. 

I find it hard to imagine not ever wanting to compare app versions, so you will probably want to implement . 

(Image license: Creative Commons Attribution-Share Alike 3.0 Unported.) For an input of , should construct the figure on the right. The only difference is that instead of an EOW link, states are marked as final. The algorithm for constructing the data structure is from the paper Incremental construction of minimal acyclic finite-state automata. 

Let's start by analysing the current algorithm. Each day that plants are dying, we iterate through all living plants. So the worst case would be if only one plant dies each day. In this case, we can see that the algorithm will take \$O(N^2)\$ time. For example, the input sequence \$ 1, 2, 2, 2, 2, \ldots, 2\$ will exhibit this quadratic behaviour. From the problem statement, \$1 \leq N \leq 10^5\$, so we will have to do better than \$O(N^2)\$. 

@BlueTrin's answer shows how you can trade space to reduce the time complexity to \$O(n)\$, so I won't go over that here. All that said, there is an elegant way to express this using LINQ: 

Every other term is 2, ... etc etc. That gives us a strong hint that our function will look like this: 

The regex silently fails on inputs that don't have length a multiple of 4; i.e. no results are returned. Things that fail silently are incredibly hard to debug. It's easy to imagine trying to figure out why no rows are being inserted for the input 

You could use the visitor pattern to separate the traversal from the processing logic. Define an interface 

There's no reason for to be protected; in fact, if we make it public we can let implement (not forgetting to add a null check). 

that is, assuming you don't really care about the value returned by , you just want some non-negative integer. 

There is a more functional approach, maintaining a count of how many parentheses are open. Let's start with the function signature 

The looks strange to me, because I would expect the method to return when the time is exactly 8am -- that is, I think it should be . As it stands, it returns one millisecond after 8am, but at 8am exactly. Whether or not it should return when it's exactly 8am is of course up to you and your requirements, but if you want to return for 8am, I think that line deserves a comment. (If you do decide an event should be sent at 8am, be sure to update as it says that no event should be sent at 8am on the first Monday of March, 2016.) Besides Jeroen's excellent points, I think the code can be simplified. Assuming we decide to include 8am, I would write 

This is looking very good. First thing I would do is split out a method, , and rename to . Then I would put braces around the , maybe invert the condition to reduce nesting, and call it a day. Ah, whoops, this fails on an empty array by returning the answer 1. Fix, add a unit test, and now we're really done. Until... I notice that the complexity looks like it's \$O(n^3)\$. Let's increment a counter in the inner : 

I'm worried this is turning into Code Golf, so I'll preface my alternative with some actual review. There is a pretty big bug in your code, as the following will not terminate: 

Now the logic inside the loop can be simplified. We're adding three bits, setting one bit of , and calculating the carry. 

A similar problem is also present in the method presented here: we end up writing 403 bytes, not because of buffering but because of how we're counting. If you want to be precise about the total file size, you will need to modify it. 

If the order is important to you, then we need another solution since "The order of the keys in the is unspecified". The obvious solution is to use a , but this gets very verbose: 

As @vnp stated, there is no known efficient (i.e. polynomial-time) solution to the subset sum problem. That said, your code can be made to run faster, but first I want to address a few points. 

This makes it clear to the reader that each element of the input array will be assigned to. Now we can keep track of where the next element for our array is coming from: 

I ran the code and found that summing the values sigma(0) ... sigma(500000) took 1 or 2ms, so there was a discrepancy of about 502ms compared to the timing posted. Fortunately you included the time taken to fill the cache: 

If you install hlint you will also get warnings about things like the redundant parentheses that were around . You can set up your editor to run this automatically on save. 

I think there are issues with both implementaitons, though I do find the first more readable. The main problem is that neither makes it immediately clear that we are assigning a new value to each element of the input array. I would expect an implementation to look something like this: 

Much of the original code is concerned with whether or not the object has been disposed. I don't believe it should be the responsibility of this method to check if the has been disposed; I would suggest instead to restructure the client code such that is not disposed until the notes have stopped playing (or play has been cancelled, see below). Unfortunately, it's hard to be more specific about how to do this without an example of the client code. I would also recommend removing the class. You might want to support cancellation with a : 

I believe your solution is \$O(n^2)\$, and we can reduce that to \$O(n \log n)\$. I'm not well-versed in python, but this is the general idea: 

Let's think about this geometrically. Since we're treating a pair of neighbours as equivalent to , we can think of our neighbour-relation as being directed. That is, from up/down we can pick one (let's pick down); similarly for left/right, up-left/down-right, and up-right/down-left. Now most elements have three neighbours: down, right, and down-right $$ \begin{pmatrix} 0 & \rightarrow & 3 & \rightarrow & 6 & \rightarrow & 9 \\ \downarrow & \searrow & \downarrow & \searrow & \downarrow & \searrow \\ 1 & \rightarrow & 4 & \rightarrow & 7 & \rightarrow & 10 \\ \downarrow & \searrow & \downarrow & \searrow & \downarrow & \searrow \\ 2 & & 5 & & 8 & & 11 \end{pmatrix} $$ We can find those neighbours with the following code: 

As your update specified that you want to use recursion, let's see what we can do. Cleaning up, we can remove the (and the extraneous semi-colon). 

defers to 's , which makes no guarantees that it won't return . How unlikely is it? Well I've had a program running for fifteen minutes now to find a with a hash code of and I've only found one, but it can happen and it's good to be aware of (and fix!). One neat way to fix the bug would be 

This code will visit every node in the tree, but it's not always necessary to do all that work. Instead you can do a breadth-first traversal of the tree, and look for the first node that has no children. Consider this tree: 

Since we're interested in \$s = 3\$, the time and space complexity is greatly reduced with that variant. A further hint on how to implement that improvement is provided on Wikipedia's page on the Wagnerâ€“Fischer algorithm. 

It's unfortunate that only implements the non-generic (though that's being fixed), but we can use to get around that. This is how I would suggest writing the main part of the first method: 

That's correct, but since your parameter has type , and the method is public, you have no guarantee that the underlying collection is an . Even in non-public methods, if you assume the underlying collection is an , your method signature should reflect that; if you decide to accept the more generic , then you should use . Otherwise you have hidden assumptions throughout your code that the type system cannot help with. 

Inspired by this question, I decided to grow my own fractal tree. The problem is: given an integer \$n\$, \$0 \leq n \leq 5\$, print the \$n\$th iteration of the fractal tree. The tree is probably easiest to describe in pictures, so here's a minified version of the first iteration: 

Given your clarification in the comments that your are getting organizations from a database, you should let the database do the hard work for you. The code will depend upon the ORM you're using, but a relatively SQL-agnostic version of the query will look like this: 

The complexity of this method is actually \$O(n^2)\$, where \$n\$ is (which is equal to ). Let's expand out and see why. 

First up, that has to be one of the most niche functions I've ever seen :) Is there a real use case? Is this homework? The prefix seems strange. You obviously can't call it , and the definition of the function is so odd to me that I can't think of another name right now, but I would recommend thinking hard about the name. I would recommend installing . It will give you suggestions on keeping code clean, and using standard functions. For instance, 

I find that helper methods and on can make tree code a bit cleaner, in general. It's not of much advantage here, but just for reference: 

does not guarantee that it will only ever return -1, 0, or 1. So if , this method will return 2. You also don't want to do this: 

As has already been pointed out, a is not the best match for this situation. Instead we can just enumerate the substrings that we want 

Your algorithm and JanDotNet's algorithm will run in \$O(n^2)\$ time. We can reduce this to \$O(n)\$ time by doing the following: 

It doesn't seem like this method should be responsible for locating the inventory. It is probably better passed as a parameter. 

That is redundant and can be removed. Using a for is roughly twice as fast on my machine. Avoiding strings altogether is faster still: 

Your definition of is very close to this, but we can use the following trick where refers to itself, just as in the formula above: 

Consider adding a constructor so that client code doesn't have to allocate a byte array or string, or manually convert the bytes to a . 

This prints , but the second call to should throw an exception, since the queue is empty. I would follow and throw an . If we call another 15 times, we do get an exception, but it's an . This bug also stops us from enqueueing: the last line here will throw an , since is -1. 

\begin{array}{ r | r | r | r | r } n & \text{Equal} & \text{Alternating} & \text{Sorted} & \text{Reverse sorted} \\ \hline 10,000 & 7.9\text{s} & 1.8\text{s} & 7.8\text{s} & 7.7\text{s} \\ 100,000 & \text{N/A} & \text{N/A} & \text{N/A} & \text{OOM} \\ \end{array} N/A is where I gave up waiting after a minute. By comparison, on the same machine: \begin{array}{ r | r | r | r | r } n & \text{Equal} & \text{Alternating} & \text{Sorted} & \text{Reverse sorted} \\ \hline 100,000 & 4\text{ms} & 5\text{ms} & 2\text{ms} & 3\text{ms} \\ \end{array} One advantage of QuickSort is that it can be done in-place, which is not happening here. If you're OK with allocating more memory, why not use Merge sort with its worst-case \$O(n \log n)\$ time guarantee? Another issue is the choice of the pivot. Choosing the first element will give quadratic performance for sorted inputs. One option is to shuffle the input array before sorting; another is to choose the pivot at random (these are not the only options). Robert Sedgewick* has a great page on QuickSort which touches on a lot of implementation issues. He also has a couple of implementations in Java, which translate easily to C#. *Who did his Ph.D on QuickSort under Don Knuth, so well worth listening to :) 

The method lets us use the same initializer syntax we used for the . And then you can use the constructor. 

We start by solving the more general problem of finding all indices of in . Let's look at the skeleton of our solution. 

And then create the method dynamically, using reflection to find the properties of that have the attribute. 

The on makes me think you're directly accessing a field of another class. This is generally a bad idea as it tightly couples the classes. 

pegs the CPU. Two metronomes increases my CPU usage from ~10% to 50%; four metronomes takes it up to 100%. Take a look at for a way of getting the same sort of functionality without using up all the CPU.