As you can see, there is lots of repetition, and I'm sure there's more Python-ic ways to approach this problem. Any suggestions? 

I am usually in support of using whitespace in programming. However, in this case I think you have a lot of superfluous whitespace in your program. Especially in between braces. 

Suprisingly, there isn't much on the internet for doing this well, so I figured I would make a simple program for it. 

Test run: As you can see, the accuracy is somewhat low. The runtime speeds are faster than the original Python program in the post above, but I feel could still be improved upon. 

This question was tagged connect-four, hence my shape parameters. Those could easily be changed to the variables input by the user (which you should handle in a separate function). Note that this will perform slower than the other presented solutions for smaller values. The speed improvement kicks in with larger sizes. 

I've recently wanted to make a "Loading..." display in C where the dots print one at a time in order and then reset: 

Algorithm Let's redo our processing a bit, shall we? Let's read the file line by line, parse the necessary data, and then process that data for optimal speed. You should only need two loops in this code, one to parse input and one to output data. 

Elaborating on the PSR-0 specification The spec defines mandatory requirements your autoloader must fulfill. They provide example inputs your autoloader must accept: 

Your code would be shorter and much easier to reason about if it was more functional. However, as JS is missing some functional concepts other languages take for granted (array comprehension, min/max in array by key function), this would require helper functions being a new, but onetime overhead. Are you using a third-party library like Lodash by accident? Then you already got many functional polyfills. Which methods does the you are using from SharePoint support apart from the iterative query interface with , ? If there is no built-in support, I'd suggest writing a generator function: 

Your will call , which will iterate the array's elements one-by-one and apply (i.e. call, not await!) the passed function on it. It is now useful to mentally desugar your passed function from the aync/await syntactic sugar: 

Several people and I explored this back then in a Flow-Based-Programming implementation for JS: $URL$ I'd consider the approach valid for small environments, but would prefer a different way on the global layer, e.g. 

I thought the function would be optimal for this, and I believe it makes my application pretty robust and fast. On my Mac (ommiting 196 lines of filename output each): 

You could use , and then if there is a group greater than 1 output . However, it's in a module, which you don't want . If you look at the link, it shows how the method is implemented (though I see no reason to reinvent the wheel). 

Overall, I think this is very well done. There is one major thing I find wrong with it though: Where is the documentation?!?!?! Sure, as a developer using this library I could read through your short source file and pick it apart to figure out how everything should work. But my time is better spent elsewhere, reading the documentation of other larger projects and programming my own code. That could actually even be a breaking point between using this library, and using a similar (even inferior) library that had good documentation for me to read. 

Noisy, linear-ish data is fitted to both linear and polynomial functions. Although the polynomial function is a perfect fit, the linear version generalizes the data better. I don't know Lua very well, but by looking at your code I don't see any attempts to reduce over-fitting. A common approach to this is by implementing regularization. Since it's too hard of a topic to cover in-depth here, I'll leave you to understand it if you would like. It is quite simple to use once its concepts are understood, you can see from this Torch implementation here. Another way to reduce over-fitting is by introducing dropout. At each training stage, individual nodes are "dropped out" of the net so that a reduced network is left. Only the reduced network is trained on the data in that stage. The removed nodes are then reinserted into the network with their original weights. The nodes become somewhat more insensitive to the weights of the other nodes, and they learn how to decide more on their own. Dropout also significantly improves the speed of training while improving performance (important for deep learning)! 

For a website I'm working on, I had to get all the unique entries in an array and count their occurrence. It is possible a certain entry is only found once, but it can also be found 20 times. So I designed the following bit of code: 

The array contains the the entries returned from the database. And the array contains the unique entries and how many times they occured in the array. This is my first php script (on a drupal webpage by the way) and as such I don't know that much about php. I'm pretty confident there is probably a more a efficient way to do this, using php-specific functions. Any and all tips are welcome! EDIT: I might have to clarify the structure of the arrays: has two dimensions. The first dimension is just a key for the second dimension. This one contains an array of drupal nodes for each key. uses the nodes from as a key and the value is how many times the node occured in EDIT 2: I printed the arrays, as requested by Boris Guéry: 

This seems a bit better already :) But I think it would still be better to move the text to .txt files 

You don't have any statement, yet you declare that you are returning an . Let's return at the end of our program to indicate success. 

Some of your conditions only have one statement in them. This is completely optional, but I like to remove the braces and move the statement up to the same line as the condition. 

For this next assignment, my job was to create a GUI with a button that changes text and color when clicked, and a slider that updates a label (with a ) based on its value. Right now it looks like this: 

I've created a JSON parsing library in C, and would like some feedback on it (feel free to submit a pull request on GitHub). Any and all suggestions are acceptable, but I would prefer if reviews were focused on making this more efficient. My header file: 

The output given is seen in the above. I know this can be done better. Any suggestions for improvement? 

Now is the only value I used from this output, so you could ignore the other returns by putting in their place. Second, let's split out data up based on these groups. We can use the function to accomplish this nicely. If we pass in the function handle to it, it'll even find the max within these groups. 

Exactly! guarantees that will be called and completed in-order on the array elements. In contrast, guarantees as well that will be called in-order on the array elements, but not that they complete in-order, too! 

I am writing a couple of functions accepting tables as input parameters. These tables constitute a range of options, which should either be given or inferred from default tables. Concrete use cases can be found in the unit tests below. The main question: Is the code idiomatic Lua – especially the use of metatables? Code 

Quiz: forEachParallel with timeouts Will the following code hang? If yes, where does it happen (in , in , in neither)? What does it print? 

This looks like a very good fit for JSONPath (initial specification, list of libraries). Of course, if you only have this single code part which has to do traversing/modifying in a JSONPath-like fashion, embedding an extra library is overkill. If you use a transpiler which supports ES2017, you can make use of the latest Object.values() method: 

Both classes use , which I also built using Promises. For the sake of brevity, I would like to restrain this question to the queue implementations. Usage example Excerpt from $URL$ 

I don't know any C, so I can't comment on the actual code. But it seems to me like you could move the text to txt files or xml files, instead of literally placing it in your code. You could probably walk through the txt file and print the text in a loop, rather than each line on its own. If you really want to keep the text in the code, you could move the print lines to separate functions to clean it up. As an example, let's clean this part: 

(Keep in mind that I've left out all irrelevant code. If you want to see the sources, follow the link below). It's quite a bit of code, but I'm not looking for code optimisations. I only need to know whether this is a good OOP implementation. Would I be better off having a separate CollisionDetector class, where I pass my colliders (Arrow and Monster) in? Should I implement the collision checking in the colliders themselves? Or is there perhaps something I haven't thought of? If you want to see the full project, check here. It's made in Java with the Slick2D framework. 

Interesting use case! The core functionality reminds me a bit of my own AsyncQueue implementation. I admittedly did not have too much of a look at your business logic, though. I hope the following notes are still of use for you. 

Then again, inside a thread or a process, you can employ the green threads/fibers/JS-esque multithreading approach again - if you feel the need for it, e.g. because of easy reasoning about concurrency issues. 

I fear this might not be the best approach depending on the scale your server application is aiming at: 

This is not quite right since JavaScript (i.e. ECMAScript) is not multi-threaded. Simply speaking, the VM executing the code has a queue from which it dequeues an action (e.g. "run this file") and executes it. This is done ad infinitum. It runs every dequeued element either to completion, to a (in generator functions), an (in async functions) or an (on a generator function). The only way your code can be interfered with (preempted) is using these statements. But even then no parallelism is created, the VM just switches the current queue item it is processing, e.g. to the caller of when the generator function just ed a value. I recommend you to read Concurrency model and Event Loop on MDN, which explains it in more detail and formally better than I can off the top of my head :) The effects of the execution model Endless loops cannot be avoided The following code will print and then hang in the endless loop.