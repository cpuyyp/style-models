I have no idea why the first simulation with the algorithm takes twice as long as all the others. It was like that every time I ran the program, even when I switched the order of the two tests (meaning the first algorithm still took twice as long as the others, even when the algorithm was tested first). Maybe I did something wrong, or the JVM does something mysterious here. Apparently, the larger the original array, the greater the difference between the performance of the two algorithms. Here are the results of 10 simulations with 500000 random characters: 

This means that and are initialized to even before the constructor is executed. So your statement is completely pointless, because is only assigned the default value which is already assigned to it. I see no problem with your second version (apart from the usage of a non-existent constructor, which I already hinted at in a comment). Every field is initialized in the constructor of the class in which it is declared, which, although not strictly necessary for non- fields, still makes the code easier to read because you don't have to jump around classes to understand the fields' initializations. Also, the class is antiquated. If you don't need synchronization, you'd be better off with an (and if you do, there are still better solutions as explained in the link). Besides, you are using a raw type, thereby denying the additional type-safety provided by generics. Edit Actually, there is a problem in both of your versions that I hadn't spotted earlier: Your constructors never assign a value to the instance variable . Instead, they declare a local variable with the name that hides the instance variable. To rectify this, you need to remove the type declaration from the assignment, so that this: 

Lastly, your organization is very confused. You make one class responsible for too many things. There is no need for one class to both handle finding the max value in a range and to compute the cycle lengths. But, while these issues are important, I can't see that fixing them is going to shave more than about 20% off your time. :-/ 

I think your code is more straightforward, but its size is a bit daunting. I actually like the original better. The only real 'trick' it uses is multiple assignment. And while it requires you to think through the different cases of a bit to realize it works, this isn't something I mind. In fact, with yours, if I were to verify its correctness I'd have to spend just as much time because it has so much more code. I tend to prefer code that's a bit terse, but elegantly handles all the cases to code that laboriously checks each case and handles that case with case-specific code. And this is in any programming language. 

Also you should be able to read more than one char at the time from the file. Reading line by line, or even a fixed size buffer at the time should be more efficient. Update: Nice that you tried different approaches with the functions. One thing that I would do differently, though, is to not call the function from within the functions of your program. Even if reading the scsi-info fails, it may make sence to read the cpuinfo. Instead return some value from your function to indicate if it was successful or not. In this way the caller can determine if it's worthwhile to continue, to propagate the error further or simply to terminate the program. Something like this is a common idiom in C, where the function will reuturn if successful and some negative value to indicate an error: 

As always when looking at performance, profile the app and see where the time is spent. My guess from looking at the code would be that you're not using buffered IO, try something like this: 

Here's a slightly different take on this question. Here is an example of the two different swap operations being used in a more-or-less real-world context. This code: 

Notice how the two different functions generate identical assembly output? Notice which swap is easier for a human being to understand? Don't use stupid tricks like the xor trick. They're novelties and amusing for all that, but they rarely make a difference in the real world. About the only place where there's even a tiny chance that the xor trick is a good way to swap two integers is on some embedded system with no free registers. And, your formulation of the xor trick is undefined behavior anyway. The fact that it worked is a pure accident, and while perhaps the fact that it didn't cause your computer to explode is less of an accident, that would also be a permitted result of running it. 

The thing that this is actually eventually going to become a part of is called Sparkles, and it's GPLv3, so the source code is there. 

That's essentially two identical sections of code, if you disregard the filename. Try to make a function instead that you can call twice. Something like: 

Apart from that, I would probably make return a -type instead of having all the matches inline. Don't think it matters wrt to performance, but it makes the code quite a bit cleaner, I think. 

The only thing that really sticks out to me is where you use the return value of etc without checking that it's valid in . If returns a negative value you risk that the logging library introduces weird bugs in the host application. You don't want that! Otherwise there's not much to pick on in this code. 

Doing so would reduce one level of indirection, while implementing the interface would be the same amount of work. Apart from that I think your code looks quite good. 

Also, you should pay attention to the indentation. The while loop in seems off. This makes it difficult to know if you want the -statement to execute for each iteration or only after the loop is finished. As it is now, the latter is the case. 

This is only slightly faster because some processors have a combined 'find the remainder and quotient' instruction that this leverages. It also avoids testing even numbers. If your number is not divisible by 2, it won't be divisible by any other even number other, since all even numbers can also be divided by 2. Also, make sure you have compiler optimizations turned on. 

This is overly confusing, and things are obscurely named. This is a one-off for a programming contest thingy, so it doesn't seem like it's that important. But I find that organizing my code well helps me think. You might find that's true of you. Also, you have several fixed sized tables that are very huge. Quite likely unnecessarily so as the short cycle lengths for large numbers indicate that most sequences converge rather rapidly on a common chain. Lastly, you keep a stack of values when no such stack is necessary because the problem description doesn't require you to print out what the chains are. And even if it did, a very slight tweak to the table contents would allow you to easily print out the chains by just following pointers with no stack necessary. There are other details that seem minor but are actually a big deal. For example, you create an empty vector, then assign it a very large table. This will create two copies of the very large table, and throw away the (rather minimal admittedly) work done to create the empty vector. Since this last is a very specific coding flaw, here's how it would be fixed: