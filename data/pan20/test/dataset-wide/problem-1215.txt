B1. Rather than have initialize the head pointer, the calling code does a to clear the . It makes more sense and is more understandable to have do that clearing. 

Obscure bug when . is only valid when has a value in the range or . As may have various negative values, can be undefined behavior (UB). 

Now with the above change, rather than use in many places, use a macro and string literal concatenation. Certainly easier to adjust one format than many. 

Dubious use of when or would work. Rarely does make for faster code nor smaller code. If memory space was an issue, unclear why code does not use or . As codes tends to zero fill arrays, also better to initialize the variable rather than assign it later. 

Formatting is inconsistent. Use an automatic formatter. Avoid manual formatting. When the pointed-to data is not changed, use . This allows for more compiler optimizaitons and lets users know the data is not changed. 

: Use meaningful variable names. Since the value returned is likely for an array, use . has incorrect functionality. If the file consisted of only "1234567890", the function would return 0 rather than 10. Code needs to consider that the last line might not end in . 

Other test may be needed @Wingblade Non-standard function is not standard C library nor did I find it in Linux. Questionable signature I'd expect a function that checks a string's validity to cope with a . So using on the supplied is not possible. Code needs to make a copy or otherwise assess the string. 

Code appears to be reading until end-of-line, yet that is not specified. Even if so, with ignoring leading white-space, it makes sense to also ignore trailing-white-space including the potential . Appending a to insure a string does meet the title requirement. Should anything special happen if a null character is read? Buffer size too small? What to do with extra characters? Consume them, leave them for the next I/O functions? How to handle an immediate end-of-file? Or an end-of-file after some characters? How to handle a rare input error? How to handle pathological input like , ? Array sizes exceeding ? 

Not all are unbuffered. Suggest appending to your print to insure timely display. Note either call below may make the same code with smart compilers. 2nd has the advantage of no problems with 

Other notes: Nice set-up. Except I'd avoid names as too likell to collide. Perhaps .... Why call the type , prefix functions and then call the file ? I'd expect consitency - use or change code. I'd expect a function to return the current queue usage. (enrollments in queue) Code looks tolerant of . This is good design and reflects well on the design of . I am not a big fan of embedding inside functions yet some error handling plan should be implemented and at least this code has one. 

In a similar line-of-thought, has negative results when . Document the limitations of the intended use of the code or make it so code is well defined and correct functionality for all input values. Better to check the results of before using. Use or better yet, add test code. 

Using a name that is close to standard names is tricky. C reserves name with certain prefixes, etc and so does *nix, etc. Maybe use and an optional . Corner case: Returning with does not make sense when . I'd expect . Underflow possible. The length of the may be longer or shorter than the 

Incomplete declaration. A declaration without parameters conveys no information about the parameters. Thus a call to before the definition of will not flag an error. Use . 

An alternative to saving the lengths and recomputing is to use some non-standard function like which copies and returns the pointer to the null character. As if this is faster than other approaches, YMMV. IMO, is the best to speed code along and since the length was compute prior, take advantage of that even if managing the saving of those prior results is a minor extra burden. 

Invalid print specifier . This led to "warning: unknown conversion type character 'I' in format" on my Windows based compiler. The use of may work well with some compliers as a valid extension, but that is a compiler issue and not an OS issue as suggested with "For Unix-based (non-Windows) systems, use zu instead of Iu". Yet since all are small here, code could use and and avoid the vs. issue. The fixed point types should use the macros such as found in rather than guess the specifier. @Roland Illig 

Amend --> to better convey function's interface and allow calling with a array. is the "Goldilocks" type to use for array indexing and array math without being excessively wide nor limiting. Re-order parameters. goes with yet is separated by . Many C library functions list the result pointer parameters first "output" and then the "input". 

Good that OP's code handles values <= 0, yet could have used instead. Further: this is a good place for the only even prime detect. Corner concern: The test fails for large , like as is always <= than or it is overflow - which is undefined behavior (UB). Preference: Use for return values that are either 0 or 1. Many modern compilers/processors calculate the remainder and quotient for little/no additional cost. Use that as an exit condition. 

Improve naming: In C, use as the length of the string which does not include the string's null character. Use , to denote the size of the string which does include the string's null character. 

Instead avoid OF and start from the top and work down. The will not integer "underflow", even if were or . 

Are there any meaningful names that could be assigned to the 1, 2, and 3 in the parsing blocks that would make the code more readable? 

Poor use of . In , is a null pointer constant best used with pointers. is a , not a pointer. Suggest below: 

ISR: get in, do minimal work of O(1) and get out. Better to have the main program handle all this string processing. Potential infinite loop. An ISR should never loop forever like with . This depends on functionally correct coding and hardware. Hardware sometimes 1) fails or 2) works in ways code just did not expect. Better to limit the number of iterations to some fixed value. If is the theoretical max number, use a for loop and set a reportable error if code loops too often. Below is scary. 1) could return and is UB. 2) by itself is UB, use . 3) affects global memory and never should be used in an ISR. 

It can over-fill leading to UB. If the first character is a , remains un-assigned leading to UB and still in . A rare input error is not detected leading to subsequent UB. On typical input, remains in , which could make a difference with a larger program. 

Check range of values, especially during debug. Consider debugging code where invoked a in a latter call . Another approach is preemptively adjust 

Consider auto format. The space between will likely shrink with auto formatting. Insure code is presentable even after auto formatting. 

[edit] Re-architecture idea: Presently the single linked list has 4 operations to add to the head/tail and delete form the head/tail. Two of these take O(1) time and 2 of them take O(n) time. By having the tail node point to the head instead of , 3 of these take O(1) time and 1 remains O(n) time. The other change is that rather than keeping track of the head node, code keeps track of the tail node as the head node is then . No need for a list structure with a head & tail pointer, just a tail pointer. 

Testing the "With getchar and putchar:" code would be easier if given a function declaration to see clearly what are inputs and outputs. Example: 

Alternatively code could be re-written to cope with overlapped buffers. I'll leave that as an exercise. 

Given the above as the coding goal, consider it important that on code review (what this site does), it should be easily discernible that the goals are met. I did not see that easy discernment in OP's code especially with the "except the second line" requirement. Improved example: 

and are a good first step as 1) it is functionally correct and 2) highly portable. Any "better" solution should use this as the baseline in which to compare/profile. The next performance step involves some assumptions. If the is of the expected endian, than a simple will work in lieu of . 

I found the excessive wide code unnecessarily challenging to follow. Recommend to re- auto-format to the width of the presentation of this site. 

Deeper review of indicates it has more issues. It isn't allocating memory correctly, and linearly re-sizing. Suggest simplification: Do not allocate memory in calling function. Pass address of . Pass address of . Use positive logic ( Untested code follows 

Better to get return value of input functions (4 places). Even in learner code, it saves time during debug 

needs a similar re-write to employ this new approach. It will remain . Further, it should return a value indicating (found) or (not found). could be coded calling 2 helper functions: and . is very similar to and also . re-write. 

What is ? The name maybe should be FT_ten_millionths_per_second or better documented. Per the original line of code and its comment, it appears to have the value of 10,000,000. Why? It seems arbitrary. The reason for this value needs to be made more clear. The comment says but the code uses a rounded value with . Better to do with simple math. Explaining why a scaling of 10,000 would be useful. Likely . 

The signature unnecessarily conforms to the details of . Why does code use parameter type for ? Looks like an implementation detail. By using parameters, the function is open to wider use. Else this code obliges the calling code to check for type narrowing issues. The parameter order may be consistent with a certain locale, yet matches the spirit of ISO8601 The following alternative breaks out aspects of calendar functions that will likely prove useful in other functions. Make public the range of allowable years by adding those limits to 

Using a parabola model like OP's (1 cycle = 1024 BAM). The below code is effectively the same preciseness as OP's code with only integer math: and, or, , , , negate and shift. Input range [0R 2Ï€R] mapped to [0 to 1024] Output range [-1.0 1.0] mapped to [-16,384 16,384] 

Good use of to insure output. Something often missed. Minor: is not explicitly allowed per the standard. Better to use Minor: Naked physical quantity. Values like height, weight, time, should have units made clear feet vs meter $327.6 million mistake 

Minor style implication: --> . Variable declaration A style issue, yet I find declaring variables when there are needed better as well as bracketed 

Architecture idea: Code reads the entire file into memory, coverts it and then conditionally writes it out. 

Use standard signatures may be acceptable on your platform, but not others. Better to return . Avoid non-portable code is non-standard. Use For array sizing and indexing, is the Goldilocks type, neither not too narrow nor too wide. As you develop, use that rather than for indexing. is OK for learner code. 

Data abstraction Even though references the year 1900, a function called should either use a more neutral epoch or be renamed. Since this is a function - used only locally, not a strong need for this. 

Limitation "only sorts arrays of pointers." --> Op's code handles pointers to objects. Pointers to functions may be wider than . 

Types Better to use for sizes and for user data. To be clear: design the interface (function signatures) in ways that make most sense for the user. Code the structure members as you see fit. Perhaps a size for this queue can only be 255, still use and test that for a valid range. has a nice way to return error indications. 

loops are best coded with . Complex usage of loops tend to be code golfing. Indexing from is idiomatic in C and should be followed when reasonable. Following this helps convey meaning and avoids off-by-1 errors. 

Since alignment is certainly something less than 127, any integer type will do for our purposes. Could use , , . The cast of is redundant other than to remove the My GCC 4.5.3 compiler says the on the return type is ignored. 

Use when referenced data is not changed. Allows for optimizations and defined behavior when the array address passed is . 

The various calls to like code suggest that a helper print function should be written. For printing , I find more informative than . Rather than allocate to the size of the type, allocate to the size of the de-referenced pointer. It easier to code correctly, review and maintain. Putting the part first insures any integer math is done with at least width. Checking for a allocation makes for robust code. 

Further improvements maintain prime lists (not shown) and use of the quick sieve of Sieve of Eratosthenes - practical when bits of memory are available. Many compilers when performing can calculate for little or no extra emitted code. Source code can use the quotient to stop the loop far sooner: about iterations rather than . This is better in many cases that than iterating to (using the function) as that invokes floating-point math with its rounding issues and potential less precision that the chosen integer type. 

Good use of to avoid overflow issues - even though appears faster, the latter can fail. Minor. Returning rather than is rarely faster/less code as that type is usually the processor's "preferred" type. Return or . Profile code if this optimization is in doubt. 

Lack of error checking/weak end-of-line consumption does not check the return value from . Should the user enter non-numeric data, nothing is scanned, will not be changed and offending input remains in . Alternative code; 

Why #define? Although is certainly a benign and speedy use of a macro for an otherwise function, be wary of using when a function will suffice. Concatenate literals An alternative to many 

Tidbits Consider avoiding when things work. This is a small style issue - I find a or more aligns with failure than success. 

Stress test The queue approach is non-deterministic and would benefit in knowing how much extra CPU is left. Presently the processor is ample and the cumulative task list is low. There is spare CPU power. Yet let us stress test this design to find out how close and how code handles falling behind. Add code to detect when is starving. Did every task get serviced at least once every 0.1s say? Append a do-nothing task that consumes a x% of CPU time, call it Administratium. Did the queue ever fail to add because it was full? What was the maximum queue usage? Was task latency too great? Armed with this adjustable idle task, preliminary testing can gauge the degree of margin in the design.