(This is only a partial answer to one of your side questions...) For some reason your DCs have 6to4 addresses. If you're sure you aren't using 6to4 (you probably aren't) then you should probably disable it. 

As an enterprise distribution, Red Hat locks packages in the distribution to a specific version, so that the features offered are known and consistent and do not change behavior unexpectedly during the lifetime of the installation. As you noted, this means the version of software can be "old." However, they also backport security fixes when available, applying them to the old version. For instance, a number of security fixes have been made for subversion over the life of the distribution. This allows for keeping a secure system without the risk of breakage caused by the introduction of new functionality (which does happen from time to time). You can obtain information about specific security fixes at Red Hat's site by searching for the CVE number. Or, to see the change history of the package online, try: 

"Memory demand" means the amount of memory that the running OS and applications are trying to consume. If it's greater than the amount of memory assigned, then the VM will be paging out. From TechNet: 

It appears you are also explicitly sending your to the wrong interface. I have no idea why you would expect this to work. There's no route to 2001:500:88:200::10 via re0 on your router; that address is only reachable via gif0. Unless you've got a second router somewhere that you didn't mention... 

You'll see a listing of devices. If some are marked as or then you'll have to deal with the failed disks first. After that, reassemble your RAID array: 

You need to set in the block, not in the block. This is one of the most common nginx mistakes. In the where you need to override the document root, use instead of so that the path is translated properly. 

Since memcached is running on the same server, consider configuring it (and your web app) to use a UNIX socket instead of network connections. 

Current versions of OpenSSL on CentOS 7 include secp256k1. If you are missing the curve, update OpenSSL on your system. 

Security In general, timestamps are used in various authentication protocols to help prevent replay attacks, where an attacker can reuse an authentication token he was able to steal (e.g. by sniffing the network). Kerberos authentication does exactly this, for instance. In the version of Kerberos used in Windows, the default tolerance is 5 minutes. This is also used by various one-time password protocols used for two-factor authentication such as Google Authenticator, RSA SecurID, etc. In these cases the tolerance is usually around 30-60 seconds. Without the time being in sync between client and server, it would not be possible to complete authentication. (This restriction is removed in the newest versions of MIT Kerberos, by having the requester and KDC determine the offset between their clocks during authentication, but these changes occurred after Windows Server 2012 R2 and it will be a while before you see it in a Windows version. But some implementations of 2FA will probably always need synchronized clocks.) Administration Having clocks in sync makes it easier to work with disparate systems. For instance, correlating log entries from multiple servers is much easier if all systems have the same time. In these cases you can usually work with a tolerance of 1 second, which NTP will provide, but ideally you want the times to be as closely synchronized as you can afford. PTP, which provides much tighter tolerances, can be much more expensive to implement. 

Create a new domain user and give it rights to join computers to the domain. Embed its username and password into your automation tool (puppet, chef, shell script, whatever). Once all the computers are joined to the domain, you can delete the domain-joining user. If you keep the user, you should change its password or lock the account. 

The way all the major repos solve this is to actually copy the relevant 32-bit packages into the 64-bit repository. You can see this from a careful inspection of any such repo (CentOS, Fedora, etc.). So, after you copy all the 32-bit packages to the 64-bit repo and re-run you should be able to install them. Since this can use a lot of space, I suggest hard linking them rather than copying them. 

If you're using raw image files then the only way to get a consistent snapshot is to suspend or shut down the VM. You can take a snapshot using qcow2 image files without suspending the VM, but the snapshot becomes part of that file. This may or may not be appropriate, depending on your situation. You would have more options if you were using a CentOS 7 or current Fedora hypervisor, such as snapshottable LVM volumes or ZFS zvols. On these modern systems you would the guest, take the snapshot, the guest, and then backup the snapshot. This requires the qemu-guest-agent running in the guest. 

You're doing the right thing by redirecting http to https (assuming you use 301 redirects). One additional thing that you should strongly consider doing is enabling Strict Transport Security so that browsers know that this is a web site they should connect to only via https. 

I run all my servers on UTC, and I convert any that come into my control as soon as I can. The one exception so far has been an asterisk server, which I had to leave on local time. Changing it to UTC completely broke asterisk. (It's on 1.6, hopefully this won't be an issue when I get around to upgrading it later this year.) 

The directive is valid inside , so you can simply add one there. However, its presence overrides any ones that appear above it in the hierarchy, so if you simply add one entry the request will not be logged to whatever access log you normally log for that server. To get around that, you can use two directives inside the , one which repeats the regular access log, and one for your special access log (which can also use a different if you wish). 

Yes, set the virtual machine's video driver to SPICE and then install the SPICE guest tools in the Windows guest. 

You're not meant to interpret anything beyond the numeric response code in your computer program; the textual representation is meant for human consumption. See RFC 2616 section 6.1.1: 

When you give a boot command line option to start networking to load a kickstart file over the network, the corresponding line in the kickstart needs the option added. From the documentation: 

Look at the file. This contains information on all the mount points that the system mounts automatically. One line will almost certainly refer to and this is the one you will look for. It will probably look something like this: