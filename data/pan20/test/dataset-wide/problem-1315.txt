What you should be doing when receiving your input, and as early as possible, is validating the input, i.e. making sure the input matched what you expect in format, and in business logic. Format means "This is a valid email address", and business logic means "This comment that the user is trying to edit, really belongs to him". 

Well, you normally don't want to use the constructor in your higher level code, you want to Promisify as low as possible. So let's create a function that checks for a single image, and resolves whenever you know the status of that image: 

This code is 100% XSS proof. And it doesn't matter what has in it. Note that with this method you do not escape for HTML before you insert to the database. Always escape as late as possible. A note: This is about escaping HTML. It will not help you escape things like JavaScript or URLs. The following will not be escaped properly: 

As I understand your code, you are looking to find substrings that could be arranged to form palindromes. You are looping over various lengths of substrings in your function. Your function, however, spends a great deal of time and effort to formulate the palindrome. This is wasted, because all you really need to know for your scenario is whether each distinct digit appears an even number of times. If each digit in the substring appears an even number of times, like , then you know you can arrange that substring into a palindrome. If there is a digit that has an odd number of occurrences, then there will be two (since the substrings are even-length, per your problem statement). Which means you have something like and that cannot be made into a palindrome. This means you can scan your input string using a "sliding window" and simply update a dictionary of counts as characters are added and removed from the window. What's more, you can stop when you find the first arrangeable substring, and return true. If you start your search from either or (if number is odd), then the first result will be the longest result: 

Figure out the unique entries (aside from name_alt) Iterate over each "group" of unique entries, and each to a single object push each newly created object into a new array. 

Yes, there are several things I can see with your implementation, from most critical to less critical: 

MVC is a concept that stems from good OOP practices. It's about seperating your application to three different parts: InputControllers, ProcessingModel and OutputView. What you are describing is the bootstrap page, which, at least from my perspective should not be a class. Here's my approach to this: index.php 

Router - Which is the component which takes a URI (or if you're really fancy, a object), and spits out an object that represents the matched route. Route - is an object that represents a single route. It contains information about the URI pattern, the controller and action, and the variables that need to be passed into them. 

For each and every pixel, assign a binary representation of all the digital lines that pass through that pixel within some NxN grid of pixels. (You may be able to use your full 10x10 grid; breaking down a grid into subgrids introduces some complexity.) In your case, rather than representing a line as simply the edge-to-edge representation using the numbering scheme described in the paper, keep track of both the edge-to-edge line segment as well as the valid end points within your white/black (open/closed, available/blocked) grid. For each pixel, maintain a container (e.g. map, hash, list, array) of allowed moves. On keyboard input, check for validity of the allowed move. (UI nicety) If a move would be disallowed because the character would bump into a wall, allow the character to move just a little bit but then snap back to the original position, and briefly show the bumped wall lightening in color. This helps indicate that a move was attempted but disallowed. 

And squeeze out another lookup. But wait, there's more! Because before you start doing that "peephole" optimization stuff, you need to look at improving your code in some other ways. Take a look at this: 

Okay, now I can see what you're checking. Also, of course, if you insist on repeating this a bunch of times, it will be more resistant against typographical errors. (If you mistype instead of the compiler will not complain. But if you mistype instead of gcc will pitch a fit.) This is an under-appreciated benefit of abstraction for low-level programming: it's harder for a single typo to compile correctly and cause hours of wasted time debugging. Style Now, a couple of words on style. I looked at your full source file, and it's a nightmare. Please keep in mind that when you're asking strangers on the internet (like me) to review your code, you're asking for our time. Also our expertise, but primarily it's time. And you're competing against pictures of cats. And gifs of Kate Upton running on the beach in a bikini. So you really, really, really need to make sure you don't waste whatever time you get from complete strangers -- who could otherwise be watching a weather forecast from Mexico (GIYF) -- by having a bad coding style! Please, use a consistent indentation. That means the same amount. Not "2 characters sometimes, and 8 characters other times." Ideally, since I've got a laptop with very high resolution, you'll pick more than 1 or 2 characters of indentation. I rely on indent and outdent to find things like the end of your outer loops and outer if blocks. Of course, I was unable to do that with your code since some of your blocks are at indent level 0, and others seem to change indentation levels at random. Next, pick a consistent spacing rule. Look at the "example" code you gave us: 

PHP already has a function for escaping HTML characters. . In order to completely and absolutely prevent XSS, all you need to do is pass anything that's about to be ed on a page through that function. So for example: 

Business rule validation belongs in the Domain Object itself. (i.e. the object directly). While your data-integrity checks should be done by the RDBM. More often than not, the RDBM (which is usually MySQL when talking about PHP) is not capable of doing all of that (which is why moving away to a better RDBM is encouraged), in which case those things also need to happen at the Domain Object level. TL;DR It's the job of the domain object to validate itself. It's the job of the storage manager (the database) to make sure the data is correct from the constraints point of view. The validator class ends up (usually) as a utility class, which is nice to have, but unneeded for an actual project. 

This returns the native array syntax to C, and lets you skip having to code any functions. Finally, I'd suggest changing your function to a function. To me, suggests , which is memory footprint. As we all know, the "length" of an array is . You have two numbers to track: used elements and capacity. In fact, you might want to convert to simply tracking capacity, and let the user deal with managing the used elements. Regardless, neither of those should be called simply because of the likely confusion with . 

(Also worth noting: removing spaces from your code doesn't actually make it go faster. But it does make it harder to read.) And given that you always use the same digits in the same places, there's really no point in doing the multiplication over and over again. You should just pre-multiply: 

First, there is no empty string for zero. So I assume you mean "None will be replaced with an empty string". So why not store it in there now? Next, there is no function, so I assume you mean , which I have to find by manually searching. Except there is no special case there, save for the which does address the special case but doesn't handle the whole "why is ONES[0] not equal to ''" question in my mind. Of course, there is some handling for that, but it's in the function, and it's not a replacement, but rather it's handled in code flow using an statement. So 2 lines in to your program, and your comments are lies. This is why comments are generally frowned upon. You can't count on them to be true, or stay true - they don't get unit tested, and they don't get compiled. I would suggest that you simply store into ONES[0] and delete the comment below it. Another example: Consider this: 

Note that this way the User has no knowledge of where the data in it came from, could have been files, could have been a session or even a REST api. 

Some context I've been tasked with supplying an escaping function to arbitrary CSS values that are entered through a form. The goals and caveats are: 

Business rule validation - "User chose this city and this country, does it make sense?" or "User said he was born in 2012, does it make sense?" Data-integrity validation - "User already exists in the database" or "Username should contain between 3-20 characters". 

The current function looks overly bloated and inefficient (with \$O(n\times m)\$ at best, and \$O(n\times m^2)\$ at worst). While this is going to be used for test code only, and to small objects only (no more than 10 keys), I would still want to find a way to make it prettier and more efficient. Would appreciate any and all help. 

Start with the technique as described above for a 10x10 grid, then introduce some logic to precompute edge cases. Create a finer line-of-sight grid. Your character may move in a 10x10 grid, but the light-of-sight grid could be something like 100x100. The Discrete Hough Transform technique describe above works for (arbitrarily) large grids, but that requires steps to break the main grid into smaller grids and then combine results. 

Since your scene is static, at least until another scene is generated, you can perform all of your raycasting at the time of scene generation. You shouldn't have to recalculate rays every cycle. Though you'll have to adapt it to your purposes, there is a method for precomputing line fits that you can read about in the paper "A Fast Rule-Based Parameter Free Discrete Hough Transform" by Genswein & Yang (1999): $URL$ Briefly put, your code would calculate all possible lines of sight before the maze or game appears on screen for the first time. You could almost certainly simplify the line-fitting technique mentioned in the paper above, but the general technique is worth knowing as a means for precomputing fits in a 2D digital image. 

In the above example the nonBusinessDays of the week are SATURDAY and FRIDAY, and 1st and 2nd of June are holidays. In that case, 3 business days from now is June 5th. This can probably be improved further, let your imagination run wild :P 

You can have more methods like "fetch the N top user with most comments", or "Fetch all the friends of this $user" The point is, the is responsible for getting/saving all necessary data from the database or whatever other permanent storage you might need, and fill the actual Domain Object, which is then used by the application to do processing. 

How to improve This code, contrary to popular belief, is not MVC. MVC stems from good OOP practices, and the separation of concerns. The idea is to separate your application into three major layers: 

Note that in the above, the User is unaware of the database, which means it's perfectly reusable across applications with different storage systems.