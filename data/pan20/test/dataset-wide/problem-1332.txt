of course you need to implement the operators , and cast to first. This can also be easily improved by chunking to the maximal power of 10 holdable in an unsigned int or unsigned long. However this naive algortithm still has quadratic time complexity in the length of the number. I am not sure whether there is a linear time algorithm. Another quadratic, but possibly faster algorithm is Double dabble. In the GMP documentation there is a short explanation of a subquadratic algorithm. Maybe this can give you some directions. You may want to look at its source anyway as a reference of a mature BigInteger implementation. I am also quite confused by your function names. What is supposed to mean? I doubt the end of the function name is the correct place for whatever it is. Is it representing the container element types? If so that should belong into a template parameter. 

If is a non-accessible data member (e.g. private) your code fails to compile with gcc. However this seems to be gcc bug. (stackoverflow question) Still if your code is supposed to be compilable with gcc you should consider this. The templates give for non-accessible (e.g. private) members. That is usually good though, because someone using quering about a class should only see the public interfacce anyway. Still consider what the intended behavior of your templates should be. If is of reference type, then your will give , because taking an address to member of reference type is not allowed. is also if is a static data member with deleted or non-accessible , although this is a pathological case because I don't see a good reason to use in that way. You might want to take instead to avoid such a case. will also not detect member function templates, because the address of a function template cannot be taken. However that is probably expected behavior. The same issue also arises for overloaded member functions, though. The adress of overloaded function can also not be taken. This is probably not intended behavior. 

You should probably use more descriptive identifiers for and here. Instead of dynamic allocation you could also use for and . That would allow to simplify your code considerably. For example you could drop the custom copy/move constructors/assignment operators and the destructor and use the implicitly defined ones instead. You could also use the provided method of to get instead of saving it explicitly. If you didn't use for performance considerations, then I doubt that is a problem. Element access is through one indirection anyway and you do not have resize operations. Simply use in your constructor to allocate the proper size immediately. Only the required memory for might be a bit larger (additional integer for current size/reserved size and doubling of length ). Even if you still don't want to use , then you should consider writting an additional class (?) to handle the memory management or you could use , which would at least make your custom move constructor/assignment operator and the destructor redundant. In : The body is simply zero-initialization of the array. The same can be achieved with: 

You are trying to do arithmetic with strings, that is bound to be expensive. Here is a naive algorithm to output a BigInteger in decimal: 

If you could specify exactly what your templates are supposed to detect / not detect that would be helpful. 

In : Is there a reason to set and to zero? A moved object only needs to be properly destructable, but the destructor does not use or . You can refer to the current instantiation of a template class without specifying the arguments, i.e. would be fine for the move constructor, too. To use you need to include . : You have a rvalue reference constructor here, but none for const references. That seems inconsistent. initially does the same as , you could simply call it: 

Note that you would not need a destructor if you were using or . If you stick to dynamic memory allocation, you probably also need to implement a custom copy and/or move constructor and assignment operator. The whole idea of a class is that it represents a certain closed/separate entity. Your class does not follow this, it is merely a wrapper to call the multilication method. If you were following OOP principles, you would create a class holding one of the matrices with an overloaded , and so on, then create two instances in and call on them. Like so: 

(dropped) (dropped) You could use just one array of type (or a custom struct) instead of two arrays and . Then you would not have to repeat the memory management code twice, and with the access pattern related data is closer in memory. Together with my point 2. this would reduce overhead even more. Your only method to return elements returns a , implying that it is impossible to modify the value of an entry in-place. I think that is a rather strong limitation. Of course one may not change the key in-place, but the value should be modifiable. Therefore the type should be and also should be of type . The maximal size of your is kind of arbitarily chosen and once it is full there will be an exception thrown. This might not have been the scope of your intentions but really the size should grow when a certain load is reached and rehashing should happen. Your takes a rvalue reference. This means that only temporaries or d elements can be inserted. There should also be an overload for const references (and without ). should be . 

I will be assuming that you use at least C++11. It also seems that you are coming from C, is that correct? 

That is fine, because all template arguments to are known at the time of parsing and is instantiated immediately, before the call to is parsed. At that point the compiler already knows that in that specific instantiation of is member function template rather than a non-template member and everything is ok. This however 

generates a compiler error, because when is parsed, the actual type of is not known and instantiation of needs to be delayed until instantiation of . This means that when is parsed, the compiler does not yet know what kind of language construct is in the instatiation of and in fact it may very well vary for different . Therefore it is assumed that is a non-template member, which doesn't make sense considering the following template argument list. Your code sadly does not solve this problem and I don't think it is solvable. Additionally I noticed that your is an empty class if an empty type list is given. That is a bit inconsistent. I think at least should be provided as empty function. Calling it should not be allowed, but referring to the member function should be fine.