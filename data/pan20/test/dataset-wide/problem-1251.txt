That's shorter and more readable. However in this case, it would actually make more sense for it to be a private field. 

is redundant. Using the operator (which is an XOR, exclusive or) already assumes that the boolean variables are mutually exclusive, which they are in your program, and also in the real world, because you can't logically fail a level and succeed ("finish" aka "complete") at the same time. If is false but is true, the first condition will be true, causing the second condition to be evaluated again, even though it is already known to be false. Just leave out the outer condition; the whole check is not needed. Just check and replace the with . You are increasing the level if the level is completed, but you are not resetting it if the level is failed. That might be by design, but I usually expect a game to start from the beginning if it is lost. I think calling here should not be needed, since I guess that calls it every frame anyway, and it is better not to mix input code or logic with rendering code. So my improved version looks like this, putting some of the code in an extra function: 

The code itself looks good, but I would look into providing a single way of subscribing to events, it will make the job easier for other developers reading and changing the code. The first method of subscribing (via injection) requires subscriber object to be created first, so it may not receive all events that you may expect it to receive. Every time you create an instance of subscriber it adds a new event subscription thus causing potential memory leaks and side effects. You might need to add method to if you prefer to leave it. Second method (the one I would prefer) is better suited for application-wide events since it moves the responsibility of subscription to the infrastructure thus avoiding multiple subscriptions and memory leaks (comparing to first option). It is also easier to unit-test since part of responsibilities are taken away from subscriber. Update based on question update: Publishing messages also looks good. In this case (following my suggestion to leave only second method of event subscription) I would remove method from declaration, and refactor it to non-generic interface with generic method . 

Your logic has a serious flaw: you expect that the consumer of the collection will iterate it till the end. In reality there are or keywords, and exceptions that will not follow your expected workflow, and thus you will be stuck with positive . Note that even moving to method won't help, as you cannot enforce the user of your collection to call it in case they iterate manually, without . I think the whole idea of working around this limitation (which was placed intentionally by the .NET team) is not very good. It would be good if you provide examples where you think you will benefit from a collection like this in separate code review posts, and community may suggest a better approach. 

Naming is a bit generic for a class name. It could basically mean anything, because almost every algorithm has some kind of solution. A better fitting name would be . It tells the reader (you, but also others) what it means. has two problems. Firstly, it doesn't sound like a method name, because methods are usually verbs. Secondly, the convention for methods and functions in Python is , also called snake case. My suggestion is to name it , or even just considering you rename the class to . has the same two problems as the previous one, but additionally it does not really tell you what it does. If it is a helper, maybe it should be a class, but it does not do enough for that. If it is a method or function, what does it help you with, i. e. what does it do? A better name might be , and you could consider making it an inner method of the other method, since it will not be used outside of it. That way the user of the class does not need to think about which one of the two methods to use. OOP You might consider making all that code (after the suggested changes above, only one short method) part of the tree class. After all, it depends on the tree anyways. Of course this does not apply if you did not write the Tree class yourself, or if you want to make a more generic traversal class for different types of trees. In you do not need to specify a parameter for . Since it is a member variable, you can just access it via . 

Note that you're using a separate thread (on a threadpool) each time you write something to log, so there will be contention between multiple threads if you write to log quickly enough. I would recommend using existing logging frameworks like NLog or log4net to avoid inventing a wheel. 

It depends on the meaning of this constant. If the value has logical relation to (e.g. it means that it should go right before in some list) then just use there, but if it's just - then either define a new constant or just use as value, depending on situation. What I would suggest is to rename to more meaningful (descriptive) name unless it's a well-known acronym in your company. 

Your example does show IoC tecnhique by passing interface to rather than actual implementation, but doesn't show the power of DI containers like auto-wiring and object lifetime management. In your example IoC container looks like just a replacement of a local variable that holds the instance . Example of DI autowiring using Autofac (use in NuGet console to install it). I borrowed 's definition of Oracle, it is more appropriate and demonstrates the IoC better than original code. I register before registering classes it depends on to show that the order is not significant here. Note that is initialized through constructor while is injected via property (just for demonstration, it would be better to use common approach): 

A bank account does not have a name. Instead the customer has a name, to which the account belongs. A customer might have multiple bank accounts. 

is a possible security hole. Instead of making it constant and thus readable in your source code as well as your memory, have the user type the password in. Then use a instead of a string, and everywhere in your code where you need to use the password, overwrite the contents of the with characters afterwards; you can't overwrite a string, and just setting the reference to still requires to wait for the garbage collector to actually delete it. 

I already added the link to a good implementation of the hash code method above, so I won't go into detail about the algorithm. But what you are doing in the above two lines before the addition is just calculating what could simply be a constant. The compiler will probably even precompute the part. Multiplying the hash code with a prime number (like 23 or 31) should happen before every addition of another value. 

Having the type in the variable name is not needed, and rather bad practice. You might want to change the type later, for example to a tuple. Using a plural name (like or ) already tells you (and possibly other developers) that the variable contains a collection, probably a sequence of answers (and a list is a kind of sequence). 

Alternative way (how most applications works) is to rely on a business logic inside client application to enforce business rules. It's much easier (and straightforward) to verify that your parent is of a valid type. Also, based on your table I think each type of "posts" should be different enough to store it in its own table. In that case the whole story of validating types is gone, and all the validation will be done by foreign keys. 

Nice task for brains :). First of all you should prepare your available list of words for faster search: extract all letters, sort them and order by descending length (so that you don't need to sort results later. Make sure to cache it somewhere as that would be the most time-consuming operation. I've written almost all, leaving you the method to compare 2 sorted character arrays :). 

There are a number of naming issues here so it's quite hard to understand the code, I'll start from those: 

The best way to answer this question is to measure the performance and see if it satisfies you. If not - then start thinking about caching results and refreshing them instead of calculating from scratch. 

This makes the code more readible and consistent. Also around operators there should be spaces, like instead of . Switch-Case Using the switch-syntax you can make your code more readible where you are using many if-else blocks with integer comparison conditions. So this 

Don't write the type into the variable name. The type should be able to change without the variable having to be renamed. already tells you that it is a collection of subfolders. might be better, to make clear that it contains the folders' names, not wrapper objects for the file system. Removing the backslash from the beginning can prevent you from having to read up the code to make sure where the backslash is, at the beginning or the end. or implies just the name. So add the backslash wherever you concatenate the strings. 

Coding style Every language has its conventions, which enable programmers to understand each other's code more easily. Usually the conventions include naming schemes for variables, classes, methods etc. and formatting rules. These are independent from the architecture, and also from the syntax. Names or formats that are allowed by the language might not be "allowed" by the convention. 

Operator overloads cannot be reused, you would have to reimplement them anyway. Both structures have references to each other which is not great. appears to add a very little value on top of . 

There are a number of articles describing why a is quite a bad idea when defined on top of ORM framework. Main reasons are leaked abstractions and abstraction on top of abstraction. And your example shows why - any optimization requires the knowledge of underlying implementation (Entity Framework). Running this process in multiple threads may help, but will put additional load on the database server and thus is not scalable. Note that Entity Framework's is not thread-safe, so you cannot share the in multiple threads unless you spin up a new per request there (which I wouldn't recommend doing). Assuming that you're using Entity Framework 6.0, method returns , you can try asynchronous implementation of the data retrieval: 

Note that in this implementation the only way to stop listening the port is to get an exception on . You might want to introduce the to have a control when to stop this process. With this approach registering and listening for all ports will be as simple as: 

These variables are mutually exclusive. If the lock is locked, then it is not unlocked. That means that you only need one of those variables to get the same information. It is usually better to use the positive case for boolean values, which means that you should keep that variable , and remove the variable which is the negative case. In Java by convention all uppercase variable names are reserved for constants, while actual variables are named in , so instead of . Furthermore, since Processing hides some of the object oriented details of Java, you do not need these variables to be static. Just remove the static keyword and it will work the same, because you are only accessing them from within the same class (which is abstracted and hidden by the Processing environment). Hint: Reading later parts of the code, it seems like you tried to use theese variables as constants. Note that does not make it constant, and you would need instead. But: Don't do that. Having save a value (which can be changed) and meaning locked, while means unlocked, is way more intuitive than using a value of to represent and vice versa. 

What you are actually doing is updating the with objects from based on matching . The optimal solution would have an O(N+M) comparisons (N and M - number of elements in both lists, while your solution performs O(N*M) comparisons. In order to make your code simpler I suggest to use the lookup table like this: 

And the usage will look like this (note that now all exceptions from third-party library will be passed through as if the code ran on the same thread) 

The code overally looks good except that Ayende suggests (and I completely agree with him) not to wrap RavenDB sessions into repositories. I would just create an extension method to add these filters to 

Since you're using Task-based async processing it's better to declare long-running method as returning or object: 

I'll use the first option in my example as it requires less changes to my previous code: Business logic: 

You have put too many responsibilities in a single interface and class. Your interface knows not only about graph itself, but also about all the possible methods of traversing this graph. It breaks Single-responsibility principle, Open/closed principle (as you'll have to edit if you want to add more search methods) and Interface segregation principle. What you should do is refactor your interface and implementation so that: