Not all types have a reasonable default value. In the case where is a primitive type (such as ), calling the default constructor of doesn't initialize and any attempt to read before writing is considered undefined behavior. Prefer in-class initialization and member initialization over assignments in the constructor body. Some types cannot be assigned to. Some types cannot be default-initialized. When using assignment in the constructor body, members are first initialized and the assignment takes place. For some types, this can be very expensive. 

Declare variables as you need them. Every file should be self-sufficient. Make sure you the headers for components you are using. Do not rely on implicit inclusion. Check that successfully read a value from the stream. Rather than jumping through the hoop of conversion, just read the value as an integer. 

Now if you decide that you want to use a different pivoting or partitioning strategy, you are affording yourself the opportunity to reuse code. 

Are you sure you want to exit if a word doesn't appear in the corpus? This doesn't seem like a case where termination is necessary. 

There are well defined rules to implicit conversions. returns an unsigned integral type that represents the total count of elements in the container. Dividing an unsigned integral by (a signed integral), the implicit conversion rules for mixed expressions promotes the signed to be unsigned. Division between two unsigned integrals results in an unsigned integral and any remaining fractional part is truncated. So \$3/2 = 1\$ and the remaining \$.5\$ is truncated and discarded. 

The problem with returning from is what do you return? Returning by value is inefficient for expensive types. Your other option is to return by reference, but is a destructive operation that would result in returning a dangling pointer. A third option is to separate the concerns. Make a non-value returning function that simply removes the top element. already provides access to the element. 

You could return an from . C++11 versions exist in Boost, Abseil, and Mnmlstc. Or you could do it the standard way and not return anything. This was adopted from SGI and annotated in their documentation: 

Keep functions short and simple. They become easier to understand, test, and reuse. Ideally, your would refactor the median calculation and partitioning into their own functions. Example: 

The problem asks you to print words beginning with consonants or vowels. You've assumed that words can only begin with only those two, but what about words that begin with a digit? A symbol? 

Each file should be self-sufficient by including the specific header a symbol relies on. You forgot to remove the and artifacts. You are missing: 

When programming with generics, it's important that you realize what possible value types you are allowing to be passed as arguments. In this case, can be any data type. could be cheap to pass (primitives like ). could be expensive (). We don't know what might be passed, so we have to assume the worse happens. When passing data whose copying cost is or might be expensive, prefer to pass arguments by reference. As earlier, if the data stored is immutable, specify . 

Depending on the length of and the value of , this could result in more than 1 allocation. Consider reserving first. Careful with your spacing ( vs ). Since you are just looping until is , your conditional could simply be . 

If you want to make your code better, make the code readable, understandable, and reviewable. If you can accomplish those, then the code will naturally be maintainable. As for this problem, consider a third option where you write a specialized iterator adaptor called . It's job is simple, read objects of type until the next char is '\n'. 

Internally, would be better to represent the ownership semantics. is the only owner of . is the only owner of the previous . And so on. Smart pointers are great for conveying ownership, but their behavior with the special members in the rule of five isn't helpful. implementations still need a user-defined destructor (stack overflow from recursive destruction) and copy ops (not copyable). is similar, but performs a shallow copy like the raw pointer. I recommend Herb Sutter's talk on "Leak-Freedom in C++... By Default". 

is guaranteed to represent the size in bytes of any object. This is very useful for representing indices of unknown limits. 

On destruction, smart pointers are great because they clean themselves up. Unfortunately, recursive destructions are not optimized. If you had a deep linear hierarchy of smart pointers, there is going to come a point where you overflow the stack due to too many destruction calls. If you used a smart pointer for a stack, you still need to implement a destructor which requires the rule of five. The rule of five says that if you provide any of the copy assignment/constructor, move assignment/constructor, or destructor special member functions, you must provide the others. 

I actually dispute that if there are no g's in a string, then happiness cannot exist and this function should return false. Unfortunately, the test case for an empty string is true... so I guess we have to work with it. 

Use to be explicit to readers that your intent is to use the default semantics. By defining a user-written default constructor (), becomes a non-aggregate and is therefore non-trivial. The user-written default constructor also has an empty exception specification, whereas the compiler-generated default constructor would have an implicitly generated exception specification. 

Constructors should create a fully initialized objects. The compiler-generated default constructor does not initialize the built-in types. Depending on the context in which is used, the values for your members could be or could be uninitialized. In the uninitialized case, it is undefined behavior as to what the value references to when read. The simplest solution is to use in-class default member initialization. 

Prefer to use token names that have some degree of uniqueness to them. Simply reusing the filename for the header guard may result in a high chance of collisions among preprocessor tokens. You can use: 

Carefully name your functions with a meaningful name. doesn't really tell anyone what to expect as a result. Prefer to distinguish language constructs with spaces. You can use the contextual boolean conversion operator to check the if the stream has failed rather than explicitly calling . Prefer to avoid . Be aware of what the manipulator actually does. Stream as it explicitly states your intent, correctly outputs the end-of-line character, and is shorter to type. 

Using beyond the size of our string returns a value initialized . The rules of value initialization from the standard: 

The item list needed to be a linear array type. You are to take a capacity, meaning you can reserve space ahead of time. What should happen if \$n+1\$ elements are entered into the list? Should it continue to add elements, expanding its capacity? Should the capacity be fixed and the user informed there is no space? 

C++ has special rules regarding evaluation order. In this case, the of the argument list is not a sequence point because the argument list itself is not an expression. Since the arguments are indeterminately sequenced, modifying the variable and trying to access the variable is undefined behavior. 

Either explicitly provide the missing destructor (Rule of Five) or don't explicitly define any of them (Rule of Zero). 

The result is undefined behavior since we are returning an uninitialized value that was never assigned to. Remember to check that the reading of a value was successful. Notify the callee whenever that an error, like invalid argument or out of range, has occurred. There are different error handling strategies today. The common ones are exceptions, , and Alexandrescu's (currently being proposed for standardization). 

Make sure to all libraries used by the code. It's a turn-off for readers/reviewers to have to actually modify your code to make it run. 

Consider the use of an empty typelist. What is the result of ? Try to use the standard library as much as possible. and can go pretty far. Here's a c++14 compliant version of c++17 Logical Operator Type Traits. 

You can minimize (re)allocations by reserving space before appending to your container. We know how large the data set is going to be because it's provided by the subtasks as the first value read. Use the information provided. 

If your default constructed is supposed to be equal to zero, you should initialize the denominator to 1. If you are going to initialize your members to constants, prefer the in-class initializers. 

is fine since you are not templating but want to support varying dimensions. I'd only use if I were using templates. As for the , I'm a believer that if you are need a specific sized value, you should use the appropriate type from to maintain portability. 

Pivot selection is important for ensuring performance that avoids the worst case of \$O(n^2)\$. Selecting the leftmost (as you did) or rightmost for a pivot makes quicksort vulnerable to sequences that are either ordered or reverse-ordered. 

Not everyone may want these unconventional operators by default. Don't pollute the global namespace. Group these operators into a named namespace and let users opt-in when they want to use them. The inplace operations do too much work. Consider implementing the copy-dependent operations in terms of in-place operations. Consider providing named functions for those that don't want to use overloaded operators. Have the overloaded operators call these named functions. Consider using a string view for read-only arguments to eliminate allocations from implicit conversions. You reuse the same variable names (i.e. , ). Use names to reflect how it's being used. For , you could use , , , etc. For , the arguments are better described as . For code not implemented, you should make them uncallable (remove/comment) or statically assert that it's not been implemented. 

While is constant complexity for random access iterators, it is calculated in linear time for bidirectional iterators. Rather than checking the full range, check the non-existence of the first value. 

If you wish for you algorithm to make a copy and you are not using the original string, pass by value. Your function also is not a plain reverse, so give it an appropriate name. Prefer C++-style declarations () References/pointers relate more to the type than the expressions/grammar. Ensure all dependencies are included 

The prototype/interface header for this implementation (ie, the .h/.hh file that corresponds to this .cpp/.cc file). Other headers from the same project, as needed. Headers from other non-standard, non-system libraries (eg, Folly, Qt, etc). Headers from other "almost-standard" libraries (eg, Boost) Standard C++ headers (eg, algorithm, iostream, etc) Standard C headers (eg, windows.h, dirent.h, etc) 

Compile with warnings enabled (). If your goal is to write code intended for other platforms, enable pedantic warnings as well (). 

Focus on using as building blocks for larger functions. In the case of insertion sort with bidirectional iterators, you could separate the logic of finding the insertion point from the shifting. 

If you plan on writing portable code, prefer guards over . While most compilers provide support for , there is no guarantee every implementation behaves the same. Be aware of the pitfalls of if you decide to use them. 

Prefer in-class initializers to member initializers in constructors for constant initializers. By defining constants in-class, you make it explicit that members will always default to a value unless assigned to. For in-parameters, pass cheaply-copied types by value and others by reference to . When copying is cheap (doubles), nothing beats the simplicity and safety of passing by value. When you don't know the size or are not using an optimization technique (like copying inputs), prefer to pass by reference to . 

Be consistent with your and reference () usage. Did you intend to copy by value or did you intend to reference? Should the argument be ? Avoid loops without braces. Braces help make it clear to the reader that there is a block of code present. Braces also help clearly define the boundaries of a sub-block. Prefer using a separate line for single-line blocks to simplify setting breakpoints in debuggers. 

Pass cheaply-copied types by value. Nothing really beats the simplicity and safety of copying in this instance. It's also faster as it doesn't require the extra indirection on access. Treat data like data. Treat class objects like class objects. Sometimes you need to simply store records in an aggregate. In this case, avoid trivial getters and setters. Sometimes you need class objects to reflect behavior and/or maintain invariants. 

I was looking at a few profiles this afternoon and noticed a few users had plenty of open questions. This led me to wonder which users actually had the highest amount of questions with unaccepted answers (both in size and percent). So with all the hoopla I kept seeing in the 2nd monitor about SEDE queries, I decided to try my hand at writing one. 

Avoid calling and explicitly. In your code, you'll notice a pattern of creating a new followed by copying some (which could throw). 

Split your library code from your test code. Instead of letting a user pump in data, grab a testing framework and write actual tests. See Catch2, GoogleTest, or Boost.Test. Here is a Catch2 example: 

Does it meet your needs? At the very least, I would expect C++11 and beyond containers to support move operations (move construct, move assign, data emplacement, swap by move), comparisons, and perhaps even allocators. I would start by looking at . 

Prefer to give macros unique names. Macros do not obey scope rules and if a common name collides with a symbol of the same name, problems will occur. You can add uniqueness to the name by employing a naming convention. Let's say the file could be found in \mylib\container\stack.hpp. I could use a common directory structure header layout with a randomly generated universal unique identifier: 

If you define or suppress any of the special member functions, define or suppress them all. This is known as the rule of five. 

By only partitioning the elements that match your comparator, your partitioning algorithm is likely to exhibit worse-case performance as more elements are repeated in a sequence. Know your 's. See . 

Use symbolic constants instead of magic constants (, , ). If you are taking a modulus of 7, will never be greater than 7. The branch is never taken.