This is by no means the only way or necessarily the best way. You should consider streams and GoldenGate as well, but if at least one application is designed to use packages and access the data only through those packages, consider the following: 

Speed - Your own checks will never be as fast as database internal checks. Completeness- There is always the possibility when you roll your own that you will miss something. 

It would seem that Oracle at one time had plans to give a different definition to VARCHAR than to VARCHAR2. It has told customers this and recommends against using VARCHAR. Whatever their plans were, as of 11.2.0.2 VARCHAR is identical to VARCHAR2. Here is what the SQL Language Reference 11g Release 2 says: 

The concept you are looking for on the Oracle side is a Database Link. See this introductory information in the Concepts Guide. Then follow the link at the end of the section to the Administrators Guide where you can learn more about it. You will also want to look at the Database Gateway documentation for the OS you are on, specifically the section on Configuring Oracle Database Gateway for ODBC which will explain steps need to prepare the system for non-Oracle Database Links. To answer your concerns... 

It may seem that an application called ASH Viewer wouldn't work with Standard Edition because it does not have the Diagnostic pack and therefore does not have v$Active_Session_History, but it does. When a new connection is created it asks whether the target is Standard Edition or Enterprise Edition. If Standard Edition is selected it does not use v$Active_Session_History. This can be demonstrated by querying the view with control_management_pack_access set to NONE, which among other things causes the view to return no records. Pros: 

In the Two Day DBA Guide see see the section called "Performing a Whole Database Backup". It explains how to use Database Control to do a full backup. If you have 11g see this version. Assuming Database Control is working this would probably be the easiest for someone who knows nothing about Oracle. On the other hand, the database may already have regular backups done on it in which case you can just send one of those. If it doesn't or the information about them hasn't been retained, then it would seem that the data would not be important enough to convert. 

Probably the biggest factor effecting the upgrade is the unknown factor. Even when the upgrade is practiced in advance on similar hardware with similar data sets, etc. things can still occur that were unanticipated and can drastically effect the duration. With that in mind you should mimic the production environment as closely as you can for the test upgrades. That is, as close as your budget will allow. If space is the issue preventing you from testing the upgrade, consider restoring the database to a test box excluding some of the larger user tablespaces. This won't give you an exact feel for the time, but it should give you a closer ballpark and allow you to work through more of the unknowns. 

I switched from developer to DBA when I was 29. For me the things that make being a DBA difficult also make it rewarding. I enjoy absorbing and using a wide spectrum of knowledge, and the greater opportunity for failure makes the avoidance thereof all the more meaningful whether others see that or not. 

Only you will know which answer gives the results you are expecting, but they are all correct answers to the question as given. Your question is better than many because it is self contained and includes the source data, but it will help if you include the output you are looking for as well. I recommend you add that to the question and make sure the accepted answer matches those results. 

When you say Oracle 10g Lite I assume you mean Express Edition. I recommend you read through the documentation, particularly the section on Connecting to the Database. If you have a more specific question after reading that, we would be glad to help. 

Another option in your case would be to put each user in a separate XE database. Each database could use database links to another database for either for common data or for all their data. While this would satisfy the requirement and perhaps be more secure all around, it would be more complex to build and maintain. 

We are testing a particular HSM to use replace the Oracle wallet and user as a key-store for column encryption. We are using redundant HSMs so that things will continue to run even with a complete loss of one HSM. This works fine when connectivity is lost to one HSM at a time. The problem we found is that when there is a complete loss of connectivity to both devices, a restoration of connectivity is not sufficient to continue to allow decryption of encrypted columns. The only way we found to restore connectivity in this scenario is to restart the instance. The question is, which of these do our findings represent? 

If you want each field on a separate line, that is a simple change. If you really do want to have the gathering of the field names be dynamic, then you will need some dynamic sql inside the loop. This would certainly be doable, but not a normal requirement. 

Querying a column that can contain nulls is more complex than querying a column that cannot. So also is querying multiple tables more complex than querying one table. I wouldn't let the avoidance of null drive the normalization. For example, you mentioned that all devices will eventually be disposed and get a disposal date. If there are no other columns in the Disposal table, then in my mind it makes more sense to put DisposalDate in the Device table. Other tables like Sanitize might make more sense as separate tables because there are multiple data points that will not apply to some Devices. Check constraints are great and should be used when possible, but there will always be times when a procedure is necessary. 

You should also assign permissions and create a django tablespace setting it as the default tablespace for django. 

If you have a somewhat limited number of tables that could be returned by the query, you could have the query select from all of them, but only return results for the one matching the data returned by the table1/table2 query. That would look something like this: 

Even stranger is the fact that creating a materialized view for query that returns no data actually returns data. 

You could create a function to wrap func_returns_str in that could be used for the later calls and appends the comma itself if the return value is not null. 

I recommend you store the primary details including the English names in simpler tables and then each table that has other language equivalents can have a language specific table containing every other language. Something like this: Languages    ID    Name Drugs    ID    Price    Name    Interactions    Mechanism    Uses DrugLanguages    DrugID    LanguageID    Name    Interactions    Mechanism    Uses Companies    ID    Name    Address    Activity CompanyLanguages    CompanyID    LanguageID    Name    Address    Activity You should know that I have never done multilingual design, so my approach may have limitations that I do not fathom. 

I recommend you read the whole article. Note in particular the warning to sort by something unique so that the results are consistent between pages (given static data): 

Start with the one you expect to need to know first. If have access to or expect to have access to a particular version then start with the concepts guide for that version. If you have no database or potential database in mind then start with the 12c. 

If you'd rather do more work on the Excel side, then you could create the following table in Oracle: 

Your own account doesn’t have sufficient privileges. You are trying to track down an issue that cannot be reproduced using your own account. 

Here was my solution to the problem which in my opinion isn't as nice as using our custom aggregate function which already exists. 

This uses the same basic technique as jonearles (+1) (since removed) but eliminates the and would require only one function that turns the string into a statement. 

The first statement returns NULL and the second returns zero. If an empty set returned zero for we would need another means to distinguish a true sum of zero from an empty set, perhaps using count. If we indeed want zero for the empty set then a simple will furnish that requirement.