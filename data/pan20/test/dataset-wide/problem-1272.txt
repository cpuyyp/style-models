I'm developing a site where I need to display popups. For now they're a popup with basket contents and a popup to display item's photos. But I might need more down the road. I've come with a class hierarchy, but I wonder if there're any better ways to split the code into classes. It might make sense to mention, that one of the design goals was to keep things from moving unnecessarily. For instance, when popup is shown, page behind it must not change. You close the popup, you get to where you were. That might be obvious, but it took more effort than it might seem to be needed at first sight. And let me make it clear, the code was only tested in Chrome. I've prepared a test page, where you can get a basic idea of what I'm talking about, experiment with the popups. You can use textareas to change popup's extents. The extents are retained across page reloads. Also, you can leave comments in the PR I created. And apparently, you can inspect the code here. Now then, let me introduce you to the thing a bit. There are two modes the popups can operate in (basically, two implementations): 

Which makes it super compact and easy to read. Objects One downside of the way you have your code structured is that you have multiple global variables. This creates difficulties in managing state and also opens the possibility of colliding with already existing global variables. Those may either be from the object or even some other plugin/library that gets included up top. All the game logic can be moved into one or multiple objects/classes, which helps you separating it from the presentation in the page. Sure you can consider this a bit too much for a such a simple game but it's definitely a way to improve especially if you want to keep adding features. As a first step you could consider the following approach: 

. Responsible for hiding page's scrollbars. Is not created in mode (1). . Basically an abstract class, that is to be inherited to make use of. Popups are shown by instantiating subclass. It has the following components: 

. Semitransparent layer that fits the viewport, and on top of which popup is displayed. . In mode (2) it's the block that fits the viewport, and it's the wrapper's scrollbars that appear if popup doesn't fit the viewport. In mode (1) it has no presence on the page, just appends popup to the body. . Title plus close button at the top of the popup. . Block with buttons at the bottom of the popup. 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

Note how you are constructing the same selector 3 times with the . So this not only repeats the selector construction as it also fetches the element from the DOM multiple times. Save the fetched element in a variable and then use it: 

. It coordinates things regarding window event. On receiving the event, it notifies (if in mode (2)), then (calls 's and 's method). . Updates page wrapper's extents. . It "listens" for other two "events". It calls its method when showing popup, after images has been loaded. And after textarea resize. method notifies if in mode (2), or updates popup position (, , properties) if in mode (1). . In mode (2) popup updates vertical position on receiving the event. Horizontal position is handled automatically, since wrapper is basically a table. 

Popup is simply put on top of the page. If it fits the viewport, it has (fixed position relative to the viewport), if not, (fixed position relative to the pge). With the latter being its drawback. Ability to scroll the page while popup is shown (with popup, that is) doesn't look good. Improved implementation. Page is enclosed in a wrapper. When popup is shown, wrapper shrinks to fit the viewport and its content (the page) is positioned (relative to the wrapper) in a way that it seems like nothing happened (page retains its visual appearance). But as a result, viewport scrollbars disappear. On top of that popup is put. In a wrapper, that fits the viewport. If popup doesn't fit the viewport, wrapper's scrollbars appear. 

I'm not going to go deep into variables and functions names since @Blindman67 already covered them. But i still can't help but mention them again. They are far more important than they look, and you haven't picked them properly. Take your time picking them, it's definitely worth it. 

Note how i used instead of . With ES6 you now have both and as other ways of declaring variables. In this case i know i don't want to change or , and with it will give me an error if i accidentally change them. This builds on writing defensive code that gives you errors sooner rather than later. The itself can also be shortened with an Arrow Function: 

footer Footer is to be stuck to the bottom of the page. That is done by setting for everything but footer: . If there's little to no content on the page, 's "moves" the footer to the bottom of the page. In mode (2), when popup is shown, footer can't just take viewport's client height (), since it might have changed when showing popup (scrollbar might got hidden). So, it asks , which in its turn asks about client height viewport had before popup was shown. Another issue you might encounter with footer in mode (2) reveals itself when you scroll down to the bottom of the page, open popup, then enlarge window vertically. Footer is supposed to follow page's bottom edge. And in this case, the abovementioned formula doesn't work. You've got to add for it to work as just described. Also, after having closed the popup, you have to set according to the first formula (without ). In mode (1), you don't add to when popup is shown. In this case the formula takes the following form: . Additionally, consider a page having . When popup is shown, it might cross right boundary, if not taken care of. In this case, you generally want to increase page's : . Manager class 

There is a similar question that you may want to take a look at for some extra insight, even thought it doesn't have the contrasting color feature: JavaScript Random Color Generator Now lets get to the review. Naming 

Don't need to be separated in such a simple statement, regardless whether you use destructuring or not. You can directly do: 

Both first blocks have the exact value you are looking for and will always be an empty because there is nothing to the left. Thus it won't affect the result at all. So you can drop the altogether, and adjust the appropriately. Personally i feel you must rethink your logic a bit on this one. Restating @Blindman67, you should take spaces into consideration to make the structure less rigid. On a simpler level you can strip down the spaces before parsing: 

. Acts as a public interface for parts of the page that doesn't open any popups, but need to know how popup affects the page. Like footer, which is to be stuck to the bottom of the page. Responsible for: 

wrapper In mode (2) page wrapper is shrunk to fit viewport minus scrollbar width/height. Should it fit viewport unconditionally, page might change visually when showing popup. For instance, consider page having vertical scrollbar, popup gets shown, viewport scrollbars get hidden, and now page has more room to take horizontally. Right-aligned elements would move scrollbar width to the right. As a result, popup's wrapper should have the same scrollbars the viewport had. Or else, there might be empty space where viewport scrollbars were. To avoid that, passes 's method to via options, and when is about to be shown, it creates , and passes to the latter scrollbar state it gets from . In mode (2) when you click outside of popup (on the wrapper), popup closes. The naive implementation would be to close popup each time wrapper receives event. But then every time you click on popup itself, popup closes. To counter that, listens to event, and notifies about itself having been clicked. Then when event propagates to , it can decide whether to close popup or not. On a side note, it doesn't close popup directly. It calls method passed via option from , which is 's method. window/content change One other function popups have, they reposition themselves in response to window resize or popup's content change. The latter may happen in at least two cases: