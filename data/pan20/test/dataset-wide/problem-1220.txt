You can use a temporary array, see for example here or here. As this would change quite a lot, I'm not going to rewrite your code to match those examples. But I do have some additional comments which might improve the readability and ease of use of your code: Constructor A constructor should only construct an object. Your constructor also gathers user input. This makes it extremely hard to test your class. Just let accept an array, which you created in a class (or main). Or pass the array directly to the sort method and just use an empty constructor. Merging Your merging code is a bit confusing, because you are using loops when would be a better fit: 

Your code seems good to me. It's readable, well structured and formatted. So just a couple of minor points: When implementing a list, it's always a good idea to implement the interface, as it's well thought out. The main differences to your interface I am seeing: 

An attacker could read .doxc files outside of the (if the FTP server allows this, and if the local server is writable at the given directory, both rather big ifs, but I would still protect against this). Security: SSL Your FTP connection will not be encrypted, meaning that a theoretical man in the middle can intercept your FTP credentials or the transfered files. This may or may not be a problem for your use-case. An alternative would be ftp_ssl_connect or using sftp (see also here). Security/Funktionality: DOS & Performance From what I can tell, each time I visit the website containing the form that lists files I can join, you open an FTP connection and retrieve a list of all the files (which may be quite a lot). A user (or multiple user) may accidentally or on purpose reload the form a bunch of times, causing performance problems. I would definitely profile this and see what strain it puts on your server. It may make sense to cache the list of docs locally (if it doesn't change that often). Usability / Bug / Security: File Listing Your mechanism will hide all files which contain a dot in their filename, which may lead to hard to trace bugs. Your current mechanism may also have security implications, as files with no extension (for example ) are listed as well, even though they shouldn't be. Instead, I would probably use an approach such as this: 

Bug Your function sets , not . You also do not check the input parameters ( and ), but and . Brackets I think that you use too many brackets, this makes your code harder to read. Generally, grouping complex boolean expressions with brackets is good, but you don't need to put a single expression in them (eg ). Public Methods Right now, you have to call 4 methods to use your class. Do you expect use cases where you need to call these methods separately? If not, just make them private and only create one public method (eg called ). Extract code to function You do a lot of range checks in your code, so why not define a function for it: 

First of, yes, prepared statements are the way to go to prevent SQL injection (and you are using them correctly). Reducing Code Length The assignment of POST values to a variable as well as an array takes a lot of space, and it makes your code hard to read. There are a lot of solutions for this, one would be to move the assignment before bind, and then use the array values for binding: 

Security You are escaping user input, which prevents SQL injection. It's good enough, but really not the recommended way to do this as it's too error-prone (whenever a project does this, it's basically guaranteed that you can find injections). Use prepared statements instead. It's not only more secure, but also leads to nicer code. Guard Clauses You have a lot of nested s, which makes it difficult to see what happens when (for example, I have to scroll all the way down to see what happens if it's a request). If you use guard clauses / return early instead, your code will be much more readable. It might look like this: 

You are assigning the username to the session if the user is authenticated and if they are not authenticated. My guess is that has a check such as ? Have you tried logging in with a correct username and incorrect password, followed by simply visiting ? My guess is that you might then be logged in. Even if not though, the assignment seems inconsistent, insecure, and just begging for future bugs. The other issue I have is that you use prepared statements (good!), but not always. Why fall back on the less secure ? Just use prepared statements everywhere. 

Now all the check icon HTML is in one place, which also makes it easier to change. But the HTML really doesn't only depend on the color, but it also matters if it is clickable or not, so lets add that as well: 

I think seeds the rng for , not for . What you probably want is . Although seeding it with the time is not that good of an idea, as time is a value an attacker might guess. But really, there is no reason to use in the first place (the documentation also warns against using it when secure values are needed). Just use : 

No, I don't think so. If you want your HTML nice on output, why not have it nice in the source code as well? So instead of this: 

Another question is if this is actually the best approach. That question really doesn't make so much sense. You could use which seems to have been written exactly for cases like this, or throw your own NullPointerException if you want to. 

I'm not that familiar with the HTML5 tag, so I will not say anything about that. Your code is open to reflected XSS here: (inside script tags). You might also think about extracting some code blocks to functions to increase readability and reduce duplication. For example you have twice, which amounts to quite a lot of duplication (oddly, you one use and once ). A function like might be helpful here. 

The first piece of code is just a straight up implementation of the well-known leibniz formula. Anyone familiar with it will recognize it right away (and even find the mistake of instead of which I'm assuming is a typo). Apart from wrong indentation, there's nothing wrong with it. With your code, there are a couple of issues: 

Structure Right now, you just have all your code in the main method. This is not good for several reasons: It's hard to maintain, it's hard to test (you have to manually enter the data you want to test each time!), and it's hard to reuse part of the code. So what would be a better approach? OOP certainly comes to mind. If you haven't looked into it yet, I would suggest to do that. For such a small task, splitting the code into different methods might be enough though. What you definitely want is to extract the code that does the actual calculation for each customer in such a way that it is independent of any input or output (ie it accepts the given facts as input, and returns true or false). This will make it easily reusable and also (automatically) testable. Formatting Your formatting is quite hard to read and not consistent. Your indentation is off, you have quite a lot of unnecessary vertical whitespace, etc. Just paste your code into any IDE and let it format it for you. Misc 

Your questions seem to have been answered (use jQuery), so here are a couple of small points regarding readability: 

If your main concern is performance, your approach seems a lot better (it doesn't create a bunch of new objects). However, when I timed it, my approach was about 3 times as fast. 

You can create a couple of functions to avoid duplications. You already abstracted a lot away by introducing the class, so this is actually rather easy: 

General Structure Your student class does too many things. It reads input, it reads output, it counts students, and it holds and handles student data. You should think about creating new classes for at least the first three functionalities. Ideally, I would gather user input outside the class and pass it via constructor/methods to the class. Misc 

In addition to all the good points of @podliy16: Usability I know that this is still common in PHP, but I really don't like using strings for control flow the way you are doing it here (with , , and ). There are two main problems with this approach: 

Now it's also more obvious what happens if the agent is null. But is returning null really what you want? It will lead to a lot of in the calling code. I would suggest throwing an exception instead. Java also has a nice utility method for this: 

Comments I think that your code is generally well commented. You might also want to comment the class. Here, you could also state that your canvas starts at (1,1) and that the y axis goes downwards. You might also want to comment on what values arguments can have. For example no negative values, etc. Whitelist I really like that you have a whitelist of supported commands. I think that this is a very good way to make sure only allowed commands make it. But here is the first problem: It does not work all that well. For example, this can happen: 

To summarize: Your approach changes input data before it is inserted into the database, which could impact usability. This doesn't even add that much security, and is certainly not considered a best practice approach to security. name This functions doesn't really have anything to do with names. I'm glad that you are not too restrictive, but really, this is nothing more than a length check, so it might as well be called . email This is fine. doesn't follow any email specs, but as it's PHPs inbuilt filter, it seems ok to use it. Style / Coding Standards I'm glad that you asked about this, as there are a couple of issues: 

For a session cookie, you really want to set to true, and possibly if you are using HTTPS. Note also that isn't timing safe and that it is always better to use instead ( values are always treaded as string, so you won't have a problem like , but it's just good practice). Misc 

The advantage of this approach is that it is rather simple to write for you. The disadvantage is that it is rather difficult to use, especially without very good documentation. An example for a query builder may be this: 

I prefer your method, because it's a lot clearer. But I would turn the if around (first check the input, then the normal action): 

What happens here: cuts off everything after when connecting to the database. However, when writing to a file, does not cut off the rest. An attacker then can simply escape the string context with , and inject their own commands. Not only is this a security issue, it's also a usability issue. What if my password is ? What you should do is escape in the user input before putting it into the strings. SQL Injection you are currently not vulnerable, but what you are doing is really not correct. First of all, you don't need and . Secondly, escaping is not the correct approach to SQL injection prevention. Always use prepared statements. They are easier to use, it's harder to mess up, and the resulting code is more readable. Hashing It is not ok to use md5 for password hashing, and it hasn't been ok for a very long time. md5 is broken, and it's way too fast. Use bcrypt instead. Installed Flag Because you have hardcoded the admin id as , it's not possible for an attacker to just add additional admins via this script. But this seems to be more of a coincidence. To avoid problems in the future, you should have a flag, to check if everything is already set up. If it is, exit the install script. Misc 

Yes, it's safe (against SQL injection; if you give users complete control over table and column names, they may read data you do not want them to read). But I would worry about performance a bit. For each query you want to perform, you actually have to perform 4 queries now. The looks to be the most expensive - it fetches all items in the table -, but is luckily also completely unnecessary. You use prepared statements for the id, which is enough. If you do want an additional layer of security, you could additionally filter your input (for example, you know that ids can only be integers). You could use an input class like this for example. For the table and column check, this is a bit more difficult. Ideally, tables and columns should not be user supplied. But I have seen both in practice, so as defense in depth, it's not a bad idea to filter this at this level. I could think of two possible performance improvements: 

Nested ifs and lack of function For my taste, your code is too nested, and it does too many different things for its length. An alternative might look like this (a bit simplified): 

Structure I'm not quite sure why you chose to write your program the way you did. It seems to add complexity to the naive approach of using a normal function, without adding any benefits: 

Structure I don't really like returning a magic array. The caller has to guess or read up on the keys, which is annoying. I know that this is often done in PHP, but I think a better approach would be to move the retrieving of information to the constructor, store the result in class fields, and then access those fields with explicit getter (or if you don't want to completely rewrite your class, store the array as field, and add getters for each key of the array). This could be used like this: 

SQL Injection You are not currently vulnerable, but your approach to SQL injections is not very good (you escape values that you think are dangerous, and keep values that you think may be ok as they are). First of all, it is highly recommended to use prepared statements instead of escaping. It's easy to use, it's safer, and it results in better code. You should also treat all variables as dangerous. It's just a lot easier than having to think about the dangers of a variable each time (which will go wrong at some point). Checking the code for issues also becomes a lot easier. Apart from that, if you do escape, the call to escape must be the very last change to the data before inserting it into the query. In your case, you call after . That means if you add to your alphabet, it may be possible - although, depending on your encrypt function, unlikely - to perform SQL injections (with a Caesar cipher, it would be easy). You may also be vulnerable to second order SQL injection, in case is in any way user-controlled. Performance This doesn't seem to be a problem between the server and the client, but a problem that exists purely on the server-side, so things like page speed will not help you. You need to profile your application instead. From a quick look, it seems that you fetch all messages every second, for each client. It's no wonder that you have performance problems. One possible solution may be to set an flag and only fetch new messages. It also seems that every time you decrypt a message, you initiate the destruction process, which is then run every second forever, resulting in a lot of calls to your script. A quick fix would be to call on the right variable, which would be the return value of . But I'm not sure why you even need an interval here. Naming Some of your names aren't all that good, hurting readability. Eg: 

Yes, you have way too many fields, which makes your code quite hard to read. If you split your code up into multiple classes, you should already see a reduction in fields. Then, you might also notice that some fields don't actually need to be fields, but could be declared at method levels. Misc 

static Student count Using a static field like like this is bad practice. I would create a class, which could look something like this: 

To summarize: You have some security issues in your code (XSS and SQL injection), and your general handling of security could be better. Just use prepared statements for all data, that way you don't have to worry about which data is currently user supplied and which isn't, and you also don't have to worry about data that is currently constant becoming user supplied later on. Same goes for echoing and XSS prevention. General Readability and Structure I mostly like your code. It's clean, easy to read, and well structured for the most part. It's a bit unclear the way you posted it here, but it seems that all this code is in one giant file. I would try to split it up, so that it is easier to reuse and it is easier to find the parts of the code that you are interested in. You could split it up by type (eg all database interacting functions in one class, all functions using HTML in another, and the controlling parts in a third), or by functionality (eg a password reset file, a login file, etc), or both. Misc