My compile-time version is more like const-lists. They are made out of s which also lives in namespace. So tail of a list is just another nested-pair. This complicates things a-little bit. I had to invent an empty . If you think as a mathematical abstraction, an empty pair might not be a good idea. But pointer-based version can just use to indicate empty list. The other problem with compile-time version is that, I wrapped into a through a variable template. But in reality, every has a different type. After you , you get a new and it's type is not the same as input . Types in the compile-time version contains all the structure of the list. For example type of is . Would this pose a disadvantage in terms of generic usage? Is it better if all had the type ? What should be the copy-semantics for a purely functional list? Right now, I am treating every copy as if a new world of lists created, separate from the previous list worlds. Is there any mistakes here? My destructor is just deleting the prepended node, unless it is the beginning of a new copy. You can check this out in the code, in the pointer-based version. Compile-time version has no destructor or copy constructor. It is all value-semantics. Which would you prefer? How would you implement multithreading and -like facility in the compile-time version? Would move-semantics help the performance of the pointer-based version? What are the code-smells you can point out? Is the heavy use of recursion problematic here? 

That's really bothering me. It just feels wrong and suboptimal and I'm sure I'm not thinking this through properly. Full code below: 

Exhaustive set of event properties which components can subscribe to manually - adds extra code overhead to each message type, which I'd like to avoid Dictionary from event Type to handler in each component - have to subscribe at run-time, which feels undesirable. Switching dynamically inside a non-overloaded handler - more viable than it sounds since most components will not listen to more than a few message types, but still has unpleasant code overhead 

For every list, Open or create Sequentially load each file in the folder into memory by creating a new instance of and calling 

If you are working in PHP use a framework that has MVC such as Laravel(up and coming and popular), Symphony, Yii, Codeigniter(defunct), etc. Each of them will enable you to use some reuse mechanism. Laravel itself uses a template PHP called blade. There are several other template mechanism such as Twig that enables you to template your views to even add more granular way and cleaner. If its a single file system that you must what you are doing is fine because you are using require_once it enables you to call other files and you can modify that file and it will reflect any other files that references it. 

I have a private function in PHP that takes a given URL string and just leave the Alpha or numeric and certain punctuation left. I need the stripping of string due to having it match against ElasticSearch and ElasticSearch doesn't take it too kindly for special characters when it comes to exact match. The following function so far is working fine. 

I'm working on a game which utilises a variant of the entity component system pattern. In my current code, I have been communicating between components using code of the form: 

However, as mentioned at the beginning of my question, I am concerned about using run-time dynamic typing in this fashion (See my dispatch code in Entity - the second snippet in this post). This system will probably be handling a lot of messages, and I have some concerns about the overhead incurred (it also feels like a code smell in general) I would really appreciate feedback on this approach; particularly whether it seems like an abuse of dynamic to more experienced C# developers than I, but would also appreciate alternative suggestions. Alternative approaches I've considered, and why I did not go with them initially: 

Ok with all that routing question out of the way - I agree with mbanzon with basename being fine to check for internal directory structure to block people out... If you want extra security you can run a short alpha numeric check to make sure nothing funny is included. As for the white list - since this is a routing file and a static one a white list can also help speed things up as long as its minimal, one problem though with that is if you file system becomes extensive it maybe best to not have a whitelist at that point (you dont want your lookup to be too large to maintain and add. Side note: if your looking for interesting ideas symfony2 routing is pretty good (its being use at core with laravel). It is more extensive than your solution of course but still interesting to look at. 

I am implementing a multi-player game in C# and having seen all sorts of projects, from indie developers all the way to large studios struggle to patch networking into existing products in the past, have made the decision to get the networking aspect done first, and build the game on top of that. I've so far gotten to the stage where my server can accept clients asynchronously, but I have a strong feeling that I've implemented the threading very badly. I think it is possible that I am misunderstanding and/or misusing async/await and Tasks, but having read documentation and similar questions I think I will need practical experience to get my head wrapped around the correct usage of these. As a result, I am hoping that someone would be generous enough to look over my code and help push me onto the right track. I have excluded 'using' statements and the client code for the purposes of this question, however I can confirm the code does function correctly. I am not too concerned about issues such as naming, and the fact that I have a bit too much code logic in the Main function right now -- these will be modified and extracted to more appropriate locations respectively as the project progresses. I have denoted lines I am particularly concerned about with 

I will apologize for the lack of formatting and using your code segments as straight example - but as I re-read your code I see my old self a whole lot and I don't consider myself any level near some of the coders here. However one important aspect to improvement is obviously trial and error and a lot of refactoring. So you asked about OOP going from procedural php within a single require I would assume your going into one right way which is using classes - however there is a lot of pitfalls in your code. The first would be that to effectively do OOP you should use SOLID design pattern. First there are plenty of ORM out there that does your PDO wrapper. One thing starters would like to do is to wrap a low level class (the PDO object) into a higher wrapper functional object - its not wrong to do so - but its been done over. In reality what you should do is not offer the user (ie you in this case) a simpler form of accessing data that you need while using the database. The database of your APP can change...what will you then? You will need to write a wrapper class again because your class is tightly coupled with PDO. Lets take a look at the database class