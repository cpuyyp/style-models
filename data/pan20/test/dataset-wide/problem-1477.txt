This is pretty dodgy. At the very least add a comment listing what each of these are. I don't like your implicit cast operations from your wrapper types to the native GL handles. If you are going to use wrappers, commit. There will always be a few edge cases where some functionality needs the native handle, but that's what is for. regarding . Libraries shouldn't just write to . You would be better served to build a string and invoke a callback that is application-defined. I would make the calls to in the VertexBuffer constructors. regarding . You do not want your GL thread to be ever waiting on I/O. It's better to receive a buffer, and delegate the file loading to someone else. Use the GL* types (instead of ) They are there for a reason. 

Do you really need to sort? Sorting is a O(NlogN) operation, whereas and are both O(N). Since you are only doing these two lookups through the vector, you might be better off just using these instead. If you can use c++11, then is even better, since you only have to do one pass. don't use using namespace std; Just... just don't. Please see every other C++ question on this site as to why. 

Obviously, the library makes aggressive use of operator overloading, so the user-facing API is actually much nicer. However, adding that feature to this snippet would have added a whole lot of boilerplate that would draw focus away from the part I need reviewed. If you want to see actual usage of this, you can find it in the file in the linked github project What I'm looking for 

C-Style casts are easy to abuse, and prevent the compiler from doing a number of important checks. For example, in your case, you accidentally casted away the constness of msg. Use the appropriate cast for the situation, if you had forgotten the const here, the compiler would have complained: 

With this, you don't have to worry about anything. The mutex WILL be released when the function exits, no matter what, even with exceptions and whatnot involved. You can also ditch your macros, and use regular old true and false for your return values. Don't worry about performance so much Your code obviously has a O(N) complexity, which is as good as it's going to get here. Beyond that, wait until you have identified this code as a bottlneck beofre wasting time on optimization. 

Input sanitization Your functions take a as parameter, as such, they should be "well behaved" for any possible passed to them. Note that well behaved does not mean that it has to "work", just that it should not break anything. Specifically, what would happen if I passed the string to that function? is , ruh roh! There's a few different ways to tackle this. 

To supplement @user1118321's answer: Do not throw anything that does not inherit from std::exception As a matter of convention, all exceptions should inherit from . is generally what you would want to use instead of just throwing a string. Do not use mutable references for read-only code 

I have one big swooping recommendation that I feel you should address before tackling anything else: Mind your class invariants! When designing a class, ideally you want to ensure every single public member function handles correctly any possible valid state of the class, in conjunction with any possible passed argument. In your case, ask yourself: What happens if gets called before ? What happens if gets called twice in a row? What happens if is called after ? A good way to tackle that is to define what's known as a class invariant. First, jot down on paper a description of the legal internal states of the class. That's known as the class invariant. For example, you may want to have in your invariant definition, but would be even better, because it allows you to rely on that being true, so you don't have to constantly check. Second, for each public member function, make sure that the function's behavior is well defined for every possible invariant state, and that it leaves the class in an invariant state after it's done. Mind you, it doesn't mean that every public member function must "work", just that it doesn't explode, cause memory leaks, etc... Edit: There are some extreme exceptions to this, such as 's . But this is an exception, and the class' documentation makes it extremely clear that you enter no-mans land if you call that with an index outside of the bounds. 

My impression was "Oh! can be possibly in certain cases", which led me to search for the scenario where that might be the case. It's misleading to the reader. Defensive programming can be useful at times, but this is just excessive. 

You don't need for anything, so you should just omit it entirely Redundant explicit void argument list in main declaration: should just be Style-wise: opinions: I don't like using unsigned Since unsigned generally reads like a qualifier (I know it's not, it just looks like one), I personally much prefer being explicit and using instead. non-style stuff, but important: don't use non-sized types with hard-coded sizeof() expectations. Your struct assumes that is 4, which is bad, you should be using to properly enforce that. Writing to an union field and reading from another one is illegal This is surprising to many people as using unions to perform type punning is such a common technique, but it is, in fact, undefined behavior. You are only allowed to read from the last field you wrote to. That means your function is not valid C++ at all. What's legal is reading and writing from a (or ) array obtained from ing the pointer of a standard layout object. In fact, it's the only legal way to do direct memory manipulation of an existing object. Edit: as requested, an implementation of using casting to array: 

Use maps to handle mappings instead of having constants for each individual ratio, you might as well have a single constant that holds both the ratios and their respective strings, as well as being able to map one to the other. Consider this: 

Good stuff! I only see one big issue (which is actually what's preventing you from using this as a ). Errors: UB: Unsequenced modification 

Adding to @Null's answer: Very nice use (intentional or not) of tail recursion. Use unsigned int when you want to represent numbers greater or equal to zero can represent twice as many numbers as . It also gives the compiler more information about what your program does, which lets it do its job better. Do not include headers you are not using You are not using for anything, so you should not include it. Return something else than 0 in main when the program fails The convention is that a program returns 0 on success, and something else on failure. It's generally just 1, but some programs encode the nature of the failure in that number. 

I'm going to be cheeky here and make a recommendation that's currently beyond what I suspect your current C++ level is, because I feel like this is a great problem to introduce templates: Consider splitting the file reading in its own function, so that you don't have to reimplement the file loading logic three times. In this case, this will necessarily be a function template, since you can load different type of values. Here's what it would look like: 

removes extra lookups. avoid Singleton instantiation in the header file This is a little subtle, but the definition of belongs in the cpp file. This is important because if DLLs are ever involved, you are going to have a bad time otherwise. 

Now, the issue here is that the lifetime of if fully disconnected from when the callback will be invoked, and I do not want to move to shared ownership to put a in the lambda (like how the boost::ASIO examples handle that situation). I do, however, have a saving grace: I know for certain that the callback will be invoked in the same thread that manages the lifetime of . In order to solve this, I've created a bastardized version of (with a matching equivalent of ) that does not require the object to be managed by a in the first place. 

On the surface, it looks less flexible, but it's as functional as your version, and takes a fraction of the time to wrap your head around. It also means that your emptiness check can be moved to the constructor, so that you don't have to perform that check every single time is invoked. isBalanced() should take a pair of iterators. The correct signature for is: 

To fix these issues, I would instead add a static member function, and get rid of the constructor entirely: 

Don't use push_back on vectors, basically ever is almost always preferable. Slow removal Ideally, you'd want to store the observer list in an intrusive doubly-linked list, so that you can have O(1) removal. Unfortunately, this type of pattern is a bit of a blind spot in the STL, as there is no ideal container for it. (AFAIK, someone please correct me on this if I overlooked something). if you don't have access to something like , you can get around this by storing a in the Observer itself. You "could" manually set up the list, but it's rarely worth the trouble. Naming: Do not call a vector somethingList. "List" is loaded with meaning, and implies guarantees that your code does not provide, so it's misleading I would personally just use for the vector. RAII Since you attach the observer to the car in 's constructor, you should detach it in the destructor. Consider using instead of polymorphism for callbacks Consider how much more flexible your code would be if was a: . Specifically, once you start scaling usage of this pattern up, you will find yourself with classes inheriting from 4-5 different listener interfaces, which will lead you to realize that is an awkward name, and a bunch of different headaches. Here's a rough example to get you started: #include #include 

Returning by pointer makes no sense here. It's not like you are expecting anyone to store a long-term reference to a token. You should be returning by reference instead. Do not use raw pointers 

This way, you can consume from vectors, strings, character arrays, etc... and there is no need to make a copy of the data into a vector prior. member functions that do not mutate the class should be marked const. Pretty simole, should be marked const. Use const references when not taking posession of the data. For example: 

If you don't have such a function, then indexing the objects in the way you do makes no sense, and you should just be storing them in order of generation. Apart from that, my other recommendations would be too dependant on the context. For instance, I would look for a way to not have to store the entire table of objects, and implement the evaluation algorithm in a way that at most a few objects have to be in existence at the same time. I would also consider that brute-forcing an optimization problem like this is generally a last resort, so I would probably look for tackling this with something like a gradient descent if possible. 

This was working just fine until I had to implement the recursivity expression. In order to prevent the compiler from running into a dependency loop, I came up with a hare-brained scheme. The loops are broken up by "tagging" the trait lookup type when we first evaluate it, so that we can select a different specialization the second time it's evaluated during a cycle. So far, so good. However, since recursive expressions can invoke other recursive expressions, that tag must be maintained as a list of types. To top it all off, dependency order is not guaranteed to be stack-like (There can be a A->B->A cycle). So the end result is, frankly, too convoluted for my taste, even if it does work. Edit: Specifically, I don't like that someone implementing a new expression type needs to deal with a mysterious template parameter he/she would have to propagate. The expression is just spilling accross the entire code base, which breaks the compartmentalization I've been bale to maintain up to now. (Note: the code is not quite identical as found in the linked project for the sake of isolating the feature I want reviewed, and removing the project-specific lingo and complexity) 

I've been diving a bit into JavaScript for the first time in forever, generally trying things out, and getting acquainted. I gave my toy project the following requirements: 

This looks pretty good in general to my eyes, however, there are a few alterations I would do: I see no real need for to make a copy of the source data. It's an adapter, I would make a const reference, and create a wrapper around this + a container if I ever need an owning version. To elaborate on this: I would operate on a pair of iterators for the source container instead of a range. This will allow you to apply your code to sub-ranges. If you want to stick with the container-based interface, I think the template parameter in 's constructor is just overkill. You can get forwarding semantics by simply taking the object by value: 

This prevents a large number of namespace polution issues, and is just a good habit to build. prefer using std::unordered_map to std::map Unless you have a reallllly good reason, is almost always preferable. Why shared_ptr? 

Do your pointer arithmetic on pointer types Working with pointer offsets is best done using instead of . This way, you know that the size of the pointer will be set to whatever architecture you are compiling against, instead of assuming that you will always be dealing with the lower 4Gb of memory. Do as little work as possible in you inner loop Why are you calling every single time the hack is triggered? You should resolve the address once, and then just reuse the same pointer over and over again. Just use typed constants Instead of using defines, just use const variables, it's basically the same thing, but you can put move them inside of a namespace if/when you want.