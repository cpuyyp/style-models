My question(s): What shortcomings will I have with these functions? Another question I have is; how can these functions be improved? 

I've written a simple helper function for my helper class that allows me to check if a substring is in a string. With my function, you can supply either a single needle to check for, or an array of needles to check for. There is also a parameter that allows you to select if you want to check word boundries or not, and a parameter to allow you to choose if the search should be case sensitive or not. 

This function takes the encrypted string and breaks it into parts of 6 (Because every encrypted character is equal to 6 characters) and reverses all of the randomizations that I did during encryption to return the string: 

So you can pass any array as the first parameter that you want randomized, then the 2nd parameter determines how the data is returned, then the 3rd parameter tells the function how many times to shuffle the array. I've written this because I think it will be useful for people on StackOverflow, I see a lot of questions trying to figure out how to get a random value from an array. The parameter tells the function to either only return a single array element if false, or return the whole array (with keys in-tact) if true. As you can see in my code, I have to check for the 2nd parameter twice to do actions before and after the actual array shuffle. I wanted to see if anyone had any advice or knows of any ways I can improve my code. I've been posting a lot of my code here lately, and I really enjoy how much I'm able to learn from answers. Thanks in advance! 

Cell is processed the same manner as earlier ones. The only difference compared to previous is that fourth direction has piece of different color. We treat this exactly the same as there would be empty space in previous location so we store to . Once we have processed the whole matrix the end result looks like this: 

Instead of checking every direction individually you could represent the directions as list of tuples to the previous cell in this direction. Doing this would allow you to easily loop over the directions instead of processing them in separate branches. 

The above takes roughly four times the memory of the original matrix. That is quite wasteful since we only need to know the state for current and previous row during the processing. Thus we could just store the state for previous and current row and swap them after a row in the matrix has been processed. There are couple smaller enhancements to the original code as well: 

This copies from up to at most, and stops if the delimiter is encountered. It returns a pointer to the first character in the input range that was not copied. It can be used like this to copy all input to output: 

The task: sort the characters in a string, as provided by the ICU . This is because I want to be able to find anagrams using the suggestion from "Programming Pearls", which is, find "signatures" for each word in the dictionary, then sort according to these. It is enough if it works for the European languages and scripts. The input file is for example the word list found in . For now, I just read from standard input, print them to standard output, sort the characters in the word, and print the sorted word: 

I did solve it using ; however, this function writes to a buffer, and I need to tell it how big the buffer is. To make it deal with lines of arbitrary length, I need to read to a buffer in a loop, checking whether is set (when the end of the line wasn't reached). Then, the easier solution was to use iterators on the input and the output stream, like this: 

The first parameter is the array itself, the second parameter is the key that you want to group by, and the 3rd (optional) parameter is a boolean that tells the function if you want to preserve the group key in the sub arrays. Examples Let's use this dataset for examples: 

I know what you are thinking, it's never a good idea to roll your own encryption functions, but I'm doing this for fun and self-learning. I created a function that allows you to send a string as a parameter and it will return an encrypted version of the string. Here is my encryption function: 

I've recently written a function that allows me to take a flat array and convert it into a multidimensional array by a specific key in the array. 

I've written a function that allows you to pass an array of values, which is then shuffled and returned based on a parameter . This is the code: 

On the second row thing get bit more interesting sine we have to take into account the row we processed in previous step. At we check if the color matches each of the directions. If it does we take the previously stored and increment it, otherwise it's the first piece in line. For first direction the previous cell is which is out of bounds so this is the first piece in line for that direction thus we store . When checking the second direction we see that there's a piece with same color at . Thus we take the previous stored value from and increment it by one resulting to . Since there is no piece in previous cell in third direction and fourth direction is out of bounds they both result to . Now our current state looks following: 

With above matrix the first cell at would have store since it's a first piece in line for every four directions. Since second cell doesn't have a piece it can't belong to a line of pieces of same color so we store as distance for each direction: . Third cell on the first row is treated the same as the second one since it is empty: . After we have processed the first row our current state looks like this: 

This will encrypt the string, whereas every character will become 6 characters. The 1st 2 of each character are keys that are required to decrypt the letter, and the 4th character is the actual character being encrypted except masked by a random digit (Basically the letter is converted to its ASCII number and a random number between 0-9 is added/subtracted from the letter). The 1st key (labeled prefix) lets the decrypt function know if the random number needs to be added or subtracted, the random number is passed as the 2nd character in the encryption, and characters 3, 5 and 6 are random noise characters. Note: The prefix is generated depending on the ASCII number of the character that is being encrypted. If this ASCII number is below 44, the random number is always added to the character being encrypted, else it is always subtracted. The prefix itself is a character in a certain range, if the ASCII number is below 44, a random character between ASCII and is generated, any of these characters tell the decrypt function to subtract the random number from the encrypted character, else ASCII between and will always add the number. For example, the string "Never roll your own encryption functions." may encrypt to: 

This is a part of a project I am working on. I need advice and criticism regarding the data base design and general approach to querying the data. I am not at all experienced with relational data bases (as you should notice), and even though I have tried to invest some time in reading up I am currently forced to just move along as fast as possible. Currently using SQLite3, and most probably sticking with it. The data base schema goes along the lines of: 

First off, I do realize that I have not put any effort at that moment to ensure data integrity (apart from the obvious and ). There are a few foreign keys lurking in there: for example, the column in both and is the same that is the primary key of the table. Another issue is that the column, in every table it is used, is a unique identifier consistent across all tables. The data, as I have it, contains no further information about "patients", so I have not felt the need to make it a unique column in a table of its own. After some trial and error, and much unsuccessful mucking around with the different s, I eventually got to the schema above, and the following "style" of querying it: 

You could use Union-Find. Every edge in your graph represents elements from two subsets that you want to merge. Once you have completed the merges constructing the sets is trivial. When implemented with union by rank and path compression the algorithm runs in O(n) time: 

One way to solve this is to keep a track of lexicographical ordering for every pair of suffixes. Then for every update just update the ordering for suffix starting from index . If ordering was changed then update suffix starting from and keep on updating as long as there are changes. The current state after every query can be found from . 

Since there are four different directions you could either loop over the matrix four times or alternatively calculate the distances in separate directions in parallel. The second approach would require you store all four directions for each cell in matrix. Let's take a smaller matrix and see how second approach would work in practice: