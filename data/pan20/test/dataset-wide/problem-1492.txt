similarly for timed get, don't catch interrupted or timeout, they are artifacts of the calling code and let them deal with it. 

Some won't let you seek to the end (stdin and socket streams for example). You should check the return value of and fall back to the classic then , rinse and repeat method on error. A single is more efficient than the repeated ; so you can replace the while with: 

But this is something that you need to profile and benchmark. There are other optimizations like doing multitple characters per iteration to help with pipelining. 

If you destroy a non empty list you leak all nodes still in the list. Similarly the in just gets its values overwritten. 

There is one thing missing: iteration. There is no way for the user code to get all items stored in the list without doing for each item which will result in O(n^2) time complexity. Building the ListIterator without remove support is simple enough you just need to have it keep a reference to the current node. 

Here means that the value may or may not have a value which you can check with . However the way you use it if by then getting the account immediately if you found it. So why not return the account directly? 

However there are better sorting algorithms (like quicksort) and there is a built-in sort in (and one in that works on ) which has been used for a long time and can be assumed to be efficient enough for most applications. 

In my opinion returning an is the best option as the method requires ints, anything else would imply additional conversions. 

calculateCombinations Your method does a lot of not required iterating. You only have to iterate up to in the outer loop as afterwards the if statement evaluates always to false (-> you can remove the number variable and thus the call). The value of and is the same on each iteration -> you can drop the variable. The if statement can be removed by starting the inner loop at . The resulting code would look something like: 

Current approach You can determine the exact count of days in the mask beforehand -> you can use a better initial size than for the array list (or directly an array as the size is fixed). You don't have to sort the list (and thus don't need the comparator), rotating based on the is sufficient as the order of the days does not change. While this is very ugly: You could replace the with . Regarding your edit: This seems like a very bad idea if you ever want to make your app multithreaded. Alternative implementation You can avoid rotating the resulting list if you start interpreting the at the provided instead of . 

Runtime improvement If you take a look at the last digit of the first few fibonacci numbers you will see that the digits are repeated after 60 numbers. As the digits in this range have a sum of you can calculate the sum for instead. Bug The task states that the given integer are non-negative, is a valid value. Currently you are returning i.e. for the range as is treated as , the initialization of sum has to be changed to: 

naming + all lower case makes it hard to parse the difference between the prefix and the name of the function, instead either pick or . returning is not ideal instead create a opaque (incomplete) struct and just let the use pass pointers to that struct around: 

This needs to be synchronized so no thread can mess with the list while another is checking the length to see if one needs to be removed. 

This has the downside that only way to get all items from a generic Collection is using the or the methods. Though each time you call it on them you get an up to date view (with the same caveats of the same methods of the queue). 

The fastest way is to give each thread its own RNG seeded (and sometimes reseeded) by a master RNG in a thread-safe manner. 

Besides that because you allocate with the default constructor will be called for each element each time you allocate and the destructor each time you . To avoid that you can use placement new and placement delete instead. This requires you to loop over all elements that you initialized and call the destructor on it during deallocation. Though this is more complicated to keep track of; the containers outsource this to an allocator object. 

There is no reason to use String as keys in . By default an object can be used as a key in a hashmap based on it's uniqueness. There is no reason that the values have to be ArrayLists instead just use List. 

In the array version you can use post/pre increment and pre decrement (most likely no difference in terms of performance but shorter and in my opinion better readable). 

MyWord Your / implementation is not conform with the specification of - equal objects can currently return different hash codes. The implementation of should return the hash code of instead of . The constructor performs no argument checks -> it is possible to create i.e. an instance with , which will lead to s thrown by the method. The method could return . Alternative implementation A priority queue is not a good data structure to determine the frequencies as you have to iterate the queue for each input element. You can use a to convert the input array to the frequencies with complexity (plus additional to sort the resulting frequencies, or to create a heap). Using the stream api this could be written as: 

The implementation 'does not count' as it overloads the method and does not override it. You can use generics to specify the expected parameter type. If you can change the interface: 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

For O(1) performance you could precompute the factorials for values up to 12 (all factorials in int range). 

Space efficiency: Currently you are storing 50% of all values, this can be reduced to 33% quite easily by not storing any multiples of . (Excluding additional values is possible but complicates the calculation between value and index, you might have to check until which point excluding values is advantaguous.) Sidenote: You reduced the space consumption by the factor 2*8=16, not 64, compared to an implementation that uses a (at least for the OracleJVM). Performance: You are iterating over each bit, I would use to process the bits in blocks of 32 bits. You might want to use multiple threads to sieve, a simple implementation could use multiple threads to strike of multiples of different starting values. (For comparison: my quite similar implementation that skips multiples of (and uses instead of ) is around 25% (singlethreaded)/60% (multithreaded) faster than your current implementation.) Implementation: You don't need the variable as it is equivalent to . Your current implementation may overflow for larger sieve sizes. I would iterate over the indices rather than over the values to avoid converting while striking values off. Possible implementation (the resulting array should be encapsulated in a class that provides methods to operate on the sieved values): 

You can use a single match of a Pattern to find both the leading values and the string inside the parenthesis: 

There is no way for the producer to check if the queue is full. It will just overflow the buffer when asserts are disabled (which they will be in production). 

If the SettingsDialog can only take a MainWindow as a parent in the constructor then declare it to be so: 

You can reduce the number of checks you do by using the knowledge that you only need to check prime factors up to the square root of , all but one prime is odd: 

I would also add a third variant that will create an object on the calling thread when the pool is empty. 

First thing that is wrong is that you are reinventing a wheel. Second why not ditch the and do directly in the first runnable instead? 

The code in and is nearly the exact same. This is a good hint that you can extract it into a single function. The switch can be simplified by letting the duplicate cases fall through: 

When you update the vertex' estimated distance you should signal the openQueue to update it's position in the backing array. 

Instead of using a raw array to store the children you can instead use a . This will better optimize the allocations that you do. Using a map will also remove all the for loops for searching a key in a layer. 

(I would initialize with a ternary operator instead.) Types As the values of , and are always in the range , you can use instead of for these variables, arithmetic is likely to be faster than arithmetic. Alternative implementation The remaining range is quite small -> you could cache the results for every number in the range to avoid calculating the sum on each invocation. 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

but this has a race condition (turn changed after the test but before the wait->the changing thread has already called and deadlock occurs. (This is the reason why wait and notify have to be in the synchronized blocks) This means that you need to synchronize the testing and the changing of turn, but if we do this then we don't need a special class but a normal will suffice: 

Your temp array is static, this immediately makes your function not thread-safe and non-reentrant. Instead add it to the parameter list. 

You can instead use a LinkedHashMap, which lets you get the in access order if you made it with the (int, float, boolean) constructor. Then adding means removing if it becomes too large. However LinkedHashMap is specially designed to let a subclass decide when to remove the oldest entry using the removeEldestEntry which gets called on each put: 

In radixSort you assume that is a signed 32bit int. Instead you should check whether it's an integral type and alter the algorithm a bit based on its properties: 

Try to avoid allowing the invocation chain to go from a valid object to an invalid object. Your allows that. Instead you can make a method which takes all the required configuration items for setting javaSE to true. 

and in the destructor you will need to destroy them all like you need with the nodes actually on the stack: 

The initializer can be replaced with or the static value . This removes the hard wire and the slow pow function. 

As sorting by frequency works for every input type and not only strings, I would use a parameterized class instead of to support all types. Possible implementation: 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

This implementation still feels like a literal translation of the for-loop approach. Streams offer options to improve readability, i.e. the inner loop can be flattened: 

Current implementation You can reduce the variable scope of your static variables by accepting the array input as parameter and returning the queue. You are currently iterating the queue three times if the queue contains the word (, iterator loop, ), this can be reduced to one iteration by only using the iterator. 

Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

Alternative implementation Your current implementation supports arrays with a maximum length of 30, you could provide a method to support arrays with up to 64 elements (or a larger datatype than to support way larger input arrays).