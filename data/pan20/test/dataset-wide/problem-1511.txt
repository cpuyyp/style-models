We will start with garbage collection. Since you are not getting long-lasting sessions, that fact that you want to collect session data files (or database records if one were to use a database to store the data) indefinitely, means that you are, in essence, accumulating attack vectors against your application. Ideally you should use an appropriate session lifetime and an aggressive approach to invalidating and pruning old records to minimize security risk. One comment from the section of the securing INI link above seems very pertinent here: 

Be consistent on your usage or non-usage of semicolons to end lines of code. It seems like you have chosen to use the no semi-colon style, so why is there one after ? 

Consider throwing if you want to be more specific here. I actually find it a bit odd that you use custom exception types in the code calling this but not here. It might call into question how you are using custom exceptions throughout the application. 

Consider changing to which is much more common terminology with regards to pagination. Consider changing to (the correct English word) if you are going to be writing your variable names in English. Also consider naming your GET/POST parameters in English for consistency (again, that is if your desire is to have your code written in English). Mixed-language code can be confusing to the reader. 

Why return the array of names from this function? If using key-value store this function might look like: 

You can probably address the same name* anti-pattern in your HTML element ID's. You probably should not have to worry about dynamically generating id names. Instead, just apply a class to all these elements and use data-properties on the elements to provide references between elements. 

Why is this necessary? If you validate properly you get away form this conditional. If there any reason to expect that the error messaging, which this applicaiotn controls would ever have extra whitespace anyway? 

If you want multiple classes to be non-clonable or non-serializable consider putting magic methods that throw exceptions as noted above into traits and simply use these traits from all classes needing these behaviors instead of re-implementing these methods across every class. The same could actually be done for singleton behavior as well, though, I would encourage you to break out of this way of thinking about singleton. 

And would go through all the logic of for validating user name, setting up directories, etc. This code should know nothing about what is required to create a "user" outside of whatever information needs to be passed (i.e. user name). 

This seems like a lot of complexity for limited/no value. Could you not just pass an object literal like to the geocoding function and be done with it, losing like 20 lines of code in the process? A few other thoughts: 

I would encourage you to use meaningful and specific variable/class/method names. For example, is not really a meaningful name. is not meaningful (and redundant) as one can obviously see this class is meant to be used in a concrete object context and is not very specific and tells the reader nothing about what this class does. Since this class is only designed to work with , I would think that, at a minimum, should be in the class name. I have a hard time thinking of what you might call this class based on the fact that it does too many different things, but even would be more specific (but defaulting to a name like "helper" should be a red flag that the class is doing too much). 

There is no reason to change your system's default timezone on the fly if you just need to apply a timezone to one specific object. Right now your code could actually severely break other code in your system that follows instantiation of one of these objects, in that you have munged with default setting for all code that follows in script execution. If the default setting on the server were for a different time zone, all code execution up to the point of instantiation would operate in that timezone, while all code after would operate in . If you truly are trying to set this as your default timezone for your entire application, this function call should be made somewhere in your bootstrapping process. If this truly is a class-level setting, should the (or similar) value be passed to the constructor, or be a class constant? Right now you are "hiding" this setting inside method logic, which is a bad idea. 

Can these credentials be passed in an object that can be better type hinted? You should take appropriate steps to validate this parameter as a valid dependency (and throw Exception if it is not) before working with at and setting it on the object. Perhaps throw upon validation failure. Consider passing the Guzzle client to constructor as dependency (dependency injection). Why should this class need to know how to instantiate its own dependencies and the potential error/exception handling around them (which is absent here) in order to work with the dependency? It should just get a valid dependency this is properly set up for it to begin working with. Get in good habit of namespacing. Wherever you instantiate the guzzle client you should do it like . This is much clearer (eliminates the need for your comment). Similarly if passing as a dependency, you should type hint as . 

You should validate user input. Prepared statements are great defense against SQL injection, but they are no defense against useless input. What if your values for and are not integer representations? Why would you even attempt a (relatively expensive) query with non-sensical input? 

JSFiddle of this example My guess is that, for your interview, they were really looking to see that you could identify this as a stack problem and come up with a reasonable implementation. 

Consider adding type hint for the parameter passed to constructor. This is obviously a concrete object being passed, so having typeint here and make this class less fragile and prevent the needs to validate the passed parameter (something you are not currently doing). 

Should be public? What is use case for caller needing this method if this is automatically done from constructor (which I think is the proper approach)? Should be public? I don't see how it is meaningful for caller to access this method. 

In an overall sense, session management in PHP is a bit painful. I have actually spent a good amount of time in this space and have created an open source PHP session library While you are free to use this library, I am hoping that at least some of the "Readme" information on the linked library page can point you in the right direction to literature related to proper session management in PHP. 

You have a few cases where your lines of code are getting to be pretty long. You should strive to keep code under 80 characters per line, breaking up code across lines as necessary. This helps make your code easier to read. 

I would be VERY concerned with performing any operation that can change data in your application via . Typically is used for these sort of operations, such that people don't accidentally bookmark the URL and keep returning to it, potentially performing unwanted changes in your application. Get in the habit of thinking as as a read-only protocol. 

You now have the basic building blocks to create your quiz. You could include this code anywhere and have a reusable quiz. Now you need to build the quiz itself. That may look like this: 

Other than for simplicity of being able apply all replacement rules easily, and with more maintainable code, I don't see an absolute need to use regex for this, as simple string manipulation should be able to be used here and may be better from a performance standpoint. There is no reason for you to loop over the regex array and each individually, as accepts arrays for both patterns and replacements. So you could easily do something like: 

Get in the habit of using exact comparisons (, ) rather than loose comparisons (, ) by default. Loose comparisons lead to buggy code and should be avoided unless that is a specific use case for the loose comparison (and I usually find myself adding a comment in such cases as to why a loose comparison is appropriate) 

Do you really need to be arbitrarily creating objects/arrays in your data structure the way you are doing with arbitrary levels of nesting? Taking this arbitrary retrieval/assignment approach to this problem of working with the desired data structure seems like a problem in how you have conceived your implementation. By my brief perusal of the specification you linked, it would appear that you are dealing with a much more specific data structure than this arbitrary get/set approach conveys. For example, I am guessing that you might need individual methods/functions managing the different nodes on your data structure (page, product, user, cart, etc.) so that you can actually enforce proper behaviors on those subelements on the data structure. 

I have similar concern for namespacing between and . You are doing nothing to prevent namespace collision. Should own providing namespace to ? Should actually contain an array of that it owns similar to the relationship between and so that it can truly own/manage/instantiate within it's top level domain space? 

Your code does nothing to protect against cross-site-request forgery (CSRF) attacks. Typically this would take form of variable stored in session compared against token passed as hidden input in the form. Without this, your script can easily be hijacked to spam mail recipients. 

Beyond that, I would suggest being cognizant of your styling. Right now: - your indentations are inconsistent - your variable naming style in inconsistent between using snake_case, camelCase (like in keys), and no way to differentiate words in your variable name at all (i.e., ). You should pick either snake_case or camelCase to make your code more readable and stick with whichever style you choose. I would actually recommend camelCase as PHP, as a language, is moving more in that direction with regard to industry styling standards. 

I am not sure that you are using static properties/methods appropriately, though I am not 100% certain without better understanding how this class fits in the overall application. It seems to me that an object in your system that is tasked with rendering a TimeTable might have separate instances. You spend a lot of time "constructing" the various data you store on static properties. This seems more like instance behavior rather than behavior that should be setting globally-accessible static property values. Is there more than one time table on a page? If so, why would you be resetting these static values for another "instance". If this class is truly intended to have a common set up across the whole application (i.e. really be used statically), then I would think you would best be served by getting the vast majority of logic out of this class, either into configuration which is read into static properties, or into separate object dependencies that could be passed to this class. This class should not need to know how to set up the the time table to be rendered. Tt should be given a properly set up time table (and other dependencies) and do one thing, render it. Also, if this class is truly expected to be set up only once, I would expect to not have to recalculate/reset the values in every time a time table needs to be rendered based on this configuration. You could perhaps have an "constructor"-like method to set the class up and then calls to could just focus on rendering. Again, though, this is really almost instance behavior as this would have the same effect as instantiating a single object of this class and operating against it across the application. Looking at the ways you are accessing your other classes, I wonder if this is a wider consideration, as you seem to be taking an almost exclusively static approach to interacting with other objects in the application. Think about dependency injection over static methods for instantiation, as you can really bloat your classes if they all need to hold understanding for how to instantiate all their dependencies (and perhaps handle errors/ exceptions that could potentially arise during dependency set up).