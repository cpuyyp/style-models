Your type is a struct, and 2 values of the same struct type are equal if all their fields are comparable and are equal. So you will find a value in the map if they match by and . is an interface, so a different comparison rule applies here. At runtime interface values can hold values of different dynamic type. Both the dynamic type and the value must match in order to claim 2 interface values equal. (You can read more about the representation of interface values in blog post The Laws of Reflection: The representation of an interface.) The dynamic type of the values stored interface is a pointer, a pointer to the unexported type . So now we need to apply the comparison rule for Pointers. 2 pointers are equal if they point to the same variable. So 2 values of will match only if the pointers stored in them match. You used to obtain the slice of s, and whenever you call it, it creates new pointers and hence they will never be equal, meaning the wrapper interface values will never be equal, meaning indexing the map with these values will never yield any results. 

So, one of the thing here is that the CPU is waiting for your hard disk to provide data, and then the hard disk is waiting for the CPU to ask for something. The first and more obvious point is that accessing disk to get a few bytes each time is terribly inefficient: disks (HDD or SDD is the same, in this case) are best for sustained reading. The OS cache will help you so that it will read a bunch of data ahead for every request you make, but you know you are going through the entire file so you shouldn't rely on the cache and try to be as efficient as possible in your code. In fact, as rolfl points out 

Now an explanation why your original didn't work as the key. When you want to find an element in a map by key, Go uses the comparison operator to test for equality of keys (hash code is generated and used under the hood to speed up the lookups, but that is irrelevant now). This is how the spec defines the terms and the result of the comparision. Quoting the relevant part from Spec: Comparision operators: 

Also it's just a matter of taste, but I find it easier to read if you use the index instead of the length (which is ): 

Your code looks ok to me, but here are a couple of points to improve: You used the package to obtain the arguments to your program. The original intention of the package is to process optional, named arguments to your program and store their parsed values into variables (designated by pointers). Using it just to obtain a list of arguments is somewhat "overkill", better would be just to use a simple variable in the package: . holds the command-line arguments, starting with the program name. Since you don't need the program name, skip that by re-slicing this slice. Your new function: 

because I have no idea how you instanced and set the dm object before, and you need to do the same here; I just added a generic call to the constructor to help you understand. Another big warning: you need to understand multithread programming, otherwise this code will sooner or later blow up in your face. Usually in the worst possible moment. 

You are rebuilding at every loop exactly the same base string, over and over and over again, what's the point of that? Your string is the same except for the serial number, so build it once outside the for loop and the reuse it. You don't even need to use a StringBuilder here, as in general it begins to be faster when you are concatenating more than 3 strings, otherwise plain normal string concatenation is better. 

Implementation Things to note: To determine which power of 10 preceeds the input , we may use a loop always multiplying the previous number by . These multiplications (the powers of ) are constants, we don't need to do this in the function, we can precalculate them and store them in a slice beforehand. Note that for practical reasons, I will store the power of 10's -1. See below the implementation for details. 

I think both your solution and your testing are fine. A couple of test cases I would add (but your solution also passes them): 

Using a constructor-like function is the idiomatic way in Go. See Effective Go: Constructors and composite literals. Also relevant: Effective Go: Package names: 

If we have a sorted slice of the power of 10's, we can use binary search to find the power of 10 for our input number. However as this slice is small (~10 elements), it is faster to just loop over it in a sequencial way. The total number of digits of all numbers having the same width (same amount of digits) are also constant values. We will precalculate these and store them so we don't have to repeat this constant calculation. For the first 8 digits: 

190 MB/s is ridiculously low for an hard disk, unless is a 5-8 years old cheap model; right now even an SD card can be faster than that, sometime. From a decent SSD I'd expect at least twice that speed, and today even SSD in the range of 100$ can easily saturate the SATA interface. That is, you want to read big chunks of data every time; no matter what, don't read a line at time. There is no magic number, but unless the computer has serious memory issues 100 megabyte each time should be more than good. Now, problem is, while waiting for data the CPU is sitting idle doing nothing. Then, while the CPU is crunching your data, the disk is sitting idle waiting for something to do: needless to say this is time for some free multithreading. Deciding what to implement is a bit complicate without knowing the exact details and limits of the project, because you can simply have a number of threads equal to the number of cores, each one working onto an equal part of the file (easily doable in an hour total), or going to write a central dispatcher that read chunks of the file, create threads up to a certain limit (maybe doing some throttling), and collecting the results (and this can take up to a day of work). It all depends on money and time you have available to do this but, yeah, go for it. 

And if you want to iterate over a whole "collection" (e.g. slice, array, map, channel), the For statements with clause is the clearest way. "Unfortunately" your type does not expose such values, so it's not possible to use here. It can still be improved to call once: 

2. Convert the first to raw bytes Compare slices () We may choose to convert the text checksum back to a which holds the raw bytes of the checksum (NOT the bytes of the UTF-8 encoded hex representation). We can parse the hex representation simply with . Or even better: since we have the text checksum as a , we can use which takes input as a . As an extra gain, we don't even have to care about lower or upper case: handles that for us. And we can convert to by simply slicing it. Once we have 2 , we can use to compare them (in Go slices are not comparable unlike arrays). 

Edit Sorry, I was again thinking about point 4 above, got struck by a doubt, checked again, and here you are doing something that make no sense at all: 

The content of the Parallel.For will be executed in multithread, so you need a unique instance of every variable you modify and for every class you call a method of, so keep an eye on the 

First and foremost, Phyton is not my language of choice (or in other words, I don't know it at all), so I'm just trying to add something regardless of the language. Yes, you would benefit a lot from multithreading here, it's quite a basic case. I give for granted that Phyton does nothing to complicate using of multiple thread, obviously, because doing multithreading itself is cheese task even when using the basic OS APIs. As a general rule of thumb, unless you are dealing with a really fast computation where the additional overhead added by threading will worsen the performances, there is no point in not using parallelism everywhere. It's one of the easiest things to do in computer programming, and it allows you to "choke" the hardware to the point that no matter what, you are granted to be going as fast as the PC allows. 

By doing this we also got rid of the package dependency (so it won't have to be added to your compiled executable; and was already used, so that's not a plus). Next on to your utilized as a Set. This is how you check if something is in your : 

Compare manually (byte-by-byte) We can also do the comparison manually, it's relatively easy and straightforward. But first to do it manually, let's create a simple helper function which tells if a hex digit (the text representation) equals to the raw data: 

Add +1: (this is why we stored powers of 10 -1) Multiply with the digits count: Add the total number of digits of all the numbers having less digits: 

If we look at it, is the negated value of (if they are equal, no need to swap). So we can rewrite the rule; swap elements if: