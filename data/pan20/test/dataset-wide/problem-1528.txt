My suggestion is to abstract from the sources where the elements come from. So the first responsibility will be a class that can asynchronously receive elements and output them in a sequence. Following algorithms now only need to depend on objects of this class: 

Conclusion You do not always need a library X or a special API. Simple language mechanics and expressive names for methods and classes will mostly do the job as well. Of course the need for the concurrency API rises by the "complexity" of your requirements. In this case I do not see any need. 

You have public/package scope variables that should be private scope You tear apart the Button construction as it should contain the ActionListener declaration as well Use lazy getter instantiation for your UI elements and use these getter only 

Comment on the builder pattern I don't think that Joshua Bloch discovered any new version of the builder pattern. I suggest to follow the standard way and purposes from the GoF. The purposes of the builder pattern are: 

Use lazy initialization You currently separate the component creation process by immediately instantiating the component at the variable declaration and configuring the component elsewhere. Component creation and configuration should be encapsulated in lazy getters like this: 

Thread Of course you can distinguish between "Runnable" and "Thread". But you should not instantiate a thread within its runnable. The whole concept is compromised as you introduce a bi-directional dependency between those classes. A Thread my know a Runnable. But the Runnable shouldn't know the Thread it is running in. For simplicity I left away the Runnable in my suggestion. But it would be cleaner to distinguish beetwen "code to run" and "thread to run the code in". 

It depends on semantics and assertions. If your semantic is that any other value that 1 and 2 leads to the UNDEFINED constant AND you algorithms work then you will go fine with Martin Spamers solution. Returning null or an Optional is equally good or bad if the reason to return uncertainty is bad. First you should go for a solution without returning null. In general it is a good idea to have a full covered enumeration. With that I mean that any case you can think of will always fall into exactly one of the categories the enum provides. If you have a real 1:1 relationship between the value and the enum constant then you should strictly follow semantics. If an enum constant does not exists for a value then throw an exception or return null. Returning an Optional should be considered carefully. For me an Optional is not an substitute for return a null value. For me it is something that states that something may be there or not NOT depending on any input parameter that provided by the caller. So you should use Optional to express a case when something currently is not available but you may come back later and the requested object will be there. And furthermore this object may disappear again in the future. Optional should be used if the requested object is nice to have but not essential. The process may not be that efficient but it will still do its job. If you have a 1:1 relationship from value to enum constant and this is defined by an RFC you can assume that a missing enum constant for a value will either never comes available. Of course an enum constant could be added. But that is not what I mean. The question is: can the enum constant be resolved by an unknown value potentially at runtime? The answer is: No. That is why returning null or throwing an exception is appropriate and you should not use Optional. 

Injecting Repositories or anything else into the business layer is an overall bad idea. You business layer should be free from framework mechanisms. You will pollute your most important parts with unneccessary complexity. What you can do is to place DI in certain objects that will initialize the dependencies around your business layer. So you may use a "RepositoryProvider" as an DI dependent artefact that will initialize a "RepositoryRegistry" which is DI independent and is used by the business layer. Keep your your business layer clean. 

Sure, you may speed up your code execution. But the core problem remains: Inresponsive UI executing a long running task. If you expect the user wait for completion a long running task you should consider UI supported synchronized mechanisms to adress it. Asynchronous execution is mentioned here: $URL$ The idea is: Execute your code in a separate thread and synchronize results by publishing them through the Java FX thread. 

This looks a little bit ugly but it is the Swing way. Other frameworks do not work with the String-Type. They often work with the Object-type (Vaadin: button.setData(...), JavaFX: radioButton.setUserData(...), etc.). Nevertheless: the trick is to make the decision at the origin if possible. In your case in the buttons. You may also have a look here: $URL$ One big advantage ist: You are able to add new Buttons (plus 300??) without the need of enhancing any if cascades. 

map the Exception to an exception of YOUR domain make the Exception signature irrelevant (RuntimeException) 

The Button is clicked ActionListener is called It is delegating to the Model The Model changes its internals The Model informs interested Listeners of internal changes (Listener pattern, push mechanism) As the WordTextField was registered as interested in Model changes it will receive the notification an can update its state on its own 

You are totally missing a model layer. I don't know if you have the intention to introduce one. But setting the text of "diagnoseField" directly is across country. I'd expect the ActionListener call the model so it will change. The change will be populated to "diagnoseField" through another listener mechanism so the ActionListener isn't aware of what has to be changed in the UI. 

Code I looked after a solution with less if statements and more expressive artifacts. I came up with this: Introduce a class "Situation" This represents a game situation with the choice of each player: 

Solution 1 Maybe for readability a recursive function is a proper solution in this case. But think about it carefully because it will strain the stack. 

Only the names are different but the calculation is the same. Normally you have 7 cases of given information: 

Object scope You should introduce object scope. Your source code gains flexibility through the possibility to to apply abstraction, polymorphy, inheritance (Open Closed Principle). Your code will be testable much more easy. Furthermore in JAVA 8 you can make use of functional interfaces. That would not be possible in a static context. Constants As "bracketMap" is a constant you should declare it "static final". Then you will get rid of instantiating the HashMap every time you call "validateBracketPairs". break, multiple return (and continue) Avoid those statements. Using them you hinder yourself to make use of applying refactorings like "extract method". Within a loop you spread your breaking conditions all over the place. That makes the code less readable an maintainable. All breaking conditions for a loop should be at one place, the loop header/footer. For methods that have to have a return value try to have only ONE return statement at the end. for-loop The for-each-loop is not the appropriate loop for this case. Consider a loop type that allows breaking conditions to have a proper place to put your go-on (breaking) conditions: As long as there are characters to process OR you not found a validation error. switch-case The switch case statement can be simplified through the standard if-then-else. Use the keys() and values()-method of the bracketMap to check if they contain a character. Now you are able to extends bracket pairs through putting them into the bracketMap without touching the if statement anymore. (Single Responsibility Principle). Naming Because bracketStack only contains open brackets it should be mentioned in the name: openBracketStack. Code So I would end up with something like this: 

Value objects Value objects are creating their identity through ALL values they own. If they differ in only one value they can be considered as different. Value object should also be immutable. Business objects Business objects do have an identifier and a type to recognize in equals. In hashcode you should at least recognize the identifier. The type is optional. The identifier is used to identify the object uniquely. The type preserves the knowledge of the object's behavior. Business objects preserve identity and behaviour but allow little mutability that is encapsulated (object orientation). You may ask if two business objects are equal even if they differ in other attributes than identifier and type? Yes they are. Think about yourself: Even if YOU change your name, you remain the same as before. Your identity is different from your attributes. General Both object types have one thing in common: They are globally unique independent of the system border and they preserve their identity under every circumstances (the identity is immutable). And that is one purpose to override equals and hashcode. These two object types also related to each other: business objects communicate with each other through value objects (messages). Here it doesn't matter if business objects communicate system internally or beyond the system border. Thats the second and the last purpose. Other objects If you have other objects that should not exit the system border (the JVM) then there is no necessity to override equals and hashcode. And no neccessity means you shouldn't do it. Furthermore you can consider it as a broken design if you need to implement equals and hashcode within the system borders as the JVM provides object identity from scratch. That would mean that you may instantiate the "same" object at independent locations in your source code. That at least violates the single responsibility principle. So if you think about implementing hashcode and equals on other objects than business objects or value objects you are nearly sure to be on the wrong path. You DEFINITELY exit the path of object orientation. You can do so but you will end up with a different programming paradigm (functional programming, only values and functions) in the best case. If you do this not strictly then you get an hybrid that will own the advantages of both paradigms but the disadvantages as well. The problem is that the assertions of on paradigm are the harm of the other paradigm and vice versa. You inherit missing encapsulation from functional programming and you inherit mutability from object orientation. So effectively you only get disadvantages. So you see: Your decision has deep consequences if you do not follow it consequently. If you implement equals on every object, the attributes on which these methods base on mustn't change as hash-related collections are working with it (HashSet, HashMap). If they change after adding them to such a collection the objects are not predictable accesssable anymore. If you implement hashcode and equals on all objects you you win immutability on all objects and functional programming in the whole. Conclusion Be carefull with this decision. Think about what kind of programming paradigm you want to follow. At least for ONE module you should decide between OO or functional programming as one paradigm will eliminate the advantages of the other paradigm. 

One other thing: the abstract Composant-class is irrelevant to the abstract factory in your case as far as I see. Furthermore it will bind you to a set of methods that "Menus" and "Bouttons" have in common. This would hinder you to configure special properties of "Bouttons" and "Menus". The two types may of course stay derived from Composant. I thought about it a little bit when the use of parameters in the factory pattern may be appropriate. In the following example (in pseudo code) a LabelField or a LabelArea is returned which depends on the size of the given text. 

Builder pattern Consider the "builder pattern". As I started to pass in arguments to the constructor, it was hard to keep the semantics right. The builder pattern helps the developer to 

state pattern, to represent the different states of the game template method, to avoid duplication of System.out.println 

"I change the state of the view AND ... I return the state of the validation." You already give yourself the answer: Two responsibilities. This is not because of that you combine UI issues and validation logic in one method. It is because of "and". Effectively you have two results out of one method. And this is a violation of SRP by itself. The more important thing is: you coupled things that should be separated. The UI should be informed in an abstract way, for example with an observer pattern. 

General First I appreciate your approach and exercing OOP as it is the most natural way to put reality into a model and final into a program. I already noticed this question at an earlier state. As I am thinking this is going into the wrong direction I want to butt in. Listener Pattern Your listener pattern is not implemented in the standard way (TankStatusListener). Your WaterTank should have add(TankStatusListener) and remove(TankStatusListener) methods to manage objects that are interested in status changes of your WaterTank. The listeners should NOT given as a parameter(getWater(.., TankStatusListener)). The listeners that are added to the WaterTank should be notified after the status change. It should look like this: 

Further steps Your solution parses and interpretes incoming data and processes calculations. This is best addressed with the state pattern and the interpreter pattern. This is an advanced technique you should have in mind when you feel ready for it. 

You currently managed 1. and maybe 2. and you scratch at 3. But you are totally stuck at 4. Sometimes programming language mechanisms are overwhelming and it is difficult for beginners to apply them properly. As you are using Java I guess you want to apply the OO programming paradigm. So that will be my assumption. I have to say I had a hard time to figure out what this code is doing. And I think I did not get in in the whole until now. Without to insult but this could be considered as spaghetti code as input can happen everywhere and output can happen everywhere and the control flow is hard to grab. You mixed a lot of concerns while they should be better separated. You have global variables and less meaningful names. Identifiy responsibilities For each element in the usecase "Calculator with history" you should have a proper representation, a code fragment that is responsible for exactly one task AND is able to provide inner consistency (isolation and encapsulation). The general responsibilities in every program: 

There is only one thing I considered as recognizable: the dolphin among the fishes. I really recommend to handle the artefact "userCanJoinAndLeave" in the method that is calling the method "getDatePeriodtext". It seems semantically anorganic here. This relates to the single responsibility principle. Be careful with multiple return statements as suggested. They hinder you to apply refactorings like "extract" method. But in this case it may be no problem at all. I also recommend full (metal) brackets ({...}) in general. The code is trivial. So no real issue here. After playing around I came up with a totally different structure with less null checks and less string redundancy. Do not take this too serious. But maybe you get the idea. 

Then we can instantiate the stream with the "elementJoiner" as an element supplier AND the ElementSpliterator with the handle to identify the stream end. 

First of all I see really nice approaches in naming your artefacts (classes, methods, parameters, vars). Furthermore you master the first step of programming: algorithmic thinking. As you have thought of naming you figured out most responsibilities so you followed the single responsibility principle. Yes, there are some things to improve. But I see only one real big issue: the intention to implement hashcode and equals. Hashcode and equals I'd like to address hashcode and equals as there are intentions to implement them. If you do so you may have strange effects in the future. You can easily see what happens if your equals and hashcode methods base on length and width (and I guess it will) of your Chocolate: 

Evaluate all possible situations You can now easily provide a Set of possible winning situations to evaluate the winner. 

Maybe you have to think a little bit more about the caching scope. It's not that easy because most developers tend to simply store expensive objects near their first occurance. My advice is: NEVER cache at the first place. ALWAYS formulate your statements as they are NOT EXPENSIVE. After that you can go on with an optimization... ... that should be transparent to the existing implementation ... and has a well defined scope to match the use case requirements