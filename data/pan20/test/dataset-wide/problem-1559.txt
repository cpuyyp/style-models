Usually it does not matter. But sometimes it does. If you get in the habbit of using prefix increment then you always use the optimal version of increment. Prefer '\n' over std::endl Don't use return 0 in main when it can never error. 

In Again more white space needed. Again tabs/space problem. In your printing functions. Rather than serialize to std::cout. You should probably pass a reference to a stream onto which you want to serialize the tree. The method custom print should probably be re-named . 

That is too easy to be confused with . Please put it in a namespace and the very least. I would actually create your own stream class (one that can be locked) and pass that as the output object to the constructor of your class. Thinking should sleep It take times to think. It should also take time to think. 

The copy assignment operator has the semantics of doing move assignment. I don't think this is a good idea. You might get some surprised people that don't see that coming when there Memory object changes under the noses when they do an assignment. I would convert this to a copy operator and then create a move assignment operator (don't forget to mark the move assignment as noexcept). 

The cost of passing an object of type around is the same cost as passing a double around (so you don't really need to worry about that). 

Yes I can see what you are doing. But will everybody! Casting a to a stream (not correctly by the way). Then reading the value from the stream into limit and checking that the read worked in one statement. Unfortunately you got it wrong. But it's still a valid statement. What is happening here is you are taking the pointer and shifting the bits of the pointer right by limit (currently undefined). The resulting pointer is then cast to a string stream (creating a stringstream object). This is tested with the and since you have not read from it will always return true. This is a good point to advertize that you should increase your warning level well beyond normal. All warnings are logical errors in your thinking. Your compiled code should not generate any warnings. I think the minimum warning flags should be: 

Declare them as close to the point of use as possible. This becomes important when your types have constructor/destructor (as they execute code). But it also makes the code easier to read as the type information is close to the usage of the object. Please declare one variable per line (easier to read). 

It may give up the core for another thread (temporarily). But it will come back just as quickly to check for more work. So I am not convinced this actually buys you anything. I would use a condition variable and block threads on it while there is no work. Then you know they are not taking up any cycles when there is no work. When creating the work package. 

Design Memory Allocation A string function can either allocate a new string and return it or return a modified version of the original. Your function CAN NOT do both of these. This is because we don't know if the returned string is returned with ownership or not (ownership defines who releases the memory). 

I am not convinced that calculating and saving all the powered values is going to save time. Also you don't need to save the same result four times. Rather than have and and and have a single array . It is the index into the array that is important. Also don't manually allocate this space with new use a . The question is a memory lookup faster than or slower than doing 4 multiplications (or callling std::pow(x, 4)). That is something you will need to time and find out. 

Have a working version of MySQL implementation of ThorsSQL library done. If you want to check it out you can find the whole thing on github ThorsSQL. This is a follow on to previous code Reviews: Part 3: Layer 1 Part 2 Part 1 The documentation for these classes is here: Part 3 (Layer 2): The MySQL Implementation MySQL uses a package based protocol. Each request/response message is wrapped in a set of packages. These packages are numbered and sized to allow validation and some basic error checking of communication between the client and server. The class PackageBuffer implements the PackageStream interface; but it is used to wrap a Layer 1 stream thus hiding the packages from the next layer and still exposing a simple stream like interface. 

Declaring arrays like this is not valid. It is C functionality. your compiler is letting you get away with it but not all compiler will. The size of the array must be static and known at compile time. If you need to dynamical size arrays then use std::vector 

Your usage of the condition variable will probably work but is a-typical. This is what you basically have: 

In my ongoing attempts to become a better blog writer I have some written some more code that needs reviewing. Full Source: $URL$ First Article: $URL$ This is a simple C++ wrapper for Sockets. Here the bit I am not 100% happy with is needing to introduce a Socket.tpp file to hold . This is because the function is templated with a callback function that is used to decide if we have read enough. This is not used by the (in Version 2) but will be used by (in Version 3). Socket.h 

I would use here. So that it is easy to spot and you intuitively know that this is a dangerous operation. 

Here you are exposing the cards. Thus allows the internal state to be changed. This is a no no. Lock up the interface only allow the state to be changed via a very specific closed interface (also note you are locking yourself to vector). 

I think not. I agree it should be but that is not something you can guarantee and thus your code should not guarantee that it does not. So this should probably be: 

C++14 Its 2014 most modern compilers now support C++14 so you should use it. This code is still very C++03. For this class this simply means adding move semantics (and nothrow on swap). To add move semantics you need to add a move constructor and move assignment operator. 

Ahh printing and recursion. In all the other places were you have a nullptr. You print , but not for the root node. Which means an empty tree prints nothing. This seems a bit inconsistent. I would make it print for the empty tree. Also you are not passing ownership around. So don't pass the smart pointer. Pass a pointer to the object (normally I would say reference but in this case we can have nullptr). 

Protected provides no protection (it does but it is an illusion that is easily pierced). Prefer to use private (especially in this case). By using public/protected you are including all these members in the public interface (this is an OO concept not a C++ concept) of the object. Anything in the public interface must be maintained in the future thus tightly binding you to this implementation. 

Types have to be known at compile time. Unfortunately to be flexable you need to look up arbitory types at runtime for a DB. So either you need to use some form of template-meta programming or you can use a variant type. I would go for something like boost Any object or boost variant this will allow you to return arbitrary types. I don't think you want to return the result from the DB after creating the Query. You want to return a query object that will allow you to bind things and execute the query at a latter stage. This is because in most DB systems creating the query is relatively expensive. And when you do execute the query you want to use the concept of the cursor (iterator) to move over the result set rather than generating the full result in one go (as this could potentially be huge). 

It is also an anti-pattern (in all languages). The problem is that is not doing what you think. When you read a file it stays good until AFTER you read past the end of file. The trouble the last successful read will read UP-TO the end of file (but not past it). So when you have read the last line of the file (ie there is no data left to read) still returns because you have not read past the end of the file. This means you enter the loop and try and read a name (this will fail) and set to and thus to but you still increment . To fix this you should always test that the read operation worked. 

Overall that seems needlessly complex. Design You return a value object even if you don't find the key in the tree. That seems funny. Especially since you must construct the value using the default constructor and thus your value type must be default constructible. Most containers when you search them return an iterator. If the object is not in the container then it will return an iterator that equals so that you can check to see if the value was found. Code Design There is no need to expose . This is an implementation detail that you leaking to the user. You should hide this and make it a private member of the class. When adding to the tree you only use copy semantics (on the value). You should look at using move semantics (on the value) to make the code more efficient. As a side note: because you use your tree itself is not copyable but is movable. Is this a desired trait? Must containers are both copyable and movable. Side Note Note all the methods in are used. 

Not sure that should really happen. The interface to should be how you manipulate the object. Needing to convert the object to a circle seems unnecessary in most situations (you should probably have virtual functions that do the actions you need). Sometimes things have unique actions then you need to convert them back.But in these situations just use dynamic_cast directly (this also shows you are doing the conversion very explicitly). Based on comments below: 

Fortunately all your global members are const so its not a real problem. Don't passs by value (unless it is a small POD object). Pass by const reference to achieve the same result. If you need to mutate internally then you can make a copy at that point. SO 

You are not being payed to conserve vertical space. You are being payed to make the code as readable and maintainable as possible. You need to pick a brace style and be consistent. There are a couple of styles out there (I can't argue that any one is better than another). So just find a style you like but then by consistent when using it: 

Though not technically illegal. This becomes a maintenance problem. It's OK for you today as you just wrote the code. But for anybody else (or you in years time) this is can be a pain. Try and give your variables unique meaningful names (self documenting code is a brilliant practice but it requires variable names to be meaningful). The whole loop where you search for the largest repeat: 

Identifiers that are all caps are usually reserved for macros. Identifiers with an initial cap are usually user defined "Types" Identifiers with an initial lower case letter are usually objects. 

And I prefer to put the statement the for loop is going to run on the next line so it is obvious what is happening (but I am not going to care that much about it). typedefing a structure is not needed in C++ 

The trouble with the socketaddr_in type is that a lot of the data is unspecified. So you need to make sure you manually zero the whole structure before you use it: 

If you want derived classes to modify the class you may need to think of something else. But you have not provided enough context for me to go further. Iterator Based on comments just showing how easy it would be to throw an iterator together that can be used without exposing implementations details. Note: this one is not complete but shows enough of how it would work (and I was slightly bored at the time and wanted to write some code). 

The streams library already discards spaces when used correctly. Also the ';' at the end of the for. This is considered bad practice. It is really hard to spot and any maintainer is going to ask did he really mean that. When you have an empty body it is always best to use the {} and put a comment in their Here you are basically lower casing the string.