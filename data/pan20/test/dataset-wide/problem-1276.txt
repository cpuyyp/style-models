This is honestly pretty good. I usually use to set the paths and configurations on require (it's going to grow a lot as you add things like shims, urlArgs, etc). You will also probably want to reuse it in several places. See my blog article on how I recommend doing this. The general idea is that you don't use to bootstrap things, you instead have a request for the configuration file and another to actually bootstrap the specific page of your application. Next, I'll ask why bother injecting and manually into ? Injecting dependencies is what RequireJs already does. app.js 

** The above code is untested but it should be enough to get you on the right track ** Feel free to ask questions in the comments area 

Ever since LINQ came out I've been talking about how the syntax is really awful. It looks friendly at first but it completely hides what is really going on which is really useful to understand. Here is the much shorter way of writing it with the extension methods off of IQueryable along with a few other adjustements. 

Php I'm not a big Php guy so I can't be too thorough in this section. The biggest thing is that you seem to be writing ... well ... a php script. While that absolutely works it's incredibly old-school and doesn't do anything as far as guiding you into the pit of success. So first bit of advice: use a framework. At time of writing, the two I've been hearing most buzz about are Laravel and Codeigniter. This is constantly changing but just pick one which you've heard about and use it, that will help you learn enough concepts to make an educated choice next time you need to select one. Second, at the bottom you seem to have some invalid php. You have some missing braces in that if statement toward the bottom and it has two clauses in a row. I'm not sure if that will cause an error but it will definitely never run the third clause. Finally, your design leaves open a huge security hole if the site is ever opened to the public. You accept the message as an input parameter, much worse, you accept the email. Think of what happens when someone does a query to and again, and again. Spammers love finding unsecured services like this! A much better approach is to have the emails (and maybe message) stored on the server already in the database or a text file. Then you could supply parameters like indicating "email the person with id=1". Having this behind a login page is not a (good) defense either. Someone could easily put the above url in the src of an element and every time someone who had recently logged into your site visits a page they put that on (like a comment or forum page) you will be sending spam! To defend against this make sure that page does not accept the Http GET verb (in this situation POST would be appropriate). This is exactly the kind of error that a framework shoudl help defend you from. Finally, I see what you're doing with the ajax flag but that's not the typical thing to do. Whether the operation succeeded or not should be determined by the returned Http code (200 for success and maybe 400 for error). Whether you should be returning json or html should be determined by a concept called content negotiation. This is again, something that your framework should be handling for you. Html is not a valid attribute for the element. But also don't put ids on things unless you absolutely know there will be only one of these elements on the page. The spec says ids must be unique across the page and lots of javascript libraries cause errors when the assumption is broken. In this case can you guarantee there will not be two elements on the page at once? What if you have 2 offices and each one wants its own contact form? What about elements with or ? A better approach I think in this case is to use a class. That is not to say that you should never use ids but in most cases the benefit isn't worth the risk. Next, you don't technically need , it's optional but submit is the default behavior. Finally, I'm not 100% sure of the spec for but I don't think it works by associating the label with the following . Instead you have to use the attribute and s (which I've already argued is bad). Or do what I recommend, something like: 

For a first try in Scala, this code is a nice attempt. There are not so many rudiments of imperative style programming, which are usually frequent. It is also quite concise and structured, which produces a good overall impression. However, there are of course a few things to adjust and to improve. I'll divide them in two categories: 

"0 is less than or equal to X AND X is less than or equal to 1" Which approach is better for understanding? Naming The function names and are simply too vague in . Their current role is access and changing pixel color values, so their names should reflect it: or . is neither very appropriate. Its role is to choose a pixel and fill it with a calculated color. Shouldn't it be named instead? Also avoid duplicate names with underscores like and in . First, the underscore is not conventional; second, the purpose of the reference is not clear. Should it be called or or other? Design Issues I think that there is a mess about the core part of class, concerning coordinates and colors management, and in function. 

Once this initial refactoring is done, it would be much easier to understand how the entire thing works and to review the details. 

But I'm not sure that from the point of view of design it's a good solution, because it looks like a violation of LoD. There should be a better approach to solve it. 2) the calculation of should be moved into a separate method, which will allow to eliminate the last remaining in this part of code. 

In the condition of the same method, is usually a better choice to check if a collection contains something, than . Loops & Comprehensions Consistency There are weird differences between loop definitions that are supposed to do similar things. Just be consistent, use either or , but not both. Semicolons are very bizarre at line start and indeed are not necessary. The comprehension produces a collection that can be directly converted using , no need for additional varargs conversions: 

Finally, you might want to check if returns null and maybe log a warning then as that function returning null would cause a cache miss every time. Now to answer your specific questions. 

As for similar methods, as you start to understand the above format you can start to understand lambdas and expressions, you don't have to understand them very deeply, but you can learn that they are simply another syntax for creating certain types of objects. Therefore you could refactor to this (using a refactoring plugin like CodeRush/Refactor Pro or Resharper will help immensely): 

You can get really far cleaning this up by just creating some private functions and bumping them to the bottom of the file so that they can be hoisted 

Usually I see tuples in js implemented with arrays though of course an object - while annoying to write would be just as valid: . So for this sort of use-case (creation and light usage of a bunch of temporary objects) I'm curious if there's a significant performance difference so I set up this jsperf. Object tuple test: 

As mentioned in the comments the question that you are asking is actually off topic as you have not implemented it yet and there are many solutions (you could for example do everything as percentage or vh/vw units rather than pixels). What you're asking for is a concept known as responsive design. I will however review the code that you have. First problem I see 

One comment on the code: you will find your constructors easier to maintain if you use constructor chaining protected BaseCache() : this(Guid.NewGuid() ) { } Now my possibly ignorant comments on other things. 

I think that the second implementation of the function is the most readable and concise. There is just the name of that should be changed. is too vague, would be more concrete. It's probably a matter of taste, but the first implementation seems to contain too much nesting (parenthesis and braces). The third implementation looks also a bit more complex than the second, mostly due to the mechanism of . By the way, I've got two suggestions that may slightly improve this code. 

In , instead of using a try-catch block, it is more concise to use on the test method that invokes it. The call will neither be necessary in this case. 

Language Issues DRY It The three functions of contain boilerplate repetitions of instructions like or . Dedicated shortcut functions can be created in order to reduce number of arguments and chained calls, for example: 

This allows us to have more flexibility for the implementation of the builder part. Returning a from each chained method in the builder looks like a waste: there will be many instances created uselessly. More traditional approach is to return the same instance of the builder object. Since we suppose that there will be more than one builder, we can imagine an abstract layer which will do most part of the work: 

Put constant parts inside the pattern, leave formatters only for variables, e.g. . Args in are usually used for variables. Use a to build. 

computePersonality Your main concern. There are too many repetitive . The personality type letters can be extracted into a constant matrix, for example: 

(or ) is invoked behind the scenes on the args passed to . If the arg is , "null" will also be output. Please note that in Scala, is implicitly imported by the compiler and methods may be used directly. Naming There are some oddities in fields and function names: underscores in names, suffixes like or . I suppose they have useful meanings, but this sort of naming is against Scala naming conventions: 

My comments are inline starting with the . I also very much encourage you to look at async libraries such as Q. 

Since this is a public method I added some checks and downcast List to IEnumerable, which is a looser contract and all you really need here. By the way, .Net naming conventions are pascalCase for private and local variables CamelCase for public and protected. It's rare to use underscores. 

A direct answer to your question: Just remember what dropdown controls have been initialized and hide those. 

For the above reasons I would recommend against using this as a general utility function. However, if this is going to be a specific utility (for example you're trying to create a simple data-binding framework where you know you won't have to worry about the above) this might be the rare legitimate use of the controversial with statement. 

In short. No. The mapping between object properties and fields on the form has to be somewhere. What you could do though is to set it up by convention. So if the field on the form had the same name as the corresponding property on the object you could use reflection (or a tool like Automapper) to do that shifting. In pseudo code (because I don't have a set up .Net environment in front of me right now) it would be something like: 

Seems to even work when wrapped in a . That being said, you might have legitimate reasons to want to test for this but I can't think of any. Edit: Added check for 'other' window. You could probably add some finagling to check that eval isn't a stub that always returns . So if it returns true for example you could generate two random numbers, add them together, and then pass them into the eval string and have it add those numbers and confirm the result is indeed accurate. Let's be honest though, that's stupid, if someone wants to trick you that bad, they'll find a way. 

I think that both approaches are incorrect. Why would you need to cast an object to its own type, while it is already typed to a type that inherits from its parent abstract type? The method is absolutely senseless, because if you have an instance of an object, it is typed by definition. 

Some more observations (excluding the nice remarks about the interfaces). Naming: and are excessively long names, why not just and respectively? toString(): patterns such as look like if they were written in Brainfuck. More readable alternatives are: 

Moreover, your method may then go directly into this class, named something like . The loop in would look like this: 

The Consumer The nested try-catch blocks look weird and useless. Since and throw exceptions, they may be caught in the outer catch block. 

Omitting dots for function calls and parenthesis for arguments are not among the recommendations of the official Scala style guide (sections Arity-0 and Arity-1). This practice can reduce the readability. For example, I find that and are easier to perceive for a human-shaped reader than the respective expressions in the original code. There are several occurrences of that can be extracted in a small helper function like . This will allow to transform the respective instructions into more elegant, for example: . But since among the three functions only one will be chosen/used, this will eliminate the duplications and the relevance of this remark. 

First of all, the readability of this code is OK. Entities are quite well structured and an effort to respect the SRP principle is seen. General Design However, I would suggest a few renaming and design changes. The class resembles a factory, because it instantiates the business logic entities ( or ). But also it chooses which one to use and triggers the main action: this is too much for it, so let's separate the roles. We can introduce an interface that provides access to the main action: 

I realize that breaks with the "single point of return" wisdom but I'm not a big fan. When you have small functions like this one, it doesn't make all that much sense. Refactoring step 2, with that cleaned up it's easy to see how this fits into a simple LINQ query 

Speaking of which, the class is probably not the best named. you could imagine making a diesel-punk version of this where you use border-radius to have round (not boxy) spaces. Instead name it for what it is. My recommendation would be I'll stop short of saying that you should avoid ids altogether but only use them when you're really really sure that the element is the only one on the page with that name (including any other components built from composite uis). Next - this is a bit of personal preference but I think you're overusing divs. proper html elements can give good semantics to your document. I would probably structure the stuff as since these are part of a series. Other valid possibilities might be (as in article of clothing NOT a blog post article) or elements. I would also say you can make this significantly more lightweight by using a javascript templating framework like Handlebars or a an MVVM framework like Knockout or a full javascript framework like Angular. Your mounds and mounds of html will then collapse down to just a single definition. Runway probably doesn't need to be an element at all. You can probably just tag the the appropriate class (like ) and use css3 gradients to create that stripe. 

I absolutely agree with @Schism that more context is needed for a really good review but I made a few other observations inline. One that also jumps out at me is this whole relationship between and how you're selecting by name. Without more context I can't say for sure, but it seems like maybe you can have with the name being the key and that would make everything much simpler. You do need to think if sounds need to get disposed of or what happens if you invoke a method for something without a name, or if there's two things with the same name. Also, as always, I'm going to go ahead and say the prodigious use of here is probably entirely unnecessary and you can just use a factory method instead of a constructor. Also, it's 2015, can't we just start using es6 already?