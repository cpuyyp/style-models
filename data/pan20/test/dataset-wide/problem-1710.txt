I've got a Windows 2003 Active Directory infrastructure, and there are times (such as when terminating an employee) that I want instantaneous propagation across both of my AD servers. Currently, I make the change in both places, which I suspect is unhealthy, but it's the only way I know to make sure that the account is disabled to every machine. Is there a better way? Do I have to wait for the normal propagation time for convergence, or is there a way to "force" it? 

Which filesystem was it formatted using? Have you tried fsck -Vr on the device to see what it says? If it weren't 6TB, I'd suggest making a backup image using dd and gzip, but I doubt you have the external storage to do that. Good luck. 

The best practice might be to use sudo, and modify the necessary files to make sure it happens automatically without being prompted for a password. If you don't mind the password being in the script, I think you can do something like 

I would start with monitoring. If you're having intermittent problems that don't go away on their own, but rebooting solves it, check your resource levels. That's a sign that /something/ is expending your free resources of some type. 

You're describing a valuable service that, as far as I can tell, isn't saturated with companies jumping on the bandwagon. The closest that my searches have come is LogLogic ($URL$ Maybe you should talk to a representative there to see what services they offer. You might find what you're looking for. 

The magic here is that the -perm flag (for permissions) can take a / preceding the permission argument, which causes it to search for a logical OR on each of the bits. From the man page: 

This is really pretty easy to figure out. Find out from the reseller/manufacturer of your fibre cables what the maximum bend radius is. Then find out how far apart the cable runs are when the arm is fully folded shut. If the cable runs would be closer than the bend radius, then you can't run the fibre there. $URL$ 

Have you considered any of the tools from Solarwinds? They're all Windows-based, so I haven't gotten too much use from them, but they looked pretty impressive when I played with them. $URL$ 

RAM is definitely faster than disk (if you need details, check numbers everyone should know). If you have the memory available on the webserver, you can make a RAM disk. If you've got an array of systems, maybe something like memcached would be better. 

I don't throw them away until I'm not using any servers that have that specific model of trays. The reason is that once you throw them away, it's nearly impossible to get the parts from the mfg again without purchasing drives with them, so you're essentially at the mercy of Ebay or craigslist to get the parts you need. That's never a good situation. 

If you open your IIS manager and browse to "Web Service Extensions" under your server, do you see "PHP ISAPI" in the right pane? (from here: $URL$ 

Where "whatever" is obviously the device. Probably sdb. 1 is the partition that you just made. It shouldn't have a problem making this physical volume. Now, run 

You can run a hypervisor and resell virtual machines with dedicated IPs, in addition to several other suggestions in this thread. 

I do not. My argument is that they impede airflow, and that there are better 3rd party cable management solutions that accomplish the same thing. I can count the times I've wanted to leave a server powered on while I was adding or removing hardware on 0 fingers, and that's their only^H^H^H^Hmain purpose. Edit I admit, they make it faster to pull hardware out of the rack, but in my opinion, it's not worth the hassle and heat. 

I used to have a very handy poster which had all of the Cisco equipment in matrix form which laid out which router had which interfaces and slots, with the same for the switch lines. Is there a web-based equivalent of this? It would be very handy when trying to decide which networking equipment I need to buy. 

Here's a quick rundown, but a screen tutorial will get you farther: 'screen' invokes it, and you use ctrl-a then d to disconnect (and leave it running) 'screen -ls' lists open sessions 'screen -r' connects to a disconnected session. 'screen -x' connects to an active session (if you want to run two terminals at once) Here's a screen tutorial: $URL$ 

From what I can determine here, "Interactive User" is almost but not entirely like "Local Service". This discussion may also be interesting to you: $URL$ I'm voting to close and move to stackoverflow, where I suspect you'll get much better answers. 

Why is everyone giving the wrong answer? It's called a scissor lift: $URL$ They make servers that are hundreds of pounds. Lots of storage arrays are far more than that. There comes a time when you don't want to rely on hands that were, most likely, just reaching for greasy potato chips. Use the actual tool if server lifting is an issue. 

I would suggest that as soon as databases start taking up enough of your time that you can't get your work done, you might consider it. Try to get a DBA with a multi-discipline background, so that they have something to do besides sit around and wait on the DB to break. 

Now, when I start the VM, it immediately tries to PXEboot. I turn off the machine, and in the vSphere client, I edit the VM's properties, go to "CD/DVD drive 1", and verify, "Device Status" has a checkmark next to "Connect at power on". Here's the crazy thing. When I uncheck that box, then check it again, then start the VM, it boots from the ISO. I've done it again and again, with the console open, with it closed, and every time, I can set the StartConnected flag on the CLI, and the GUI reflects the setting, but only after I mark the checkbox manually does it actually boot from the ISO. Is there a step that I'm neglecting to perform in PowerCLI to get this setting to "take"? 

Have you sniffed for arp traffic to see what's being sent out, and from where? That would be my first step. Maybe it's screwing up because the other machines are sending advertisements. Whatever you find there would lead to your next step. If you have evidence that the other machines are sending ads, login and check the network config with a fine tooth comb. Virus scans all around. Look for more strange traffic from them. If there are no advertisements, but it still changes the arp table...well, come back and let us know, because I've got no idea. 

I wholly support this methodology if you're doing it for forensic purposes, and to learn more about the virus, and perhaps as an exercise to determine ways to examine deltas in virtual machines. If you're doing this from a "I want to recover my server from this virus without reinstalling" standpoint, then you should re-examine your goal. I don't know a better way, so I'd do this the hard way, where you get the system to the point you want before the virus is introduced. Then you boot in with a Linux cd and make an image of the filesystem using 'dd'. Then start the machine back up, introduce the virus, shut it down again, reboot with the CD, dd again into another image, then mount the images readonly with the noexec mount option and then write find command that would run diff between the filesystems one file at a time and output files which are different. Now, some caveats. First, because this method is so bad and so slow, there has to be a better one, but I don't know what it is. Second, there are going to be some false positives. Windows writes to the registry all the damned time, so the registry files will be different. So will any config files that have been changed, any updates that started downloading on their own, etc etc. It might actually be that you could use find -mtime to get the same data, then run diff on those files that have changed. Since you're in Linux, clamav might save you some time, as well. 

Logging in with all caps $URL$ hrm. I fear I may have misunderstood the question :-) But I'm leaving the link, because I find it interesting! 

I don't know how to do it the way that you're configuring it, but I know that Likewise Open did all of this for me. It makes it extremely easy to add domain users into local groups, and UID/GIDs are a hash, so they're identical across all of my authenticated machines. I can't tell you how amazing it was to finally have it just work.