Some test frameworks require all test methods to be prefixed with "test", but when it's not required (and the presence of attributes clearly shows that it's not handled by reflection), there's no point in doing this. It restates the obvious, serving no other purpose than to add noise. 

Looking for an element and finding out that it's NOT present in the collection IS a successful operation. Just because an operation renderered a negative answer doesn't mean it failed. The purpose was to find this answer, and this we did. Encapsulation I don't like that is public. Wouldn't a more restrictive visibility modifier do? Rendundancies As I pointed out before, after a is always redundant. 

Prefixing a string with an empty string makes no sense. (I know what trick you're employing, but "/" does that for you already). 

Again, is it worth it? Sometimes the clever thing is not to be too clever, and keeping it simple beats trying to make it pretty. 

Error handling or the lack thereof. Sending an email can fail for a variety of reasons, and you don't handle exceptions or failures. In you're sending emails in a loop - what if there's 10 managers, and sending it to the second one fails badly, shouldn't we try to ensure that the remaining eight would still receive their notifications? You don't handle edge cases either (such as an inexistent recipient: it would result in a once you tried to retrieve from a null , if didn't contain any entity under a given id). 

Do you plan to extend this class? If not, I would mark it as . Given its nature, inheritance can open a Pandora box. 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

This bit repeats several times. I would encapsulate it as a private method (?) to avoid code repetition. And as a side note, I don't really see any purpose in , it's just clutter. Clear the collection anyway (even if it's empty), I wouldn't expect much of a performance boost from this check :) Benchmarking This is weird to me. You're setting in : 

Beware of a lesser known gotcha. This may not work as expected for that's not "really" a (it's not in s inheritance tree), only has an explicit cast operator defined allowing it to be casted to . In that case while would return a instance, won't even be called because your check would prevent this from happening. Other than that, I'd have some remarks related to naming and code style (rather subjective, so treat them as suggestions or food for thought more than claims your code is incorrect) 

This name is off as well, it doesn't check whether the input string is alphanumeric, it tests whether it only contains '-', '.', ' ', 'Ã', '©', '¡', '­', 'º', '³', 'Ã', '‰' or '_'. Do we need case insensitivity here, but not in ? Or is this discrepancy accidental? If it's not deliberate, then I'd implement case insensitivity in directly, and get rid of . Inconsistent parameter naming - other methods accept , but this one takes an . I'd drop the "str" suffix - it's pretty clear this is a string value, no need to revive the infamous Hungarian notation. Finally, there's some code repetition here - this bit: 

Who would have thunk! Not too informative... In contrast, this code doesn't comment the non-obvious stuff. For instance, now your class has a certain policy regarding nullability - which, as I said, is by itself an improvement over the previous code, where this policy was sort of accidental. But is it obvious that throws an exception whereas is ignored? I wouldn't have guessed that correctly, and yet the documentation doesn't say a word about it. It's too busy telling me that element is element. By the way, it's not just a question of documentation - I'm not sure I like this asymmetry in principle. And it isn't the only inconsistency lurking in the implementation, either. For example won't crash when the list is empty - but will if there are already elements in it. What's the rationale for that? :) That's not predictable behaviour in my book. Speaking of , this comment is just plain wrong: 

This being said, it could be overengineering for simple cases. It's hard to say without knowing broader context. All info you've provided is that there's 5 cases, which is quite a few already, and it makes me guess there's a chance for more to come; if all I knew was that there's 2 or 3, I would say keep it simple. 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

This is nitpicky now, but I would change the order of these assignments. Because If throws an exception, the object will be left in inconsistent state. Again this is a consideration for easier debugging. 

I'll admit to being new to this concept, and can't think of a real-world application for this method. Regardless, here's my thoughts. Issues #1 and #2 are directly results of your use of Object.Assign which seems an acceptable limitation. Issue #3 is stating a fact of how Object prototypes are set up. The prototype of Object.prototype is by definition null, so #3 is technically a given. However, your questions make your meaning of #3 more clear. 

Your comments are excessive. Commented out code helps no one. If you remove code and want it later, that's what version control is for. Your method is too long. You should break it into smaller pieces. Use loops instead of very similar repeated code for instance: 

Do not use multiple statements to check the same variable. Either use an block or You do not have to post all of your project, but you should at least post pieces that are whole. If we must go to a separate site to even properly review what you posted, it probably isn't going to happen. 

There's not much here to optimize mostly because there's very little here. A few things you could do: Store your selection to a variable outside both functions (bad idea if you may have multiple notificationDivs). 

Not if I understand what you're doing correctly. So essentially each image has itself, and then some other element that should be before it as a buddy? Assuming they are all siblings, you should utilize some of jQuery's functions that support working with siblings. Here's an example, though I'm sure it could still be better: 

Not a full review, but: is completely unnecessary. Because Data will be null if you didn't set it within the If portion. Just add an to the previous if and have it . 

I know names aren't hugely important but my 2 cents in addition to having already written some of what @tomdemuyt said (which I editted out): 

Euler2 is a confusing variable name. It has the disadvantage of resembling Hungarian notation, so those exposed to that may read it as booleanIsHigher which makes no sense. Rather than trying to find a better name, you can actually factor out the need for the variable. You get the same result from the following: 

Scope your variables. Change your code to target all instead of one element with the id . Use when events are triggered to make sure you have the correct element. Remove the added elements instead of hiding them. Remember to call using the smallest possible parent container. Possibly a or ? Use short circuiting where appropriate. Use to get the appended elements parent. 

which I would argue is closer to how the fibonacci sequence is actually derived as will always be (n-2) and will always be (n-1) instead of repeatedly trading places. 

I agree with tomdemuyt that requiring this to be used with jQuery seems to contradict your description of it being "lightweight". Most of the code doesn't reference jQuery, I'd look into factoring out the jQuery dependence. 

Did you start out code golfing? Use variable names that mean something. The only variable you used that has any meaning to the reader is . This means that unless you remember, every time you hit a variable you have to scroll up to find out what it is. This almost looks obfuscated. (It's not, but it is painful to read.) I'm not even reviewing the logic itself. You need to use meaningful variable names or no one else will ever want to touch your code. 

For reference, here's the code I used to find that your program doesn't handle intervals the way I would expect. Add a break point at the commented lines and inspect your locals to see what I mean: 

In this code, I'm overriding the sorter and matcher for Twitter-Bootstrap's Typeahead functionality. The reason for the override is to allow state (technically Jurisdiction) abbreviations to be used to match the full state name. I've reduced the length of the source array in this example for brevity, but a full version is available on this fiddle. I also decided to make it so that duplicate entries could not be made. I went out of my way to make JSHint like my code, but I'd basically like any suggestions. This is my first time doing something like this and I'm relatively new with Javascript anyway. The only things I'm not interested in is white space as I simply formatted this based upon JSFiddle's TidyUp function, the css (as I didn't create it), and suggestions to override highlighter as I don't see the need. Note: In production the number of inputs is dynamic, which is why I am selecting them each time. If you need to view the Typeahead source code to understand my overrides, you can download it here HTML for Example 

This has the benefit of treating null input essentially as if it were not provided, which would seem a more expected result. You could still have an error thrown, but I don't see the value. If you choose to have an error, at least make the issue more obvious. "Prototype chains are assumed to be delimited by Object.prototype." is confusing and unclear what the issue is to me. I would go for something like: "Cannot appendToProto of null." In general the error message should indicate what is wrong with the input instead of the codes philosophy regarding what its input should be.