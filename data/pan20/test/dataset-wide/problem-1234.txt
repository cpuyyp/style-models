Indeed, the conditional branching in is quite complex and prone to bugs. This implementation does too many things at the same time: sets the value, determines which calculation method to use and executes the calculation. These concerns should be separated. Each GUI element should trigger only the changes that are relevant to its responsibility. s, when clicked, should define the calculation method to use; should trigger the calculation. Without significant changes to the design of class, the separation of these concerns can be achieved as follows. In order to extract the selection of the calculation method, we will use a simple interface 

The method name looks like a getter. However, there is some logic inside and getters usually don't have arguments. seems a bit suspicious for me. The name looks too verbose: category is present three times. Why not calling it ? There would be no repetition and it is read straightforward. To avoid the confusion with a getter, I also think that it could be named or . 

The builder instance can be extracted into a dedicated reference and you'll be able to apply the common instructions on it only once, for example: 

The three classes are thus removed from the original code. I can also suggest to extract all the nested classes (, , ) to their dedicated files: this simplifies the structure, makes it easier to navigate and is simply cleaner. Update: The arguments to can be refactored with shortcut methods: 

What is done in : 1) we filter the connections to work on with the refactored ; 2) we use the standard function to calculate the sum. It takes the initial value and performs the calculation using the current value in , tupled with each of the filtered s. function can also be simplified using our refactored and : 

The part of this method may be extracted to the super-class. This will avoid repetitions in the concrete classes. Expressions like should be extracted to static constants. They do not need to be evaluated each time the method is called. Remove useless comments like , and others. Validation: constructor arguments are not validated. If , or args are negative? Without entering into theoretical discussion, I suppose that negative values will be invalid in the context of your API. In main(), the array would be initialized better with 

this already begins to look like a testing framework. Now, each test class that plugs the interface will have to implement the test method. Moreover, using generic types (e.g. ) will allow to avoid to have args in methods, but this is optional. Naming and Style 

It is intended to set the value of a pixel at a given coordinate, but instead it does too many things: 

Moreover, other referenced functions (, ...) are flat, so all of the pieces are well kept at same level. Other Considerations Returned values. The return type from seems suspicious. I hope to understand the meaning ( for successful result, for no solution found), but the returned values are hugely falsified. will return an Int only from the last call of , the others will remain hidden. Since the solutions are output into the console, I'd suggest to return nothing from : 

In the current code this looks like a bug: there is a high risk that multiple are created for same date and is hard to ever become in the loop. "Java <= 7" solutions: 1) compare them through string representations, using formatted date output with pattern up to the searched granularity ("yyyy-MM-dd"); 2) compare year-month-day values; 3) ... other multiple inventive ways found on SO. Recommended solution: throw away and use from Java 8 or Joda-Time. Conditions This one 

But for this very concrete and short example of code I would consider decomposing it into patterns as a sort of overkill. There is some job to do about the original straightforward approach, so let's just try to improve it. The input numbers are read several times using the object. They should also be validated, so a dedicated method would be very useful: 

Indeed, I didn't cover it in the initial answer. is not necessary for field, it can and should be transformed to . The reference is never changed throughout the code, but only the contents of the array changes. And I also think that there is no need to expose the array with public access at all. The in also seems disturbing, because it recalculates the maze on each call and returns a new different instance of . Was it really the intention? It would be more logical to remove both and from and define an accessor for cell values at the trait level: 

They should be separated. All JavaFx-related stuff would remain in class and the model would be better described within a dedicated entity. For small applications like this one, there is probably no need to implement fully the Model-View-Controller pattern, but at least model-view separation would be beneficial, bringing more flexibility and extensibility. Don't Abuse of Generics Please look closer at these declarations: 

I think that with this approach it is not mandatory to bind to an interface. The method may even be static. The returned builder references may be either constant or instantiated for each call: it depends on other details. With this approach, building a message will be reduced to this chaining: 

The class groups a huge list of functionalities: it parses different commands ("new", "del", "connect" etc) and queries, executes them, produces output et alia. It looks like it is very much against the SRP and is just not easy to navigate into. I'd suggest that each definition should represent a dedicated class outside . All of these functionalities can be grouped within a shortened version of interface. Indeed, according to the current code, its arguments and represent one thing: the input and its split. So having 

It should be named , because in the current implementation it returns only the files with names matching the regex and all the directories. By the way, it is not very clear why the directories are put there. The implementation of this method is correct in general, but is coded entirely with before-Java-7 style. Indeed, would be a lot of help here. First of all, there is FileVisitor interface. Using a SimpleFileVisitor prevents us from pre-calculating . It also solves the problem of files with same names in different folders: 

These remarks do not answer your initial question about the type safety of the solution. It's too early to answer it before fixing many of the critical issues. 

should not be caught, because it is wrapped in yet another . Is it useful? The messages in are not informative at all. The type of the wrapped exception is known anyway, so the messages should be changed or removed, to have simply . Law of Demeter Multiple calls like 

By the way, catching of type might be a bad coding practice, but I'd not discuss it here because the context is not enough to judge. invalidateVarnishCache The only purpose of the try-catch block in the original code is to trace the using a hypothetical commented logger and then re-throw it. I doubt that the block itself is useful, because exactly the same exception is re-thrown and must be handled somewhere among the callers and even probably also logged by them. Wouldn't it be redundant? Concerning the , the problem is that it is a and the caller can miss to handle it properly, with hardly predictable consequences. I don't know what is the range of response statuses that this sort of proxy can return, but your implementation does not make distinction between 4xx and 5xx codes, which may lead either to a client-side error (your request is invalid, 4xx) or to a server-side error (5xx), which is semantically close to an I/O exception. For the latter, I can suggest to wrap the response message into a and re-throw it. For the former, it's still up to you to decide how to handle it, probably just logging is enough. 

Otherwise, a test failure will produce the message "false was not true". And of course, if you choose to extract message builders in separate implementing classes, there should be separate test classes corresponding to each builder. 

Args Validation It's also a good idea to validate method arguments, but I think that is not really appropriate here. The checks like 

When checking them a bit deeper, I saw that this approach just reproduces some math expressions like , but at a first glance with a human eye it might be just confusing. When reading a boolean expression, we are more likely to expect the variable part to the left, like this: 

Clearly, it is not very friendly with the SRP! Another question is why does it check if the pixel is already filled and if the color is available? I think that this validation should be produced outside. Colors and Coordinates The dedicated s for possible colors and coordinates look heavy, especially in the context when they are iterated, mapped or sorted on each call in different implementations of function. What improvements I can suggest: 

BUT! Indeed, there is no need to keep the function. The calls between it and introduce too much of complexity. The problem here are the parenthesis for and it can be solved by making a distinction between the root level of the expression (where they are not necessary) and all levels below it (where they are to insert). So an ordinary recursion and an additional boolean parameter to check for the root level will do the job: 

is called before crawling the files in a directory: it corresponds to the original code under condition . wraps the main logic of producing a hash for a file, under in the original code. The size of the byte buffer (2048 here) can be adjusted: try to play with different values to see whether the perfs change. 

First of all, is not an appropriate choice of functional interface for this purpose. implementation should receive an instance of and return an instance of (although and still can be of same type). If there is no incoming type, this looks like a . If there is no returned type, it resembles a . If there are no types to specify, can be used, but it'd better be kept for its initial concurrent usage. So a dedicated functional interface can be created to solve the problem: 

2) It looks like you are using JPA. In a Spring repository, you can achieve the same result by using , without detailing the implementation: 

I hope that you are allowed to use Java 8 in the project (anyway, nothing is said in the original question about the version of Java). The same goal can be achieved with almost no ugly branches. The idea is the following: 1) use stream operations in order to obtain the references to all existing files; 2) extract the entire routine of class loading and instantiation of objects into a dedicated method; 3) fill the Map with these instances. In the example below I skip logging instructions. They can be easily added where necessary inside the lambdas. 

method seems to be a bit outside the principle of its fellow opposite . Why does it take a as argument? I'd expect a here also. Although is now a functional interface, it is more often associated with multithreading than with functional style. And if the intention was to use its threading abilities, the call in the method body is incorrect. should have been used. Another remark, much less important. Since this wrapper class is very short and has only one field, there is no much sence in hiding the one-arg constructor allowing only the builder method publicly available. Both may be left public. 

Yes, there is no magic and it is equivalent to double/nested for loops. As I already mentioned, when we have 

Here I suppose that member of this class can take only a predefined set of values (and even should be transformed into an !) and any value that is not in this set denotes an internal problem that puts the application into an invalid state. BTW, since the original method is , I suppose that is also a static member and therefore should be renamed according to style conventions. And I also suspect that there is some misuse of statics, but can't say more about it without having the entire code. Second, we rewrite the original method: 

If this is a generic implementation, my first question then is why interface is there? This interface is part of Swing API, which has it own sphere of application. The objects implementing this interface may (or may not) be convenient here; anyway, they tend to be used in Swing/GUI-related situations and I'd not interfere with their scope for a generic case. There is also something even more important concerning . As you know, it has method which returns an . This type is a very old Java thing (since JDK1.0), introduced even before Collections, and currently it looks like a rudiment. And it's not very pleasant to iterate on. But if you still need/want to keep , a type bound mark should be added, in order to avoid compilation warnings. To replace , I'd suggest to create a short and concise class, which points to a (or even a ) of children s and overrides and methods. This class would also be useful in other examples of your article. Code Blocks I understand that conciseness and lack of extra space is the priority in this code, but when I see this 

This implementation will return all the files having . If you want to get them by regex, it's achieved with a little change in the condition. If we push a bit deeper and try to benefit from Java 8, it becomes really concise: 

is not a very performant data structure when you need to search and match elements. Here you have a nested loop, with even one more "hidden" loop when is called. To improve the performance, I can suggest to operate on s. If it is not possible to change the signature of method, the contents of the lists can be transformed into two objects, where the key points to ref and the value contains the BO itself. The transformation method: 

This transformation is not so obvious, but still feasible without instantiating a dedicated directly and without using . First of all, I suggest to implement and in and classes: this is often useful, especially when storing objects in collections. Here is how the functional sequence can look like: 

Code Duplication Each of and methods contain too much duplicated code. In each of them, the second outer block can be simply cut out. An additional call of the method with inversed arguments will produce the same effect: 

Now we cannot reassign the field, but we can operate on its contents when necessary. method would look like this: 

Both one-for-loop and solutions represent a naive approach: its main drawback is that for each index you need a dedicated variable like or . Since you confirm that the array can be quite large, this also means that you'll need as many variables for indices as there are items in the array. Of course, there might be more flexible solutions and I see that the first step is already in the original code, supposing that is an enumeration like this: 

Randomness I think that there is a minor issue with random values distribution. As per Scaladoc for :