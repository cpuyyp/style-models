Also, a rule was to use React and SASS (The FCC founder said that SCSS is acceptable). This was my first attempt at using Redux. As a result, some things in the app are experimental. For example, the reducer works well and returns a new state each time - but I'm sure the code here could be better written. Also, in the component, I found myself confused at how I should use the component's state, or draw data from the Redux store. Some thoughts on this are most welcome. As was recommended to me on a different code review, I used the BEM pattern for my SCSS. I used Vex for the modals. This resulted in some pretty ugly code. For example, html tags within a string (which I think looks really confusing in the vicinity of JSX). But the functionality is fine, I believe. Would React-Bootstrap be a better option in this case? Here is a link to a Codepen of the app Javascript: 

Here is a demo: $URL$ Please can you review for any improvements to how I have structured and written my code? 

The code returned in the view is messy. How can I tidy my code so that the styles applied do not take up space inside the main of the view, perhaps instead within a variable beforehand? How else can I optimise this code? 

Without the link, I can only make certain assumptions, so I am going to give a couple of global comments: 

A short comment about your first approach, using a would be a good thing, because concatenating s with each time builds a new object, whereas with a , you would only make a new when you concatenated all parts. In this very case though, pure performance wise, it might get optimized under the hood to use a anyway. 

Not sure if I should review it as a programming challenge, or if I should include design remarks, I'll just say what comes to mind. I'll first note that I would make the fields , and add accessor methods. Them being immutable makes sense I would say, and methods help for using them as method references with the streaming API and others, as I will show in a second. For , I would really refrain from using and , at least when you do not know the implementation. Depending on the implementation, the performance of these could turn out to be quite horrible (e.g. could traverse the list up to the index each time in case of a ). Also looping and mutating a collection at the same time is a lot of times error-prone or worse. Finally, you mutate the collection passed in, which is also a point to think about twice (though not necessarily bad). For , I like this implementation better. It is a smarter implementation for given problem. First, I would like to note that since Java 8, has a default method implementation for sort. Next, with the method, you can specify which property of the type to use to compare with. If you add accessor methods like stated before, this would make the sort look like (with a static import of ): 

Even if I'm not quite right, 99.9% of the abundant numbers will immediately be abundant with this test, so in constant time you will have detected them. You could check a few manually the rest of the way if you are "close" to abundant. I leave you to decide how close is close. A number that is not divisible by 2,3,4,5,6,7 is almost certainly not abundant. So you can find that critical value and then not test anything higher. Store the abundant numbers into a vector. Given the list of abundant numbers: 

I am trying to represent questions in quizzes. The database is Mysql but I am using fairly generic sql. The assumption is that varchar cannot handle more than 255 though, so I am supporting longer text by having multiple text components. There are four primitive kinds of questions: multiple choice, multiple answer, fill in the blank, and editText. Multiple choice have multiple answers, with one being right. Multiple anwer have multiple answers, with some being wrong and some being right. The student is expected to pick multiple answers and avoid getting incorrect ones. Fill in the blank allows a string answer which is compared against the answer (or answers). For editText, a block of text is loaded and must be modified by the student. An edittext can exceed 255 characters, so cannot use a single varchar. In addition to the base types, there are also multi-part questions where each part can be a question. My approach is as follows: A Quiz is a collection of CompoundQuestions in a particular order. This table is not included because it is not relevant to the rest of the question. A CompoundQuestion is a sequence of text, graphics, and questions. Some compound questions could have zero questions (text only) while other CompoundQuestions could have many. Most will have just one. 

I think overall it is a nice implementation. It is clear and readeable. The use of constants is nice, makes it easy to refactor the code to make it more generic later on (e.g. replace with given character, not just space). Clear variable names (although I'd try and be consistent, and use , or , most likely the former). I have two remarks: 

I don't really think you have what I'd see as duplication, but a possible other way to implement it would be to keep track of wether you are currently in a sequence of underscores. Example: 

The reason for this is that now we only flip while it is necessary, because if the bottom of the remaining stack already contains the largest pancake, we do not need to flip. Meanwhile, we are also keeping the implementation clear: you first look for the largest pancake in the remaining to sort stack, move it to the top, and then to the bottom of the remaining stack. Using clear variable names makes it so other people can understand your implementation more easily (and even for yourself, if you would come back later). 

You have to keep in mind that Streams are not the solution to everything. In this case for example, you need to keep track of multiple values, i.e. the current individual, and a cumulative sum (and you have to return a a value as soon as a certain condition is met). Yes, there are ways to do this with Streams, but I think in this case it is best to implement it with a simple loop like you have. A couple of side notes: 

Sorry I am late to this party, but your code is actually useful to me, so I am using it as a start for my own; here are my comments on style. 

No need for ; after functions. Only declarations end in semicolons. When passing AABB objects, which are on the large side, consider passing parameters by const & instead of copying. It is faster to copy objects less than 3 words. This is 4 floats, it is kind of borderline but I will check. Certainly if you use double, then pass by reference. 2b. AABB is a weird name. Boundary would be better. Do not pull code out of the class when it is so short. The constructor and destructor are 4 lines each, the code becomes more readable and shorter when kept in the class definition, and this is the kind of code where you want those inlined anyway. Do not pass Data by value!!! This is huge, you have no idea how big T could be. Always by reference when you don't know. The biggest so far that I found is that in insert, you are testing nw,ne,sw,se. You should be comparing your value and deciding which one to do without trying them all! You might consider having only a single bounding box at the top and computing the bounds of each sub quadtree dynamically. It might be just as fast and would take substantially less space. 

Well, I do not want to be the one always hammering on using s, but your second solution was almost immediatly clear to me, whereas the first was not. It does help that with the second one you split it up into methods, a very good thing! Nontheless, I still think you can improve the second solution: 

Note that will bring you to the same spot as . You can see that each of those share the same second parts as well. This is duplication which we can use to speed up the algorithm. If you think about it, there are generally multiple ways to get to some point . If you think of this as the starting point, the possible paths to the destination will obviously be the same, no matter how you get there. So what you can do is create a lookup table for a calculated location, so you calculate each one only once. This will give you an extreme amount of speedup I would think, on problems with a big amount of possible paths. Which you will get to quickly, even for small values of . 

I have a feeling there is a direct way to compute this amount, but I am not really into all the mathematics, you could possibly look it up. I'll talk about your code as is: 

I was perplexed why you want a better answer if your current answer is able to solve this in seconds, but if you are interested in the math, there are definitely better ways to do it. They just don't matter much if the maximum number is on the order of 28000. If you eliminate the lists and go up to the square root, the code should get faster by a factor of 1000 or so, a rough estimate based on the difference between 28000 and the square root which is 167. Another factor of 2 due to only dividing by odd numbers after checking 2. But if you look at Wikipedia on abundant numbers: $URL$ You will see that the first abundant number that is not divisible by 2 is 5391411025 First of all, that's way more than 28000. So you can immediately ignore any number that is not even in your search for abundant numbers. Wikipedia says 2 or 3, which is confusing and seems wrong. Perhaps I misunderstood them but I was looking at their list of abundant numbers, and 20 is abundant, and it's not a multiple of 3 (it's a multiple of 5). 1+2+4+5+10 > 20 Still, this means that any number that is abundant is going to be divisible by 2 and either 3 or 5 (or both). Think of it. How are you going to get factors that sum to a lot? You need factors that are an appreciable fraction of the whole number. The closest you can get to n is n / 2. The next closest is n / 3. The highest number you have to check is the square root, and since the square root of 28000 is about 170, that's the high end. But you can immediately terminate if you find that the number is already abundant, or if the sum is so low that it cannot possibly become abundant. So try only even numbers, and do the following: