I think having one in your definition of sublist is perfectly appropriate, but the use of isn't appropriate because you are going to need a list anyway. You aren't using it wrong, there are just better solutions. Also, as noted in the other answer, you can avoid repeated slicing by creating a copy of the list on the first run of the function through an optional default argument (see in the code below). Finally, summing three lists in your return statement is probably less than optimal. With unpacking in Python 3, you can turn this into a single comprehension which should be better in terms of intermediate object creation. 

Sort But wait, this decrement function suggests that we turn into and turn into . This clearly isn't correct. While the outputs are larger than the original and the digits sum to the correct value, they are not the respective minimal solutions. However, if we sort all of the digits after the incremented digit in ascending order, the minimal solution is achieved. 

I echo both of the previous reviewer's sentiments, but I'd also like to add that regex is overkill for the parsing here - will work just fine. Implementing this and some of the other suggestions might produce code like: 

I don't see why you want/need three functions to download the different quality videos. There is a bunch of repeated logic both in the functions and in the main loop. Then, I would move all of the specific code into the section because that's the purpose of that section. 

My game uses configuration files in JSON format. One of them is used for setting up control bindings, and it looks like this: 

I'm no PHP expert, and this might be personal preference, but I like to initialize variables at the top of the function to make it clear that their scope is not limited to the constructs in which they're defined. 

If you know how reflection works in .Net, then you know it's looking for the methods by name in the MyGame class. The Exit method is actually defined in the Game base class, which I don't control. What does everyone think of this? I am considering moving the MoveDown, MoveLeft, etc. methods into another class, like IPhysics or something, where I would also do the collision detection. Since I haven't gotten that far yet, these methods live in MyGame for now. EDIT: Initially I tried to focus this question as much as possible on the Input class, but I would be grateful for any advice. 

I'm writing a program to help with remembering complex bash commands. On invoking the program, it asks for a description of the desired operation, e.g., "increase volume" or "find orphaned packages", and displays the commands matching the input ordered by closest match. Matching is determined by splitting the command text into a string vector, then the description, and combining these with a list of additional keywords to compare with the input via . This is currently case sensitive, which I plan to change. This is my first C++ program so I've probably made plenty of mistakes. A couple things I'm still unclear on: when to pass arguments by reference, when to use and , and when to use pointers. 

Since will always be by the virtue of the list not being empty (as previously checked). This second line is equivalent to 

First, note that this is all untested, but the ideas should hold up. I tried to abstract a lot of the logic by distilling the object creation to a dictionary containing the data, but it turned into a bit of a mess. To start with, consider the following structure for your object data: 

One immediate, fairly significant improvement that I see would be to calculate and outside of the loop in . This provided a 30%-50% reduction in time in my tests depending on the computer and Python version. 

Per Graipher's answer, I extended the chance of victory to accept an arbitrary number of regions and number of wins required. 

In addition to the recommendations suggested by @Austin, you could inherit from to create an object to register and recall your functions. For example: 

This contains the name of each object, any keyword arguments that are necessary, and any attributes that also need to be created (as objects themselves). These can be created from this structure using the following functions: 

Sure, you could remove the global variable by moving the memoization to a decorator and adding a base case scenario to the function. 

We can't increment any of the 's since isn't a digit. Thus, we must increment the . From this, we learn that 's can't be incremented. 

Now you don't have to register each effect in your dictionary after the function declaration and this should clean things up a little. Additionally, if you import this object, you can add functions anywhere, easily see what effects are registered, and you can add logic to the class itself if you want more complex behavior (i.e. address the case where an invalid string is entered). 

Both share the following code used for loading and instantiating the player object: (Don't get too hung up on the loading stuff. It's fairly complex and might take a while to step through. I just included it in case someone wanted to see.) 

In my game, I need to detect whether any buttons/keys are pressed at all before I try to process any input. This is easy enough for keys since the XNA library provides a method on the class: 

If this is a web application, you can use an HttpModule to do your session management. Begin every web request by opening a session and beginning a transaction. At the end of every web request, commit the transaction and close the session. As long as you're wrapping all the hits to the database in a single transaction, you don't need to worry about efficiency too much. 

The second implementation has this instead. is called on every tick regardless. When the mouse is clicked anywhere on the stage, is called once: 

Other than that, it might not be a good idea to send the user's email in plain text. You can have an AJAX request use the method as well as , which would improve (slightly) the security of personal information. 

I tried whipping up my own extension method but, as I'm not really familiar with enums or arrays in C#, I'm afraid it's a little sloppy: 

I've come up with two ways to do sprite movement with CreateJS, and I'm wondering if one is better than the other as far as performance and maintainability. The player data is saved in a json file and looks like this: