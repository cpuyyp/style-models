We execute the function twice for each value and time only the second call â€” this is a non-rigorous attempt to prime caches and such to get a more accurate measurement. Some results for your original code are: 

The final clause is where all the interesting work occurs. It first calls with a default value of to check if the value tuple is present. If it's not, the default value of is returned, and the case clause for creates a new list of value tuples based on the incoming values of , , , and and passes it to a new call, setting the initial sum value to 0 and passing the current cache. This call returns a 2-tuple comprising the sum for that value tuple and a new cache. The final line in this case clause inserts the sum for the value tuple into the cache. The case clause for when finds the value tuple just returns the cached sum and the current cache. The result of the case expression is stored into , and then is called recursively with , which is the tail of the value tuple list, a new sum which is , and the new cache . We can run the code in a list comprehension to calculate the running times for values from 1 to 12 using like this: 

And submitting to keetCode it got a lower score than using a loop, being only ahead of 73% of submissions ??? Then I tried 

Zero indexed array and clean code. The loops are a little strange starting at 1. Normally you index into an array from 0. If you have 8 items in the array the loop would be but you may have extra elements on the array. Without the HTML I can only guess. For finding the checker colour you can add the x and y and then get the remainder of 2 saving you the second loop. Function names should tell you what they do. You have which could mean anything. The whole thing can be done as follows 

Cycles never end. This problem is not as simple as it first appears. All path finding algorithms need to be aware of the paths that lead in circles. Your problem and the solutions for this are , , and ". but if we change the last link to we create a circular link. Your code will follow and so on until the call stack overflows. In most recursive problems where you encounter a cyclic reference you can easily avoid the endless recursion by simply tracking the objects you have already referenced. Ending the recursion when you find a link that has already been traveled. But your problem requires ALL paths which complicates the problem (Actualy impossible as cyclic links create infinite paths). Consider the links It has the following solutions 

Then, you could implement all of your command-driven printers using that same base class, like this: 

If each ID1 can only have one valid corresponding ID2, then I would recommend using a dictionary object to store the valid combinations, like this: 

The third way to fix this would be to use your second example. By fixing the class so that it is a stateless class, multiple threads can call the same object as often at the same time as necessary because the data is stored outside of the class. So, as long as each thread is instantiating a separate object to store the data before passing it into the object, all the threads can share the same object without needing to worry about collisions. 

Then, you would need to create a separate factory class which creates all of these objects and wires them together properly: 

By synchronously locking on the object, if a second thread tries to call at the same time, the second thread's execution will be blocked (i.e. hung) until the first thread's call to is complete. The problem with this approach is that, at least to some extent, it defeats the purpose of multi-threading because only one thread can do that part of the work at a time. The second way to fix this would be to have each thread create a new object so that they don't interfere with each other. For instance, instead of having the object declared as a class-level field, you could just create a new object inside the method, like this: 

On my machine, this overhead is ~1.20s. The original solution for input with 9000 entries and 3 lookups takes ~6.25s, while the solution I've posted here runs in ~1.23s, which means it imposes hardly any overhead over that of the VM startup and shutdown. 

I created an input file containing 9000 entries to be stored and used it to measure this solution to be about 150 times faster than solutions that read the input line by line, as measured by running the solution on the command line in a bash shell like this: 

Caching is definitely appropriate here as well. You can carry a cache through the calculations using an Erlang map. I took your original code and made the following modifications: 

The first value is , the second value the execution time in microseconds, and the third value the result of the function for that value. For values greater than 2, there is roughly a 6x increase in run time at each step. For of 12, the execution time is just over 75 seconds. Here are the results for the revised code: 

When you think about it, it makes perfect logical sense. In the real world, you'd never even think of designing a car that creates it's own engine--that would be a nightmare. You of course would build a factory which would create both the car and then engine, and then put the engine into the car (inject it). The equivalent in code, would be to create a factory class, like this: 

The reason that the first example would be considered problematic when multiple threads are involved, is because in that example, a object maintains state (i.e. data) and it has methods that act upon that state. There's nothing wrong with designing classes that way, per se, and it doesn't mean that the class cannot be used by multi-threaded applications safely--it just makes multi-threading more difficult. For instance, consider this example: 

By doing it that way, you only need the single statement. Another side benefit is that you can now store the list of valid combinations somewhere else, outside of your code, such as in a configuration file or a database. Then you could load the data from that data source into the dictionary at run-time. 

A need I have always found dynamically creating SVG content and filters a painful and messy process. 

Vets unsafe state properties before using them. Hides them so that they are not accessible. Uses setters to prevent mutation or improper state. 

Bad code. There are some that will not agree, this is an opinion on good coding practice for JavaScript. The code in question 

Swap the first item with a random position. The first item has a 8 in 9 chance of being above 1, so there is a good chance it will be swapped with a random pos again, but the item that moved to 1 will only have the random selection chance to be moved again. As soon as you have a system in which starting position changes the odds of being shuffled you add a bias to the shuffle. Even if the result looks random to the eye they are not so in reality. Testing for random To test you need to find out how often each item ends up in a particular position after each shuffle (starting from the same pos each time) Example start with ordered 123456789 array and a count array, then shuffle, in the count array add one for the position the first item landed in. 

Simply put, from an idealistic standpoint, fancy-pants code is always better than cowboy code, but from a practical standpoint, fancy-pants code can sometimes be much worse. So, as a general rule-of-thumb, I would say that you should always fancy-pants-code unless you have a good reason not to do so, and you should accept that there are some very good reasons not to do so, sometimes. I have a lot of experience with this, and I can tell you, designing code well up-front, is WELL worth the effort. It's true, as you said, that good design has more up-front cost, and poor design has more back-end cost, but to say that the two are equivalent, because of that, is fallacious. It all depends how much back-end work will need to be done. As you say, a simple statement isn't really that bad, and if adding more statements to the statement is the worst of the back-end cost that you are going to incur, then it's really not worth the time to add a bunch of complication to avoid something as trivial as that. But if the project grows and changes over the years, a little shortcut like that, to save a few hours of development time, could potentially cost months of development time in the long run. It all depends. Another issue which often muddies the water is that not all fancy designs are actually good designs. You could develop the most impressive fancy code in the world, but if it doesn't actually solve any problems, such as making the code more stable, flexible, or maintainable, then you've actually made the problem worse by all your fanciness. As much as I am a believer of good design, I am also a strong believer in the YAGNI principle. If you haven't read the wikipedia page on YAGNI, I'd strongly recommend it. YAGNI simply means "You aint gonna need it". Simply put, don't add features and complication that you don't currently need. YAGNI does not preclude good design, but it does preclude unnecessary fanciness. Again, the issue isn't whether or not the design is fancy, it's whether or not the design is good. A good design will follow the YAGNI principle. It is definitely possible to "over-design" something. All that being said, if there is no good reason to cowboy-code on this one, as it sounds like their might not be, allow me to offer my perspective on what a good fancy design might look like. My way is by no means the only right way, but hopefully it will be helpful to you. I'd like to think that my fancy way of doing it does solve a lot of future problems and would therefore be worth the relatively small up-front cost. My Way to Do It (Dependency-Injection) Your first instinct was to think that the Factory Pattern would be a good solution to this problem. That was a good instinct, but I don't think it quite goes far enough. Dependency-Injection (DI), which relies heavily on factories, is perfectly suited to this type of problem. Personally, I think it is well-suited for almost all problems, but there are certain problems, like this one, which just scream dependency-injection. In general, the principle of DI is that a class never creates it's own dependencies. So, for instance, if you have a class, and it needs an object, you wouldn't have the class create its own object. Instead, you would have the class request that the (it's dependency) be given to it (injected), usually in its constructor. For example, rather than having something like this: