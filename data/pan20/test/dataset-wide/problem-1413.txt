Use Here is a blog post containing an example: (link) Have a look at the language-python package. It's lexer is built using : (link) Purescript handles indentation via the , , and functions: (link) Grep the rest of the source code for these functions to see how they are used. Its lexer defines a token (link) but from what I can tell it is never returned, i.e. see (link). The indentation level is kept track of by the parser (link) via the function. 

partitions This is inefficient since once you have one person's items you know what the other person's items are - just take the complement. Also - does this condition really work if two items have the same value? 

and it avoids having to return the object from the player object. Perhaps my implementation of isn't quite correct, but you can make it work. 

is another potential expensive call. I would detect alphabetic characters using comparisons with the end points of the upper- and lowercase character ranges: 

Even though they are not needed, they aid in reading the code. Also, aligning the in the case patterns helps with readability. The type signatures on your calls are not needed due to Haskell's type inference. insert You should be getting this warning from ghc and ghci: 

Do you want to pollute the global namespace with this operator? Is a part of the ConsoleTable interface? Instead do this (I avoided the "try" word on purpose): 

Don't use -- in most cases it only clutters the code. I prefer to have some distinction between the c-tor parameter and the class' field, so I use "naming convention": becomes in a c-tor. Using prevents compiler from copying every column. 

have inconsistent bound checking, which may cause confusion when quickly screening the code, i.e., you need to mentally switch between and , which consumes your "brain cycles". :) [added 23.04.2018, 16:36] IMHO, the preferred way would be: 

You won't need to think when/if the first line is only short description. Besides, it also look more consistent when adding file header, e.g.: 

This way you "re-use" the fact that returns / -- so it minimises the burden of analysis. You intuitively expect when some operation returned that something went wrong. This is only if you really need the operator implementation. Personally, I think that it creates more problems than helps with anything. I seems quite concise to write: 

If I remember correctly it should contain "forward-decl" of . These are only used by the implementation: 

Having braces around the "one-liners" eases adding new code and reduces the frustration related to adding the braces after. No more "I should've added them at the first place". ;) Field visibility These: 

The big idea The idea behind these patterns and similarity measures is that given historical data we compute a pattern and a future price change with the idea that the pattern implies the future price change. Then given current data we compute the current pattern and search for a similar pattern in our database from which we can deduce the corresponding price change. The main problem is that the function is not symmetrical in its arguments, i.e. and may have wildly different values. Consider these examples: 

Then you have a list of primes and their exponents: (p1, e1), (p2, e2), etc. and the number of divisors is: 

The idea is to keep track of the last node in the chain so you can update its field when you create a new node. 

Note that row and column indices start from 0. In the case of diagonals, 0 is the main diagonal, with positive diagonals to the right and negative diagonals to the left of the main. Products And here is how to use : 

You've gotten rid of a lot of global variables, but you can do even better! Consider writing this function: 

is a standard way to copy blocks of memory, and most C libraries implement it with special processor instructions to speed it up. Another coding style issue... instead of: 

In such a case it should be 32 bits wide. Documentation Parameter name is duplicated in the function doc. Instead of: 

Eclipse can add this automatically. And this is also something that is useful, e.g., when your GPL-licensed code will be copy-and-pasted in some other project. If so, you'll be famous, which is what programming is about anyway. :) Headers Someone else pointed it out in the first part. But... Do you need all of: 

It can throw. Most people won't think that an operator may throw. Especially when it looks like adding to some . [/added 23.04.2018, 16:36] Braces I prefer: 

to remove seventh row. But what does it syntactically mean to subtract from a table? Why is it removing the row? Why not column? Ideally, mathematical operations (, , etc.) should be used only with mathematical objects, e.g.: numbers, matrices, vectors -- but not , I mean mathematical vector, note that the does not have overloaded to add more elements. I think that this is because library designer knew that it makes no sense syntactically to allow such an overload, etc. Such a syntactic sugar could be useful in small implementation, but I would definitely avoid it in larger designs. Consider, e.g., in a 100 kLOC code base that someone encounters: 

and you have a similar problem with . Unfortunately, to preserve whitespace in these cases I don't think you will be able to use the function here. It is customary to have parens around the list patterns, e.g.: 

parseMessage The main problem here is that you are calling on the result of , and this doesn't preserve the original whitespace. For instance, the last case should just be: 

Note how the while loop avoids the duplication of code that you have in your program. Here is another idea for a subroutine - one that updates a player's score and returns how to report it. Either the computer's or player's score can be updated with this: 

meaning that the price difference (from the price at time 0) at time 1 was 1%, at time 2 was 3%, at time 3 was -2%, etc. Given another pattern we want to compute how "similar" they are. This is done componentwise using a similarity function for percentages whose definition is: 

In fact, you should be able to find a way to eliminate the need for this variable - during the player's turn it is always odd and during the computer's turn it is always even. 

stream->list Avoid on large lists. In your function it will create a (large) list before passing it on to . There is a stream version of - namedly , and this will process the stream lazily - i.e. it will only generate as many elements of the stream which are needed. next-prime Another way to eliminate the recursion here is to combine with and with your predicate, e.g.: 

As I understand it, I should be using instead of having all that nesting, but I'm not sure how that works. Correct use of will probably obviate the need for me to define how to handle those three failures each time. 

I’m using decorator objects in a Rails app so that I don’t have to do checks in views. Everything is working nicely and it’s easy to test, but I’m suspicious that my test:code ratio is a little high. Am I being too verbose? Is there a better way this could be done? Test suite: 

I'm creating some age-verification functionality for an iOS app. The user is presented with a object, and the latest selectable date should be today minus 18 years. How vulnerable to inaccuracy is my code? How could it be leaner? 

I have some working Haskell code in a Yesod application that is responsible for creating a new paid Stripe subscription for a user. Although it works, I'm not pleased with the walking indentation that appears as a result of nested case matches. 

I'm trying to remove the repetition as much as I can. Originally, the business logic was repeated once for each of the properties shown, but I've moved that into a method named . I've also introduced the conditional operator to remove larger blocks. I imagine the next step is to reduce the seven chunks of code into one, and iterate over a list of keywords, but how? 

The key is to use with an increment of 1 starting from the previous computed config. Using this idea, here is a better definition of for a general : 

e.g. is all the ways of removing one element from the list . Also, using the polymorphic signature alerts the reader that the function isn't specific to Ints. I would also introduce a type alias: 

So build up the solution iteratively. If you have the placement how can it be extended to a valid placement ? Clearly r2 can't equal r1 and (0,r1) can't be on the same diagonal as (1,r2). And, of course, r2 has to be a valid row number. 

which helps to describe better what it is doing. Anywhere you can use the alias instead of will help the reader. In fact, I would even write the signature this way: 

It all depends on how many configs you have. For a large number using a sqlite database could be a win. 

Each of these steps can be put into their own helper function which are also called "subroutines". The will make the body of the while loop a lot more readable. Here is an example of a subroutine to get a valid number from the player (again, pseudo-code): 

The only drawback is that explicit bounds have to be determined for each level function. This approach computes in about half a second. 

This shows intent more clearly. (Some may say that too clearly. ;)) There's also another problem with: 

Does it really need to be ? How many rows do you need? Is it stable? Is it robust? is guaranteed to be at least 16 bits long. I would use: 

should be private! File naming I was taught that is a C header, and for C++ it should be used or . I know it is not entirely true, but using: & for C only and & (or & , or & , or even & if you want to be particularly unique) for C++ only provides a nice distinction between C and C++ files without even opening them. It could also be used by some shell script if needed. Further reading: Try: $URL$ 

You won't need to change your docs, when parameter name will change. Also, I don't know why people use this comment style: 

I also prefer to copy all includes from the header file to the implementation file. The rationale behind this is that it ensures that when interface change is made, it will not impact the implementation file. And you get the implicit-include problem solved at no cost. But I can't guarantee it is how the C++ code is written nowadays. Interface Does it really belong to the interface?