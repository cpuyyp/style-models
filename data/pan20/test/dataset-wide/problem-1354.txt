I'll go for the styling of your code. Firstly, python uses docstrings. There are one line docstrings and multiple lines docstring. 

That being said, they problem statement seems foggy. The MD5 function does not yield the same hash for two different sets of data, when concerned with these kinda problems. That is way it is called a hash function or a one way function. If the hashes is identical the content is identical. The last thing I will say, is that even the very fast hash function MD5, is slower then a efficient comparing of the content. So I criticize the problem not your solution. Thanks! Good work. 

that is the fastest way I know of to solve this first problem. For bigger n:s the execution time is pretty much unaffected. Instead of creating the numbers, add the all at the same time :). 

Your labels variables does not contain anything, you can not chain very much in python. It's a design choice from the developers. So the variable of the labels is unnecessary. This: 

My personal belief is that if you don't need the try catch, don't use it. However the above code is analogues to yours. 

Instead of working with the objects in people_data i suggest you work with data structures. It becomes easier to manipulate that way. The data you care about can be represented with: 

This code takes each integer, maps it into the result of , takes all the results until they are no longer prime, and counts how many are there. Cool! Right? The only problem with the code above, is that it will take infinity to complete it, as it takes all the numbers and maps them, and then checks for how many to take. To solve this problem ruby now has... Lazy Enumerables As of ruby 2.0, lazy enumerables allows you to calculate values in an infinite stream only as needed. To solve the problem above, all we need to do now is to add the operator on the range: 

You should also consider extracting some of the hard computational lines to helper methods, and name them so that the reader will better understand your code: 

Now all we need to do is multiply them with each other! Method naming Your names are very verbose, which is a good thing, but ruby idiom frowns upon prefixes. Also, prefer using verbs already in the language () over those which are not in the language () So now the code will look like: 

Doing stuff over and over again I'm pretty sure, though I might be wrong, that at the end ends up running the same "pairs" more than once on the same string (or its duplicates). It will be better strategy to cache results, or maybe pre-process your data (build a template, and only set the variables, or something). 

In python, the ";" that you use in the end of some of your rows does nothing, python instead uses line breaks and indentation. You use very many variables, and you probably don't have to, and it seems that you are repeating yourself. If you want to do it that way, there are a better way. Function naming conventions in python is not camelCase, but instead function_name, camel case is reserved for classes. variable naming conventions in python is always lower case, and not B1, that looks to me as a poorly named class and not a button. You should write you variables after your functions, and not into right after your imports. When you top-down a piece of code, you make it dense, and hard to manipulate and read, break it up into functions. 

What would be the coolest solution? It would be to have a class inherent ThreadPoolExecutor and override the specific part of the class that executes the the threads inherent to ThreadPoolExecutor whit what you want to do. 

Encapsulation: You are not working with kwargs and args, so don't name them as such, in the same sense that you should not name your variable i, it is very confusing. You are dealing with three different args and kwargs, namely the job, the executing process and the classes, and args and kwargs in the class, should belong to the class if needed or not. 

How does your intersect with ? As far as I know, there is no such method on ... It is quite hard to calculate complexity of code, if we can't know how this intersection happens, especially since it happens within a polynomial iteration (*) in , and within a recursion in . Caching? If the complexity of is a constant, your complexity would be \$O(maxRays \cdot objects \cdot lights)\$ (I'm counting your operations' complexity as constant), this might not be ideal. I've got lost in all the recursion and iteration loop you have there, but might there be a way to cache some of the calculations? Would it help you to "remember" distances between your (which does not change during your calculations), and your s, and reuse them as you go along? This might lower your effective complexity, and make your code run a lot faster. 

Regarding and , @BroiStatse suggested caching , and I'll say - you don't need to cache ! Once you have used it, you don't need it, so if you load the XML on initialization - you don't need to save at all: 

Tail Recursion Erlang (and hence Elixir) pride in the tail recursion idioms they use. You've got one recursion in your code but it is not a tail recursion! This means that the recursive part is not the last thing in the function, and the tail recursion optimization cannot be used. Although your code's recursion is limited to up to 11 hits, it still misses the point of the Elixir idiom. A more idiomatic pattern is using an accumulator, and recursing on that: 

Is this a property in an object? If so why have you named it ? Give it a proper name such as or something along those lines to make it more obvious what it does. Now it's just confusing. And for the other function you could name it . If you included some additional markup it would help your question a bit. 

This might need a bit of editing but you get the idea. However I'm not sure if any of these are actually better ways of doing what you want, but it's other ways of doing it. It might make everything more manageable if the code gets even bigger. Hope this helped. 

Personally I would create loops for this, it's very unreadable at the moment and you are repeating yourself a lot. Remember the DRY rule (don't repeat yourself). Also if you do it via loops it's easier to maintain and change in the future. 

I'm trying to grasp this whole MVC design pattern idea but I'm in the dark if I'm doing it correct. This is where I need some feedback on what I've done so far. Here's what I'm wondering: 

I've made my own pagination service for my forum that I'm working on. I'm quite happy how it turned out but it feels a bit rough around the edges so I would like to know how I can shorten this code and make it more efficient and better structured. The comments are overly redundant just so that I can pick up on the flow of the program really quickly now during the production phase whilst working on other things simultaneously. Figured it'll also help you guys understand what's going on easier so I left it in. Any pointers here are welcome, let me know if you need any additonal information. The markup (excluding banner): 

What are nested classes? What are subclasses? You ask whether you should use of , but your example shows neither. A is a class which inherits from another class, and then looks and behaves just like it, plus some other functionality, which makes it a special case of its parent: 

Ruby's chaining and keeping it DRY To elaborate on the multiple assignment above, it is idiomatic in ruby to use to transform all elements in an array: 

Both of these solutions will give you the needed matrix, so we can move on the see what we should do with it... We want to get the coeffiecients that produce the number of primes, so let's do just that: 

I think your code is very nice, succinct, and ruby-like. Two minor issues - Your code is a bit over-sophisticated, which makes it not very readable, and quite brittle. Although it won't fit in one line - a solution will be more suitable here: 

All of these styles work, but it is better to choose one, and stick with it. When using a hash in method, my favorite is the second style () Use language features Since Ruby 2.0, named parameters are supported, and you are encouraged to use it. It will give you free validation, as any parameter which is not one of those you declared, an error will be issued: 

Now to the suggestion If with any number that is even, it has a number of factors 2. So remove the factors 2 and do you algorithm on that number. Like this: 

you save yourself possible future headaches if you pick up this habit. When python imports a file, it will run the code in it, if not protected like this. 

I ended up with this, and I don't claim that it is any better then yours. But I'll show it anyway for completeness. 

The manager might be unnecessary, you are only ever transferring one value. What you are looking for might be a Queue. 

For big numbers and for many numbers checking for divisibility with prime numbers under the sqrt will give a big speed increase, you could still use the same method. But there are many ways to optimize factorization, many many ways. 

In the problem you've provided each induvidual pairs order does not seem to matter, so load them as such. If you do that, you don't have to sort the in the calculation function. If you don't, you'll resort them later. Again and again. Them more samples you use, there more time is spent doing this. Times: 

Now what I would do if this was for someone new to programming is relay on something else then abstraction of the init and abstract in something like biology: 

The first line selects all subdirectories matching the pattern. The second line selects only the ones which are empty. The third groups by the numeric suffix (non-numeric suffixes will be grouped under , so they will be last). The last line sorts by the numeric suffix of the directories, and returns the directory names. 

Use correct data structures - in you manage a , but it never has more than one element! You the current node and the next... Simply using would be sufficient - and more readable 

Your code looks OK, though I think there is some redundant code - is never used, since work is never completed... You might also want to consider a different approach to - . Instead of creating a worker thread you can do this: 

You are interested in how to use classes properly, so let's talk about it. Design your classes Why did you choose to split the functionality as you did? Does you have any stand alone value? Does it have any re-use value? In ruby it is very easy to arbitrarily break functionality into different classes, because you can call methods and members which are not there, and only in runtime they are checked. This does not mean you should arbitrarily break functionality into different classes - quite the opposite! It is the developers responsibility to design his classes well. How should you design this? What are the actors in this exercise?