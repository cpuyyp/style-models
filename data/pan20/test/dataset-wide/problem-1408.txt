The bug I've found is somewhat unfortunate, but easy to fix. Apart from that, there are a lot of little things that you could do to improve your code, but apart from point 1 I didn't spot anything that would require immediate changes. However, it would be nice if you'd strive to make this code portable, i.e. remove . Also, there are some irregularities in how you name things; you should decide on a coherent style for the sake of readability. Regarding STL usage, I didn't actually find much that could be improved. Apart from replacing legacy C functionality (i.e. and ), there is not much to do in regards to making your code more C++-y. Overall, I enjoyed reading your code. Keep up the good work! 

Order your s alphabetically. This will facilitate checking whether all required s are there. Also, consider leaving a space between and as this tends to be a coding style issue most programmers agree on. Also, you don't seem to use anything from , so you should remove it. No, I disagree. You're putting your code up for review here, so you should be posting your real code and not some changed variant that will never actually see a compiler. Using or not can mean the differences between subtle bugs that may not manifest until some edge case occurs, and you'd probably want to be told about those in a code review. Also, in all honesty, writing every few lines doesn't change the length of your code much at all. It is discouraged nowadays to use for simple numeric constants. You could either use here (or, if you don't have anything >=C++11, ) or define constants. Again, if you have C++11 or beyond available, you should prefer to , because it is much more readable and versatile. Being explicit is good, but being too explicit is bad, too. can be written as , which is most commonly used today. Ultimately, though, this is a personal style issue, so don't take this point as a required change. is not the right type for everything. For example, might overflow because might be bigger than and, in any case, unsigned. The standard offers for sizes, so you should make use of it where appropriate. Don't use because it's horrible. Although it does insert an endline character into the output stream, it also flushes the underlying buffer which is very rarely required (and for that cases there is ) and can seriously harm performance if you're doing a lot of IO. Just write instead, the underlying system takes care of converting it to the correct end-of-line sequence for the current OS. Use member initialization lists where possible. Lines such as should just be part of the member initialization list of your constructor. Your code violates the Single Responsibility Principle. To be exact, is doing not only its main purpose but also IO, which violates its responsibility. Extract the IO to a helper class/function so that other people can use without getting extremely annoyed at standard output they don't want. The same is true for benchmarking: You shouldn't have a method that measures time, but write a separate benchmark class/function, possibly utilizing a benchmark library that allows you to get more reliable results. should take its first argument by . Currently, you're making a copy of every single time, but don't do anything with it that would change its contents. Taking the parameter by reference to const will remove that copy and thus speed up the code (probably). is a lot of code that does remarkably little. is very handy in some cases, but this is definitely not one of them. Just write , or just use ( is not exactly what you would call expensive to copy). Don't make assumptions about the container type everybody uses. Instead of taking a or a or any other container as a function parameter, take a begin and an end iterator instead. Iterators enable the caller to use whatever container he wants while not putting a huge burden on the library implementer to ensure correctness for every available container type. The keyword here is test. You should restructure your project and write actual tests and benchmarks for correctness and performance. The function is not the right place to do any of those. Since we are talking about restructuring your project: Nearly all of your code should be extracted into a header and an implementation file. is terrible to read and verify. You should have a separate object definition, maybe even a dedicated generator function (in the test class this actually belongs to, of course). 

Bingo. You're assigning a non-const, non-rvalue reference from a temporary, which is actually not allowed by the standard (and my compiler rejects it correctly). However, even if it were, you'd have a problem anyways: Since the lifetime of the temporary ends immediately, you now have a dangling reference that points to an invalid location in memory (= a location where no object of type lives). Doing accesses through such a reference is undefined behavior, and thus your whole program becomes undefined. Fixing this, however, is not at all difficult: Just remove the reference and let be a normal object of type . In general, avoid using references as members unless you are 100% percent sure of what you're doing. In almost all cases, you are running a high risk of shooting yourself in the foot and blowing your whole leg off in the process. Regarding As far as my knowledge of the STL goes, there is no single function that would do what you require here. However, I came up with an implementation using both as well as , which, in my opinion, is about as concise as it will get: 

All in all, you code is mostly well written. None of the points above constitute a "Act now! Your code is on fire!"-grade problem, only tips that could make your already good code a little better and prevent some subtle, thus nasty bugs. However, I can't tell whether your approach is really worth anything. You should definitely perform some benchmarks to see if there are any performance improvements compared to a single threaded approach and, if yes, how big they are. Another thing you should consider is learning to do proper testing. There are a variety of testing frameworks (for example, Google Test) which provide functionality for writing and executing tests effectively. Especially since you are concerned about determinism here, writing and executing tests at a much larger scale should help you verify that your code works correctly. 

Please don't . It's use is uncommon nowadays, and you are unlikely to encounter it in code that is supposed to compile on any compiler that is not MSVC. Only choose to include it if you can show that it has a significant benefit. Don't . Do instead. is a C header, is its C++ equivalent. Speaking of includes, you are missing which is required for . Don't use and . Starting from C++11, C++ has rich random number generation facilities in the standard library, which allow for much more fine-grained control of the underlying RNGs and distributions. If you use C legacy functions (such as ), only use the functions supplied in the namespace (i.e. instead of ). The existence of these functions in the global namespace is not mandated by the standard. Pass parameters by reference or const reference where appropriate. For example, should likely be taking both its arguments by const reference since they are not modified and probably above the size threshold for efficiently passable objects (although I don't know anything about the big integer library you are using). Don't do timekeeping with . Use the facilities provided in the header. They are much nicer to work with, enable fine-grained control and are less prone to unit conversion errors etc. (same as with /). Your -function is doing way too much work. Split it up into multiple different functions with clearly defined responsibilities. Don't start your functions off by declaring every variable you are going to use at some point throughout it. This kind of forward declaration is an old pre-standardized C legacy; neither reasonably modern C nor any version of C++ require it in any way. In fact, it hinders readability to an extent, because the reader has to keep juggling all those variable names mentally, most of which will not be used until much further down in the function. Don't use , use for reading things from the commandline instead. Also, don't use , use the format capabilities of . Again, both and are legacy C functions and are somewhat restricted in their use. Don't use C-style casts (i.e. casts of the form ). Instead, use on of , and where appropriate. The following line (taken from ) is almost surely undefined behavior: 

invoke undefined behavior. The Single Responsibility Principle This principle, which is one of the foundations of good object oriented programming, states that each class should only have a single responsibility to fulfill. In your case, however, both and seem to violate this: In addition to doing their duties as observer and subject, they also log all their actions to , which should be the job of another part of your program. Performance Issues Currently, you pass everything by value. However, what if your template parameter is not cheap to copy (imagine a with millions of elements)? In that case, you're wasting time and resources by making a copy too much. Instead, you should always pass by (if you need more advice on when to pass by reference and when to pass by value, I suggest you take a look at the Cpp Core Guidelines). Don't use You usually don't need to flush the underlying output buffer, which does besides inserting a new line, and if you do, there is . will do in almost all cases.