Notice that I also didn't break the line into multiple. This is based on your subsequent lines, which show that you're willing to have content out past its character limit. No need to perform unnecessary line breaks. It just makes the code muddier. I also reworded it, since "resolution failed to resolve" is a bit redundant. Also, if you're checking against multiple files, I would use a of them. This will make it easier for you to tack on functionality later, if you need to. e.g., 

This works thanks to autoboxing, and it's a handy trick to remember as you move forward with Java. Even though this bit of code now works, it's still really bad practice since it's a completely unchecked (and therefore unsafe) downcast. In other words, you're just assuming that will return something that can be cast to an . We'll return to this later to add some sanity checking and error handling. 

Here you can actually just use if you feel that would make your code less wordy. As you can see in the documentation, you don't actually have to pass in an array of the appropriate size to the method; it only uses your array for infer the type to return to you. So by just initializing an empty, zero-length array like this, you may be able to improve code readability a bit (and performance by just a small amount, by saving on memory allocation). There's no consensus or standard on this. Just personal preference. 

I think this doesn't do what you expect it to do. It finds the position of the last character in which is equal to either of the single characters in . You probably want to use instead, which returns the position of the last occurrence of the full string . Looking at your example file however I believe you actually want to check whether the beginning of the line is (consider the work string might include ), so you would use and check it against instead of . 

Again the input is one word each instead of lines. Data which includes the word would trigger the end. 

The operator will read one word at a time, not a whole line. If you want to read whole lines, you should use . 

Here you try to dereference , which you previously checked to be . Dereferencing the iterator invokes undefined behaviour. Since I guess these lines are debug output only anyway, just remove that part. 

You should declare objects in the narrowest scope that they need to exist, instead of the function head. 

Instead of using , you can also connect the comparisons all together, potentially saving the double variable lookups: 

Since you do many index lookups on these arrays turn them into lists. Numpy is not good at single index lookups. 

I just picked this bit out because it contains a lot of your variable declarations. Your code was very, very difficult to decipher because of the names you chose for your variables. If you intend to ever work on a large scale project, you will likely be working with other people. And if you're working with other people, code readability is much, much more important than anything else. There's a common adage that goes something like "A programmer's job is 10% development, 90% maintenance," and that's incredibly true. You'll find that even if you're the only one working on a project, you'll come back to your code and look at this and ask yourself "...What in the world was I thinking here?" Believe me, it happens more often than you think. Bottom line: pick good variable names to try to make your code self-documenting. Note that in the final version that I post below, you can pretty much know exactly what every line of code is trying to do just because I've chosen my variable and method names intuitively. Also, if you want to be really Java-esque, follow the naming conventions. No underscores in variable names (unless they're ). 

These are all very odd variable names. In general, are constants (). The beginning underscore is also a paradigm that isn't really Java-esque (and to my knowledge in other languages it is generally used for -like fields). public static int glGenBuffers() { Your method names are also oddly named for Java. In general, Java method names should be actions and verb phrases. (For example, ) 

In order to use you need to . What is the purpose of the at all? It stores the s as keys and s as values. The only difference between the two is that has an added. Why do you need to save this? You can append the each time you have a new . This would be much easier to read and much faster. If you are trying to minimize the number of calls you might want to store all the opened s in the map and access them as you need them, closing all at the end of the function. Notice however that is not copyable, so you need to store references to them in the map, instead of the objects themself. If the input files are not that big, you might also consider saving all the parsed data in memory first and then writing it to the output files in one go. While parsing you can use a string-string map to save the data for each file. You are lacking any check of syntax errors in the input file. You probably should add code that reports back if the syntax is not as expected instead. 

Instead of assigning the array elements to , , etc., use them directly. Since later comparisons are not executed if earlier one already return this might save array lookups: 

Certainly, that seems adequate. You may want to make the field , though. Otherwise having a getter is pretty irrelevant. Also, I would make the field so that the associated color can never be modified. Were you told to code your own class? There's already one provided for you in . 

Here, your method assumes that every image is a rectangle of some kind. If you had an image that was, say, a triangle, your code would fail with either a or an at some point (depending on which end of the triangle you started at). 

I'm being forced to use the common anti-pattern of a which many classes in this project implement. Long story short, I need to have a constant which is pre-populated with values. Normally I would do this like so: 

You should try to use consistent style in your code. If you're going to put these checks and return statements at the beginning, either put them on the same line as the statement or don't. It doesn't matter which you do, as long as you do the same thing throughout. Makes your code much more readable and easier to maintain. 

I don't believe there's any good use-case for this code. I know it makes for a boring answer, but sometimes the correct thing really is simple and boring. As you say, the Struts framework should always redirect to the appropriate method and fail entirely otherwise. Even the scant lines you posted have some bad/useless programming practices, so my guess is that the developer thought he was being thorough and clever by tacking on needless framework. 

Your algorithm is of time complexity in . If your current code needs for , then one could estimate the time for to be roughly . Even an improvement of the most inner block's execution time by a factor of would yield an execution time of about . I guess this is not good enough. So you should better try to improve the algorithm itself. However I do not really understand the problem the function is trying to solve and I couldn't come up with a better solution on the spot. Also I haven't looked at numpy approaches, because you seem to have no vectorizable calculations in there. Nonetheless I tried to make improvements to the code as is. I came up with the following: 

The improvement is not even close to what you need. Also I tried to run the algorithm with and got memory problems. The reason is the number of solutions: There were solutions taking up of RAM. With other values for I found that around of all possible solutions are valid! So it seems you need to change the way you output your solutions if you want to get beyond on any realistic machine. Edit: I just notice that 5 GB is a bit too much for the number of solutions. However this was the memory allocated by the python process. A run with was unsuccessful due to lack of available memory. Edit2: There is actually something far more efficient you can do, by interweaving your solution checks with the combination generation (abandoning ). This doesn't look so nice however: 

I'm a bit confused why you're accessing statically here rather than just as like you do throughout the rest of the code. Is there some obscure reason that I'm not aware of? If not, try to remain consistent. Pretty high quality stuff overall! 

@gnanz's answer has a great tip for your method, but I just wanted to go over some more general style points for Java. 

This is just general nitpicking, but you should only expose methods as which actually need to be . The method makes sense as a method because it's the part of the API that you will want to use in other parts of the application. This method, however, is purely internal and thus should be . Also, method names should pretty much always be verbs or verb phrases. I might rename this method to something like or . Actually, because of the nature of how I rewrote your loops above, I would change it to or that way my usage of it is more intuitive. These notes also apply to your method, which is and might use a more intuitive name for code readability. Also, in those two methods, what happened to your beautiful variable names?!? Why did you suddenly move to using single letters instead of something more descriptive? 

The whole purpose of a map is to be able to access the values via a key instead of iterating over them. You should use this functionality: 

In summary: Your code will likely not do what you expect it to do in many cases. You should generate more diverse test cases. (try instead of in your example file and report what happens). Several parts of the code are redundant (all the map-iterating loops) and at the same time they might be very time costly for large input files (since the map might grow rapidly). 

These two strings are the same? Why? In the following code they are used interchangeable, so stick to one and remove the other. Even if they were used differently you could still use . Also you are trying to get a substring of the same length as the whole line (the second argument to is the length of the substring to be extracted), which obviously doesn't work. However truncates in this case such that a substring ending at the end of the input string is returned. The supposed filename you are extracting should be the part after in . However you start the substring one position after the position of the last occurrence of , which would be result in being part of the string. However with the particular example file you provided and in combination with the semantic error I laid out in 5., you actually get the expected result. Here two errors cancel each other. For different input however you would have very unexpected results.