to spare on the call. At the end I’d suggest reverting the keys and values of the mapping hash (because you start from roman characters), using symbols instead of strings as keys and replacing recursion with a loop: like this: 

I admit it is longer, but behaves better raising error on erroneous input and is faster – on my machine benchmarked against your code was regularely almost 3 times faster. UPDATE @200_success Thanks for asking - besides the performance gain there are two more reasons for using symbols instead of strings as keys. Never use mutable objects as keys in hash tables This is reason enough - mutable objects as keys are evil, if they change unpredictable things can happen, since values are placed in buckets of a hash table based on hashcode of the keys, now you can imagine that changing the keys of pair after it has been placed into a hash map is never a good idea. And strings in Ruby are mutable! I admit though, that this will rather not happen in our case, yet it would be a bad practice anyway and should be avoided just to keep the code clean. And it seems that in fact Ruby copies and freezes the strings if used as keys in hash maps in case we forget about this rule :-). Nevertheless we have our performance gain by using symbols. roman_mapping is in fact an immutable constant Neither keys nor values would ever change. So it is logical to use an immutable class for the keys - like symbols. Now numbers are immutable, too, but the hash maps are not. So while we are talking this, we should make also immutable using , and while doing this we can also replace the method with a frozen constant. To make immutable all these steps are necessary - simple freezing the hash map wouldn't be enough. If a reference to its keys leaks into the outside word it still could be changed. I've just updated the code above. A new benchmark on my machine shows now even more performance gain: the new code is more than 10 times faster than the original: 

As an exercise to the reader, you can similarly create a to avoid having to reimplement the function in every single leaf class. 

edit: This last approach also makes the trie operate on raw data instead of characters, which makes it encoding-agnostic (which gives you your unicode support) Avoid using shared_ptr unless absolutely necessary shared pointers are clunky and heavy affairs. On top of this, using them sends a message to people reading the code: Ownership of the object is potentially shared between multiple owners, which is simply not the case here. in your case, a is absolutely fine. Your root does not need to be dynamically allocated It's created at construction unconditionally, and destroyed at destruction unconditionally. On top of that, it does not make use of type erasure (polymorphism). As such, there's no reason for it not to be a normal member of trie. 

Which value does take for that second indexing? The C++ standard says: either the pre or post increment value is legal. You have undefined behavior here. You can solve this by separating out the incrementation as a separate statement. Using the evil comma operator would allow you to do it as a fairly small modification of your existing code: 

The code above is less efficient performance-wise since it does more - yet it is safer and much more readable (and IMO elegant :-)). Simplicity and readability reduces errors and thus testing and maintenance costs. If you refactor processing of the input parameters (validation, conversion into a map) and creating the String array out of the method it gets very short, very straightforward and more efficient. Since the input validation should be done anyway its cost shouldn't actually be taken into account. Now the command line processing is pretty ad-hoc, there are better ways to do it - for example using . 

The organization of your code seems strange to me: should be class or instance method of the String class or maybe neither? The method lies outside of the String class bracket, yet references private hash and . My throws a runtime error while trying to execute it. Then the code doesn’t properly handle invalid (non-roman) characters, it stops recursion because for the first invalid character the mapping will fail, in this case not the result of the canversion up to that point but the array of the ’s values will be returned, which is supposedly not what you want to achieve. After putting within the class frame and adding public before it for the code to execute: 

Better Solution So these were the intuitive solutions. However, is there some room for further improvement?. Obviously yes. The point is, that you do not need to store the same element every time because you know what the maximum is. You can circumvent this by using two stacks. One with the current maximum and one with the number of its occurences. 

your assert doesnt use the reference but a copy, so you should use In the equal case, i would make it actually explicit and do , which is the same pattern you used all over the code. It might be ok if your assert is used multiple times, but it is rather confusing, that you pass it i and j and i read only i in the code. Maybe use better names like Any reason you declare outside of the loops? 

So i think there are quite a lot of things to improve: Use more function. Your code does a lot of stuff within a single function. Separate it into specialized functions, that do only one thing. For example how to generate the alphabet. In your code you have this 

Review of : Prefer char* to void* when dealing with pointers to bytes refers to "literally anything" and is normally used when using dynamic typing. Since you are always passing an array of bytes, there is no dynamic typing involved, so you should use the proper static type: . It will also remove a few ugly casts from your code. Speaking of casts... Avoid using C-style casts 

Comment non-trivial algorithms: is funky enough that I had to squint a bit and take a quick minute to run the code in my head to even have an idea of what it's trying to do. An explanation of what each line is "supposed" to be doing would have been helpful here. Either name the struct type or the field name, not both 

Good job in general, mad props for proper use of vs . I don't see any "errors" per se, but I do see a few things I personally would have done a bit differently. Opinion: Not a big fan of std::exit() in anything but main() A function is supposed to be decontextualized, and having a "will crash the whole program if it fails" as part of the function's contract is just too aggressive in my opinion. Personally, I'd rather just throw an exception instead. It accomplishes the same thing, and it lets users of the function choose how to handle failures. Opinion: maybe have a separate prompt for failure? I would personally explain to the user why he is being asked the same question twice when the input fails to match either criteria. Opinion: std::transform is overkill here This is a personal bias, as I find in-place usage of uncomfortable at best, since a range-based for does as good a job in a much more legible manner. Specifically: Having to read the third parameter to understand that it's an inplace transform is just unnecessary cognitive load. I find the following easier to parse: 

meaning "find all groups consisting of one or more apostrophes and replace each of them a with starting apostrophe followed by the found group and an ending apostrophe". Now try to do this without a regular expression - it would require much more complicated code. All this will reduce the very act of processing the to a mere one liner if you exclude checking for null: 

I assume you get the arguments as a array - given the above you should first transform it into a - the most efficient would be an , but I would suggest using a which will preserve the order of the arguments. This will also validate the input and only accept valid arguments, thus preventing the program to crash because of an invalid input. Now what you actually do to the is basically enclosing a single or double apostrophe within a pair of apostrophes. There is a way to do it without iterating over the string variable character by character - use a regular expression, all you need is: 

Now this means "find all groups of single or double apostrophes and replace each of them a with starting apostrophe followed by the found group and an ending apostrophe". This works only for single or double apostrophes - so does probably the right thing for your use case. To enclose any number of input apostrophes in a pair of the same, you'd use: 

Do not use namespace::std; Google it or just drop it. Add all the necessary headers. You are missing string If you have to implement getter functions declare them const. 

What is the actual purpose of ? Generally i would expect that it tells me whether the data at position is valid. So a function like should simply set the boolean to false and not tamper with the data. Also your code contains an invalid memory access here 

With c++ you should stick to std::cin and std::cout instead of scanf and printf You do not have to set default values for variables you are reading anyway 

I think you routine is buggy. Also it will always return the first empty location after the first nonempty one. As an example look at , which is not the last empty location. Also from the name find empty I would expect it to return the first empty slot it finds. So if you really want the first empty spot behind the first nonempty you have to traverse from the back. Also you are inconsistent in your return value. If you found an unused value, you return , but if you did not found one then you return , which is off by one 

It's 100% clear that does not have ownership of the data, so accessing mutable data from a const span is absolutely fine in my opinion 

I think should be a free-floating function, since you already have the accessors. I would definitely try to format that fold expression in a more readable manner. See my version of it above for an example. 

Relationship between batch and single-call api Typically, when a manager class like like has both a single and a batch API call, the general function is the batch API, and the special case is the single-case. so it's the single-call API that should be calling the batch API, or the batch api should not exist at all. The reasoning is that normally, the batch API provides some kind of advantage on top of just calling the single call in a loop. If there is no advantage to be gained, then there should only be the single resource call function, and let your user write a loop around it if they need to call it a bunch of time. You want to keep your API surface as small as possible. Smart pointers Unless you are dealing with some very legacy system, you should have access to C++11. use std::unique_ptr<> instead of raw pointers, it'll massively reduce the amount of possible errors, as well as the amount of code you have to write. Avoid double lookups: 

Then i would urge you to define more classes that hold your respective data and apply some methods. Currently you have one class snake that does everything. It might make sense to encapsulate rendering into its own subclass and the snake itself too the same goes for the arena. 

This is one of the questions, that is directly related to the underlying data structure. So you can actually be quite sure, that this problem is best solved with a stack. The trick here is, that a stack ha$URL$ a well defined order in which the elements are retrieved. In that particular problem, lets say you know the current maximum of the stack. If the new element is smaller than that, you can push the maximum value instead of the actual one, as you are only interested in the maximum value of the whole stack. This is only true, as a stack guaranties, that the new element is removed before the previous maximum element. Only if it is greater you push the new element. This has the distinct disadvantage, that you do not preserve the original data. So there are two solutions, one for tracking the maximum element and one for also preserving the data.