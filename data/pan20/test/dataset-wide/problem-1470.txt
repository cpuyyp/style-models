My task is to create custom script to control PTZ (pan-tilt-zoom) cameras. We have an application for video surveillance but problem is that some functions are missing, like speed zoom out. Also, some cameras loses focus etc. My idea is to create appindicator to control cameras from there. Below is python script, and it's working, so my question here is, can I change this code a bit for a better performance or to improve something? I am not so familiar with python, so this is more like a test project for now. I am using API to control cameras from script. file: lib/Camctrl.py 

Which is an anonymous/unnamed return value. While your question is tagged C++11, I'll opine that it's a nice practice still to be aware of the newer standards and that with C++17 you're guaranteed copy elision. I suspect that compilers of earlier standard implementation are also likely more able to support copy elision when using unnamed return values. Copy elision tends to help with performance. Moreover, returning output through return values encourages value semantics, aids with constness, and I find it makes it easier for people to reason about the code. As to , I haven't seen it increase performance much of code I've used it with. OTOH, I love what recognizing code as means — computable at compile time — and I agree with Scott Meyers recommendation: use whenever possible (from Item 15 of his Effective Modern C++ book). A related nicety IMO is that types having constructors can then satisfy the concept. How to store the data that all are byte arrays, but some of arrays have fixed length (such as SHA256 hashes), and some have dynamic size (such as data)? I like how you've already done this — you're using for the fixed length types, and for the dynamic types. It's a preferable starting point so long as these types' access don't allow your data invariants to be violated. Prior to C++17, you may just want to update the type you're using in the and containers to . Since C++17, we can use for this type as one of the commentators suggests. Deeper in, you may need to answer whether speed is more important or data correctness is. A structure of arrays (SOA) often lends itself better to speed, while an array of structures (AOS) can lend itself better IMO to correctness. How to pass empty byte array? sha_t() is ok? It's not clear what you're asking with this question. Sounds like you may want to read about value initialization (introduced in C++03). How to deal with time and make code short and fast? Seems like this question is asking again about how to improve performance. If so, please see my response in that section. What SHA256 library should I use? The code from the most recent OpenSSL library is what I'd go with just simply because I suspect it's had the most eyes on it. If your code is license compatible, you may find it easier to just copy the OpenSSL code for SHA256 into your code instead of trying to build the entire OpenSSL library and then linking with it. 

Unique window name is required because there will no be two windows if two clients are opened from the same PC. CPU usage is very low, on my PC cpu usage is 4% when server have connection, and on every other connection which uses the same params, there is no update in cpu usage. Basic server usage: 

Worked with same IP cameras for some time, and noticed that camera use much processing power because of multiple connections. Writing streaming server looked as nice solution so I decided to write my own. This code is posted to my github page 

2. Recognize your code's structural invariants, and then enforce those using encapsulation. Take the class for instance. I'd guess that the field is dependent on the field. If correct, then make these inter-dependent fields private. Provide accessor methods for these values and a mutator method for the data field which updates the hash. If nothing else depends on the or fields, then I'd suggest making this tuple of info its own class and put the encapsulation within it. Then compositionally incorporate this new class into your block class. This way can still be a with its members publicly accessible. Use Non-Member functions unless the function needs direct access to the representation of a class (C.4). For my favorite explanation of what I'm suggesting here, please see Scott Meyer's article: How Non-Member Functions Improve Encapsulation. 3. Prefer value semantics over reference semantics. You haven't shown any code which exemplifies reference semantics but for the sake of C++ developers everywhere (or at least for my preference), please keep with value semantics as long as you can: don't expose to your API any classes that inherit from other class (see inheritance is the base class of evil). How to improve performance? Use constexpr or something else? 

Don't reuse to be the index of the loop. It's confusing. It violates the meaning of start. The lengthy parameter parsing is good, but can be made more clear. Don't waste time on checking for or . Just use the statement. 

These aren't "utility" functions. They appear to be central to your app. There are rarely "utility" functions in any app. What we used to call "utility" functions are almost always part of a standard library. 

Do not use a database for this. Use files. A single file with one tweet per line showing User Name, Tweet Text and whatever other information you have. You need to sort the file by user. Use the OS-level program, don't write your own. Once the tweets are sorted by user, you simply read and count. 

I recently started to work with python and came to idea to automate process of looking for new jobs. There is nice website and I managed to get content, because they use angular to render webpage and using just gives no results, because page is rendered using javascript. Below code is functional, but a bit slow, it take about 10-15 seconds to get rendered page. Full process include going through all job ads, get title,description,link, etc, and check local database to see whether this ad already exists. If not, new mail is sent through mailgun. Any suggestion is welcomed. 

Regarding "best practices", I'd recommend checking out the C++ Core Guidelines for suggestions like: 

Reduce the number of conditions/loops. The whole method is doable in a single loop. See below for an example. Prefer nouns for names of variables and verbs for functions/methods. For instance, instead of calling the return value , call it . Refactor the code to handle the connection getting closed before getting all of the expected bytes. According to a Microsoft Winsock web page for the call, "If the connection has been gracefully closed, the return value is zero". At which point I believe your code will try again and get (with an error code of ). And then return false even though it may have missed only say the last byte expected. Recognize values that are constant with the C++ type qualifier (or as you've done for compile-time constants). Seeing as how you used (available since C++11), go ahead and also prefer using . Consider making the method a method of a class that the client can use too (I don't demonstrate this though). 

Camctrl have a task to execute command. It accepts last part of IP address, as well as params (one command is string, multiple are list). file: lib/Gui.py 

This is started as a simple project, because I don't like software I'm using. Not that they are not good, but I wanted some custom stuff, so this little project started. This part of project is for live viewing while archiving is done with opencv (not shown here, I managed to get this work). I am very new to python, but I managed to build this GUI. My question for you is: Is there anything I can improve? I am satisfied with CPU and memory usage (15 cameras in view are using about 100 MiB of memory). First approach is made using opencv, but with this I lower the resource used. There is known bug on line 174, when one image is shown, picture not fit the view until 'right-click' ( action) is called by user. So solution for this will be helpful. 

Avoid trying to build a "mutable tuple" as a fixed-length list. Either use immutable named tuples or a proper class. 

This can't work unless you stipulate a specific size for the partition and do not grow it. You can't discard any value from the input sequence or you won't get the actual maximum. The fact that you're popping a value means that you may be discarding a proper part of the solution subset. Consider a slightly contrived example where X = 0.25. The initial state is to process 1/X items (4 in this case) of which 1 is maximum and 3 are discarded. The values were 100, 99, 98 and 97. You keep 100 as the 25% maximum and discard 99, 98, 97. (You could try to keep all 4 or even the first 25 values. It doesn't matter how many you keep initially, the logic problem will still arise as soon as you pop a value. I think the contrived example makes the logic flaw easier to see.) At some point, you've seen 7 values. The maxima subset has 1 value (100); the remaining values (99, 98, 96, 95, 94 and 93) have been discarded as not part of the maxima set. You get value 8, it's 92. You need to append this to the top set. Yet, sadly, you discarded a value larger than this. When you get to value 12, you again need to expand the maxima subset. However, you will have discarded values that may be larger than the 12th value in the sequence. You cannot do a from the maxima subset unless you can prove the value being popped must be less than all future values which may arrive. 

Instead of naming a bunch of elements that are all the same type, use an array for your structure's elements like , or use a . Or if you really don't want to change your structure's content, use to craft a of your structure's elements on demand. If you used a regular array use on the iterable elements of the two structures. A or already has non-member function support for operators like , , , etc. though. Kick back and enjoy a brewski. ;) (only if allowed of course and be sure to drink responsibly etc. etc.). 

It extends an existing partition on the low end or high end. The number is adjacent to exactly one range. It creates a new partition. The number is not adjacent to any range. It "bridges" two adjacent partitions, combining them into one. The number is adjacent to two ranges. 

It's (often) slightly faster in Python to avoid the statement. After measuring that with , you should rename the variable . That's a poor name. 

This is a pretty radical rethinking of your algorithm, so it's not a proper code review. Assembling a string with separators is simpler in Python. For your example of ","-separated strings, always think of doing it this way.