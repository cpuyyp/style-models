Your algorithm is pretty hard to follow, at least for me (I am no expert in graph theory). If you add some local variables with descriptive names - that might help. For example, instead of writing: 

I don't like property, as it makes things ambiguous. Is it safe to call ? Or will I modify some existing static field? Well I will have to go and check the implementation to know for sure. I would rather just call instead. Or if you have something against using default constructors. I think you should merge and methods. It doesn't look like does any meaningful work and you can easily declare array inside . Also since you already check for string being null, you might as well return early by calling: 

waht happens to reference? members in class do not make much sense (consider making those ). Your class should probably extend and not encapsulate it. This way you can drop all those proxy methods and therefore reduce the amount of code. Edit2: i think using arrays in class is an overkill. You'll end up re-writing implementation. Resizing is the only noticable performance drawback of but that is not going to happen in your case (since you specify the size in constructor). The rest is unlikely to become any kind of bottleneck, so you probably want to keep it simple. this should probably be a parameter rather than a constant (at least as a user i would like to be able to set up the size of a node) 

Create a class to read the data source, write the data to buffer and notify your application when the complete message is read. Currently, you are constantly "analyzing" input, even if no new data is received and there is nothing to actually analyze. This will eat up both a CPU core and phone charge even though no useful work is being done. What you should do is put your thread to sleep and only wake it up, when complete message is received. This is a classic producer-consumer problem, you can look up a C# implementation on the internet. You should also gracefully terminate your analysis task when your application shuts down. Don't just leave it there. Create one class per message and encapsulate the parsing logic there. For example: 

EDIT: P.S. I dealt with serial port quite a while in the past and I can tell you this: I have never ever been able to make method work the way I want it too. There is always "something", seriously. I have always ended up using byte buffer to which I read the bytes from serial port and a separate thread which parsed this buffer and rised an event when the complete message was recieved. So... I wish you luck :) 

The only way to quickly get the last index is to store this index after each write operation. Other approaches will not, quote, "pull as much performance as possible". I have a feeling that this problem you are having is a symptom of a much larger design issue. In general you should be able to just pick a correct data type, in this case it's , and work with that. You don't have to come up with your own ill-thought-out implementation. 

You don't show your business logic and you don't say what kind of processing you are doing, so it's hard to tell whether inheritance is the best approach. It doesn't look like it based on your examples. Maybe it is better to have a single class that would contain all the boiler-plate code you require (similar to ) and inject as delegate/interface instead. 

The second version is over-engineered in my opinion. The code bloat it introduces is obvious, the benefits are not. I think this api: 

It is not clear what problem you are trying to solve exactly, so it is hard to give a more specific advice. Hopefully this will make more sense, once you wrap your head around MVVM. 

Calculators implement deduction rules. Should they, really? How would you re-use a rule in different implementations? The answer is - you copy-paste, as you have demonstrated in , and . A better approach, IMHO, is to come up with a common rule-set and reuse it in your calculators. Say: 

If method is only called by the service that watches files and should not be used by consumers, then it should not be available to them as public method. The easiest way to achieve this is to inject interface instead of implementation: 

This does not answer arguably the main question one would have: what does it mean for one array to be "larger" than another, when both have equal size? Do you compare sums of the elements? Do you compare first non-equal pair of elements (looks like this one is correct)? Do you use some other even less obvious criteria? You should explain this in above documentation, so it is not necessary to read through obscure boolean logic in order to get the answer. 

To answer your question: those solutions are identical performance-wise. There is no "magic" in or methods: they do the same thing you do in your first solution - compare the two values using operator. There is no significant performance cost for a method call or for an extra assignment - those operations are so cheap, that you won't solve any real-life performance issue with this kind of optimization. If you will become obsessed with those small things - it will have a negative effect on your code quality. So, instead of asking, which is faster, you should ask yourself which is more clean, readable and OOP-ish. I would go with second solution. If you want to really speed things up - you should first identify the real problem. In your example - it is the number of iterations, not the number of assignments. So the faster solution would probably involve multi-threading and iterating through different parts of your array simultaneously. 

If you are looking for ways to optimize your application - you are clearly looking at the wrong place, at least in my opinion. is a simple wrapper around actual stream. All it does is it converts simple types to byte arrays and writes those to stream. Ofc it is slower, as any other wrapper, but not that much slower. In real life this difference can be ignored. If writing to is your main performance issue, then consider wrapping it with . If it isnt, and you are simply curious... then you can always use disassembler to see whats inside method for yourself. 

And initialize it in constructor. It is cleaner and requires less code to write. Also you might want to create another constructor for your command, that passes for by default. 

As for implementation - caches should be implemented on repository level. That's one of the main reasons why people bother with repositories in the first place. Whether and how queries are cached is an implementation detail of repository, it is not consumer's responsibility to cache results in simple scenarios. You can also eliminate copy-pasted code in your methods, if you utilize generics, since it boils down to: 

First, I think you should carefully consider whether you actually need those optimizations. Debugging and maintaining multi-threaded code is a lot of work, and you don't have to make it harder unless there is a good reason for it. If you need a pool, does it have to use and ? Is simple too slow? Is too slow? You should start by trying the simplest option first. Only when you have objective proof that simple options do not meet your performance requirements you should consider more complex solutions. It looks like you are doing it the other way around. Potential design issue: in order to release a pooled object I have to have a reference to the pool it came from. In some cases this reference might not be that easy to get. Potential design issue: your pool does not count references. If and ever get a reference to the same pooled object, it is going to be hard for to release it without risking that it might still be in use in . 

This is because when you write to dictionary it can,for example, increase the size of underlying collections or reorganize internal "buckets" where items are stored. Those operation will move items around which can break a concurrent read operation in unpredictable way. Enumerations on the other hand will throw straight away, if you modify the collection during enumeration process. The bottom line is: your (read) and (enumeration) are not thread safe. You must synchronize them with your method if you want to read and write concurrently. 

If this control is intended for widespread use, then the main issue is poor support for customization. is not gonna cut it, as soon as I want to use my favorite gradient brush as background or change border color based on importance of the step. Even if you support that, next thing I am gonna ask you is "hey, I want to make this close button look just like this other close button in my metro-style application, how do I do that??!". Then I'm also gonna need to write different text on buttons depending on current step. Then I'm gonna need a button of my own. Etc. I guess my point is, if you are going to write a library for WPF, then you should support one of the key WPF features: custom templates. property is a half-measure, it's just not enough. class should be a fully customizable , which I should be able to declare in xaml and style however I want. Your current approach would be fine, if you were writing this for one-time use in your own application. But if you are writing a reusable UI library, then it's "go big or go home", IMHO. :) As a result you have a poor MVVM support. For example, instead of calling method for some step, I would rather bind to a command on my element in XAML. But I can't do that. I also don't like static classes. Why do I need a static dependency in my code just to set command? Why can't I set this command directly on my instance? Another issue is that its hard to customize a tour. Lets say I have a plugin-based application. It will be really tricky to include only enabled plugins into the tour. If every plugin I have could somehow "add" or "register" its "steps" within existing tour, that would be awesome. But it looks like I can't do that easily with current API, as it asks me for fixed predefined list of steps in order to create a tour. As a final note: I like the idea, and I would consider using such library in my projects, but not if I can't re-disign those popups to fit into existing themes. Oh, and I guess it should be either or . 

To make the code flow more obvious and your code style more OOP-ish, instead of nesting methods in each other you should call them sequentially, so each method has single responsibility: 

I am still not convinced that all this boiler plate code is worth the effort though. But oh well. :) P.S. I think your Fibonacci sequence implementation is a bit unconventional. There is no "step" in classical implementation: 

The general issue with your code is that your client and server implementations reside in your control's code-behind. It is always a good idea to separate business logic from UI. This is copy-paste: 

You do not pass this value through views. There is no reason to make your views responsible for creating view models. For example this: 

Yes. Unless you are having a bunch of really small classes, you should try to have one class per file. 

But only a bit, both versions look fine. The only thing I don't like is in the end. You should probably keep your tests as small as possible and create separate test for part(s). P.s. Also it's worth mentioning, that most unit-testing frameworks have some support for test cases. In NUnit, for example, you can write: 

Yes, I think it would make more sense, if you have all the required information to construct new animal. If you don't - you should consider moving this logic to game system that would manage the breeding and that would have access to both instances and to your world state. 

It adds an overhead of returning value, but if the you benchmark does any meaningful work whatsoever, it shouldn't really affect the result given the fact that benchmarks are not that accurate to begin with. But it is probably something, that you might want to... benchmark. There are definitely other (probably less pretty) ways to remove copy-pasted code though. 

In your original code (as well as in Abbas's answer) enum value is being converted to string and then this string is parsed back to get the value. That makes no sense. 

What are you trying to achieve by locking statement? It feels like you are misusing the , because default event implementation (when you declare event in a field-like fashion) is already thread-safe. You can just declare: 

This will enforce every descendant to override it. Note, that there is no public setter. It should not be possible to execute this code: 

Is there any reason why you can't use the standard WPF filtering? At first glance your code looks extremely complex and bug-prone. I think you should keep it simple and use the existing abstractions instead. In your case I would go for something like: 

If you want a pretty solution, you would have to separate your data source ( in your case) from data processor (your loop), hide implementations behind interfaces and then wire those interfaces together via events or aggregation. This is actually a pretty common problem called "Producer-Consumer", you should be able to find multiple decent implementations on the net. If you want a simple solution though, yours is probably fine. A few things you might want to improve: 

You can drop equality checks in since callback only triggers when dependency property actually changes. Your properties can use a better naming. doesn't tell me anything. I can already see that the property returns and I can see that it is an attached property. What I do not know is its purpose. Use property name to tell me that. Your class wont work if I set from code. This is counter-intuitive. Either make the setter private or make it work. You are leaking event handlers. Which might not be an issue for your current use case, but it can quickly become one, once stuff gets serious. Either use weak events or unsubscribe manually. is a really poor choice for a base class. There are two main approaches when it comes to controls, that host multiple children: