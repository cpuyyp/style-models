Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function. 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example 

Discussion: first of all, please note that the above code is rather a proof of concept and not a full solution. Besides the missing effects (which you can add if you choose to extend this example ;) ), it can be improved in many ways (e.g. not putting game state and functions into the global namespace, but rather enclose them in an object). That said, let me point out the advantages of this solution: 

Background Linked lists are a well-known data structure, so I won't waste too much detail on them. Suffice to say that a linked list consists of "cells". Each cell contains some kind of value and a reference to the next cell (except the last one, which contains an empty reference). I implemented a linked list in Clojure as an exercise. The code 

If I understand correctly, the program counts the occurrences of some words in a file. I have the following observations: Error handling I would recommend throwing exceptions instead of/additionally to writing to cout and cerr (btw., I think if you do write to these streams, you should stick to one of them, most probably cerr). EDIT: Note, that as the constructor is written currently, we can end up having an object in an invalid state after calling it. This would be prevented by throwing an exception. Encapsulation, state of the class I suggest making setWord private, or at least protected. As it is now, one could call: 

You can simplify the last part (getting the original stack back) a bit, if you use another stack, instead of the queue. Then, you can directly read back the elements of the second stack, and put them back in the first stack. Something like this: 

Possible improvement You could even further improve either your solution, or that of the book to use dynamic allocation (malloc/realloc/free) instead of fixed size arrays. 

What this means is that when the comparison fails, E is updated to the current value of X. If the comparison succeeds, X is updated with the value of N. Therefore, you don't need to update X again! That is the whole point of a compare/exchange operation; you're basically saying: "I was the last to modify X." Issue #1: Unsynchronized access to writer In your code, you perform a store to the atomic variable with a copy of a value you last obtained from the update performed in the compare/exchange operation, but this is not atomic. 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

Basic algorithm Since you have very large files, you should consider streaming the file one line at a time instead of loading them all once; your program would use a lot less memory. You would also not have to copy your , which is very large! In order to know which files you've already processed, you could create a new file that holds a list of all the files you've processed and write to it as you stream from the original file. This is of course, assuming you want to keep the original file intact. I will continue under this assumption as the other case (simply delete from the list as items are processed) is simpler. Check the Notes section for a better idea that you can implement with inspiration from the following section. Implementation The following is a sample implementation for the algorithm I described in the previous section. For brevity's sake, I did not include the items mentioned under the Form section, nor did I include exception checking; I will leave those things for you to figure out. It is also most likely not as optimal as it should be, but it's merely meant to show you streaming. Sample 

Although lines (1) and (2) do look right on first sight, due to indentation, they are breaking the if-else statement. This kind of issue can be avoided by always adding braces. 

With the current implementation, this will return an empty result: . Now, with the semantics that the name of the parameter implies, this should be correct (maybe an exception could be thrown, but that is only detail). However, wouldn't it be nice, if the signum of could control the direction, in which the first coordinate grows? Something like this: 

I especially like the point of @Mike, namely that you should generalize your code. I would suggest taking this idea one step further, by having the situations and the choices in some data structure (e.g. JSON) and having only a single div, where to render the text and the corresponding choices (as opposed to one div per situation). To be more concrete, I am thinking about something like this: HTML: 

So, I am asking if there is a better way, to compare two sets, providing a custom function for equality checking (in this particular case, this custom function would be ). I am thinking of something like this (pseudo-code only): 

In Java, Strings are objects, and thus the comparison with the operator checks that they are referring to the very same object, which, in this case, is of course not true. You should use the method instead, like this (not tested): 

I think the logic for getting the minimal distance between the points would work even without the explicit check against MAX_INT: 

The code N.B.: I include only relevant portions. A full, working version can be found on GitHub. As external library, the code uses Guava. (And JUnit / Hamcrest for testing.) Implementation 

To indicate that the first three files have been processed. You would then only have to check the first character of every line you read, instead of the whole file name, to know which files have been processed. This is the technique I would personally use, as it doesn't require an extra file and it keeps the original file mostly intact while providing a much faster comparison. 

You can expand on this by providing functions that use the "Error hiding pattern". That is that they return a to indicate whether the input operation succeeded or not, while the result is stored in a reference parameter. Other isn't the only object that can be streamed from. For example, you can also stream from files. You should provide a way for users of your function to specify what they want to stream from (this can be as simple as having a parameter. 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck.