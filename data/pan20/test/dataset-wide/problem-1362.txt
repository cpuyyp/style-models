is being called twice, so you can assign it to a variable to remove one of the calls. Since we know there's only one per line, we can use to find it, and to extract the relevant parts of the string. This may be a little bit faster than calling . 

My guess is that the timer used for summing the values is mistakenly including the time taken to fill the cache. 

but I would probably recommend not overriding and for this class, if you don't have a good reason to do so. 

If you don't want to go to the trouble of implementing a skip list, I think you can fake it with a combination of and . I couldn't find guarantees of the run time of the relevant operations on MSDN, but it runs much faster on this test input: 

Let's think about the following input: $$ 2, 5, 1, 10, 3, 11 $$ The first plant will never die, and the second plant will die on day one. For the third plant, we look at the previous two values and see that they both have more pesticide than the third, so the third plant will never die. The key here is that we can now forget that the first and second plants ever existed. Why? Because any plant waiting for the first or second plant to die will have to wait for the third plant to die first. The fourth plant dies on day one. For the fifth plant, we look at the previous two values, 1 and 10. The fifth plant will die a day after the 10, and again we can forget the 10 ever existed, because any plant waiting for the 10 to die will have to wait for the 3 to die first. 

What's the expected output? The question is maybe underspecified for the first case (I would say it's 0), but the other two are clear: 0 and 2. But we get: 

I used the module to compare the running times of this version and the original for different input sizes. The functions were each called 1,000 times on randomly shuffled input of size \$n\$. Here are some of the results 

One benefit of this solution is that you don't need all the strings in memory at once. For instance, you could use this method on the contents of a file, without the entire file in memory: 

I would very strongly recommend against using a regular expression for this. There is no clear mapping between the list of requirements you posted and the code. Imagine another developer looking at this. Are they able to deduce the list of requirements? Given the list of requirements, are they able to verify that the regular expression is correct? How long would it take to convince them that it's correct? In fact, it's not correct. The character class is not the same as (unless you specify ECMAScript-compliant behaviour), and your regexp matches the username (that's an ). (It doesn't match on the link you posted, but that's a Ruby, not .NET, regexp tester.) Now suppose one of your requirements changes -- this code is going to be tricky to maintain. Instead, I would recommend writing a series of tests, each corresponding to one of your requirements. Here is the code I came up with. It still uses regular expressions where appropriate, but very simple ones. 

Let's set up code to benchmark different approaches. Every word counter will implement this interface: 

This field can (and should) be made private. We don't want strangers messing around with our rovers! While we're at it, let's change the name from to -- we don't need the name to reflect the fact that it's a list of rovers. Finally, we can make the field . 

until you realise that it only has 79 characters. You would want to measure the performance, but I would suggest not using a regex and writing a simple method, like so 

A new instance of is created, with a new, empty . An item is added to that list, and then goes out of scope and is later garbage collected (along with its ). This code effectively does nothing. 

As the digits are 1-9, there's no way to represent 'j' (10) or 't' (20). I'm guessing that's a mistake in the question. 

So where does a segment start? It starts at the sum of the previous lengths. We can use to calculate the partial sums of the lengths. This gives us the final solution 

Documentation This is quite a lot of code. I can tell you've put some effort into the naming of methods, but comments describing the purpose of each would go a long way. Imagine that you're looking at this code for the first time -- is it clear to you what the output of a call to should be? What conditions will hold on the result? For example, I believe the following are true (correct me if I'm wrong) and worth documenting: 

I might be missing something, but from what I can see is only ever used by , and can be removed. Consider making protected, since with the implicit operator I don't see how exposing it is helpful. Consider exposing operators and to make composition of more complicated specifications easier to read and write. Here's an illustration of how I'm imaginging it: 

and are much easier to read than and . Consider using multiple return statements, instead of just the one. Stick to the naming conventions: change the parameter to , and the variable to . It's a good idea to document that this is relative to UTC time, otherwise users might get strange behaviour like this: 

Of course, for many applications, 2.5MB is just a rounding error, but sometimes it matters. I'm just trying to reduce memory usage as a learning exercise. 

You can remove the variable , which I believe makes it cleaner (though possibly at the cost of some performance). 

While we're at it, it should be more efficient to use the overload of that takes an , so we're not making lots of throw-away strings: 

really made me wonder. You're threading this object through recursive calls to hold the answer. Instead you can remove this class and change your methods to return an : 

You might want to check the parameter in to check that the card is not null, is not already in the deck, won't make the deck have more than 52 cards, etc.