(spacing to demonstrate relationship to terrain_map) With this array you can start with any coordinate and convert it into an index in this array via a the function and back with its inverse function. Once you have that you can move up or down by adding/subtracting and left or right by adding/subtracting from the index. Since this array is a padded version of the map, you never have to worry about wrapping around because you cannot move to these fake coordinates that make up the padding. This may or may not wind up actually being faster (it depends on how big your maps actually are and how easy the set of paths were to compute in the first place). code: 

ignoring immutability and such (like having a getter and no setter for FlatSideArea that computes on the fly)... What you are basically implementing here is an internal usage of the INotifyPropertyChanged interface. If you are going to implement that interface, I suggest you actually do so instead of only sorta partially doing so: 

However I know this function has a bug: javascript can have cyclic references (causing infinite recursion). To fix that I need to either limit the traversal to a particular depth or check if I have already visited an object. Here I'll do the latter: 

and refactor accordingly. Beyond that the only suggestion I would have is perhaps some better variable names (at least use a single naming style; if you don't already have one, use this: $URL$ 

The bigger issue here is that I am not sure if reading this stream async will get you anything. The blocking operation here is the out of process request to write the data to postgres. I am not sure a controller is ever waiting for input data. It comes down to considering what is doing for you. allows you to take an already blocking operation you do not have control over (a network request for example) and free your thread to do something else while that is waiting for a response. This means that if your application was sitting at 100 requests before async and most of those requests are spending most of their time waiting for the database to respond, you could switch to async code around those database requests and now all of that time you were sitting around waiting can instead be used to queue up more requests from the clients. 

and so on for attaching events, setting DOM properties, making ajax requests, etc. Then in you would check if the object in has a removeReference function; if so run it then delete it and the object. 

I have made the arrays into objects so that it this is easier to edit. I doubt it makes enough of a difference to be noticeable. That is, I replaced with a structure . It may be worthwhile to change them back though. Reduce comparisons by navigating a 1 dimensional model of the map instead. When you call you can generate a set of for a given map. For the terrain_map provided and a mobility index of 0, this would be the following array: 

In response to the comments: This is very similar to the code you initially put up. I derived it again on a gist using the code you put in your question here (slightly different from the code in the fiddle): $URL$ Clone that repository to see the full history. 

While the use of high order functions in JavaScript is fine and normal, your code has other issues. Symptoms Your usage of the method here is to do 3 things: 

None of this code needs to create any global variables. The pattern you have here is known as namespace creation. It often follows the pattern: 

JsFiddle to show it works. Interestingly this version is also about 20% faster than the original code. (see: $URL$ 

This code looks mostly fine to me, when the method gets called, gets moved to and then when happens, gets deleted (and eventually garbage collected unless a reference to it continues to exist somewhere else). However I think you could do better by encapsulating each route in a function that takes care of and for you. Something like: 

In these cases, you would need to do more than what you are currently doing in your method to take care of unregistering these functions (In IE7 and below). My perspective would be just to let it leak (tell the users to get a better browser). IE6 would leak until the browser is closed, IE7 would leak until the page is out of the navigation cache. In every other browser, once the DOM is detached (or the timeout occurs, or the ajax post happens, etc.) these functions are not reachable from the global scope anymore (and so they are removed in the next garbage collection cycle). Cleanup in IE Essentially what you are doing in is move the stuff you want to delete in the previous route to and then in you take care of deleting the old references. Really the only things you should care about are those properties that you cannot actually get at via variable properties once set. Whenever you do a (or similar) you would want to do something like this: 

every time you call , jQuery needs to do some work in the background to figure out what you mean in the string. You can instead cache these items and not need to depend on retrieving them repeatedly being fast. In this case it doesn't make much of a difference, but eventually it will cause your page to be slower. There is too much extra junk in the way to make it apparent what is doing. A good rule of thumb is to wait a week, then if you cannot glance at a statement and know that it is both in the right place in the function and what it is doing then something is too complex. While your code is probably sensible to you right now I am willing to stake the claim that in a few weeks/months when you go to add some other functionality you would waste some time trying to figure out what this is doing. 

The controller is vulnerable to automation. If I can discover a list of user ids I could create the following html page: 

It would be better code to have cases 1 and 2 be the same method call, differentiated by a parameter. In this case I would use . In general it is better to say what you want, rather than how to do something you want to do. This is because the details of how to do something tend to change, while the logic remains the same. To complete this separation you now should use some function that checks the state of this item; enter in this case ; thus those 3 uses become: 

Another change you could do to make this appear smoother to the UI would be to make it async. Instead of the loop (reminder this will require changes elsewhere): 

show the element hide the element (more precisely: exact opposite of state 1) enumerate the state of the visibility of the element (check if it is in state 1 or state 2) 

(unable to check correctness right now due to not sitting at my work machine, but barring any syntax errors I think that is right) Am I doing something wrong here? I think a static constructor is fine for the singleton pattern as well, but I am not 100% sure it covers all thread safety issues. I don't see how a single lock object wouldn't though. 

This implementation (whether or not you pull out the functions is irrelevant to this single use) will let you manage inheritance properly, but it does have some inefficiencies (setting radius raises the event 3 times, similar to how your implementation does). If you weren't concerned about inheritance you could simplify this by not bothering with the change event and modifying the private members outside of their own setters: 

+1 to this code looking fine as is (with caveats and one issue). Issue: You should always quote class as it is a reserved word for future use in javascript. Don't take this as me advocating you use it or saying it is ready for production1, but I'm using JsRender in production to ease much of the pain you are seeing/imagining here. I think the central issue here is that this type of Javascript invokes a hard dependency on the structure of the page and so we look at it with a bit of queasiness that it rightly deserves. If your visual designer comes along and decides that the shopping cart needs to be in a dropdown list where you can drag (or swipe) items out of or into now you have to go and make a whole bunch of changes all over the place. Unfortunately I don't think it is reasonable in a modern website to expect both that the html has no dependencies on the Javascript ("page works without javascript") and that the Javascript has no dependencies on the design of the html("javascript works equally well on a totally different design that happens to have a couple of the same named elements"). I personally am comfortable ignoring the former to get much closer to an ideal on the latter. That said, my working environment is such that I have very little control over the redesigns that happen all too often in the products I work on. At a minimum I would strive to make sure this code stayed together inside its own function at or near the top of your javascript (or in its own global/namespaced function in the html file itself). This code has very little to do with your logic and a lot to do with your site design. Therefore it doesn't belong sitting alongside your page logic. On minification (for this code in particular) I am less concerned. A solid minifier is going to combine your statements, rename the variables and possibly inline them and then remove whitespace. If you were concerned about this, you could inline everything yourself (and you would lose a little on the readibility), but the gzip of this even uncompressed is only about 480 bytes (closure compiler adds some stuff before it estimates) so at most you are going to gain maybe 100 bytes (closure advanced gets 140 but the result will not work; I can manually do it and get 145 off; none of these numbers will mean anything in terms of page performance for your site). FWIW, your original code was only 332 bytes zipped (smaller than my manual attempt) and compressed (manually) down to 297.