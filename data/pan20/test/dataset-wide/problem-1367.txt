A big problem with your current function is that to output several HTML tags, you'd have to write things that actually belongs together very far apart. For example: 

Using streams is not always the best option. Using a greedy algorithm you only have to loop through all your persons once. You can even implement it in such a way that you don't even have to save all your persons at all. So what do we need to keep track of, then? 

Reusability If you want this re-usable, you might want to not have all the methods static, so that they can be overridden for example, and you might also want to look into using the Strategy pattern for the method. Appending zeroes 

Does it really matter that the words comes in a list? How about a ? Or, actually, how about ? Iterable is after all what defines the method that you are using. 

I do not consider your class useless, I have actually done a similar thing myself. Very similar actually. Perhaps even exactly the same, pretty much. Overall, your code is very well-written. You use and where you can, which I like. 

Side note: The only method you have that is actually useful is . Otherwise it would be easier to just use or . However, I understand that this is just an exercise in which case it's fine. 

You manage to do the right thing, but the way that you do it is a bit... what shall we say...? twisted? backwards? non-optimal! Your approach: 

And viol√†, you have flipped x and y! In other places you are doing but here we have . Thanks to how Tic Tac Toe works, you won't see a difference, but it is still quite important to be consistent. Also, when changing to using an enum this can become 

When dealing with sorting algorithms, it can be useful to add some more detailed logging so that you can see what is going on. I created a JSFiddle where I added some logging so that we can see what exactly is going on. The results of these loggings indicates a problem with your code: You are accessing index and index at times, which only contains data. Your for-loop loops over one element too many, it should be 

This is honestly pretty good. I usually use to set the paths and configurations on require (it's going to grow a lot as you add things like shims, urlArgs, etc). You will also probably want to reuse it in several places. See my blog article on how I recommend doing this. The general idea is that you don't use to bootstrap things, you instead have a request for the configuration file and another to actually bootstrap the specific page of your application. Next, I'll ask why bother injecting and manually into ? Injecting dependencies is what RequireJs already does. app.js 

Usually I see tuples in js implemented with arrays though of course an object - while annoying to write would be just as valid: . So for this sort of use-case (creation and light usage of a bunch of temporary objects) I'm curious if there's a significant performance difference so I set up this jsperf. Object tuple test: 

While this is the simplest and is certainly acceptable architecture it is always a good idea to also consider Composition over Inheritance So instead you might do something like 

In short. No. The mapping between object properties and fields on the form has to be somewhere. What you could do though is to set it up by convention. So if the field on the form had the same name as the corresponding property on the object you could use reflection (or a tool like Automapper) to do that shifting. In pseudo code (because I don't have a set up .Net environment in front of me right now) it would be something like: 

First, unless the module is about force times distance in a physics simulator, it is a terribly over-generic name! What does the name communicate to someone who is sitting down with your application for the first time? Name modules after what they do and be as specific as possible but not more so. Second, if you're only exposing a single method in that module just return that method directly, no need for an object. Next, won't your scrolling handlers depend on a specific structure being present already? You might want to make it explicit. I can't really make a recommendation how without understanding better how you plan to use this (I'm really confused what could possibly do). As for where key navigation should go, it really is all about naming. So if you view the arrow key navigation to be a part of the grid scrolling then yes, it should be in the module that sets that up, otherwise it should not be. Finally, What if you have two grids on the same page? seems like you're trying to apply a lot of stuff globally? Perhaps your modules can accept the grid you want to modify as a parameter? 

The code has a lot of conditionals which could be refactored. Any suggestion on making the code a bit cleaner and concise would be helpful. 

The approach was a pretty straightforward DP implementation which is in terms of space and time complexity. My solution took about to execute all the 1183 test cases while I saw solutions which executed in about in the same language. As far as I know there isn't a greedy solution to this problem, only approximations algorithm exist for this. Can you suggest if there exists a solution with better time complexity for this problem or if my implementation has some redundant initialization or iterations which slow it down. 

The idea behind my solution was if at each iteration we have the closest triplets we will be able to get the optimal absolute minimum. I couldn't find a clean way to implement this logic. And my solution is this. 

Could you please suggest how to avoid excessive statements in the solution. Also, this solution wouldn't be scaleable for more array's so a more general approach would be helpful as well 

The approach used is very similar to the way one would do this by hand. This solution looks like it has a lot of if/else statements. Could you please suggest a cleaner way to write this solution. 

Load the task by it's occurrence in a queue While the number of distinct tasks is greater than the period we pick the number of tasks with highest occurrence and decrease it by 1. If the number of distinct tasks is less that the period then we multiply period with the highest occurrence of the task. 

I am not sure if my solution uses the right data structure in the correct way. As inserting back into the queue requires me to store the -ed values in an temporary array and then insert it back. Could you review this code for the right usage of data structures.