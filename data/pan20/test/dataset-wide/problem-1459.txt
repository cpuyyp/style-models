That's it. I don't see how we can leverage any other built-in method to shorten above task. Using JavaScript's built-in gets us pretty far, but it is missing timezone offset and millisecond options and introduces unwanted separators: 

to mitigate timing attacks. Reason: The public function should only return one information - whether the password and the hash match or not. But right now, it leaks more information to an attacker who observes the time this function takes to complete. Whether or not that information can and will be used to the advantage of the attacker is dependent on many factors (e.g. preimage attacks) and unless you have taken all those possible factors and scenarios into account, you better use the safe and simple . 

You can avoid use of by using as the key type in the for keeping track of occurrences of elements in the container. 

is not right. can be executed first, last, or anywhere in between. The standard does not specify the order of evaluation of arguments. Also, you are incrementing in that statement followed by: 

Since you are dealing with only integral numbers as input from users, I would create a helper function to get input from users. 

Remove unused functions and member variables is not used at all. is not used. is not used. There is a function local variable of the same name in but the class member variable is not used at all. is not used. There is a function local variable of the same name in but the class member variable is not used at all. is not used. There is a function local variable of the same name in but the class member variable is not used at all. Replace hard coded numbers with suitably named constants You have: 

As already pointed out, you need a more sophisticated approach to testing runtime performance of runtime-optimized code produced by modern JavaScript engines. I compared the performance of your datastructure against the built-in as well as plain objects on the well-known performance testing playground jsperf.com based on the benchmark.js library and got the following results on Firefox 53 / Ubuntu: 

See $URL$ The JavaScript specification doesn't mandate a specific implementation for , but I assume that the chosen string searching algorithm comes with higher setup cost but better runtime complexity or simply benefits from its native implementation speedup. 

Even better, use the newer and more explicit method. However, this changes the semantics of your code due to the different handling of : 

The other point is that you need to move this check inside the subsequent loop. Otherwise, the conditional will always evaluate to false since has been initialized to . Updating Inside the loop, you have: 

Make a of does not need to be exposed to users of . It's best to make it a of the class. Don't hard code as the sole target to output It will be better to provide an function to output . 

Decide how to deal with use of If you use , the function will always return . For that use case, there is no way to tell whether a function returned with success or failure. One way to deal with the problem will be to prevent use of using . 

Suggested Implementation Write a general purpose helper function or use a library which already includes one. Such a function would group array elements by their label or name. The user supplies a callback which returns the label or name for each array element: 

I like your idea of counting character frequencies first. This allows you to count the required deletions in linear time. Your code is readable, but readability can be improved by more semantic naming and leveraging modern JavaScript language features. Naming: Regarding the variable names , , , , : Those identifiers mainly include type information (, ). But as a reader, I am more interested in the role of your variables instead of their type. So instead of I would prefer to read or even . And instead of I suggest the simpler . For-loops: First of all, you probably forgot to declare the local loop iterator in . Unfortunately, those omissions can introduce very hard to trace bugs as you now access and potentially share a global variable . Also, JavaScript arrays and strings implement the iterable protocoll. This means you can iterate over them using a simpler for-of loop: 

You have most functions named consistently -- with a verb as the first term -- except . That should be changed to . 

You have many functions, none of which are . All getter functions should be made member functions. The idea behind objects and member function is too long to be included here as an answer. More can be found at Wikipedia and other resources on the web. Briefly, when an object is declared , it is meant to be read-only. When a member function is declared , in that function, the object on which the function is called is meant to be read-only. has many functions even though it doesn't derive from any base class and it is not a base class of any other classes. I would remove the specifier from those functions unless there is a need for it. 

I think that by closely following the above recipe, you can avoid the more obscure arithmetic and come up with a simpler and more intuitive 'generative' algorithm. The scheduling is encapsulated in the function: 

Notes Declaring some of your variables as can protect you against erroneous reassignment or rebinding, as any assignment to variables will throw a at runtime instead of silently continuing execution. Instead of I recommend using the unary plus operator which is "the fastest and preferred way of converting something into a number" according to MDN. Parsing I like your separation of input parsing and the actual program logic. However, you create a lot of temporary copies by first splitting and then mapping the array. If you like, you can use iterators or generator functions to parse input with only constant additional required space: 

It's not clear to me what you are trying to do here. I think you should change the type of from type to and have just one line to increment its value. This is how I see the loop. 

These lines are in a function that has as return type. These also produce compile errors. They need to be changed to: 

unnatural. I would expect to act like a pointer to since it's the value returned from a function named using an object of type . It would be more natural if: 

This is one way of reading the contents of the file once and using the contents in the loop. Function to read the contents 

Style Instead of I suggest the more self-documenting as the length can never be negative. Also, don't needlessly mix vs. for strings. Specification Right now you are returning a distance of when there is no path and a distance of if equals . I suggest following the common definition of path length and return and instead. You might also want to pass the alphabet as a parameter instead of having a hard-coded 'magic' constant in your function. It can easily be computed from your dictionary as . Also, you currently allow any word for while must be part of the dictionary. I recommend allowing non-dictionary words in both cases for consistency. Performance Your main performance bottleneck is the function. If you keep track of a set of open words which you haven't visited yet, you can replace that function call with a simple . Set lookup time is constant and thus much faster than iterating the whole array. You then have to pass the set to . The map is no longer needed. Another performance drain is performing string splitting via in the inner loop of . You can push that to the outer loop. Also, you currently treat as a special 'shortcut' case. You could generalize this to . Sample code Applying all those modifications to your code yields: 

You have class templates with the above enum as template parameters. You have specializations that use the enums. You have user defined suffix operators that depend on the enums. If you want to add to that list, you'll have to search for all the places where these units are used, go through every one of those files, and add another function, another value, another clause that deals with the new unit. These are very intrusive changes, and will most likely introduce bugs. You shouldn't have to modify existing working code to add new type/enum to the code base. My suggestion 

Don't assume file IO succeeded Always check status of file IO operations. It's never safe to assume that they succeeded. Change the lines that read the input to: 

If is not an array but an object, replace with . Performance If performance is really an issue, look into the runtime complexity of your operations. By introducing an explicit from parent names to children files, the runtime complexity could be reduced to depend linearly on the total number of children only. 

First of all, your given sample features zero-padded 2-digit months and milliseconds which you currently don't reproduce. The mentioned 'smell' is probably caused by 

2. Remove the redundant condition: The final condition is redundant as it is always when the first if-condition is . Remove it: 

Now, it is much easier to see that the inner loop is actually just checking the existence of an element within an array. You can use the faster built-in method instead: