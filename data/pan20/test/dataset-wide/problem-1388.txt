My main reason for doing it this way is that it separates the database operation from the model. Now, you can use the model without being forced to have a database interaction (maybe one isn't needed right now, maybe you want to run tests, maybe the current instance of the object comes from somewhere else than the database, etc). On the other hand, if most of your business logic happens directly on the database, not the object, this might get confusing. So it really also depends on what is exactly. But for simple objects which are mainly retrieved, updated, saved, etc, this is the way I would go. 

You then somehow have to string these components together, which is where the approaches to MVC differ a bit. 

I'm not even sure why you have the debug statement in there, it shouldn't be needed, and it will add a lot of unnecessary overhead in production. If you want to know if calcPressure works correctly, it's not going to help, you would need automated tests for that. And if you just want to see if something is calculated, you would see that in the view anyways. 

(This method should be used if the agent being null is not expected. If you do expect it, because it's part of your program logic, this might not be the best approach) Bugs Your code doesn't work for quite a lot of input: 

Instead of wrapping mysqli, it may make sense to aim for less abstract methods. For example, you may have a , which may have methods such as . 

You could also create a class (containing logic for adding, getting, and showing cards), which the class extends. That way, you could also add a class, which also extends . 

Error Handling First of all, your return values are quite confusing. If you were to check them, you would get code like this: 

These problems also occur in other parts of your code. None of the methods have comments, and , , , , , etc are all bad names. Even some of the longer names are not all that expressive. and what of what? what? 

It's obviously for some sort of corner-case, but which one? Confusing for loop The null check isn't the worst part about the loop. The worst part is that you change t and s on every iteration, and additionally modify t and s inside the loop as well, which is difficult to understand. Now, the easiest solution would be to use two temporary lists (even and odd), iterate over the original list, put the values in the correct list, and then join the lists at the end. I'm assuming that you are not doing this for time and space reasons. An alternative may be to use a while loop. Unit Tests I didn't write an alternative solution, as things like these are a lot easier to write when you have unit tests. You can make a small change, run the tests, and see if it breaks something. Without tests, making changes is rather difficult. You may want to consider writing unit tests first and then implementing against them in the future. 

Structure: Cache Class You already noted it yourself, you have some duplication. You could get rid of it by introducing some function, but ideally, you would extract the whole cache handling code to its own class (and maybe have an additional twitter specific cache function or class). Right now, if you want to change how the cache works, you would need to do that all over the place. And if you want to cache other things, you would again duplicate code. So instead, create a class that can load and store cache entries. Structure: Logic 

Approach The approach is interesting, but doesn't seem practical or actually useful. I think that you need more justification for this than simply stating that you want to use less if-statements. Especially since you essentially still have the if-structure, just with a different syntax: 

First of all, use prepared statements. The account id part is always the same, so extract it to the beginning. Also, you can extract the isset and not empty part to a function to simplify the code. 

Prepare once - execute multiple times Prepared statements not only prevent SQL injection, but also enable you to only prepare a statement once, and then execute it multiple times with different values for increased performance: 

The problem is that you do not have quotes around your values. I'm not quite sure if you were thinking of XSS when you said , if not: cleaning the Email of HTML is not really the job of your Email send script, but of the script that later reads and displays the Email (if that is not secure, I could just bypass your filters of the Email content by sending you Emails directly rather than using your Email send script). Misc 

Yes, it only saves one line, but you really do have it in a lot of places, so it's worth it. Indentation Proper indentation is important for readability. For example this code: 

Note that I removed your comments, as they were not that helpful in determining what a test does. I did give the test methods names that I think describe the test cases better. 

Your Controller Your controller is fine. If you use a similar approach to the one outlined above, you would need to change it a bit, but generally, it would still perform the same task as now (get input, apply it to model and view). You should probably add a more generic instead of using an directly to separate the controller from the concrete GUI. It would probably only have one method: , which should return the desired move in some way (either create a move class, or just use an array). Misc 

This isn't very easily understandable. Sure, it updates some table, but a reader has no idea what exactly is happening without looking at the code itself. If you go with something like a query builder, you might get code like this: 

And you use it like this: Player1 plays paper, Player2 plays rock. Look in the paper row for the value under rock. it is 1 and player1 wins. -1 would mean they lose, and 0 means tie. For just rock, paper, scissors this is overkill, but for a lot more options this might work well. Comments on current code 

What do you mean static values? returns something like , right? Then it's not static. Just because your HTML says that the values can only be pre-defined strings does not mean that anyone has to actually follow that. An attacker can send whatever they want to your server. You should never trust user input, at all. SQL Injection: Solution You need to use prepared statements whenever you put variables in queries. It doesn't matter what the variables hold, if you think that the values are probably not user controlled, or only partly user controlled, or may be safe. Because they may actually be safe right now, but if you need to think about it in every query, you will make a mistake eventually. Also, code changes. Variables that are safe right now may not be tomorrow. Luckily for you, you already have the function which uses prepared statements, so you should use it. For example, this: 

First of all, it's great that you want to do this. Prepared statements are always safer than escaping (and your current script seems to forget to escape some values, which would be a lot easier to catch with prepared statements), and it's actually important even in a script like this, which doesn't accept direct user input, because of second order SQL injection. You didn't post your class code, so it's impossibly for us to tell you how to do it with this class. On the other hand, the class doesn't seem to be all that great (you can/must do something like , etc), so you might as well use PDO directly. The complete intro to PDO can be found here, a shorter one about prepared statements here, and if your problem is how to actually write insert queries, see here. Also note that if you perform the same query multiple times for different values, you only have to prepare once, and can then execute multiple times (which will increase performance). If these links, and the link posted by KIKO in the comments do not help, I would suggest that you try to write prepared statements, and post the non-working code on stackoverflow and ask why it's not working. Misc 

Yes, you really should use prepared statements, your current code looks extremely vulnerable. Right now, is the only value that you actually validate in some way before putting into a query, all other variables - if user supplied - will lead to an SQL injection (they could have been cleaned by , but I really would not rely on that, and input validation is at best a nice addition to proper escaping or prepared statements). SQL injection is possible in and statements, not only statements.. Also note that is - as it's documentation says - deprecated since 2013, you really should not be using it anymore. Use either or , and use prepared statements. Naming You should handle your variable names uniformly. Either use camelCase, or snake_case, but don't mix them, as that will make it harder to remember names. Also, don't start variable or function names with an uppercase character. And don't abbreviate variable names. What is ? And does stand for ? Maybe, but why is it written out in ? should be , etc. It's also not really clear that stands for . I would just get rid of it, it doesn't really add any benefit anyways. Early Return If you turn this if around: , then you would save one level of nesting: 

Your code looks wide open to SQL injection. It is unclear what data is user supplied, but for security reasons I would treat all variable data as user supplied (it doesn't hurt). Use prepared statements with mysqli or PDO everywhere, always. OOP Currently, it seems a bit unclear what your class should actually do. Should it be a model that temporarily stores data, as the getter imply? Or should it perform database interactions? You could easily separate these concerns with a different structure: 

But: Do you really need ? I would guess not. And with a decent IDE, is it really slower to write HTML yourself? I wouldn't think so, so is out as well. And : You can just use a minifier, which will probably be better at what it does. And allows you the option of turning it off for debug purposes. Point is the only one I would consider to be a real advantage (but then you would have to make it a priority to produce valid HTML). Disadvantages: 

Prepared statements (which you use, as you use ) are the correct way to prevent SQL injection. It is still recommended - but not necessary - to clean input parameters with , but just as a second (or in this case first) line of defense. What if you forget to prepare that variable somewhere? Maybe when you retrieve it from the db and use it in a second query? Or what if you echo it somewhere and forget to use proper encoding? No program is 100% secure, so if you know that you never want special characters in your usernames, then it's a good idea to filter. If you do want those characters, then don't filter.