You can improve the code even without a separate class in the case that you don't need other detection mechanisms. The following will allow you to easily add new prefixes but nothing more. 

You need to allocate storage for the reversed string using unless that's changed in the last twenty years and place a string terminator at the end. 

To avoid exposing the underlying map you could go further by using a closure (Java 8) or anonymous visitor class: 

The application bootstrap is the place to tie the configuration source to the resulting objects. The Factory and Builder patterns come in handy here, though they certainly aren't necessary for small projects. This separation will let you write simple code for tying the objects together. 

This pattern can be difficult to understand outside of an application with many modes of operation. There are two advantages to using the factory patterns: you can swap in different implementations, and you can vary the construction parameters without changing client code. Where do these advantages shine? Testing! In the case of a game, randomness is a good example. When playing the game for real, you want your monsters to vary their behavior randomly. But when testing, you need to be able to choose from their possible behaviors. The real factory will initialize each monster with a real random number generator, but tests must be able to specify the behavior choices. Take this example monster action: 

Edit: If you're doing this once per team you can use a loop with to remove the first element and to place it at the end: 

Assuming a set of ten to twenty common types, you can make your API easier to use with these helpers. For the rest, the generic accessor will suffice. Either way, encapsulate all parameter item creation and use behind container methods, which you may already have since you left them out. 

I enjoyed playing and won on my first attempt. I suppose that means I'm quite virtuous! :) Quick Tips 

Adjusting the nested output loops to use the counts should be pretty easy, and you may even be able to use the count directly instead of looping over the duplicated sentences for each subject/object. 

But if you really want to use the ternary operator here (), at least move them to the declarations, and move the assertion above. It's a micro-optimization, but I would assign array[j] to a temporary variable inside the loop since it may potentially be accessed four times. Plus it is more readable 

What is the reason for performing internal initialization inside the function? You're already inside a function, and you're operating on its local variables. Here are some thoughts on the insertion sort (chosen at random): 

Check out Guava's helpers for some ideas, specifically . But first let's look at what you have in the first method: 

tracks unique word sets, one per word length. It maps word length to a set of unique words. Whenever a new word appears in 1 above, add it to the set. When it is seen again for the first time in 2, remove it. Next sort those entries by their keys (word length) in reverse and pull the first word from the first set. Note that you may end up with ties of same-length words. The standard set will return an undefined "first" word. That may be okay. 

The object gives access to sections and top-level values. It makes sense to expose sections using a or method. 

You can gain a lot of readability by formatting the code (every decent editor will do a passable job at this with a single keystroke) and extracting several small functions (refactoring). I'll start with this but only extract the reusable functions. 

If you want to perform full file validation, I'd suggest extracting that functionality to a utility class. This is overkill in this instance, but it will give you more ideas on how to separate responsibilities so that each method does one thing and each class has a single responsibility. 

While the code duplication seems much worse with those temporary variables, the logic is more apparent to me. The real problem is that there's no logic inside . If you add the line number to and added some helper methods, you could clean up that code a bit. 

I have fully embraced Clean Code's goal of five-line methods, and my life of reading code has absolutely improved as a result. Right at the start I see this and am stumped: 

Since this set doesn't support elements, you can drop the "and this set does not support null elements" at the end. 

I don't know Go so I'll limit this to a more general review. If I recommend non-standard things, please point them out so someone else doesn't pick up bad habits. :) Unless the error result is always named in Go, I would prefer in the cases where you are searching for a node by key to clarify its meaning. A comment in says missing nodes will be created automatically ("make new node if doesn't have one"), but the code doesn't match. The problem is that there's no payload for the new node(s). The graph will let you add nodes to which you cannot attach edges. Move the key checking to a new method, and call it from and . 

I haven't used MongoDB, but I have a few suggestions based on experiences with optimization and other databases. 

If is only valid when it's omitted or a function, you can drop the and just test that it's truthy. This will avoid setting an invalid callback when someone accidentally passes . 

First, modifying your click handler invalidates any test you run, so we'll need to leave that in place, i.e., no simulated call or extra deferred. Your best bet is to poll for the call to complete with an interval and fail the test if it doesn't complete within X seconds. 

I hope this gives you enough to go on. The idea is to move the scene-specific logic into the model so that you can continue the story without writing more code. 

Another aspect to consider is cache locality as the pool grows. The cost of allocating a small temporary string may be far less than an L1/L2 cache miss. You could randomly generate strings such that the pool will grow to thousands of unique values to see if it has any effect on the benchmark. 

Neither will be simpler than using the date function's code, and I'd bet $5* this would be faster than both. 

Substitute your desired "not present" value of choice for . Edit: This is the short form of the ternary operator which evaluates to the first expression if truthy or the second expression if not. This is similar to how the operator is often used in JavaScript. 

You could define it on itself instead of adding it to the prototype and exposing it to every object. This would parallel how works: 

While I applaud your effort to keep methods short by refactoring, I question the benefit of replacing 

Also, you load the list of directories twice--once to get a random key and again to pull its value. Since you don't expose you may as well move it inside .