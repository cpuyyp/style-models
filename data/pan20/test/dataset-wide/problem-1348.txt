tl;dr Sort the , remove the duplicates and use a binary search instead of your linear approach and you will discover a huge performance benefit. 

don't use You should not use because it eliminates some important information, which may lead to some conflicts with your classes or classes of other libraries. It is not uncommon to have a class, which has a totally other meaning than the . And to be honest, it isn't that much more work, to type in front of the classes/functions, is it? use You do everything with for loops, which is bloated and error prone. Use the algorithms of the namespace instead. I provide you with a short an clean example, how you could do the above task (and more) with less lines. your algorithm itself You should think about logical improvements. Is it necessary to store every score in a vector, when equal scores produce the same rankings, and the following scores just increments by one? Therefore I took the algorithm, which returns a . doesn't erase anything itself. It just moves duplicates to the end of the range (our ); you have to them manually. But, before you can use you have to order your elements. I don't know if it's guaranteed to get the score input in a descending order; thus I simply use to ensure this. After that, it's a simple (which is a binary search instead a linear search) to get the first iterator to an element, which is not less than the provided score (ok, I had to pass an other function object, because we want to check for greater and not for less). starts with a zero index. This means, we have to add 1 to our index, to get the official ranking. Easy, huh? 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

You make your code more self-descriptive. your Socket class Your class suggests an other meaning, than it provides. It should handle the sending and receiving without the need, to specify the explicit. The user shouldn't be forced to pass the themselves. That's up to the class, to provide the correct socket (at least you are holding a socket as private member). Think about that, perhaps your class has simply the wrong name for its purpose. use instead of heap array You are using a heap array as a read buffer. This yields exception errors, and it isn't totally clear (at least for the user of the Socket class) who is responsible for the cleanup () of this buffer. It is never a good idea, to hand back a pointer, and let the user cleanup the stuff by themselves. Instead, you should simply return a . That's clean, smart and has no hidden traps. If the user decides, he doesn't need the buffer anymore, he can simply let it go out of scope and it will be deleted automatically. The problems are even bigger, when an is thrown by any part of your framework, the users code or any other part of the program. If you want to pass ownership, use the provided classes. For strings it's , for every other point it is or . When you think, "returning a char* has better performance than returning a ", that's not totally true. Most of modern compilers can optimize that. You should google for "" (). In it is guaranteed, but in or it might fail. But even in that cases, a simple move of the happens, which is not as bad as it sounds. 

Be aware of the fact, that you have to take care for the cases, where your vector size isn't a multiplication of thread count. There will be some elements left untouched, but I let this job as a task for you ;) 

It's also a little confusing that you return from to indicate that you want to keep running the program. I would probably change the name to and return to indicate that you want to continue. Float literals have an on the end of them: 

Another shameless linq answer that doesn't require reversing or creating a new enumeration and only goes as far as it needs to: 

Since there are only three valid key sizes for AES, it makes sense to not even let the AES class be instantiated with any value. I would introduce an enum similar to this: 

Using namespace std pollutes the global namespace. It's better to use everything with its full name (, , etc...) 

I changed the logic a little, because seems to neglect to grab the item to the left of the current item. Also, in the for loop skips the entire row above the current item. I would add the enumerable in the traverse method into the for loop: 

I'm almost alright with not declaring local variables though. The function names are descriptive enough, especially knowing we're traversing a tree: 

returns the price plus the tax. If it's going to do that, I would name it . There's also a lot of repetition in the method. Find out the part that's not repetitive, and do that first: 

In , you do a lot of the same as in the else. Also, has an overload for a format string. Use that one instead of concatenating a bunch of strings and variables together. Also, it's hard to read when it's all on one line: 

I would get rid of the continues on the for loop. They can get rather confusing, especially with three of them in there. You can use and to do so: 

I removed because I don't think it's necessary. I would also check for malformed input, as can fail with an error, and can be something other than , , and . Before I got into the industry, I had flaky UIs that worked if you used it how I, the programmer, intended. There were quite a few ways to misuse it and break the program. One of the first things I learned on the job was that that was not going to fly. Ewan's answer is great for the OO principles, so I'll neglect to cover that. 

Just pick one. Here I just return void, keeping with the semantics of the rest of the parameters (pass by non-const reference): 

Of course, then you have to fix the other parts of your program that use them. In addition, I'd stop doing assignments inside of parameter lists and and headers. It's dangerous to do so, especially as a beginner. Here I've changed the first : 

I'm going to be brutally honest, because I think it will do the most good for you as you look for a job. You say you "have the right frame of mind" and "just need someone to 'nudge' [you] in the right direction." You're way ahead of most of the pack, as you are capable of something much harder than FizzBuzz. However, this code needs a lot of work and a lot of reorganization. It's going to take time to learn the culture of C#, and it's going to take time to learn OO principles in an effective way. If I were you, I'd start writing a lot of OO code in C# in my free time and posting it to codereview. This is C#. You don't need to call on strings. Instead, do: 

The algorithm you used is the way I've always seen it - flooding the matrix. I think my sister had this question at her first interview, and I think she did it the same way as well. 

Instead of putting the logic in the method, we can change the header of the method and let it populate a list of items visited by that cluster: 

You could take a page out of functional programming and shorten the visitors for the multiply, divide, subtract, and add: 

Consistency is important. The rest of your variables start with a lowercase letter, so name the variable in the same way: 

In , the return type is , but you return and . Just return a and return or . You also never use the variable. Also, comes before , and you probably meant to surround the response checks with parentheses: 

shouldn't be a property on the program. Nothing is going to be accessing the file, so if it's going to be in there, it may as well just be an instance variable: 

Use when you can. It lets the programmer know (reasonably well) at a glance that a variable will never be modified again. The variable can be declared as such since it's never changed. Also, returns a , so I'd probably declare it as such and cast later: 

That second is a bit long, but we can rewrite this to something I think is more readable by creating ranges and using as a cross join: 

Sure, they could still pass bad values, but they have to try harder by explicitly creating an invalid enum value. Also, making it a scoped enum provides extra type-safety and prevents naming clashes. Either way, I think it makes sense to throw out of the constructor immediately if the key length is wrong instead of waiting until the function. If you want to enforce a valid value at compile-time, you can use a , or you can use a smart-enum pattern. This is an example hacked together real quick: