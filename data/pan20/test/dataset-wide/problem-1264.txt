(we started with the 50 USD object from above, the conversion rate is completely arbitrary). What have we got now? We can add amounts of the same currency. We can convert an amount into a different currency. We can also add amounts in different currencies via wrapping them into a converter first. That's pretty much all currency stuff should do. Now how do you get this nice converter? It is simply a call to a class that generates it for you. This class should only deal with generating the proper conversion object when asked to provide one for conversion from currency A to B. To fulfill this, it needs access to a resource of knowledge, but this resource could be anything. For example, a HTTP client. But the client cannot be universal, it has to be customized for the web service you are using. So in reality you need to create something like a factory that is able to make a request for converting currencies to a certain web service. This call triggers a basic HTTP request with some parameters. Caching should be done as decorator pattern as well. Decorating an HTTP call with a cache means that in the decorator you see if there is a matching entry in the cache that is still valid (might expire to fetch new updates), if not, it forwards the function call to the real client. I apologize for not going into details for these tasks at this moment. I hope you got the idea of how to split up responsibilities between classes from the currency conversion example. 

Although it does plenty of things, it has no answer to the problem of how to actually recognize which currency any amount is in. Adding two amounts might be valid, because you add GBP and GBP, but might actually be invalid because of GBP and USD. Your variable would only contain the integer or float value. So split it up. First create a class that actually represents an amount of money in a specified currency. This can be as easy as making a class with two public values, $amount and $currency, but usually you do not want to allow write access to these, so the two values should go into the constructor, stored as private properties, and be accessible via get methods. 

After a significant amount of optimization, I got it... mostly. The main looping variable for the While Loop is still clunky (still working through BuiltIn's method of accessing Robot Framework-style variables), but it's about 1/6 as long as the original with the same functionality, and runs significantly faster with less overhead. I'm now working on nesting the While loops. 

Given one of the main highlights of Robot Framework is readability, I'll show my suggestions to improve that first and then go into my mechanical suggestions. First, good readability practice in Robot Framework is to line up your cells by tabs (or sets of four characters depending on your IDE) and capitalize each word of your keyword uses. So, your code as sent would look like this. 

A common feature of basic loops is the functionality, allowing the user to specify break points for their loop to stop. I've been creating a keyword to enable nesting loops in Robot Framework. This Nestable For Loop for Robot Framework includes the functionality. The basic code for a nestable Robot Framework For Loop is located here. This is a strict upgrade, in that it includes the functionality in the form of the keyword . requires a single argument: a Boolean expression written in a string. includes two methods to work with this kind of expression: and . returns True if the expression is a Boolean string (including unsupported Boolean expressions), and returns if the expression would logically evaluate to . Because the nature of this code is to be nestable, I need it to be as fast and efficient as possible, so I'm looking for performance and algorithm-based suggestions. 

I don't currently have the code available to me, so I don't feel comfortable investigating the dictionary or sub-functions, but that's the result of the small optimizations suggested. It already looks much cleaner and shorter, at least on the bottom half. EDIT: After more editing, I've transferred everything over to an array-style implementation, further shortened some of the logic, and divided the code into sub-methods. Still interested in any further optimization suggestions anyone might have. 

I'm implementing things in Robot Framework that it does not support by default, including nestable For Loops and, now, While Loops. I'm looking for readability, algorithm, methodology, and/or performance suggestions. The While Loop is not as advanced as the For loop is yet. I'm eventually looking to implement nesting the While Loop and breaking it on a command, but at present it will take any Robot Framework variable (assuming it's an integer) and loop until it reaches the specified breaking point. The custom keyword Increment plays the part of a line of internal code incrementing the value by a specified number. At present, Increment only supports and with any integer, but I can easily make it support and for more advanced increments. The following code works, but as (still) a relative novice in Python I don't know all the tricks that could be used to optimize this loop structure and logic. The general idea, for those who have not read my other two RobotNest posts, is to allow the user to write nestable For and While loops in Robot Framework. My basic methodology is as follows: 

Easy. And completely unrelated to your currency conversion so far, but it solves a problem you might have, unless you are only offering a web service that inputs amount and currencies and translates this to the other value. What about currency conversion? What about adding two different currencies? Decorator pattern to the rescue! You can build a decorator that implements the same interface, which wraps around a currency object and does the calculations for converting the currency. Let's fix the interface stuff first: 

Adding or subtracting monetary values is a common task. How can we add two amounts of the same currency? Simple addition. Let's add a method for it. Note that I add the method to the Money_Currency class, which can be discussed. If I do not want to do this, I'd need an independent class that does all the math. If you have such a class, try this different approach. If not, continue following me... 

Your classes do too much different stuff Your classes do not implement proper dependency injection. But if they do, they have very weird dependencies that will fit a certain use case, but not all. 

Bonus: It is easily extensible should new fields appear. Negative: Still a lot of code duplication for three basic comparisons... But we will address it: Extracting all basic functions into separate variables (an array would work here, too), and adding the field that should be compared to this function, you get an almost universal arsenal of comparison of object properties. 

Reading the tests, I do not really see how a single slot is to be used. I only see how multiple slots inside a page are used. Also, I only see tests for several GET methods. If I want to verify that the results that are coming out are correct, I somehow have to read the config fixture file - a secondary source of information. This situation actually is bad. I want to be able to read the tests, and actually CHANGE some input values in a certain test method to see whether or not it changes the output and breaks the test. If I cannot see the input, I cannot play with the values. One final improvement: If you include files, they can actually return a value. You do not need to define a global variable that will transfer the config values. 

I'm not trying to be too critical of your variable naming but I do have to be for completionism and for other future Robot Framework users looking for how to write readable code. Because (it appears) that you're using the Python version of Robot Framework, I'd say it's good practice to keep to the Python convention of naming variables, which is for local variables or for global variables and index variables in loops. Also, shorter, more descriptive variable names are perfectly acceptable for this size of program. Re-written for that, your variables should be , , , , , and . Mechanically, I'm assuming it works fine as-written, but there's a few optimization problems. First, having a custom keyword for a single action is usually redundant (unless you want to simplify a repeated action with a lot of parameters to a single word for readability), so you could re-write your For loop as follows (using the re-formatted variables): 

Language: Python 2.7.13, Robot Framework 3.0.2 (Python 2.7.13 on win32) Dependencies: BuiltIn Library, ExtendedSelenium2Library 

This methodology seems very inefficient to me. By the end of the program, I've looped through my list of keywords once statically and around 4 or 5 for every iteration of the loop itself. This is why I'm looking for algorithm suggestions. In addition, I'd like to get away from using to delineate lines, but unless I figure out how the compiler takes Robot Framework's code and says "this is what it equates to in Python", that probably won't be happening. Here's my code as it currently stands: 

In other notes, this is actually a very good first Robot Framework script that is very optimal (as far as I can tell) other than my suggestions. Also, I completely missed who wrote this code originally when I was writing up this review. I know this guy IRL. Hey Fin! Hope this explained how I get my code to look so nice. 

That makes the keyword unnecessary, making your code easier to maintain. Finally, as another good practice, Selenium2Library is outdated. You'll need to download it separately, but ExtendedSelenium2Library is more robust, contains more keywords, and includes code to deal with Angular applications. The final code after formatting and optimization looks like this (I also took some liberties on comments that are either unnecessary or too wordy for what they describe): 

You are doomed! Basically you try to allow an attacker to define which code should be executed, and you try to find out if you are smarter in detecting malicious code than him injecting and hiding it. The "EXEC" mode is completely insecure, we need not discuss this. But I doubt the blacklist mode is of good use either. I feel it to be insecure as well, but I cannot prove it in 5 minutes. For example, I can try to read any file on the webserver by calling . I can try to overwrite any file by using . I could install my multipurpose script this way that is called a second later, and you get owned. In the end, only the whitelist mode seems reasonably secure, but this is just a generalized form of AJAX RPC calling - and a very dumb one, because it is limited to single PHP functions, you cannot do anything more sophisticated. And if you really think about it: There are already plenty of working solutions to allow Ajax calls to do more useful stuff within one single call. Some of them are called "restful webservice". 

I must criticize your tests. They are not part of your question here, but available in your github repo. Your SlotTest does not test slots. It does test the page. Why? 

It converts currencies. It validates currency identifier. It fetches HTTP resources It caches fetched HTTP resources. 

I find it weird that the bootstrap class actually changes the configuration. Configuration to me is a read-only value storage. It gets written in the config object only once in the life cycle of the application request: When it's read from it's permanent storage. The AppController for some weird reason has dependencies on a session manager, a configuration object, and TWO database connections. None of them should be the business of a controller. The controllers task is to be the combining layer between the incoming request on the input side, a number of models that act upon the data in the request as the processing step, and passing data back to the response as the output. Analyzing the input data from the request usually is done by helping objects that represent HTML forms to do validation (none of the controllers business). The models usually make use of some database access or session, but this also is not for the controller to know. Preparing a response means to push some values into the answer, which might actually be rendered by a template, but this also is not really the business of the controller. When I look at your AppController class, I see that it offers a whole lot of methods that have nothing to do with controller tasks, but with implementation details of a concrete application. I see methods like , , , that shouldn't be there. I especially wonder why does not use the to terminate the session. It was mentioned before, but I want to underline that if you force all the application classes to be extended from your frameworks classes, you make it hard for others to use your framework. For example the - for some reason they have to be extended from your mother helper class. A much better approach would be to only force the implementation of an interface, and offer an abstract helper class that already has a basic implementation that can be extended if there is no need to build from scratch.