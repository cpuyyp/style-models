Then create an implementation of errorHandler that wraps a StringBuffer (if you wish or whatever i.e. FileWriter, DbWriter etc) 

Then using an IOC container (Ninject, AutoFac, Unity are a few I've used. Or see this blog by Scott Hanselman for a list of what's around) I would inject these into my controller. The setup of the dependency registration would be dependant on the IOC implementation. 

I don't think there is anything necessarilly wrong with your approach especially if it works. However I personal might consider trying to leverage the DayOfWeek enumeration of c# and avoid the individual day timesheets. This way you could loop over weeks more easily as well as potentially leverage Linq to do things such as calculating the TotalHours as part of the viewModel. My viewModel for this case might then look like this: 

No I don't think you necessarilly need a viewmodel and there is plenty of debate on this on the internet. However I personally like the viewmodel approach as it provides the flexibility of adding any UI specified fields I would like without the overhead of my view being tied directly to the buiseness model. Of course this means also that you now have to have the rules copied twice like you mentioned. However if you were using jquery validation this would be the case anyway (or so I believe). 

The second (recursive) version can be made tail recursive using an accumulator. This would help some compilers produce better code. 

You are not using tail recursion in , so the compiler cannot easily turn it into iteration. It depends on the specific problem; in this case I would probably do it iteratively. Sure, is useful and convenient. 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

Stack overflow is tail-recursive, so if you compile it, it should become a simple loop and there should be no stack issues. However, do not rush with it yet. Algorithm Number of iterations Let us use to see the problems: 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

I sure hope so, because it's pretty much the same, except for an added else case. So let's grab the table from last time: 

Lastly, I don't know what you're doing with that user-agent string, but I don't think you're 4 browsers at once and it probably needs a comment. 

Don't put code in comments, unless it's to illustrate usage. Code in comments is dead code. It doesn't get run. It doesn't get tested. It doesn't get maintained. It will get out of date when a last-second bugfix is applied. It will eventually confuse reviewers, maintainers and you yourself. "But Pim, what if I need the code later?" Use source control, such as Git, Mercurial and Subversion. At the very least, comment that the code is removed because insert reason here. 

Seemed fine at first, then I took another look... The validation function displays the error message? I'm sorry, but that's indeed a violation of SRP. You'd be better off returning a which you could use. You already HAVE this validation result... so in a way, you've already done what I said. What's wrong is that your function names do not reflect this. You call , but it also displays errors. Rather than changing the validation method to return a (which would imply taking out and doing everything in , you should change the function name instead. 

is C/Java style. Lispers use or . is clearer than . Lispers use indentation, not paren counting, to read code. Your code is thus virtually unreadable. Please use Emacs if you are unsure how to format lisp properly. 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in . 

First of all. Is _queryLeadsByHeat supposed to represent a method? If so I would steer away from using underscore in it's method name unless that's your naming convention in which case I guess your stuck with it. Underscore is traditionally mainly reserved for fields (if at all as there are large debates for this practice). I don't have Visual studio in front of me so not sure if this will even compile (or is even possible) but my initial thought would be to try and consolidate the Predicates into one method. 

Also, do you need to catch the exception in this method? Could you not just handle that situation in an if statement as it looks like you are letting the exception handle the case where one of the values is null when a simple null check would suffice?? 

I've read alot about returning null is not the best practice in the world, but like anything I think it will depend on it's usage and how often it might be called. So, in your case this might be ok. However, I'd just like to chuck out another way of doing things using the Null Object pattern. Using this you would not return null at all but rather return a Null/invalid object. Your calling code dependant on it's usage will be checking an instance type and so you might not need to even worry about whether it's null and potentially remove all those checks. 

Aside from the slow api, your code is very repetitive. If you made one function for sending out an api call and passed in the URL, the data object to fill, and the key it should use, you could reduce this function to 14 function calls loading data and the couple things you do at the bottom. 

Just doesn't inspire great confidence. The part worries me that you'd have a lying around somewhere (which would be unheard of). The ... that's just redundant. But to call this would be wrong as well, as this contains much more than just a single . Really, this is either the class or the . 

At this point, you could consider shifting certain parts of the logic towards a function which does simple calculations. Your call. I'd prefer that to this inline logic, because if you use the functions, you can write this function on a different level of abstraction. That is, you can write English code consisting entirely of function calls. At that point, if you made a mistake, you'll spot it instantly. Because if you have a function that looks like this... 

Edge cases You don't handle negative integers very well. Specifically, the modulo operator, when performed on a negative integer with a positive divisor, may return a negative value. And when this negative value is something like, say, , then you get , which results in setting a high bit instead of the bits for 0-9. Duplication You currently have duplicated the code for and . By making use of smaller methods, you can get rid of the duplication: 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

In order to avoid serving customer unfinished pizza's (and to have the whole builder pattern make sense to use, since it's rather hefty), we should make it so that all 's are built and baked. That is to say, a Pizza is done after instantiation. 

Erm... yes it is. Maybe "The input list shouldn't be empty". Also NullPointerException is NOT valid here; use IllegalArgumentException instead (I didn't pass null! I passed empty list! If I get back when I pass in non-null objects then I spend a lot of time debugging, trying to find my null.) 

Don't use here; write a descriptive variable name! in general is flawed. What you should use is a constructor, taking a width, height and length of the container. Then you can set the arrays and such based on those values. Right now, only allows creating cubes that are the same size in all dimensions... if I'm reading your code correctly. 

That bit of code. So what if we made a function whose job it is to tell you whether you should? Something that could give us this: 

Welcome to the hell that never ends. Just kidding. But please don't make TVs that automatically turn on an alarm to wake you up in the morning. I have alarm clocks for that, which are beating resistant. Method naming