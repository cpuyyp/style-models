Remember that enums can have constructors and methods in Java! Look at Oracle's Planet example. Take a look at Oracle's tutorial for an example on how enums can be used. Then you can use a on the enum, or compare using . 

I am not sure if you really need this one. Especially not inside that class. It is good that you have not made your class a singleton at least, but I'm not sure if this 'global' is really necessary. 

(200_success and others is right that this should not be ) In Java, the naming conventions for boolean getters are that they should begin with , followed by the name of the variable they are a getter for. So let's say this variable were to have a getter: 

I would suggest moving these things to fields in the class or perhaps preferably, methods of the class: 

Judging by what you actually do in the method, I would expect this method to input a and return . At the moment, your method is dependent on several class variables and is therefore causing side effects, things that cannot be seen by checking the method header only. So change your method to: 

If you want to create a SQL query to search for properties like you are doing here, I recommend using Hibernate (which simplifies this a lot -- once you actually get the whole system up and running correctly...) 

method: This method is slow because a) You're using a loop to find the gap b) You are storing the results in a . Solutions: 

Card class Your does not change after being set once. This makes it perfect for being set inside a constructor. This will also allow you to make it . It is a good practice to use fields whenever possible. Instead of: 

Therefore, you're actually not saving any memory at all. (Technically you're wasting memory by creating a map for it, but that's so little memory it barely counts) Instead of creating a you might want to use setBackgroundResource() and setImageResource() (assuming you're using s) As for the name , I don't see what would be wrong with it. It's purpose is clear: A provider for cell drawables. 

Overall, it is very easy to read and understand your code. I think that you make good choices of data structures. A few things: 

Additionally, I have to question a little bit the usage for a "Everything in One Line" library. If the code that you are writing is trivial one-liners, it might be easier for other programmers to quickly re-write the actual code than to use your library. Most of the times I could use a function, I would probably write the actual code in-line, without using an additional function for it at all. However, writing a "Everything in One Line"-library can of course be an educating experience for yourself. 

I'm sorry, did you just call this a framework? Never in my life have I seen a framework where I had to edit the sourcecode to make it usable. Let users of the framework pass the to the constructor instead. And while you're at it, can I please have a public method from the class? for example, it'd be ideal as a public method. 

There's no fundamental difference between those two lines, and if asked what those lines do you would probably say something like "it shows the text on the cards". Now let's make that a method in the class! 

This removes the need for these methods completely. Depending on whether or not each really has multiple users, you could even do 

This should give you a "unused variable" warning from the compiler. What happens to this variable once the method is finished? Nothing! 

palacsint's answer is good, but it's missing just a few things. All in-built Java collection classes I can think of has copy-constructors, and an method. So your method can be a one liner, when using a : 

I'll try to say this the best way I can... Completely useless unnecessary! Sorry. I couldn't find any better way to say it. The code that you have is well-written, but it is not necessary in the first place. The reason is that the interface Closeable already lists as a "superinterface", which means that . So all objects are already . Which means that your code: 

You don't need all these three loops, simply one is enough. This will also make the arrays you use unnecessary. There's no need to store them in an array at all. 

Overall design / Organization of the menus In your usage for how you actually use these classes, you are always calling after . Because your method does this: 

So let's make permutations and variations of this: , , , , , ... Pick one. You want something that's not too long, but it should be long enough to be self-documenting. My personal favorite here is . 

Play my game! Having the name that I do (Simon), of course I have to participate in this challenge! (Even though I am a bit "late", but Simon says "have forgiveness!") This is an implementation of the Simon Says challenge using libGDX. I started using this framework a couple of months ago, and I love the fact that it can create games for Desktop, Android, iOS and HTML5, at once. As it is libGDX, and Android support is needed, I'm limited to Java 6. As I'm also using GWT, there's some restriction there as well. Class Summary I have not included the several different launchers here, as I am just using the defaults that comes with a LibGDX project there. 

Even though it's not used, the parameter to a main method is better named as . Also please write it as to be consistent and to adhere to the convention of where to put those . 

A while ago I started solving Binary Puzzles (also known as "binero"). Not having done much C++ in my life, although it feels like I have a pretty good understanding of C++ in general, I figured it was time to do some C++! The rules for a Binary Puzzle are: 

Honestly, skiwi, you make things more complicated than they need to be. Please rename to to avoid confusion. Because that's really what they are, it's a Listener, not a View. It doesn't by itself provide any UI functionality. Prefixing your interfaces with is, although understandable why you are doing it, not something I recommend or have seen been done in other places. You're already suffixing to the name (which is what I would recommend, and what I have seen in lots of other code), no need to prefix the interface with . The method names can be prefixed with , as they have been already. Why are you bringing and into your code? In what way does that help you? In my opinion, it doesn't help you at all. It creates more confusion than brings something good. If you want to "transform" an into a , use Java 8's method reference style by using something like . Now, let's see if we can write more or less the same thing of your interface heirarchy but with fewer lines. 

This reduces the need to subclass and let's you use composition over inheritance. This might also lead to the possibility of removing some of the arguments from the constructor. The different objects can then either be implemented as pure classes, or constructed using factory methods and anonymous inner classes. So instead of: 

There we go. I broke your function. Sorry. Even though the Roman Numerals Kata specifies that only numbers between 1 and 3000 needs to be returned correctly, I think it is better to handle numbers outside the working range in a specific way, such as throwing an exception. Return, do not log Imagine that I am writing a program and I want to use your method to count how many unique characters there is in the resulting string. 

What you are already doing is a nice way of defining both the text for the button and the action for it at the same time. As you're able to use Java 8, I would really recommend that you start using Java 8. You might actually even want to consider migrating to JavaFX (that would probably require even more work though, but it could be a nice user interface upgrade). One option, when using Java 8, is to do this: 

Creating a new each time it is rendered is a big fat waste of resources. Create it once, outside the render method, and only refer to it from inside - just as you have done with . Additionally, as I doubt that path exists on all computers, I would recommend using a relative path or use classpath resources (possibly with the Maven tool). 

But I have to agree with @Kao that your class does not seem to be very useful. It is better to learn the existing API than creating your own API to avoid having to learn the existing API (Yes, I just made that up. It makes sense though, doesn't it?) 

If you use this , then you won't have any use for your current and classes. Each time, you just subclass the and override the method you want - leading to very similar functionality as that of how default methods in an interface works. 

Naming conventions Several of your classes and variables defies Java naming conventions. A class should start with an uppercase letter and a variable with a lowercase letter (with a possible exception for static final variables, which you do not use). Here are some changes to conform with the naming conventions 

String or int? Many of your parameters are s. I would use them as ints. A port number is an int, an id for a tweet is (most likely) an int. Don't use them as strings! 

is an interface that exists in Java 8, but as you're not using Java 8 you have to declare it yourself: 

Now you only have to use to make a move on button 4. If you use an enum, you could use . Once you have cleaned this up a bit, I recommend you post a follow-up question, as there is likely more things that can be cleaned up then. 

The easiest, and what I also believe is the best as well, way to reduce cyclomatic complexity is to extract methods. Your method suffers from one particular code smell 

From what I understand, you want to make sure that new objects are not created when they are identical to what has been created before. This is relatively easy, and would include either having a static map or a map inside another object, such as a . I'd personally go with ReflectionFactory as I don't like static things when you can avoid them. Here's an example factory: 

Summary You might have use for your code, if so then great. I personally would probably not use it. (I tend to use the Event-driven approach when I need to, not for each and every property of course. Sometimes I might even use the "put-it-in-the-setter-approach") 

This has the benefit that one Material can have multiple MaterialTypes. Then you can use the method of the enumset to check if the material is of a specific type. See more in the EnumSet documentation 

I'd recommend getting rid of these special cases. To do this, you can check for special conditions inside the for-loop. Loop through all the positions in the string, and check if there is a on that position. If it is, then check if the position is more than 0 (i.e. it has a char in front of it) or if the position is less than (i.e. it has a char after it). The details about how to write this can be done in oh so many ways, but here is what I would end up with: 

in those files without any difference in behavior. I am not a big fan of your naming scheme for your android IDs, such as . 

What do all these have in common? They all can make the value in there some where. 11 + 4 (= 15) + 3 + 2 (= 5). So, what do I want to say with this? Once you have calculated the possible partitions for the value of 5, reuse them! To accomplish this you can use a structure. In your method, check if the map contains a value for () and if it does then reuse it. If it does not, then do something similar to what you are doing there already and use at the end to add the found values to the map. I have to warn you though that even adding this reusing-feature, I still expect it to take quite a long time for larger numbers. I strongly suggest that you switch back to using (or for storing them in collections). An int will take you to , try partitioning that number first before switching to (Hint hint: It will still take a tremendous amount of time to partition , if you don't believe me then try doing it by hand). 

Do not store the connection information in a file unencrypted Assuming that you are connecting to a database somewhere on the internet... If you plan on distributing this application, do not store the connection information unencrypted in a file on the user's device. In fact, preferably don't store the database connection information at all. Do not let your Android application connect directly to your remote database! It is not recommended to let your Android application, or any other distributed application, connect directly to your database. This is because it is very easy to decompile an application, which would give information about the connection details, your database structure, and a whole lot of other things. Instead, perform connections to a server-side script or application that is responsible for handling the connection between your Android application and your database. Only let this script/application that only you control deal with the database connection. Unless you deal with this, any number of prepared statements your application itself uses doesn't matter, as a user could just find out the connection details from your application and then create their own connection to the database server. 

This looks like the start of a Question class. But wait, how/why does a Question have a Score? What does it mean that the score for a question is "Bad"? That depends on how you answer that question, doesn't it? I would remove that from this data, that value belongs elsewhere. You could possibly have some "points" integer value in the data to indicate how many points a question is worth though. You say that you are not looking to make your program give the points, but the user to honestly give the points. This is good, and reminds me about Anki Flashcards (although Anki doesn't have hints AFAIK). 

, and possibly I'd recommend having this method outside your binary tree class itself. It can operate on a binary tree, but it's not a method that requires to be specified directly inside the binary tree. Also, it doesn't use any state other than what is passed through its parameters. As such, I would make it and probably also . First call It's currently a bit weird to call this method from the start, the parameter is used for further recursions, but what value should it be passed originally? Considering this problem, I'd separate this method into a public part and a private part, such as: