Try and only declare variables in the smallest scope possible, as in right when you need them. Since n and i are only ever used inside the loops, only declare them there. I would avoid assigning 0 to r, as then if later the program crashes, and I see r no value, it makes the bug much easier to spot than if r has a valid value. 

This could be move into the function, though I'm fuzzy on if it makes a difference or not, I'd need clarification that it is a good idea to stop namespace pollution 

This is exactly what padding was made for. I don't really know how to pad with cout, but printf makes it very easy. It looks like: 

Why is this so far away from where it is used? Try to keep the declaration of variables to as near to their first use as possible 

Each call to this is an O(n) operation on the list, m times where m is the number of times the element occurs, x times where x is the number of keywords. So in big O (and worst case) we have O(nmx). We can be smarter about this, and do it in O(n) and in one iteration. We will use extra memory to store the keywords in a dict So replacing this: 

I may have missed some bits and pieces, but the idea here is to give you a starting point so you can look at your own code and decide what is good, and what needs to be changed menu.py 

This piece of code doesn't actually achieve anything, you are basically copying a String array to another String array, using an unnecessary parse too. Since it is not needed, you can just delete it, and change any later references in the code to it, to input instead. 

This extends the first row of the matrix to contain every row in a flat list. Before the matrix was of size N * M, whereas now it is N * M (the first row + (N - 1) * M (all the other rows). Subtracting the original size from this tells us how much extra memory we are using. We use (N - 1) * M additional memory or in other words O(NM) extra memory. This is not what we want. The reason to put all the elements in one list is to make sorting easy. Lets see if we can sort without needing a flatten (1d) list. There are many sorts that don't require extra memory, they are called "inplace" sorting algorithms. For simplicity we will modify selection sort to work for our case. How selection sort works is it picks the smallest element in the list, and puts it at the front. Then it finds the next smallest element, and puts it second, and so forth. To implement this, we can find the smallest in the whole list, and swap it with the first element. Then we can find the smallest of the list skipping the first slot. 

This is only a quick review, since I don't know much in the area of rendering graphics Repeated Work 

So many pretty powers of 2, I'm guessing it is deliberate. It is a good idea, it speeds up multiplication and division because x << 3 is the same as 8x, shifting bits is the same as multiplying by a power of two, and shifting bits is really fast. As far as I am aware, Java doesn't optimise this, so try switching division by 512 for right shifting by 9, and testing the performance. It might not make any difference because Java already did this, but it may be a micro-optimisation worth doing. But remember, the algorithm you use > the micro-optimisations you implement. Low level changes like these make code harder to read, harder to change later, and more prone to bugs, if edge cases aren't accounted for. Do them last if you need the small boost to go from 58 fps to 60 

This function is weird. It highlights that the game board is strongly coupled with the players. The reason I say this is because this function assigns the names and characters each player uses at the same time for both players. What makes player1 and player2 special and need to be handled all at once? The code in this function could be halved and called twice, once for each player (or for an arbitrary amount of players if the game was a team game with a much larger board for example) 

The fact it calculates the distance is important, that it converts from degrees to radians is not, maybe something like 

Now getting the median of this is a piece of cake, it will be in the middle slot of the middle row! Since N * M is odd, both N and M must be odd. Therefore the median is at matrix[N // 2][M // 2]. 

Now onto the code overview. Strictly speaking, your code doesn't work at all. You never actually took in all the input. If its input looks like 

The rest of the code looks kinda dense right now, I would suggest going through the above suggestions and any other replies you get, make some improvements and post again with the next iteration of code. I hope to see you post an update soon, all the best! 

I feel like this is the wrong approach to take though, as there is a lot of boilerplate for what is essentially a function which is used in two ways. Is there a better design pattern to use in this scenario? I suspect a more functional approach would suit, such as passing the encryption functions into a class that binds them together. My concern is I lose the option of providing metadata with the function with that style. 

This will make it much easier to read, and you don't have to change code in multiple places, such as if a value changes. 

You scan 3, and 10. That is it. All the rest of the input is ignored. There is a reason it tells you how many test cases there will be, its important to use that information. 

The globals here are unnecessary, and a bad idea. What happens if someone forgets to call this function? Or worse, it causes an error? The rest of the code would either have to explicitly check for it, or pray that it will always work. An alternative is to just pass the two values back, and have nice local variables to work with, kinda like toys that you know someone else won't swoop in and break on you. 

The only place y is used is as an index. To quote Raymond Hettinger "There must be a better way". We can use enumerate to keep y, but make the iteration look a bit nicer The conditions can be shortened a little too, though not everyone would say it is an improvement. 

In other words, you only need to look each half once, at the moment you are checking the first and the second half, and then the second and the first half again. We can stop sooner 

Spelling mistakes in comments and variable names Abbreviations, if you notice there is a lot of words highlighted, maybe there is a few too many abbreviations, and would benefit readability if they were given more descriptive names Give you another chance to read through the code in a different light. Sometimes reading code in a different editor or even without one can change your opinion on what is ugly and what looks nice. You might even spot a bug or a chance to improve things. 

There is a bug here, if you reach the end of the array, and the longest sequence is at the end, what happens? I'll leave it to you to figure out the fix. A hint towards what I would do is try to add an extra check at the end 

You have inconsistent spacing, generally if you have 4 spaces for indentation, stick to it for the rest of the code, nothing is saved by not including it, and it makes it easier for other people to read. The same idea for names, shortening them doesn't really give much other than saving a few bytes, and makes it much much harder to understand what goes on in a few months, so descriptive names are better, unless the abbr. is really obvious or defined Below is your code with better spacing, and suggestions for better variable names, although the suggestions are not perfect, try and improve on them 

When you reverse the string, it remains the same The first half and the reverse of the second half are the same 

This comment doesn't really achieve much. If I see a class called Players in a file called TicTacToe.cpp, I would assume it contains code relevant to players in the game. In general comments are useful if they explain why a block of code is there, or what it tries to do. 

The next column is just counting upwards, so if column is 1 or if it is row - 1 (both conditions presuming row > 0), we can just return row. 

Continuing from my previous point (and ignoring that if it is a lowe case alphabetic character this doesn't returning anything) this could be a function for just one player. Another small piece of note is that even if the character is not an acceptable character choice, it is still assigned to the player. That seems like an unintentional feature/bug. My suggestion for a first iteration of refactoring is as a constructor for the Player class 

It has been a while since I did any c++, so I'm going to focus more on the concepts rather than the language features themselves. There probably are more concise ways to implement this in c++ than I can illustrate. Note #1: Typos. You can use a spell checker on code, there is no reason you couldn't. Why I think it would be a good thing to do is because it will highlight 

There is a little room for improvement here. While we only use constant extra memory, our time complexity has gone up from O(nm lognm) to O((nm)**2). For a better time complexity, I would recommend using inplace quicksort which brings us back to O(nm lognm). Another point is that we are doing too much work. Once we have worked our way up to the row N // 2 and the slot M // 2, we are actually done! We have put the median element in it's place, and we can stop. This is a simple enough check to add, but can cut the actual running time of the code in half. 

There is no need to overwrite choice with the default again and again if it fails. Also a more explicit error makes debugging and reading easier. Finally I only catch on ValueError as something unexpected would be better off thrown back up rather than silently dying here. 

Huh? I didn't notice the global variable for quite a while, it looks like it is a method. I would move this to the top, above main. It would not be good practice, but if I was being lazy, I would just print the character before returning the length of the longest sequence, or return an array or list with both in it, rather than using a global. I just prefer not to use global variables until I have to. 

Sorting the contents of the matrix and then picking the index with the median value is a good approach. Lets see if we can do it with constant extra memory. 

I am implementing a game in python, which will give the user a sample encryption, and explain each step from plaintext to cipher. The task for the player is to decrypt a word by undoing each step shown above on the new word. For this, I have created an abstract algorithm which requires an encrypt function, and a current development status. In the future I think it will require other properties such as explanation text or a difficulty level. The abstract algorithm looks like this: 

Since this will be the name of the file too, (if you save it) I would recommend naming it something descriptive so that you don't have to open it in order to know what it hides. 

Input Split input, output and the algorithm up, they are tangled together and it makes the code much harder to read. Make the main modular, for example 

Profile the code, and with each change test it again, the only way to really improve performance is to know where the bottleneck is. Sometimes it is in the last place you expect. 

This is the perfect time for if/else statements. One good piece of logic here is if they aren't equal, and a isn't bigger than b, we know the answer to a < b without needing to check. There are more things to mention, like moving the check if two numbers are equal to a method, and making use of the library of methods available, but get it working first, then post a follow up. Best of luck 

There is no need for a while True. Before adding the coords to the currentShip, we can check if they are in an empty part of the grid. If they aren't we abort early. The boolean validShip doesn't actually do anything, if you reach that part of the code you know it has to be True. That means it can be removed 

Spacing Use as much whitespace as needed, it makes it easier to read code, especially formulas or expressions with a lot of operators. 

I don't know what you are trying to achieve, so this is going to be just code refactoring since you are doing the same thing in 3 places, you can reduce it to a for loop 

This code appears many times. It would be a great candidate for a function. That way, adding a new set of problems doesn't require a whole load of copy pasting 

I would suggest making a function to actually change to and from fullscreen, so you don't have to worry about changing anywhere near as much code later. 

If it makes it through the loop, we should just return true The second thing of note is the definition of a palindrome, here are two ways of looking at it 

Since it is going to be the same character, why do we need to loop over the array? We could just print the character once and it would serve the same purpose 

Speaking of input, while a buffered reader is probably faster, I don't think the performance is worth it over the simplicity of a scanner. 

I gave a naive solution as seen below, where I simulated the grid with a 2d array, and applied each operation as it came. I also tried to implement an array of fenwick trees, but that solution gave more timeouts, so I believe there are a lot more add and remove commands than query. Code: 

Lastly, and most importantly, since the triangle is symmetric, only half of it needs to be generated in the first place. The mid point of the row is given by row/2 + 1. 

I will admit the code right now is not the most readable, but I think that is down to variable names now, as opposed what is going on in the code. 

As we are printing out the natural numbers, starting from 1, and going to r*(r+1)/2, I would just have a variable that keeps counting upwards. Then I don't have to work out what number the row starts with each time, and you are incrementing i anyway, so there is essentially no extra work done by having a count, and you save a few operations too. 

Maybe a note that this formula assumes that the cannon is on ground level, it is a simplification of the formula for range Now this is up to you, I would just write the formula in comments, and remove the timeInAir 

We can avoid generating some of the numbers of the triangle. From looking at the triangle, every single value in the first column, ie if column == 0, has to be a 1, if asked to generate it we can just return 1. Similarly we can do the same if the column equals the row. 

You could reduce this to a single any with two loops inside it, but it gets a bit long and unwieldy. 

This doesn't seem all that arbitrary. If you change it to 1, or 3, will the code still work? I suspect this is not actually needed.