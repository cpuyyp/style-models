However, my suspicion is that the biggest gain you will get is implementing your own tag reader library rather than using TagLib, assuming you are correct that it reads the entire file. I/O is one of the most expensive things you can do on a computer. ID3v1 and ID3V2 tags should generally appear in the first X bytes of the file, so you only have to read until the end of the tag, rather than the entire file. As with any performance issue, though, you need to run this through a profiler. The results may very well point you in a completely different direction. For example, it may reveal that TagLib isn't actually reading the entire file. At the very least, it provides baselines to use in determining if you are making meaningful gains. 

: There is no reason to use dynamic allocation, and are constant expressions!. Just use or better . That said you usually want to have dynamic sizes or your matrix may be larger than the stack limit. Then you should use . C-style arrays and dynamic allocation should always be limited as much as possible. Using proper class objects wrapping them is much safer. will take care of all memory management for you. If you are concerned that will layout rows non-continuously, then use instead and properly access the elements by . Also, in C++, you do not use and . Instead you use and . The difference is that not only allocates memory but also constructs the object in that memory. In most cases you would need to manually construct the object in the allocated space (although for double it is technically ok here). You should not declare a method, but rather everything freeing memory belongs in the destructor, which is automatically called as soon as the object itself goes out of scope or is destroyed: 

Finally, should you add more classes to User, Series, and Lessons, you must modify your method, and add the necessary conditionals. So ask yourself if this code really belongs in the method. My two cents. 

Using a hash instead of an array alleviates the problems of 0 index when using arrays. It makes more sense. 

Finally The habitable range for ladders and snakes is the same, so this can be replaced with a single range : 

The first check is for the length of the string: If it's odd, the can't be balanced. I then iterate over the chars of the string: 

and should be . You need to to use . You are defaulting the copy constructor and assignment operator, but not the move constructor and move assigment operator. That's fine because the defaults are generated anyway, but it is inconsistent, I think. What is the point of ? should be . You don't want to have users create s. does not actually own the pointer it holds. It is copyable and will just copy the pointer it holds. It also does not create anything or delete anything in the constructor/destructor. Nontheless you provide a member. That seems very wrong to me. You don't know how the memory you point to was aquired, it could be with static storage or an array. In both cases calling would cause undefined behavior. The object creating the pointer with should also be responsible for ing it. Calling on two copies of also causes undefined behavior. The fact that the pointer is not owned seems to be a major flaw here anyway. Currently the user of your class needs to gurantee that the object pointed to keeps in scope until all 's holding it are destroyed and then it has to take care of proper deletion. Using it outside of is not allowed. So why not move the responsibility of managing the pointer to ? The same holds true for the lock. Currently the user needs to provide a suitable lock and keep it live until no references it anymore. Why not create the lock/mutex inside the constructor from pointer? Though I realize if you do it like this you need to manage references to the lock and you end up with fully reimplementing . Therefore I will just assume that this wrapper is explicitly only about locking and not managing ressource lifetime and that the user is required to run the destructors properly. is fine if copy elision is performed (not required in C++11, but in C++17), but is not either way. The object you create in is destroyed before the function returns. That means that is called before the caller expression using the pointer ends. currently returns a copy. It should return a reference. At least that is the usual way this operator is interpreted. In general the approach with and has some limitations. You may not call either twice in one expression or you have deadlock. But you are also not allowed to save the pointer returned by or a pointer/reference to the object referred because these are not guarded any more by the lock. I guess it would be much better to let the caller call a which returns a . Access to the holding pointer is then only allowed via and of this . As soon as goes out of scope its destructor releases the lock, similar to . This still allows the user to misuse a saved reference/pointer to the raw object, but at least more than one usage can me made in the same lock aquisition. An implementation via C++11 standard library would be similar to this (not tested): 

Even better would be a way to map data objects from the database code to XML. Normally, this is where I might suggest System.Runtime.Serialization.DataContractSerializer, but it does not support attributes :( Unused Code I ran across a number of variables which are not used or assigned and then never read. Some examples include and . I cannot ascertain whether they should be removed or if the code meant to use them has yet to be added. Constants Most of the string literals in the code appear to be good candidates for constant values rather than local string variables. Boxing There are a few places where unnecessary boxing occurs. Specifically, the ArrayList used to store report servers and the DataSet used to store the second query result will both box values. The former can be easily replaced with a List, which also eliminates the need to perform the ToArray call. The latter is taken care of by changing the database code to use something other than a SqlDataAdapter (see above). 

It depends. I prefer the newer syntax because I feel that it is more readable. As others have pointed out, however, the newer syntax is only compatible with Ruby 1.9.2+. You should be aware, however, that the new syntax does not entirely replace the hash rocket syntax. This is because you can only use the newer syntax with symbols. 

I'm passing a callback to handle hiding the from from the parent to the form, and then to the link component that hides the form. Seems excessive to pass down a callback through descendents. Validation is very complex, but I have a simple case here: text is required. It seems a bit ad hoc to validate this way. 

(It was thrown together quick just for quick turn-around sake.) I then provided 3 ways of loading. One loads the data much like you did above: 

I would second Steven Doggart's comment about it being pointless to spawn a thread that does nothing. To address your separation of concerns issue, though: If you are using one of a number of design patterns for your UI (e.g., MVC, MVVM, MVP, etc.), your MainForm class will merely be binding to one or more data objects and raising events from the user. The real work and asynchrony will be done in another class. For example, in the MVP pattern, you might have MainForm, MainPresenter, and MainViewModel. 

Doing so means the placement methods for ladders and snakes only have to worry about working out the range and populating their respective hashes, which are the only two differences between them. This reduces duplication. 

I'm building a JSON API. I'm writing my controller tests so that they compare the response body to actual JSON I'm generating in my tests using ActiveRecord. I wrote two helper methods that make the process easier. The first simply parses the actual response body and returns it. 

The best way to ensure a bullet proof implementation is to avoid having a square contain more than one object. For example, there's an edge case where a square can contain a ladder's head and a tail, causing you to progress even further. To do that, the placement should be delegated to a method that checks if the square is occupied. This requires tweaking the initialize method, but it's worth it: 

You forgot to in . There is no need for your limitation on integral types. You could just as well use the algorithm for any type with overloaded and or even only . You could follow the interface and make custom comparators available, too. However you would need to think about copy-constructibility and such. I think you cannot avoid limitation on copy-constructibility. I don't know why you write , is just fine in C++. It might even mask some errors, because will introduce as incomplete type, while will give an error if was not declared at that point. In C++11, which your code seems to be, you can easily offload memory management to in most cases. This makes the code shorter, clearer and safer, e.g. make and and leave the rest as . Then each node is owning its successor node and owns the first node. As soon as is destroyed, will be destoyed, which is owning the first node and it too will be destroyed, cascading down to the last node. There might be a problem with recursion for every node here if tail recursion optimization is not possible, though. In that case you can still use a custom destructor moving through nodes iteratively. You can spare a few lines of code, if you put and in the constructor of . Your code has undefined behavior if the input length is zero. You either need to check that this is not the case or change up your code a bit to work without handling the first node in a special way. It is unnecessary to repeat the node creation code so often. Just make a function which inserts a new node before the node pointed to by and updated to point to the new node. In fact I think this belongs into , rather than , so that will handle its own memory. I think holding the is unnecesary, as you can just get it from one indirection to . You are basically reimplementing a holding pairs of and . Maybe try using the standard library directly. I tried it out (I deleted the file accidentially though) and got your algorithm down in about 15 lines or so with and no performance impact on the test case and only about 10% additional time on the test case (but that might be improvable). If you used a tree () instead of a list to store your sorted values, then you can reduce the time to . I think this should also be possible while still keeping your behavior for smooth input. If you used a hash map () instead of a list to store your sorted values, then you can reduce the time to by counting all elements with the same key and ordering keys with afterwards. However the complexity for smooth data would not be better than that in this case, except if many consecutive values are identical. 

I suggest you extract two methods: to check if the user is authorized, and to handle behaviour. You would then end up with this: 

Try not to use with and conditions because it becomes confusing. It's clearer to use negation: . Some people are boolean impaired, including myself. I'm not sure under what circumstances the hash does not exist. So checking for its presence may be redundant. 

Ideally you will want a nice helper for this. Now you can helpers from inside the decorators using the context.