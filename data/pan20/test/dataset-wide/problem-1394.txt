This is a project I've been working on and released on GitHub here. The purpose of the module is to provide sessions, which can be used in situations where access to sensitive data needs to be restricted. A session can be implemented alongside your normal code flow, or by subclassing . 

I am having trouble getting this to be more scalable. Adding a row/column would currently require adding another two lines to the code, so for a larger number (128 / 256 positions), this would become unmanageable. Also, for each added row, the print() function in draw_graph needs another line. If anybody has any suggestions on how to simplify the graph matrix or draw_graph / update_graph functions, or otherwise on how to improve the code, I'd love to hear. 

Getting this right is possible, but you must be willing to spend time and effort to do research, lay out an API, and document it. 

Use whitespace more efficiently, especially in your palindrome() function. Instead of converting n to str() in your palindrome() function, use numbers.append(str(x)). This way you can reuse palindrome() and have it take n as a string by default (or use an assertion / try: except: statement). Rewritten: 

You can then check if , to run if the script is called as the main program (see 'What does if __name__ == "__main__" do?'): 

Appendix: Design API design Since you plan on matching PyGame's functionality, you should take the time to think about how you want to design your API. You've taken an event-driven (callback functions) approach, which is probably the most sensible thing to do for user interfaces in general. As it stands, though, the caller can't retrieve the return value of the callback functions, which means in more complex cases, you'd have to modify a shared variable, which can get really messy, really fast. And I haven't even covered threading yet. Interrupt handling If I press Ctrl-C, I get a bunch of traceback lines, but more importantly, my terminal is still in cbreak mode. Once your codebase starts growing, it becomes tiresome to wrap every call in a -block. You could put the block in , but that would mean a forceful exit any time the user presses Ctrl-C. Unfortunately, there's no trivial solution. Backend I have my doubts about the UI backend: 

Note that I removed , because the statement result is immediately discarded anyway. Suppose we feed a key of and a message of to the function. We now have: 

Others already provided great answers, but I'd like to add something about portability. I see you used the python2.7 tag, but I feel like (at least for this snippet of code) there shouldn't be a reason to limit it to Python 2. If you're learning Python from scratch, I strongly recommend learning Python 3. Support for Python 2.7 will be dropped soon and version 3 future. 

In my opinion, no, this isn't any better than just making use of the tools that provides out of the box and a class is overkill. operates in a very similar way, so it should be just as easy to call it straight-up: 

A list comprehensions is shorter and often faster than its -loop counterpart. Debug messages should be sent to stderr, not stdout: 

This is pretty clean code, good job. I'll be reviewing each file in order, and then I'll you some extra advice at the end. server.py General 

References 1 PEP-8: Imports 2 PEP-8: Function and variable names 3 PEP-8: Class Names 4 PEP-8: Blank Lines 5 PEP-8: Other Recommendations 6 Here's what I mean. 7 Using ANSI escape codes fixes the problem for me, which suggests the bug is related to '$ clear'. 8 Wikipedia: ANSI escape code: Platform support Appendix: My reasoning With most of the points I wanted to make out of the way, I want to explain some of the changes I made. 

There's some things I really like about your code. For one, you used , which is in many ways superior to -formatting. You also included docstrings, which help others better understand your code. The other answers already covered most major problems. I'll be answering mostly in terms of design choice. Object oriented programming (and why it doesn't apply here) Classes should be thought of as containers that capture 'state'. Methods can act on that state and properties can be used to query it. A die, however, doesn't have any sense of state. A good rule of thumb is that if a class has only two methods, one of which is the constructor, then it shouldn't be a class. I'd go further and say that you shouldn't consider creating a class if you are not confident that there is a sense of state in your program that could be grouped together. If you want to know more, there's this well known talk on when not to use classes. Python 3! Python 3 rocks, and you should definitely start using it right now. Python 2 only has so much time left, and switching to Python 3 isn't that hard. The only changes that affect this code: 

In addition to @Snowbody's answer, I'd like to point out that and are not fit for generating passwords. The module makes use of the Mersenne Twister, which is not cryptographically secure. The Python 3.6 release added to the standard library, which retrieves random data from . If you're not running Python 3.6 or upwards, you can still use (or directly). 

This one's common it seems- Whitespace Python relies on whitespace and proper indentation to be readable; both for the developer(s) and people from all over the world who view the code. You should try to add whitespace to seperate logical pieces of code from one another. Especially your load_game() function needs this. I've rewritten it so it's more readable: 

It's hard to track where they are being used and modified. This problem becomes very prominent when using threads; Loading a global variable is more costly than loading a local one; If you design an API and have lots of global variables floating about, when someone performs a wildcard import, their global namespace will be cluttered. 

I don't get the point of . It handles the case where the current working directory has been changed, and it's called for each comic to download. That seems pretty pointless to me. Instead, I would only create the directory once, in : 

However, neither of these apply here. Using global, non-const variables makes your code harder to debug, and is a burden for anyone reading / updating it in the future. You can avoid global state here easily by passing variables as parameters. In my opinion, is a bit overkill. I'd make it a constant instead (). The loop in can be improved: 

really confuses me. Type checking is the way to go for readability. On top of that, if you need to accept new types later, all you need to do is add an statement. In my opinion, if you absolutely want the brevity of , accepting multiple types of arguments is fine, and so is returning multiple types (as is the case with many builtin and standard library functions). It is important that you mention this in the documentation, though. 

Some very nice code, overall. There's some minor points I think could be improved, but your general implementation is good. Nitpicks I'd like to point out some small 'issues' regarding best-practice and code style: 

Good job, this is some very clean code. There's some small things you could improve, but for the most part this is readable and to the point. I'll be going over some smaller issues first, and then cover your main question. 

Rewrite Putting everything together (I've changed names, reordered some functionality and added comments explaining certain changes): 

Yes and no. Your approach works, and it is easy to understand. If, however, you want to keep track of what type of exception was raised, it could be improved. What if you have some super complex function that can raise 10 different exceptions, and you need access to the exception traceback if something goes wrong? You'd need 10 instances. In that case, you should use a instead, which is thread-safe (untested snippet): 

First things first, I really like your idea and I think with a couple of small changes it would be a really nice utility to use! To start out with, here's a couple of suggestions regarding code style: 

You forgot to define . I'm not sure if this is a quirk of my terminal emulator / MacOS Sierra, or if it's present regardless of setup, but the bounds checking in doesn't do its job: I can keep moving the pointer down forever, which causes interesting screen glitches.6, 7 This isn't strictly a bug, but if a user presses anything other than △, ▽, or return, the program crashes. 

I've written a primitive Python script which "draws graphs" based on a list. It works, but it's a lot of lines for what I am trying to reach. The idea of the script is to function as a module that can be imported for a quick visual representation of data. Here's nextgraph.py: 

Basically, any method, property, or attribute that isn't useful for end users, should be private. OOP could be a . A static method does not receive an implicit first argument. You should make a method static if it doesn't interact with the instance of the class, but is still strongly related to the class. I'd then rename it to : 

Don't use for error messages. If you want to warn the caller they passed an illegal value, raise a : 

My goal was to create a simple-to-use CLI program for drawing directory trees (what does on most platforms, basically). I'm submitting my 'backend' program for review because I think it makes more sense to review the actual algorithm, rather than reviewing an interface on top of it. 

Implementation The code as is works just fine if you need to modify a matrix, but wouldn't it be useful to turn it into a separate object altogether? We can do this by creating a custom : 

It can be a pain to do this every time you want an integer, so you may wrap it in a function for future use: 

client.py Disclaimer: I don't know Kivy, so I can't tell if you're following Kivy best practices. General 

References 1 PEP-8: Imports 2 PEP-8: Naming Conventions: Descriptive: Naming Styles 3 PEP-8: Blank Lines 4 PEP-8: Other Recommendations 

You don't need the clause here, since the clause stops the program if executed. In fact, you can simply return there. Putting this all together: 

As @Ludisposed suggested, you don't actually have to convert the entire string to lowercase, would do. 

Apart from that, your code is mostly clean. There's an official style guide for Python called PEP8 which I recommend you look over. Security First the good part: you're using , which is good, because it provides a lot more entropy than most other 'random' sources. Now the bad part: you're rolling your own cryptographic implementation. As much fun as it is to come up with your own 'secure protocols', 99% of them are broken from the start. As @Oscar Smith mentioned, you should use be using cryptography, which provides the high level Fernet protocol. 

You also leave the first line of every method blank (or make it a docstring). If a function is undocumented, I wouldn't bother adding a blank line: 

Regarding your actual code, the incompatibility is a result of your use of , which doesn't exist in Python 3. The Python 3 release renamed to and provided as a way to simulate Python 2's behavior. To fix this: 

Alternatively: using If you run the rewritten code, you may notice the program takes a couple of seconds to shutdown after (reportedly) having downloaded all images. This is because the last thread started doesn't necessarily end last (that's the whole point of threads, after all!). To avoid this, and to get rid of some of the boilerplate code, we can use and . I've created a GitHub gist here which uses together with , which reuses the underlying TCP connection, potentially resulting in even better performance. 

Very clean code indeed, there's not much to be said here. PEP8 I'm sure you've been lectured on this before, but there's an official style guide for Python called PEP8. It states that module-level class definitions should be separated by two lines: 

References 1 PEP-8: Indentation 2 PEP-8: Function and variable names 3 PEP-8: String Quotes 4 PEP-8: Maximum Line Length 

Ultimately, it's up to you. PEP-8 also lists some examples of acceptable styles.1 Use for function and variable names. Only use for constants.2 Don't mix single and double quotes. I prefer double quotes, because they're less likely to cause clashes with quotation marks in flowing text.3 Limit the line length to 79 characters.4