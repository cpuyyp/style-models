This will be quite big project it seems. I will try to give you some hints (I have written something like ECMA-262 / JavaScript compiler and iterpreter with custom bytecode as school project). If you really plan to develop big language, then you should probably learn about LEX, YACC and BISON, but you'd have to learn about formal grammar for parsers. If you are fine with learning by trial and error, your Lexar is not bad, but I would advise to start writing some custom classes and enums instead of all those strings: 

I usually focus on the design and this review won't be different. You seem to have created some custom universal allocator, that will place all the (different) objects in continuous space (a page) or create new page if needed. The whole space can be released all at once, but no individual objects. So... 

Example (added) I have purposedly created bad XML file and opened it in my app. The result is not so perfect (for a user, because they should never hand-edit the XML), but I can clearly see the problem: 

You can see I have moved few variables outside and added few to reduce the code a bit. But I am really not the one to talk about code-styling :D 

Comments about this topic ( and such) appriciated, I will gladly edit the answer, if somebody can shed some more light at it. 

Template (with some SFINEA for iterator->const_iterator) Inheritance (common base with the implementation) Composition (common struct to place inside as a member) to share some code. 

Looks like you can terminate the loop whenever you change . is no bad, use it ;) ( cannot terminate all nested loops, can) But that is only beginning, try thinking about the algorithm, can it be improved? What about checking the filled slot first (along with all sub-rows and sub-columns)? Try finding out all unnecessary computation you do and eliminate it (to speed it up). 

with one waiting/sleeping Thread to finally dispatch the finish action. Or atomic downcounter that last job will know to dispatch the finish action. 

I was looking a bit at your PyCXX and want to offer you Bartonâ€“Nackman trick using Curiously recurring template pattern together with variadic template recursion (through partial specialization). This way you can solve all your types and conversion operators with one template: 

Packet: Observer, Router: Obsarveble This looks like good pattern for new / system introduced in .NET 4.0 (or 4.5). I have used similar patter (my is your , is the same, my method is your ). I cannot see where you subscribe the transmitted packet to the receiver, but assume you will do that somewhere. Some inefficient code 

First of all, you should use instead of and please don't use for template parameters ( is mostly for preprocessor, sometimes used for constants and/or static variables), rather use , e.g. . Your implementation looks good to me otherwise, but you know it can only be used with containers with member . If you want to create it from , then it would be something different (e.g. ). You may find some inspiration in . 

Interface Enhancement The is not enough for algorithmization. A way to call some (templated/universal) function (functor) is needed. For now, this was added: 

How it works At first it was very confusing how it really works, but I think I got the idea: You are taking advantage of how is dispatched - through main message loop (the same way as implements interface). This allows you to have absolutely no in your code but still make it thread-safe (as your synchronizer is not designed to be accessed from any other but main/UI thread). EDIT: The importat thing here to understand is that BackgroundWorker is executing all the events except DoWork in main/UI thread - that makes it working. See comments and description bellow for synchronization needed if used with threads. Synchronizer and BackgroundWorkers speration I don't know why you designed it that way and if you plan to wrap it all in another helper that will be spawning the workers while connecting the callbacks as well, but I think it would be a good idea, because the synchronizer is quite unclear (how it works, how is it to be used). EDIT: I was at first assuming that the code is fine and working and therefore that it is designed that way - to be used with BackgroundWorker that is doing all the hard synchronization. The Main/UI thread only design I think that the main problem with your class is, that it is not clear that it is designed for main/UI thread only. To make it clear (and for better usage), you should derive it from the same way as is (and probably join it all together as already suggested). EDIT: When used with BackgroundWorker, all those actions/callbacks are executed on main/UI thread (no matter which thread started it). That is the nice thing about BackgroundWorker and why it is a Component - it is designed to run some job in the background (some thread) but report progress and completition in main thread that we can happily acces our controls without problems. 

Note: Maybe I did not get it right and BER is not designed for complex packets, but for simple tagged values. In that case, all could be done in constructor. Here you can see I have renamed your class from to , while using some method that would handle possible reallocation. The data is always encoded as big-endian (and packed), independent on the MCU architecture. (Note: Some prefer to use instead of , but the later is allowed within classes, forbidden in global space). The same could be done for reading, possibly creating two other classes: and , but you can have it both embedded in the (or ). The way you have it now, you have to create all the data at once (while handling the big/little endian) and pass to constructor: 

Code Styling Your code is very good at first look. Good structure, code-styling, new features used, clever trics. Functionality and Usability The message is for the user, the code is for you to debug it. Exceptions currently allow adding good message and naming properties won't help a bit (to the user, if it is designed to tell the user: "You did something wrong" like "Wrong Value Format"), but to diagnose problems, you'll need more than property/method name. And for that, you have the stack trace. To state it simple: the problem is not in the exception and what additional info it can carry (it already has the stack-trace), but in the way you present it. This is my own code I use: 

You should pass to your and terminate it, once you reach zero oxigen. Big map with low can cause TLE. You don't need the , you can reuse the array and just mark visited spots (e.g. with '*'). This would be wave algorithm (handle all nodes in the queue at the start of the step, reduce counter and proceed to next step, unless or zero reached). This is simplification of Dijkstra algorithm for graph with all weights=1. Your code is hard to read. You are on Code Review! You are using C++ but program like in old C. Use instead of when possible, avoid super-shortcuts like and , please. 

You can see, what is wrong, in the title - File Open Error And can track the exceptions to see what elements and what attribute is wrong (page-state-badattr). It won't tell much to the user (except for the title - could not properly parse selected file), but I know, immediatelly. Actually, the stack trace is not that important here, but the exception chain is perfect! But to achieve this, I had to create custom exceptions and add additional data (element/attribute name) to them. But that should be normal :) 

BTW: This would be the same (but the conversion is altered) in my own syntax, which you may find a bit familiar: 

Load the value - all the threads will see the same value, e.g. 3 Do the math = decrement - all the threads will calculate 2 Store the value back - 2, but the result should be 0 if three threads were removing their callbacks! 

The above code may not be optimal, but makes sure that all the actions are executed first and last (different solution with single lock could reorder them). 

As you seem to specifically ask for: Is there a better way for calculating the position of the user controls that are being added? I don't like the way the if/else looks but I am not sure how else to do it. My answer will address only this. You can make a better use of the variable and instead of use and later . The code: 

vs. - the later seems to allow multiple nodes (e.g. cities or what payload can be) in same place + accept/return list of such nodes/elements. What I am really missing is some Doxygen documentation describing every method and adding some usage example (note: the example was edited in the question while I was writing this review). - I would personally add another method taking pair of iterators: 

Why it has to be used with BackgroundWorker? Imagine that would simply spawn some thread, execute and finally on the same thread (not on main thread). That could lead to problems inside called on the list of . Imagine that it has to decrement the and is doing it with some math: 

It is removing first handler (if multiple). Nothing bad about it, just to note that you can think about it. Using remove-erase could change that (removing all of them), I would not change the code in this way if you are fine with removing the first only (which makes sense, or possibly remove last not first). The remove will be taken in to account in next round (when you copy handlers), not immediatelly. That is something that may be a problem. Think about adding to if that is desired behaviour (to cancel-remove it as soon as possible). 

Tag for SFINAE The needs to be identified by a tag () to allow SFINAE in variadic functions (templated overloading with ). 

Something more.... immutable Static reference to normal class What I had in mind was static reference to the class, where is like calling and is like and you can even have in it. But if you cannot redesign, you cannot. You got my thoughts, now it is up to you. 

First scan - not bad, but I would use another template parameter (defaulted to ). - now we know it is actually (which is heap). 

As the comments suggest that it is not designed for main thread only, then look at this Action returned: 

?? Again and again in the loop? You don't need the . And I would personally use instead of as type of the variable, in constructor, (or some readonly collection) as property type and some during the build phase. 

You should rather check the return value from (e.g. and/or maybe use + to ignore anything but digits: 

Alternatives The main question is wheter you really need the especially for its nice -> (which is again dispatched through main message loop). The alternative I would personally choose is to spawn for each job ( is doing that for you, maybe using ) and use 

The already pointed out is a bit more complex, because we are executing unknown actions - we should not do that in synchronization block (under the lock): 

That looks like you plan to derive from while providing and in the constructor and overriding which should therefore be . Did I get it right? Await Response Unfortunatelly, I am forced to use .NET 3.5 and therefore don't understand / that much (use threads and events instead). I hope that some override in your or casting the result to appropriate type (as the original returns , not or ) will solve the problem with type and later usage: . What I don't like is the active waiting (or it at least seems to be active waiting): 

Your code looks good, constants are good for understanding and possible future changes. BitArray is memory-optimal (if we don't count the overhead of the very object). Using it is limiting your getter. The only thing that could improve your code would be to use directly. That would need few shifts and masking, e.g. , but that may get less readable for somebody. For 8x8 board, may be even better: