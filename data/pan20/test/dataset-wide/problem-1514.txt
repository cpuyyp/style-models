Silent bug: Bad move constructor Your move constructor will perform a copy because your parameter is ; you cannot move from a value because moving implies modifying what you're moving from. Simply change the signature to: 

Do we really need and ? No. Here is an alternative solution: You currently allocate bytes. This is wasteful. You can use exactly as much space as you need by declaring your storage any of these two ways: 

Although C11 introduced , there is no support for aligned reallocation (AFAIK). The structure that follows and its related functions provide such functionality. I wanted to provide something with as little overhead as possible, which is why there's close to no error checking done. I envisioned this structure being wrapped in another structure that does do safety checks if that is required. Is this reasonable design? features: 

Extracts from the specified template argument integer pack the values from at indices in the range \$[src, dst]\$. If \$dst < src\$, a reverse extraction is performed. 

There is a small subtle bug you can avoid by doing it like shown above, but I will describe it so you can be on the look out in the future. The bug is that the elapsed time is stored in a , but basically returns . How is this an issue? Well, must be represented by a signed integer type of at least 64 bits (see: $URL$ While a does have 64 bits, it's certainly lacking the ability to represent values from the integer point of view. This would result in a loss of precision/erroneous results. 

Replace long conditions with type traits. In order to promote from a smaller type to a larger type, you currently enable certain conversion operators based on on your type . These quickly become hard to maintain and are error-prone: you might forget to add a type, you might forget to update something, etc. In order to solve this problem, you can take a type traits approach. It will require some boiler-plate, but not much more than what you've already got with those long enable-if conditions. Traits based approach: 

Method Name The method name is confusing, because the word "Log" to most developers means some kind of diagnostic routine that writes data to a file or console purely for debugging purposes. You are using it to take over the console (by clearing it) and output the text graphic of the dungeon to the console. I think a better name would be something like or something like that. However I think you shouldn't be having methods anywhere in this class, let the user decide what to do with it. If a class has a valid representation, you should be overriding the method instead, so becomes : 

You may be over thinking this, all the types have a common implementation and you can use to parse from a string. 

Also notice I changed the name. Also notice how I left out the method. This isn't a good way to do that, what if you wanted different text? Or only the number? In a different language? Try not to be too specific in implementation, leave that up to the "end" user. Actually instead of an class, I think this would be better off as an interface, this is what it would look like: 

Avoid Mutable Properties Your has a few externally mutable properties that I don't see a reason for them to be mutable. It would be better if these weren't mutable: 

I would advise to not have a list of "variables used" in your program. They really don't serve any purpose (pretty sure you can figure out when reading the code that writes to a file, etc). This only serves to add complexity to your code documentation. The problem is that if you change your variable name in your method, then you have to find it in there and change it too. Some automated renaming tools are good at renaming variables, but don't (usually) find it in documentation unless it follows a specific format (like Xmldoc). The other thing that I see is that you have a lot of "thinking" in the code in the form of comments: 

I've been on a quest to learn C++, and to learn, I've started building a small Role-Playing-Game skeleton to help myself learn the language. I've tried to make sure that I've followed C++ styles/standards correctly. This is the first "part" of my development of the skeleton, and it includes a usable class, . The class has the following attributes: 

Finally, this is not a good way to do password checking at all. Preferably, rather than creating your own system without any security, you should use a library, like OpenSSL. 

You should also also have two blank lines between functions, not one. You should also read PEP8, Python's official style guide. 

Instead of requiring the user to provide a file in the command line arguments, you can just do, well, nothing. This is the language Nothing after all. This means that this piece of code here: 

Issues You should also be using a context manager to open and close files, not . For example, this block of code: 

Now, while this is something that you can do, in the case of your code, there is no need to manually define the getters and setters in your properties. You can simply define an auto-property, like this: 

Not using is a really bad way to generate random numbers, you should be using a solution more along the lines of this: 

Using for string formatting is deprecated. You should be using instead. Here's how one would use : . also supports using keyword arguments. Here's an example of that: . Near the end of the function , underneath the block with the condition , you have comments above every line. These are unnecessary and can be removed. Finally, I'm not sure why you have square brackets, , around the value of the variable . If these aren't needed, they can be removed. 

But since we are learning about abstraction/inheritance I'll leave it as a class. Now lets tackle the implementations, I'll do two of them here, you can figure out the rest: 

So what is happening here is you know that for every open bracket there must be a close, so if we count all the opens, and subtract all the closes, that resulting number must equal zero. 

The first thing I would say is that the API is not well-defined. The upstream code should be calling the specific method. The fact that you call a single method based on multiple names is fragile. It seems like you are trying to stick an entire API into a single method. It would be much better if you exposed one method per "childCollection", for example: 

Now the user of your class can decide to do something else with it, such as write it to a file, send it over the network, print it on a webpage, etc. The user is no longer tied to the console. 

You are saying its a "tax id scan copy" but then you are loading a "photo" and displaying it as an avatar. What is the difference between and ? I'm assuming one is a physical file path and the other is a web URL. If that is the case, I would suffix the first with , otherwise a casual observer would expect it to return the binary image data. 

Now let's suppose we want to validate this class, but we need to support quite a few types. We don't want to have to modify the validation logic each time we add a new type, so lets create a validation attribute: 

You seem to be very much over-complicating this. Here is an efficient solution: Assuming and are positive numbers and the result is a valid 32-bit integer value 

Make an type where is the values in the range \$[from, to]\$ using an increment/decrement of . will be subtracted if \$from > to\$. Tests 

The variadic template is not a pack forwarding references, it is an rvalue reference pack. For it to be a forwarding reference variadic template, the variadic template must be a function template parameter: 

Note 1: I've renamed the function to to keep consistency with other similar functions such as . I've also reordered the initial condition to take advantage of boolean short circuiting. Note 2: As Rakete1111 points out, if your compiler hasn't caught up to C++11 yet, accessing the first character of an empty string is undefined behaviour. The condition should be modified like so: 

Consider the rule of 5 when your class manages a resource. Whenever your class manages a resource, it probably needs to implement the destructor, copy and move operations. You definitely do not want pointers to be copied when a copy of is made. Possible issues: 

You can similarly apply this to all your other applicable conversion operators. It will greatly reduce the amount of code inside your class. 

Demo Note: The public interface should be based on as defined in the C++ standard. This implementation is purely for demonstrative purposes. 

Introduction In template meta-programming, integer sequences and ranges are very useful. I've made a couple of utility classes that do various operations on compile-time integer packs. The implementation is non-recursive (except for \$log(n)\$ recursions when generating a pack), allowing faster compilation and a greater number of template arguments. Note 1: In every implementation section, at the top of every namespace, there's a comment indicating which feature is inside. Note 2: Include guards are omitted. Note 3: The following headers are used: 

Because it allows you to change where you get the from in a single place. The next thing I see is this confusing piece of code: 

This keeps your database layer separate from your data layer and separate from your presentation layer. The more separation you can do here, the better off you are going to be when it comes to updating and maintaining this code. I would recommend a good read through SOLID principles to get an idea. 

Naming , to me, would mean that it is a class that generates a . But the way you use it, is itself, a Dungeon. I would drop the "Generator" part of the name, or refactor it so it is in-fact a dungeon generator. Additionally you have a namespace and a class within that namespace. I would avoid having a class the same name as its containing namespace. Otherwise you need to write confusing things like: 

It is now functionally the same but has less code to maintain. Nullable properties can also be defined shorthand: 

I don't see anything apparently wrong with the coding, other than the selection of your index variables seems to be random ( in the outer loop, in the inner one for example). is pretty apparent as to its meaning (index), but things like don't really have any semantic meaning. Like other variables, you are free to choose one that best describes its purpose and loop variables can have more than one character. The other thing I see is that at the top of your file you have this: 

This shows the power of inheritance a little better. MSDN also has a good example using shapes as well that you may want to read. The take-away here are these points: 

We need to test whether a certain door is openable by a certain key. Using the previous building blocks, that's easy to implement: 

Review goals The full implementation (with iterators and a -like interface is omitted because of the amount of boilerplate code involved. This question is already long. A sample toy implementation is provided in the demo below to demonstrate minimal usage. I would like a review that focuses on: 

Destructor Here, we notice that your only usage of is in the destructor. You don't provide any query member functions, so let's just go ahead and remove altogether. This will make the class smaller. You also want milliseconds, but first take seconds and then multiply by 1000. You can directly get milliseconds by using . 

Factor out repeated code. Your overloads and have the exact same block of code being repeated; this block is a prime candidate for being extracted into a private function: 

Additional usage/test This simple example shows how one would create the symmetric difference operation of two integer packs using the already existing operations: The symmetric difference of two sets A and B is the set of elements comprised of: 

and both have the member function. The function takes the arguments to construct the key-value-pair internally (thus avoiding copy/move operations). You can instead write your return statement like so: 

Performs the set intersection of two integer packs. The output set is sorted. The output set will have the same integer type as the integer pack specified as the left template argument. Tests 

3.3 Initialize your members in the constructor member initialization list You do it in some constructors, but not in others. Do it whenever possible. You can start with 's move constructor: