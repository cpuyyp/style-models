But you don't really need it. You never need the Fibonacci number here, out of the blue. You're always going in order. If you're going in order, you can just keep them as local variables and update both: 

Cents make Sense A much easier way to think about money is to just store everything in cents. That makes all your mathematical operations trivial (just translate to the appropriate operator). This is especially a big deal for things like comparison, where comparing one thing is easy, but comparing multiple things is much harder... Unnecessary work only has integer types. It doesn't manage any memory. So the default copy/move constructor/assignment and destructor all do the right thing. Let the compiler do its job for you, and do not write these functions! If you insist, you should just them: 

And so on. , , and The first function takes the average of ALL times, but the next two take the average of the TOP times for some number. That number should be an argument and the function should be named differently. In any event, should probably return the average, not just print it: 

Size Requirements You talk about wanting to "use less memory" than . But doesn't use that much memory. It's three pointers. I guess if you set your to instead of , you can have a vector of 16 bytes instead of 24, but I would really have to see what you're doing that that difference should matter. Performance There's two glaring issues that jump out at me as far as performance goes. I suspect this would be substantially slower than . First one is on : 

What value do any of the comments there add? None. You have a comment to "return the node" next to the line The code itself is already written in a very readable way. I have no issue with the code for . If a reader can't understand what the function is doing, then it's because they don't know C++ - the comments aren't going to help anybody. Minor comments follow 

Furthermore, those asserts don't need to be in the constructor, they can be in the body of the class. Lots of code Repetition Pretty much all of your code is just duplicating what does. What does actually give you? It costs you aggregate-initialization, and that's not nothing. Ultimateyl, it's really just a with some extra conditions on and . But we can just use those same conditions to SFINAE the : 

Now, if you want to add a new attribute, you need to add one line of code. Just another . That's tough to beat! 

and forward them into , and only there do you construct a . Never take a , you're going to shoot yourself in the foot. Minor Issues Avoid writing expressions like like you have in , just use : 

Note that the operator here takes s and not s. We know what the derived type is, so we can just use it. The nonqualified call to lets us write something like: 

What are , , , and ? I can't even tell from the body of the function. Avoid single-letter variable names unless used in a context where they are truly trivial (e.g. iterating over a range with or is fine). Function names should be , not , and should describe what the function actually does. Certainly and are not helpful at all. Which one checks which kind of diagonal? What arguments do they take? What do they return? docstrings belong inside the function: 

There's no need for - you know is supported. Throwing on empty range Honestly, I'd prefer it just be undefined behavior and avoid the first check. Let the user deal with it. That's just a personal preference though. Additionally, you could return an , returning if the range is empty. Defer to ? Since is more efficient than yours for forward iterators, it'd be nice to defer to it if you're given a forward iterator: 

That is a single atomic operation. We load the value of and if it was , we set it to and the function returns . If two threads get to that line at the same time, only one of them will succeed in flipping it to and the other will fail. This also gives us... Copyable? Movable? Dropping the means our class is tentatively copyable and movable. Do we want to support that? If so, the default behavior is bitwise copy and move which is fine for PODs but not for anything else. You would have to add those operations. 

Well, you kind of have to have two arrays. You need your counts array and you need your output array. If you want to sort the input array in place, you can do that, that's just a completely different semantic for your algorithm. So you'll just need to figure that out up front: do you want to sort the input list (a la ) or do you want to return a new list that is sorted (a la ). That said, here's some comments on your initial solution. To start with: 

Side note on this guy. It doesn't actually do what you want. This isn't an arbitrary rvalue reference - it's a forwarding reference. In fact, we can even combine the two constructors here in one go: 

This will additionally let you use non-class types as optional data members (since you couldn't inherit from, e.g. ). So you can now do something like: 

On the producer front, did you really mean and not ? Let all the consumers fight for the lock! Lastly, this: 

Don't Repeat Yourself Consider , , . They all have the exact same structure: they befriend , hold onto some , which is exposable, and are ly constructible. When you see that kind of repetition in class definitions, that calls for a class template: 

Value constructor Well done on making the value constructor explicit. However, you're using the wrong type trait. You're checking if to . But that's not what we're going to do with the . We're not implicitly converting. We're explicitly constructing. The two are not synonyms. You should instead prefer: 

Although would definitely be the preferred container since you're always appending and traversing in order - and never doing any of the operations for which linked list is favored: 

Break out your type trait You have this large amount of checks in a couple places. Break it out in its own trait, and call it something like : 

This will be \$O(n)\$ to create the hashtable, and then another \$O(n)\$ to do all the searching... for a grand total of \$O(n)\$. 

Uh, what now? I have a 5-dimension array that consists of 32 integers. That should be 128 bytes. You're using more than 10x the amount of memory necessary! And that underestimates the size since you have this huge which is all on the heap. Why? Because in addition to storing your array (), you're storing completely unnecessary information in and . Why do I say unnecessary? Let's consider your access by : 

Ok, we have a typelist. Now we just need to filter it down based on a condition. To filter, we need to be able to concatenate: 

Metaprogramming is all about convention. If everybody doesn't agree on convention, everybody's metaprograms may as well be written in different languages. The most core convention is that the "return" of a metafunction lives in a type named . But a fairly common one is that when you need a "metafunctor", you pass something like this. The advantage of something like this is that it's always easy to create a type, but usually not so easy to create a template template (which would be the alternative). Specifically here, we need: