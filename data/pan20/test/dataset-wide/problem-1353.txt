Firstly I would like to describe some generic recommendations (and performance improvements, as I assume it is quite a critical data structure for you): 

Note that semantically these options are not equal. There is a chance (very-very small) that first option will output smth like , so second option is better at least because it will always generate consistent results (3 consecutive years). But second option is also quite cluttered. There is a method that is able to combine different values with separator, so your code may look like: 

I may have gotten your question wrong... Will the following implementation work for you? Can you show how your looks like? 

Your code is correct as long as you plan to validate business integrity using triggers. But I would question whether business validation in SQL Server is a right choice: 

You have a bug in your code: can return a new instance, and you ignore this instance when calling and . Also, I do not see the reason to iterate on simplification (), as it appears as each expression will only need one call to be simplified. class exposes 2 public fields, and . Exposing public fields is a bad practice, and I would assume there may be cases where expression can have 1 or more than 2 "parameters". Can you make use of Expression Trees available in .NET instead of developing your own framework? It seems like a good fit for your purpose. If not - I would still consider copying design patterns from it, like immutability of expressions and Visitor pattern for walking the expression tree. 

Also I would suggest to use CancellationToken to stop asynchronous processing. UPDATE Based on comments it is really needed to wait for all workflows to be configured before starting them. So cancellable implementation can look like this: 

Here we release the UI thread and running a (computing) task in parallel. The reason I've added "computing" is that you're manually spanning a new task using . In case of I/O-related task returned by .NET framework it won't actually represent a new thread as it can wait for external data on the same thread. 

Now it's much cleaner, and the caller of this method can decide what to output in case when SQL Server is not running... About DB wrappers - I would suggest to avoid them at all. They represent abstractions over abstraction (Entity framework). By wrapping adds/deletes/selects in separate methods you loose lots of benefits provided by ORM frameworks like transactional nature of the DB interaction, without getting pretty much any benefit. It's actually much easier and cleaner to explicitly define context boundaries (in case of Web processing boundaries are already defined) and directly use the ORM to manipulate with the data. Update based on updated question. There are several issues in the code that uses class: 

Assuming that you load the data into your instances from database, it's better to issue a direct query over database rather than iterate on a client. As a side note - it is an awful practice to compare dates by comparing strings. If your table has a column it's much better to cast the value to and compare typed dates like that: 

It looks like valid implementation, but it could be simplified. Also there are some naming issues: in method is actually a and not a string. carries a single char but is declared as . You have a lot of trie management code inside class while it would be more readable to have the logic in class: each node would be responsible for making decisions on its own level, delegating further decisions to its children. Also there is a common trie optimization that groups several chars in one node, e.g. if you have only and words you would have 3 nodes: din with children (din)e and (din)ner 

You have a bug in implementation, you're throwing based on instead of values. Also, you don't actually need to throw this exception explicitly, it will be thrown anyway by expression. 

Based on your comments it looks like your code is actually some sort of library used by different clients in different environments. If that's the case I would rather let clients define the batch size they want rather than writing tricks around memory management on your own. If you do need to manage the memory - I would suggest to reduce the frequency of calls, e.g. check it once per 1000 rows or so. Bear in mind that since your component is not the only one in the application it may turn out that application has already consumed 1GB of RAM thus causing you to reduce the batch size to minimum. 

In addition to Jeff's changes (I completely agree with all of them) here are my 2 cents: I assume this class may process large number of documents, so it's better to switch it to using streaming techniques where you are not required to keep all the data in memory. So, let's start with constructor... it's usually better to move time-consuming logic out of constructor, e.g. you may later want to introduce asynchronous implementation. So we get rid of constructor and move all the logic into method. By following "streaming" technique it should receive IEnumerable instead of pre-loaded array of documents. We will calculate all the stats for each document and then forget about it, so all the arrays that expected a known number of terms and documents should become lists (except as it have to be calculated later, when the total number of docs is known). Here is the resulting code for your class: 

There is no sense in creating a task and waiting on it straight away. The following code is almost identical to your test method (almost - because tasks are created on a thread pool here): 

Since we are on a code review forum I would suggest you to give more meaningful names to variables, avoid redundant assignments (e.g. initial array assigned to variable is not used), and split the logic into smaller methods that perform distinct functionality. Also you can use extension method instead of writing your own. But I guess that's not what you want to hear, so in terms of algorithms I suggest you to apply the A* algorithm to this problem instead of full search. If you find it difficult to understand and implement, I would recommend you to pass the Machine Learning course from Coursera or Introduction to Artificial Intelligence from Udacity 

You're misusing , if you pass only one parameter it should contain the name of the parameter which value is null. You don't need at all, as you just kill all the benefits of task-oriented approach with it. All you need to do is just capture the task, without awaiting on it. As a result you don't need all those calls as well. Since you're just outputting the collection of different tasks that eventually return the object - I would prefer to return the instead of . And finally - split different approaches of getting the result record into different methods (if not classes) so that the code remains clean. If you use an IoC container you may even want to split the implementation into different classes implementing the same interface, but that would be too much for this example. 

As to performance improvements (other than caching ) - currently you scan the through the list for each and every item in . Assuming that lexicon is built from it would be much better to scan the list only once, tracking which items you've already counted and where are the doc boundaries. Since you haven't provided the meaning of all parameters participating in this method it's hard to suggest a proper solution, but here is the first approximation: 

Based on discussion in question comments it sounds like might be unnecessary. Then, parameter can also be dropped in favor of 2 different methods. So, in case of it gets simplified to: 

It's better to use constructor to set the cancellation after 5 seconds. Also, method is a recommended way to run compute-bound tasks (see remark here). Other issues worth noting: 

This kind of condition may actually hurt performance quite a lot, because query optimizer most likely will be confused by complex filtering condition and would have to do a table scan rather than index seek (assuming that you have index over and ). In order to improve querying performance you should simplify clause. Best solution would be to utilize client-side ORM capabilities to generate dynamic filtering based on available data. If that isn't possible, then I would go with one of the following approaches (I would prefer Multiple queries approach in case when select statement is simple): 

The main issue in this code is that several classes rely on each other's proper behaviour in order to work correctly. I'm talking about sharing the instance of and requirement for proper locking on it in all places. See remarks to Statement for recommendations on proper usage. Since you mentioned that you can't use the namespace I suggest to create a class that mimics BlockingCollection functionality to avoid first issue. It should incapsulate the thread-safe manipulation with queue, so that both and don't need to handle multithreading logic. Also I don't see the reason for deriving / from . They use functionality of , but not extend it, so classes should not derive from it and rather store the instance of in a field. 

You don't need to change anything as long as the code performs what you need. If you want to insert records to another table on every update (and not only in this place) you should probably take a look at triggers 

Instead of sleeping for short periods or using it's better to use waithandles, in your case. I don't have Visual Studio at hand, but the following example should give you the basic idea (most of the complexity will be gone if you start using .NET 4 or 4.5, in particular ): 

It's quite easy to answer your question by looking at the source code. As you can see they copy all objects into new array before iterating them. I suspect that your code will work incorrectly when rows are deleted (accepting changes for deleted rows means removing them from ), most likely you'll get exception since it's not allowed to change collection while iterating it. 

What you have done is usually called a Maybe Monad. There are several implementations of those for .NET (one, two), and usually they just use extension methods to apply operations to nullable object. Concerning your code: you don't need a hierarchy here, since most of the code is already in base class. 

You are using / absolutely correctly, that's how they were supposed to be used. Please note that from this code it's hard to tell whether the method will return the immediately, since it will be waiting synchronously for method to return the , and thus the answer depends on the implementation of . As a side note - you are using implicit dependency here (first method prepares files in folder, and second method enumerates all pdf files there). I would prefer explicit dependency: to return a collection of FileInfo objects consumed by the method.