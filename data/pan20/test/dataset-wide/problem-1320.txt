You've put a boundary in between yourself and the third party interface, but then you've turned around and coded against an implementation. We should code against whenever possible. Right now you're probably confused. 

First and foremost, use in all of your code modules. It forces you to declare all of your variables. You have about 20 declarations at the top of your module, but haven't declared your recordsets at all. These are never used I didn't check the rest of them: 

Disclaimer: I'm a SQL Server guy. I might get the particular syntax of MySQL wrong. I apologize if I do. The first thing I notice is this that subquery shows up over and over again in your query. 

I think you've done a great job of creating comments that say why, not what. That's very promising. Well done. You also did a great job of keeping your main method small and the "business" logic separated from the input/output of the program. One small thing to mention in addition to what's already been said. 

At this point there's still some duplication, so you could use the concepts from #1 to extract the inner loop to its own subroutine. Some other things you could do better: 

Which is hopelessly confusing because the second call is actually starting the . Consider renaming your private field. The chained calls in main are also confusing. I'd recommend an intermediate variable to clarify it. 

BUT........ Correctness Is a valid string? Both your and my method says it is. Your regex also suffers from the same problem. 

Agreed with what others have said about not putting actual values in your method names. Personally, I like names. Yeah, they're long, but useful in projects of any size. There's no reason to repeat the category string all over the place. 

I was inspired by Me How's question to see how far I could push an imitation of .Net's Enumerable Class. The new functions can obviously handle Collections, but can also handle any collection-type object whose items have a default value. If a 's items don't have a default value, Runtime Error 438 "Object does not support property or method" is raised. So, things like and work, but doesn't. and only differ by one operator, so there's some duplication there, but I don't know how to refactor it out. also seems inefficient to me, but I couldn't imagine a better algorithm. So, those are particular areas of interest to me. Suggestions for which features to add next would also be appreciated. Enumerable.cls 

API (or the lack of one): As it stands, we can't sort any array except the one you've hard coded into the main method. You should create a separate method that accepts an array of numbers as a parameter. Then we could call that method from , or anywhere really. Naming: It's hard. Really hard, but I recommend against one and two letter variable names. It tends to obfuscate the code and make it hard to follow. I don't like having to map meanings in my head. That's even harder than naming things. 

So now, we can go ahead and write that method. We'll pass in the actual checkbox control along with our predefined true state and false state. 

Let's start with some sensible line continuation and indentation so we can see what's actually going on here. 

I'll let someone smarter than myself help you with your actual problem. I'm going to talk about naming a little bit. Naming, you see, it's important (and hard). If your variables had more descriptive names, you might not have had to write several paragraphs explaining what they are. Poor Mr. Maintainer will not have the benefit of your explanation either. By time he sees this code, you've already moved on and he's left figuring out what's what; mapping short and cryptic names to meanings in his mind. 

This is just begging to be a method called . It should return some object that represents those three values in some sensible and well named way. I apologize that I've left s critique without any code examples. Normally I would provide some, but it's been a while since I've written any Ruby. It's better in this case that I leave you to attempt a clean up yourself. Try to: 

The creates it's own instance of the object. I have a real concern here. I don't like that I have to pass in the test name along with the actual conditions I'm testing. Assert.cls 

There is a pretty big flaw with your logic. This query might work okay here, but wouldn't work as well on a site like Stack Overflow where it's more likely for an answer to get upvoted long after it was originally posted. The problem is that the query will be naturally skewed toward older answers simply because they've had longer to accrue votes. Unfortunately, I don't know quite enough about the schema to offer an alternative approach. 

Anytime the same string literal shows up more than once, I recommend using a constant instead. It will protect you from spelling errors that can cause runtime problems. Apply the same advice to your method. 

Indentation, it's important. Please indent one level for each set of braces moving forward. Frivolous comments. You have one comment for each function. These comments simply repeat what the names of the functions already tell us. They're noise. Remove them. I find it's a good practice to write pseudocode comments and then "fill in the blanks", but they shouldn't stay once you've implemented it. Comments should always say why, rarely should they say what. 

Ultimately I realized there's never actually a need to check the flag, so you could probably just drop the Enum and change to a Boolean with a default value of . Abstracting this to work on columns instead of rows is easy. The logic doesn't change at all. You just call it with the row number passed into the column argument and the column number passed into the row argument. So, really, naming the hard part and I'm drawing a blank on any actually useful names, but for the sake of giving an example... 

As I commented, using this method to fake a constructor makes setting a variable to the default instance looks wrong and that's half the battle. We want buggy code to look wrong. We need it to stand out from the thousands of lines of boring code that works just fine. 

I know this is a fairly old question, but I'd like to point something out. While and are commonly used as "counter" variables, they only serve to obfuscate the code in this case. By time we make it to , it's very difficult indeed to tell which variable stands for what. These should all have meaningful names for Mr. Maintainer's sake. This is a little more verbose, but (I think) a little easier to understand. Particularly considering that it's easy to see now that the in the initial loop, is not the same as the one nested in the second loop. 

This doesn't buy you much though. Just the ability to format your code nicely without making twenty lines long. Now, the more I look at your , the more I don't like this parallel array thing you have going on. I would create a simple struct (or perhaps a class) to hold this information in. Something along these lines. 

Which brings me to my next problem. It's case sensitive, right? So, wouldn't match. I believe it should, but I'm not familiar with Robol. Please correct me if I'm wrong. I've seen this handled by defining case insensitive tokens for each letter. 

I haven't run the code, but are you sure it does as you expect it to for odd length strings? By padding the last character with a space, you get some... interesting results. For example, inputting will return . That doesn't seem quite right to me. I would expect it to return . I would do something like this. 

If I got that wrong and those are namespaces, not static properties, for goodness sake use some imports. 

Doing so would dramatically reduce the horizontal scroll. This logic gets repeated an awful lot too. It only differs in a few places. It should be possible to extract a method something like this. 

Now, the view interface is your public API and subclasses , so it's completely appropriate to expose the binding list directly and have your Presenter/Controller modify the View's collections directly. 

I would create two functions that take a form as an argument and return a point representing the and center point respectively. 

I would look for ways to reduce the nesting here. Probably by flipping some of your statements to be guard clauses instead. The statement will help us out here. 

First of all, you're throwing new exception, just to immediately catch it. That's... pointless. Secondly, you've not implemented correctly. Please see this for an example of how to properly implement it.. Lastly, why are you implementing at all? You're not actually disposing of anything! 

This is an adhoc query now, but many many adhoc queries make their way into production use. Never should you in a production query. It often forces a table scan where a more efficient query might be found otherwise. 

Either way, this method allows us to remove the duplication and string literal by utilizing a lookup table. 

That's an awful lot of horizontal scroll. I'd recommend moving the Linq outside the loop and adding some line breaks. 

Using makes it clear to Mr. Maintainer that this check is not a typo or bug. I would much prefer this. 

But I still don't like it. Let's say down the road Mr. Maintainer realizes that something else should happen . Then they do something like this. 

It's really very pleasant to read this code, even if there's quite a bit of it. I'm also a big fan of fluent API's and it seems that you've implemented one that I wouldn't mind working with. 

It's not very DRY or configurable this way though, so I tend to go one step further, and make my repositories look something like this. 

Yes. Yes. I know that it shouldn't ever be less than zero, but document that in the code by throwing an exception and leaving a comment saying that it shouldn't ever occur. This way, the maintainer will know that this possible (highly unlikely, but still possible) condition was considered. 

Number. As. String. Let that sink in for a second. You're passing a Number into your function as a String. If that doesn't smell funny, I'm not quite sure what does. In fact, your function doesn't care at all if what it's padding is a number or not. 

It's hard to say exactly how this will be implemented without seeing the entire sub/function, but what you need is a statement and a loop. Pseudo code to get you started: 

But.... what exists? Let me just look a few lines up... OH! A record exists! Why don't we just say so? 

Well, having your abstract class rely on its inheritors like that makes it pretty much useless. This should be declared like this. 

Considering your constants seem to be related to writing those files, move those constants to your new class and you'll have no more worries that they're in the wrong place. Speaking of repositories... 

When thinking about interfaces/class hierarchies it's useful to think in terms of "is a" or "has a" relationships. Bob is a player. A rook is a piece. A player has a rook. I would modify your interfaces a bit. 

The comments are nice, and add a bit of clarity to the code, but these kinds of comments indicate an opportunity to extract subroutines/functions. Each of these comments could be replaced with a well named function. 

One empty interface could be considered a code smell, but can sometimes be useful for reflection purposes. Having two is nonsensical. An interface defines a contract that the type has to adhere to. Where's the contract here? I fail to see how these two types belong to the same inheritance tree. "Type" members also set off alarm bells in my head. They're usually an indication that there are missing interfaces. You could then just inspect the actual type, if you really had to. I would go with something more like this. 

I think this is pretty much done. You have great naming. No glaring bugs as far as I can tell. It's clear and concise. Very OOP, which is impressive given the language. Even the high level design seems pretty darn tight. (I know very little about dependency injection though. I could have missed something that would be obvious to someone else.) I just can't find anything to pick apart. Well done. Thank you for helping me make the case that VBA is a legitimate programming language in the right hands. 

So no, this may not work properly. You need to register an event handler on the event so that you know the message has sent successfully. I'm going to be frank about this, the SmtpClient has an awful API. Your confusion is not your fault. Your best bet would be to create a dictionary of recipients to use as a queue. 

I haven't thought this entirely through, but I can see subtle bugs happening in the client code because they've accidentally swapped the real and imaginary parts. Would it be better to create types for these in order to gain some extra type safety? They would both basically just defer to , but it would ensure that this method isn't accidentally called with the wrong arguments. 

Note that in your full code, you will likely need to also pass the appropriate ranges into this method as well. Also, I'm not sure if you need this line of code, so I've left it's equivalent in the above method. 

Open Paren; A Letter; Any letter, digit, or underscore; close paren; optional space; lambda; optional space; anything goes. 

All of these variable types declarations could probably be replaced with the keyword. I know the last one could. 

Now we can start rewriting the main function with that and I was talking about earlier. But before I do, I'd like to note that you have a deceiving variable name. 

It's already been mentioned that you're in need of a player class and you seem to be interested in my XML Serialization suggestion, so I'll forgo a traditional review and show you how I would do that. Let's start with looking at your XML. (You should properly indent your XML by the way.) 

I don't like hardcoding values like this. I'm sure you'll be ok, because I doubt the format of your NIC will ever change, but for clarity's sake... This: 

The sub name is a bit hard to read. I personally like the .Net capitalization standards where methods are PascalCased. Isn't easier to read? Also, get into the habit of explicitly declaring scope. 

You already have a reference to that worksheet stored in (which will henceforth be referred to as by the way), there's no reason to get the worksheet from the collection via its name. 

So, you should probably declare them as actual constants. This removes the possibility that you'll mistakenly assign any of them a new value. Except... I would probably inject values into the constructor for all of the "number of characters" fields.