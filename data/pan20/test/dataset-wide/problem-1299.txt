End the loop with Instead of ending the loop with , it's more idiomatic to use . It requires less typing and avoids an unnecessary subtraction. 

I'm looking for suggestions to improve any aspect of the code. In particular, I'm looking for suggestions to improve my use of C++11 and C++14 (I'm compiling with Visual Studio 2017 but most of my C++ experience has been with a C++03 compiler). Also, some specific questions: 

Avoid This can cause name collisions because it adds every name in the namespace to the global namespace. For a small program like this one it's unlikely that you'll run into any problems (then again, maybe not) but it's best to get into the habit of using the prefix on names in the namespace. Alternatively, you can introduce using declarations like to add specific names to the global namespace. Avoid in favor of flushes the stream, which can cause a loss in performance. Don't reinvent the wheel Since you've tagged this homework you may be required to implement a linked list as part of the assignment. If not, however, you can use with your struct or something similar as the data type for the (you'd be able to remove the field of the struct). Here's a basic demo of what such a contacts list would look like: 

These two structs hold the same categories of data, just that one holds budget data and the other holds expenses data. You can just create one (called, e.g. ) and use one variable of that type for all the budget data and another variable of that type for all the expenses data. Using one for both reduces the amount of code you have to write and, more importantly, reduces the risk of bugs if you need to add or remove categories: instead of having to remember to modify both of your structs you'd only have to modify the one struct. Similarly, you have a lot of code like this: 

Consider a class instead of 2D arrays Mathematical libraries implement matrices as a class. Internally, the class may use 2D arrays to store the data, but client code shouldn't depend on how that data is stored. A class can hide the implementation details from client code. Extend to non-square matrices In general, an \$N \times M\$ matrix \$A\$ can be multiplied with a matrix \$B\$ if \$B\$ is \$M \times P\$ (\$A\$ has \$M\$ columns and \$B\$ has \$M\$ rows, but otherwise the two matrices can have different dimensions). With a function template you can easily extend the multiplication function to support non-square matrices. Simply add the necessary template arguments and tweak the algorithm to use dimensions other than . Here's a demo: 

Avoid It's a security risk, not portable, and introduces unnecessary overhead. Variables should use the proper types The return type for is (which is usually an unsigned type), so that should be the type for , not . Similarly, should be of type because: 

Client code can obtain a reference to the member for iterating over it and/or to call its and member functions. Client code can also access a directly from using or . Here's a small demo program to show it in use with both mutable and const iterators, and accessing a specified : 

Check your inputs in You don't check that the user entered a valid vector index. For example, if I enter a as the row and/or column number the program crashes. You should reject an input if the user enters an invalid row and/or column number (like you do if the user selects a space that is already taken). All control paths of should return a value You only ever in . If none of the check conditions are true then you should explicitly at the end of the function. Use the correct type for indexing You have for loops like , which compare the signed integer to the unsigned integer . Use . Use a type alias / type definition for the container Use a type alias like if your compiler supports it, otherwise use a type definition like . You can put it after the statements so you can use it for all your functions. This is useful for a couple of reasons: 

I would take a different approach to solve the problem. With your approach, you have to iterate through the string at least once to sort it (step 1), then again to remove the whitespace (step 2), then a third time to look for duplicates. If you copy the string in step 3 that's yet another iteration. You only need to iterate through the string once. Here's one way to do that: Iterate through the string's characters (skipping the whitespace characters) and put each character in a if you haven't encountered it before. If you've already encountered it (it's in the ) put it in a separate of duplicates. Once you've iterated through the string's character's once, you can iterate through the set of duplicates to print them. Here's a demo: 

Good job breaking up the logic in into different functions. However, some improvements can be made. Avoid This can cause name collisions because it adds every name in the namespace to the global namespace. For a small program like this one it's unlikely that you'll run into any problems (then again, maybe not) but it's best to get into the habit of using the prefix on names in the namespace. Alternatively, you can introduce using declarations like to add specific names to the global namespace. Make your code more re-useable / Don't Repeat Yourself (DRY) There are places where you've written a lot of code that does essentially the same thing. For example: 

I would still avoid On Stack Overflow, I once saw an even shorter program which failed to compile due to -- the programmer attempted to define a function which conflicted with . Your program may have less than 100 lines of code, but that just means there aren't too many instances in which you have to qualify a name with . Plus, it's best to get into the habit of not using for when you write longer programs. 

Avoid This can cause name collisions because it adds every name in the namespace to the global namespace. For a small program like this one it's unlikely that you'll run into any problems (then again, maybe not) but it's best to get into the habit of using the prefix on names in the namespace. Alternatively, you can introduce using declarations like to add specific names to the global namespace. Avoid in favor of flushes the stream, which can cause a loss in performance. Declare variables in the most local scope possible You declare at the beginning of but you don't actually use it (and initialize it to 0) until you're inside the loop. It's better to simply declare and initialize it in the same place and in the place where you start to use it. I would also rename it to be more descriptive (e.g. or ). Avoid hard-coded numbers Your code works with \$4\times 4\$ matrices but you've got hard-coded all over the place. You say 

you are comparing it to on the line . The two variables should both be unsigned for proper comparison, and preferably the exact same type. you are using it as the argument type for , which uses as the argument type. 

I'm still learning how to use the full power of C++11 and C++14 since I was using a pre-C++11 compiler for a long time, so are there any C++11 or C++14 features I forgot to use which would improve the code? I'm not very comfortable with move semantics yet. Are there some optimizations I've missed because of that? I've provided no functions to modify the internal data of the class (it is immutable). This simplifies the class design a bit (e.g. I don't have to check that at least one of the minimum/typical/maximum values are defined when modifying the instance -- I just have to delete the default constructor). However, in my usage it has occasionally been inconvenient to not be able to modify a instance after it's constructed (e.g. to acquire a instance with limits taken from another instance but clamped -- I have to copy it instead). Was my decision to make the class immutable a good one, or does it limit its usefulness? It would be nice to detect if the code is being compiled by a compiler that supports and use if so, or try to fall back on if not. Is there a way to do this without too much difficulty?