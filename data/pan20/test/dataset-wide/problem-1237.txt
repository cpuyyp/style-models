Not only that, but if you were to decide to expand or contract the board at any time, you could add or remove objects at a whim, and, so long as you release any references to the objects you put into the array, when the main array is released, it will release the sub-arrays, and the sub-arrays will release their objects. It really is quite beautiful. 

*As an aside, it's also a good idea to use an alpha value of 1.0f, instead of 255, because alpha is also measured on a 0-1 scale 

Alright, there's a number of simplifications to the Utility Class I'd like to make before I continue: Your abstraction from (at least that's what I hope it is), is too expensive to not just use the corresponding C-code directly. You could even make your own method in C, and use the inline qualifier for faster code than calling out to a singleton 3 times for every color. Also, it is never good to name an Objective-C method "instance". Singletons usually use a naming convention that makes sense with their overall implementation (i.e. ). The following will generate a random for you between 0 and 1. Not only is it cleaner, but it's cheaper. 

Actually, they are completely equal (obviously sans the keyword on the constant define). When literal strings are declared , the compiler expands them out to a compile-time constant expression, which looks familiar to us all: -albeit with a lot more compiler magic thrown in. Nearly the same process occurs with macros, but with one extra step: replacement. Macros are placeholders, which the compiler replaces with the value you at compile-time, which is why CLANG can show you errors and warnings. Where the difference lies is how much work the compiler has to do to replace your abstractions, not in the "memory overhead" they will incur (which means there is absolutely no speed or performance to squeeze out). Besides, NSString* is a brilliant class cluster that's been optimized over the years, especially with literal constants, where a sort of caching occurs in the binary itself. That way, literals used over and over again don't get reallocated over and over again. Though, to make one thing perfectly clear: #define'd literals do NOT reduce memory overhead! 

then I read that Haskell people prefer to compose functions and then pass the parameter, not doing the forward thing. What do you think about that? Also, I searched over the Internet, and I found some divided code, more like that: 

You better express your attempt with this. Also, you do not need to put the type of depth, this is by default. If you want to run at least one time the block, this is better (in my sense) to write this: 

I am learning Haskell, and what is better than advent of code to do so? The day 1 problem is about adding together the digits that are followed by the same digit from a "circular" string (the next of the last is the first). My solution is the following: 

Not sure if my explanation is legit, but when you give a thing to another function, this function can do whatever it wants to this thing: it can take it as mutable or not. That is not anymore the problem of the previous owner. 

My question is not only about the algorithm (I think that it is ok, and the problem is not that difficult) but also about the "haskellish" style. Because I am used to Rust/Ocaml/Elm etc., at first I wrote: 

I will post comments not about your performances, but about your writing style, because some things can be shortened. Simplify vector creation: 

PHP Your PHP code falls under the same issues as the jQuery code, that is, repeating several chunks of code that latter on will prove difficult to maintain. 

Validating Code: This links should prove useful as to validate your code and warn you about common mistakes: 

JQUERY Your jQuery currently uses the same code over and over, the best option is always to make scripts as generic as possible, to minimize the amount of code that as to be downloaded and interpreted by the browser. Also, in future maintenance, you'll find it easy to deal with a small generic code then a large element specific one. 

The above notes should give you an overall improvement on your form validation, leading to a valid code and a better solution for future maintenance. I haven't tested any of it, but it should be working. 

elements don't accept fields as direct childâ€™s, so you should place your submit button inside a wrapper element. I don't know about your visual aspect, but you should use CSS to format your elements and keep HTML to a minimum. Your password field should have the type password as to allow the browser to obfuscate the characters being typed. If you're using jQuery, you're better of going with the .blur() event instead of giving attribute to all elements subjected to validation. 

If you only need to read one line from a file that will not change at runtime, you can use As already said, the whole program can be simplified a lot using a functional programming style on iterators: 

You do not need to take the numbers by reference. Do not put an underscore at the beginning of the variable name. A variable name beginning with is used to say to the compiler that the variable is unused. 

Explanations: gives you a shifted string. makes the iterator cycle infinitely, remove the first (replace it with for the second part. You the zip the two iterators: one on the string, one on the shifted string. Then you keep the pairs with same numbers: Then you convert each to and you discard the failed conversions. Then you make the sum of all the numbers. If you want to do the two days in one like in your code: 

This cannot work as-in, because cannot be borrowed twice, but if you rewrite your data structure differently, this could be ok. Do not use Use instead. Be careful about code formatting This could seem meaningless, but people can be embarrassed by missing spaces, or other badly formatted things. Do not be afraid to use the official code formatter. 

This is a very broad question. I advice you to think things differently. In Rust, you can give a thing, or only lend it (the thing is borrowed). The general answer is: if you do not need anymore the thing, or if the receiver needs a full control on it, give it away. In this specific case, the thing is copyable and small (as small as a reference, in fact). So, borrow it does not give any advantage: just take it (or take a copy) and do not bother with references.