I have some criticism on details you didn't ask, but which should be addressed: Autoloading Make use of it! There is no need to make manual calls to . There even is a standard: PSR-0, which defines how you should structure your class and namespace names together with the directory and file structure. When I look at your code, I see some issues: Because the underscore was used as a separator before PHP got namespaces, it is considered a separation character in class names. Namespaces Make use of it! I cannot see a reason why the exception \DH_MVC2_Application_Exeption is located in the root namespace, and not called \dh_mvc2\application\Exception. It would be so much easier to simply inside the "\dh_mvc2\application" namespace. Whitespace and coding style Endless debates might occur, but I really don't like yours. Especially the inconsistent placement of parentheses. Personally, I'd rather prefer not to use that much spaces, but if you really have to, use them everywhere. For example, if you want to find the function "set_ini_default_paths", and want to make sure not to find "set_ini_default_paths_directory", you'd search for "set_ini_default_paths(" - which will find only function definitions, but not usage. To find these, you'd have to search "set_ini_default_paths (". Dependency injection Doesn't take place. Objects are created inside your class. There is no way I would be able to change for example the Config object if I'd use your class, I must use yours. I even cannot change the config filename! Include path Be careful what you add here. If a PSR-0 autoloader is used, there is no need to add anything to the include path. In fact, you'll get a good amount of performance if you include as few directories as possible, preferably only ".", to be able to include files with a relative path. 

Since , you should consider using interfaces instead of classes, for object dependencies. And as the "hidden" dependency of : It highly depends of what the framework is for. You've gone for the common practical approach instead of the academic one (injection). There's no right or wrong here, it highly depends on the framework's purpose and audience, the academic approach may not always be the educative approach. 

If is empty, is set to "no" (can't read the author's mind, but my choice would be , not a string). From the naming we can assume that holds (or not) the keyword(s) of a search. Now if that is not empty: 

The clause is very similar to the one discussed previously, only this time other than checking if has a index, the author also checks that the value is larger than zero. That's an unsafe check, because at this point we don't now what the type of the value in is, and if it's anything other than a number, there will be automatic type juggling involved, and the check is completely unreliable. From the name and context, I'm assuming the variable should hold an integer (if anything) that limits the search. If the variable doesn't hold anything, the limit is set to zero (), curiously using a string form of zero. I'd rewrite that check as: 

You need to add another css class to any of your paragraphs You need to change a css class to any of your paragraphs You need to convert a paragraph to anything else You need to change the text of a paragraph blah blah blah (there are a lot of other likely scenarios, but I think the first 4 are enough to illustrate my point) 

It converts currencies. It validates currency identifier. It fetches HTTP resources It caches fetched HTTP resources. 

You are doomed! Basically you try to allow an attacker to define which code should be executed, and you try to find out if you are smarter in detecting malicious code than him injecting and hiding it. The "EXEC" mode is completely insecure, we need not discuss this. But I doubt the blacklist mode is of good use either. I feel it to be insecure as well, but I cannot prove it in 5 minutes. For example, I can try to read any file on the webserver by calling . I can try to overwrite any file by using . I could install my multipurpose script this way that is called a second later, and you get owned. In the end, only the whitelist mode seems reasonably secure, but this is just a generalized form of AJAX RPC calling - and a very dumb one, because it is limited to single PHP functions, you cannot do anything more sophisticated. And if you really think about it: There are already plenty of working solutions to allow Ajax calls to do more useful stuff within one single call. Some of them are called "restful webservice". 

Reading the tests, I do not really see how a single slot is to be used. I only see how multiple slots inside a page are used. Also, I only see tests for several GET methods. If I want to verify that the results that are coming out are correct, I somehow have to read the config fixture file - a secondary source of information. This situation actually is bad. I want to be able to read the tests, and actually CHANGE some input values in a certain test method to see whether or not it changes the output and breaks the test. If I cannot see the input, I cannot play with the values. One final improvement: If you include files, they can actually return a value. You do not need to define a global variable that will transfer the config values. 

Well, more of a factory method now, which is silly. But not as silly as . If you absolutely need to keep the class's signature as it is, go for it. If not, a PDO wrapper would be the better approach. 

and avoid the costly call to . And do return something, tell the user if the operation succeeded or not, regardless of what the Java interface does. 

Your code is just fine, exactly how I would do it. There isn't much to discuss really, it's kind of simple. It's as effective / efficient as it could be, and fairly readable. 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

Points 1 to 3 are user interface specific concerns. In an MVC approach they belong to the View and not in the Controller. Point 3 can be a user interface concern, if the texts are static, but can also be viewed as a data concern. The same way you get data from the database, you could collect all these static texts in a configuration file and only have to look at one file to change them across every View in your application. That could be considered a Model approach. Having said that, this: 

I would suggest returning instead of when element not found. It feels a little more natural and expected. 

Consider all of the above as extreme nitpicking, your code is way past the point of obvious flaws. The real value of the answer, if any, was to point you towards the SPL. If you did consider it and rejected it, would you care to share why? 

(we started with the 50 USD object from above, the conversion rate is completely arbitrary). What have we got now? We can add amounts of the same currency. We can convert an amount into a different currency. We can also add amounts in different currencies via wrapping them into a converter first. That's pretty much all currency stuff should do. Now how do you get this nice converter? It is simply a call to a class that generates it for you. This class should only deal with generating the proper conversion object when asked to provide one for conversion from currency A to B. To fulfill this, it needs access to a resource of knowledge, but this resource could be anything. For example, a HTTP client. But the client cannot be universal, it has to be customized for the web service you are using. So in reality you need to create something like a factory that is able to make a request for converting currencies to a certain web service. This call triggers a basic HTTP request with some parameters. Caching should be done as decorator pattern as well. Decorating an HTTP call with a cache means that in the decorator you see if there is a matching entry in the cache that is still valid (might expire to fetch new updates), if not, it forwards the function call to the real client. I apologize for not going into details for these tasks at this moment. I hope you got the idea of how to split up responsibilities between classes from the currency conversion example. 

Don't know if this is just poor question formatting, or your style, but please indent properly, this isn't really good: 

checks whether the value is an integer and whether it's a string that only contains digits (thus a integer in string form), any of the two is acceptable for the following check, . I've also moved out of the check, I'm initializing it to zero and will override if and only if there's a need. But let's see what happens if the check is true: 

The first clause, essentially checks if there's an "old_keyword" index in the array (and whether it's or not), that's a pretty typical check for arrays. The second check, that executes if and only if the first one passes, checks whether what's in is not the same as what's in . I'm assuming that the author had some reason for that, but can't imagine what that reason is. Summarizing what happens here, if: 

Everything seems to be working as expected (repo, with a simple demo). Since this is my first plugin, I'd be particularly interested in critiques of its structure. That said, as always in reviews, any aspect of the code is fair game for criticism. The plugin code: 

This is not a Controller. The purpose of MVC is separation of concerns, more specifically the separation of domain logic from the user interface. Let's see where it fails: 

Obviously, what's more important right now is to minimize that glorious readability mess, hopefully the (small) performance gain might be just the incentive you needed. Cache your jQuery objects You are using in and twice in . That's three times jQuery traverses the DOM to find , what you need to do is: