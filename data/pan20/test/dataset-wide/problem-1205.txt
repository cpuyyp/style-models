Variable definition You sometimes define variables in camelCase and sometimes with underscores. I recommend to use one spelling type only. PHP If function is not part of a class consider developing a database class that handles it. Another option is to add a function to each of your Model classes. This makes your code easier to read. For more details check mvc pattern. In the function you establish a new database connection with each call. You can avoid it by promoting the function to a proper class and define a global attribute holding your database connection. JS In your javascript you have html code. I recommend to either load it with rest of the dom and hide it by default or load it using ajax. I personally compare it with inline css. HTML In html form you have an attribute . It should be in a javascript file. I compare it with inline css as well. "QUOTES" Also see CodeX answer. As tim mentioned and other variables not provided by yourself have to be validated and parsed by htmlspecialchars e.g. to avoid XSS. A bit about security I've added this section due to mentioned XSS. Security is a very complex topic and must not be underestimated. There are a lot of options to implement and grant security. What kind of options you choose depends on your time/budget but also kind of project and data that are going to be stored in your database. I kindly ask you to think wise about the data that will be saved in the database and make researches about proper security measures. There are a lot of PHP Frameworks. I recommend to take a look into some of them as those provide security standards. 

The code in Abdallah Hodieb's question is good (LGTM). I prefer the simpler, more readable form of the first loop. 

Go uses camelCase: . Go uses a capital letter for the first character to export identifiers. Use functions to encapsulate complexity: . Bubble errors up so that each level can handle them appropriately. Local variables such as and are not exposed outside the function. The function runs at the end of the function instead of the end of the program. For output files, check for errors on . Don't panic in packages: . is a rewrite of . Note that now truncates the local file only if there is no error reading the remote file. From a design point of view, we may want to download the latest version of the remote file if available. If there is an error, common on remote connections, we can elect to fall back to the last local file. Robust code gracefully handles failure. And so forth. There is more, but I'm out of time. 

Code should be readable, correct, maintainable, robust, and reasonably efficient. Readability is a prerequisite for the other characteristics. Start with Go Code Review Comments. You write: 

First, we can see that the third numbers, the function results, are identical to those for the original code. This means that either the new code is also correct, or both versions are incorrect. As you can see the execution times are greatly reduced from the original code for all values of greater than 4. For the smaller values, the original code is faster because it doesn't have any caching overhead. But for the larger values, each increment in results in only a small increase in execution time. For of 12, the run time is only 2.68ms, which is roughly 28000 times faster than the original code. With the revised code, calculating takes only 2.8 seconds: 

The first value is , the second value the execution time in microseconds, and the third value the result of the function for that value. For values greater than 2, there is roughly a 6x increase in run time at each step. For of 12, the execution time is just over 75 seconds. Here are the results for the revised code: 

This is an addition to other reviews. Code Quality: include 'home.php';: In the context of your shared script it's not obvious what it does. I recommend to rename it to e.g. . Further depending on the content there are other more beautiful ways to handle "that". require_once 'class.user.php': Including classes manually shouldn't be practiced anymore. Okay, maybe in an application which has like 3 files in total. However, in larger applications you should use feature provided by PHP using . So, when you try to instantiate a class PHP automatically tries to include the class once if it does not exists in the current context. View & Business Logic are not separated: Nowadays view and business logic is separated to provide a better overview. Further it grants a better maintenance if implemented correctly. Check patterns like which stands for Model View Controller. Other header("Location: index.php"); You perform a redirect without specifying the reason like . 

Description: This section describes missing setter, multiple returns and if-conditions. In the constructor of the class Route are multiple returns. This makes the code less maintainable. Having more than one return means there are multiple scenarios when the constructor can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. So, at this point a switch to if-else-if-else should be performed. Below you see a minimalistic sample. 

which use the idiomatic, efficient range form which allows the compiler to bypass some index range checks and calculate len(a)-1 once. Unless there are at least two array elements, no sort is needed. The upper limit for the outer loop is len(a)-1 not len(a). Especially in the inner loop, avoid unnecessary address calculations, index range checks, memory accesses, and exchanges. Also, avoid inefficient comparisons. 

The Go programming language was designed to operate at Google scale. Go programs are usually written to be reasonably efficient. For example, assume that your function is used by Google's search web crawler on billions of HTML pages (with multiple scripts per page) per day. I see opportunities to make your function more efficient by using CPU time and memory only when necessary. To estimate how much your function might be improved, I ran some Go benchmarks. 

The unnecessary conditional path and indentation are a distraction. The most important path is the correct path. It should be easy to read the correct path. 

Go uses the testing package to write tests and benchmarks. These are the results for benchmarks of the various selection sort functions. Each benchmark sorts an array of 1,024 random integers from descending to ascending order and then sorts it from ascending to descending order. 

In general your code is a good start. Keep going :) However the class should be refactored. Issuelist: 

Not every method has a self-describing name : What does it return? Object Length, Current Line Length, ...? I recommend to rename the method to what it does - . 

Recommendation Curly brackets are sometimes in same line as a method header and sometimes in the following For the sake of a good code-reading and understanding code should be structured. Write curly brackets either in the same line as the method header or in the following. 

The code became even better readable and when the validation has to be adjusted it is obvious where to make the changes plus you can validate the Route at any line in your software with the guarantee the validation is up to date. Approach 2: Move the assignment to a respective setter and throw an . 

Classes are included manually Instead of including classes manually it is recommended to make usage of the autoloader function ($URL$ The advantage is that you don't have to worry about including a class. 

On my machine, this overhead is ~1.20s. The original solution for input with 9000 entries and 3 lookups takes ~6.25s, while the solution I've posted here runs in ~1.23s, which means it imposes hardly any overhead over that of the VM startup and shutdown. 

The code below first reads all the input in chunks of 4096 characters, accumulating a list of chunks. It then reverses the list, flattens the list into a large string, and splits the entire string on newlines. After that, it converts the first element of the resulting list to an integer , and then processes names and numbers from the remainder of the list by storing them in a map. The value stored isn't just the phone number, but the required output string . Once all the entries have been processed, the rest of the input is queries, which are then processed one-by-one against the map. Query processing uses with the string used as the default for lookups that fail. This allows the return value from to be unconditionally output directly to stdout. 

The most important property of a program is that it is correct. For the Caesar Cipher, Latin letters are rotated, in either direction, by a fixed shift amount. Decoding is the reverse of encoding. Your algorithm looks suspicious. I tested your algorithm against my algorithm. Encoding "Hello, 世界" for shift +25, your algorithm gives "a~\u0085\u0085\u0088, 世界" and my algorithm gives "Gdkkn, 世界". Your algorithm: 

We know that this is safe to do (a nil value for conn is OK) and that it is the expected behaviour because we read the net.Dial source code. 

Now we have an easy way to test. Let's make sure that we can handle all reasonable values. Here are some values that you don't handle. and so on. You should always expect the worst from user input and handle errors gracefully. For example,' 

Even if you write impeccable code, you will still be judged on the quality of the external packages that you use. The packages from are of very low quality. Here's my complete program. It's a first draft. 

As you notice it is better readable. From here there are two approaches how the code can be optimized further. Approach 1: IsValid-methods should be created. These kind of methods performs a validation. 

You include an autoloader in the test class. From UnitTests I am aware of a bootstrap file. If such a class exists/can be registered for functional tests as well you should move it to a respective file. 

There are multiple returns in one method This makes the code less maintainable. Having more than one return means there are multiple scenarios when the method can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. 

Each class belongs in an own file It seems to be overhead but remember: Each class has one task to solve and the same goes for files. In small projects it does not matter that much but as soon as a project grows it helps a lot. My namespaces are similiar to the path of the class location. As of this I know where every class is located - everytime I instantiate a class. Namespaces If you have not read yourself into namespaces I recommend it. Namespaces combined with an autoloader are a great way to make your daily developer life a lot easier. When using an autoloader you have another reason for having one class in one file. further aspects 

I created an input file containing 9000 entries to be stored and used it to measure this solution to be about 150 times faster than solutions that read the input line by line, as measured by running the solution on the command line in a bash shell like this: 

The final clause is where all the interesting work occurs. It first calls with a default value of to check if the value tuple is present. If it's not, the default value of is returned, and the case clause for creates a new list of value tuples based on the incoming values of , , , and and passes it to a new call, setting the initial sum value to 0 and passing the current cache. This call returns a 2-tuple comprising the sum for that value tuple and a new cache. The final line in this case clause inserts the sum for the value tuple into the cache. The case clause for when finds the value tuple just returns the cached sum and the current cache. The result of the case expression is stored into , and then is called recursively with , which is the tail of the value tuple list, a new sum which is , and the new cache . We can run the code in a list comprehension to calculate the running times for values from 1 to 12 using like this: 

I reorganized your code. Don't write code as a heavily indented stream of consciousness. First, write the normal flow. The first step in a code review is to read and verify the normal flow, it should be obvious. Second, add exception handling. Third, add error handling. Sensibly minimize indentation. See Indent Error Flow. For example, a simple first draft, 

Your program is running 100,000 client connections using goroutines. One connection has a problem, so you crash the program. We have 100,000 very upset customers. Handle errors and fail gracefully; return errors; don't or . See Errors. 

Your rationale is "I easily forget some things." That's not a problem. What is a problem is that you don't know how to easily find this information in the documentation. No employer wants employees who write idiosyncratic, unreadable, and unmaintainable code. Similarly, you write, 

Go is statically typed. Every variable has a static type, that is, exactly one type known and fixed at compile time. You are not in dynamically typed Python anymore. You could use reflection, BUT DON'T!