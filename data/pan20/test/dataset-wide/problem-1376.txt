Please, don't tell me anything about the docstrings, because I actually removed them from my code to make it clearer. In general, I prefer efficiency to clarity, so I am not so interested in list or generator comprehensions if they don't make the code more efficient. Anyway, you could also suggest them, if you feel that they would turn the code more "pythonic". 

I was trying to write a dynamic programming algorithm using a bottom up approach that solves the subset sum problem's version where the solution can be either an empty set and the initial set can only contain positive integers. The following is my implementation, but I am not sure it is correct for all cases. 

I implemented a invert-range operation in a (logical) circular vector. A circular vector is a vector without a logical starting and ending object, or, equivalently, the successive element of the element at the last index of the vector is the element at index 0 (similarly for the previous element). I'm not 100% sure it's correct. If it's correct, any suggestions to improve it (especially in terms of performance)? 

One piece of feedback is that your error handling code is very repetitive. You are calling in every failure block. That might seem OK for one cleanup task (though I'd tend to disagree), but once you have N things to clean up on failure (or even successful return), it gets to be a lot of effort and maintenance. There are a few ways around this that I've seen. 

The question is whether or not it's safe to call while another thread does . According to Microsoft's documentation it is safe: 

You can imagine a compiler generating better code when using this launcher. (Eg. the method call might be inlined into the thread creation routine. Also, function pointer calls are typically not as efficient on modern CPUs as simply calling a function.) In most cases this won't really make a difference, but if you had very frequent calls to something like this, it's a good thing to be aware of generally, and one of C++'s real strengths. You can also imagine additional launchers which carry parameters for the callee, cleanly releasing any acquired resources they get deleted. Also: for your scoped locks... It's rare, but can fail. I'm not sure off the top of my head what those failure conditions may be, but you might want to do something for that case, like throw an error. Lastly... I would re-iterate the earlier comment that maybe the C++0x thread support is right for you. (To be honest I haven't looked into it all that much, so I don't know much about it myself.) Failing that, maybe Boost. 

Now, this pseudocode is really easy and intuitive to understand, and I implemented very fast my "contains cycle" function using my adjacency list representation of a graph that I had implemented some time ago. Note that checking if is an edge in an adjacency matrix representation of a graph is a constant time operation, but not in an adjacency list, where the complexity of that operation is linear in the size of the adjacency list. Thus, with an adjacency matrix representation of a graph, the above algorithm runs roughly in O(n3) time, since iterating through the edges requires O(|V|2) and through the vertices O(|V|) times. On the other hand, using an adjacency list representation, the time complexity of the "contains cycle" algorithm is even worse, as far as I have understood, unless we can iterate through the edges in linear time with respect to the number of edges. We could do this, if we keep track of a list of all edges in the graph while constructing the graph, but I would like to avoid this, and try to find an alternative solution. The following is my implementation using Python 3: 

Rewritten I've rewritten your code to be easier to follow and read. I've avoided using functions (but seriously, learn functions, they're helpful). 

In , you're shadowing the built-in . To avoid shadowing a variable, by convention, you should add a trailing underscore (as in ). If you find that ugly, you can also spell it out, or abbreviate further: or (the former is more desirable). You don't need parentheses around -statements and -statements. The idiomatic way of checking if a container is empty in Python is to directly use it in an -statement, in this fashion: 

When you have a local and a global variable with the same name, and you explicitly want to refer to the global variable; In local scope, when you need to (re)assign to a global variable. 

Welcome to Code Review SE, nice first question! Here are some of my comments, not pertaining to performance: 

If multiple processes perform steps 1/2/3 in lockstep, and the initial value is 0, they will both store 1 back. You could use a GCC extension for compare and swap to make an increment safe: 

I think the suggestion in the link you mention is to not bother with making your object files "intermediate". I tend to agree. If deletes the object files after the link step then it has to re-build them all at the next invocation of . Without this, the next time you , it can look at the dependencies of the object files (as specified by the makefile, the part after the ) and only rebuild them if the stated dependencies have a later timestamp. You might also want a target to remove the objects via , so that you can delete them when you really want to. But the typical workflow for using is to keep your object files around for extended periods and type when you want to build what you've changed. 

Interesting question. We can solve the problem (at least partially) by changing the order of the statements. I'm assuming you'll want to add more conditions in the first clause, which means we can 'fall through' early: 

I've written a library with convenience functions for working with the Python module (specifically and ). I'd appreciate it if someone could take a look at it. I've also uploaded the code on GitHub. 

This makes the code look slightly cleaner and allows for other early-return clauses. It's hard to tell what the context of this piece of code is, but another solution may be to call helper functions, e.g. 

Preamble What you're looking for is a way to obfuscate your code, not a way to encrypt it. The issue lies in the fact that the interpreter needs to have access to the unencrypted source code. This means that you have to store the key somewhere and decrypt the file before runtime, which defeats the purpose of encrypting the source code in the first place. It's almost impossible to properly protect Python code and there's lots of decompilers out there. 

If you don't mind modifying the caller's input buffer, there's another style of doing this in C that results in fewer allocations. Let's look at , present in some C libraries as a less ugly version of the older : 

Moving along the spectrum (from code that crashes given large input, to code that truncates the input, to code that errors out when the buffer in insufficient...), you might also want to dynamically allocate memory for this. 

The benefit to this kind of style is that you can add any type of allocation you want (in between the other stuff, before it, after it, whatever), and you just need to add a quick line or two in the cleanup block, and suddenly, all success and failure paths get the resources freed. If any of the intermediate steps fail and you wind up in the cleanup block, you can be assured that you're not leaking anything, and it won't feel repetitive to make that happen. There are other variants of this, for example if you or someone you're working with has some religious objection to (even though it's the cleanest way to do error handling in plain C), on the slightly more repetitive side you could repeatedly check to see that you're still succeeding: 

I implemented a function to shift an element after another in a logical circular array. Shifting in this case simply means moving element at position to in front of element at position . Of course I can't simply swap the elements at position and , because I would alter the positions of two elements in this circular array. Here's the code I came up with: 

I have implemented a "infix-to-postfix" function that takes as input a list representing the parsed expression, resulted from applying a certain regular expression to an expression, and I would like to have your opinion regarding its correctness and efficiency. Good suggestions are of course more than well-accepted! For making you able also to test directly my algorithm, I decided to include also the regular expression and other important details. 

Note: these functions were actually methods, i.e. part of a class, and they actually working on a field and not on, e.g., global variable. 

As a general rule, having to do casts like this is often an indicator that you're doing something wrong. :-) When writing code and reviewing the work of others' I tend to try to avoid as many unnecessary casts as possible. A lot of times these mask bugs, for example casting a function to an incorrect function pointer type can produce crashes, or casting away may crash when someone tries to modify a read-only buffer. For reasons like this it's a good habit to watch for inappropriate casts when reading code, and be sure not to introduce them yourself; code like this should offend your sensibilities. :-) [3] In your case, the issue is that string literals have the type , so the compiler complains that you are passing this to something that doesn't have . So what you need to do here is: 

First of all, is my algorithm correct? Its time complexity should be roughly O(n4), which is very high for a simple idea, algorithm. Is there a better way to do what I want to achieve without keeping track of all edges of the graph? 

I'm not looking for "idiomatic" C++, but for correctness and performance, but if idiomatic also means correctness and performance, then perfect. Here's the method: 

I was trying to create a function to delete the node at index from its current position and insert it after node at index from a . These container is logically a circular container of nodes, that is there's no actual first or last node, i.e. after comes . I really need this function not to have bugs and to be as performant as possible, so I'm asking here your help to a further check and for eventual suggestions to improve its performance. So, this is the function: 

I don't think speed should be your primary concern in this case. The only thing I could come up with as an improvement is to change : 

Learning Python 3 is not hard if you already know Python 2. Some things have changed only a little, like being a function in Python 3, while others have been rehauled entirely, like how strings are handled. These differences are easy to pick up on, however. If you don't know where to start, this Python Wiki article is a good read. 

As is, if I import the module, I get a bunch of text printed to the console. This can have nasty side effects. It's best to assure that part of the code only runs when being run from the command line. Here's where a name guard comes in handy: 

This seems like a cool project, and a nice first introduction to web scraping! I'll cover some general advice first, and then address your main concern: speed.