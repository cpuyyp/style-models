I think you will find that keeping track of the parent node will make the code harder to write. But lets see! Sure this is a find method to have: 

When writing comments. DO NOT put a comment for each obvious line of code. The code describes itself I don't need you to tell me what the line of code does. I can actually read code (as can everybody that will read your code). When you write comments describe the algorithm that your code is trying to implement (preferably with a link to a static page that will never move (wikipidia) that not only describes the algorithm but what its trying to do (or put it in the comments at the top of a chunk of code). Describe WHY you are using the algorithm and what the final result will be. Code: 

Also by using this style re-balancing dynamically does not get that much harder. This again I would use a more functional style: 

I think your loop is the wrong way around. Normally when reading a line I would not add the new line character to the buffer (but that is a debatable point). Which you seem to be trying to do with the condition at the end. But if the first character is a new line then you add it to the buffer (because you don't test that was read outside the loop. 

Using new/delete is a bad idea. It makes you do all the memory management. It is better to use classes that do it all for you. In your case std::vector is a better choice for memory management of arrays 

The difference is that the C++ versions put the function into the stanadrd namespace so that we avoid name collisions. You have not implemented the rule of three. 

So this double assignment of NULL is redundant. Also When you create the node you have already set it up to be NULL. So there is no point in setting it to NULL again. On the other side of the else you have the same issue. 

So the above may not be accurate. You can add a fake set of cells at the top/bottom/left/right of type 'WALL' then you don't need the test as it can never reach outside the bounds of the maze (this can be forced to be true because it is part of the code and not part of the user input). This means you don't need as that is the only use case. My main issue is that actually mutates the object. Some form of visitor pattern may be a more re-usable technique, or would be better as a member of . 

Your integer is a specific size. This is not true. The integer is a platform specific size. The integer has a specific representation in terms of layout. This is not true. You need to check the difference between big and little endian systems (or even a few more obscure than that). You spacing between members is consistent. This is not necessarily true. The spacing between the members a compiler thing. It can very by compiler or even on the same compiler it can very just by using different flags for optimization. 

They are also extremely dangerous (they basically tell the compiler to shut up and do what your told as I the programmer am god and know better than you the simple compiler). In reality this is usually wrong the compiler always knows better than you and telling it to shut up is usually hiding an error message. As a result C++ has its own casts. There are actually four of them: 

If you define the copy constructor/assignment operator or destructor then you should probably define all three. Accessing via deleted pointer 

A declaration. Wow. I have not seen one of those in a while (20 years). The optimizer is much better than you at deciding what fits in a register let it do its job. I would even bet this keyword is ignored nowadays. 

Design Pattern Comments It works as a chain of responsibility (and the point of patterns is that they are not exact and are chained depending on exact need). BUT saying that I think you could have done it better in this situation. 

The algorithm "moves" all the bad elements to the end of the container (returning an iterator to the first bad elemenet). Then the erase will "erase" from the container from that point to the end. Another alternative is to split the container into two. One of bad values and one of good values. A bit more work. But can be made relatively efficient by using 

Is just screaming out to be converted into C++ (Rather than C). The following can be made much simpler by using an iterator: 

Yes it does not work in this situation. But there is a more important rule recommendation that makes this situation obsolete. The rule is to declare one variable per line. So this should actually be written as: 

As a result the parameter should be marked as a . Also you are passing by value. Your object contains a vector so this is forcing a copy of the object just so it can be printed. So pass by => . 

Most people forget about though I use directly (I can remember why so now I have to go and try and work it out again and it a comment to my generic makefile so I understand the decision). Don't need to shell out to find files: 

I prefer the second one because it can be used with normal compound stamens without modifications or accidentally being used incorrectly. 

Good try again. But this version (as you seem to know by the use of ) uses the old random number generated. This is not a great random number generator. Its absolutely fine for programs like this. But it is worth learning to use the new random number generator. Also will be removed in C++17 (it was deprecated in C++14). So prefer to use . 

The two dynamic memory allocation areas (HEAP for C and FreeStore for C++) are not guaranteed to be the same region (nor is the underlying implementation of memory layout). So memory allocated can not be free'd by the other system. So using two different systems for memory allocation becomes dangerous as not only do you need to free the memory but you need to track which system of allocation was used to allocate the memory. A simpler solution is to just not use the dynamic memory allocation system of another language. Which brings us around to vectors. Which does all the memory allocation in the background and you don't need to do it manually. Also as it acts just like an array it is just as easy to use as a pointer. RAII Here is another example of problem with pointers. 

My favorite container the list. Even doubly linked to make it more fun. Issues in your current code. You don't implement the rule of three/five. Any class that manages resources needs to correctly implement the rule of three (optionally the rule of five). Otherwise you will have issues because of the compiler generated methods. If you do not define them the compiler will generate the following methods: 

Now when you create a task object you can create an object that takes any parameters and returns any types. 

Also you have the same boilerplate code for both t1 and t2. If you have code that does the same thing factor it out into a function. 

This way I can install both normal and debug version of a library and explicitly link other code against them. Anyway back to your make file. To achieve this I normally do 

You can take this a step further by abstract the container type by allowing the user to pass in iterators. 

The init shut-down can be quite expensive (I hear). I would rather do this once at the beginning of the program (when the first connection is created) and destroy it once at the end. Also you are inconsistent on where the check is. On Startup your check is in and your TearDown the check is in I would have expected it to be in so that they look symmetrical. I would do it like this; to make sure initialization is done only once when needed. 

Deleting items from a singly linked list is a pain (as you need the proceeding item). doubly linked list are a lot easier (in my opinion) to use because of this. But again you are potentially deleting the sentinel here. You also search the list twice. The first time you search to find the value. Then you search the list to find the value before the node you want to delete. bool deleteVal(const T& val) { Node* pos = isPresentN(val); if( pos == 0) return 0; if(pos == begin) { begin = pos->next; delete pos; return 1; } 

There are also some very good command line parsing utilities (so you don't have to write boilerplate code with potential mistakes). When somebody has gone to the effort of writing and debugging for you you should probably use them. $URL$ 

Very Minor personal preference. Personally I prefer on the right of the type. The rule is that binds left unless it is on the very left hand side then it binds right. There is one obsecure corner case were this makes a difference. But it is obscure so don't worry. 

Validation code with custom stream inputter. When you write the stream input operator you should validate input and set the streams failbit as appropriate (I changed the code from yesterday to do this). Now detecting bad input and correcting for it is the same as any other type. 

Globally mutable state is not good practice. Because of tight coupling and side affect driven code (code that has side affects outside of the parameters is difficult to handle in real life as well as for testing). 

I would be surprised if most compilers don't turn the recursion into a loop. Its an easy optimization. I would worry less about optimization and more about readability. Its usually much more important. The compilers are darn good at making the code fast. 

Not sure what the operator does :-( Your code could really do with a lot more white space between operators to make it readable. To be honest I can not follow the logic of this function. Especially since I have not idea what the input parameters are supposed to represent: 

Note. When you give up ownership of the object you should not be using it from the original pointer again. The only way to access the render object should not be through the that owns it. If you have kept another pointer to the renderer that you are cheating ownership semantics. Writting a shard render object 

This is because the compiler sees that it can do the comparison by converting the two values to bool and then doing the comparison. You can fix this by marking the function . 

The idea of making it and not was so that it would not be too obnoxious when going in the code. This is very obnoxious to read. A bit of work formatting these lines to make it easy to read would have gone a long way: 

But actually prefer not to do it at all. If you must do it then confine it to the most narrow scope possible. The whole reason that the standard library is is so that it does not cost much to prefix members by it. 

It is easier to put the read as part of the while condition (so that the loop is entered only if both reads succeed). A couple of other things to note (they may be intentional and if so they should be commented). If is valid then an empty meaning causes both to be dropped (ie not put in the map). If hits eof (ie there is none) you don't test for this (thus meaning is left unchanged) you don't exit the loop. This will put random (probably the last value) value into the map.