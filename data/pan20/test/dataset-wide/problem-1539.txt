I know it's obvious, but it bears stating. A is not a . You compare a meter and a second, you cannot add them, etc. They are different types completely. So what you want is to make a different type: 

What are you Returning This function is adding a new member variable, . Presumably you want to just return a new temporary variable. Also, is actually less efficient than , so you might want to start with: 

Moving all the logic you had in the loop into its own function. Picking a door The logic for picking a door is a little hard to follow. Let's simplify it. We start with all of our doors: 

Worst case is \$O(n \log n)\$ If we pass an array of completely unique elements, we get a pretty bad runtime. Your solution is good if we expect a lot of duplicates, but bad if we don't. As an optimization for the worst case, we could add some exponential bounding to find the next element. Basically, replace 

Locking Your is weird and unnecessary. Just construct a lock object, it'll be cleaner. Also if you find yourself writing , you're probably doing something wrong. In the case of your destructor, I would rewrite it as: 

emplace_back The advantage of is not having to actually construct the object to pass in. So when you write: 

Determining Success Right now, your is explicitly listing all 9 cases. That's super repetitive. First of all, the message is the same regardless of which win case we're in, so you could simplify the to actually be a table of wins: 

That said, why is being prime a special case? Your non-prime logic would've worked just fine on primes too! And for 1! So just drop all the branches completely and simply iterate. Need a better algorithm 10^15 is simply too big to brute force the answer. Even dropping all the unnecessary extra work you're doing is likely insufficient. You'll have to try to come up with some optimal substructure this problem has so that you can use dynamic programming. 

Now, your enumerated steps for recursion seem to overcomplicate the algorithm. We want to go top-down! Given your example, when we start with: 

This returns a generator, instead of a list, but generators are typically far more useful anyway. I feel that this approach makes it much more explicit what it is you're actually doing: you're yielding the first element, and then the pairwise difference between the rest. 

That change will also simplify your implementation, which leads into... Simplify, Simplify, Simplify Once you drop the increasing/decreasing check, the code becomes simpler. We are always going from to by . First, let's determine the size of our sequence. For signed integers, we can just divide by and floor at . For unsigned integers, we have to ensure that is at least as big as : 

Similarly to before, I don't see the value in . And should take the type, not just yield the metafunction: 

is a . Lookup in a list is linear time, and comparison is more expensive than int comparison to boot. Instead, use a different structure: 

There is no reason to do such a thing. That is unnecessary terse and you're just making it hard to see what's going on. Furthermore, you don't even need for now. So let's just start with the by itself: 

Yes. You're thinking about the problem backwards. As far as I can tell, your solution may be as fast as you can do in Python solving the problem directly. That is, something like: 

But that means if we have , we can construct it with a . We definitely need to disallow this. On a similar vein, should be restricted to those s which are the same type as and are at least as cv-qualified. Add another alias Rather than writing this: 

Use the from the stream you're using. It's clearer and doesn't lead to the question of where comes from. Also, if the program doesn't exist but is , we still want to fail. So the flow should probably be: 

The first one is simply wrong. You're using this metafunction to check if a type is move constructible (in )... but you're doing this by just checking if it's neither an lvalue reference nor . You're not actually checking anything relating to move construction. Just because something is an rvalue reference does not mean that you can move from it. And just because something is an lvalue reference does not mean that you cannot. Consider two simple classes: 

Having a streamable class is gratuitous. NumberConverter The flow of this class doesn't make much logical sense. You have a member variable , that you're modifying as you go. It's really more like an implicit argument to . Same with all the member variables actually. Makes it very difficult to reason about the correctness of . doesn't make sense as an array. The three elements in the array have nothing to do with each other. You have the numbers under 20, you have the tens numbers (why the hyphen?) and the block identifiers. Declaring it this way means you have a bunch of cryptic or expressions. Prefer to make three different s and name them appropriately. So takes both a units and its string representation? That's not good design since you're basically passing the same/similar information twice. Prefer to restructure this call such that you're converting one "block" at a time (e.g. the millions block, then the thousands block, then the unit block). Redundant information is bad. This fragment doesn't make sense either: 

Do we really need the map lookup there? Can we just mathematically determine the right from ? Of course we can: 

You have an object with 3 zero sides. That's a degenerate object. Rather, you'll want to make it so that once you have a , then it must be valid. Building up our Triangle To that end, let's consider . As a member function, this makes little sense - it doesn't interact with at all. The naming suggests that it's yielding some sort of member, when actually it's prompting the user for input. So let's rework it as a free function: 

Your runtime complexity grows commensurately with the second column. According to Wikipedia, that means your algorithm is something on the order of \$O(e^{\sqrt[4]{n}})\$? A better approach Rather than checking every individual number (which leads to terrible runtime complexity), we can build numbers up from the bottom. The numbers we want are basically \$2^a3^b5^c7^d\$, for all \$a,b,c,d\$. Of course, that's difficult to iterate over (how do you know which one to do next?). But a different way of writing that is each humble number is either 2x, 3x, 5x, or 7x some previous humble number. And that's easy to iterate over: 

Future work Bubble sort is \$O(n^2)\$. It gets the job done, but it's... not great. A strictly better algorithm to start with is insertion sort, which is still \$O(n^2)\$. From there, you can look at merge sort and quicksort, both \$O(n \lg n)\$. Also consider what you'd need to do to be able to support (a) arbitrary types, not just s and (b) in arbitrary order, not just increasing. 

Note that is not a good name. Prefer more descriptive names. Division All of your numbers are s. Which means that when you divide, you're going to end up with as soon as you have any number that isn't . That isn't particularly interesting, so I'd suggest using floating point numbers instead. 

Recursive Code Should Be Recursive Making recursive makes perfect sense. After all, pretty much everything you're going to do with trees is recursive, and this algorithm definitely lends itself well to recursion. However, your function isn't recursive. It calls a recursive function, and takes a - which obfusticates the algorithm. It would be much easier to understand if you just made it recursive - this goes a long way "to reduce the cognitive overload." Let's start with the base case - if we have no ordering, we have no tree: 

Why are you using the specific word format as a signal for something? Also, all the words in end in a hyphen so you always go into this block. 

That's... it. I added a second template argument in case your users want a different clock (e.g. ). I intentionally left non- so as to make the class copyable. If you don't need this to be copyable, then I would write it as: 

Simplify the interface My suggestion: simply the interface. Instead of having to and , and then separately having to keep track of whether or not they were called (which, btw, now your timing with has to include checking - that's not nothing) - just drop all of that and have: 

A few code comments before I get into a simpler algorithm. Don't use . It's far more complicated than a list comprehension. These two: 

For the , we're copying it. And for the array, we're decaying it and ending up with a pointer. We want to return an lvalue reference for lvalue references, and a value for rvalue references. That is, trivially: 

Also you'll note I flipped the return type of . Returning on success makes way more sense. Also this will throw instead of silently doing nothing - that way you can catch that in and log an appropriate message. This differentiates an invalid move from attempting to play on a bad square. Game It is confusing to have be a member variable rather than a member function. I would change it. It took me a while to find the first time around. Now, should just defer to the appropriate user: 

Why U No Doctest ? You wrote a doctest for , but why'd you forget about ? Just because it's a generator doesn't mean you can't doctest it: 

The is unnecessary. IsEmpty This function should be named for consistency with other similar container-like objects. Template Signature You are currently just listing all your types in order. However, if you look at all the other class templates that take a callable, they always take a single template argument as the signature. This makes the usage more explicit. That is: 

Returning a column is much more annoying, but you definitely want to use to avoid any extra allocations: 

Additional Requirements The binary-search optimization requires that the type the container holds is ordered. You may want to fallback to the simple forward-iterator version if the type is only equality-comparable but not less-than-comparable. Initialization I would prefer: 

Not sure I prefer that to the simple loop that you have, but just throwing it out as a potential alternative. 

That said, we can certainly improve your code. First, there's which is more directly what you want. Let's just put that in a function: 

Use a up front that you append to. This avoids having to do a branch. Keep a reference to the next min node - this makes you only have to append in one spot. Write a copy function 

First of all, this is a reserved name (as is any name that contains a double underscore). Secondly, it does nothing for you. Just have: 

Rather than having it be up to the user to provide the correct type, you could instead take advantage of template deduction: 

We've now reduced dozens of lines of loops and variables, which are error prone, into a one line standard algorithm which is very easy to both reason about and for other users to understand. I don't know anything about chemistry, but I get this! 

That is not a . UpperCase names for variables are confusing to read and tend to look like class names, so stuff like: 

It doesn't really matter which direction you do the checking in - it's a matter of personal preference. Both are valid, semantically identical, and will almost certainly perform identically. One thing you can do to avoid having to rewrite all of this stuff is to have a single function that does bounds-checking: 

Pointer to vector? You have two members: a pointer to a vector (which you , but never , which leads to several other problems) and its size. But you're already using a , so just do it twice: 

Why are we enumerating anyway? Enumerating is for enumerating. But here, the round number doesn't actually correspond to the letter number. It should just be an external variable: 

I like your version one better - in that you can break it up into even smaller pieces. Split out the printing of repeated characters: 

Your lengths are off by 1 everywhere. An empty string has length 0 not 1, has length 5 not 6, etc. Your constructor from the can just assign every character in the loop (since we know the th character of will be , right? Even better would be to use : 

!!NO GLOBAL VARIABLES!! That merits being capitalized. And underlined. And lots of exclamation points. Nothing can kill your ability to write good, modular quite quite like global variables. You have several of them, and it took me several reads to understand what exactly is going on here. Let's simplify. What do we need for WAR? We need a Deck: 

I don't know about time complexity, but we can do a lot with readability. There's no reason for your function to be a class method, so let's pull that out. Then, let's rename all our variables be representative of what they are: 

That'll happen in the case where is divisible by one of our primes, but we somehow haven't seen yet. But we are iterating in order, so you're guaranteed that for all . So you can simplify that block to: 

Where is something you should provide to meet the expected interface of C++ containers. What if I wanted to do something like... print all the elements of your tree? Can't do it. 

The bare minimum amount of work necessary would be to add 15 to both results - but with your loop as written, you'd add 15 to , but then add 1 to 15 times. That's less than ideal. So let's first condense the row into a counter - and then add the counter itself: 

Iterating over a Dict In python, iterating over a dict is the same as iterating over the keys, so we can just save that step: 

must return . Comment Style The purpose of comments is to explain issues that the code itself cannot. Consider this function: 

If you want to add more SFINAE goodness here, you could additionally require that gives you something that inherits from . But this is just an overhead thing. Your implementations of , , , and all take as arguments a of some sort too. This is ok but inefficient for and , but makes and much less usable: 

Either way, no space between function name and parentheses, no code on same line as opening brace. It's incredibly hard to read. And no run on statements like: 

Memory Handling I see but I don't see . Your tree leaks memory. It needs to clean up after itself in a destructor. And once you add that, you get into the Rule of Three: you need to add the copy constructor and the copy assignment operator, otherwise you'd still leak when you copy your tree. Usage Your code looks like an implementation of , and your usage suggests the same, so it'd be better to change your template arguments from and (which mean nothing) to and . Using as the key is confusing - you should name it . Although conventionally nodes for maps in the C++ standard library use s. You should make it clear that needs to be both LessThanComparable and EqualityComparable, or provide ways of passing comparators in as template arguments. If I try to for something not in the map, will eventually become and then you return . Oops! You can insert elements with duplicate s. Is that intentional? should be spelled . Other 

What's with all the pointers? I could sum up my review with just that comment. So many pointers. Why? You're adding all this extra work for yourself in having to do memory managementwhen you don't have to. You want a container of s? Use . Here's how I would write code to generate a bunch of random integers: