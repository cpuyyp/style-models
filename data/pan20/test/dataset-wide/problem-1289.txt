I don't see any issues with your switch itself. There will only ever be a finite number of arguments to be handled and this seems like a reasonable way to go about it. What I don't like is how you've repeated the check on all over the code. (I do like your comments though. They've really clarified unclear things.) I would recommend extracting the logic into a routine that takes a delegate function. You could declare it something like this. 

Here you're moving to the first record, and then immediately moving to the th record each time though your loop. You should probably just find the matching records instead. It would save you a few iterations I think. 

I would opt for option number three myself. I hope I've done enough to convince you that is not really the same thing as an . Making it it's own thing makes sense. This could also be considered the most "correct" thing to do because you really should never change an interface once it's been created and used. To quote CPearson: 

shows up all over this code. While the row/column widths are easy to understand, this isn't. I have no idea what color is without looking it up. This definitely needs a well named constant value, but whatever you do, don't name it something like . If you do, you'll have to rename if you change the value. Go with something like this. 

I like that you're testing your code, but you have to visually verify your program's correctness. It would be better to use a testing framework and automate that task. 

Like here. There’s no reason to abbreviate this. Use , or better . Also, this should be a constant so you can’t accidentally assign a new value to it. 

For anyone interested, the reason you can call these functions without creating a new instance is setting creates a default instance of the class. 

There's no reason to Activate/Select all over the place here. You use variable reference elsewhere, there's no reason not to do it here too. 

I'm not a fan of putting all that validation logic inside your view. What happens when we need a second, slightly different person view? Or we need a with the same validation logic in our shinny new WPF app? We're going to copy/paste that logic because it can't be shared with this architecture. There's a reason that newer Windows platforms support DataAnnotations and the concept that the model should know how to validate itself. You could tackle it several ways, but any route you take will end up with a new method. You could implement a separate , roll your own interface, or go way over the top and create your own DataAnnotations framework for Winforms that leverages the same IValidatableObject interface that MVC and WPF use, but you'll eventually regret that "passive presenter" if you don't get that logic out of the code behind. Note: Letting the model validate itself is still a passive presenter, just a (maybe) more correct implementation. 

And that's all very minor really. This is good code. Unfortunately, I've no better ideas about how to simplify the API. It's a side effect of needing to use the type to get large enough values. I've got.... nothing. I think the best you can do is add some example code inside of the class and document the use of the class's API as best you can. What you may be able to do is some precompiler directive magic. You're using currency to get a 64bit integer, right? Well, on 64bit installs, there's the type. So, you might be able to clean this up for use in that environment, but in my experience, very people are actually running 64bit installs of office, so it may not be worth the effort. Particularly when it would mean that you would effectively have two APIs for the same class. 

This line ties your class to access. It won't compile in any other host app. I try to keep utility classes like this host agnostic. Removing this option will allow you to use this class in any app that supports VBA. I honestly don't like this option anyway. It ties how the code behaves to the environment it's running in by letting Access determine how string comparisons are made. If you're going to use an , choose either or depending on your needs. Both of those are available in any of the host apps by the way. (I know, Access probably inserted this line for you, moving on...) 

If you're going to catch an exception, you need to be prepared to do something with it. Handle it, re throw it, or leave a comment explaining why exactly it's okay to just swallow it. 

The class then takes in an object in and stores it as a property. I need the Output stream to be available to the local project, but I don't want to expose it to external projects referencing it, so I declared it at a scope (more on that later). UnitTest.cls 

As I alluded to in my comment, you have bigger concerns than performance right now. I don't know who said it first, but I've repeated it here many times. 

That's poor form whether or not you already have a table scan in the underlying query plan for the CTE. I think you misunderstood the article you linked to. It is warning against doing exactly what you've done here. SQL just doesn't lend itself to code reuse in the way a "regular" programmer is accustomed to. It's a different beast that way, it takes a different mindset. SQL is a set based query language. Code reuse comes in the form of (well tuned) views and stored procedures. If you need this kind of fine grained control over the SQL, then keep it where it belongs, in the database. Depending on just how dynamic your queries are, you may not always be getting the benefit of query plan caching. Each time a query that the analyzer hasn't seen before is processed, it has to generate a new plan, so you'll take a performance hit. Lastly, I left a comment, but I should mention it here too. Be careful using query hints. You may be able to outwit the analyzer now, based on the current data, but the data will change over time. When the data has changed and your hint is no longer the most efficient query plan, the analyzer won't be able to choose the most efficient plan because you've told it not to. Performance gained this way may degrade over time.