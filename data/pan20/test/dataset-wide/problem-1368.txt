Now, in your dest, the value of each cell is a function of its index. There are a few critical values: 

Your code seems to me to be as efficient as reasonable for the application you are writing... ... but what you want/intend to do with it is unreasonable.... but first: 

(note I added some spaces around the as well). has me really confused... you store it at the class level, and you never 'reset' it. This makes me think you create a new instance of each time you test a .... otherwise the will just keep getting bigger, and bigger..... I believe that should also just be declared inside the method, and not as a class field.... 

Re-inventing the wheel If you have to reinvent this wheel (it's homework, or something), then consider this: 

The above should reduce the number of joins a lot, and use a better key for the joins that are done. 

and they essentially become a prt of your locking system, and that can result in lock-conditions that are unexpected when you created your class. To make the class completely thread-safe, and have just a single lock point, and still keep isolated from the out-side, I recommend using a dedicated lock instance. It typically looks like this.... 

Further, this process can be easily extended in to any "base", by extending the , and adding a parameter to the function: 

This will significantly improve your performance for large lists. The performance of this option will scale in terms of \$O(n^3)\$ which means each time you double the input data size, you will take 8 times longer to compute a result. Wiki Version The second method uses the wiki algorithm, which is also the base of the algorithm I would recommend.... The Sort will take \$O(n \log{n})\$ time. For largeish lists the log(n) can be effectively ignored.... What's interesting here, is that you loop to the array size still in the loop. You can actually limit the outer loop to valeus less than or equal to 0. At least one of the values has to be 0 or less in order for there to be a zero-sum. Similarly, once you have a second number, chosen from values after , you should then be able to do a binary-search for the third number. 

Now, that's the way I would write that method, and why I think it is an improvement. Having said that, I want to point out some other issues in the code: 

As has been pointed out, overriding the method is not the best way to improve the readability of your code. Using attributes is not, in itself, a problem. What you may want to consider is a trick you can play with Rock/Paper/Scissors. If you create an array in the order: 

Convert the input number to binary representation in a String, and if just one bit is set, it's a power of 2. That removes all the extra memory needed for the results, and it only needs to create a String that is a size which is logarithmic to the input value.... which is quite small, even for very large input values. There's probably faster ways to implement that algorithm, but the core concept is good: just count the set bits, and if there's 1, it's a power of 2. 

Your powInternal is also a functional extraction that is redundant. I suspect this is a copy/paste issue, or a refactoring that was partially undone. Still, the assert is meaningless, and cannot happen, and the function should just be re-integrated in to the public function. Then, I would also make base the variable that mutates in the loop, and remove the variable, allowing you to convert the loop to a while loop. Finally, I know it is pedantic, but you should sjift the exponent with instead of , even though the exponent is not negative. Something like: 

This is in an Ideone here; The advantages here are that the logic for the boolean on_consonant is removed. Additionally, the pointers only ever advance, and never have to be re-located (if you ignore the rotate...) 

The above code uses the ConcurrentHashMap in a way that is minimally locked. It uses an optimistic process for creating a new HashSet only when it is likely going to be used (instead of creating, and throwing it away almost all the time). It also makes sure that, if one is created in a different thread, and our optimism was proven wrong, that we use the one that other threads are using. Then, for the actual HashSet, it synchronizes on the whole set, and all operations are completely isolated from other threads. This is OK, because, the only time there will be thread blocking, is when two threads are accessing the event handlers for a single Class.... which is likely to be uncommon. Note, that the getHandlers creates a defensive copy of the Set, so that iteration has a consistent copy of the data, and that there does not need to be any locking during the iteration. Edit: To remove unnecessary work in the code, I would actually recommend the following: 

The methods have an accumulator mechanism (adding up ints, doubles, and the string lengths) and making the results available in a method. Also, I have put your function in there as . There is a function which builds an array if input strings where there are approximately equal numbers of int, double, and string values. Finally, the benchmark function: 

Your recursion is doing far too much, and it can be simplified a lot. Additionally, you are creating a lot of Data instances, when a simpler mechanism would be to call it a and reuse that single node for all values.... 

What does that mean? It means, on average, your code is 40-times faster than the Scanner. Your code runs in 1.7Milliseconds to process 1000 input values, and the scanner runs in 70 milliseconds. So, a is a bad idea if performance is required, right? I agree. Alternative But, what about a RegEx pre-validation check? Note that the regex will not guarantee a clean parse, but it can go a long way. For example, the regex will match any integer, right, but is a valid integer? No, it's too big. But, it is a valid double. We will still need to have a try/catch block even if we pass the regex prevalidation. That's going to eliminate almost all exceptions, though.... So, what do we do to prevalidate things? Well, the function documents a regex for matching double values in Strings. It's complicated, and I made a few modifications because we don't have already trimmed our inputs, but here's a couple of patterns for prevalidating double values, and integer values: 

The code appears to be sane, and reasonable. Logic Duplication There are a couple of logic duplications. For example: 

seek in the file to the position of the first needed Second_Packet strip off whatever information you need to complete the record. update the KEY_FRAME instance of data with the required information 

You can use implicit numeric conversion to save you a lot of coding here. Specifically, if you use instead of you will do floating-point arithmetic automatically. Consider the following: 

EDIT: I have seen the following done (translating from memory of a C program)... this has been known to be able to compile down to SIMD-using instructions on supporting compilers, etc. 

Your code is a testament to a careful attention to detail. There is so much potential for copy/paste bugs, yet I cannot see any. You have been fastidious. Given an assignment like this, I assume that you are aware of loops, and functions. This code is begging for that. Why have you ignored those programming features? The user input can be extracted to simple functions: 

and, also since rows 1, 2, and 3 are always the same, and since rows 5, 6, and 7 are always the same, it's relatively easy to break the digits in to 5 sections..... which I will call the: head, thorax, waist, legs, and feet. Each section can have just one output. Then, the right construct to hold that all, is a set of 2 enums... one for rows of text, and the other for the complete digits. The lines enum does not need to be public. The process is somewhat verbose, but, the mapping has to be manual, so there's no way around it. Turning the above in to a discrete class/file, I get the following, with a main method for testing: 

Posting a second answer to keep things clean. I think I missed one of the important concepts in your use-case, that you are 'gating' the access to the resource from the resource-side of things, not the thread side of things.... If I were to suggest the following code, I think it would add to this 'conversation': 

This has presented an interesting problem. Your solution concerns me, because it does not solve things the way I would. This, in itself, is not a problem, but I had to look through your code, and figure out why you were doing things. Your solution has a couple of unexpected, and useful side effects. 

Now, with the above code, you are giving this the details it needs to get the data, and you don't care how it does it. The fact that it is on multiple hosts, with block-lists, or whatever is not the point. That URL_RETRIEVER is what your code should implement, and, my guess, is it will look something like: 

it should be declared at the top, before the add and other non-static methods (and constructors). I have mentioned before that I prefer inner static classes to have getters and setters for the private members (even though it is a private nested class). You have chosen to ignore that, that's OK, but I should still point it out. I have also suggested before that there is no need to have the left and right as part of the constructor. You never use them (when constructing), so it is redundant and confusing.