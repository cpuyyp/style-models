I'm going to second @PetLahev's point about creating a GUI for your co-workers to use and officially recommend using the in your code. That would make all of the code verifying that a directory exists obsolete, because it had to have existed in order for them to have selected it. So now, this snippet 

Note that I did extract a method so we could name the filter. It makes it a bit more readable (and as an added bonus, reusable). You may be asking yourself why naming the predicate is better than using a variable. Other than reuse, the benefit is that there's no need to store any state. At its heart, Linq is a functional way to program, so it's good to embrace it. 

Note that I also removed the parameter, as we're replacing it with inherited classes. Now we can go about implementing child classes like so. 

This is beautiful. It makes sense to group all of the different overloads together. This is a good use of regions. Unfortunately, you have some instances where it's not so good. Here, for example, you've wrapped a single method inside of a region. Why? What does this do for us other than clutter the code? 

Anytime you find yourself saying "if condition return true, else return false" you can directly return the result of the expression. 

Your method of obtaining a database connection string is misguided. If something is hard, it's usually because you're going about it the wrong way. Just use the data context ctor overload that takes in a connection string. 

Don't worry about performance until you've proved that you have a performance problem. Make your code readable and maintainable. A stream would solve this nicely. 

The method is public and you've done some proper argument checking. (At least I'm going to assume that returning the base is appropriate if it's < 1. Is it?) So, that's good! However, does it really make sense to Assert on a condition that has been gracefully handled? I don't think it does. Minimally, it can cause confusion for someone coming behind you wondering "why are we asserting this in s public method when we've handled that case right there. Like I said, asserts are awesome, but try to keep them in places where there're likely to catch actual bugs. 

Is it beautiful? I don't know, but it's very readable for the most part. You have a pension for single letter variable names though. I don't care for that. Yes, yes... naming is the hardest thing in programming, but we that just means we have to try hard at it. Names like and don't tell me anything about what the variable actually is and represents. As a maintainer, I have to keep looking around the implementation details to remind myself. The other thing I notice is this method. 

Even though it matches the spec, isn't a very good name for what this function does. would be a better name. gets called in this code a lot. It happens more than enough to declare a variable for it. All of the parameters are being implicitly passed which isn't nice. (And you have no excuse. The add-in you're using warns you about this.) The optional parameter for is okay, but it exposes implementation details to the client. It would be better to create a private function that does all of the heavy lifting. It can require that the midpoint be specified. 

I wanted to talk about your using Ninject as a service locator, but I can't even begin to describe how bad is. I don't even know what it is that you're trying to do here. In order to fix this up, you'll need to take a few steps. 

All I'm going to say is that you know better and this is neither cute nor clever. This is a slippery slope to Spaghetti Code. is leftover from an ancient version of Visual Basic that didn't have subroutines. Use a proper subroutine or function. For what it's worth, it appears to be a correct and clean use of . You just shouldn't be using it. 

Note that if you use a switch without a , you would need to , as the code would continue to "fall through". 

Regular Expression patterns are rarely obvious. Tell Mr. Maintainer in English what you're matching on. 

Why does the client code go through all the trouble of spelling this out? should know how to get the info it needs from an so the dev doesn't have to. 

There's not a lot to go on here, but consider this. Can someone's age be ? Will a student ever be 1000 years old? An can be both of these values. That means a simple default getter/setter isn't sufficient. You'll need to write some bounds checking in the setter and throw an exception if someone tries to set to an unreasonable number. 

There's another problem though. In reality, a single sku can only have one pricing strategy at a time, but this implementation doesn't do anything to prevent that from happening. Also, why does a pricing strategy need to know what Sku it's attached to? Answer: It doesn't. You only did this so the Cashier knew which strategy to apply to a Sku. Kill two birds with one stone. Remove from and provide the with a instead of a . 

This is for an interview. Don't test from the console, write and use unit tests. I don't mean to be harsh, but I would rule out any submissions that were testing code manually from a console program like this. Doing it this way means you have to visually scan for correctness. It's all too easy to make a mistake. You're also more likely to consider edge cases when writing proper unit tests too. 

Why not just make them sequential at runtime? Do you really need them to be stored gapless in the database, or do you just need them to be gapless when you go to use the data? I suspect it's the latter. Consider this sample data: 

In blackjack, an Ace's value can be 1 or 11. You've got its value as 10. That's a bug. Being it's value is context sensitive to the rest of the hand, what you need is some sort of class that takes in a hand and returns a score. Later, you can learn about interfaces & polymorphism and implement different scoring algorithms for different games. 

It should be as in "X Range". Don't use underscores in your names. Underscores have a special place in VBA. They represent Event Procedures and Interface Method implementations. Using the underscores elsewhere gets confusing for people. It's better to use for variable names. 

Anyway, there are other completely different algorithms for this. Typically, when searching for all the prime numbers up to , we'd use the Sieve of Eratosthenes. Lastly, I apologize if my syntax is wrong or the code isn't very idiomatic. It's been a long time since I wrote any Ruby and I never was very good at it. Hopefully this still helps. 

In that order. Let's see what we can do to make this code right. I'll try to be gentle, but prepare yourself. This might be rough to hear at times. 

It's well worth extracting the logic into a dedicated module or class to standardize your error handling UI. 

Maybe I'm missing something, but I think declaring a character array for delimiter is overkill here. 

Now, instead of this loop, let's iterate through a range of cells with a loop instead. But first, remove this line, it is also dead code. 

Brackets would have made it instantly clear that you were returning and not just letting the code blithely stumble on. Heck, even a new line after the statement would have cleared that up. 

Now, you notice that there? It's there to force the Antlr to throw an exception if a SyntaxError happens. The implementation is right here. 

Good name for the class. Very descriptive. Normally I wouldn’t advocate for abbreviating, but I actually think it’s best to abbreviate this one. Having worked in retail, everyone in the domain knows what an EAN is. Nearly no one knows what it stands for. Use the domain term and abbreviation for this one. (To be clear, I would normally tell you the opposite. Abbreviating things shouldn’t be the norm.) 

You're a good programmer, so I won't question that you need to use here, but you definitely should add a comment here explaining why you're doing it. As it is, I don't have to domain knowledge to understand why you're doing this (and neither will the person maintaining the code someday). 

My syntax may be a little off, I'm accustomed to ANTLR's flavor of EBNF, but that should illustrate the idea. 

You need to immediately search the code base for every instance of this pattern and remove it immediately. It serves no purpose but to destroy the stack trace. That makes it much harder to debug production issues, because you've no idea where the exception really came from. (While you're at it, look for any place the previous developer may have been simply swallowing exceptions too.) Next is this patten: 

It's nitpicky, but I've never seen a namespace begin with an underscore. It just looks weird to me. While I'm being nit picky, C# tends to have braces on new lines instead of the Egyptian style that you use. But, you were consistent and that's what really matters. You have a typo here. 

There are several a lot of hardcoded strings in . Some of them may be ok as they only show up once, but the file paths and URL addresses are repeated several times. Those should definitely be stored in constants. If you ever have a need to update them, it would be far too easy to miss one of them. I should also point out that this code will only run if that exact filepath exists on the target machine. It would be much more portable to pull that file path from a config file. 

I doubt anyone will be using the code in the year 2100, but you should know that your solution would be off by a day if it was being used in that far flung future. 

Next, give your SQL statement variables some meaningful names. I shouldn't have to keep reminding myself that is the select statement and is the update. Try and respectively. Next, I would separate the messy business of creating the string to be executed from the business of actually executing. 

The existing answer did a nice job of refactoring your code, but there are other things that can be said about it. To begin with, I'm not sure you're doing a great job of validating . 

Is there any reason you don't just use the cancellation token to stop the thread? I'm also wondering why you're using an explicit thread at all. This is asynchronous programming the hard way. async-await and s are the idiomatic way to do this for the last several versions of the language & framework. I'm imagining your code looking something like this. (Totally untested. Might not compile.)