Implementing all of these changes (and removing the increase score function, as it kind of hid a main concept of the game) we arrive at the following code: 

To properly answer your question I would focus firstly on why you want differentiated test sets, and not carry all the eggs in one basket. After that I'll focus on using factories or not, before a little summary at the end. (Sorry in advance, for the somewhat lengthy response.) Some Test Levels Different test sets could and should have various focus and coverage area, which again will reveal various kind of errors in your code. Here is a list of various test areas (with my personal and simplified description): 

An even more vital question than does it deviate from best practices, is whether it actually does what you intend for it to do! Does it accurately time exection of the function in you are testing? I believe not due to the following reasons: 

Let us start with some code review, before improving the performance, and finish off with a comparision against the original code. Code review As a gesture to us reviewing your code, it would have been nice to know which modules where external to a default installation, as I had to plunder a little to install the and module. However I got thing up and running, and then I looked at code and found the following: 

There are loads of options on how to store and execute equations, and here is one version where you are able to remove all of those / blocks, and where the check of arguments/fields is moved into each equation function. The full code is as follows: 

Do be aware that this code review is making some assumptions, and might be a little overkill for something which you might just have thrown together to solve an immediate problem you had. However, becoming a robust and good programmer, starts by doing it right from the smallest through to the largest projects. 

My other answer says most of the stuff related to your underlying question of how to handle cleanup. In this answer I would like to focus on reviewing your code. 

This assumes that the is available as an within the Node class, but you'll get the gist of the idea and can surely complete it. 

Here I've also renamed the class to , as it seemed kind of strange to use the class to stuff... I've also removed some temporary variables to avoid clutter. I also added a second constructor allowing for providing a different to the constructor. This way you could change the entire functionality of the encode/decode by providing a different properties file. Code is untested as I don't have access to do the resources thingy using my online java compiler, but you'll get the gist of the idea. PS! Using the try-with-resources as Vogel612 exemplifies in his answer, is most likely a better, more up to date way to do the properties reading. 

Updated: I did a few test runs to compare the different solutions, before doing a final test run of 100 000 times (which I let run over night). With a 1000 samples I found the following: Original code (58.6 seconds) and the version by SuperBiasedMan (56.5 seconds) runs in around a minute, whilst my version using int comparison and simpler random function runs in only 2.8 seconds (about 20 times faster). ( And if faking the coin flip, it only takes 0.5 seconds to complete it. :-) ) But here are the ultimate test for a 100 000 times run on my computer: 

Performance review You are asking if there is another way to separate your input strings, and there is at least one method using tuples which can achieve this. Then instead of storing you store (or ). However this has a penalty when creating, and when accessing again. When speed is important, it seems like your current solution of postfixing with or is faster, although more unclear when reading the code. I reimplemented the faster solution of David Z as a function, and got a performance gain. But I got an even greater gain when loosing the iterator, and using a previous and current variable set. Here are the two main contenders for performance comparision, the first is a version using tuples instead of postfixing the strings, and not using the pairwise iterator: 

A rather interesting choice of language for solving the Project Euler problem. Are you going to do the rest of the problems in bash, as well? The common pitfall of this particular Euler problem is the inclusion of the 15's as they are divided by both 3 and 5. By adding the after the you avoid that pitfall. Nice usage of and to calculate the sum, however be aware that if you increase the sequences enough you might run into issues related to argument lengths. If you do so, then might also start acting funny. (Update: As seen in comments, this can be counteracted by introducing a secondary level of , and ) That leaves not that much to comment upon, besides that this is unix, so there is a ton of ways to do this. Including various options with , , , bash scripting, and so on... This is however, a nice, neat and easy solution which fits the extended YAGNIA principle perfect. That is: You Ain't Gonna Need It Again. 

Performance comparison I made some variants of the code, both of your original, the one by SuperBiasedMan (with some correction as his code currently has a bug), some versions using only generators, itertools, and , and finally a version using loops instead of list comprehension and a slightly alternate optimisation to find the minimum. I used the following version of memoize, which most likely can be further optimised: 

Could still need some tweaking, but you get the gist of idea to make it more modular, and to make it read a lot easier, which in turns will make it more maintable. 

Secondly I would make the functions actually return values and not printing them directly. In your case I would probably make the function return a triplet of where the index is used for offsetting the next run. 

Look into using named tuples and/or classes, i.e. your main character could be well served using either. That would allow for coding like or . Which in turn could use a namedtuple with x and y coordinates. Using a named tuple for coordinates could also make some of your logic easier, as you could use loops to check for all the different positions, instead of large amounts of blocks. You also use some anti-patterns, as they are called. I.e. followed by . First of all this could be written like followed by , but the second part is redundant, as has only two values. So you could and should use followed by . A similar anti-pattern is setting the in each and every if statement. Set it once to before all the if statements, and let the statement reset it to . Looks nicer, and is easier to follow. Regarding all those if statements, you could also benefit from combining them using statements in between. Or even better to make a position class with a class method so that you could do stuff like: . That would look a lot nicer... Lastly, I would look into print formatting which could simplify print statements to: . Or if using named tuples or classes: . The manual seems OK, but I would most likely manually word wrap at around 72 characters, to make it read easier most places. But that kind of depends upon where and you are displaying the text. This is not a complete review, but you should have some pointers to get you started on refactoring your code. You are very welcome to post a new question with your revised edition of your game. 

However there is an even neater solution to avoid most of your code, and that is to use all of the capabilities of the fractions module. Using this module your function can be reduced to: 

This code is tested rather heavily, and should work nicely. It's rather similar to code from Wikipedia's binary search algorithm. 

Refactored code That is enough rambling, and here is my suggestion to refactor code addressing most of the issues I've commented upon: 

I tried playing your game, and neither in Python 2 (after some fiddling), nor in Python 3 can I get the game logic to work properly. So it does have some bugs here and there! Naming and spacing 

Which would pop values from the end as long as they're not returning a falsy value, which would work in my current case. However as I tend to want generic solutions (not directly asked for in the question), I found this alternate solution which would allow for the default values to be real default values, and not only . 

Here are some comments on your code. First some stylistic comments, and afterwards some related to the logic of your code. 

The code as it stands doesn't read well. And your text is also slightly confusing. I do believe I would rework the code to something along these lines: 

Some new(?) constructs I'm not sure if you know these already, but there are a few new constructs I would like to show you: 

I left in the option to allow for negative palindromes in this version, which could be removed if one is so inclined. Devised a little test scheme where I called the integer version with the numbers , and in a loop with 100 000 repeats. It turns out that on my computer this runs in less than half the time of versions using conversion to string. (In my test the iterative and recursive version had almost identical timings!) Conclusion Your version does solve the task, albeit it has some minor style issues. An iterative version can be used, and has it benefits like it's easier to extend into various version which all ends up in the same code. And finally, a solution using div and mod is in preliminary tests almost twice as fast when it comes to deciding if an integer is a palindrome or not! PS! Thanks to Bob for pointing out that I'd forgotten to include the last code segment! 

And then to wrap it up we need some changes to the end of the code to adjust to the newly created list of lists: 

This file has only the intended changes. The latter option should be a better alternative for changing lines in a file, and should be quite efficient as well. A further optimisation, could be to remove already changed option from the dict after doing that line, but then again that could be unneccessary micro optimisation. The provided solutions reads and writes the file in one go, and only keeps one line of the file in memory (except internal cacheing). In most operating systems, this should be the better option for handling an arbitrarily sized file. (Earlier Windows version could loose some efficiency due to the almost simultaneously read and write to two different places/files at the same time.) 

One way to implement this interconnection, and related sums and signal values, could be to introduce a static list of s, and extend each with dynamic lists of indexes into this list to describe its inputs and outputs. This would allow for methods identifying all the inputs or outputs, by checking whether the input or output list for a given neuron is empty or not. You could also make static methods traversing based on input nodes describing the paths to new nodes (possibly with circular node connection detection) until you reaches the output nodes. 

I'll end this hasty review with a very useful construct which could cleanup your code (when you've created functions): 

Edited: My solution review was based on a misunderstanding of the problem statement. As a foreigner I confused multiple/multiply/multiplicand, and thought you had done the same. Your code does however return the binary looking decimal which is a multiple of \$N\$ as requested, and that renders my previous solution void, which found the factor you need to multiply to \$N\$ to get a binary looking decimal. The only comment I then have to your actual solution, is whether it is worth it to test whether the candidate is greater than \$N\$ before starting the modulo operation, but that has to be tested if it gives any significant speed increase. Most likely it is not worth it. Thanks to Barry for correcting me regarding my mistake on the solution review