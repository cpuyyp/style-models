Note that in this switch, the isn't really needed, since I've spelled out all the possible values. But it doesn't hurt to handle strange cases, since there's always some idiot who will cast an integer to an enum, or something. (Probably better to throw an exception, really, but I don't know if you've gotten that far.) Back to At this point, I can't get to link because of so let's turn our attention to that. First, I have serious questions about your statement, "these Objects are supposed to know what room they were originally in, their "homeroom" so to speak." I looked in your homework assignment, and I see the line there about knowing what room they belong in. I just don't understand why. The only use for this is in one of the following credit portions, where objects that are homing will return to their home room when dropped. IMO, this is the kind of thing that should be implemented in the homing objects, not built in to every single object type. Regardless, consider this: an object has a home room. It always has a home room. The home room cannot be changed. What does that sound like to you? Because to me, it sounds like a reference, not a pointer. But supposedly this exercise is about pointers, so we'll do it with pointers, following WooWapDaBug's suggestion: 

Now, suppose that the expression evaluates as true. In that case, you have your pointing to allocated memory; you have pointing to allocated memory; and you have pointing to uninitialized memory. Ignoring my suggestion to completely rewrite this part (#6), I would suggest rewriting this using . Yes, it's possible to manage the zeros on your own for a structure this small, but why bother? Something like this: 

and have a simple, obvious operation for checking if the player has won. As the saying goes, "keep it simple stupid." A place for everything... Most of your code is inside a loop. But much of your code doesn't get executed more than once! Consider this: 

As I understand your code, you are looking to find substrings that could be arranged to form palindromes. You are looping over various lengths of substrings in your function. Your function, however, spends a great deal of time and effort to formulate the palindrome. This is wasted, because all you really need to know for your scenario is whether each distinct digit appears an even number of times. If each digit in the substring appears an even number of times, like , then you know you can arrange that substring into a palindrome. If there is a digit that has an odd number of occurrences, then there will be two (since the substrings are even-length, per your problem statement). Which means you have something like and that cannot be made into a palindrome. This means you can scan your input string using a "sliding window" and simply update a dictionary of counts as characters are added and removed from the window. What's more, you can stop when you find the first arrangeable substring, and return true. If you start your search from either or (if number is odd), then the first result will be the longest result: 

You are setting the score to 0, then printing the value 0 as the score. What if you decided, that the player starts with 100 score points? You would have to change the value in two places. Since you already have the value in a variable, it is better to print the value of the variable. Like this: Note that I also removed the newline from the output, because reads much more naturally than 

You say you want to adapt the code for different board sizes. In that case, a loop that goes along the diagonals is needed (I first assumed you meant looping over diagonals as a whole, i. e. for each diagonal do this). Think about what defines a diagonal, not in terms of geometry, but coordinates. Both coordinates are the same (or they have the same absolute value, depending on the direction). So you only need one loop, and use it for both the x and y coordinate. Then you 

Hint: Seeing later in the code that the angle is in radians, and one might expect an angle to be in degrees by default, a better name would be or , which I am going to use later on. Also, since means the rotational speed, I will later use instead. 

Just call it then. You probably will find an even better name, if you think about what kind of helper functions this class contains, but never abbreviate a class name like that. And most importantly, never make it depend on a comment to be understandable. More idiomatic names might be or , even better if you add what they are for. You can also omit the , since it is kind of obvious, and the class represents the thing which is a or . For Example . As statet by Timothy Truckle more explicitly in a comment, the Helpers do not need to be static, and it actually hurts your attempt of good object oriented design. This is what I wanted to imply by "the class represents the thing ...", which means you better treat them as objects with a certain behaviour. So the classes are more than just a set of functions. That whole class is actually your , not just some . Your should abstract how and what exactly is being written out, and have an interface with methods like (which comes close to what the first 8 lines of the main loops are doing) instead of the whole code being put into the class. 

You're printing lines from the file, then printing allowable answers from the program source code. This means that the test file and the source code are in sync - they're not independent of each other. Since the source code is constant, why not put the possible answers in the test file: 

Don't use wildcard imports You had this same advice on your prior post. You apparently decided to ignore it. It doesn't make you look smarter. Use if you must. But put some kind of prefix on Tk functions so that later readers of your code - including yourself months from now - will know when a function call or class reference is to an outside library: 

This code loops over the offsets (I copied it from your King method). And it "zooms" in each direction - repeatedly adding the same offset to the 'candidate square'. So instead of writing four different loops for moves in each direction, I can use this same method for any "zoomy" piece, including the Queen. All I need is the right offsets table, which can be a piece of class data. In fact, if you allow the "zoom limit" to be a class constant instead of using you could use the same code for all the pieces, with the "zoom limit" being 1 for kings, knights, and pawns. Going further, kings, rooks and pawns have special movement options (castling, first double-move) that is only available when the piece has never moved. So you could add this: 

You're not looping like a native. See this link to Ned Batchelder's "Loop like a Native" talk for slides and video. In particular, you are writing "read and store" code, when you should be writing "generate when needed" code. There's no reason to process the blocks by first loading all of them into memory. And, considering you are talking about video files, there's plenty of reasons not to load all of them into memory! Instead, use a generator to yield one item at a time, as needed. And that whole thing. Ugh! ! Use the library! Say "Hello!" to my leetle friend: pathlib 

But honestly, why not do the checking in the while loop, instead of relying on a global variable set who-knows-where? 

Above, the marks the end of positional parameters - meaning there are none. Every parameter after the is required to be named. So you call this like: 

Here we have the same, but even worse: The functions change global state, which can make it much harder to find bugs. Try to avoid that whenever possible. Furthermore, and already tell you that the speed is increased/decreased, and they tell you how much they are changed, which is valuable information. If your only reason for defining these functions is that you can easily change how much the speed is increased/decreased, define variables instead and do . Writing it in uppercase later reminds you not to change it. 

Most users would probably expect to be the maximum amount of enqueued items, rather than . I am not sure whether you thought about it as an array index, or whether this compensates for an off by one error in the method. If a user checks for the MAX_SIZE and adds 1040 items in a loop, then, because neither throws an exception nor returns anything when the queue is full, the last item will just be ignored silently. 

I already added the link to a good implementation of the hash code method above, so I won't go into detail about the algorithm. But what you are doing in the above two lines before the addition is just calculating what could simply be a constant. The compiler will probably even precompute the part. Multiplying the hash code with a prime number (like 23 or 31) should happen before every addition of another value. 

Note that your is equivalent to , and since is exclusive on the upper bound, this gives you numbers between and , which I'm not sure is what you intended. 

Using for exponentiation is faster and looks cleaner than using . Note that and are local variables here, even if they have the same name as the global ones. Use the function like this: 

This comment is obsolete, because it just says what the code in the next line says anyway. Instead try to write self-documenting code, for example by selecting the random index first and saving it in a variable, so that the variable's name tells you what it is. Also you can directly get a random integer value, so you don't have to round. Then you get 

Note that I had to invert the logic, because it seems like you are using a value of in the (intended to be constant) variable , which is counterintutitive. Try to be more consistent with spaces around operators. You write , but . Always add spaces around operators, i. e. .