I was reading this question, and the answer that mentioned streams, and a thought had occurred to me. In many cases (at least in my usage) I want to determine if a sequence (or ) has at least a certain number of elements, or has no more than a certain number, etc, that all match a predicate. As it stands now, we have the method, but it will enumerate the entire before returning. In some cases, we know we only care if there are certain numbers of values. (Such as exactly 8.) As a result, I've built out a set of new extension methods to , that add some functionality for counting only as needed. That is, if we care that we only have at least , we can now deal with that in particular. 

So, first: there's no need to define in the method as a parameter. It's not used as such, instead it's used as a pre-fill so that you already have an array of the right size, but there are better ways to do that: 

You can derive from the model class without any problem your attributes will get applied in you view model also (not every but for exmple the validation attributes will). I also recmommend to have copy constructors becouse they can help you a lot. Beside this my opinion is that no need to worry about display/display format attributes in you model classes it doesn't feel an incorrect way and it helps to keep things clear if you have a lot of derived classes. 

Refactoring to class With object oriented view we can build a class to solve this problem what kind of problems we have to deal with: 

Question #1 No. You do not need to ref the connection object in your methods' parameters - think object oriented way not class oriented. Question #2 The only way is to make this as a non static class. Avoid always statics when the current problem contains some kind of state management like a MySQL connection. Question #3 No you don't but you should implement the IDisposable interface and apply the correct disposable pattern. 

Once more, I come to you for assistance! I have written a significant bit of code that converts IP Addresses from strings to minimal byte-arrays. (So that you can store them in a binary format instead of as a wasteful string.) It currently works with IPv4 and IPv6 addresses, saving both to a 16-element byte-array. (The IPv4 addresses are padded with 0's at the beginning as per this RFC. It currently is only capable of converting an IPv4 or IPv6 address to a byte-array, though I am going to be adding the reverse conversion soon as well. I've omitted XML documentation from it to shorten it up to the relevant code, but you can view the code (as of this version) in it's entirety on GitHub. As usual I appreciate all comments on anything you see here. 

Even more problematic with the above class is the name: what does mean? Is it a ? If so, call it that. Don't make the next programmer guess what it means. 

So that's one gone, and it was easy to do. Next, we want to eliminate methinks, because you don't use that after the algorithm runs, it's just state for the algorithm: 

If this query performance slow then check the indexing on your server (EXPLAIN). The important thing is that with SQL server we have to work with small number of huge result sets instead of a lot of small subqueries. 

Multiple problems Why is static? Why is the database hardcoded in the class? Echo or return? Neither Exit? Direct $_SESSION write (super global) HTTP stuff in an Auth class? Why is static? You are using stuffs in static where you should not have. Handling database through a static proxy? Untestable, unreadable and what happens if some forget initialize it? Same thing applies to your class which is handling the authentacation. Why is it static? If you wan't to access it whereever you want then create a static facade class and keep the main logic in a separated non-static class. Why is the database hardcoded in the class? What happens if you don't want to use anymore a standard SQL database to store your users? You will rewrite the whole class to achive that? If you create a new class as i described above leave out this hardcoding use constructor injection instead: 

In this situation we test if the is to see if it already has an element. If so, we append the ampersand () and continue on. Now we don't need to worry about the last character being an ampersand at all. I've used a couple constructs that may be unfamiliar to you: 

Another variable naming nit-pick: you should always local and variable names: i.e. instead of . This is another best-practice. 

With as frequently as you use and , you should consider extracting variables there for extra micro-performance boosts. Those are the only complaints I have, good work! 

Now, we can remove one of the levels of indentation of the rest of your code. (This is a good thing.) We'll do the same with: 

And bam, now we have safely casted the items to an , and allowed ourselves a great deal of reuse in the future. And finally, with some extra cleverness, we could even devise a method, that would test if our is a , and if so do the filtering at that level to avoid redundant calls. That is: 

The construcotr may not contain any business logic/work process Your logic is not enough clear to me (hard coded WHERE clause first [id=2] then in getNumVisits() is just a simple select all query, etc.) No they should not be used in classes, force to inject them into the worker methods (ISession interface) Clarify your logic please Just read the common OO and SOLID principles, search for Martin Flowler's name 

This is from my library it's similar to the other solutions but it's using a little hack: the array_key_exists() is a slow function so i execute first an isset() 'function' and if it's says "yes, it exists" then i don't have to execute the array_key_exists() function. The reason why isset() is not enough is the isset() will return FALSE if the key exists but the value is NULL. 

You can't find the correct answer until your code is just a bunch simple PHP scripts. The ultimate solution would be is to use a dependency injection container and resolver where sou can say for example a PDO instance to keep in use until the request ends (in PHP this would be a singleton behavior). If you can't rewrite your whole system to have an object oriented design to have the ability to use a DI container then the only thing you could do is to create a class loader in your bootstrap section to load a factory. A Factory is a simple class which can build object instances like a DatabaseFactory::CreateNewConnection would return a new PDO instance. You can create a static factory but that would be as flexible as the pig-iron. A recommend you to have a static DatabaseBuilder class there you can register a DatabaseFactory class instance as the default database factory and your factory can hold a database class instance until the request ends. Here is the skeleton: 

As you can see, it's still nice and short, and it's more robust than the original. :) This was an excellent start, and hopefully you take more out of this than just a bug fix. :) 

Technically, that's it. We rewrote for tail-call recursion very easily, but we still use . Now that we see the tail-call recursive example, it's easier to do the next step: integrate into the "" (I'm bad at naming things): 

The rest remains the same. Now by doing it this way, we can add more filter conversions and only change two locations: add a , add a clause. 

Advantages? Your code doesn't need modified, at all, to add support for a new type. Simply add the type, define , and if necessary. Downsides? Calling it frequently can become expensive, it would not be difficult to build a cache to hold all the queries and select the relevant one from, so that if you call it would return the result from the cache. Now the point we're at is great if you only need select queries, if you need more than that we hit a slight issue in that we have a lot of code to reproduce to build a new query. Now there is a fix for that. 

You can found a lot information about what is dependency injection and with the example above you can use any existing DI framework (or create your own) you only have to do is create an adapter (Adapter pattern) which is implementing the IDependencyResolver interface and working whith the current DI framework implementation. 

For example an id is not always mandatory it can be optional or we could define a pattern like "veryimportanturl" but the framwork can handle like: controller => lottery, action => getthisweekwinningnumbers, id => 5 

ordering the available routes: by the static parts (fix parameters not pattern elements ({})) and by the constraints (in a route i can set up constraint like the id onyle can be in the range of 0-5) [static length descending, constraints' numbers descending] iterating through the ordered rules collection and trying to find out which one will be the first mach by using regular expression (the Route contains it's pattern translated into regular expression), if a match found i try to fill the pattern with data; if everything is in place i've founded otherwise continuing the search.