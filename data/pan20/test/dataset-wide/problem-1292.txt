C++ std::cin and std::cout are both tied together and and tied to C stdin and C stdout respectively. This causes a lot of performance problems when dealing with std::cin and std::cout. You can help the situation by using: 

This is not real C++ code. This is C written with a couple of classes. Pointers are dangerous and should rarely be used in code. C++ has moved away from C in this regard over the last decade and all pointers should be either wrapped in a smart pointer or be part of a container structure. For this a technique called RAII has been introduced. This is the concept that creation and destruction of an object are linked within the objects lifetime thus allowing you to control resources even in the face of exceptions. There are a couple of ways to fix the code. The simplest technique is to just use std::unique_ptr (or std::auto_ptr if you are using C++03). 

Experimenting with vera++ to validate some C++ source files. $URL$ vera++ is expandable by providing your own rules in tcl. To interface with the vera++ parser the following interface is provided: $URL$ Using the above I have written a rule to look for type identifiers and validate that they have an initial uppercase letter. 

Again because you are implementing a dequeue like a vector your increase in size is very expensive because of the copy you are making. 

Be consistent with braces. You normally line your braces up on the same horizontal. But here you place it on the end of the line: 

A user of your code will eventually forget to check an error code thus resulting in bug. If something goes wrong that you can't fix locally then throw an exception. If the user of the code does not catch the exception then it will correctly terminate the application (any other action is a bug without knowing the context). You can then find this in testing and add the appropriate code to fix the problem (or ignore it as appropriate). Semantics and Rule of Three The compiler generates the copy constructor and copy assignment operator for you by default. So the following are not your only constructors. 

Every time we test loop against end we have to loop through the whole list to construct the end iterator. That basically converts this from into an operation. If you must do it this way keep a copy for re-use. You only need to re-create it when you add/remove elements to the container the rest of the time just return your cached copy (a lot of containers use this simple optimization tactic). But really this class is so simple I would expect to see: 

Probably. Mutable is really for designating members that are not part of the objects actual state (ie temporary caches). 

If you implement the above function split. You now make it easy for your self to implement a slight return optimization. 

Or you can just declare it at the correct location so that the constructor initializes it correctly before use. 

The difference is that also calls on the stream. There is no need to flush the stream manually. The stream is designed to flush when it needs too. When you do it manually you will make your code much more eneficent. RAII 

But the case you are trying to optimize is rare (at best) and this causes the normal case to be worsened (failed branch predication can be very costly). As result I tend to not bother and just use the standard swap technique 

It is more standard to use an initial capitol letter to define a type. An initial lower case letter donates an object (which also encompasses functions). Since you have a nameless type. With an object called . I would have called it . Then used your wrapper functions call that directly. Declaration The code works well as is for a single file program. But you have problems when using it from header files. Because the class is nameless you can not use it any declarations to mark the object external and thus you will be getting an instantiation of the object in every compilation unit. This will break your guarantee that it is thread safe as each has its own mutex. I think your best bet is to put the object in its own file. Then expose all printing via wrapper functions which can be made external in the header file. Expansion. Currently your printer is only used for std::cout. Why not expand it so that it can be used for any stream. 

Also (another personal preference) I like type names to begin with an uppercase letter. That way you can easily spot types in comparison to objects (ie runtime Vs compile time things). Its a shame the standard libraries does not use this convention but we are now stuck for backwards compatibility (But user defined types tend to be defined with an upper case letter (but thats not universal and a style thing so follow your local guidelines)). Personally I think should be not . I know this means things like splice go from to so there is a trade off and you probably chose the correct one (as thats how the standard version deals with it). But you could cache the size value so you calculate it on first it can be just returned on subsequent calls; then on you can mark it as dirty and recalculate the next time is called. 

Rather than pass the object in. You should look up variadic templates. This will allow your constructor here to take the same arguments as the T and forward them directly to the T object being constructed. So now the only T is the one inside the object. 

In this case change two of the std::endl into "\n". Then use the last one to flush the output to the screen. Good start but you should validate the input. What If I typed Rock instead of 1. Then the stream gets broken and all further input is ignored. So validate your input and fix the stream if the bad bit is set. 

The number of elements currently in the vector. The amount of space allocated. This is space allocated but currently unused. Normally when creating arrays you allocate slightly more space than you need. So you can use it without having to reallocate the whole data segment and copy it just for adding a single value (or when deleting a value you just reduce the size and can safely re-use it). 

Classes with Virtual methods should have virtual destructor When you create a class with a virtual method. This means you are calling that method through an object of another type. This type is usually dynamically allocated and thus will be dynamically destroyed. If you delete it via a pointer to the base class the wrong destructor will be called (unless it it virtual).