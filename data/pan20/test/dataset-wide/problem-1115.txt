Edit: Query to detect overlaps If you use the first option, where allocations include a date range, then you need to use some application logic to enforce a business rule that says a resource can only be allocated to one project at a time. To do this, what you want to do is this: Before every insert or update of a record in , you need to check to see if the record you are about to write would overlap in an illegal way with all of the other records that are already in the table. A query that would find potentially overlapping records would look something like this: 

You should use one table per object of interest. That means one table for users, one table for pages, one table for posts, etc. Use a normalized database (See database normalization) for transactional data. This is precisely what relational database management systems are built to do. Don't presume you are going to have performance problems because you have many rows. Most systems perform better with many rows than with just a few. 

This design assumes the simplification suggested under Issue 1, above. One potential drawback of this simplistic solution is that there is no constraint against assigning a teacher to teach a lesson for which they are unqualified. This constraint, if it is important, could be accommodated by replacing the and the tables with new tables as follows: 

Note that your individual assets need to be normalized out into their own table. This lets you separate the two semantically independent pieces of information: 

Here's a couple of questions around your stated business requirements, which differ from the "text book" role-based security pattern in a couple of ways: 

A foreign key is a type of constraint. The purpose of constraints is to make sure that data in tables follows certain rules. You use foreign key constraints to ensure that child data has parent data. You can use it to either prevent orphaning child records or to facilitate cascade deletes or updates. 

Note that I've added an intersection entity type between and . This new entity type: provides the information which is implicit in your model, that a particular department has a give set of jobs of various classifications. Adding to your model as an explicit entity has a few advantages. 

Assuming that you are prepared to compromise on the absolute correctness of the answer in order to obtain practical performance, you could do the following: 

Here there is only one potential cycle to be concerned with, instead of the several that are in your current model. Fewer potential cycles means less extra work that might need to be done with triggers instead of declarative referential constraints. This keeps your system simpler and more maintainable. 

You need to have a many-to-many table for your message recipients. Think about it this way, each message can be sent to one or more recipients. Also, each recipient can presumably receive zero, one or more messages. This means you have a many-to-many and you need an intersection table to record this information in your database. Consider this ERD: 

Note that for OP's scenario where determination of the seller may be delayed, the agency would need to have some kind of escrow account. This would be an additional party, such as "Outstanding Order Payments". In such a case the agency could take their fee right away and the balance would be placed in the escrow account. When the sellers are determined later on, they would be paid out of the escrow account, rather than out of the buyer's account, as is shown in the example, above. Also note that while each transaction is shown with two details above, it is also legitimate to have three or more details for one transaction if you happen to want to record it that way. For example, all of the details in 8001, 8002 and 8003 could have been represented as a single transaction if you prefer. 

The physical model is what is created in most physical implementations of a many-to-many relationship. However, it does not correctly replicate the rules in the logical model. The physical model allows for zero or more in both directions. The logical model indicates one or more from project to employee. The reason that many physical implementations of any relationships do this is that in many DBMSs the SQL declarative referential constraints (i.e. foreign key constraints) don't allow for the rule to be suspended while data is inserted into two tables at one time. The SQL standard provides for "deferrable constraints" and some DBMSs implement these, but many don't and the ones that do haven't always, so not everyone uses them, even if they are available. Old habits can die hard. For the ones that don't implement deferrable constraints, think about it this way: For there to be any kind of mandatory relationship in both directions (i.e. 1:1,M or even 1:1) then you would have to insert the parent and the child at the same time. While you can create a transaction that ensures the parent and child are created in one logical unit of work, the referential integrity rules aren't built to "suspend judgement" until the whole transaction finishes. This is why in practice, physical implementations without deferrable constraints are essentially always optional at the child end. This lets you insert the parent and then insert the child. The practical way around this is generally to write additional application logic to ensure that there is at least one child per parent when 1:1,M is the rule or to just leave it and hope that users do the right thing. These work-arounds aren't necessary if you do happen to have access to deferrable constraints. 

What you are describing is an example of the general situation entity sub-typing. There are two basic ways to handle entity sub-typing: One method places common attributes in a table and distinct attributes in separate tables, linked using 1:1 relationships to the common table. Some other considerations: 

Accounting is very complex and is mission critical for any business. The most central piece of an accounting system is the general ledger. Building your own G/L is pretty hard to justify. You should buy a well-supported desktop G/L, like QuickBooks. There are some good, cost-effective choices available. The other functions in your business, even ones that are related to accounting (outside of G/L) can be specialized. Focus on custom-building these areas, if you find that a general purpose package really doesn't handle your needs. I have built customized subledgers for areas like cost accounting and profitability reporting for businesses with highly specialized needs, but they still used off-the-shelf G/L software. You won't necessarily end up with a perfectly suited, fully integrated custom system, but you don't have time to build such a system and still operate your practice. 

There are some things you want to think about based on the nature of your items and how you store and track them. Are your items discrete or are they a commodity? The way you would track television sets, each of which has its own distinct serial number is different from how you might track boxes of nails. If your SKUs are discrete you don't have a "quantity" field, instead you track individual items with an intersection table (as suggested by Joe). Otherwise whether you need an intersection table depends on how many different SKUs can be on a shelf (see below). Is it important to track inventory movements? Do you need to see stock deliveries and shipments? If so you might want to take a kind of double entry accounting approach, treating shelves like GL numbers. If not, a simpler quantity per shelf may be sufficient. Can multiple SKUs share a shelf? If so, you need an intersection table. If not, you can get by with a foreign key from to . Does every bin have at least one shelf? Your application (queries) will be much simpler if every bin has at least one shelf, such that you don't need to track inventory which is in a bin but has no applicable shelf information. 

You want to convert the pivot table into a normalized table. Store each cell in your chart as a row in a table. The business key of this table is + and the non-key columns are and . 

Having the same types of columns is not the same thing as being the same entity type. Normalization is not the same thing as code reuse. Normalization is about arranging your columns into tables in such a way that you avoid insert, update and delete anomalies. It is about reducing the kinds of redundancy that can lead to these anomalies, it isn't about putting things together because they look alike. As a first choice, you should let your database engine use its declarative constraints (foreign keys, unique keys, etc.) to protect the integrity of your data. This saves writing application code to do this and makes your system less buggy in the long run. This means that you should aim for at least third normal form (3NF) by default and then consider later whether any denormalization is necessary. From this perspective, your first option is not good, because you are jamming three different kinds of child data into one table. You can't control referential integrity as cleanly or easily this way. The only two conventional, practical options you have are 2 and 3. Choosing between options 2 and 3 depends on the circumstances, and may depend quite a bit on your personal preferences. Some people would avoid option 2 because they believe all nulls are evil. Other people would avoid option 3 because they don't like having too many different tables. This is a "holy war" debate without a definitive, logical answer. For practical purposes, looking at your three main tables, I would say that they don't look like they have very much in common. There is a little overlap, but not very much. Therefore, I would tend towards option 3. Keep your tables separate so that your code and your data stay clean. As an aside: You don't show the details of the child table(s). If these three child tables have an identical structure and you're worried about having application code that is duplicated, consider creating a class that handles the child table structure and inheriting from this class for each of the three child tables. This will give you code reuse without compromising data integrity. 

On another subject: Your model indicates that a can be written by many s. I'm not sure that this is really possible in your system, since you don't say anything about collaborative authorship. However, one thing that is almost certainly a problem is that each user can only ever author one post. I'm sure that's not what you meant. To fix this you either need to move the foreign key in the relationship between and to the post side or you need to create an intersection entity if posts can have multiple authors. Similarly... Your business rules state that posts can have multiple and assignments, however, your model doesn't reflect this. In your model each post can have exactly one of each of these. To fix this you need to implement a many-to-many relationship for each of tags and categories. This will result in an intersection table in each case. Lastly: Why is some of your user information segregated into another table with a many-to-many relationship to the main user table? There may be good reasons to keep password information in a separate table from other user information, but I don't see any reason stated in your business rules. Also, it isn't likely that password will be many-to-many with your user record.