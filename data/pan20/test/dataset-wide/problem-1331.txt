If you were dealing with two properties that were in the then you'd probably be able to use a derived property. But since one of the properties in an association, a derived property won't work. Instead, you can do this: 

Templates Ideally, you'd have two templates: one for the class and one for the methods. That would avoid the clunky JSP-style programming. You can read more about Groovy's template engines here. 

If you're interested in creating some Groovy mixins, you can make your Fizz Buzz program quite simple, while getting some reusable Excel functionality out of it. The Fizz Buzz Program Here's the business logic of the Fizz Buzz program: 

The meta-programming You can start with a Groovy Category that adds the method Writable moveLine(Object, Object) to a class, such as an InputStream. 

Firstly, underneath everything Javascript is an event driven language so I do not think that there is anything wrong with using an event driven design pattern if you are comfortable with it. Events are a great way to be able to interlink different components of your system without exposing the inner workings of them (loose coupling) and they add queuing by default. However they are more complex, they make it hard to trace behavior which in turn can make them hard to debug. I think that you would get a cleaner interface by developing using something called the revealing module pattern, there is an excellent resource on various design patterns by a guy called Addy Osmani at adyosmanio.com and the revealing module pattern specifically here. This (or a flavor of it) is commonly used in jQuery plugin development which you can see on the jQuery advanced plugin development page (see Keep private functions private). By following these principles you can keep the private stuff private and only expose the functions that you want the calling code to have access to. You mentioned specifically , and so a quick example of how that might look. 

This has the additional benefit of not having side-effects. Another improvement is to change the location s to s so that instead of you can do . This improves readability. To build the path , I think using is better suited than because it helps clarify the code's intent. can be used on the output of , but that would have been more trouble than it's worth due to the need to keep multiple things in context (accumulator). So I used instead. 

On the Groovy side, it would still be best to use the method because the property can get out of sync if changes. 

You'll see the use of methods throughout. It's a practice common in Groovy that reduces the changes of leaving resources, such as files, open. You'll also notice a lack of for-loops. The and methods do the same thing; and in the case of , the index value is set for you :) Inner classes are also gone because Groovy supports multiple classes per file. The Mixins Here's the magic you can use to make this program clean and simple. 

Then onwards. Arguably this is borderline procedural but with these few steps I think that is acceptable. Edit: Less readable, more old school 

By using an enum you clearly enumerate all the supported cases and encapsulate your data without resorting to data structures that do not fit your purpose. If your data is not clearly defined, or is dynamic or extensible in anyway then the enum approach will not work. At this point I would need to understand the relationship between the key and value in your map. If the key describes the parameter and the two values encapsulate the behavior then the key should be a part of the object (if this is the case you are using as a tuple). In this case you should begin by modifying to include a parameterName member variable and then override and so that you can use in a set. How you chose to override the methods will depend on whether you can have multiple instances of a parameter with different values or whether each parameter name should be unique. If your data is hardcoded today, but might not be tomorrow, don't worry about it. If your data is hardcoded today and won't be tomorrow you could define an interface, say . This interface can expose whatever maethods might be useful to you - size, iterator, next... Create a single implementation for today say or - whatever accurately describes the data you will be feeding back. This means that in the future you could add a or or whatever. Now, inside your you could create an enum as described above. If you need to iterate over the values to convert them into another structure you can use the method: 

In addition, since in the JVM is immutable, concatenation can create temporary objects which the JVM must then dispose of. It's typically better to use . Testability To make the code testable, meaning that it can be executed via a method call and the output can be validated, I placed most of the code into the method. As a consequence, I converted the closure into a method. I know the challenge states If a map is invalid, STDOUT 'Invalid map.' (That includes if the map is unsolvable). However, I disagree with using the same error message for multiple problems. That's one reason I replaced these messages with insightful exceptions. The other reason is to keep the Groovy Console from exiting. 

How it works The method iterates through the and calls a closure with an object to aggregate with and the current item in the list. Iteration begins with an empty as the aggregated object, which remains empty unless the un-matching countries are found. When a mismatch occurs, it is recorded in the . The closure purposely returns the because the output of the closure is what's fed back in during the next iteration. Finally, if the resulting is empty, then all of the countries are the same. Otherwise, the contains one or two keys indicating what the problem was. If all you really need to know is whether all the countries matched or not, you can simply use : 

I assume both lists contain object of the same type/class, ie MyClass1 and MyClass2 are not two different classes. In such a case MyClass can override equals method. Once equals is implemented as stated & you have ensured not to have violated the equals and hashcode contract, you can the use a HashMap. This can reduce your time complexity. 

should be private and nested. is valid field inside Entity.java, you are using generics. is a more standard name than can be marked as final. You dont need a private , a constructor can call another constructor, called constructor overloading. method does not check for can be renamed to In , is BUGGY. You need to rehash and recalculate index. In you are advancing temp. Its giving you no benefit. Infact it appears buggy. Try looking up for stack using linkedlist. In , your if statement is redundant. code works perfectly fine without if block 

The main difference here is that you have deferred the creation of the random value to the callers end. The calling code will also be required to either use generics too: 

Now what you really want to do of course is collapse down that loop. I found that if you have LINQ (which I see you do not) you can use the operator, very simple e.g: 

Are you changing the fields that you expose from your objects depending on certain conditions? On the whole it would be best to use reflection only as a last gasp. Gson works fine with collections in general see the documentation over at Google. If you want to exclude some fields from serialization then you can use the annotation, as documented here. This requires you to annotate all fields that you want to serialize with the annotation, and to use a builder to instantiate your Gson Object like so: 

Since , , and are public, you can just pass the to the instead. Also, has so much functionality that it might as well be a class rather than an enum. In fact, it would be even better if it's an interface: 

In this example, is an interface with four implementations, (only one of which I coded), one for each of the possible directions. The methods accept a and any other necessary parameters which are not part of the . The implementations can then get , , and from the . Sure, this breaks some object-oriented programming rules, but as the adage says: some rules are meant to be broken :) Note that it still involves passing the current state of the . Alternatively, you can implement as an abstract class containing and the equivalent of the methods as abstract methods. Then, you can remove all together and implement four s; one for each direction. 

If there is other code and you need all the features of a TreeSet great, otherwise delegate to a TreeSet member variable. Your code is somewhat superfluous because of the next test 

Finally, you say you have read about the factory pattern, that is ultimately what you are playing with here. Note. I think Enum naming should use the singular (Type) rather than the plural (Types), you are not selecting an Object of type Types as your Object (Types.DOUBLE) represents just one type. 

So, if you're clever about getting an index in there you could write the algorithm (without validation) in just 3 lines and you'd have done a bit of functional programming which sets you up nicely for playing with a new language. 

Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

I felt, the two formats and confusing. I understand the whole concept of DRY and stuff, but take it with punch of salt. Make it use the same format. As correctly pointed out by @mdfs13, can and should be replaced. Professionally, a heap could be extensible, not restricted to fixed size. Each time you throw , you pass it empty, ie without any string message. Your child classes have , this can be dangerous since is supposed to be and needs to be . Your should return immutable . Given your implementation you should not encounter this condition in . Good to have a check, but you could avoid such checks in private methods, since they are in your control. In this check should be enof. No need to check ; You can declare this too. 

Modify this to render just the first three links, then your ellipses (...) separator and then the final page number. EDIT to add pseudo code This is messy but hopefully gives you the idea, create your function, make it work and then post a new question asking how to make it prettier (for example tidy up the ifs, add logic to only render a single set of ellipses, don't repeat any rendering code). 

Next, don't try to return every type of Object from the one Switch statement, it will always be ugly. In order to work out the next step maybe you could elaborate on what is happening outside the blackbox, e.g. if the calling code wants a Double you could add that into your enum: 

In general try to limit how much you are working with the type and reduce as far as possible your use of reflection.