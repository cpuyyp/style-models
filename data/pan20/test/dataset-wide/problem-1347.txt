This creates a function scope around your code (function scope is the only type of scope in JavaScript), limiting those variables to use within that scope. Another related pitfall to watch out for is implicitly declaring variables by assigning them values without using the keyword to explicitly define their scope. There are a few variable assignments in your code where variables are unnecesarily scoped to global namespace, though defined and used only within functions. Textbox event choice For user-friendliness, I recommend attaching your event listener to the "keyup" event instead of the "change" event; that way the floor textboxes will update immediately as the user types a number instead of waiting for the input textbox to lose focus. Working example of some modifications Here's an example of your first linked jsfiddle modified to use native JavaScript and the other recommendations I provided above: 

This can be corrected by replacing with in this instance. Note that the primary difference between and is that is block-scoped, while is function-scoped. Since the block containing this variable declaration is a function anyway, you don't gain any advantage by using . IE11 also does not yet support arrow (=>) syntax for lambda functions, but if you don't have to support such users you can ignore that problem. Avoid modifying directly Direct modification of an element's property should be avoided whenever possible. It has performance drawbacks (forcing the browser to re-evaluate the DOM with each modification) and it can create memory leaks (when code retains references to elements that have been destroyed by overwriting their HTML). Instead, consider these approaches: Clearing To clear the innerHTML without creating memory leaks, instead of you can use a loop to remove all child nodes: 

Syntax and Compatibility Most browsers will balk at the redefinition of a function parameter using the keyword here: 

It works its way down from \$n\$ to 1, adding \$2^n\$ along the way, and returning the sum as a final result. 

createForm() I don't think you need the array or its named elements at all; you're not using it for anything. To build the form controls, you can loop through the array instead of the array. 

Readability In general, readability is improved if your function names are all verbs or verb phrases. Contrariwise, readability is hampered if non-function variables are given verb names. Following these rules of thumb can help "make wrong code look wrong". In your case, you've named the buttons to clear the tables , , and . When I see a variable named my assumption is that I can invoke that method to clear the "done" table, but that's not the case at all... is not a method but an HTML button. I suggest making those variables more descriptive, much like you did in your function by appending to each of the variable names representing buttons. Efficiency When selecting HTML elements by their ID property, browsers are always more efficient using the dedicated method than using the more generic/flexible method. Other Thoughts First, in my experience it's usually best to avoid altogether in favor of . The function you pass to can decide whether or not it needs to keep executing and, if so call on itself again, and otherwise do nothing. This saves you from having to keep track of an interval ID externally and later call on it to stop the process from repeating. Second (!), rather than attempting to add a second to a counter with every passing second, you can keep a more accurate record of passing time by tracking the exact timestamps when the start and stop buttons are pressed, then calculating the difference as needed. That way, if there is ever a delay in the execution of your JavaScript, your recorded times are still accurate (or at least as accurate as the system clock on the computer executing the JavaScript). The pseudocode for that logic would be something like this: 

There is a benefit to using local variables besides memory savings, namely avoiding polluting the global namespace. You can use closures to adhere to the best practice of using only local variables without having to re-query the DOM for elements you've already selected. Using closures to maintain references to objects Although it'll still consume as much memory as if you kept the variables "cached" in global variables, you can modify your code using closures to maintain references to local variable values even after they've gone out of scope, as in the example below. 

Like Kennebec's original answer, the code is inconsistent in its identification of different versions of browsers. For example, Internet Explorer 9 will appear as while Internet Explorer 11 (which despite forsaking the family name still wields the trident of its ancestors) will appear as . Since you have direct control over the name returned for a trident-detected version of IE, why not return "MSIE" instead of "Internet Explorer"? Super minor nitpick: you misspelled "guarantee" in the code comments. 

Since these are constants, a common standard is to name the variables with all capital letters; you can do that if you find it helpful, but the important thing is to be internally consistent. I would take this concept (of capturing reusable strings in variables) a step farther for the element IDs of your daily deals, and throw them into an array of objects. 

Since you're already looping through the elements in the and creating each span element one at a time, you might as well just tuck away a reference to each span as you create it. 

Welcome to Code Review! There are a lot of things we can focus on here, so let's start with your request for suggestions around optimization. Native JavaScript will outperform JQuery Equivalents jQuery makes it easy to write working code quickly, but this is often at the expense of code performance. Converting jQuery methods to their native JavaScript equivalents can increase perfomance. 

Note that this only really works because we know what to expect in the class names. This would break, for example, if you had an element with a class because it would replace the substring . A better (but more tedious) approach would be to split into an array (using ) and check each array element for the desired class. You'd also want to be aware that although IE9 supports CSS opacity, it doesn't support CSS transitions. The end result is that the images will transition promptly instead of fading in and out for IE9 users. Working Example 

One way to fix that would be to simply remove the If statement . Without that check, regardless of whether the parameter is already set to the specified value, it'll be overwritten with the desired value and the URL string will be returned. Original Sin does not exist in older versions of Internet Explorer (9 and down). If your user base doesn't overlap with those poor souls still using IE9, feel free to ignore this one, but otherwise you could do something like this: 

I made several changes to the code based on GameAlchemist's advice and my own observations. The improvements: 

Sure, you can use event delegation for this. For the uninitiated, event delegation in JavaScript means attaching the event listener to a container element and using the property of the event to identify which sub-element was acted upon. You'll still need to crawl your way up the DOM tree to get to the root element, which can be done without knowing the DOM structure as long as you have a sentinel you can check, such as the root element's class name, to determine whether you've reached the root. Once you've made it to the top, so to speak, you can use query selectors to find your way back down to specific child nodes within the root element, again allowing you to grab or modify specific elements without knowing the HTML structure--all you'll need to know is a reliably query-selectable combination of attributes (such as an element class). Here's a working example with comments: 

I'm not sure about ways to improve performance, but I did notice a couple things. Guaranteed Returns If the specified key is already set to the specified value, your function does not return anything. Maybe this is the expected behavior, but I could see it being a problem if you used the function to directly update the URL.