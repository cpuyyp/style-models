I went looking for a cause and it seems that has problems with nullable types. You have to use the underlying type of the nullable in order to make it work: 

Your code is still clean and the method is reusable. Notice that I use instead of explicitly declaring variables. This is not mandatory, I just prefer to use it. Hope this helps! Update: I updated the method to handle a fail on the conversion, in case you want to change to a for example. :) 

If you now add/remove a property from the class, you only have to add/remove that property in the initializer. You don't have to change the constructor and all the other lines of code anymore. But I'd recommend to use validation. You can add code to validate the values in the constructor or setter of the properties, although in the setter is strongly recommended. Or you can use DataAnnotations. Lastly, as mentioned in the comments: try looking into the Entity Framework. 

First point, small but important: give your method a proper name. doesn't mean much and doesn't tell what it returns. Take a name like or . Secondly, did you test this method properly? I changed the code a bit to be able to test it, I removed the value and just use the parameter as value: 

This way your code is shorter and cleaner which makes it easier to read and maintain. Use the keyword: Definition from MSDN: 

We're not seeing a method and we're not able to get all type information but OK. Your code doesn't look unreadable to me. The only thing I can suggest to clean up is the printing by extracting that part into a method and calling this. This is how the method looks: 

Note: you don't exactly use the code twice, inside the function you have at the end of the line where you get the id. 

When you're using this method to store all the error messages, you can use the Enumerable.Aggregate<TSource> method: 

I think you should place it inside the catch as it is in the catch that the "error" will be handled when an exception is thrown. Only when using a variable to return, there will be a return-statement at the end of the method. But it doesn't make a big difference, it's more of a personal choice actually. 

The variable will now contain 4, 5 and 6. If you were to change that to , the variable would contain all the numbers from the original source. [That's why you need the guard :) ] Now you can apply this logic to your code. When the is not , your variable will be . This means that in the where clause the left part is false and the second part will be evaluated. The same goes for . This is the resulting code: 

Also, you prepend the type to every name you use. for a class, for a string, etc... Don't do this. Property-names like and should be and . The name of the class becomes , and the method should be . The names of the parameters in the constructor of the class should start lower case: will become . Variables should make clear what they stand for. A name like doesn't say much, make it instead. The keyword: From MSDN: 

And as "Bobson" mentioned, mixing the ternary operator and nested if/else structures is messy. Keep it with an if/else structure or you could try this: 

Naming conventions: Please follow the Capitalization Conventions for class names. The name of the class would become for example. String manipulation: This is about this line: 

Another way of achieving the same is creating one event and assign this event to the event of any checkbox that requires this: 

Note that I put the line breaks there just for readability. In Visual Studio it can be on 1 line, making it 6 lines in total plus the method. That should be shorter than 6 blocks of 4 lines of code. Hope this helps! :) 

When no record for given id is found, the default of the type will be returned. Since is a reference type, this will be null. Now all you have to do is a null -check when using this method. What you also can to is work with the parameter and make the method return a boolean. This makes it clean to do the check: 

Input Since the input is not mixed in the Person-class we have to declare it somewhere else. In this example I put the input-code in the KeyInput class. The method returns an instance of the Person-class and if the user enters "exit", null is returned. This way we can later on catch if the user wants to stop. 

But it's best practice to stick with one and not to mix the two up in your code. (I prefer the second use of braces.) Logical use of variables: In both click event handlers you instantiate a new filter. Whether or not is null, you call with again a new instance of that filter-class. Just re-use the instance you created before. You didn't manipulate it in any way. Generic method: First of all, the following code is written out of my head and not tested as I have little information what all your classes are/mean. But here's an attempt to make it generic: 

The comparison is redundant as is a bool which can only be true or false. Thus, this can be rewritten as: 

StringBuilder instead of string concatenation The quickest way of adding strings together is pasting them together with a sign. Quicker isn't always the better practice, as is in this case. The better practice to combine strings is to use the . Instead of something like this: 

Short code vs longer code: Writing shorter code can in certain situations be a good thing. But in your case I would not recommend this as it makes your code hard to read and/or maintain. Try something like this: 

Now, to the question. In your code the second check for the variable to be equal to or is redundant. If you get to following line: 

Now, you implemented a no-LinQ solution so I created one myself too. My implementation doesn't have to calculate the amount of chunks or use two loops to create the list of chunks: 

You'll notice that I use this in the code: . In case you don't know, it's called String interpolation. You can read more about it here: $URL$ 

Correctly rethrowing an Exception Everywhere in your block you are rethrowing the exception with . This is bad practice since you'll lose the stacktrace. Just use to rethrow the exception. Implement it this way: 

The element, short for division, is a block element mostly used to group larger chunks of HTML, to create CSS-styled layouts. On the other hand, the element is an inline element, mostly used to group and stylize text/images. It makes it easy to apply custom styles without changing the general layout. Also, a element takes all available width while the only takes as much width as necessary. It is certainly not illegal (since HTML5) what you're doing, but to follow semantics I'd use for what you are trying to achieve. 

Why not name them both the same? The difference is the type of parameter you're passing. This leaves you free to do some method overloading: 

In following code, the statement is also redundant. If the previous check succeeds, the return will be called and the else will never execute. If it fails, the second return will be called, no need for an else statement. 

Since you won't do anything further with those variables, the second if-statement should just read as: 

"Expression = True": You can leave out the part in your if conditions, since the methods return a boolean value. This is what the code now looks like: 

You should let your class handle more than you are doing now and inside your class divide all tasks properly. I've rewritten it so you will understand: 

If this is not the case, ignore this tip. LoadNewDataFromDatabase(): Generally this is not bad, but it can be improved. Naming tips will already be applied without further explanation, this is done in the previous part. Since you already know the loaded data in the method, you should not get all the items from the database and then check which ones you want to add to the main data list. Fetch only the items that are not already in the list. This makes more sense but more important: your SQL-task will be less heavy. 

If this were in a loop and building large string, you'd be wasting memory. Use a instead (which has a method to append a string using a format, cfr. previous point): 

As you see, you can also add other variables like the although in .NET I suggest you use instead. StringBuilder: Perhaps, using the class is even better since you're creating a long string. And then even the String.Format can look messy. Here's another short example: 

This answer is another way of achieving the same. I am not claiming that this is the cleanest or most performant way but it certainly works. 

Of course you can't group by in this case as it is a string property and the expects an integer. You might change the to , but please don't as that is hacky code. Since the purpose of your method is to group by a , you can implement this easily: 

Even though the difference is minimal, there IS a difference. So you'll need to make a minimal distinction, depending on the button that was pressed. What you could do is create a general event for all the buttons and in that event you'll determine the index to be passed to the method. The code might look like this: 

Validation Nowhere in your code do you validate the input of the user. If I enter some random text you'll get a with following message: 

In general your code looks good, here are a few smaller remarks. Method name: Capitalize the name of your method and make it more meaningful. Use or something similar. Comments in code: You can omit the comments in your code. It speaks for itself what the code is doing, certainly because you use clear names for your variables. IsNumeric() - Char.IsDigit(): In the .NET framework, there's the method, use this one instead: