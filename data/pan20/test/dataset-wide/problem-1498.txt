Shutdown strategy Because you are using Swing you currently define following to close your application: 

Model vs UI Your classes have basic separation of concerns. But as you can see by yourself some model elements like "Ball" or "Box" or "Paddle" or even "Game" have a dependency to the package java.awt.*. Try to reformulate your model not to point to UI elements. This is not just because you may provide another UI technology like JavaFX. Sure you can do that afterwards. But the real issue is code quality because you satisfy the "single responsibility principle". My advice is to have a look at the observer pattern. Doing the separation of UI and model is very hard while saying to do so is easy. I even saw experienced developers struggling with it as the do not put the fact into account that a proper separation implicitly makes the UI interchangable. I often heard "we do not need to exchange the UI but we have proper separation". But that is inherent contradictory. I see UI exchangability not as a feature. I see it as a measurement for a pretended separation. Game state You formulate the state of the game within an enum. My suggestion is to use a full state pattern. There you not only provide an artefact that says you are in state 1 or in state 2. You also encapsulate the corresponding behaviour and use polimorphism. Currently the state specific behaviour is spread all over the place within if-then-else-statements. Furthermore you should extend your state handling. The game is a process that follows some process states. And one other important process state is the end of the process. I do not say to model ALL states. But if you have behaviour that should handle the end of the game you should represent it as a separate state. Application State I think you mixed "application state" with "game state". State.MENU seems to be semantical anorganic to State.GAME if you model the game state with it. Either you should have two types of state (application state AND game state) or (my suggestion) omit the representation of the application state as the "menu" has nothing to do with the game itself. Magic numbers You have some magic numbers left you should name. You already did this with "HEIGHT_FRAME" or "WIDTH_FRAME". But the checks for the mouse position are comparing against magic numbers. Game vs. game instance You also mixed some further semantics as a game may be the set of rules you follow OR a concrete game currently in progress. I suggest to separate these responsibilities. Direction As the amount of directions are limitted in yur usecase using an enumeration is totally fine. But here again you have external behaviour you can internalize using polymorphism. Especially the move-behaviour can be encapsulated within the enumeration. Avoid early return-statements "return", "break" and "continue" are structured goto statements and they come with a heritage. They break the control flow and say "I am not interested in the statements below me". I do not say you have to have a single exit per method but I encourage you to have it. My point of view is: Code is never perfect. As code is never perfect it is continuously improved by refactorings. Maybe the statements below the return statement become important at some point or you want to some extract code into a new method then you will have a hard time to do so without reformulating the whole control flow. But if you think your code fragment does currently not violate the single responsibility principle and will not in the future you will not face the burden of such a refactoring. Swing event dispatcher thread If you are working in a single thread environment you have no real problem. But you are working with multiple threads so the Swing-UI can asynchronously change for different reasons. The "Ball" will continue to move and your paddle as well if you press the direction keys. To enforce a consistent UI state I suggest to make ANY change to your UI in the EDT (event dipatcher thread). Mostly you will not face the problem. But concurrency problems are those that are hard to interprete if they occur. You already use the "EventQueue" when you start the appication. 

You said you have a business layer but the separation isn't proper. And here is why: Your "business layer" is responsible to serve a web service by throwing a BadRequestException. You are mixing in technologies that belong to other layers. You do not distinguish between proposal objects, consistent business objects and communication objects. They are all same (StudentDTO in, StudentDTO out). The null checks are not business relevant. They are a result of mapping from one representation (String) to another representation (Std, Division) while you do not know if the source made proper assumptions of the presents of the requested business objects. This is related to the web service layer that has to ensure to pass correct non-null values to the business layer. On the other side you have code that composes an entity in the same method. That should be separated at least into another class but after all it is a different layer, maybe the business layer, in my opionion the dao layer. 

The internal deque will have a special behaviour if no elements are in the queue: If no element is available it will block a certain amount of time (here 5 seconds). Either a new element was insert that can be returned OR it will return null. Abstract from Thread "this" and other threads After all the only difference between registering elements from other "Threads" (UUIDs) and registering the elements of the http request is that you perform the registration in "this" Thread (the main-Thread). You only delay registration for a second (Thread.sleep(1000)). So the task is to abstract from where elements are received. Furthermore it doesn't matter from which thread the elements come from. We have to tell one thread... 

Having the the whole construction at one place If you use the lazy getter only you do not have to care about the creation time. You are more flexible when rearranging the components 

The question is: what do you want to achieve. As you store the singleton in the database it seems to me that your singleton is semantic and not technical. Technical singletons have that unified structure of static instance field, maybe lazy initialization and private constructor to ensure only ONE instance per JVM. Semantical singletons do not have the assertion to be unique per object identity in the JVM. Their assertion is they BEHAVE the same EVERYWHERE and they have semantic identity (equals) in ANY JVM to ensure identity beyond JVM boundaries. Often this kind of singleton is used to have a central entry point to a domain/module. To avoid the public constructor in the semantic singleton I have separated the requirement "central entry point" from "object instantiation". In my design I have a SingletonX class that adresses "central entry point". Furthermore I have a class X that is more or less a POJO Finally I have an interface InterfaceX to redefine the public interface of class X. Class X should be resolved at runtime and is mostly out of scope to be instantiated through client code. Class X is the class to be serialized. 

1. Missing model You are missing a model or if it is there it is mixed together with the UI. For example: You have an Enum "Size" that internally holds UI information (float) and externally promotes a model fragment (TINY, SMALL, ...). I would force myself to write the "game" without any UI first so I have the essence decoupled. So the first step for me would be to separate those fragments. 2. Idea to distribute responsibilities of Direction Your Direction Enum owns responsibilities that it shouldn't. My suggestion is to represent the directions for 2D navigation as tuples of the factors -1, 0 and 1. 

Counting while iterating over the interesting elements until there are no left Decide how to find the next interesting element and provide the information if there is no element left Provide an efficient search for the case of mass data 

Very clean code. I only see some little issues: You throw "InvalidFileFormatException" in HuffmanDeserializer. Should the class care about where the byte-array comes from? I suggest to rename it to "InvalidFormatException". The MAGIC handle (checkSignature) can be omitted as you already identify format issues while you process the byte array. That is semantical redundancy. I currently do NOT say "delete the constant" as it is significant information to a developer what he/she has to expect if maintaining the code. But the relevant data is only the length of MAGIC. On the other side I do not know if MAGIC bytes are used only in your code. If so then I really think it is completely obselete. You several times mentioned: 

Do not use Optional as a general substitute for null. In your case it is absolutly ok to not use Optional. You will have less noise in your code. Optional is a way to express, that your code should not depend on a value. As you create the value right after you determined it is not present your algorithm seems to have not an "Option" to bypass the non-existence. Your algorithm is a lazy initialization mechanism where a null check is appropriate. Everything else is noise and should be omitted. There are rare occasions to use Optional. Your result value is not optional. The using code depends on the existence of a non null value. Using Optional is misleading. My bigger concern is that hibernate initialization mechanism. As I do not know your other code I don't know if it is neccessary. But this statement is a surprise. It does some magic to your structure to return AND it is directly dependent of a concrete technology instead of an abstraction like JPA. I highly recommend to avoid such mechanisms and adress this kind of micro management architectural. But as I do not have any further code I cannot make detailed suggestions on that.