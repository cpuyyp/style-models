The actual hashing is done in and OpenSSL. Those pretty much cannot be reduced, so at best it could be made ~3 times as fast. 

Again, I do not think relying on this is a good idea, but it does not seem insecure either. Personally, I would rather make the number of iterations a smoother function of time, i.e. round after the multiply. You still get different iteration counts for different passwords, but you also avoid the abrupt stepping up every two years. Also, you lack any code to upgrade the iteration count of password hashes as time goes by. That should probably happen somewhere in the class, e.g. if the iteration count is less than some fraction of the current. 

Yes, path compression. You descended down two paths from and to and and it took \$O(log\ n)\$. At each step you can point a node to its root, instead of just the next element. You can do this recursively like so: 

I was able to shave some milliseconds off by moving the call inside the calls, which let me get rid of the explicit loop: 

Usually when you can UnitTest all model API easily in pure JUnit (without mocking JApplet environment or providing fake UI/display), you are on the right track. There's sometimes need to provide some complex back-end functionality, like database, or server API, for model classes, but it should be still quite easy to mock only a bit of it, and having model exercised to do everything it should. Testing View classes is quite often much more difficult, or straight counter-productive, if you change the design a lot, so your tests would have to be updated often. Testing Controller code depends, usually needs some good instrumentation helper to simulate all kind of inputs/events, mock views (just verifying the is called at proper places), and often may work upon real model classes, making such tests more integration than unit. Why I'm talking about tests so much, while you didn't even ask. Because once you do the MVC properly, unit testing "model" part becomes so easy, that it's low hanging fruit and should be probably your next topic to try out, after you get more comfortable with MVC patterns. :) 

You are saving some data that you never use. , never used after this. The whole parameter is unused if you remove the assignment. already is. If you remove from here, you can also remove from . 

You could leave out that second – it will cause an extra unnecessary line break if the name overflows the limit and will not alter normal output in any visible way. Calculating the column width is also independent of the current score, so you could move it out of the loop, breaking the overlong line: 

You should define the lower level method instead. will use that to define and that way you are sure to get efficient testing. Speaking of which: 

Is it an improvement? On the original: I think so. Nested logic is generally more difficult to follow. On the --? Not really, but that's the price to pay for caching the intermediary values. 

Two ways to rewrite it: When you know which version of the method you want to call you can name it directly, but in that case need to pass self as an argument: 

I would move lot more closer to the area where it's modified, so it can be easily seen with eye, where the whole block is, and span over fewer branching points (which is always error prone, to keep correct stack across some branching). You can actually surround just few instructions with , not having any branching at all. 

(the exact value stored in is , encoded as 64 bit integer value) So you are just destroying precision bits of the original value, but the resulting value can still contain decimals with precision you don't expect. For some more information study how the floating point numbers are designed, maybe this may be of help: $URL$ 

EDIT: The invalidity of PIC-ness was nagging me, so I finally did dig into the issue, and fixed it, these are things to be modified in the answer above: Commands to compile: 

Hmmm... anyway, I really like what you wrote here: "I'm noticing that reading doesn't really help much as much as writing programs and running into issues and solving them." This is absolutely spot on. All this general babbling around usually makes little sense when hit by real world problem. Also refactor a lot. Not just the code, and implementations, but as learning is your goal, dive deep into finished project and go trough all the API, all the abstraction, and try to imagine something better, easier to use, easier to understand it's responsibilities, easier to read and get the idea and eventually easier to implement (although sometimes to get better API and abstraction the implementation can be more bloated, but the cost of bloat has to be clearly justified by the cleanliness of resulting API/abstraction). 

Python 3 introduced a new cleaner format for the common case when you want to step up from the current class and pass (the first argument): 

At this point you can probably guess that I'll recommend doing away with the list. A generator should work. If on Python 2, is probably better than as well. (Note, I didn't mention . That could be changed into invocations if you are on Python 2, but you seem to be on Python 3.) 

By default pickle uses an ASCII format, so you shouldn't really open the file in binary mode, although nothing should break if no one touches the file. You could leave out the s from both calls or use binary pickling by passing to . 

What's the worst case running time of this? At most \$O(n)\$, since has \$n\$ values and there are no cycles. However, since you are comparing ranks in : 

Personally I find your use of a global variable fine. Using a singleton class for encapsulation where a module would do is IMO needless complexity. If you can have multiple high score objects it's a different matter, of course. 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

(I did debug it in NASM, so if I'm unlucky, something may fail in FASM due to syntax, but it should be easy to fix. But it's highly unlikely, they should have identical syntax for instructions and I don't use any macros/etc) 

performance ideas (from comment): If you are already assuming ASCII alphabet-only word inputs, you may do direct , which will yield only values, and for vs it will produce the same values too (functioning as fake ). I also personally prefer non-else/non-nested variants (when they make sense), so I would do and the would go after that in the loop block. This is part of answer is level golfing advice, i.e. lowering readability and robustness of source for some hypothetical performance gain, not suitable for real world production code ;). 

edit: When designing the algorithm, design also "memory". Where the data are stored, how much of them, why (purpose), when you want to create (temporary) copy, or when you want to use semantics, etc. I'm not suggesting to go after full "Data-Oriented Design" (unless you are designing some big-data processing application, where performance is main goal), but still some level of awareness how your data are flowing under the hood is good to have. Often by keeping data life cycle lean and without useless moving around, you will not only gain performance, but also simpler algorithm implementation and less code written = less bugs. 

Depending on your application and the number of users it is possible that both, the latter or neither is insecure. 

In python 2 you can remove the invocation. That alone saves a few seconds. A set is faster for testing, so that's also an easy fix. Take advantage of 's and by noticing the length stays constant and you are at 2x the speed: 

Any GPU limitation on salt lengths is small, unlikely to last, and will not necessarily apply to ASICs. I do not think it is a good idea to rely on it. The salt is only used on the first iteration of PBKDF2 so it might even be possible to precompute the first step with a CPU and leave the rest for a GPU. It would be fine to halve the salt length, but since it only costs memory and a constant amount of work, it is not a problem to leave it as is. Nit: You misspelled "length". 

However, beware. AFAICT, the item could have been deleted by another process in between checking whether it exists and deleting it. You should probably just delete the item and raise an error if that fails. 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

Overall your code is very reasonable for somebody learning Assembly, I would say quite nice work. I can produce something what will look more advanced (I hope), but it's more like tiny details improved here and there, and some of them for the price of worse readability of source. I mean on the syntax and low level. On the algorithmic level your code can be improved considerably, as Paweł already answered, but he missed another opportunity to halve number of divisions. My variant of code, showing: 

how to use the result of (which has to be done anyway to test remainder) as approximation of suggested sqrt(input) test, for earlier exit. used to set zero into register (shorter opcode than plus modern CPU recognizes it as idiom of "set to zero" and optimizes for it) to check if remainder is zero (shorter opcode than plus modern CPU will recognize it as idiom of "test for zero value" and optimizes for it) resolving even numbers at the beginning (even numbers have zero in least significant bit: . And the only even number being prime is , no need to test other even numbers by . but that means only odd divisors have to be tested in the loop, because for sure. So my loop is testing divisors 3, 5, 7, 9, 11, 13, 15, ... some non-trivial usage of arithmetic instructions and flags to check for input values ahead of loop, as those would break the loop logic and produce invalid result. It may be nice exercise for you to "decipher" how it works. you should try to keep things "together" (if possible). For example you set up for at the end of your loop code block, so it's A) not together with , interleaved by (hard to read for human, no problem for CPU) B) you have code duplicity (), because you have to init the register values ahead of very first separately. => So I do initialize right ahead of , only single time in code, and it's easier to read IMO. 

On Python 3 you can encode the letters into bytes and avoid inside the loop, for similar performance. You might still make it about 1.5x as fast if you replaced the -> algorithm with something faster ( and depth first search?), but that's about it. 

Recursion adds its own cost, though, so whether it's faster in practice would require testing. An alternative would be to add a second iterative compression function: 

Here you could avoid the list creation by using a generator (by changing the to ) or you could use . Probably no difference performance-wise, but the latter is less code. 

I also found this PyPy issue that leaves me less confident there's any performance still on the table. 

Nothing else really. The s at the start of all your strings are a bit ugly, and some people prefer using empty print statements to indicate extra empty lines. 

Again, you are creating lists which takes time. This whole thing you iterate over could be a constant nested tuple that's only allocated once at the top (or even outside the function). 

Why does the function end when is not equal to ? That should be mentioned in description, that must be to make it work. 

I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code. 

Now you are walking the path twice, which again may or may not be faster than recursion. You should only need to call this for one of the paths, though. 

By choosing block size close to , you only need to keep about \$\sqrt x\$ items in memory at a time. 

That's a brute force search of hashes for a particular prefix, meaning it's complexity is \$O(2^n)\$, where \$n\$ is the number of bits in the prefix. In your case that's \$2^{28}\$. You can't make it faster in terms of complexity or the hash would be broken, but you can increase the constant factor. 

If "large input" is only up to a couple of GB, there's not much you can do. As long as all the data comfortably fits in memory, the built-in sort is about as good as you can get. If, OTOH, your dataset is large enough to cause swapping and/or not load at all, you could: 

My recommendation (echoing well known advice) is to use the 32-byte random string directly as an ID (converted to base64 if needed). That gives such a small chance of collisions that you can do away with the loop as well. (It's likelier e.g. that the CPU fails to loop due to cosmic rays than that you see a collision.)