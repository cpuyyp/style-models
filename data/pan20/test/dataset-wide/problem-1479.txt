This should do the same as your code, but in my world it easier to understand now due to following the guidelines. Not that besides moving the storing of the route into the creation of the , I've not done any algorithmic changes. Most likely, one could do simplify some of your logic using list comprehension, but that is up to someone else to look into! 

The operations in here is \$O(N)\$ where N is the number in the list, and that you can't beat. The cost for each element is the creation of one or two sets, and the comparison of those sets, which is dependent on the size of the sets \$O(M)\$. In general since the \$N << M\$, the loop over the elements should be prominent. This means, without changing the data structures there is not a whole lot to be gained, as you do need to loop through all elements, and you need to verify membership agains the list. If any optimization is to be performed it needs to address the actual comparison somehow. Another view on your solution is the readability of your code, and how to understand what is happening. The list comprehension is understandable, but the comparison is not obvious to me, at least, and I would have liked a comment. Or a rewrite, so let us attempt an rewrite for readability and see how it performs. This rewrite is using a Python specific concept to avoid a flag variable: 

I would also fix the spacing, so that it is consitent. In the three lists/dictionaries/... at the top you vary between having spaces around or not. Personally I like to see stuff with spaces after the separators, so I would try to be consistent with using (that is spaces after at least the initial colon and after commas. It seems like your code might be faulty as you have braces around the but not around the two others? Are the braces optional? If so, it would look better if you used the same for very similar lists. Regarding that last code block I would perhaps include a little more vertical space. And possibly, it it's legal, replace the with or similar. That would make the following lines easier to read, I think. 

This program is useful in a very narrow context of someone using as their command shell, and using for terminal windows. And as suggested in comments I would rather have programmed this a bash function or similar shell script to improve a little on portability and usage options. With that out of the question, the main issue I'm having with your code is that you wrap series of commands and blatantly ignore any error codes returned from anything. Any or all of the subcommands can fail, and you ignore it. Not good. And you finalize your code returning 0 (which by the way is unnecessary as it is the default) indicating everything is OK. A secondary minor issue is that you've duplicated the command in the two cases, and if you at some point in time decide to change it, there is a certain possibility that you'll change one of the two, and forget about the other. I would rather have used some variant with on the second case, referencing the command from a constant string. 

You could also consider changing the name of to , which would enable you to do directly. Another considerations in the same method, is to define a few given format patterns beforehand, so they can easily be changed. All in all the code looks neat and tidy, and I might have written something similar myself. Maybe I would choose , or instead of , and possibly using more in due places. Addendum on private variables A major point of using classes, is to hide or consolidate information. The public interface of a class (or instantiation of a class) is usually limited versus the internal interface. In your case you have defined most variables and properties to be public (by naming convention like , indicating that all attributes can/should be accessed from both in- and outside of your class. Usually a better approach would be to hide some of the internal details, and then let methods affecting the object change the internal details. You've made a public property of , which is good, but it is dependant on , which to me should be an private variable, like . Similarily I would have used and . And then depending on what your really depicts, a method like could at given points increase the or , or alternative if they are more related to actions, you could have reducing the as it uses energy. And if your user was attacked it could affect the , and so on. The core concept is that is kind of strange to have all of your attributes publicly available, instead of some of them being private and affected by class methods. But then again it comes down to the main purpose of your class, and how you build your domain model. To me the class as it stands is very sparse, and missing a lot of methods and interaction for it to be useful, and I would have extended the usage way beyond just a means to save attributes. 

Use predicates to generalize method If you look at the accepted answer of "Most pythonic way of counting matching elements in something iterable", they suggest some neat ways of handling your issue at hand. In fact your can be replaced with the itertools.quantify recipe. 

With the danger of not understanding your question entirely as it stands now, you have with a field. Why don't you use to trigger a CSS class for the entire entity which disables that entity? Why do you reiterate over the attributes, and create loads of helpers which I don't understand why you need. I'm not entirely sure about the syntax just now, but wouldn't something like the following do the trick: 

The main change in this file is consolidation of factors into the precomputed and , in addition to using simpler and faster numpy alternatives. The somewhat strange is a little hack related to running the code with or without . The code runs as it stands, but to profile it you need to comment the . If you don't intend to profile it, you can remove the and the decorators. File: 

Note how this way of making it a function allows for 'proper' use as a function, whilst still allowing for user to input the missing numbers and/or operator of choice. Another possible extension would be to add another parameter to control whether it is printing the result, or returning it for further calculations. Possibly even adding a loop around it, so you can repeat calculating other stuff? 

Before tackling the speed issue, let us comment on the chosen solution of using a class and style issues: 

I also tried with an actual generator with both the large prebuilt list of random numbers, and a loopable generator with 1013 random numbers. Those had similar run times to the original code. So, with the exception of making a python wrapper and implement the algorithm in another language or re-build the algorithm, I would be surprised to see a faster implementation. But I'll happily be proven wrong! 

This should avoid the repeated loading of the words for every word of every sentence... Will try to test this tomorrow. 

Even though not needed I would consider using parentheses, or at least space the condition out so that it is possible to see the connection. Possibly something like this: 

All the branches here ends up in either: , or . And these vary by only one thing and that is if they check whether or or all is present in the current element. If present they all call the same which ends up doing the , and if this is found you do the . This should be possible to restructure into a nicer and possibly faster structure: 

I've renamed some of the variables, combined the log output, and introduced a to tidy it a little more. But more or less this code is as is, and could most likely benefit a lot from reducing number of steps and what gets stored in the arrays. I skipped updating of the position of earth, as that is the base of your system. In total I've reduced the number of lines in your code, even though I've added a lot of blank lines here and there to enhance readability. Performance comparision Your original code when I ran it on my computer gave this output: 

If you get more than one or none resulting row out of this query, you have a problem. This is also easily extensible, as you just need to change the matching option count on the section and add appropriate extra groups on the parts. 

Refactored code running within time limit So as not to spoil the fun for those wanting to solve this challenge by themselves, I've chosen to have the code hidden beneath a spoiler. That is if you hover over the block below you'll see the code. 

Whilst I was writing this answer, the answer with using the concept came in, so I included that in some basic timeit tests to check for running times, and the result surprised me a little: 

The only magic in this code is the joining of and using which joins them index for index. This allows for, in my opinion, code that is easier to understand instead of list comprehensions, ifilters, index searching, sorting, sliceing and other stuff. 

Alternate approach using an intermediary file The alternate approach is to split this into two, using an intermediary file. That is use the above approach, but instead of doing the tertiary loop, you write just those parameters needed for modifying the list into a new file. Doing this you can skip loading in the first pass, and do a memory efficient one pass of where you process it line by line. And then you add a new pass where you read this intermediary file into memory, and do a memory efficient one pass of matching only those needed and doing the output to the final file. Doing this you would simplify from potentially having a time and/or space complexity of \$O(n\cdot m)\$, where \$n\$ is number of lines in and \$m\$ is number of lines in , into having having a time complexity of \$O(n+m)\$, and a space complexity of \$\theta (p)\$ where p is lines in the intermediary file. This can have a huge impact on execution time. To change from reading all lines into doing the memory efficient version, you change the first loop into: 

I've looked at your code and question (and on the answer by Gentian Kasa), and there has been something troubling which I haven't got my head around, but I do believe the main issues I have with your code is the following: 

All in all, your code did work locally, but when posting it got a little scrambled and dysfunctional. You should clean up your code to avoid having magic words and number, and rather use constants at the start. And you should cleanup your naming and spacing to make the code easier to read and understand. Text handling and documenting (both internal to the code and for the user) is also areas you need to look into some more. 

Code refactoring My refactored code is a combination of some of the other answers, with my names and error handling, and an example section to show how to use the generic version of this. 

This just doesn't look nice. You have a single line hidden after the without braces, and then you have yammed the up there, and it is kind of hard when reading the code to see what is really happening here. Two suggestions: Always have braces around the blocks belonging to whilefor`, and make a choice and stick to it regarding where to put starting braces. Either choose to have starting braces on the same line, or the next line. Here is an example using the next line: