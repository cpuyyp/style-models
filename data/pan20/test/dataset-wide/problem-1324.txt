Too many variables - the majority of the time the need to hold onto the DB's credential inside the object is not necessary - it should be part of your configuration of the APP and invoked as such then passed inside to the DB object to initialize the connection - once that is done you don't need this info. If you change information then a new object should be created. Why? because image you do need to connect to two different DB (one for user, one for tracking as an example) - if you store your credential your stuck to this. Also as I can see from your constructor - your not even passing your credentials to it - its fixed from a global stand point. The majority of your class is just a smaller typing of what is already presented ie: query, then bind, then execute. Its a rehash of the system's PDO. Another flaw is your Single() function - it has the command - what happens if your query returns more than one result and you want to iterate it one at a time - you can't re-execute the query to grab the second row. fetch()'s purpose is to go fetch and iterate through the rows one by one. You can argue that you can use resultSet() to grab all then foreach but if you are returning 10K rows you will be in a heap of trouble. Next - lets touch a bit of the tracking class. One flaw is the getInstance. Singleton are bad for maintainability because you can't make more than one object of it and its hard to test it. Ideally - since all your functions are relying on the database - you should have passed it (aka injected) is part of your constructor and then call your functions which uses the DB. Its not like you will instantly use a different DB within the function because you are tightly coupled from it. Basically: your Track class is your repository, and your PDO is redundant because its just shorthanding the coding. thats my first pass through of your code. 

Firstly I don't agree with a particular coding convention being tied to a language, implied by your excerpt. I know this isn't the point of your question but as an aside, coding conventions develop from an amalgamation of best practice, and what your development team is happy with adopting (I've been through this painful process). Naming of Boolean Variables A fairly neat convention I've adopted recently is naming of boolean variables by the name suggesting something is true (i.e. an assertion). What I mean by this is that where you have and , you could have and . Then, when you need to use the variable in an if statement you have: 

I'm currently using a make shift INSERT on DUPLICATE UPDATE function that relies on a DB raw query from eloquent. I'm looking to improve the quality of the code and the speed. Please take a look 

I could be wrong (and my answer down voted) but when it comes to routing or submission of forms consider using Behat or a behavior test framework rather than PhpUnit testing. The reason why I'm stating this is because you have sessions, and submission and cause/effect returning that you want to test. Those ARE valid things you want to test but its more user behavior test rather than what PHPUnit is built for which is functional testing. A lot of time when doing unit testing when relying on other classes your able to "mock" or substitute classes that normally function in production to be isolated which is only to initialize a class or a function that you are running a test on. What you are doing instead is testing if the routing mechanism is behaving with set inputs. 

I find it surprising that nowhere do you call , as CSV is a line-based format. Data structures You're resizing your array, which suggests a would be a better option. Naming The method does not contain any assertions, so I would suggest renaming it. Control flow There are parts in the code that are of the form 

I would make it clear that is modifying the array by changing its return type to . This could go either way, as it is nice to be able to chain method calls, but here I would err on the side of . 

Ok with all that routing question out of the way - I agree with mbanzon with basename being fine to check for internal directory structure to block people out... If you want extra security you can run a short alpha numeric check to make sure nothing funny is included. As for the white list - since this is a routing file and a static one a white list can also help speed things up as long as its minimal, one problem though with that is if you file system becomes extensive it maybe best to not have a whitelist at that point (you dont want your lookup to be too large to maintain and add. Side note: if your looking for interesting ideas symfony2 routing is pretty good (its being use at core with laravel). It is more extensive than your solution of course but still interesting to look at. 

That's almost human readable! There are some variants on this like but they can begin to be a bit wordy, but the point is that you're implying that the variable is a boolean from its name. Use of and Variables In this context it doesn't make sense to have a boolean variable for each supported language. The reason being is that it is possible that both variables could be true, which you correctly identify as an error. I get the feeling you're procrastinating by leaving the error checking towards the end. My first recommendation is that you create an enum which stores the detected language, and can have one of three possible values: 

NOTE: function is only valid on model level and does not allow mass insert. Doing will allow to have a inserted as long as fillable is used however it will reject if there is a duplicate key 

If you are working in PHP use a framework that has MVC such as Laravel(up and coming and popular), Symphony, Yii, Codeigniter(defunct), etc. Each of them will enable you to use some reuse mechanism. Laravel itself uses a template PHP called blade. There are several other template mechanism such as Twig that enables you to template your views to even add more granular way and cleaner. If its a single file system that you must what you are doing is fine because you are using require_once it enables you to call other files and you can modify that file and it will reflect any other files that references it. 

You're using -1 to indicate that the floor of the key is not in the array, but what if -1 is the floor of the key? Conflating indices and array elements in the return value is going to cause trouble. The floor of is the greatest value less than or equal to . Also, what happens when ? For the array , here are the results I would expect, and the actual results: 

to calculate Fibonacci numbers, as it takes exponential time. Instead, we can calculate Fibonacci numbers in an iterative way 

I will extend mulquin's short post. Sanitizing your POST will enable you to make sure there are no SQL injection. Since you are using PDO - you should use prepare() function reather than exec(). exec doesn't escape your query. (as shown in the link provided by mulquin) Furthermore - you are not checking if the email is indeed an email or not what happens if its not a real email address (ie the format is not john@doe.com) - you will be storing gebrish at this point. So a bit of validation so that not only spammers won't just enter anything. 

I would strongly recommend against using and in your files like this. To compile without them would require going through every file in your project and removing those lines. These symbols can be set in Visual Studio at a project level in the project build settings: 

is (generally) an implementation detail. has a public field . The fact that you're storing nodes in a is an implementation detail, and should not be exposed to users of this code. 

This implementation of Quicksort has poor performance for arrays with many repeated elements. From Wikipedia, emphasis mine 

You should pass the body of the mail as an argument and it will do what you need. The body part should have been on the outside and independent of the mailing function. This way if you decide to expand this - you wont need to copy paste a third version 

From a first pass over - all you are doing are if else without any throw or inspection as to what possible errors that the PDO might be tossing out. Thats bad because on production servers - I would assume that you won't be turning on error/warning reporting but will be logging them. Also as @Alex L mentioned - you are missing a IF statement that checks if $pdo == null then throw exception. However its better with a try/catch