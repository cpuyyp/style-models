So any attempt to modify it generated a completely new string (which to programmers in most other languages is strange). The solution is to use the java.lang.StringBuffer. This behaves like most other languages string object and allows mutation. The objective is to build a string inside a StringBuffer and when you are finally finished covert this into a string. 

You can simplify this and just look for the value by checking the value of the next node. Note: The same code works for NULL terminate list (just change begin into NULL). 

Note the format string: " %d" The leading space ignores multiple (including zero) white space characters proceeding your data (Note: White space includes '\n' so it will correctly wrap past the end of line). Then the %d will read a number from the stream. If it succeeds then it will return 1 to indicate the number of decoded '%' objects is 1. 

Comments on encapsulation You wrote your program very serially. Basically what you wrote was C code (you just happen to use some basic C++ constructs, this does not make the code C++ (C++ has a style that is distinct from C)). What you should have done is encapsulate the date in a class of its own. Then you can write an input method that read data from a stream so that the object initializes itself and can also print itself. The main should have looked like this: 

Also do not limit it to sqlite. Make it so it is easily expandable to other DB types. I would go with a prefix Notation on the DB name: 

Polymorphism: It looks like all this work is done on the board. But really you should be using polymorphism to mark the board. ie the piece knows its own type and can mark the board appropriately. 

The one improvement you can do is during construction. By retrieving the size of the input container you can reserve enough space for the new elements. 

Prefer over The difference is that forces the buffer to flush. The buffer will flush automatically when it needs to. Forcing it to flush is only going to make your code inefficient. 

Naming conventions. It is more usually to have function names with an initial lower case letter. This helps us distinguish types from objects (user types normally have an initial uppercase letter). You are using the term incorrectly. The term handle is used as a double indirection. It is a technique that allows somebody to delete a resource and set the the first indirection to null showing the resource been released (thus anybody else with a handle will see it has been released). The term handle has fallen out of use as the ownership semantics of C++ provides a much better mechanism. Really what you have a various pointer types. These seem to be badly named: 

When you comment a member out you take all the stuff you need with it. I would also move the work for your jobs into your task object. 

Next you always copy the objects into the list. That's fine but you should also think about moving objects into the list and emplacing them (building them in place). 

Or don't even calculate it at all. The string is terminated when you reach the '\0' character so just look for that 

There is no need for in this context. Unlike Java it is very unusual to use in C++ code. Using it also leads to errors that compilers can not detect. The only reason to use is to distinguish a local variable from a member variable that has the same name. This is called shadowing. The problem is that the compiler can not tell if you meant the local variable or the member so there is no way to automatically detect when you accidentally forget to use . On the other hand the compiler can easily detect shadowed variables and generate a warning. A compiler warning is a logical error in your code that you should fix (your code compiles with zero warnings when you add -Wall -Wextra?). Anyway, not using shadowed variables makes your code easier to read and understand and you will never accidentally assign to the wrong variable (as they have completely different names). 

Looking at the code Lets make it readable by indenting more than one character! Two is acceptable but more usall is around four. OK we assume this is reading from some file descriptor but it is not a standard function. 

Problem here is that you are starting from 1. arrays/containers nearly everything is indexed from 0 and you can access the elements 0 -> (size() - 1). So here you are starting at the wrong point and going past the end of the string. But as mentioned above you don't even need this as you can replace the loop. 

Emplace back is usually used when you have the arguments and want to build the object in place using the arguments. By passing the object you are going to just invoke the copy constructor. As a result there is no benefit from using it. Though there is nothing wrong with using it either. Currently I am still working out when to use over but this is one situation where I would still use . Also because you pass the argument by value you are copying the object into the function then using the copy constructor to put it in the array resulting in another copy. So here I would pass by reference. 

The directive is "#include". Not all pre-processors are going to support this. So get out of that habit. Remember that the pre-processor phase happens before the compiler is invoked (though modern compilers roll it all it to one). Even if it was legal I would advice against it as it is non standard and makes people second guess that it is going to work. Style: Having a hard time reading your code Your indentation style is making it hard to read the code. 

Bad idea. You are doing a runtime check for something that can be detected by the compiler. This should force a compile time error. Code Review 

Just because a src is an IsourceAccount does not mean it is also sourceAccount so casting it may not be valid. But it looks like what you are trying was to create a wrapper class (like this): 

But not sure why you would need it. The only reason to use the two above functions is so that you can serialize your enum's easily. So why not have conversion operators or stream operators rather than explicit get the underlying structure. Also this allows you to stream your object out but not in. Don't use 

That's fine as far as it goes. Though I am not sure why you want all the added complexity for a problem that seems to be already solved. What I think we all want is to stream in a logical way, that is consistent across containers. Your basic example: 

It may look like it is working but this is just pure coincidence that the ABI for static member function happens to be the same on your platform as the ABI for C functions (there is no requirement in the standard). Nor do any OS that I know give guarantees that they will not change this ABI. You should declare it like this: 

Comments on Code Don't use this interface. What happens if the user types an extra long line of stuff. 

Note: the returns a a reference to the stream, so this is functionally the same as the line above. But it imparts more information. What you are saying here is: we succeeded. Looking at your dispatch. You have a structure that is the same every time you call. 

Also I would add constructors to your classes so that you can jsut create the elements in one go: So if we add the constructor here: 

If we are building a tree I would normal expect the return value to be the tree we are building. Not a way of filling out the tree. So I would expect the function signature to look like this: 

But really the above is a text book example (not a real world example) of a singelton. The singelton pattern is actually dangerous in that it binds your implementation to an object with mutable state. As such it should not be used in isolation it should be used in conjunction with a creator pattern (A factory is usually a good choice). Note: Singelton is a design pattern. But in a lot of places it is also considered and anti-pattern so be very careful with its usage. Template problem Though technically correct. You may find problems with this design when using shared libraries. As each shared library may have its own instantiation of the templated object that is not shared. Thus you actually have multiple instances of your singelton. Summary: Personally I would not use a singelton (I think you can use other techniques). But if you have to use a singelton then it would look like this: