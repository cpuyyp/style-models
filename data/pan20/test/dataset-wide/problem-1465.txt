They are practically the same. But now let me explain how this works a bit now. in .Net inherits from the class which has the Where() overloaded extension method from the Linq library. Using linq in combination with a lambda expression I was able to specify to the method exactly what values to give back. I specifically did this with some math involving the index of the item that was being iterated over internally. Suffice to say, the Where method loops over given list, and returns all values which meet the criteria given in that lambda expression. At the end I convert the to a to work like the data you had before. 

I see no reason to have be a non-static class. You are not taking advantage of the fact that you are remembering the path and worksheet name, and you aren't keeping some sort of open connection to the workbook. And always feel free to make your code look more complex by removing variables that are only being used once (optional). There is no reason to this, because you are returning an anyway. 

In your code, you are getting the subsection of the extension, then removing it from the original. Instead you should simply just get the subsection of the string without the extension. 

I do want to address the way this method is functioning. It would appear that you have gotten some data, and now are checking the data. I know you said this is someone else's code, but it should be changed. My assumption is that outside this method call is a try catch statement that is catching the exception and displaying or logging the exception message, otherwise display/logging the "It worked" message. I am guessing this is the case because the person who wrote this code didn't realize how much better it would be to just return two values. Notice at the end of the method signature is a new parameter called succeeded 

Now just use some linq to only grab results from the Combinations function where the sum of the numbers in the list equates to 0. Foreach of them, print it to the console. 

Ensure that in your you aren't actually doing the logical calculations every time. I assume you are doing your calculations based on a delta based system, where your calculations used the elapsed time since your last .update() to determine how much (lets say) something has moved. So be sure you've implemented a system, where the calls update on all the items in the list of items, and each one of them determine if the time since they last updated their stuff, was long enough ago to warrant recalculating their position. (Each item class maintaining how often they need calculations) If you want to see an example of this, check out the Source Engine's implementation. $URL$ Here you will see after events happen in game, the programmer manually sets the next time the think() method will be ran, which is called update() for you 

As far as the methods you've created and are calling I see no problem with (as per your doubts). Functions calling functions is a good thing. Functions should pull all of their own weight, calling other functions when necessary, the coder shouldn't have to call those functions beforehand and pass in the parameters, unless of course there is a situation where you (the coder) do at times need to specify specific running values. Your main looks good, however as far as aesthetics of your code goes, I would add spaces between your operators and symbols... 

The code I posted in is the most efficient because it only does as many comparisons as is needed, and cuts out when it finds the correct value. One advantage 4.1 has over the code you posted is that it doesn't do a string assignment before it does the comparison. Your code could have been re-written to avoid that as-well. The code in is sleek, however it does require you to create an array, which is not expensive at all. I am only mentioning this, because it is something to consider when choosing the right code for you. While the differences here may not even be noticeable by the computer its self in terms of run-time speed, efficiency is something to keep in mind at all times when coding. 

...saves 3 characters, and makes more logical sense. Also, instead of checking that index, it could be re-written to store the result, then only modify the 3rd indexed location and that. 

If it wasn't for the I would suggest you actually go forward with the whole OOP thing, and have the workbook load when you construct it, and take advantage of OO design by actually having internal data besides just the path. I do think its is fine that you give them the option to specify , that could be very handy. 

Your worst case scenario for the chain is that you have to hit every single one of those IFs. If you structured those in binary search design, ie. start from the middle and eliminate half of the spectrum at a time and work your way out, worst case scenario is that you have to hit half of your IFs. The code for this may look ugly, but it would help. 

Your If-chain should be an if-else chain, because if one of those is true, then there is no reason to check the next condition. This behavior is easily emulated also in a switch statement 

I'm looking for feedback on anything relating to structure of my tree, or how I programmed it. If you have any tips, or see some place where I've taken a longer route than necessary, I'd like to know. I'm not looking for criticism on how my if-else chains look, or how I only include brackets when necessary instead of all the time to maintain consistency. I am more interested in functionality feedback. One thing I can point out right now, which I believe is inefficient is that when a block is being created, it is looped over just to be collected and passed into another block constructor. This means if you have a block nested 10 blocks deep that block is iterated over 10 times, and only processed the last time. I could remedy this by creating new properties and blocks as I go, the deeper I go. Using a recursive approach, and that might work faster. However as far as I've seen blocks are never nested 10 deep, they may get as deep as 5. Anyway here is the code. IVNode 

As I said above, C# convention is to make anything that is publicly accessible to be a property. So this is your chance to look at your class members and decide what really needs to be seen and/or modified by outside sources. What if you decided to allow addons to your game, and lets say its a multiplayer game, so you don't want people cheating. But now anyone who can get the memory address of your asteroid object could easily change its position, visibility, or its texture. Even if this is some small project for yourself, data should only be exposed as much as absolutely necessary, and only those who need to change that data should be able to. Also, anything that is public needs to be , not ie. start with a capital letter. From a quick look... this is how I would do it. 

TimeSpan objects have properties like Days, Hours. the calculation done, does take into consideration leap years. Printing to the console can be made easier by sending parameters to be inserted into your string. 

I realize this is complex, and the average person wont be able to read it. I use magic numbers, and I do some things specifically to keep the glory on 1 line. Feel free to bask in the presence of psychedelic code (which just wants to be your friend). 

Edit: Expanding on Exceptions Instead of throwing an , adopt the model used in TryParse. Return success or failure of the method as a boolean, and sent out the data you want. This way you don't have to throw an exception at all. 

I wrote this function to use in my applications where I need to easily color-code output. Example syntax would be: 

In this alternate solution, you'll notice that I use LinQ to the two lists. For the second list, you may also see that I set the count to be negative, so when I re-grouped them again and did a sum of their values, they would subtract from each other. Then after that I do a checking for anything that wasn't zero'd out by the subtraction. Then return whether or not the collection contains any of those.