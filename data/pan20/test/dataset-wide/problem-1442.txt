But we can do better than this. The above code has two loops: one which calculates the factor counts and one which searches for the contiguous fours. Lets merge this into one loop: that way it will stop generating factor counts as soon as it finds the fours. 

For this code to be usable, it has to be completely 100% thread safe. Can anyone see a hole in it? Also, am I just re-implementing something that already exists in some corner of the .NET base class library? For the sake of context I'll provide a practical use: there's a long running application, and some code that must execute if a file exists. The file might exist when the code first runs, or might come to exist later, or might never exist at all. I invoke it like this: 

Here you throw a string. You can throw any value, but it's more helpful for debugging purposes if you throw an object. Just pass this string into the constructor to make your own error message. 

I've created a function that takes an integer greater than zero as an input and converts it into its corresponding Roman numeral. If you're not familiar with Roman numerals, you can read about it on Wikipedia. I've tested this code with some examples, so it should be working correctly. I'd be interested in hearing about any general improvements I could make on the code. Nitpicky details are fine as well; whatever you have to say I'm willing to hear, but I hope your answer is more substantial than that. I suppose my main concern is whether this is sufficiently efficient or if there is a way I could improve on that. Also, do you think I've used the correct data structure in this situation? I can't think of a better data structure for what I wanted to do, so that is why I chose arrays. 

I'm creating my first Bash script , which generates a Markdown file containing the metadata for a new blog post. This blog post will be hosted in a Jekyll engine, like GitHub pages. The idea is to facilitate: 

By the way, I'm using Excel 2016. So I'm not sure the code compatibility. Please tell me if there's any error. 

This block can increase the code efficiency and readability. Check the existence of target object The macro record is powerful, but it's more difficult to understand whether something exists already. For example, we may not want to apply 10 rules of color scale to the column A. 

I'm learning Java concurrency by a TDD approach. Therefore I wrote a basic test case in JUnit to test the behaviour / expected results of 2 threads. I'm looking for feedback for this code. In particular, the feedback for using . I'm not sure if it is used correctly. 

You initialize and , then you reinitialize in the outer for loop, then do nothing with in the inner one. You don't need to write an initialization step in the for loop if you don't want to. 

This is a good first attempt, but you have a couple things wrong with it. If you look at the for loops, you'll see it's adding each element to the nav in the same level (rather than nest them inside each other), but then proceeds to move it to the correct place with the inner for loop. That's the second problem. You rebuild the nested element structure each time you iterate over the array. You should eliminate all this unnecessary work, and you can do it in all plain JavaScript without using jQuery. Edit: changed function to accept any number of elements as arguments to nest (e.g., ). 

And so on. When you're done, every number will either be 0 (if the index is prime), or it will be the count of prime factors of that index. Now it's as simple as finding the first four contiguous fours. This solution takes around 130 milliseconds: 

I like the pattern of the jQuery Deferred object. I like how you can call any number of times, but the listening objects will only be notified once. I also like how you can attach a listening object after has already been called, and the listening object will still get the notification. If you're programming in an uncertain multithreaded environment, it greatly reduces the amount of thinking you have to do. I couldn't find an equivalent in the C# library, so here is my implementation (a basic subset so far): 

Immutability. A version object should never be changed once its instantiated. (I don't know what would be the benefits, but I feel it's a good idea). 

This can be useful to do explicit job, without changing the active sheet. The same way for , and , you can always access the target object by the collection. Use rather than Aside from error-raising macro problems, a recorded macro is less efficient, because it mimics all the mouseclicks and keystrokes (every cough and camera flash) that occurred while the recording was taking place. A recorded macro clicks on every object to select it, then performs an action on the selection: 

"Version" a common notion in software, which helps to unique states of software development. I implemented a simple POJO for "version" in Java. I would like to have your review about this code. I'd like to have a Java class satisfying the following requirements: 

This will swap s when passed addresses to s, a.k.a. s. Now your function will swap the members in the s correctly. 

You might appreciate taking advantage of some ES6 features. You're using an object literal like a map, so why not use a real ? Speaking of ES6, since you're a beginner, you would benefit from taking the time to learn it now and save yourself the headache later. As others have noted, you can accomplish finding the mode in a single for loop. 

In that example, is 7, the duplicated number is 1, and the missing number is 6. So you get the formula . We can solve for by adding to both sides, leaving us with ! Let's do that. First, you can calculate the expected sum from that formula, . In your loop searching for the duplicate, you will need to keep a running total (and don't break early). After you find the sum of your list and identify the duplicate number, you can calculate the missing number using the formula we talked about in the above example, . Also, you don't need to record the frequency as an integer, you can just keep a list of booleans for numbers already seen. I've also taken the liberty of cleaning up the indentation issues and renaming some of the variables for the purpose of readability. Here is the solution: 

If you have two or more property or method statements that work on the same object, wrap them in a / block: 

Composition. A version is composed by 3 parts: major, minor, and patch. All of them are required attributes. Digits. Each part must be an integer. Negative numbers are NOT allowed: a valid part value should be either 0 or positive number. Incrementation. Incrementing a version means incrementing the value of major, minor, or patch. Comparability. Versions are comparable. Such comparison should be numeral, and should not be lexicographical. For example, is greater than . Serialization. A version object in Java should be able to serialize into a string representation. And a string representation can also be deserialized into a Java object. Reversibility. The serialization and deserialization of this object should be reversible. So an object should obtain its owner value after { serialization, deserialization }. So leading zeros are denied: