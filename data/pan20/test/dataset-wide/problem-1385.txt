Naming Structure/variable naming is one of the most effective ways you have of making your code self documenting. It's always worth taking some time to consider your names, this becomes more important the wider the usage of the names. You have names like s, info, num for your most important structure, its members and references to it. These are far from descriptive and are worth reconsidering. You also have method names like , , what are these methods reading/writing, to where? Overflow You method loops through a file, reading into a constantly sized structure buffer. If the file contains more lines than the number of buffer elements it will overflow. You should be checking that < MAX. Error checking Your method is using sscanf to parse the contents of the file. You're not checking it's return value, what are you expecting it to do if you get passed a line that's not the correct format? Bracing This is subjective, but I don't really like this: 

I had a few thoughts whilst reading through your code: Naming I don't mind the prefix for interfaces, I've never really liked as a prefix for classes although I can live with it. Having another prefix of for engine specific classes feels wrong/confusing. is a concrete class, that does stuff, why isn't it / for example? Interfaces Some of your interfaces don't really feel like interfaces. For example, has one method . This isn't what I think of when I think of an Engine interface. It could be an interface but it still feels a bit wrong. I'd expect to define operations that were then implemented in . Initialisation You're declaring variables and calling methods on them at the same time: 

The shadowing works, and the correct implementation is invoked. However, because you're invoking the implementation from the base class: 

Could be abstracted into an method which would make the code easier to follow. Recursion This is odd: 

These lines essentially output a menu of options to the player (subsequent lines fetch the input and decide what to do). This is a prime candidate for extracting a method to perform a common task. For example a method which displayed the menu and returned the selected option. You may want to consider using an instead of an int to indicate the selected option. This will make the code easier to read. You've then got two lines that you use to display the current state of a fight. This: 

This is hard coding knowledge about the external environment into the class. This means that if in the future you decide to move/rename the method you'll have to update the class as well. I'd consider passing the information instead into the Snake's constructor. You could pass the initial snake coordinates directly, or my preference would be to pass the function into the constructor. 

The first method is called from the Challenge class and the second is called from your test classes. This duplication is caused by knowing how to read information from the user. It would be better to only expose a single method, possibly or and have another class responsible (or the main method) for constructing the array from user input. This prevents the need the class to differentiate between when it's being called properly and when it's being called under test. This also removes one of the confusing aspects of your unit tests where you do this: 

_pin overflow You're relying on the caller to prevent a buffer overflow. Consider if the calling code was this: 

size I don't like that you are calling size outside of the guard methods. Is it documented that it is thread safe to do so? It probably won't cause an issue, since you check again within a guard, but it feels like you are making assumptions about how it is implemented. r1 to 4 These feel wrong. If you only have one worker removing items from the queue and you are confident about being thread safe then they are redundant. The if statement ensures the condition you are going to wait on has already been met. The mutex can simply be locked. 

map map is a collection in the STL, so I would tend to avoid using it as a variable name. I'd also consider using a two dimensional array to represent the play area, rather than a 1 dimensional array. That way instead of doing the hard work yourself: 

As I've said in my comments, I'm not a huge fan of testing private methods. It couples the tests very closely to the implementation of your class which makes even simple refactorings much harder than they need to be. That said, lets have a look at your test. Naming tells me nothing really about what the test is expecting. is the name of the method you're calling. tells me nothing about what you're passing, or what you're expecting back. This doesn't make the intention of the test easy to read. Exceptions You're catching exceptions in your test and more than that, whilst you're logging them, you're swallowing the exceptions. I really don't like that. If your code throws an exception, you should let the exception escape the test and fail it. Having the test fail on when it's actually failed because it threw an is just confusing. Setup If you're going to be running multiple tests against the same private methods, then it makes sense to do a lot of the prep work either in a method called explicitly, or in a method on the test class (notice that I'm not catching any exceptions. If they happen, because your class structure changes you want it to fail: 

Wrapping the calls in a method like might make it more obvious. There would also be scope for re-usability for some of the methods, between your applications (your previous post has very similar curl connection setup). Error Handling On some errors you exit the program (failed to parse JSON), however on others you don't . I would assume if curl returns an error for the call you will probably fail to parse the JSON so might as well abort early. Constants Consider using constants for your magic strings. Whilst it's obvious that the argument to this call is the targetURL: 

As you seem to commonly write the same string to both and , it's probably worth defining a function that simply does that and using it instead: 

This might be ok if was sorted, however this doesn't appear to be the case. The assumption that you can add 10 if the rolling value is <= 11 is incorrect because it means that the order you draw the ace is important. If you get (A, 7, 7), then I don't want the ace to be worth 11, I want it to be worth 1, which is what it would have calculated if I had got (7,7,A). This can be demonstrated if I force cards to be drawn: 

Exit You exit if there is insufficient memory to allocate a . The exitcode 0 is usually reserved for a successful program exit. You should be passing a different value to exit (usually a negative number) to indicate failure. Heads or Tails In your method, you're not updating your tail pointer, what is going to happen if the tail happens to be pointing at the node that contains the value you remove? Similarly, what happens if is pointing at the node that's removed? reset I'd honestly expect this to clear/flush/empty the list, not just reset the pointer that's used for iterating over items in the list. This is likely to be confusing. templates Depending on what it is you're practising for, a good next step would be to adapt your so that it can support a templated value type. You could then extend the list to store and retrieve values of any type. 

Various things about your code seem odd. Field level values There's no reason for these variables to be declared at a class level, you only ever use them within a single function: