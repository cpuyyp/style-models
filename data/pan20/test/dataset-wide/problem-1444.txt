Style-wise, objectively improvable: Avoid leaving dead code This looks like junk you forgot to delete: 

And you could rebuild the class in a much simpler way around it, and it gets rid of iPoolable entirely! want a ? no problem! You are creating too many objects too soon. 

But that's fine because that's preferable once you move to anyways. Edit: On that note: Raw pointers are not evil 

T must have a default constructor T's constructor get called for all objects as soon as the pool iscreated T's destructor doesn't ever get called. T basically can't use RAII semantics 

Don't use for_each when a range-based for works. is not best practice unless you are already manipulating a predicate. range-based-for is preferable: Like so: 

I actually take issue with functions written like this in general. It screams "I am smarter than a compiler", and flies in the face of most of what C++ is about at a philosophical level. It's not portable, it's not future-proof, it's severely hamstringing the compiler, so optimizations implemented in future versions of the compiler will likely not be able to be applied. All this to say: for me, there needs to be a crazy strong rationale to motivate the existence of something written like this in a non-toy codebase. The biggest culprit of this in your code is the "writing more data than the size returned" part of it. The chances of this eventually stomping out-of-bounds memory is simply not worth the marginal performance difference. Considering the places in code where such encodings tend to be used, I find it highly unlikely that it has any measurable performance impact in anything that benchmarks this in context with some other code around it. So, now that that's out of the way, here's my feedback of the function as written: Don't use builtins where you don't have to. I get using , but there is no valid reason to use over . Don't use magic values where unnecessary That 64 coould easily be . Same goes for the 9, it could be . I know you only care about X86_64, and is always 8 bytes on that platform, but if being safe does not cost you anything (which is the case here), then there is no excuse not to be. Alternatively, if you really want 64 bits exactly, just use instead. Separation of concerns The main issue I see with your function is that it conflates the encoding and the storage. You would be better off separating them, and letting the compiler reconciliate. In the following, compiles to effectively the same thing as your . On top of that, since is now a pure function, and does not involve any side effect anymore, the compiler is a lot more free to mix and merge it with the calling context, so odds are it'll end up being faster in actual use. 

I'd like to give some thoughts which spring to my mind when I read your given code. Now, you have an implementation specific for primitive ints. A more advanced step would of course be to implement a generic like the one in the JDK, just mentioning it. First up, I like that you use clear variable names, and that you reuse methods like \ . Kudos for that! As an aside, you do not need the variable, as it is the same as . It is a fixed size stack, so it does mean you have to know beforehand how much elements it would take up, in order to not waste space (or run out of it). Perhaps for a follow up exercise you could try and make it dynamically resizable? Now, for the method. I would not let it silently succeed if the stack is already full. Seeing as it is a fixed size stack, I would probably opt to throw an , because to me it looks like a programming error. A possible second idea could be to return a , signaling succes or failure (though I don't think it is the better solution). Same with peek. It now silently succeeds and returns , which is very well a valid value which could reside in the stack ( exists by the way!). The solution would not work here of course. Also, I personally do not think the extra new line is an improvement, on the contrary. Finally, to me means taking off the top element of the stack. So why not return it? 

I'm not going to comment on the OS interactions here, just the C++ code in general. prefer anonymous namespaces to the static keyword static is just a C backwards compatibility thing, the proper way to prevent a name from leaking out of a translation unit is an anonymous namespace: 

Logic error, exec() can only return "0" or "1" That doesn't feel right, since you handle "0", "1" or "2" 

Answering only your specific question here: "Efficiency" is really the wrong thing to be worrying about. For example, look at what your code generates when given to clang 5.0.0: $URL$ It looks like a bunch of gobbledigook, but what it means is that clang very heavily vectorized the code. This makes the code extremely fast for long chains, but not as fast as it could be when handling 1 or 2 digits. Performance is ALWAYS contextual and relative, and unless you know what context you are operating under, you can't really know wether it's efficient or not. 

Apart from type erasure, there is nothing gained by inheritance that cannot be accomplished through composition. Composition is more flexible. Primarily because you don't run the risk of running into clashing namespaces, but also because diamond patterns are easier to work with. 

the stl provides you with the super handy to deal with these situations, where you can in-place create and in-place delete object from safely. 

You have to keep in mind that Streams are not the solution to everything. In this case for example, you need to keep track of multiple values, i.e. the current individual, and a cumulative sum (and you have to return a a value as soon as a certain condition is met). Yes, there are ways to do this with Streams, but I think in this case it is best to implement it with a simple loop like you have. A couple of side notes: 

I don't really think you have what I'd see as duplication, but a possible other way to implement it would be to keep track of wether you are currently in a sequence of underscores. Example: 

I have a feeling there is a direct way to compute this amount, but I am not really into all the mathematics, you could possibly look it up. I'll talk about your code as is: 

I can't think of a way with better time complexity, you have to know all values before you can sort. Though with some Java 8 stream capability added to the class, you could implement it quite cleanly as follows: 

Without the link, I can only make certain assumptions, so I am going to give a couple of global comments: 

Your problem is not in the code, but in your algorithm. Brute-forcing the solution as you are doing is fundamentally slow, and you need to tackle the problem from a different angle if you want to make a substantial dent in your runtime. The problem is constrained in two specific ways we can exploit: 

It sounds like what you want is a hard-enforced singleton. With an interface like the following, you can provide a hard guarantee that only a single instance of Controller will ever exist: 

Now, if I had a function that converts a substring into "some" representation that's common between annagrammic pairs, but only between annagrammic pairs, I could simply generate that representation for each substring and work off that datastructure instead (probably by using it as a key to a map of number of instances seen). Since we only have 26 possible letters, a simple , where each cell represents the number of times a given letter appears in the substring, has all the properties we need. Just to make sure I'm not spouting nonsense, I gave it a try, and my solution using these principles solves all the hackerrank test cases in under 10ms. I encourage you to give it a try by yourself, but if you request it, I'll be glad to post the code for my solution here. 

Well, I do not want to be the one always hammering on using s, but your second solution was almost immediatly clear to me, whereas the first was not. It does help that with the second one you split it up into methods, a very good thing! Nontheless, I still think you can improve the second solution: 

This example may be used when the method this code is executed in does not declare to throw a checked . But it all depends on the case at hand. 

The reason for this is that now we only flip while it is necessary, because if the bottom of the remaining stack already contains the largest pancake, we do not need to flip. Meanwhile, we are also keeping the implementation clear: you first look for the largest pancake in the remaining to sort stack, move it to the top, and then to the bottom of the remaining stack. Using clear variable names makes it so other people can understand your implementation more easily (and even for yourself, if you would come back later). 

So, apart from the good points already given, I'll add my comment as an answer: Your method should return the first of each type of element. This would only really make sense if the stream itself is ordered, so that the encounter order is deterministic. When there is no fixed order, 'first' does not have any sensible meaning. A way to check it is: 

I think should be a free-floating function, since you already have the accessors. I would definitely try to format that fold expression in a more readable manner. See my version of it above for an example. 

It's 100% clear that does not have ownership of the data, so accessing mutable data from a const span is absolutely fine in my opinion 

You can apply the feature to anything, even base types. You won't run into a diamond pattern if you need to inherit from two interfaces. You don;t pay for the feature until you are actually using it. 

A good example of this is vs having a base class at the bottom of your hierarchy. With , which is composition-based, you get a few major benefits: 

Whitespace, let your code breathe Your code has a few logical sections, you should use empty lines to break them appart visually. It makes your code easier to read. Personal opinion: front-load your type aliases General wisdom in C++ is to define things as close as possible to their first use, but that's generally meant for objects with lifetimes. I personally prefer to put any type alias at the start of its scope. algorithm is unused, so it should not be included Simple enough: do not stuff you don't need. That's kind of it, really, good job! Edit: to answer your question, you could finagle something with , or just create a scope for partial_sum, but it's not worth the trouble. What you have it fine. 

Note that will bring you to the same spot as . You can see that each of those share the same second parts as well. This is duplication which we can use to speed up the algorithm. If you think about it, there are generally multiple ways to get to some point . If you think of this as the starting point, the possible paths to the destination will obviously be the same, no matter how you get there. So what you can do is create a lookup table for a calculated location, so you calculate each one only once. This will give you an extreme amount of speedup I would think, on problems with a big amount of possible paths. Which you will get to quickly, even for small values of . 

Not sure if I should review it as a programming challenge, or if I should include design remarks, I'll just say what comes to mind. I'll first note that I would make the fields , and add accessor methods. Them being immutable makes sense I would say, and methods help for using them as method references with the streaming API and others, as I will show in a second. For , I would really refrain from using and , at least when you do not know the implementation. Depending on the implementation, the performance of these could turn out to be quite horrible (e.g. could traverse the list up to the index each time in case of a ). Also looping and mutating a collection at the same time is a lot of times error-prone or worse. Finally, you mutate the collection passed in, which is also a point to think about twice (though not necessarily bad). For , I like this implementation better. It is a smarter implementation for given problem. First, I would like to note that since Java 8, has a default method implementation for sort. Next, with the method, you can specify which property of the type to use to compare with. If you add accessor methods like stated before, this would make the sort look like (with a static import of ):