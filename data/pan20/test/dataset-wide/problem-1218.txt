Rule-based search: This method involves identifying the set of blank squares that can be filled immediately with the available information. For each iteration, the amount of information increases, and eventually as each squares get filled, the puzzle board gets completed. guided brute-force search: The evaluation algorithm, on a high level, is a brute-force algorithm which relies on an analysis method which prioritizes the blanks that are to be filled first. During each search iteration the rule-based search is called to complete the evaluation if the amount of information on the board is sufficient (as each depth first search iteration increases the amount of information on the board). The analysis method that guides the depth first search: This assigns a weight value for each of the blank squares based on a measure which determines the influence of filling-in that square with a possible value. 

The value represents a null-set. The values starting from to represent the values in the Sudoku board. For example, the bit-field value represents the set of numbers: . Therefore, unlike this stores multiple numbers in an integer field. An object of this type is used for holding the possible list of values that can be inserted into a particular square. 

The signed integer values from represent the numbers in the Sudoku puzzle board. The value zero signifies a blank-box in the Sudoku puzzle board. 

The following defines bit-field values associated with each symbol accepted by the sudoku board puzzle: 

This Sudoku puzzle solving algorithm follows a brute-force approach mixed with rule-based approach. To further improve performance, an extra analysis step is added, to determine which squares to be prioritized while choosing it to be filled. The priority value is inversely dependent on the number of possible values that can be filled into a particular square. This value is used in computing the priority weight value of each of the blank square that is to be filled. This priority weight value helps in ordering which squares must be filled first. 

The class's function solves the entire puzzle. Understanding the functioning of this function will be enough to understand the working of the algorithm. The following, 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

Here, says that in the expression above, the type whose behaviour/implementation we're defining is the type. How do we check if a is valid? Well, it takes no arguments, so a proposition that is just or is valid if it's true, and otherwise a contradiction. 

Inductive Instance Definition - First Step This is the fun part. We're using induction. Here's the full code snippet, and then I'll break down each line. 

This is the key: asks the question "Is this proposition false for all possible inputs"? To test this, we split into two parts: its first argument and the rest. If the first argument is , then is it possible to satisfy proposition with the remaining arguments? If not, then it's a contradiction. This is the part . is itself a function of 1 Bool argument, so it is in class , and so we're able to apply to it to see if it's a contradiction. We also need to be sure that it's not possible to satisfy if the first argument is either, which is why we this with . I'll leave the function as an exercise, and move on to the next inductive step. Inductive Instance Definition - Inception Since is of class , then so too is . I could be mistake, but I'm fairly sure that is actually just short-hand for this. So this means that a boolean function of two boolean variables is itself a proposition. How do we determine its validity? We check if both and are valid. The former means 'if and both evaluate to True'. Hopefully you can see now the recursion that's going on (I haven't done a great job explaining it; sorry)-- what we're doing is recursively defining the ity of the type so that such a function is valid if and only if it evaluates to for all possible inputs. 

type represents the set of all values that can/can't be filled in a square. This type is specifically defined for storing bit-fields for representing a set of values. This follows the following convention: 

These are the definitions of the generator functions. This shows the vital functions involved in the analysis process (the process to determine the priority of selecting blank squares): 

This holds the priority value of each square in the puzzle board. This is used during the evaluation process, where each instance is sorted based on the . A detailed explanation will be provided in the later sections. 

I had written a Sudoku puzzle solver that accepts puzzle boards, and completes them with the least possible time. Rather than purely depending on brute-force, my algorithm first attempts to fill in the squares that have an obvious solution. And for each square being filled this way, the amount of information increases (I.e.., more number of squares get filled which aids in filling in the remaining squares) which makes the further iteration process easier. Once this method fails (this happens if there isn't an obvious answer to fill-into any of the squares), the algorithm immediately switches over to brute-force search. (Note, the source contains a few spelling mistakes, like the word recursive misspelled as Recrussive. Please ignore spelling errors. Anyway, it has been a while since I touched this code, and this was my first object oriented code written in C++). The basic working (High level view) 

Though this algorithm may seem to provide an alarmingly bad worse-time complexity, this algorithm almost never hits the worse time complexity regardless of the (legal) puzzle entered. List of types defined and used throughout the program : I. BoardGrid 

The program first determines the set of all possible values that can be entered into every blank square in the puzzle board. The possibility set is determined by iterating through the row, column and the block, and eliminating the set of numbers already present. The possibility-set is stored as a bit-filed value for each square. Every blank square with a single possibility gets the number entered into it. The algorithm is repeated from the first step again, until there isn't a square with just one possibility. If there aren't any blank squares left, the current board's state is returned as the result. It chooses a blank square and enters a value into it. The process of choosing the blank square, out of all the available blank squares is guided by an analysis algorithm. The value entered into this blank square is chosen from all the possible values that can be entered into the square. A recursive call to this function is initiated with a clone of the current board's state. Note that the current board state now contains the modification done to it at the 4th step (entering one of the possible values). Steps 4 and 5 are carried over until all the possible values in each of the available blank squares are tested with, or until the puzzle gets solved. 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

says that the function mapping our proposition type of to whether or not it's a valid formula is the function . (This function just returns whatever it's given). says that the function mapping the proposition type to whether or not it's a contradiction is the function . Just as well, because takes just one as an argument, and returns a . This is compatible with the contract we laid out earlier in the typeclass definition of . says that the way of comparing two of these propositions (once again, of type here) for logical equivalence is to simply invoke the already existing method . 

initializes the evaluation for the current iteration. The statement called before these is the program's attempt to try and solve the problem purely based on the rule-based procedure, trying to eliminate the set of numbers that can be entered into each square. The function iterates through each bit-field trying to discover the possible elements (values) that can be entered into the blank box. The set of values are then stored as bit fields. This function runs in a loop because, an empty box getting filled by a value might help provide enough information to figure out the value in a different box. Therefore, until such a possibility is ruled-out the function iterates. The above process configures the bit-fields, which would help the function to compute the number of possible elements that can be entered into each square. The next function, which relies on the result of the function, computes the which assigns a floating-point value to each square in the sudoku board following the expression and later the function is called followed by the function, which returns the list of all the empty cells, along with its associated priority value. The function sums the number of possibilities across each row, each column and each cell (the smaller boxes, which must also contain values from 1 to 9) and stores them in an array. The function returns a priority queue, sorted based on the priority value derived from the result provided by the other three functions. The final depth-first search is computed by recursively calling the function, belonging to a locally declared instance of the class. The sets the puzzle board for the next recursive call. Recurrence is brought about by calling the same belonging to a local instance of the same class, declared within the function. In what areas does my code need improvement? And how can I improve the design of my code and algorithm? I wrote this code intending it to be Object oriented. How object oriented is it? (I.e.., is there a better way to structure the same solution) And is there a better algorithm to solve this problem more easily? For complete code, please refer this URL: $URL$ 

What stands out to me is that you initially perform a check against every grade range and insert into the map in the right one. By that point, you've already found which grade is right. But then you initiate another loop to start searching for the grade corresponding to . I think instead, you ought to alter your method to output a enum, and delegate the string handling to another function. I feel that it's better practice to return a Enum from the first method because of the strong typing-- you may want to use this information for other methods besides finding the grade name. In fact, s are particularly nice because you can use a on them. 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

Now the first line says this: is of type , as long as the constraints in what we call the context are met. Here the context is what comes before the , and what it says is that , the type, is a member of the typeclass. This means that we're saying that any type which maps a to any type of is itself an instance of . Why are we doing this? Well, let's start with the simplest case. is an instance of typeclass , because we defined this 'base case' explicitly. Okay, so then is also of typeclass prop, because we said that any type is in class . This gives us the functions which take in one boolean argument and return a boolean. Examples: , , , . (In fact, these are all such functions). How have we defined whether to determine whether one of these functions is ? Our definition says that