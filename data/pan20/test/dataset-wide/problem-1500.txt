Even shorter. Now we can get rid of the before the loop. Also drop the comments, because the code itself is now more clear. 

I'm not that big a fan of this deep nesting, and would prefer to also write a generator which yields the files. But I hope you can continue from here. Also, maybe you should use , that way the file gets closed when the iteration is done. Further remarks. There are certain style guidelines. Keep your imports at the top of the file. 

In general, no, this would not be the fastest approach. However, assuming that all the lines are quite small, I think you won't do better by the 'general' fast approach. You could use . 

(I don't know the proper headers for spam-checkers, but by only using your validator, I would be able to inject headers into an e-mail.) 

This is a bit convoluted: you're performing a lot of queries (depending on how many followers a user has). Ideally you'd like to perform just one query. Also, looks like it will return a queryset, instead of a list. 

Should work just as well, and returns an actual queryset. (I'm not sure if I got the exact syntax right, please look at $URL$ if it does not work). 

These are nested loops, which you can probably not do too much about due to your algorithm. However, what I do notice is that you're a lot of duplicate work. You're creating slices of the list, which could be memory expensive. You're using which does a look-up all the time. You're also computing the all the time ( times) which is expensive. 

Notice how it is non-repeatable? The reason is that the hash values of strings are somewhat randomized. In the case of ties, doesn't really care which value it returns. Hash value randomization is important to prevent a 'hashdos' attack. If you really care to fix it, here's a small recipe: 

Then, using , it will run your the parts prefixed by , and check the output matches. I fixed the example, because the tie-resolution was not done properly in your example. 

In the first call, you're copying exactly half the list. Slicing a list is linear in the length of the resulting slice. So this alone is O(n/2) = O(n). Due to recursion, you get O(n/2 + n/4 + n/8 + ...) (still O(n), though). So your algorithm is actually linear due to copying. However, this is fixable. Instead of slicing storage, pass in offsets (/), calculate . Then recurse using or . However, instead of re-inventing the wheel, why not look at the Python bisect module? $URL$ (I'm intentionally pointing at the source, because I'm going to copy the code, not call the module) 

I left the last part (regarding the cleanup intact), as that's probably numpy specific, and I don't know enough numpy yet. 

(One advice I personally have: When somebody ever asks you to do something for 2 items, try to keep in mind that they will later on think of asking you to do it for 3 items instead, because 'what is just one more'. Keep that in mind when writing algorithms. Sometimes you'll be worse off, but often replacing 2 with ' with ' in your head gives you inspiration for better algorithms. Count "0", "1", "many".) 

Ideally, you'd split out the parsing of the -chunked blocks from the iteration, but this is good enough for now, I think. 

Already a lot clearer, no? Still, I've typed the sign 3 times here. By using the module, I could write: 

Moving files the correct way When doing files, and there is a risk of race conditions, (almost) always use the following pattern: 

Many queries I took a close look at the line you indicated might be troublesome. You have not profiled (I assume), but it looks suspicious because it performs a query in a loop. So basically the code looks like this: 

First of all, the indent is 'wrong' (indenting in Python is traditionally 4 spaces). Second, there's a traditional format for writing examples. It's called doctests. It looks just like the REPL. 

if were to be , it would be off the board. So I don't know why you're testing for that. Too much conditionals? One of the first things to note is that you have a lot of conditions. I've counted 10 top-level conditions on currentTile. Also, looking at their order is as follows: 

Another thing I notice, is that you never use the value of one of the items itself, but always . Why not just replace with , and remove the part? 

In general I would recommend only using for functions that are side-effect free. Another thing I'd like to remark is where you build the . You do it inside the function, building a new class for every task you add. Please move that code outside of the function . 

Note that the cases are quite simple: If I'm not at the bottom, I can move down. If I'm not at the left, I can move to the left. 

Your code is doing too much in the same place. First, it converts the numbers to lists of digits, merges them, and finally builds up an integer again. It would be good to separate this into multiple functions. In pseudo-code: 

What I notice is that it first checks for hit, before checking if the input is valid (in bounds, and not already guessed). I'd suggest cleaning it up as follows: 

Re-using variables Notice how in , the variable has two purposes: It is both a number (due to the ), and a list. Please don't do that. Because the number is unused, we should indicate that to the readers by using the conventional as variable name. 

This makes it easier to add extra parsers, and the is no longer called multiple times. Parsing files The following piece of code is quite suspect. 

In this case, there are 3 valid moves. Moving up gets chosen with a probability of 50%, left, do-nothing and right would each be chosen with probability 16%. In a fair case, I'd expect all three to be called with about 33% probability. Improving? Where to start? When looking at code, there are two ways I consider if it needs improving. Sometimes I try to look inside-out, and sometimes I look at it from a distance and think 'no'. This is the second case. I want to get rid of the huge -tree. To do that, you need to consider what each of the branches is doing. And because all branches differ (a bit), that is actually not that easy for me. Making it more fair. However, thinking inside out is still the way to improve. Because the first thing I want to fix is the unfair distribution and the no-op moves. So let us take the one with the unfair distribution, and try to make it fair. 

(where means: the result is stored in . See how it does does 5 -> 16 -> 8 -> 4 twice, (and 4 -> 2 twice). I don't have a current suggestion for a better algorithm, but please think about it. 

You notice I left 1 comment in. That's because of the number. If you follow the advice below, you can replace that line with 

(Note: I myself prefer using a double underscore instead, but convention is .) Encapsulation Not sure if you are at the level of classes yet, but I'd suggest learning about them. Instead of 

Another thing I'd like to note. actually returns a value. What value? The last value in the list, that is . Let's inline it. 

Now, has a problem, it only works on the same filesystem. So depending on your needs you could do something like: 

And, will take almost no memory at all, because all the values are evaluated just-in-time. The downside is you can not iterate twice (because it is not stored). Continuing in similar fashion: Here I did the same for a couple of the pieces. 

So, if I enter a correct row, but a wrong column, it'll ask again. Without telling me what I did wrong. I'd suggest 

And similar for match2 and match3. However, the real complixity in your implementation lies in the determining of the error message to show. I would suggest building a dictionary mapping the display error to internal errors: 

As an outsider, comments like this make me believe that you are a beginner in Python, or even programming in general. Probably even following a class where the lecturer dictates comments like that. Commenting like this screams 'I know nothing'. However, when I read the code without the comments, it's very readable, and only a few comments remain that are actually necessary. Actually, just two: 

(There are also a lot of conventions on how to phrase a docstring. I won't get into that for now.) Parenthesis in conditional The code says 

The tuple is always the same size, and the same form. So, why not make it a namedtuple? Put the following import at the top of your file: 

This is like an 'early return' (except not in a function, but in the main body of code). Second, you have 

Not sure if the following will be faster, but I'd like to hope so. That is: profile! I see that in the nested if/else, they share code. 

First of all, the function name is too generic. Instead of , you should use or something similar, describing that it calculates the CSS class based on status code. Second, why is this function responsible for getting and parsing the status code? It should be passed directly. Third, what do the conditions mean? The conditions probably represent error conditions. Why not make that clearer by calling a function ? Taking these into account, you'd end up with: 

(Also note: if the user inputs something different from or on the first go, you get a : is referenced before it is assigned because you never enter the loop). 

Ideally, you'd profile it on a line-based manner, seeing where the cost is. But, I might have some suggestions. The following -statement gets run every time the function is called: 

Also, there is a bit of a trouble with race-conditions here, but that's probably easily solvable using transactions and locking. Or, better, use 1 query (which is also faster!) 

Also, I'd like to change the last to have the at the end instead of at the beginning, as it's convention to end a line with a instead of starting one with it. But that's up to you, as it would change the semantics of the script. 

Wow, we saved a few lines of code. If we're lucky, it's also going to gain us some performance. Next, you have . This can be replaced by (as that's how dict containment checking works). Furthermore, can be replaced by . Furthermore, you write followed by . You can simplify this to . 

Also, make sure to add any created object to the after creating, so that you don't incur a database hit for that. Dispatch 

The first branch of the conditional is cleaned up nicely. Let's consider the second branch, most specifically the handling of . You're checking if , and throwing a ValueError otherwise because of an empty stack. What you actually mean is . That's already checked by the other branch, so this condition is superfluous. However, we can't just remove it just yet, because might then throw an IndexError. So, let's continue and see if we get another opportunity to fix it later. In the while loop, we see a . The has a , so we might as well move it outside the loop. (I took the liberty to also remove the temporary variable ). 

There are a few lines between the definition of the operators, and the calculation of the desired result. First suggestion: use instead of 

Naming and describing Ok, with threading out of the way, I'm having a difficult time finding what the application is supposed to do. It does something with an , and each worker with an and an . What are those? The code could be a lot clearer in this regard. Anyway, let us clean things up a bit first, and maybe I can find a pattern to help you improve the algorithm. Performance Checking for integer-valued lists. Let's start looking at . 

Again: profile! But I think it will either make it faster, or not be slower, so you should be good. Adding to or is done, but I don't see any nice way to make that better without losing performance. 

Especially if the file is large, and needs to be transfered over the network, it's good to know what the file is working on. Now, I assume the is now a bug, as the file no longer gets truncated. Assuming we can replace it with instead, we could write: 

First, you get the sentences from . Then, you again get the sentences from , but as many times as there are sentences in . Then, you only use the first item from the second set. 

You're basically asking a question, and then "What is the answer to the question?". Better to just ask the question alone. Instead of writing , you could write or . Another thing of note: the score (I assume that's what you mean with ) gets reset to each time you get a new problem statement, but the score () is only printed at the end of the rounds. That is, you have (pseudo-code) 

Looking at your code, it's clear that it is going to take long to execute. First of all, allocations need to change quite often, and for instance will be calculated often. Far from ideal. As a list: 

Moving same lines out of if Notice how the last two lines always read the same? Let's move them outside the blocks. 

I'm hesitant to do this for the cursor, because that might break things. Why, you ask? Because of the . Before a statement has been made, it is . So we must mimic that. 

or something similar. But this is something you need to decide yourself. Conclusion Great code, but it could use some (very) minor improvements with great benefits: 

A regular expression is overkill for this. Also: only matches at the start. If you actually want to match anywhere, use 

Here, for all the positions on the screen, you're looping over all the drops. Ideally we'd turn that around: 

(my preference is the second). Finally: please use capitalization when writing strings for the end-user. So, instead of , write . (The final space is to make the question look even better when entering the data, but that's merely convention.) After making the changes, I ended up with 

But if equals , the will have been executed, and you won't reach any other lines anyway. So you can just write 

Incorrect algorithm The worst part, I think, is that your code works by trying different ratios, and will miss some geometric sequences. For instance, the sequence 

All these conditions look the same. Let's see if we can simplify it a bit. Let's start by flipping the and branch in . ( becomes ). 

First of all, it's quite long, but there is one thing I would very much like to comment on. If possible, do not use loops when a loop suffices. But there is actually a lot more going on. Let me walk you through a few refactorings I'd like to suggest. First, the code just before the : 

First of all, awesome that you have written tests! However, your checker is a bit verbose on the matching case. It is often considered good practice for automated tests to be as noise-free as possible. Consider the following outputs: 

The advantage: building data_rev.txt only needs to be done when data.txt changes, which is hopefully not that often. 

But now, the whole generator-function is a bit annoying, and I'd like to switch to ... (drumroll) Generator comprehensions Defining lots of separate generator functions can be really annoying, especially when the body of the generator is quite small. There's a solution for that: generator comprehensions. 

Notice how the while and if are now both gone? All because of how already guarantees they are ordered by max-occurence. Code duplication in getting the radius Let's take a look at the inner : 

I'd like to do the same for the , but it's used in the clause. But, it's still at that point, so let's cheat a bit and substitute that by hand.