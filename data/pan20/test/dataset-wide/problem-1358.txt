A user first has to choose between Red, Blue and Green. Upon selecting an option, additional form elements are displayed, depending on the choice. For Blue, a Date and Font are required. Currently, there's no need for a third level, but who knows what the future brings. In order to represent this data, I've come up with the following model (after many attempts). 

The goal is to construct a with a connection that uses an access token. The access token is acquired with ADAL (Active Directory Authentication Library). The problem is that acquiring an access token is an async operation. Luckily, ADAL uses for its async calls, so it should be safe to do sync-over-async without risking deadlocks. Full code is provided below. The focus for this question is on the sync-over-async code and method of registering the , but remarks for the other code are welcome too. Container configuration 

I see that you're reading the from the array as you're enumerating it and writing that at the , presumably to avoid having to get a to swap the two elements: 

This alternative works, if it's a style that you prefer. However, it's iterating the slice twice; once to find the element and once to find the index. To address that I'll use a to iterate over both the elements and the indices at the same time and find the minimum element-index-pair by comparing the elements. Since only the minimum index is needed to swap the elements I'll use tuple destructuring to only reference the once it's found. 

I'll review this in two steps: first the body of and then the higher level structure/architecture. The selection sort implementation Swapping elements First of all, there is a bug (the only one I could find) in the code that swaps two elements that sometimes loses elements while swapping them. The smallest example where I can reproduce this is by sorting which results in , losing the . Looking at this code: 

A picture says more than a thousand words, so here's a mock-up. The actual choices are different, this is just a sample. 

I don't think there are any possible edge cases here, at least some initial tests don't reveal any problem. I think it's short and readable, but readability is often hard to judge when you're the author. Any remarks? 

I understand his argument, but the code is harder to read and there's a higher chance on bugs when doing date/time calculations without using date/time objects. I also can't cast it to a in the query because I'm using LINQ to Entities. Which method is the better one? 

One thing I'm not sure of: is the readonly property necessary for or can I write ? I'm not worried about the tiny chance of multiple calls to the same uncached object causing multiple and I'm also not worried about stale data. The main goal is to cache some informational data that is simply displayed on the screen, instead of retrieving it every request. I've tested this with an expiration of 1 minute and a class that gets on creation, and it worked fine, so I believe the code is bug-free. 

The second one is a bit trickier and highlights some constraints in how can be extended to support other sorting algorithms. To make support any kind of collection, it would be natural to also make it generic over a type that is a Swift collection: 

The first is pretty straightforward to address, by making the struct generic over an type that is constrained to be and by using arrays of that type: 

i.e. if the product id exists in then it should be deleted. The implementation of may have to go through the array of ids but it should in most cases quickly discard an object based on its hash which should make it faster. I also find it more readable than an explicit loop. I'm not sure what the method does in your case but it's not safe to add or remove objects from an array while enumerating it. If that isn't the case for you then your code could can be simplified like this: 

I'm using s for hard-coded choices, so I can make decisions based on the value. s come from the database and do not matter in the programmed decision flows. This works, but I can't help but feel like this is an ugly solution and I'm worried about future modifications. I've never had to make something like this before so I can't make decisions based on past experiences. The UI design is more or less set in stone, unless strong arguments can be made against it. (I'd need to bring them up to the designer and project manager.) 

We have a table with calculated data that groups sales by product, year and month, to provide fast querying for statistics. My colleague argues that the year and month should be two separate fields, because a day is meaningless. I want it as a date field, because using two separate fields leads to awkward code like this 

Other than the minor syntactical difference, this means that the type of is an associated type of the collection being enumerated. This has no benefit for arrays, but will be important if you want to be able to sort other collections. Secondly, since the loop body is only executed when the element at that is smaller than the element at the current I would possibly move the inner if-statement to a where clause: 

Don't worry about the temporary variable. The compiler is going to remove that and it helps with readability. If your delete operation is safe to run concurrently on many objects then it may be slightly faster to run it like this: 

Finding the index of the smallest element I'll make two small syntactical changes to the code that finds the , partly to leverage Swift features but also to prepare the code to be generic (which I'll discuss later). First, I'd like to describe what this loop is doing as "iterating through the indices of the slice of elements starting from the current index". In code I'd translate that into: