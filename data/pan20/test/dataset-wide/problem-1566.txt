(If you use a trait rather than abstract class, you also have the choice of making some functions concrete in the parent trait). Option 1 is the functional approach as seen in functional languages which don't offer OO. I've written tree types in Haskell code and that's just how it is done there. Option 2 is more OO (pattern matching goes away because each case class knows how to deal with itself) while still being good functional code if you do it right. Option 2 is the way most functions in the Scala collections library are done. Ironically, your function is very much Option 1 style despite the fact that you put it into the class. It could be moved into the companion object with almost no modification, because it doesn't use polymorphism properly. Since I have already given an example of how walkTree would look in Option 1 style (which is how your code is effectively done), here's how some simple functions would be done Option 2 stylee: 

Applies the sum function to the contents of a list. So my first line of code takes the list returned by largest2, squares each member of the list and returns the result. Now, what you want to do is find the largest of two. Even if you don't think of a nice way to do this, your code would be cleaner if you just output the two largest and then give it to my first line of code above and it will be cleaner than what you have. But here is a simple way to find the biggest two of three. Firstly, assume you have a function max which finds the largest in a list. It's actually part of the standard Scheme library but it is not hard to write if you want to write one yourself (or if your tutor wants you to write one yourself). Either way, this will give you the two highest of three numbers: 

See how this works with the actual class hierarchy to build comprehensive tree functions simply and recursively? It should be fairly obvious how you could add depth or size methods. You don't need that wrapper class. What I do recommend is 

Done. Annoyed that the final result is in reverse order? Reversing one final list is cheap compared to appending to each list in the map, every time. Note that you can dispense with having to manage the index-accumulator by folding over 

I used the same variable name in both groupBy and map. Those are two separate closures so can reuse the same single-item name. I placed spaces around the operators. Scala can be dense enough (and also permits non-alphanumeric characters in variable and function names) without more density. 

Meaningless output Your function as written does not seem useful. There is no way to assign meaning to its output for two principal reasons. 1. Non-matching sequences reduced to single item lists As @janos pointed out in his comments, any sequence of items which fail the predicate will be transformed into a sequence of single-item lists in the function's output. While this does mean that any list in the output with size > 2 will contain only matching items, there is no way to tell whether a list of size 1 contains matching items or non-matching ones (without reapplying the predicate to each). If this were fixed so that non-matching sequences were not broken down, then the output would be alternating matching/non-matching sequences, which would be marginally more useful. Except that... 2. Nil in (Nil, _) output from span is discarded If returns - showing that not even the first element satisfies the predicate - you discard that . This means we cannot know whether the first list in the output matches the predicate (without reapplying the predicate). This means that, regardless of whether the problem in point 1 were fixed, gives the same output as Possible Improvements Minor: still returning List[Iterable[T]] If we stick to your basic design, returning , but 

also evaluates to . So any invalid branch will not return a list of positions and not become part of the final list. So the final list can only contain valid solutions - if there are any. Haskell allows n-queens to be solved in a very compact and expressive fashion but still be performant. Although it appears to require a huge number of combinations to be assessed, invalid branches are discarded immediately. So this means that my solution is also brute force. I just let lazy Haskell not bother being brutal for no gain. Placing queens recursively, filtering out any threatened squares at each step, is also much simpler than your "build it all, examine every solution" approach. Here's how could be done: 

You may balk at that last point but modifying the data held at any one node is a dangerous and pointless thing to do. The way binary trees work, it doesn't even make sense. When adding a value, the only places you would want to change left or right is at the node where you insert the value in place of an empty tree (possibly having to move the left branch to the right branch, to preserve ordering). Adding a value to an immutable tree is only marginally more complicated than to a mutable one and much safer. Also, you regain the option of variance (if you want it, although I recommend against). My final recommendation: throw away that isBST/isValid method. It's pointless... That's not an implementation Nothing in your code actually implements a binary tree. All you've done is provide a shell into which data has to be manually inserted, with a validation method to check whether the manually-constructed tree looks like a binary tree. But the rules for adding values to an ordered binary tree are simple (OK, more complex if it's a balanced tree). Your type should know how to do that. If you think about it, it shouldn't be hard to create an add method along the same lines as isValid. I'll start it off for you 

The functional version is also only 5 lines long. If you really do not need those functions elsewhere, you can move them inside. Since they are only used once, you could even make one or both of them anonymous lambda functions. 

You might be overcomplicating a bit by reaching further than you need into builder mechanics. If you rewrite the signature of to 

where xs is obviously the smaller list (if both are not the same size) But if you filter the larger list and then create a map, you are traversing that list twice, so not saving much work. one way to only traverse the larger list once would be to fall back to mutability, something like 

This is not an Enumeration and you have not called nextElement(). This is not an appropriate exception sort() should really take a list as a parameter and return a sorted list. Give it a list as a parameter; if a null is passed, Java will do you a nice NullPointerException, free of charge. If the given list is simply empty, return an empty list. Being asked to sort an empty list is not an exceptional error situation. It's no more an error than being asked to sort a list with 1 element, which you do show you can do. Which brings me to the more important stuff... Method and object conflated and confused. You've combined a sorting algorithm with the (hand-rolled) list to be sorted. It would be better to have a properly usable list class and either a mergeSort method on that class or a static helper class with a MergeSort method that can act on any list object. Then you could create a list, examine it to show that it was a well-functioning and populated list, create a mergeSort()-ed version, check that this was a valid list, that it still had all the right elements (none missing, none added or substituted) and that they were in the desired order. You'd have something useful you could do more with. List object cannot be tested/examined. This is part of the problem created by the previous issue. There's no way to get at the list data. You print it out on the screen, but it's inaccessible to the rest of your code. What use was the sort? Did it even work? How is this validated except by the naked eye? Since you don't print the unsorted version out on the screen, how does the viewer know you did anything? Make the list fully usable. Provide a way to traverse and inspect it. Then your code can verify the sort (and do something useful with the sorted data afterwards, if you like). Printing directly from within the merge class. Don't do this. Have your class methods return useful values which can be inspected and tested. Print out the results in your main method if you want, but don't litter your classes with println statements. Final, what? What do you think you are gaining with those final keywords? Those local variables are going to evaporate when that tiny method returns, so what have you achieved? I should go on to examine the actual sorting algorithm but I think I'll leave that to somebody else - it's late and I'm tired.