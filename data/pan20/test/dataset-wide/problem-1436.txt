If you feel it's important to write the code so as to start with an empty list and extend it, you could instead use 

Generally speaking, buffering is good for performance, so it's better to write newline characters rather than inserting when you don't actually need flushes to happen. As a bonus, they're less typing and usually easier to read. Of course, I/O performance is basically irrelevant here because the human delay far outweighs any other concern — but it's good to get in the habit of writing what you mean early on. Thus, the above code snippet demonstrates the general pattern: I use newline characters to write newlines, and I do something to flush the stream at the point I want to ensure that all of the output has been written. Using to do the flush isn't an option here, if I want the flush to happen at the right place! 

I have a few observations from looking at your code. Some of them are related to the PHP code, some of them are related to the SQL. Some of these observations may also help you resolve some of the perceived bugginess of your code. Let's start with the PHP: Use only one database abstraction per database type I see that you are using three different database abstractions to access two databases. I would try to bring that down to two: one for your DB2 database, and one for your MySQL database. I am guessing that your code is using both PDO and mysqli against the MySQL database. Choose one and use that. If you need multiple connections to a single database, you can do that with a single abstraction. Use different connection handles or objects to differentiate between your connections, not different database abstractions. Use functions to structure your code It could be that your code is using multiple database abstractions to keep your MySQL connections separate. A large monolithic block of code can be hard to visualize all at once, particularly if it is doing a lot of stuff. Break things up into functions that just do a single thing, then assemble the functions into a main procedure. For example: 

In the source code, you can collapse a lot of the output statements to improve readability and so that they take up less vertical space. For example, 

You are using a reserved name due to the double underscore; you should adjust your naming convention for header guards (e.g. only use a single trailing underscore). The relevant passage from the C++11 standard, 17.6.4.3.2 , says 

The usual way to implement the algorithm you're using (the sieve of Eratosthenes to find all primes up to a chosen bound) is to make an array of boolean values, so that means is in the list, and means that is not in the list. The point is that removing an element from the list only costs time, so it can be done much faster than erasing an element in the middle of the list. (and also, you don't even have to bother checking if the element is in the list before you remove it) 

I would say that if you are looking for a code review of code written right now, you should be using modern practices. I can excuse the lack of as it appeared with v7.3 (PTF'd back to v7.1). But you still should be using free form H, F, and D specs. Also ditch the O specs for print files as those do not have a free form equivalent. Also realize that by sticking with SEU, you are not able to use any advances in RPG or SQL put forth since v6.1 (about 10 years) without turning off syntax checking. So that is a big issue as well. On to style, I have just a few points here: 

One issue is that your function is four functions in one. The problem is that they are four unrelated functions — yes, they all have the job of displaying results, but: 

I'm going to focus on implementing the recursion. First, let's avoid the globals. The easiest way is to keep the same structure, but move it into a local namespace: 

Use the memory management tools the standard gives you In particular, should be of type , not . The memory management you are doing is a standard and common thing... and also well-known to be an extremely common place for programmer errors. Use the right tool for this job, so that it's easier to write code, less likely to have errors, and more obvious to the reader what your implicit intentions are. (and yes, you do have errors — for example, the way you wrote the code requires a destructor to deallocate the memory, and you don't have one!) You have a const correctness error is a const member, but it returns a pointer that would allow the user to modify the contents of the string! If you are going to have this function, you should have two variants 

Use named indicators rather than numeric indicators. Even with display files. The keyword should be used to name your indicators. Otherwise you are going to have to keep going back to the display file to determine what all those numeric indicators mean. It is a lot more readable if you can write something like rather than . Use file references. That is activated by the keyword on the file spec. This way you can keep your file activity seperate by using a qualifier rather than by forcing yourself to rename fields or set prefixes. This allows you to read and write into data structures and assign values by name (using ). Break SQL out into it's own procedure, it just clutters the logic of the routine that contains it. Because local variables and parameters are scoped to the sub-procedure, the does need to be in the same sub-procedure as it's associated , but keep everything else separate. Don't mix and match command key processing. In your DDS you specify but . You are also assigning indicators 01 - 03 to subfile control keywords. So F3 must be detected by the AID byte in the file information data structure or the old K indicaotrs, but F5 can be detected either by the AID byte or , and - don't refer to Function keys. This will be initially confusing to anyone coming behind you. Either use the AID byte exclusively, or reserve indicators 01 - 24 for function keys F1 - F24. Once you start using on your display files, the K indicators will not be usable. Not a big deal, the letters aren't contiguous anyway (there are gaps in the sequence, do you know off the top of your head where they are)? Finally, your life will be made a bit easier by using a message subfile rather than a standard subfile for error messages. 

While some would advicate relying on the implicit flushes coming from being tied to , my own observations are that: 

Note the use of and for yielding results. Using generators has a number of advantages including: you get to see results as they're created, you can stop iterating when you're happy with a result, rather than having to wait for the entire recursion to finish, you don't waste memory/time creating a list of all the results. Generators take a little bit of time to get used to, but they're well worth it, and should often be preferred to returning lists of results. Finally, one last neat trick; the general pattern of "make a change ... do stuff... undo the change" can be error prone; it can be easy to forget to undo the change, or an odd code path (e.g. an exception) skips the change. The other answers suggest making copies; however, backtracking algorithms like this can often suffer massive performance penalties from such a change, so it's worth knowing a pattern that mitigates this problem without introducing copies. We can use a context manager to do this automatically, such as below. (this post is not meant to be a tutorial on context managers) 

The GROUP BY Using the wrong array to provide parameters to your PDO prepared statement because your big chunk of code is unwieldy. 

This will be easier to understand, and the names of the functions helps document the code. Let's look at the SQL: Use prepared statements and parameter markers as much as possible rather than concatenation to build your SQL statements. This will reduce your susceptibility to injection attacks. This is particularly important when concatenating strings together as it is the strings that can contain raw SQL which can change your statement when concatenated together. This includes concatenation by variable replacement as you are doing in several places. This is not as big a deal if you are concatenating in values read from numeric database fields, but you still need to make sure that you don't inadvertently replace numeric values with strings. Since PHP is a dynamically typed language, this is a distinct possibility, and needs to guarded against. Don't use unless you are aggregating values. There is a group by in your DB2 Query which I can only assume is being used to remove duplicates from the result set. If you are getting duplicates, use DISTINCT instead. It is more semantically correct. When I see a GROUP BY without aggregation terms, I wonder why the GROUP BY is there, but DISTINCT tells me that you only want to see unique rows. Note that your group by could still be providing duplicate rows since there are more terms in the GROUP BY clause than there are in your SELECT clause. Things that could be causing bugginess: