Use the enumerate function. It lets you use a foreach loop and get the indexes at the same time try: cm = next(v for v in cl if v > om) + len(mn[1]) add a line like: start_comment, end_comment = mn, that way you can avoid the indexes are your code will be clearer. 

Use sys.exit to indicate success or failure of the program. file is a builtin python function, its best to avoid naming your variables the same thing. 

Untested, and probably not quite correct. I think it may actually apply operations backwards, but you should be easily able to flip that. 

Use for source, dest, value in row: li.append(float(source), float(dest), float(value)) Do you really want floats? Are the source and destination really floats or are they ints? 

Don't use variable names like a, a one letter variable name is terrible waste of information capacity. 

Why not use the string search functions rather then having built a newline list? Also, if you need to treat the end of input as a newline, put that in when you create the list not in an exception handler. 

I recommend putting the comment on a seperate line from the if. Otherwise it tends to wrap off the side of the screen and that's annoying. Also, iterate over the container, not the indexes. Use something like for source, dest in edges: 

should not be static. It's one thing to maintain a static instance to implement a singleton, but that object should interact with its state using normal instance variables. And you may as well initialize it in its declaration instead of the constructor. The service should create the thread itself instead of creating it in to make it self-contained. This allows another implementation to use a thread pool for parallel directory creation and easier testing. is not thread-safe and could allow two or more instances to be created. Use a blocking queue, so you don't have to poll and sleep. The thread will be put to sleep if the queue is empty and be awoken once a new directory is added to the queue. This will shrink your run loop to a few lines and allow you to rely on the well-tested thread-management in . 

First, serialize in parallel, no pun intended. Each thread can perform its own object serialization without making the other threads wait. Here's how would look: 

Going Faster First, creating a temporary table out of would be huge. Technically, MySQL should be smart enough to do this on its own, and being only three short columns should allow it to fit easily in RAM. However, I've found that the simplest of derived tables can often cause it to go off the rails. I will confess that I don't have a lot of MySQL tuning experience. Second, this would be pretty easy in PHP. Load the results of into an array and use two passes to calculate the minimum, filtered, and total completes. The latter two values can be calculated together during the second pass. Since you probably need these values in PHP in the end, the only real cost is slurping in all that data which again isn't very much here. If you got tricky, you could even probably do it with a single pass while streaming the results from MySQL so you wouldn't have to store the entire derived table in RAM at once. For each condition, you only need to know a) the minimum subcondition completes, b) how many subconditions have that minimum value, and c) how many subconditions are over that minimum. The total filtered completes for that condition equals 

and discovered that your code fails for . This is just bad form. The 'assignment' gave a whole bunch of positive and negative test cases, but you only chose to test the positive ones. That counts as 'half-a-job' when testing is concerned. It took me a few minutes to copy/paste the tests in and found what should be a 'fail-the-assignment' condition. Then I looked at your algorithm and figured it was 'failing' early tests too early... let me try to explain.... consider the following: 

That way, people clicking through will have the default values populated, and will possibly get a better experience. Display Name In SEDE you can sort the data based on the columns. The [User Link] column does not sort by the name though, it sorts by the URL for the user, which, in essence, does an alphabetic sort of the user-id because that is where the URL starts to change.... Add the Display Name in as a result column as well as the so people can sort the data alphabetically.... (because people like to know where they are...). Ranking Consider adding a RANK column as well, so people an sort by other columns, and still see their ranking. SQL you have already seen inconsistencies in the capitalization of the keywords... You have chosen upper-case, which is fine, but then these should all be upper-case: 

Add the new section to the enclosing section. BTW, under what condition does not create a new section? I can see it looks for a section with the same name, but is that supposed/allowed to happen? Finally, run the new section. 

The major problem here is using imprecise floating point values. Not only does it slow the entire process (minor quibble), but it will produce incorrect results once the values pass the integral cutoff of the field width. If you truly want to allow calculations approaching infinity (or what? 24 bits?) you need to switch to which can model "exact" integers of any size. 

Without seeing how the numbers and styles are used, I may have gotten the above wrong. What exactly does hold? What is in each ? 

Blech! :) You could solve the problem and expose a cleaner API by providing type-specific accessors. 

You can avoid byte shuffling by inserting a for the size before serializing instead of performing an insertion after calculating the size. The key is that "write entry" should be an atomic "append byte buffer to file" operation which again I believe NIO provides. Here are some random notes I made while reading the code: 

Create a list with a single element, putting that in a set, simply to call issubet is silly. Use Edges[i][j][1] in firstgen. 

No explanation is given for what you are putting inside found. I have no idea what the return value means. return found General thoughts: The code is complicated, it really should be split up into a lot of functions. Rather then all that code matching different types of comments and strings, have a set of ignore regexes. The regex should match an entire comment or string which can then be removed. Your code builds lists of everything which would only serve to complicate what is going on. Lists can be great, but they aren't the solution to every problem. My rewrite of your code: (I didn't start with your code, but it should support the same features:) 

That way each piece is self-contained. FlipACoin just flips the coin, it doesn't keep track of counting. And TryGetThreeHeads() only worries about trying to flip three heads not the process of flipping each coin. 

You declare draw far away from where it used. Just assign to it in the scope its used in. Multiple assignments on one lined is also frowned upon in python. 

That expression says "Match any 'g' that has no 'g' before it, and no 'g' after it. Then, you can use it as: 

Brythan has given a good review of the code, but I am going to disagree with his analysis of the complexity.... or, at least part of his analysis. 'Complexity' is an indication of how the algorithm scales with respect to 'size'. How much additional time is required to compute a solution if the input data is X times larger. An algorithm with \$O(n)\$ time complexity, that runs in T seconds with X data, will require 2T seconds to run with 2X data. How does this relate to your problem? Well, it doesn't. Not at all. Your inputs are not changing at all. The solution to the problem "the first number that has 500 divisors" results in a number somewhat larger than 75,000,000. That is somewhat after the 12-thousandth triangle number. So, in this case, you are looping through 12,000 times, and that's the same regardless of whether you use your old, or your new method. The question is, why is the new one so much faster? Well, that's simple.... As your numbers become reasonably large, say, around 70,000,000, you are, in your old loop, going to loop 70,000,000 times. In the new code, you are going to loop less than 8,500 times. Now, that is..... about 10,000 times faster. If you were to take the method itself as an isolated system, the performance complexity of the original code was \$O(n)\$ where is the input number. for the new algorithm, the complexity is \$O(\sqrt{n})\$. Since 'n' is, for the most part, a very large number, the difference between \$n\$ and \$\sqrt{n}\$ is huge. It does not surprise me that the second solution is thousands of times faster, for the large values you are factoring. 

If you don't mind formatting an empty message that won't be sent, you can extract the format/check/send logic to yet another function. 

From my reading of the documentation, your code looks like it should handle parallel usage. Each list of URLs is owned by exactly one spliterator while they all share the thread-safe set of scraped URLs. If you're concerned about performance, you may want to switch to , but is sufficient for example code. I believe you can add two more characteristics: 

You're performing a breadth-first search of all possible paths through the maze which is what I ended up going with. By scheduling timer events you're essentially queueing up cells. I did the same but with an actual queue of cells to visit. This is the core of my Scala version. 

Why are and using ? They are already being called with the correct context, and rebinding to the same context changes nothing. Edit: Instead of using plain functions to implement "private methods", promote them to proper object methods and mark them private using JSDoc. This will save you those extra calls to . 

Extract an abstract base class that implements the better-named interface by moving all code that's duplicated between and (all but the table and column names). This is a major step in the DRY direction that will simplify your code. I won't attempt to produce this code on my phone, but the key is for those concrete implementations to contain only unique code. The end result will be with a simple one-line constructor. Another improvement would be to decouple reading the table contents from picking random words by splitting these functions between that reads words from a database table into an array and that provides various ways to consume it, including choosing random words and subsets. 

OK, now for the real issue, the storage of the Enums in a convenient-to-access system... First, I recommend that you change your Enum to have two parameters in the constructor: 

and your calling class should be changed to have a instance instead of a instance, and, well, that's it. Oh, and since your RemListView class is now empty, unless you have other stuff in there, you may as well delete the class and use NumberPicker directly. 

In Java, common code conventions are useful for communicating your code with others, and for preventing bugs from creeping in later. In your case, there are two things you have done which are very unconventional. The first is you have a class called with a lower-case name. Java classes should be "CamelCase", and thus, should start with an upper-case letter. The other item, is you have called it , and that means your class, and its constructor, conflict with the same-named method that is called that Java calls when your class is the entry point. In essence, is a really, really bad name for your class. A name like "WordGuesser" would help a lot. Here's your code with that name: 

Use references that are unique and not related to the name. I would consider using the attribute name 'id' because that has some advantages: 

This version won't modify the original array passed to . How does this differ from writing your own loop using ? Mostly in style. You'll pay a minor performance penalty switching between system and user space (once for each call to the callback), but you won't notice this unless is huge. It looks much nicer when the callback returns an immediate expression instead of using one statement to modify and another to return. You can do this here using . In fact, this also allows you to refactor into a generic helper function. 

I find it's best to leave the type of collection out of the name. First, it makes it easier to change later. And second, you can see it and in any IDE hover over the method to see the required type. I might even drop the suffix from the last two above since this method only deals with intervals. Finally, there's no reason this method couldn't accept a list. It should respond just as it does when the list is empty: return an empty set. 

Here's a more traditional (heavyweight) OOP treatment of the problem. Note that it produces duplicates due to permutations. The fix is to change into or manually remove duplicates at the end. Both classes are immutable to make the code safer. You could also clean some of it up a bit by using Guava's collection helper methods. 

The value of the above changes is that now you have consistency in the use of gates and wires. Talking wires, your initialization of your various wires would be considered redundant in go - in go, it is idiomatic to ignore the specification of zero-values. The zero-value of a boolean is , so specifying it is wrong. Your code: 

That's a bit complciated... it has an auto-closable feature which may, or may not close the scanner when it is dismissed. The point, though, is that it lasts for the length of the program, and it is reusable. It has methods which prompt for user input, and interprets the response. The method is important because it is what allows the main program loop to be super-simple: 

While the additional checks may slow down valid numbers slightly, it drastically improves the performance of handling invalid numbers in the majority of the cases, and the trade-off is, in my experience more than worth it. 

get a String to analyze ("bananas"). do a 'nested' loop (i,j) to find every possible sub-word in it for each sub-word, inject it in to the possible node tree 1 character at a time. 

it is a pain, but you benefit from getting all the information in the stack trace. Currently you are losing some. The only other issue I see is the extension of the AsyncTask. You have re-implemented the methods: