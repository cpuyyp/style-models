You don't need to maintain separately, it is always , so can be simply declared inside the loop's body. Your boundaries check inside the loop body is redundant, loop condition alone is enough. You're probably performing too many int-to-Integer and back conversions. Even more, the question deals with arrays, you don't need to pre-convert the argument into a list. Accept, process and return an array of plain ints. 

Your is very suboptimal in few aspects. I. There is no sense to check for prime factors of a number ABOVE the integral part of that number's square root. II. Aside from 2, all other prime factors of a number are odd (if any), so you only need to check at most sqrt(n)/2 numbers. III. And your recursion does not look tail-optimizable, so you'll need to either reshape it so that you get a single tail-call (if your CL implementation is aware of tail optimizations), or transform it into an iterative construct (which, I believe, are highly available in CL, much more than in Scheme). After all, you don't need to obtain a list of ALL prime factors of a number to say it's composite; and even less do you need to keep a stack frame per EACH number less that it. is less sensitive (all the recursive calls are either in a tail context, or in a tail modulo cons-one), but still you don't need to check every number less than x (remember, only up to sqrt(x) and only half of them). Additionally, concerning , doesn't CL standard library feature a primitive predicate to compare against zero, like in Scheme? 

Source Code Structure As already mentioned, only define one class per file. I like it, that you encapsulate the fields of your classes. However, you have many static functions, which basically degrades your classes to some kind of namespaces. There is nothing wrong with static functions, but be careful not to overuse them. Advice #6: Don't overuse static functions (and statics in general) As you mentioned, and is suboptimal. You have pretty much three options: 

Project Structure Currently, you have a few php files in your root directory and a few php files in your PHP directory. On a first glance, it seems, that the PHP directory contains your framework and the root folder contains the views, which use this framework. If that's the case, make it obvious. Advice #1: Give your framework a name and rename the folder accordingly. That way, you will have an easier time to find the place you are looking for. Which leads to the next problem: Your core.php contains multiple class definitions. If you continue doing this, your file will grow exponentially and it will take you a long time to find the line you want to modify. Advice #2: Put each php class in a separate file. The next step is to use namespaces to further structure your classes and files. It might be more difficult to begin with, but will help you in the long run. Additionally you might want to look into autoload. Used correctly, this should solve your troubles with and . Advice #3: Use Namespaces and autoload Another possible improvement are the files in your root directory. Currently you probably access each file directly via www.whatev.er/viewPost.php or www.whatev.er/createPost.php. I highly recommend to take a look at something like a controller/routing mechanism and only use ONE file (index.php) to access your website. Take a look at .htaccess and URL Rewriting. This is actually a pretty powerful and extensive technique. So just a short explanation: Every (nearly every) call to your website is redirected to your index.php. So www.whatev.er/blub/bla/1234 or www.whatev.er/post/create all call your index.php. In the index file, you can parse the requested uri and call the appropriate actions. Advice #4: Use .htaccess and URL Rewriting and only one file as an entry point to your website. Advice #5: Use some kind of controller/routing mechanism to handle actions depending on your route. 

That brings us to naming. Lists are usually called (for es). That's just a minor nitpick, although it would make place for as the first element of the accumulator. Either way, the constraint should not be necessary. might even lead to a wrong if all other values are lesser, e.g. 

But we're stopping short before the finish line. As I said, you just want to change the memory in your program, and maybe, maybe want to show or take some text. So 's correct type would be: 

If is going to be put in the list, it will always be prime. Note that one can improve this function further, but that's left as an exercise. Exercises 

Keep in mind that that function won't work with if they are a array. To put things together So, was your algorithm correct? For positive numbers, the answer is yes. But as soon as the user is allowed to input negative numbers, the answer was "no". However, the greatest weak point of your program is that it is a single large function. You don't need to split it into too small functions, but the actual counting algorithm kind of gets lost in the noise of the rest. So for a future exercise, try to write 

Use for canonical implementations If you use you don't have to implement both variants yourself. Consider generics for your structs (and traits) Your only supports . However, we can imagine a situation where we want to store , for example for GPU calculation. We can use also in that circumstance if we make it generic. Add documentation and examples Since you're working on a reusable library you want to have some documentation at hand. Furthermore, examples in your documentation are automatically checked with .