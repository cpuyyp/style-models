With no indexes or keys, you can't defragment it normally. You can add/drop a clustered index, or do something like this 

However, I would consider doing this in my report layer (say in SSRS): do you need all levels of grouping at the same time? 

You can use SUSER_ID which will give you the SID from sys.server_principals regardless of metadata visibility Also note that syslogins has been deprecated since SQL Server 2005 

You are running RTM (10.50.1600.1): the latest patch is SP2 + CU3 (10.50.4266) These include patches like KB 2498786 

Permissions error, reported as an (old) MySQL bug Check out the permissions bit in the MySQL install docs 

There is a whitepaper too. See the section "Maintaining Statistics in SQL Server 2008" where there are some conditions that sound like affect you. Example: 

varchar doesn't support : unicode only This includes the literal which is varchar too Collation here doesn't matter: this is sorting and comparison only never seen this before! Some more SQL to use your table 

Note: GUIDs make poor clustering keys In this case, with the surrogate column, the table has 2 candidate keys: 

You've hit the nail on the head: copy the files. I've used this to good effect. I'd say you have to define "cheap" to include investment of time to prepare a solution that doesn't involve xcopy 

If you do want to involve the previous Payment meaning in a query then you use JOIN to get the table whose meaning is the AND of the simpler meanings. PS You don't need to declare a FK because it will be enforced by the combination of FKs in Payment and Enrollment. 

A query is typically like . You could use an expression like the formula part of a query if you consider any free variables/attributes to be implicitly universally quantified. (This is also sufficient.) 

The general approach of the SQL standard is that many things not imposed by chosen semantics are left to the vendor to optimize or specify. Under the chosen policy users choose names when they care what they are. SELECT without FROM isn't standard SQL either. MySQL chooses to use the expression that evaluated to a column's value as its name. Those PostgreSQL "?column?"s aren't the column names, they are strings output instead of the column names. If the system defaults to internal unique names then clashes are avoided compared to defaulting to patterned names. In your example you could have selected "column1" but with your expected behaviour you'd need "t2.column1". Ultimately, they just chose a certain design for the language. And even where people leave a rationale, engineering and ergonomics are about pragmatic timely tradeoffs where one decision cannot necessarily be justified as "best". 

Arguably there is no such concept as a backup strategy: you have a restore strategy because this determines how long until you are back in operation*. All strategies require a full backup to base any subsequent restores of differential and/or log backups. In practice, you can have a full backup from 6 months ago with 15 minute log backups: however you have to apply every log backup from the last full. As a random example, one scenario could be full weekly, differential daily, log 15 minutes. The backup interval determines how much data you'll lose in the worst case: 15 min log backups gives you a data loss between 1 second and 14 mins 59 secs, average 7.5 minutes. Is this acceptable? Log shipping is warm standby with manual failover: it isn't backup but a high availability option. 

The safest way for SQL Server in this case would be to use standard constraints such as unique and foreign keys. I can't see why you check the folders table for a constraint on the files table though Edit: to prevent a file and a folder having the same name in a given parent folder only, use an indexed view. Duplicate files or duplicate folders requires table level uniqueness. 

There should be a table for every box, ie entity type/class, and every diamond, ie relationship type/class. There should be a column for every oval, ie attribute/property. Each line from a diamond to a box is indicates a foreign key. Relationship PKs are composite and consist of FK columns to associated/participant/referenced entity types. 

Relational calculus is a notation for expressing relation values in terms of given named relations and sometimes constants. So is relational algebra. A constraint is an expression making a statement about one or more relation values. But such a statement is not relation-valued, so you can't express it in relation-valued notation alone. (So you need to ask what exactly is wanted.) You have to have operators returning equality of relations, or whether a relation is empty, etc. (Either of those two is sufficient.) 

That has a "for-all for which there-exists", just like my solution. But your proposed answer 2 has a "there-exists for which for-all": 

Natural join "automatically" joins on equality of common columns, but you should only write that if that's what you want based on table meanings and your desied result. There's no "automatically" knowing how two tables "should" be joined or in any other way any table "should" appear in a query. We do not need to know constraints to query. Their presence just means the inputs may be limited and, consequently, the output may be too. You could define some kind of join_on_fk_to_pk operator that "automatically" joins per declared constraints; but if you want the meaning of the query to stay the same if only constraints change but not table meanings then you'd have to change that query to not use the new declared constaints. Just giving the query you want using join & conditions already leaves the meaning the same despite any constraint changes. What constraints hold (including PKs, FKs, UNIQUE & CHECK) don't affect what tables mean. Of course, if the table meanings change then the contraints might change. But if the constraints change it doesn't mean that queries should change. One does not need to know constraints to query. Knowing about constraints means we can use further expressions that without the constraint holding wouldn't return the same answer. Eg expecting via UNIQUE that a table has one row, so we can use it as a scalar. These queries can break if the constraint was assumed but not declared. But declaring a constraint that the query didn't assume cannot break it. Is there any rule of thumb to construct SQL query from a human-readable description? 

I've only seen it once with an bad app that had badly indexed heaps and had heavy ETL.This was rubbish and luckily not mine. Otherwise, there is no reason. If you are getting statistics updates at inappropriate times then it means you are doing incorrect index/stats maintenance or have massive deletes/loads that hit the threshold. With SQL Server 2005+ you can defer the stats update anyway. See "When to Use Synchronous or Asynchronous Statistics Updates" It'd be interesting to see what article they've followed or read about to make this choice... 

Basically impossible for desktop clients. Security when you connect to the database doesn't care about what client is used, SSMS is just another client. Every PC with Office installed since Office 95 at least has msqry32.exe which is a client. You have the ODBC Control Panel item too. Note: the APP_NAME() function in SQL Server returns what is in the Connection String which can be set with anything. 

Do both your Dev and Prod link to the same Navision DB? Compare the rows in sys.servers, especially the column Is the linked server via an ODBC/DSN or is it simple "SQL Server"? If ODBC then are settings the same in the DNS? 

That asks for tuples P where there is an offer S1 where [P's sid is S1's sid and for all Items S1's iid is that item's iid]. I hope you can see that this involves a single iid being the same as all the ones in Item, not what you want. Your answer 1 

A FD (functional dependency) X -> Z is transitive when there exists a Y such that X -> Y AND Y -> Z AND NOT Y -> X. (X, Y & Z are attribute sets.) There can be lots of X, Y & Zs where X -> Y AND Y -> Z but X -> Z is not transitive because Y -> X. Eg this happens whenever X and Y are CKs (candidate keys). (Because CKs functionally determine all attributes--each determines the other and Z.) And there can be lots of transitive FDs. Eg this happens whenever there is a FD whose attributes are non-prime. (Because a CK determines that FD's determinant which itself doesn't determine the CK--if it did then it would be a CK, which with non-prime attributes it isn't.) The FDs among all those ones that are important for normalization are transitive FDs of non-prime attributes on CKs when a relation is in 2NF. Because it is always possible to losslessly decompose such a relation to components free of them, ie in 3NF. 

As far as my quick and dirty tests show (using ALTER TABLE and ALTER INDEX), no The setting is captured at CREATE time. 

rights allow the use of things like and the stored procs which can affect the underlying OS, but it depends on the service account used If you limit the service account permissions (eg not local system, not local admin and certainly not domain admin) then it's pretty much OK. The SQL installer limits the permissions of the service account during install, of course this assumes you don't escalate permissions yourself. 

Do not store a CSV in a column: this is bad practice, can't enforce data integrity, can't search it efficiently, has no meaning etc Note: A column called "ID" is very ambiguous so this is one case where you prefix with the table name 

A subquery is evaluated once if possible. I can't recall what the "feature" is called (folding?) sorry. The same applies to GETDATE and RAND functions. NEWID is evaluated row by row because it in intrinsically a random value and should never generate the same value twice. The usual techniques are to use use NEWID as input to CHECKSUM or as a seed to RAND For random values per row: 

"Y can be determined by X" is not clear. "X maps to one and only one Y" is not clear. You are not clearly saying what a FD is or what it means to functionally determine in R. For attribute sets X & Y, a FD is an expression of the form "X -> Y". For attribute set S and attribute A, "S -> A" is another way of saying "S -> {A}" and "A -> S" is another way of saying "{A} -> S". "FD 'X -> Y' holds in R" and "X -> Y in R" and "X functionally determines Y in R" are ways of saying "all the tuples with the same subtuple value for the attributes of X have the same subtuple value for the attributes of Y in R". "X is a superkey of R" is another way of saying "X functionally determines every attribute in R". Your question seems to be, does X -> Y in R imply that X a is superkey of R. No, it doesn't. 

If there are no offers and some stores then every store offers every item. But since there are no offers, it's false that . No Ps make that true. So this is {}. So this is not the answer. (Your answer 1 may be modified from a textbook answer expressed by Codd's original relational division operator. But so dividing Offers by Items doesn't actually return tuples s where . It returns rows where . So the answer is not expressed by Offers/Items.) (Indeed 2 has an extra ∃ compared to your natural language description and my answer, but it's the outer ∃. So your solution 1 is in that way reminiscent of the correct answer.) 

One file per filegroup, one file per volume. So a partition read/write goes to one volume: which is one reason to partition. Otherwise, you are simply using all 4 drives all the time. So why bother with partitioning I personally don't like multiple files per filegroup (except tempdb of course). I assume "4 drives" means 4 discrete SAN LUNs or RAID arrays... 

No code goes into the Data schema. No tables live outside the Data schema. This can extended of course to have a Lookup or Staging schema if you wish. For views we use but this was to distinguish them from tables in SQL Server 2000 and it's kinda legacy now 

is implied by because means you need to see the table structure. So it can't be blocked. The same applies for = = anyway, which is the same. So no, it can't be done via MySQL Permissions if you want the developers to run queries 

The difference is that Enterprise edition without the hint may decide not to use the indexed view but the base tables instead. My personal experience is that SQL Server is somewhat braindead in this. I almost always have to use the hint: the query is quicker with far less IO even though the plan "looks" worse with a scan on the view not index seeks on the base tables. And it runs more consistently too YMMV of course :-) So, to answer, it will (should?) work the same based on what I've seen. Other folk may have different experiences and I'm interested in other answers To avoid using the hint everywhere you can wrap the indexed view in another view with the hint: hints propoagte inwards to all outer queries will automatically have NOEXPAND. 

"Loose" dependency is the right idea You seem to be thinking of "strict" vs "loose" or "direct" vs "direct or transitive" FDs where the explicitly given FDs are taken as the "strict"/"direct" ones. Such a notion of "transitivity" is only an artifact of how you chose to define the situation. The set of given FDs is only relevant in that their closure is relevant. The definition of 2NF refers to all partial FDs and all full FDs. What particular ones given to describe a bunch that hold is irrelevant. When certain sets of FDs are present, certain other FDs are too. They are all just present together. By definition they are the ones in the closure of the given ones. Re given FDs It is a common problem that people will just say "these FDs hold". Note that that means "all the FDs in their closure hold", because if the given ones hold, the closure's hold--by definition of the closure. But if they don't say that the ones in the closure are the only ones that hold then you are (in general) limited in what you can determine about the relation. So usually they really mean, the only ones are the ones in the closure of the given ones. Ie that the given ones form a cover for the ones that hold. Moreover if they say this in practice beware that they may not actually know that there aren't any other FDs than in the closure of the given ones, ie that they form a cover. Without knowing that there are no others it is possible to answer "what is the closure of these", but it may not be possible to answer "what are the CKs". Transitive vs non-transitve FDs The term "transitive" FD and "non-transitive" FD are defined and play a role in the definition of 3NF. (A non-transitive FD is one that's not transitive.) But they are not defined in terms of given FDs as "direct" either. FD (functional dependency) A-> C is transitive when there is an X where A -> X and X -> B and NOT X -> A. (Likely that last conjunct is unexpected.) Transitive FDs are those that hold as a consequence of all the FDs that hold, not just the ones given. Similarly the definition of 3NF refers to all transitive FDs and all FDs. (2NF plus every non-prime attribute non-transitively dependent on every candidate key gives 3NF.) There is no notion of "direct" FD except "non-transitive" FD.